{"sha": "9774b7e64b7ff8323b4f8160cc38eb793f447217", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NzRiN2U2NGI3ZmY4MzIzYjRmODE2MGNjMzhlYjc5M2Y0NDcyMTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T22:32:03Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T22:32:03Z"}, "message": "rollup merge of #22480: alexcrichton/hashv3\n\nThis commit is an implementation of [RFC 823][rfc] which is another pass over\nthe `std::hash` module for stabilization. The contents of the module were not\nentirely marked stable, but some portions which remained quite similar to the\nprevious incarnation are now marked `#[stable]`. Specifically:\n\n[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0823-hash-simplification.md\n\n* `std::hash` is now stable (the name)\n* `Hash` is now stable\n* `Hash::hash` is now stable\n* `Hasher` is now stable\n* `SipHasher` is now stable\n* `SipHasher::new` and `new_with_keys` are now stable\n* `Hasher for SipHasher` is now stable\n* Many `Hash` implementations are now stable\n\nAll other portions of the `hash` module remain `#[unstable]` as they are less\ncommonly used and were recently redesigned.\n\nThis commit is a breaking change due to the modifications to the `std::hash` API\nand more details can be found on the [RFC][rfc].\n\nCloses #22467\n[breaking-change]", "tree": {"sha": "5583e7a616f23fc144f56f10f65c51ab96d93001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5583e7a616f23fc144f56f10f65c51ab96d93001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9774b7e64b7ff8323b4f8160cc38eb793f447217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9774b7e64b7ff8323b4f8160cc38eb793f447217", "html_url": "https://github.com/rust-lang/rust/commit/9774b7e64b7ff8323b4f8160cc38eb793f447217", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9774b7e64b7ff8323b4f8160cc38eb793f447217/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "261364d45d6a90dbe1e6702455f7a6ea661e74c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/261364d45d6a90dbe1e6702455f7a6ea661e74c9", "html_url": "https://github.com/rust-lang/rust/commit/261364d45d6a90dbe1e6702455f7a6ea661e74c9"}, {"sha": "f83e23ad7c464c242c2d7ace7212d323980b2bca", "url": "https://api.github.com/repos/rust-lang/rust/commits/f83e23ad7c464c242c2d7ace7212d323980b2bca", "html_url": "https://github.com/rust-lang/rust/commit/f83e23ad7c464c242c2d7ace7212d323980b2bca"}], "stats": {"total": 5344, "additions": 4988, "deletions": 356}, "files": [{"sha": "343ede4e2cf45c66db451e8f42329ff02490c585", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -605,11 +605,19 @@ impl<T: Default + Sync + Send> Default for Arc<T> {\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n+#[cfg(stage0)]\n impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n     fn hash(&self, state: &mut H) {\n         (**self).hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash> Hash for Arc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state)\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "a3516bd667b7a18cb6e9f0653481511bc5f04779", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -10,13 +10,14 @@\n \n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of heap allocation in\n-//! Rust. Boxes provide ownership for this allocation, and drop their contents when they go out of\n-//! scope.\n+//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! heap allocation in Rust. Boxes provide ownership for this allocation, and\n+//! drop their contents when they go out of scope.\n //!\n-//! Boxes are useful in two situations: recursive data structures, and occasionally when returning\n-//! data. [The Pointer chapter of the Book](../../../book/pointers.html#best-practices-1) explains\n-//! these cases in detail.\n+//! Boxes are useful in two situations: recursive data structures, and\n+//! occasionally when returning data. [The Pointer chapter of the\n+//! Book](../../../book/pointers.html#best-practices-1) explains these cases in\n+//! detail.\n //!\n //! # Examples\n //!\n@@ -58,8 +59,8 @@ use core::ops::{Deref, DerefMut};\n use core::ptr::Unique;\n use core::raw::TraitObject;\n \n-/// A value that represents the heap. This is the default place that the `box` keyword allocates\n-/// into when no place is supplied.\n+/// A value that represents the heap. This is the default place that the `box`\n+/// keyword allocates into when no place is supplied.\n ///\n /// The following two examples are equivalent:\n ///\n@@ -219,12 +220,20 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n+#[cfg(stage0)]\n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: ?Sized + Hash> Hash for Box<T> {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n /// Extension methods for an owning `Any` trait object.\n #[unstable(feature = \"alloc\","}, {"sha": "bc349ebebdeed0a317a30943c9aefa6142a096ff", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -73,7 +73,6 @@\n #![feature(unboxed_closures)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n-#![feature(hash)]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]\n "}, {"sha": "65513465dd2a92a586b063960956ae5863121e4a", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -150,7 +150,7 @@ use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n use core::fmt;\n-use core::hash::{self, Hash};\n+use core::hash::{Hasher, Hash};\n use core::marker;\n use core::mem::{transmute, min_align_of, size_of, forget};\n use core::nonzero::NonZero;\n@@ -599,12 +599,20 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n-impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n+#[cfg(stage0)]\n+impl<S: Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: Hash> Hash for Rc<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display> fmt::Display for Rc<T> {"}, {"sha": "6c152f366fdb287ca4a275231ae385071a758e55", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -984,6 +984,7 @@ impl fmt::Debug for Bitv {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n@@ -992,6 +993,16 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl hash::Hash for Bitv {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.nbits.hash(state);\n+        for elem in self.blocks() {\n+            elem.hash(state);\n+        }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl cmp::PartialEq for Bitv {\n@@ -1756,13 +1767,23 @@ impl fmt::Debug for BitvSet {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n     fn hash(&self, state: &mut S) {\n         for pos in self {\n             pos.hash(state);\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl hash::Hash for BitvSet {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        for pos in self {\n+            pos.hash(state);\n+        }\n+    }\n+}\n \n /// An iterator for `BitvSet`.\n #[derive(Clone)]"}, {"sha": "73d2af28a046aebd838838074a02ebccda6d656c", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -843,6 +843,7 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n@@ -851,6 +852,15 @@ impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K: Hash, V: Hash> Hash for BTreeMap<K, V> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        for elt in self {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, V> Default for BTreeMap<K, V> {"}, {"sha": "3734bfad28ffbcfbce2b1eb4a5ff32a766159c2e", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -27,7 +27,9 @@ use alloc::boxed::Box;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Writer, Hasher, Hash};\n+use core::hash::{Hasher, Hash};\n+#[cfg(stage0)]\n+use core::hash::Writer;\n use core::iter::{self, FromIterator, IntoIterator};\n use core::mem;\n use core::ptr;\n@@ -926,6 +928,7 @@ impl<A: fmt::Debug> fmt::Debug for DList<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -934,6 +937,16 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<A: Hash> Hash for DList<A> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.len().hash(state);\n+        for elt in self {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "06f7e825a1466429cb3af4efe128f4e6ecabf2bb", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -26,7 +26,6 @@\n #![feature(box_syntax)]\n #![feature(box_patterns)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]"}, {"sha": "c241b096b39d1e1025a7907151f36bdd88aea10f", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -31,7 +31,8 @@ use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::raw::Slice as RawSlice;\n \n-use core::hash::{Writer, Hash, Hasher};\n+use core::hash::{Hash, Hasher};\n+#[cfg(stage0)] use core::hash::Writer;\n use core::cmp;\n \n use alloc::heap;\n@@ -1667,6 +1668,7 @@ impl<A: Ord> Ord for RingBuf<A> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(stage0)]\n impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n@@ -1675,6 +1677,16 @@ impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n         }\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<A: Hash> Hash for RingBuf<A> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.len().hash(state);\n+        for elt in self {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Index<usize> for RingBuf<A> {"}, {"sha": "6204c4427b5163f6f4cfb6a14e2c7c514568d127", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -833,12 +833,21 @@ impl fmt::Debug for String {\n }\n \n #[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n+#[cfg(stage0)]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl hash::Hash for String {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, hasher: &mut H) {\n+        (**self).hash(hasher)\n+    }\n+}\n \n #[unstable(feature = \"collections\",\n            reason = \"recent addition, needs more experience\")]"}, {"sha": "203a3381c79af4d66d3c16cce69cd092b8e5da99", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -1303,12 +1303,21 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         Hash::hash(&**self, state)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<T: Hash> Hash for Vec<T> {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        Hash::hash(&**self, state)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Index<usize> for Vec<T> {"}, {"sha": "c271cb052abd625d40e86efb30394c0ba1f874a3", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -20,7 +20,8 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Hash, Writer, Hasher};\n+use core::hash::{Hash, Hasher};\n+#[cfg(stage0)] use core::hash::Writer;\n use core::iter::{Enumerate, FilterMap, Map, FromIterator, IntoIterator};\n use core::iter;\n use core::mem::replace;\n@@ -99,6 +100,7 @@ impl<V> Default for VecMap<V> {\n     fn default() -> VecMap<V> { VecMap::new() }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V:Clone> Clone for VecMap<V> {\n     #[inline]\n     fn clone(&self) -> VecMap<V> {\n@@ -111,6 +113,7 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n         // In order to not traverse the `VecMap` twice, count the elements\n@@ -123,6 +126,20 @@ impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n         count.hash(state);\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg(not(stage0))]\n+impl<V: Hash> Hash for VecMap<V> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        // In order to not traverse the `VecMap` twice, count the elements\n+        // during iteration.\n+        let mut count: usize = 0;\n+        for elt in self {\n+            elt.hash(state);\n+            count += 1;\n+        }\n+        count.hash(state);\n+    }\n+}\n \n impl<V> VecMap<V> {\n     /// Creates an empty `VecMap`."}, {"sha": "b2bb5ee7999d8fac3d7b73eca36f36c62625aabf", "filename": "src/libcore/array.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -17,7 +17,7 @@\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n-use hash::{Hash, Hasher, self};\n+use hash::{Hash, self};\n use iter::IntoIterator;\n use marker::Copy;\n use ops::Deref;\n@@ -35,11 +35,19 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            impl<S: hash::Writer + Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n+            #[cfg(stage0)]\n+            impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for [T; $N] {\n                 fn hash(&self, state: &mut S) {\n                     Hash::hash(&self[], state)\n                 }\n             }\n+            #[cfg(not(stage0))]\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<T: Hash> Hash for [T; $N] {\n+                fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+                    Hash::hash(&self[], state)\n+                }\n+            }\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             impl<T: fmt::Debug> fmt::Debug for [T; $N] {"}, {"sha": "b9a5122dd9c00ecaad777d3f8c5e3268c72e6941", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 378, "deletions": 116, "changes": 494, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -35,16 +35,16 @@\n //! the trait `Hash`:\n //!\n //! ```rust\n-//! use std::hash::{hash, Hash, Hasher, Writer, SipHasher};\n+//! use std::hash::{hash, Hash, Hasher, SipHasher};\n //!\n //! struct Person {\n //!     id: uint,\n //!     name: String,\n //!     phone: u64,\n //! }\n //!\n-//! impl<H: Hasher + Writer> Hash<H> for Person {\n-//!     fn hash(&self, state: &mut H) {\n+//! impl Hash for Person {\n+//!     fn hash<H: Hasher>(&self, state: &mut H) {\n //!         self.id.hash(state);\n //!         self.phone.hash(state);\n //!     }\n@@ -56,15 +56,11 @@\n //! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![unstable(feature = \"hash\",\n-            reason = \"module was recently redesigned\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use prelude::*;\n-\n-use borrow::{Cow, ToOwned};\n use default::Default;\n+use marker::Sized;\n use mem;\n-use num::Int;\n \n pub use self::sip::SipHasher;\n \n@@ -76,29 +72,131 @@ mod sip;\n /// to compute the hash. Specific implementations of this trait may specialize\n /// for particular instances of `H` in order to be able to optimize the hashing\n /// behavior.\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Hash {\n+    /// Feeds this value into the state given, updating the hasher as necessary.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn hash<H: Hasher>(&self, state: &mut H);\n+\n+    /// Feeds a slice of this type into the state provided.\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n+        for piece in data {\n+            piece.hash(state);\n+        }\n+    }\n+}\n+\n+/// A hashable type.\n+///\n+/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n+/// to compute the hash. Specific implementations of this trait may specialize\n+/// for particular instances of `H` in order to be able to optimize the hashing\n+/// behavior.\n+#[cfg(stage0)]\n pub trait Hash<H: Hasher> {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n     fn hash(&self, state: &mut H);\n }\n \n /// A trait which represents the ability to hash an arbitrary stream of bytes.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n     /// Result type of one run of hashing generated by this hasher.\n+    #[cfg(stage0)]\n     type Output;\n \n     /// Resets this hasher back to its initial state (as if it were just\n     /// created).\n+    #[cfg(stage0)]\n     fn reset(&mut self);\n \n     /// Completes a round of hashing, producing the output hash generated.\n+    #[cfg(stage0)]\n     fn finish(&self) -> Self::Output;\n+\n+    /// Completes a round of hashing, producing the output hash generated.\n+    #[cfg(not(stage0))]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn finish(&self) -> u64;\n+\n+    /// Writes some data into this `Hasher`\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn write(&mut self, bytes: &[u8]);\n+\n+    /// Write a single `u8` into this hasher\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n+    /// Write a single `u16` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u16(&mut self, i: u16) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 2]>(i) })\n+    }\n+    /// Write a single `u32` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u32(&mut self, i: u32) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 4]>(i) })\n+    }\n+    /// Write a single `u64` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_u64(&mut self, i: u64) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n+    }\n+    /// Write a single `usize` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_usize(&mut self, i: usize) {\n+        if cfg!(target_pointer_size = \"32\") {\n+            self.write_u32(i as u32)\n+        } else {\n+            self.write_u64(i as u64)\n+        }\n+    }\n+\n+    /// Write a single `i8` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n+    /// Write a single `i16` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n+    /// Write a single `i32` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n+    /// Write a single `i64` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n+    /// Write a single `isize` into this hasher.\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    #[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+    fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n }\n \n /// A common bound on the `Hasher` parameter to `Hash` implementations in order\n /// to generically hash an aggregate.\n #[unstable(feature = \"hash\",\n            reason = \"this trait will likely be replaced by io::Writer\")]\n #[allow(missing_docs)]\n+#[cfg(stage0)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);\n }\n@@ -107,148 +205,312 @@ pub trait Writer {\n ///\n /// The specified value will be hashed with this hasher and then the resulting\n /// hash will be returned.\n+#[cfg(stage0)]\n pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n     let mut h: H = Default::default();\n     value.hash(&mut h);\n     h.finish()\n }\n \n+/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n+///\n+/// The specified value will be hashed with this hasher and then the resulting\n+/// hash will be returned.\n+#[cfg(not(stage0))]\n+#[unstable(feature = \"hash\", reason = \"module was recently redesigned\")]\n+pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n+    let mut h: H = Default::default();\n+    value.hash(&mut h);\n+    h.finish()\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n-macro_rules! impl_hash {\n-    ($ty:ident, $uty:ident) => {\n-        impl<S: Writer + Hasher> Hash<S> for $ty {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                let a: [u8; ::$ty::BYTES] = unsafe {\n-                    mem::transmute((*self as $uty).to_le() as $ty)\n-                };\n-                state.write(&a)\n+#[cfg(stage0)]\n+mod impls {\n+    use prelude::*;\n+\n+    use borrow::{Cow, ToOwned};\n+    use mem;\n+    use num::Int;\n+    use super::*;\n+\n+    macro_rules! impl_hash {\n+        ($ty:ident, $uty:ident) => {\n+            impl<S: Writer + Hasher> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    let a: [u8; ::$ty::BYTES] = unsafe {\n+                        mem::transmute((*self as $uty).to_le() as $ty)\n+                    };\n+                    state.write(&a)\n+                }\n             }\n         }\n     }\n-}\n \n-impl_hash! { u8, u8 }\n-impl_hash! { u16, u16 }\n-impl_hash! { u32, u32 }\n-impl_hash! { u64, u64 }\n-impl_hash! { uint, uint }\n-impl_hash! { i8, u8 }\n-impl_hash! { i16, u16 }\n-impl_hash! { i32, u32 }\n-impl_hash! { i64, u64 }\n-impl_hash! { int, uint }\n-\n-impl<S: Writer + Hasher> Hash<S> for bool {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u8).hash(state);\n+    impl_hash! { u8, u8 }\n+    impl_hash! { u16, u16 }\n+    impl_hash! { u32, u32 }\n+    impl_hash! { u64, u64 }\n+    impl_hash! { uint, uint }\n+    impl_hash! { i8, u8 }\n+    impl_hash! { i16, u16 }\n+    impl_hash! { i32, u32 }\n+    impl_hash! { i64, u64 }\n+    impl_hash! { int, uint }\n+\n+    impl<S: Writer + Hasher> Hash<S> for bool {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u8).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer + Hasher> Hash<S> for char {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u32).hash(state);\n+    impl<S: Writer + Hasher> Hash<S> for char {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u32).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer + Hasher> Hash<S> for str {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(self.as_bytes());\n-        0xffu8.hash(state)\n+    impl<S: Writer + Hasher> Hash<S> for str {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            state.write(self.as_bytes());\n+            0xffu8.hash(state)\n+        }\n     }\n-}\n \n-macro_rules! impl_hash_tuple {\n-    () => (\n-        impl<S: Hasher> Hash<S> for () {\n-            #[inline]\n-            fn hash(&self, _state: &mut S) {}\n-        }\n-    );\n-\n-    ( $($name:ident)+) => (\n-        impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn hash(&self, state: &mut S) {\n-                match *self {\n-                    ($(ref $name,)*) => {\n-                        $(\n-                            $name.hash(state);\n-                        )*\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            impl<S: Hasher> Hash<S> for () {\n+                #[inline]\n+                fn hash(&self, _state: &mut S) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+                #[inline]\n+                #[allow(non_snake_case)]\n+                fn hash(&self, state: &mut S) {\n+                    match *self {\n+                        ($(ref $name,)*) => {\n+                            $(\n+                                $name.hash(state);\n+                            )*\n+                        }\n                     }\n                 }\n             }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.len().hash(state);\n+            for elt in self {\n+                elt.hash(state);\n+            }\n         }\n-    );\n-}\n+    }\n \n-impl_hash_tuple! {}\n-impl_hash_tuple! { A }\n-impl_hash_tuple! { A B }\n-impl_hash_tuple! { A B C }\n-impl_hash_tuple! { A B C D }\n-impl_hash_tuple! { A B C D E }\n-impl_hash_tuple! { A B C D E F }\n-impl_hash_tuple! { A B C D E F G }\n-impl_hash_tuple! { A B C D E F G H }\n-impl_hash_tuple! { A B C D E F G H I }\n-impl_hash_tuple! { A B C D E F G H I J }\n-impl_hash_tuple! { A B C D E F G H I J K }\n-impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self {\n-            elt.hash(state);\n+\n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n         }\n     }\n-}\n \n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n+    }\n \n-impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer + Hasher, T> Hash<S> for *const T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+    impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n+        where B: Hash<S> + ToOwned<T>\n+    {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            Hash::hash(&**self, state)\n+        }\n     }\n }\n \n-impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+#[cfg(not(stage0))]\n+mod impls {\n+    use prelude::*;\n+\n+    use borrow::{Cow, ToOwned};\n+    use slice;\n+    use super::*;\n+\n+    macro_rules! impl_write {\n+        ($(($ty:ident, $meth:ident),)*) => {$(\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl Hash for $ty {\n+                fn hash<H: Hasher>(&self, state: &mut H) {\n+                    state.$meth(*self)\n+                }\n+\n+                fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                    let newlen = data.len() * ::$ty::BYTES;\n+                    let ptr = data.as_ptr() as *const u8;\n+                    state.write(unsafe { slice::from_raw_parts(ptr, newlen) })\n+                }\n+            }\n+        )*}\n     }\n-}\n \n-impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n-    where B: Hash<S> + ToOwned<T>\n-{\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n+    impl_write! {\n+        (u8, write_u8),\n+        (u16, write_u16),\n+        (u32, write_u32),\n+        (u64, write_u64),\n+        (usize, write_usize),\n+        (i8, write_i8),\n+        (i16, write_i16),\n+        (i32, write_i32),\n+        (i64, write_i64),\n+        (isize, write_isize),\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for bool {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_u8(*self as u8)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for char {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_u32(*self as u32)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for str {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write(self.as_bytes());\n+            state.write_u8(0xff)\n+        }\n+    }\n+\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl Hash for () {\n+                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($name: Hash),*> Hash for ($($name,)*) {\n+                #[allow(non_snake_case)]\n+                fn hash<S: Hasher>(&self, state: &mut S) {\n+                    let ($(ref $name,)*) = *self;\n+                    $($name.hash(state);)*\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: Hash> Hash for [T] {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            self.len().hash(state);\n+            Hash::hash_slice(self, state)\n+        }\n+    }\n+\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized + Hash> Hash for &'a T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized + Hash> Hash for &'a mut T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T> Hash for *const T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_usize(*self as usize)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T> Hash for *mut T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_usize(*self as usize)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T, B: ?Sized> Hash for Cow<'a, T, B>\n+        where B: Hash + ToOwned<T>\n+    {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            Hash::hash(&**self, state)\n+        }\n     }\n }"}, {"sha": "ce8917cc20589a93b0edddccc6ede9ed5fe7e329", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -15,7 +15,9 @@\n use prelude::*;\n use default::Default;\n \n-use super::{Hasher, Writer};\n+use super::Hasher;\n+#[cfg(stage0)]\n+use super::Writer;\n \n /// An implementation of SipHash 2-4.\n ///\n@@ -30,6 +32,7 @@ use super::{Hasher, Writer};\n /// strong, this implementation has not been reviewed for such purposes.\n /// As such, all cryptographic uses of this implementation are strongly\n /// discouraged.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n@@ -88,12 +91,14 @@ macro_rules! compress {\n impl SipHasher {\n     /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> SipHasher {\n         SipHasher::new_with_keys(0, 0)\n     }\n \n     /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n         let mut state = SipHasher {\n             k0: key0,\n@@ -114,10 +119,16 @@ impl SipHasher {\n     #[unstable(feature = \"hash\")]\n     #[deprecated(since = \"1.0.0\", reason = \"renamed to finish\")]\n     pub fn result(&self) -> u64 { self.finish() }\n-}\n \n-impl Writer for SipHasher {\n-    #[inline]\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n+    }\n+\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n         self.length += length;\n@@ -164,16 +175,28 @@ impl Writer for SipHasher {\n     }\n }\n \n+#[cfg(stage0)]\n+impl Writer for SipHasher {\n+    #[inline]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.write(msg)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Hasher for SipHasher {\n+    #[cfg(stage0)]\n     type Output = u64;\n \n+    #[cfg(stage0)]\n     fn reset(&mut self) {\n-        self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n+        self.reset();\n+    }\n+\n+    #[inline]\n+    #[cfg(not(stage0))]\n+    fn write(&mut self, msg: &[u8]) {\n+        self.write(msg)\n     }\n \n     fn finish(&self) -> u64 {\n@@ -199,6 +222,7 @@ impl Hasher for SipHasher {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Clone for SipHasher {\n     #[inline]\n     fn clone(&self) -> SipHasher {\n@@ -216,6 +240,7 @@ impl Clone for SipHasher {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Default for SipHasher {\n     fn default() -> SipHasher {\n         SipHasher::new()"}, {"sha": "11e5e6f334f13c8e21615248392f3f5b02f93730", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n-use std::hash::{Hash, Hasher, Writer};\n+use std::hash::{Hash, Hasher};\n use std::default::Default;\n \n struct MyHasher {\n@@ -22,25 +22,20 @@ impl Default for MyHasher {\n     }\n }\n \n-impl Writer for MyHasher {\n-    // Most things we'll just add up the bytes.\n+impl Hasher for MyHasher {\n+    type Output = u64;\n     fn write(&mut self, buf: &[u8]) {\n         for byte in buf {\n             self.hash += *byte as u64;\n         }\n     }\n-}\n-\n-impl Hasher for MyHasher {\n-    type Output = u64;\n-    fn reset(&mut self) { self.hash = 0; }\n     fn finish(&self) -> u64 { self.hash }\n }\n \n \n #[test]\n fn test_writer_hasher() {\n-    fn hash<T: Hash<MyHasher>>(t: &T) -> u64 {\n+    fn hash<T: Hash>(t: &T) -> u64 {\n         ::std::hash::hash::<_, MyHasher>(t)\n     }\n \n@@ -91,8 +86,9 @@ struct CustomHasher { output: u64 }\n \n impl Hasher for CustomHasher {\n     type Output = u64;\n-    fn reset(&mut self) { self.output = 0; }\n     fn finish(&self) -> u64 { self.output }\n+    fn write(&mut self, data: &[u8]) { panic!() }\n+    fn write_u64(&mut self, data: u64) { self.output = data; }\n }\n \n impl Default for CustomHasher {\n@@ -101,15 +97,15 @@ impl Default for CustomHasher {\n     }\n }\n \n-impl Hash<CustomHasher> for Custom {\n-    fn hash(&self, state: &mut CustomHasher) {\n-        state.output = self.hash;\n+impl Hash for Custom {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        state.write_u64(self.hash);\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    fn hash<T: Hash<CustomHasher>>(t: &T) -> u64 {\n+    fn hash<T: Hash>(t: &T) -> u64 {\n         ::std::hash::hash::<_, CustomHasher>(t)\n     }\n "}, {"sha": "bdcc10ebceca061899bf93a64540a42c37de4253", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -185,12 +185,20 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n         let ptr = self.lint as *const Lint;\n         ptr.hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl hash::Hash for LintId {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        let ptr = self.lint as *const Lint;\n+        ptr.hash(state);\n+    }\n+}\n \n impl LintId {\n     /// Get the `LintId` for a `Lint`."}, {"sha": "06c6f0c11834629efc797a773d950b990dd9d2ee", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -1588,6 +1588,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n // Path and definition ID indexing\n \n+#[cfg(stage0)]\n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n     F: FnMut(&mut SeekableMemWriter, &T),\n     T: Hash<SipHasher>,\n@@ -1628,6 +1629,47 @@ fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn:\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n+#[cfg(not(stage0))]\n+fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n+    F: FnMut(&mut SeekableMemWriter, &T),\n+    T: Hash,\n+{\n+    let mut buckets: Vec<Vec<entry<T>>> = (0..256u16).map(|_| Vec::new()).collect();\n+    for elt in index {\n+        let mut s = SipHasher::new();\n+        elt.val.hash(&mut s);\n+        let h = s.finish() as uint;\n+        (&mut buckets[h % 256]).push(elt);\n+    }\n+\n+    rbml_w.start_tag(tag_index);\n+    let mut bucket_locs = Vec::new();\n+    rbml_w.start_tag(tag_index_buckets);\n+    for bucket in &buckets {\n+        bucket_locs.push(rbml_w.writer.tell().unwrap());\n+        rbml_w.start_tag(tag_index_buckets_bucket);\n+        for elt in bucket {\n+            rbml_w.start_tag(tag_index_buckets_bucket_elt);\n+            assert!(elt.pos < 0xffff_ffff);\n+            {\n+                let wr: &mut SeekableMemWriter = rbml_w.writer;\n+                wr.write_be_u32(elt.pos as u32);\n+            }\n+            write_fn(rbml_w.writer, &elt.val);\n+            rbml_w.end_tag();\n+        }\n+        rbml_w.end_tag();\n+    }\n+    rbml_w.end_tag();\n+    rbml_w.start_tag(tag_index_table);\n+    for pos in &bucket_locs {\n+        assert!(*pos < 0xffff_ffff);\n+        let wr: &mut SeekableMemWriter = rbml_w.writer;\n+        wr.write_be_u32(*pos as u32);\n+    }\n+    rbml_w.end_tag();\n+    rbml_w.end_tag();\n+}\n \n fn write_i64(writer: &mut SeekableMemWriter, &n: &i64) {\n     let wr: &mut SeekableMemWriter = writer;"}, {"sha": "f70c5554c6ee9010b2e09e1f606cc9bc76e7232b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -72,7 +72,8 @@ use std::borrow::{BorrowFrom, Cow};\n use std::cell::{Cell, RefCell};\n use std::cmp;\n use std::fmt;\n-use std::hash::{Hash, Writer, SipHasher, Hasher};\n+use std::hash::{Hash, SipHasher, Hasher};\n+#[cfg(stage0)] use std::hash::Writer;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -958,11 +959,18 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n+#[cfg(stage0)]\n impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n     fn hash(&self, s: &mut S) {\n         (self as *const _).hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx> Hash for TyS<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        (self as *const _).hash(s)\n+    }\n+}\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n@@ -980,11 +988,18 @@ impl<'tcx> PartialEq for InternedTy<'tcx> {\n \n impl<'tcx> Eq for InternedTy<'tcx> {}\n \n+#[cfg(stage0)]\n impl<'tcx, S: Writer + Hasher> Hash<S> for InternedTy<'tcx> {\n     fn hash(&self, s: &mut S) {\n         self.ty.sty.hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx> Hash for InternedTy<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        self.ty.sty.hash(s)\n+    }\n+}\n \n impl<'tcx> BorrowFrom<InternedTy<'tcx>> for sty<'tcx> {\n     fn borrow_from<'a>(ty: &'a InternedTy<'tcx>) -> &'a sty<'tcx> {"}, {"sha": "c9d50b9cecf84ff005f033b439c589b5202a61fa", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 91, "deletions": 2, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -13,7 +13,8 @@\n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n use std::fmt::Debug;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+#[cfg(stage0)] use std::hash::Hasher;\n use std::iter::repeat;\n use std::time::Duration;\n use std::collections::hash_state::HashState;\n@@ -144,11 +145,54 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n /// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n /// very small graphs. If the graphs become larger, a more efficient graph representation and\n /// algorithm would probably be advised.\n+#[cfg(stage0)]\n pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n                        destination: T) -> bool\n     where S: HashState,\n           <S as HashState>::Hasher: Hasher<Output=u64>,\n-          T: Hash< <S as HashState>::Hasher> + Eq + Clone,\n+          T: Hash<<S as HashState>::Hasher> + Eq + Clone,\n+{\n+    if source == destination {\n+        return true;\n+    }\n+\n+    // Do a little breadth-first-search here.  The `queue` list\n+    // doubles as a way to detect if we've seen a particular FR\n+    // before.  Note that we expect this graph to be an *extremely\n+    // shallow* tree.\n+    let mut queue = vec!(source);\n+    let mut i = 0;\n+    while i < queue.len() {\n+        match edges_map.get(&queue[i]) {\n+            Some(edges) => {\n+                for target in edges {\n+                    if *target == destination {\n+                        return true;\n+                    }\n+\n+                    if !queue.iter().any(|x| x == target) {\n+                        queue.push((*target).clone());\n+                    }\n+                }\n+            }\n+            None => {}\n+        }\n+        i += 1;\n+    }\n+    return false;\n+}\n+/// K: Eq + Hash<S>, V, S, H: Hasher<S>\n+///\n+/// Determines whether there exists a path from `source` to `destination`.  The graph is defined by\n+/// the `edges_map`, which maps from a node `S` to a list of its adjacent nodes `T`.\n+///\n+/// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n+/// very small graphs. If the graphs become larger, a more efficient graph representation and\n+/// algorithm would probably be advised.\n+#[cfg(not(stage0))]\n+pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n+                       destination: T) -> bool\n+    where S: HashState, T: Hash + Eq + Clone,\n {\n     if source == destination {\n         return true;\n@@ -206,6 +250,7 @@ pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n /// }\n /// ```\n #[inline(always)]\n+#[cfg(stage0)]\n pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n     where T: Clone + Hash<<S as HashState>::Hasher> + Eq,\n           U: Clone,\n@@ -224,3 +269,47 @@ pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) ->\n         }\n     }\n }\n+/// Memoizes a one-argument closure using the given RefCell containing\n+/// a type implementing MutableMap to serve as a cache.\n+///\n+/// In the future the signature of this function is expected to be:\n+/// ```\n+/// pub fn memoized<T: Clone, U: Clone, M: MutableMap<T, U>>(\n+///    cache: &RefCell<M>,\n+///    f: &|T| -> U\n+/// ) -> impl |T| -> U {\n+/// ```\n+/// but currently it is not possible.\n+///\n+/// # Example\n+/// ```\n+/// struct Context {\n+///    cache: RefCell<HashMap<uint, uint>>\n+/// }\n+///\n+/// fn factorial(ctxt: &Context, n: uint) -> uint {\n+///     memoized(&ctxt.cache, n, |n| match n {\n+///         0 | 1 => n,\n+///         _ => factorial(ctxt, n - 2) + factorial(ctxt, n - 1)\n+///     })\n+/// }\n+/// ```\n+#[inline(always)]\n+#[cfg(not(stage0))]\n+pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n+    where T: Clone + Hash + Eq,\n+          U: Clone,\n+          S: HashState,\n+          F: FnOnce(T) -> U,\n+{\n+    let key = arg.clone();\n+    let result = cache.borrow().get(&key).map(|result| result.clone());\n+    match result {\n+        Some(result) => result,\n+        None => {\n+            let result = f(arg);\n+            cache.borrow_mut().insert(key, result.clone());\n+            result\n+        }\n+    }\n+}"}, {"sha": "1b07ce789e77c8e7713c3ff2f2831fde021fc818", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -15,7 +15,8 @@\n use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n-use std::hash::{Hasher, Writer, Hash};\n+use std::hash::{Hasher, Hash};\n+#[cfg(stage0)] use std::hash::Writer;\n use syntax::ast;\n \n pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n@@ -27,12 +28,22 @@ pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n pub type NodeSet = FnvHashSet<ast::NodeId>;\n pub type DefIdSet = FnvHashSet<ast::DefId>;\n \n+#[cfg(stage0)]\n pub fn FnvHashMap<K: Hash<FnvHasher> + Eq, V>() -> FnvHashMap<K, V> {\n     Default::default()\n }\n+#[cfg(stage0)]\n pub fn FnvHashSet<V: Hash<FnvHasher> + Eq>() -> FnvHashSet<V> {\n     Default::default()\n }\n+#[cfg(not(stage0))]\n+pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n+    Default::default()\n+}\n+#[cfg(not(stage0))]\n+pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n+    Default::default()\n+}\n \n pub fn NodeMap<T>() -> NodeMap<T> { FnvHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FnvHashMap() }\n@@ -52,12 +63,14 @@ impl Default for FnvHasher {\n     fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n }\n \n+#[cfg(stage0)]\n impl Hasher for FnvHasher {\n     type Output = u64;\n     fn reset(&mut self) { *self = Default::default(); }\n     fn finish(&self) -> u64 { self.0 }\n }\n \n+#[cfg(stage0)]\n impl Writer for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n         let FnvHasher(mut hash) = *self;\n@@ -68,3 +81,16 @@ impl Writer for FnvHasher {\n         *self = FnvHasher(hash);\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl Hasher for FnvHasher {\n+    fn write(&mut self, bytes: &[u8]) {\n+        let FnvHasher(mut hash) = *self;\n+        for byte in bytes {\n+            hash = hash ^ (*byte as u64);\n+            hash = hash * 0x100000001b3;\n+        }\n+        *self = FnvHasher(hash);\n+    }\n+    fn finish(&self) -> u64 { self.0 }\n+}"}, {"sha": "f00dd7b0fdf24869d5387656a119bf16b8e4e942", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -28,7 +28,8 @@ use middle::ty_fold::TypeFoldable;\n \n use std::collections::HashMap;\n use std::collections::hash_state::HashState;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+#[cfg(stage0)] use std::hash::Hasher;\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -1433,6 +1434,7 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n     where K: Hash<<S as HashState>::Hasher> + Eq + Repr<'tcx>,\n           V: Repr<'tcx>,\n@@ -1448,6 +1450,21 @@ impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n+    where K: Hash + Eq + Repr<'tcx>,\n+          V: Repr<'tcx>,\n+          S: HashState,\n+{\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"HashMap({})\",\n+                self.iter()\n+                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n+                    .collect::<Vec<String>>()\n+                    .connect(\", \"))\n+    }\n+}\n+\n impl<'tcx, T, U> Repr<'tcx> for ty::OutlivesPredicate<T,U>\n     where T : Repr<'tcx> + TypeFoldable<'tcx>,\n           U : Repr<'tcx> + TypeFoldable<'tcx>,"}, {"sha": "b7cfda280925701495074fcb68d1955b03b3a058", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -20,7 +20,6 @@\n #![allow(non_camel_case_types)]\n \n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "21320a987adf7e08be8726a9d6deec9b232b9932", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -25,7 +25,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(libc)]\n #![feature(link_args)]"}, {"sha": "d220b496863fdc360f04ef05d2e6883280f0209b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -20,7 +20,6 @@\n #![feature(alloc)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]"}, {"sha": "3deca436a1f903be1c63edf3aaed4cfe1639fc79", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -28,7 +28,6 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(env)]"}, {"sha": "f9e0948d7bc8a0ee6d707bb349d71d3592bf32f4", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -23,7 +23,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(env)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(libc)]"}, {"sha": "7176ad7f88da3a454217e0d519a28d32bea6d2e9", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -12,7 +12,8 @@\n \n use std::usize;\n use std::default::Default;\n-use std::hash::{Hash, Hasher};\n+use std::hash::Hash;\n+#[cfg(stage0)] use std::hash::Hasher;\n use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n@@ -157,6 +158,7 @@ impl<\n     }\n }\n \n+#[cfg(stage0)]\n impl<K, V, S> Encodable for HashMap<K, V, S>\n     where K: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n           V: Encodable,\n@@ -175,7 +177,26 @@ impl<K, V, S> Encodable for HashMap<K, V, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<K, V, S> Encodable for HashMap<K, V, S>\n+    where K: Encodable + Hash + Eq,\n+          V: Encodable,\n+          S: HashState,\n+{\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self {\n+                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<K, V, S> Decodable for HashMap<K, V, S>\n     where K: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n           V: Decodable,\n@@ -195,7 +216,27 @@ impl<K, V, S> Decodable for HashMap<K, V, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<K, V, S> Decodable for HashMap<K, V, S>\n+    where K: Decodable + Hash + Eq,\n+          V: Decodable,\n+          S: HashState + Default,\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n+        d.read_map(|d, len| {\n+            let state = Default::default();\n+            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n+            for i in 0..len {\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n+                map.insert(key, val);\n+            }\n+            Ok(map)\n+        })\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<T, S> Encodable for HashSet<T, S>\n     where T: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n           S: HashState,\n@@ -212,7 +253,24 @@ impl<T, S> Encodable for HashSet<T, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T, S> Encodable for HashSet<T, S>\n+    where T: Encodable + Hash + Eq,\n+          S: HashState,\n+{\n+    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self {\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n+                i += 1;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<T, S> Decodable for HashSet<T, S>\n     where T: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n           S: HashState + Default,\n@@ -229,6 +287,22 @@ impl<T, S> Decodable for HashSet<T, S>\n         })\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T, S> Decodable for HashSet<T, S>\n+    where T: Decodable + Hash + Eq,\n+          S: HashState + Default,\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let state = Default::default();\n+            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n+            for i in 0..len {\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(set)\n+        })\n+    }\n+}\n \n impl<V: Encodable> Encodable for VecMap<V> {\n     fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {"}, {"sha": "d476fd72abc3b03ea2f8cc8b729f8182fa78fad6", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -31,7 +31,6 @@ Core encoding and decoding interfaces.\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(old_path)]\n-#![feature(hash)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "f04bbbb1f4dc9d0fc4625c68293566cf65847f61", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 43, "deletions": 85, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -19,7 +19,7 @@ use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Debug};\n-use hash::{self, Hash, SipHasher};\n+use hash::{Hash, SipHasher};\n use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n@@ -440,28 +440,26 @@ impl<K, V, M> SearchResult<K, V, M> {\n     }\n }\n \n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n-    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash {\n         table::make_hash(&self.hash_state, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<H>\n+        where Q: BorrowFrom<K> + Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<H>\n+        where Q: BorrowFrom<K> + Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n@@ -490,7 +488,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n }\n \n-impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n+impl<K: Hash + Eq, V> HashMap<K, V, RandomState> {\n     /// Create an empty HashMap.\n     ///\n     /// # Example\n@@ -520,10 +518,8 @@ impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     }\n }\n \n-impl<K, V, S, H> HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n@@ -1037,7 +1033,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where Q: Hash + Eq + BorrowFrom<K>\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n@@ -1060,7 +1056,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where Q: Hash + Eq + BorrowFrom<K>\n     {\n         self.search(k).is_some()\n     }\n@@ -1086,7 +1082,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where Q: Hash + Eq + BorrowFrom<K>\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1138,7 +1134,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where Q: Hash + Eq + BorrowFrom<K>\n     {\n         if self.table.size() == 0 {\n             return None\n@@ -1195,10 +1191,8 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n     }\n }\n \n-impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: PartialEq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> PartialEq for HashMap<K, V, S>\n+    where K: Eq + Hash, V: PartialEq, S: HashState\n {\n     fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -1210,17 +1204,13 @@ impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Eq for HashMap<K, V, S>\n-    where K: Eq + Hash<H>, V: Eq,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Eq for HashMap<K, V, S>\n+    where K: Eq + Hash, V: Eq, S: HashState\n {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Debug for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Debug, V: Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Debug for HashMap<K, V, S>\n+    where K: Eq + Hash + Debug, V: Debug, S: HashState\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashMap {{\"));\n@@ -1235,22 +1225,20 @@ impl<K, V, S, H> Debug for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Default for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Default for HashMap<K, V, S>\n+    where K: Eq + Hash,\n+          S: HashState + Default,\n {\n     fn default() -> HashMap<K, V, S> {\n         HashMap::with_hash_state(Default::default())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          Q: Eq + Hash<H> + BorrowFrom<K>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash,\n+          Q: Eq + Hash + BorrowFrom<K>,\n+          S: HashState,\n {\n     type Output = V;\n \n@@ -1261,11 +1249,10 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          Q: Eq + Hash<H> + BorrowFrom<K>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash,\n+          Q: Eq + Hash + BorrowFrom<K>,\n+          S: HashState,\n {\n     #[inline]\n     fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n@@ -1373,10 +1360,8 @@ enum VacantEntryState<K, V, M> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, K, V, S> IntoIterator for &'a HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     type Item = (&'a K, &'a V);\n     type IntoIter = Iter<'a, K, V>;\n@@ -1387,10 +1372,8 @@ impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, K, V, S> IntoIterator for &'a mut HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     type Item = (&'a K, &'a mut V);\n     type IntoIter = IterMut<'a, K, V>;\n@@ -1401,10 +1384,8 @@ impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> IntoIterator for HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     type Item = (K, V);\n     type IntoIter = IntoIter<K, V>;\n@@ -1550,10 +1531,8 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> FromIterator<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState + Default\n {\n     fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n         let lower = iter.size_hint().0;\n@@ -1565,10 +1544,8 @@ impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<K, V, S> Extend<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash, S: HashState\n {\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n         for (k, v) in iter {\n@@ -1606,9 +1583,9 @@ impl RandomState {\n #[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n-    type Hasher = Hasher;\n-    fn hasher(&self) -> Hasher {\n-        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n+    type Hasher = SipHasher;\n+    fn hasher(&self) -> SipHasher {\n+        SipHasher::new_with_keys(self.k0, self.k1)\n     }\n }\n \n@@ -1621,25 +1598,6 @@ impl Default for RandomState {\n     }\n }\n \n-/// A hasher implementation which is generated from `RandomState` instances.\n-///\n-/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n-/// typically declare an ability to explicitly hash into this particular type,\n-/// but rather in a `H: hash::Writer` type parameter.\n-#[unstable(feature = \"std_misc\",\n-           reason = \"hashing an hash maps may be altered\")]\n-pub struct Hasher { inner: SipHasher }\n-\n-impl hash::Writer for Hasher {\n-    fn write(&mut self, data: &[u8]) { self.inner.write(data) }\n-}\n-\n-impl hash::Hasher for Hasher {\n-    type Output = u64;\n-    fn reset(&mut self) { self.inner.reset() }\n-    fn finish(&self) -> u64 { self.inner.finish() }\n-}\n-\n #[cfg(test)]\n mod test_map {\n     use prelude::v1::*;"}, {"sha": "18241c7a0c3d8135b3c325f44eebf6a2ee589bed", "filename": "src/libstd/collections/hash/map_stage0.rs", "status": "added", "additions": 2329, "deletions": 0, "changes": 2329, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -0,0 +1,2329 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15883\n+\n+use self::Entry::*;\n+use self::SearchResult::*;\n+use self::VacantEntryState::*;\n+\n+use borrow::BorrowFrom;\n+use clone::Clone;\n+use cmp::{max, Eq, PartialEq};\n+use default::Default;\n+use fmt::{self, Debug};\n+use hash::{self, Hash, SipHasher};\n+use iter::{self, Iterator, ExactSizeIterator, IntoIterator, IteratorExt, FromIterator, Extend, Map};\n+use marker::Sized;\n+use mem::{self, replace};\n+use num::{Int, UnsignedInt};\n+use ops::{Deref, FnMut, Index, IndexMut};\n+use option::Option::{self, Some, None};\n+use rand::{self, Rng};\n+use result::Result::{self, Ok, Err};\n+\n+use super::table::{\n+    self,\n+    Bucket,\n+    EmptyBucket,\n+    FullBucket,\n+    FullBucketImm,\n+    FullBucketMut,\n+    RawTable,\n+    SafeHash\n+};\n+use super::table::BucketState::{\n+    Empty,\n+    Full,\n+};\n+use super::state::HashState;\n+\n+const INITIAL_LOG2_CAP: usize = 5;\n+#[unstable(feature = \"std_misc\")]\n+pub const INITIAL_CAPACITY: usize = 1 << INITIAL_LOG2_CAP; // 2^5\n+\n+/// The default behavior of HashMap implements a load factor of 90.9%.\n+/// This behavior is characterized by the following condition:\n+///\n+/// - if size > 0.909 * capacity: grow the map\n+#[derive(Clone)]\n+struct DefaultResizePolicy;\n+\n+impl DefaultResizePolicy {\n+    fn new() -> DefaultResizePolicy {\n+        DefaultResizePolicy\n+    }\n+\n+    #[inline]\n+    fn min_capacity(&self, usable_size: usize) -> usize {\n+        // Here, we are rephrasing the logic by specifying the lower limit\n+        // on capacity:\n+        //\n+        // - if `cap < size * 1.1`: grow the map\n+        usable_size * 11 / 10\n+    }\n+\n+    /// An inverse of `min_capacity`, approximately.\n+    #[inline]\n+    fn usable_capacity(&self, cap: usize) -> usize {\n+        // As the number of entries approaches usable capacity,\n+        // min_capacity(size) must be smaller than the internal capacity,\n+        // so that the map is not resized:\n+        // `min_capacity(usable_capacity(x)) <= x`.\n+        // The left-hand side can only be smaller due to flooring by integer\n+        // division.\n+        //\n+        // This doesn't have to be checked for overflow since allocation size\n+        // in bytes will overflow earlier than multiplication by 10.\n+        cap * 10 / 11\n+    }\n+}\n+\n+#[test]\n+fn test_resize_policy() {\n+    use prelude::v1::*;\n+    let rp = DefaultResizePolicy;\n+    for n in 0..1000 {\n+        assert!(rp.min_capacity(rp.usable_capacity(n)) <= n);\n+        assert!(rp.usable_capacity(rp.min_capacity(n)) <= n);\n+    }\n+}\n+\n+// The main performance trick in this hashmap is called Robin Hood Hashing.\n+// It gains its excellent performance from one essential operation:\n+//\n+//    If an insertion collides with an existing element, and that element's\n+//    \"probe distance\" (how far away the element is from its ideal location)\n+//    is higher than how far we've already probed, swap the elements.\n+//\n+// This massively lowers variance in probe distance, and allows us to get very\n+// high load factors with good performance. The 90% load factor I use is rather\n+// conservative.\n+//\n+// > Why a load factor of approximately 90%?\n+//\n+// In general, all the distances to initial buckets will converge on the mean.\n+// At a load factor of \u03b1, the odds of finding the target bucket after k\n+// probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n+// on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n+// this down to make the math easier on the CPU and avoid its FPU.\n+// Since on average we start the probing in the middle of a cache line, this\n+// strategy pulls in two cache lines of hashes on every lookup. I think that's\n+// pretty good, but if you want to trade off some space, it could go down to one\n+// cache line on average with an \u03b1 of 0.84.\n+//\n+// > Wait, what? Where did you get 1-\u03b1^k from?\n+//\n+// On the first probe, your odds of a collision with an existing element is \u03b1.\n+// The odds of doing this twice in a row is approximately \u03b1^2. For three times,\n+// \u03b1^3, etc. Therefore, the odds of colliding k times is \u03b1^k. The odds of NOT\n+// colliding after k tries is 1-\u03b1^k.\n+//\n+// The paper from 1986 cited below mentions an implementation which keeps track\n+// of the distance-to-initial-bucket histogram. This approach is not suitable\n+// for modern architectures because it requires maintaining an internal data\n+// structure. This allows very good first guesses, but we are most concerned\n+// with guessing entire cache lines, not individual indexes. Furthermore, array\n+// accesses are no longer linear and in one direction, as we have now. There\n+// is also memory and cache pressure that this would entail that would be very\n+// difficult to properly see in a microbenchmark.\n+//\n+// ## Future Improvements (FIXME!)\n+//\n+// Allow the load factor to be changed dynamically and/or at initialization.\n+//\n+// Also, would it be possible for us to reuse storage when growing the\n+// underlying table? This is exactly the use case for 'realloc', and may\n+// be worth exploring.\n+//\n+// ## Future Optimizations (FIXME!)\n+//\n+// Another possible design choice that I made without any real reason is\n+// parameterizing the raw table over keys and values. Technically, all we need\n+// is the size and alignment of keys and values, and the code should be just as\n+// efficient (well, we might need one for power-of-two size and one for not...).\n+// This has the potential to reduce code bloat in rust executables, without\n+// really losing anything except 4 words (key size, key alignment, val size,\n+// val alignment) which can be passed in to every call of a `RawTable` function.\n+// This would definitely be an avenue worth exploring if people start complaining\n+// about the size of rust executables.\n+//\n+// Annotate exceedingly likely branches in `table::make_hash`\n+// and `search_hashed` to reduce instruction cache pressure\n+// and mispredictions once it becomes possible (blocked on issue #11092).\n+//\n+// Shrinking the table could simply reallocate in place after moving buckets\n+// to the first half.\n+//\n+// The growth algorithm (fragment of the Proof of Correctness)\n+// --------------------\n+//\n+// The growth algorithm is basically a fast path of the naive reinsertion-\n+// during-resize algorithm. Other paths should never be taken.\n+//\n+// Consider growing a robin hood hashtable of capacity n. Normally, we do this\n+// by allocating a new table of capacity `2n`, and then individually reinsert\n+// each element in the old table into the new one. This guarantees that the\n+// new table is a valid robin hood hashtable with all the desired statistical\n+// properties. Remark that the order we reinsert the elements in should not\n+// matter. For simplicity and efficiency, we will consider only linear\n+// reinsertions, which consist of reinserting all elements in the old table\n+// into the new one by increasing order of index. However we will not be\n+// starting our reinsertions from index 0 in general. If we start from index\n+// i, for the purpose of reinsertion we will consider all elements with real\n+// index j < i to have virtual index n + j.\n+//\n+// Our hash generation scheme consists of generating a 64-bit hash and\n+// truncating the most significant bits. When moving to the new table, we\n+// simply introduce a new bit to the front of the hash. Therefore, if an\n+// elements has ideal index i in the old table, it can have one of two ideal\n+// locations in the new table. If the new bit is 0, then the new ideal index\n+// is i. If the new bit is 1, then the new ideal index is n + i. Intuitively,\n+// we are producing two independent tables of size n, and for each element we\n+// independently choose which table to insert it into with equal probability.\n+// However the rather than wrapping around themselves on overflowing their\n+// indexes, the first table overflows into the first, and the first into the\n+// second. Visually, our new table will look something like:\n+//\n+// [yy_xxx_xxxx_xxx|xx_yyy_yyyy_yyy]\n+//\n+// Where x's are elements inserted into the first table, y's are elements\n+// inserted into the second, and _'s are empty sections. We now define a few\n+// key concepts that we will use later. Note that this is a very abstract\n+// perspective of the table. A real resized table would be at least half\n+// empty.\n+//\n+// Theorem: A linear robin hood reinsertion from the first ideal element\n+// produces identical results to a linear naive reinsertion from the same\n+// element.\n+//\n+// FIXME(Gankro, pczarn): review the proof and put it all in a separate doc.rs\n+\n+/// A hash map implementation which uses linear probing with Robin\n+/// Hood bucket stealing.\n+///\n+/// The hashes are all keyed by the task-local random number generator\n+/// on creation by default. This means that the ordering of the keys is\n+/// randomized, but makes the tables more resistant to\n+/// denial-of-service attacks (Hash DoS). This behaviour can be\n+/// overridden with one of the constructors.\n+///\n+/// It is required that the keys implement the `Eq` and `Hash` traits, although\n+/// this can frequently be achieved by using `#[derive(Eq, Hash)]`.\n+///\n+/// Relevant papers/articles:\n+///\n+/// 1. Pedro Celis. [\"Robin Hood Hashing\"](https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf)\n+/// 2. Emmanuel Goossaert. [\"Robin Hood\n+///    hashing\"](http://codecapsule.com/2013/11/11/robin-hood-hashing/)\n+/// 3. Emmanuel Goossaert. [\"Robin Hood hashing: backward shift\n+///    deletion\"](http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/)\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// // type inference lets us omit an explicit type signature (which\n+/// // would be `HashMap<&str, &str>` in this example).\n+/// let mut book_reviews = HashMap::new();\n+///\n+/// // review some books.\n+/// book_reviews.insert(\"Adventures of Huckleberry Finn\",    \"My favorite book.\");\n+/// book_reviews.insert(\"Grimms' Fairy Tales\",               \"Masterpiece.\");\n+/// book_reviews.insert(\"Pride and Prejudice\",               \"Very enjoyable.\");\n+/// book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n+///\n+/// // check for a specific one.\n+/// if !book_reviews.contains_key(&(\"Les Mis\u00e9rables\")) {\n+///     println!(\"We've got {} reviews, but Les Mis\u00e9rables ain't one.\",\n+///              book_reviews.len());\n+/// }\n+///\n+/// // oops, this review has a lot of spelling mistakes, let's delete it.\n+/// book_reviews.remove(&(\"The Adventures of Sherlock Holmes\"));\n+///\n+/// // look up the values associated with some keys.\n+/// let to_find = [\"Pride and Prejudice\", \"Alice's Adventure in Wonderland\"];\n+/// for book in to_find.iter() {\n+///     match book_reviews.get(book) {\n+///         Some(review) => println!(\"{}: {}\", *book, *review),\n+///         None => println!(\"{} is unreviewed.\", *book)\n+///     }\n+/// }\n+///\n+/// // iterate over everything.\n+/// for (book, review) in book_reviews.iter() {\n+///     println!(\"{}: \\\"{}\\\"\", *book, *review);\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `HashMap` with a custom type as key is to derive `Eq` and `Hash`.\n+/// We must also derive `PartialEq`.\n+///\n+/// ```\n+/// use std::collections::HashMap;\n+///\n+/// #[derive(Hash, Eq, PartialEq, Debug)]\n+/// struct Viking {\n+///     name: String,\n+///     country: String,\n+/// }\n+///\n+/// impl Viking {\n+///     /// Create a new Viking.\n+///     fn new(name: &str, country: &str) -> Viking {\n+///         Viking { name: name.to_string(), country: country.to_string() }\n+///     }\n+/// }\n+///\n+/// // Use a HashMap to store the vikings' health points.\n+/// let mut vikings = HashMap::new();\n+///\n+/// vikings.insert(Viking::new(\"Einar\", \"Norway\"), 25);\n+/// vikings.insert(Viking::new(\"Olaf\", \"Denmark\"), 24);\n+/// vikings.insert(Viking::new(\"Harald\", \"Iceland\"), 12);\n+///\n+/// // Use derived implementation to print the status of the vikings.\n+/// for (viking, health) in vikings.iter() {\n+///     println!(\"{:?} has {} hp\", viking, health);\n+/// }\n+/// ```\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct HashMap<K, V, S = RandomState> {\n+    // All hashes are keyed on these values, to prevent hash collision attacks.\n+    hash_state: S,\n+\n+    table: RawTable<K, V>,\n+\n+    resize_policy: DefaultResizePolicy,\n+}\n+\n+/// Search for a pre-hashed key.\n+fn search_hashed<K, V, M, F>(table: M,\n+                             hash: SafeHash,\n+                             mut is_match: F)\n+                             -> SearchResult<K, V, M> where\n+    M: Deref<Target=RawTable<K, V>>,\n+    F: FnMut(&K) -> bool,\n+{\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, hash);\n+    let ib = probe.index();\n+\n+    while probe.index() != ib + size {\n+        let full = match probe.peek() {\n+            Empty(b) => return TableRef(b.into_table()), // hit an empty bucket\n+            Full(b) => b\n+        };\n+\n+        if full.distance() + ib < full.index() {\n+            // We can finish the search early if we hit any bucket\n+            // with a lower distance to initial bucket than we've probed.\n+            return TableRef(full.into_table());\n+        }\n+\n+        // If the hash doesn't match, it can't be this one..\n+        if hash == full.hash() {\n+            // If the key doesn't match, it can't be this one..\n+            if is_match(full.read().0) {\n+                return FoundExisting(full);\n+            }\n+        }\n+\n+        probe = full.next();\n+    }\n+\n+    TableRef(probe.into_table())\n+}\n+\n+fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n+    let (empty, retkey, retval) = starting_bucket.take();\n+    let mut gap = match empty.gap_peek() {\n+        Some(b) => b,\n+        None => return (retkey, retval)\n+    };\n+\n+    while gap.full().distance() != 0 {\n+        gap = match gap.shift() {\n+            Some(b) => b,\n+            None => break\n+        };\n+    }\n+\n+    // Now we've done all our shifting. Return the value we grabbed earlier.\n+    (retkey, retval)\n+}\n+\n+/// Perform robin hood bucket stealing at the given `bucket`. You must\n+/// also pass the position of that bucket's initial bucket so we don't have\n+/// to recalculate it.\n+///\n+/// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n+fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n+                        mut ib: usize,\n+                        mut hash: SafeHash,\n+                        mut k: K,\n+                        mut v: V)\n+                        -> &'a mut V {\n+    let starting_index = bucket.index();\n+    let size = {\n+        let table = bucket.table(); // FIXME \"lifetime too short\".\n+        table.size()\n+    };\n+    // There can be at most `size - dib` buckets to displace, because\n+    // in the worst case, there are `size` elements and we already are\n+    // `distance` buckets away from the initial one.\n+    let idx_end = starting_index + size - bucket.distance();\n+\n+    loop {\n+        let (old_hash, old_key, old_val) = bucket.replace(hash, k, v);\n+        loop {\n+            let probe = bucket.next();\n+            assert!(probe.index() != idx_end);\n+\n+            let full_bucket = match probe.peek() {\n+                Empty(bucket) => {\n+                    // Found a hole!\n+                    let b = bucket.put(old_hash, old_key, old_val);\n+                    // Now that it's stolen, just read the value's pointer\n+                    // right out of the table!\n+                    return Bucket::at_index(b.into_table(), starting_index)\n+                               .peek()\n+                               .expect_full()\n+                               .into_mut_refs()\n+                               .1;\n+                },\n+                Full(bucket) => bucket\n+            };\n+\n+            let probe_ib = full_bucket.index() - full_bucket.distance();\n+\n+            bucket = full_bucket;\n+\n+            // Robin hood! Steal the spot.\n+            if ib < probe_ib {\n+                ib = probe_ib;\n+                hash = old_hash;\n+                k = old_key;\n+                v = old_val;\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+/// A result that works like Option<FullBucket<..>> but preserves\n+/// the reference that grants us access to the table in any case.\n+enum SearchResult<K, V, M> {\n+    // This is an entry that holds the given key:\n+    FoundExisting(FullBucket<K, V, M>),\n+\n+    // There was no such entry. The reference is given back:\n+    TableRef(M)\n+}\n+\n+impl<K, V, M> SearchResult<K, V, M> {\n+    fn into_option(self) -> Option<FullBucket<K, V, M>> {\n+        match self {\n+            FoundExisting(bucket) => Some(bucket),\n+            TableRef(_) => None\n+        }\n+    }\n+}\n+\n+impl<K, V, S, H> HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n+        table::make_hash(&self.hash_state, x)\n+    }\n+\n+    /// Search for a key, yielding the index if it's found in the hashtable.\n+    /// If you already have the hash for the key lying around, use\n+    /// search_hashed.\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<H>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n+    }\n+\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+        where Q: BorrowFrom<K> + Eq + Hash<H>\n+    {\n+        let hash = self.make_hash(q);\n+        search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+            .into_option()\n+    }\n+\n+    // The caller should ensure that invariants by Robin Hood Hashing hold.\n+    fn insert_hashed_ordered(&mut self, hash: SafeHash, k: K, v: V) {\n+        let cap = self.table.capacity();\n+        let mut buckets = Bucket::new(&mut self.table, hash);\n+        let ib = buckets.index();\n+\n+        while buckets.index() != ib + cap {\n+            // We don't need to compare hashes for value swap.\n+            // Not even DIBs for Robin Hood.\n+            buckets = match buckets.peek() {\n+                Empty(empty) => {\n+                    empty.put(hash, k, v);\n+                    return;\n+                }\n+                Full(b) => b.into_bucket()\n+            };\n+            buckets.next();\n+        }\n+        panic!(\"Internal HashMap error: Out of space.\");\n+    }\n+}\n+\n+impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n+    /// Create an empty HashMap.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new() -> HashMap<K, V, RandomState> {\n+        Default::default()\n+    }\n+\n+    /// Creates an empty hash map with the given initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::with_capacity(10);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize) -> HashMap<K, V, RandomState> {\n+        HashMap::with_capacity_and_hash_state(capacity, Default::default())\n+    }\n+}\n+\n+impl<K, V, S, H> HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    /// Creates an empty hashmap which will use the given hasher to hash keys.\n+    ///\n+    /// The creates map has the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_hash_state(s);\n+    /// map.insert(1, 2);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n+        HashMap {\n+            hash_state:    hash_state,\n+            resize_policy: DefaultResizePolicy::new(),\n+            table:         RawTable::new(0),\n+        }\n+    }\n+\n+    /// Create an empty HashMap with space for at least `capacity`\n+    /// elements, using `hasher` to hash the keys.\n+    ///\n+    /// Warning: `hasher` is normally randomly generated, and\n+    /// is designed to allow HashMaps to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n+    /// map.insert(1, 2);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n+                                        -> HashMap<K, V, S> {\n+        let resize_policy = DefaultResizePolicy::new();\n+        let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n+        let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n+        assert!(internal_cap >= capacity, \"capacity overflow\");\n+        HashMap {\n+            hash_state:    hash_state,\n+            resize_policy: resize_policy,\n+            table:         RawTable::new(internal_cap),\n+        }\n+    }\n+\n+    /// Returns the number of elements the map can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let map: HashMap<int, int> = HashMap::with_capacity(100);\n+    /// assert!(map.capacity() >= 100);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.resize_policy.usable_capacity(self.table.capacity())\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `HashMap`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new allocation size overflows `usize`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// let mut map: HashMap<&str, int> = HashMap::new();\n+    /// map.reserve(10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve(&mut self, additional: usize) {\n+        let new_size = self.len().checked_add(additional).expect(\"capacity overflow\");\n+        let min_cap = self.resize_policy.min_capacity(new_size);\n+\n+        // An invalid value shouldn't make us run out of space. This includes\n+        // an overflow check.\n+        assert!(new_size <= min_cap);\n+\n+        if self.table.capacity() < min_cap {\n+            let new_capacity = max(min_cap.next_power_of_two(), INITIAL_CAPACITY);\n+            self.resize(new_capacity);\n+        }\n+    }\n+\n+    /// Resizes the internal vectors to a new capacity. It's your responsibility to:\n+    ///   1) Make sure the new capacity is enough for all the elements, accounting\n+    ///      for the load factor.\n+    ///   2) Ensure new_capacity is a power of two or zero.\n+    fn resize(&mut self, new_capacity: usize) {\n+        assert!(self.table.size() <= new_capacity);\n+        assert!(new_capacity.is_power_of_two() || new_capacity == 0);\n+\n+        let mut old_table = replace(&mut self.table, RawTable::new(new_capacity));\n+        let old_size = old_table.size();\n+\n+        if old_table.capacity() == 0 || old_table.size() == 0 {\n+            return;\n+        }\n+\n+        // Grow the table.\n+        // Specialization of the other branch.\n+        let mut bucket = Bucket::first(&mut old_table);\n+\n+        // \"So a few of the first shall be last: for many be called,\n+        // but few chosen.\"\n+        //\n+        // We'll most likely encounter a few buckets at the beginning that\n+        // have their initial buckets near the end of the table. They were\n+        // placed at the beginning as the probe wrapped around the table\n+        // during insertion. We must skip forward to a bucket that won't\n+        // get reinserted too early and won't unfairly steal others spot.\n+        // This eliminates the need for robin hood.\n+        loop {\n+            bucket = match bucket.peek() {\n+                Full(full) => {\n+                    if full.distance() == 0 {\n+                        // This bucket occupies its ideal spot.\n+                        // It indicates the start of another \"cluster\".\n+                        bucket = full.into_bucket();\n+                        break;\n+                    }\n+                    // Leaving this bucket in the last cluster for later.\n+                    full.into_bucket()\n+                }\n+                Empty(b) => {\n+                    // Encountered a hole between clusters.\n+                    b.into_bucket()\n+                }\n+            };\n+            bucket.next();\n+        }\n+\n+        // This is how the buckets might be laid out in memory:\n+        // ($ marks an initialized bucket)\n+        //  ________________\n+        // |$$$_$$$$$$_$$$$$|\n+        //\n+        // But we've skipped the entire initial cluster of buckets\n+        // and will continue iteration in this order:\n+        //  ________________\n+        //     |$$$$$$_$$$$$\n+        //                  ^ wrap around once end is reached\n+        //  ________________\n+        //  $$$_____________|\n+        //    ^ exit once table.size == 0\n+        loop {\n+            bucket = match bucket.peek() {\n+                Full(bucket) => {\n+                    let h = bucket.hash();\n+                    let (b, k, v) = bucket.take();\n+                    self.insert_hashed_ordered(h, k, v);\n+                    {\n+                        let t = b.table(); // FIXME \"lifetime too short\".\n+                        if t.size() == 0 { break }\n+                    };\n+                    b.into_bucket()\n+                }\n+                Empty(b) => b.into_bucket()\n+            };\n+            bucket.next();\n+        }\n+\n+        assert_eq!(self.table.size(), old_size);\n+    }\n+\n+    /// Shrinks the capacity of the map as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<int, int> = HashMap::with_capacity(100);\n+    /// map.insert(1, 2);\n+    /// map.insert(3, 4);\n+    /// assert!(map.capacity() >= 100);\n+    /// map.shrink_to_fit();\n+    /// assert!(map.capacity() >= 2);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn shrink_to_fit(&mut self) {\n+        let min_capacity = self.resize_policy.min_capacity(self.len());\n+        let min_capacity = max(min_capacity.next_power_of_two(), INITIAL_CAPACITY);\n+\n+        // An invalid value shouldn't make us run out of space.\n+        debug_assert!(self.len() <= min_capacity);\n+\n+        if self.table.capacity() != min_capacity {\n+            let old_table = replace(&mut self.table, RawTable::new(min_capacity));\n+            let old_size = old_table.size();\n+\n+            // Shrink the table. Naive algorithm for resizing:\n+            for (h, k, v) in old_table.into_iter() {\n+                self.insert_hashed_nocheck(h, k, v);\n+            }\n+\n+            debug_assert_eq!(self.table.size(), old_size);\n+        }\n+    }\n+\n+    /// Insert a pre-hashed key-value pair, without first checking\n+    /// that there's enough room in the buckets. Returns a reference to the\n+    /// newly insert value.\n+    ///\n+    /// If the key already exists, the hashtable will be returned untouched\n+    /// and a reference to the existing element will be returned.\n+    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n+        self.insert_or_replace_with(hash, k, v, |_, _, _| ())\n+    }\n+\n+    fn insert_or_replace_with<'a, F>(&'a mut self,\n+                                     hash: SafeHash,\n+                                     k: K,\n+                                     v: V,\n+                                     mut found_existing: F)\n+                                     -> &'a mut V where\n+        F: FnMut(&mut K, &mut V, V),\n+    {\n+        // Worst case, we'll find one empty bucket among `size + 1` buckets.\n+        let size = self.table.size();\n+        let mut probe = Bucket::new(&mut self.table, hash);\n+        let ib = probe.index();\n+\n+        loop {\n+            let mut bucket = match probe.peek() {\n+                Empty(bucket) => {\n+                    // Found a hole!\n+                    return bucket.put(hash, k, v).into_mut_refs().1;\n+                }\n+                Full(bucket) => bucket\n+            };\n+\n+            // hash matches?\n+            if bucket.hash() == hash {\n+                // key matches?\n+                if k == *bucket.read_mut().0 {\n+                    let (bucket_k, bucket_v) = bucket.into_mut_refs();\n+                    debug_assert!(k == *bucket_k);\n+                    // Key already exists. Get its reference.\n+                    found_existing(bucket_k, bucket_v, v);\n+                    return bucket_v;\n+                }\n+            }\n+\n+            let robin_ib = bucket.index() as int - bucket.distance() as int;\n+\n+            if (ib as int) < robin_ib {\n+                // Found a luckier bucket than me. Better steal his spot.\n+                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n+            }\n+\n+            probe = bucket.next();\n+            assert!(probe.index() != ib + size + 1);\n+        }\n+    }\n+\n+    /// An iterator visiting all keys in arbitrary order.\n+    /// Iterator element type is `&'a K`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for key in map.keys() {\n+    ///     println!(\"{}\", key);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((&'a K,&'a V)) -> &'a K = first; // coerce to fn ptr\n+\n+        Keys { inner: self.iter().map(first) }\n+    }\n+\n+    /// An iterator visiting all values in arbitrary order.\n+    /// Iterator element type is `&'a V`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for val in map.values() {\n+    ///     println!(\"{}\", val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n+        fn second<A, B>((_, b): (A, B)) -> B { b }\n+        let second: fn((&'a K,&'a V)) -> &'a V = second; // coerce to fn ptr\n+\n+        Values { inner: self.iter().map(second) }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order.\n+    /// Iterator element type is `(&'a K, &'a V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<K, V> {\n+        Iter { inner: self.table.iter() }\n+    }\n+\n+    /// An iterator visiting all key-value pairs in arbitrary order,\n+    /// with mutable references to the values.\n+    /// Iterator element type is `(&'a K, &'a mut V)`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Update all values\n+    /// for (_, val) in map.iter_mut() {\n+    ///     *val *= 2;\n+    /// }\n+    ///\n+    /// for (key, val) in map.iter() {\n+    ///     println!(\"key: {} val: {}\", key, val);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+        IterMut { inner: self.table.iter_mut() }\n+    }\n+\n+    /// Creates a consuming iterator, that is, one that moves each key-value\n+    /// pair out of the map in arbitrary order. The map cannot be used after\n+    /// calling this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(\"a\", 1);\n+    /// map.insert(\"b\", 2);\n+    /// map.insert(\"c\", 3);\n+    ///\n+    /// // Not possible with .iter()\n+    /// let vec: Vec<(&str, int)> = map.into_iter().collect();\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_iter(self) -> IntoIter<K, V> {\n+        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two;\n+\n+        IntoIter {\n+            inner: self.table.into_iter().map(last_two)\n+        }\n+    }\n+\n+    /// Gets the given key's corresponding entry in the map for in-place manipulation.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n+        // Gotta resize now.\n+        self.reserve(1);\n+\n+        let hash = self.make_hash(&key);\n+        search_entry_hashed(&mut self.table, hash, key)\n+    }\n+\n+    /// Returns the number of elements in the map.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert_eq!(a.len(), 0);\n+    /// a.insert(1, \"a\");\n+    /// assert_eq!(a.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len(&self) -> usize { self.table.size() }\n+\n+    /// Returns true if the map contains no elements.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// assert!(a.is_empty());\n+    /// a.insert(1, \"a\");\n+    /// assert!(!a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool { self.len() == 0 }\n+\n+    /// Clears the map, returning all key-value pairs as an iterator. Keeps the\n+    /// allocated memory for reuse.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.insert(2, \"b\");\n+    ///\n+    /// for (k, v) in a.drain().take(1) {\n+    ///     assert!(k == 1 || k == 2);\n+    ///     assert!(v == \"a\" || v == \"b\");\n+    /// }\n+    ///\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+    pub fn drain(&mut self) -> Drain<K, V> {\n+        fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n+        let last_two: fn((SafeHash, K, V)) -> (K, V) = last_two; // coerce to fn pointer\n+\n+        Drain {\n+            inner: self.table.drain().map(last_two),\n+        }\n+    }\n+\n+    /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n+    /// for reuse.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut a = HashMap::new();\n+    /// a.insert(1, \"a\");\n+    /// a.clear();\n+    /// assert!(a.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.drain();\n+    }\n+\n+    /// Returns a reference to the value corresponding to the key.\n+    ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.get(&1), Some(&\"a\"));\n+    /// assert_eq!(map.get(&2), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n+    {\n+        self.search(k).map(|bucket| bucket.into_refs().1)\n+    }\n+\n+    /// Returns true if the map contains a value for the specified key.\n+    ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.contains_key(&1), true);\n+    /// assert_eq!(map.contains_key(&2), false);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n+    {\n+        self.search(k).is_some()\n+    }\n+\n+    /// Returns a mutable reference to the value corresponding to the key.\n+    ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1, \"a\");\n+    /// match map.get_mut(&1) {\n+    ///     Some(x) => *x = \"b\",\n+    ///     None => (),\n+    /// }\n+    /// assert_eq!(map[1], \"b\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n+    {\n+        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n+    }\n+\n+    /// Inserts a key-value pair from the map. If the key already had a value\n+    /// present in the map, that value is returned. Otherwise, `None` is returned.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// assert_eq!(map.insert(37, \"a\"), None);\n+    /// assert_eq!(map.is_empty(), false);\n+    ///\n+    /// map.insert(37, \"b\");\n+    /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n+    /// assert_eq!(map[37], \"c\");\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n+        let hash = self.make_hash(&k);\n+        self.reserve(1);\n+\n+        let mut retval = None;\n+        self.insert_or_replace_with(hash, k, v, |_, val_ref, val| {\n+            retval = Some(replace(val_ref, val));\n+        });\n+        retval\n+    }\n+\n+    /// Removes a key from the map, returning the value at the key if the key\n+    /// was previously in the map.\n+    ///\n+    /// The key may be any borrowed form of the map's key type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the key type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map = HashMap::new();\n+    /// map.insert(1, \"a\");\n+    /// assert_eq!(map.remove(&1), Some(\"a\"));\n+    /// assert_eq!(map.remove(&1), None);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n+    {\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n+    }\n+}\n+\n+fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n+        -> Entry<'a, K, V>\n+{\n+    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n+    let size = table.size();\n+    let mut probe = Bucket::new(table, hash);\n+    let ib = probe.index();\n+\n+    loop {\n+        let bucket = match probe.peek() {\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return Vacant(VacantEntry {\n+                    hash: hash,\n+                    key: k,\n+                    elem: NoElem(bucket),\n+                });\n+            },\n+            Full(bucket) => bucket\n+        };\n+\n+        // hash matches?\n+        if bucket.hash() == hash {\n+            // key matches?\n+            if k == *bucket.read().0 {\n+                return Occupied(OccupiedEntry{\n+                    elem: bucket,\n+                });\n+            }\n+        }\n+\n+        let robin_ib = bucket.index() as int - bucket.distance() as int;\n+\n+        if (ib as int) < robin_ib {\n+            // Found a luckier bucket than me. Better steal his spot.\n+            return Vacant(VacantEntry {\n+                hash: hash,\n+                key: k,\n+                elem: NeqElem(bucket, robin_ib as usize),\n+            });\n+        }\n+\n+        probe = bucket.next();\n+        assert!(probe.index() != ib + size + 1);\n+    }\n+}\n+\n+impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n+    where K: Eq + Hash<H>, V: PartialEq,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n+        if self.len() != other.len() { return false; }\n+\n+        self.iter().all(|(key, value)|\n+            other.get(key).map_or(false, |v| *value == *v)\n+        )\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V, S, H> Eq for HashMap<K, V, S>\n+    where K: Eq + Hash<H>, V: Eq,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V, S, H> Debug for HashMap<K, V, S>\n+    where K: Eq + Hash<H> + Debug, V: Debug,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"HashMap {{\"));\n+\n+        for (i, (k, v)) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{:?}: {:?}\", *k, *v));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V, S, H> Default for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn default() -> HashMap<K, V, S> {\n+        HashMap::with_hash_state(Default::default())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          Q: Eq + Hash<H> + BorrowFrom<K>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, index: &Q) -> &'a V {\n+        self.get(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          Q: Eq + Hash<H> + BorrowFrom<K>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    #[inline]\n+    fn index_mut<'a>(&'a mut self, index: &Q) -> &'a mut V {\n+        self.get_mut(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n+/// HashMap iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Iter<'a, K: 'a, V: 'a> {\n+    inner: table::Iter<'a, K, V>\n+}\n+\n+// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+impl<'a, K, V> Clone for Iter<'a, K, V> {\n+    fn clone(&self) -> Iter<'a, K, V> {\n+        Iter {\n+            inner: self.inner.clone()\n+        }\n+    }\n+}\n+\n+/// HashMap mutable values iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IterMut<'a, K: 'a, V: 'a> {\n+    inner: table::IterMut<'a, K, V>\n+}\n+\n+/// HashMap move iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<K, V> {\n+    inner: iter::Map<table::IntoIter<K, V>, fn((SafeHash, K, V)) -> (K, V)>\n+}\n+\n+/// HashMap keys iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Keys<'a, K: 'a, V: 'a> {\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n+}\n+\n+// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+impl<'a, K, V> Clone for Keys<'a, K, V> {\n+    fn clone(&self) -> Keys<'a, K, V> {\n+        Keys {\n+            inner: self.inner.clone()\n+        }\n+    }\n+}\n+\n+/// HashMap values iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Values<'a, K: 'a, V: 'a> {\n+    inner: Map<Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n+}\n+\n+// FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n+impl<'a, K, V> Clone for Values<'a, K, V> {\n+    fn clone(&self) -> Values<'a, K, V> {\n+        Values {\n+            inner: self.inner.clone()\n+        }\n+    }\n+}\n+\n+/// HashMap drain iterator.\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform specification, waiting for dust to settle\")]\n+pub struct Drain<'a, K: 'a, V: 'a> {\n+    inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n+}\n+\n+/// A view into a single occupied location in a HashMap.\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single empty location in a HashMap.\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    hash: SafeHash,\n+    key: K,\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single location in a map, which may be vacant or occupied.\n+#[unstable(feature = \"std_misc\",\n+           reason = \"precise API still being fleshed out\")]\n+pub enum Entry<'a, K: 'a, V: 'a> {\n+    /// An occupied Entry.\n+    Occupied(OccupiedEntry<'a, K, V>),\n+    /// A vacant Entry.\n+    Vacant(VacantEntry<'a, K, V>),\n+}\n+\n+/// Possible states of a VacantEntry.\n+enum VacantEntryState<K, V, M> {\n+    /// The index is occupied, but the key to insert has precedence,\n+    /// and will kick the current one out on insertion.\n+    NeqElem(FullBucket<K, V, M>, usize),\n+    /// The index is genuinely vacant.\n+    NoElem(EmptyBucket<K, V, M>),\n+}\n+\n+impl<'a, K, V, S, H> IntoIterator for &'a HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = (&'a K, &'a V);\n+    type IntoIter = Iter<'a, K, V>;\n+\n+    fn into_iter(self) -> Iter<'a, K, V> {\n+        self.iter()\n+    }\n+}\n+\n+impl<'a, K, V, S, H> IntoIterator for &'a mut HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = (&'a K, &'a mut V);\n+    type IntoIter = IterMut<'a, K, V>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, K, V> {\n+        self.iter_mut()\n+    }\n+}\n+\n+impl<K, V, S, H> IntoIterator for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = (K, V);\n+    type IntoIter = IntoIter<K, V>;\n+\n+    fn into_iter(self) -> IntoIter<K, V> {\n+        self.into_iter()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> Iterator for Iter<'a, K, V> {\n+    type Item = (&'a K, &'a V);\n+\n+    #[inline] fn next(&mut self) -> Option<(&'a K, &'a V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> ExactSizeIterator for Iter<'a, K, V> {\n+    #[inline] fn len(&self) -> usize { self.inner.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> Iterator for IterMut<'a, K, V> {\n+    type Item = (&'a K, &'a mut V);\n+\n+    #[inline] fn next(&mut self) -> Option<(&'a K, &'a mut V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> ExactSizeIterator for IterMut<'a, K, V> {\n+    #[inline] fn len(&self) -> usize { self.inner.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V> Iterator for IntoIter<K, V> {\n+    type Item = (K, V);\n+\n+    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V> ExactSizeIterator for IntoIter<K, V> {\n+    #[inline] fn len(&self) -> usize { self.inner.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> Iterator for Keys<'a, K, V> {\n+    type Item = &'a K;\n+\n+    #[inline] fn next(&mut self) -> Option<(&'a K)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n+    #[inline] fn len(&self) -> usize { self.inner.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> Iterator for Values<'a, K, V> {\n+    type Item = &'a V;\n+\n+    #[inline] fn next(&mut self) -> Option<(&'a V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n+    #[inline] fn len(&self) -> usize { self.inner.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> Iterator for Drain<'a, K, V> {\n+    type Item = (K, V);\n+\n+    #[inline] fn next(&mut self) -> Option<(K, V)> { self.inner.next() }\n+    #[inline] fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n+    #[inline] fn len(&self) -> usize { self.inner.len() }\n+}\n+\n+#[unstable(feature = \"std_misc\",\n+           reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n+impl<'a, K, V> Entry<'a, K, V> {\n+    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n+    pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n+        match self {\n+            Occupied(entry) => Ok(entry.into_mut()),\n+            Vacant(entry) => Err(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> &V {\n+        self.elem.read().1\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.elem.read_mut().1\n+    }\n+\n+    /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n+    /// with a lifetime bound to the map itself\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.elem.into_mut_refs().1\n+    }\n+\n+    /// Sets the value of the entry, and returns the entry's old value\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, mut value: V) -> V {\n+        let old_value = self.get_mut();\n+        mem::swap(&mut value, old_value);\n+        value\n+    }\n+\n+    /// Takes the value out of the entry, and returns it\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove(self) -> V {\n+        pop_internal(self.elem).1\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        match self.elem {\n+            NeqElem(bucket, ib) => {\n+                robin_hood(bucket, ib, self.hash, self.key, value)\n+            }\n+            NoElem(bucket) => {\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n+        let lower = iter.size_hint().0;\n+        let mut map = HashMap::with_capacity_and_hash_state(lower,\n+                                                            Default::default());\n+        map.extend(iter);\n+        map\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn extend<T: Iterator<Item=(K, V)>>(&mut self, iter: T) {\n+        for (k, v) in iter {\n+            self.insert(k, v);\n+        }\n+    }\n+}\n+\n+\n+/// `RandomState` is the default state for `HashMap` types.\n+///\n+/// A particular instance `RandomState` will create the same instances of\n+/// `Hasher`, but the hashers created by two different `RandomState`\n+/// instances are unlikely to produce the same result for the same values.\n+#[derive(Clone)]\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n+pub struct RandomState {\n+    k0: u64,\n+    k1: u64,\n+}\n+\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n+impl RandomState {\n+    /// Construct a new `RandomState` that is initialized with random keys.\n+    #[inline]\n+    #[allow(deprecated)]\n+    pub fn new() -> RandomState {\n+        let mut r = rand::thread_rng();\n+        RandomState { k0: r.gen(), k1: r.gen() }\n+    }\n+}\n+\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n+impl HashState for RandomState {\n+    type Hasher = Hasher;\n+    fn hasher(&self) -> Hasher {\n+        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n+    }\n+}\n+\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n+impl Default for RandomState {\n+    #[inline]\n+    fn default() -> RandomState {\n+        RandomState::new()\n+    }\n+}\n+\n+/// A hasher implementation which is generated from `RandomState` instances.\n+///\n+/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n+/// typically declare an ability to explicitly hash into this particular type,\n+/// but rather in a `H: hash::Writer` type parameter.\n+#[unstable(feature = \"std_misc\",\n+           reason = \"hashing an hash maps may be altered\")]\n+pub struct Hasher { inner: SipHasher }\n+\n+impl hash::Writer for Hasher {\n+    fn write(&mut self, data: &[u8]) {\n+        hash::Writer::write(&mut self.inner, data)\n+    }\n+}\n+\n+impl hash::Hasher for Hasher {\n+    type Output = u64;\n+    fn reset(&mut self) { hash::Hasher::reset(&mut self.inner) }\n+    fn finish(&self) -> u64 { self.inner.finish() }\n+}\n+\n+#[cfg(test)]\n+mod test_map {\n+    use prelude::v1::*;\n+\n+    use super::HashMap;\n+    use super::Entry::{Occupied, Vacant};\n+    use iter::{range_inclusive, range_step_inclusive, repeat};\n+    use cell::RefCell;\n+    use rand::{weak_rng, Rng};\n+\n+    #[test]\n+    fn test_create_capacity_zero() {\n+        let mut m = HashMap::with_capacity(0);\n+\n+        assert!(m.insert(1, 1).is_none());\n+\n+        assert!(m.contains_key(&1));\n+        assert!(!m.contains_key(&0));\n+    }\n+\n+    #[test]\n+    fn test_insert() {\n+        let mut m = HashMap::new();\n+        assert_eq!(m.len(), 0);\n+        assert!(m.insert(1, 2).is_none());\n+        assert_eq!(m.len(), 1);\n+        assert!(m.insert(2, 4).is_none());\n+        assert_eq!(m.len(), 2);\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&2).unwrap(), 4);\n+    }\n+\n+    thread_local! { static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()) }\n+\n+    #[derive(Hash, PartialEq, Eq)]\n+    struct Dropable {\n+        k: usize\n+    }\n+\n+    impl Dropable {\n+        fn new(k: usize) -> Dropable {\n+            DROP_VECTOR.with(|slot| {\n+                slot.borrow_mut()[k] += 1;\n+            });\n+\n+            Dropable { k: k }\n+        }\n+    }\n+\n+    impl Drop for Dropable {\n+        fn drop(&mut self) {\n+            DROP_VECTOR.with(|slot| {\n+                slot.borrow_mut()[self.k] -= 1;\n+            });\n+        }\n+    }\n+\n+    impl Clone for Dropable {\n+        fn clone(&self) -> Dropable {\n+            Dropable::new(self.k)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_drops() {\n+        DROP_VECTOR.with(|slot| {\n+            *slot.borrow_mut() = repeat(0).take(200).collect();\n+        });\n+\n+        {\n+            let mut m = HashMap::new();\n+\n+            DROP_VECTOR.with(|v| {\n+                for i in 0..200 {\n+                    assert_eq!(v.borrow()[i], 0);\n+                }\n+            });\n+\n+            for i in 0..100 {\n+                let d1 = Dropable::new(i);\n+                let d2 = Dropable::new(i+100);\n+                m.insert(d1, d2);\n+            }\n+\n+            DROP_VECTOR.with(|v| {\n+                for i in 0..200 {\n+                    assert_eq!(v.borrow()[i], 1);\n+                }\n+            });\n+\n+            for i in 0..50 {\n+                let k = Dropable::new(i);\n+                let v = m.remove(&k);\n+\n+                assert!(v.is_some());\n+\n+                DROP_VECTOR.with(|v| {\n+                    assert_eq!(v.borrow()[i], 1);\n+                    assert_eq!(v.borrow()[i+100], 1);\n+                });\n+            }\n+\n+            DROP_VECTOR.with(|v| {\n+                for i in 0..50 {\n+                    assert_eq!(v.borrow()[i], 0);\n+                    assert_eq!(v.borrow()[i+100], 0);\n+                }\n+\n+                for i in 50..100 {\n+                    assert_eq!(v.borrow()[i], 1);\n+                    assert_eq!(v.borrow()[i+100], 1);\n+                }\n+            });\n+        }\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 0);\n+            }\n+        });\n+    }\n+\n+    #[test]\n+    fn test_move_iter_drops() {\n+        DROP_VECTOR.with(|v| {\n+            *v.borrow_mut() = repeat(0).take(200).collect();\n+        });\n+\n+        let hm = {\n+            let mut hm = HashMap::new();\n+\n+            DROP_VECTOR.with(|v| {\n+                for i in 0..200 {\n+                    assert_eq!(v.borrow()[i], 0);\n+                }\n+            });\n+\n+            for i in 0..100 {\n+                let d1 = Dropable::new(i);\n+                let d2 = Dropable::new(i+100);\n+                hm.insert(d1, d2);\n+            }\n+\n+            DROP_VECTOR.with(|v| {\n+                for i in 0..200 {\n+                    assert_eq!(v.borrow()[i], 1);\n+                }\n+            });\n+\n+            hm\n+        };\n+\n+        // By the way, ensure that cloning doesn't screw up the dropping.\n+        drop(hm.clone());\n+\n+        {\n+            let mut half = hm.into_iter().take(50);\n+\n+            DROP_VECTOR.with(|v| {\n+                for i in 0..200 {\n+                    assert_eq!(v.borrow()[i], 1);\n+                }\n+            });\n+\n+            for _ in half.by_ref() {}\n+\n+            DROP_VECTOR.with(|v| {\n+                let nk = (0..100).filter(|&i| {\n+                    v.borrow()[i] == 1\n+                }).count();\n+\n+                let nv = (0..100).filter(|&i| {\n+                    v.borrow()[i+100] == 1\n+                }).count();\n+\n+                assert_eq!(nk, 50);\n+                assert_eq!(nv, 50);\n+            });\n+        };\n+\n+        DROP_VECTOR.with(|v| {\n+            for i in 0..200 {\n+                assert_eq!(v.borrow()[i], 0);\n+            }\n+        });\n+    }\n+\n+    #[test]\n+    fn test_empty_pop() {\n+        let mut m: HashMap<int, bool> = HashMap::new();\n+        assert_eq!(m.remove(&0), None);\n+    }\n+\n+    #[test]\n+    fn test_lots_of_insertions() {\n+        let mut m = HashMap::new();\n+\n+        // Try this a few times to make sure we never screw up the hashmap's\n+        // internal state.\n+        for _ in 0..10 {\n+            assert!(m.is_empty());\n+\n+            for i in range_inclusive(1, 1000) {\n+                assert!(m.insert(i, i).is_none());\n+\n+                for j in range_inclusive(1, i) {\n+                    let r = m.get(&j);\n+                    assert_eq!(r, Some(&j));\n+                }\n+\n+                for j in range_inclusive(i+1, 1000) {\n+                    let r = m.get(&j);\n+                    assert_eq!(r, None);\n+                }\n+            }\n+\n+            for i in range_inclusive(1001, 2000) {\n+                assert!(!m.contains_key(&i));\n+            }\n+\n+            // remove forwards\n+            for i in range_inclusive(1, 1000) {\n+                assert!(m.remove(&i).is_some());\n+\n+                for j in range_inclusive(1, i) {\n+                    assert!(!m.contains_key(&j));\n+                }\n+\n+                for j in range_inclusive(i+1, 1000) {\n+                    assert!(m.contains_key(&j));\n+                }\n+            }\n+\n+            for i in range_inclusive(1, 1000) {\n+                assert!(!m.contains_key(&i));\n+            }\n+\n+            for i in range_inclusive(1, 1000) {\n+                assert!(m.insert(i, i).is_none());\n+            }\n+\n+            // remove backwards\n+            for i in range_step_inclusive(1000, 1, -1) {\n+                assert!(m.remove(&i).is_some());\n+\n+                for j in range_inclusive(i, 1000) {\n+                    assert!(!m.contains_key(&j));\n+                }\n+\n+                for j in range_inclusive(1, i-1) {\n+                    assert!(m.contains_key(&j));\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_find_mut() {\n+        let mut m = HashMap::new();\n+        assert!(m.insert(1, 12).is_none());\n+        assert!(m.insert(2, 8).is_none());\n+        assert!(m.insert(5, 14).is_none());\n+        let new = 100;\n+        match m.get_mut(&5) {\n+            None => panic!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.get(&5), Some(&new));\n+    }\n+\n+    #[test]\n+    fn test_insert_overwrite() {\n+        let mut m = HashMap::new();\n+        assert!(m.insert(1, 2).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert!(!m.insert(1, 3).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 3);\n+    }\n+\n+    #[test]\n+    fn test_insert_conflicts() {\n+        let mut m = HashMap::with_capacity(4);\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(m.insert(5, 3).is_none());\n+        assert!(m.insert(9, 4).is_none());\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+    }\n+\n+    #[test]\n+    fn test_conflict_remove() {\n+        let mut m = HashMap::with_capacity(4);\n+        assert!(m.insert(1, 2).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert!(m.insert(5, 3).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert!(m.insert(9, 4).is_none());\n+        assert_eq!(*m.get(&1).unwrap(), 2);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert!(m.remove(&1).is_some());\n+        assert_eq!(*m.get(&9).unwrap(), 4);\n+        assert_eq!(*m.get(&5).unwrap(), 3);\n+    }\n+\n+    #[test]\n+    fn test_is_empty() {\n+        let mut m = HashMap::with_capacity(4);\n+        assert!(m.insert(1, 2).is_none());\n+        assert!(!m.is_empty());\n+        assert!(m.remove(&1).is_some());\n+        assert!(m.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut m = HashMap::new();\n+        m.insert(1, 2);\n+        assert_eq!(m.remove(&1), Some(2));\n+        assert_eq!(m.remove(&1), None);\n+    }\n+\n+    #[test]\n+    fn test_iterate() {\n+        let mut m = HashMap::with_capacity(4);\n+        for i in 0..32 {\n+            assert!(m.insert(i, i*2).is_none());\n+        }\n+        assert_eq!(m.len(), 32);\n+\n+        let mut observed: u32 = 0;\n+\n+        for (k, v) in &m {\n+            assert_eq!(*v, *k * 2);\n+            observed |= 1 << *k;\n+        }\n+        assert_eq!(observed, 0xFFFF_FFFF);\n+    }\n+\n+    #[test]\n+    fn test_keys() {\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let keys: Vec<_> = map.keys().cloned().collect();\n+        assert_eq!(keys.len(), 3);\n+        assert!(keys.contains(&1));\n+        assert!(keys.contains(&2));\n+        assert!(keys.contains(&3));\n+    }\n+\n+    #[test]\n+    fn test_values() {\n+        let vec = vec![(1, 'a'), (2, 'b'), (3, 'c')];\n+        let map: HashMap<_, _> = vec.into_iter().collect();\n+        let values: Vec<_> = map.values().cloned().collect();\n+        assert_eq!(values.len(), 3);\n+        assert!(values.contains(&'a'));\n+        assert!(values.contains(&'b'));\n+        assert!(values.contains(&'c'));\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        let mut m = HashMap::new();\n+        assert!(m.get(&1).is_none());\n+        m.insert(1, 2);\n+        match m.get(&1) {\n+            None => panic!(),\n+            Some(v) => assert_eq!(*v, 2)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        let mut m1 = HashMap::new();\n+        m1.insert(1, 2);\n+        m1.insert(2, 3);\n+        m1.insert(3, 4);\n+\n+        let mut m2 = HashMap::new();\n+        m2.insert(1, 2);\n+        m2.insert(2, 3);\n+\n+        assert!(m1 != m2);\n+\n+        m2.insert(3, 4);\n+\n+        assert_eq!(m1, m2);\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut map = HashMap::new();\n+        let empty: HashMap<i32, i32> = HashMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(3, 4);\n+\n+        let map_str = format!(\"{:?}\", map);\n+\n+        assert!(map_str == \"HashMap {1: 2, 3: 4}\" ||\n+                map_str == \"HashMap {3: 4, 1: 2}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"HashMap {}\");\n+    }\n+\n+    #[test]\n+    fn test_expand() {\n+        let mut m = HashMap::new();\n+\n+        assert_eq!(m.len(), 0);\n+        assert!(m.is_empty());\n+\n+        let mut i = 0;\n+        let old_cap = m.table.capacity();\n+        while old_cap == m.table.capacity() {\n+            m.insert(i, i);\n+            i += 1;\n+        }\n+\n+        assert_eq!(m.len(), i);\n+        assert!(!m.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_behavior_resize_policy() {\n+        let mut m = HashMap::new();\n+\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(m.table.capacity(), 0);\n+        assert!(m.is_empty());\n+\n+        m.insert(0, 0);\n+        m.remove(&0);\n+        assert!(m.is_empty());\n+        let initial_cap = m.table.capacity();\n+        m.reserve(initial_cap);\n+        let cap = m.table.capacity();\n+\n+        assert_eq!(cap, initial_cap * 2);\n+\n+        let mut i = 0;\n+        for _ in 0..cap * 3 / 4 {\n+            m.insert(i, i);\n+            i += 1;\n+        }\n+        // three quarters full\n+\n+        assert_eq!(m.len(), i);\n+        assert_eq!(m.table.capacity(), cap);\n+\n+        for _ in 0..cap / 4 {\n+            m.insert(i, i);\n+            i += 1;\n+        }\n+        // half full\n+\n+        let new_cap = m.table.capacity();\n+        assert_eq!(new_cap, cap * 2);\n+\n+        for _ in 0..cap / 2 - 1 {\n+            i -= 1;\n+            m.remove(&i);\n+            assert_eq!(m.table.capacity(), new_cap);\n+        }\n+        // A little more than one quarter full.\n+        m.shrink_to_fit();\n+        assert_eq!(m.table.capacity(), cap);\n+        // again, a little more than half full\n+        for _ in 0..cap / 2 - 1 {\n+            i -= 1;\n+            m.remove(&i);\n+        }\n+        m.shrink_to_fit();\n+\n+        assert_eq!(m.len(), i);\n+        assert!(!m.is_empty());\n+        assert_eq!(m.table.capacity(), initial_cap);\n+    }\n+\n+    #[test]\n+    fn test_reserve_shrink_to_fit() {\n+        let mut m = HashMap::new();\n+        m.insert(0, 0);\n+        m.remove(&0);\n+        assert!(m.capacity() >= m.len());\n+        for i in 0..128 {\n+            m.insert(i, i);\n+        }\n+        m.reserve(256);\n+\n+        let usable_cap = m.capacity();\n+        for i in 128..(128 + 256) {\n+            m.insert(i, i);\n+            assert_eq!(m.capacity(), usable_cap);\n+        }\n+\n+        for i in 100..(128 + 256) {\n+            assert_eq!(m.remove(&i), Some(i));\n+        }\n+        m.shrink_to_fit();\n+\n+        assert_eq!(m.len(), 100);\n+        assert!(!m.is_empty());\n+        assert!(m.capacity() >= m.len());\n+\n+        for i in 0..100 {\n+            assert_eq!(m.remove(&i), Some(i));\n+        }\n+        m.shrink_to_fit();\n+        m.insert(0, 0);\n+\n+        assert_eq!(m.len(), 1);\n+        assert!(m.capacity() >= m.len());\n+        assert_eq!(m.remove(&0), Some(0));\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+        for &(k, v) in &xs {\n+            assert_eq!(map.get(&k), Some(&v));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_size_hint() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n+\n+        let mut iter = map.iter();\n+\n+        for _ in iter.by_ref().take(3) {}\n+\n+        assert_eq!(iter.size_hint(), (3, Some(3)));\n+    }\n+\n+    #[test]\n+    fn test_iter_len() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let map: HashMap<_, _>  = xs.iter().cloned().collect();\n+\n+        let mut iter = map.iter();\n+\n+        for _ in iter.by_ref().take(3) {}\n+\n+        assert_eq!(iter.len(), 3);\n+    }\n+\n+    #[test]\n+    fn test_mut_size_hint() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n+\n+        let mut iter = map.iter_mut();\n+\n+        for _ in iter.by_ref().take(3) {}\n+\n+        assert_eq!(iter.size_hint(), (3, Some(3)));\n+    }\n+\n+    #[test]\n+    fn test_iter_mut_len() {\n+        let xs = [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)];\n+\n+        let mut map: HashMap<_, _>  = xs.iter().cloned().collect();\n+\n+        let mut iter = map.iter_mut();\n+\n+        for _ in iter.by_ref().take(3) {}\n+\n+        assert_eq!(iter.len(), 3);\n+    }\n+\n+    #[test]\n+    fn test_index() {\n+        let mut map = HashMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        assert_eq!(map[2], 1);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_index_nonexistent() {\n+        let mut map = HashMap::new();\n+\n+        map.insert(1, 2);\n+        map.insert(2, 1);\n+        map.insert(3, 4);\n+\n+        map[4];\n+    }\n+\n+    #[test]\n+    fn test_entry(){\n+        let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n+\n+        let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n+\n+        // Existing key (insert)\n+        match map.entry(1) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                assert_eq!(view.get(), &10);\n+                assert_eq!(view.insert(100), 10);\n+            }\n+        }\n+        assert_eq!(map.get(&1).unwrap(), &100);\n+        assert_eq!(map.len(), 6);\n+\n+\n+        // Existing key (update)\n+        match map.entry(2) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(mut view) => {\n+                let v = view.get_mut();\n+                let new_v = (*v) * 10;\n+                *v = new_v;\n+            }\n+        }\n+        assert_eq!(map.get(&2).unwrap(), &200);\n+        assert_eq!(map.len(), 6);\n+\n+        // Existing key (take)\n+        match map.entry(3) {\n+            Vacant(_) => unreachable!(),\n+            Occupied(view) => {\n+                assert_eq!(view.remove(), 30);\n+            }\n+        }\n+        assert_eq!(map.get(&3), None);\n+        assert_eq!(map.len(), 5);\n+\n+\n+        // Inexistent key (insert)\n+        match map.entry(10) {\n+            Occupied(_) => unreachable!(),\n+            Vacant(view) => {\n+                assert_eq!(*view.insert(1000), 1000);\n+            }\n+        }\n+        assert_eq!(map.get(&10).unwrap(), &1000);\n+        assert_eq!(map.len(), 6);\n+    }\n+\n+    #[test]\n+    fn test_entry_take_doesnt_corrupt() {\n+        // Test for #19292\n+        fn check(m: &HashMap<isize, ()>) {\n+            for k in m.keys() {\n+                assert!(m.contains_key(k),\n+                        \"{} is in keys() but not in the map?\", k);\n+            }\n+        }\n+\n+        let mut m = HashMap::new();\n+        let mut rng = weak_rng();\n+\n+        // Populate the map with some items.\n+        for _ in 0..50 {\n+            let x = rng.gen_range(-10, 10);\n+            m.insert(x, ());\n+        }\n+\n+        for i in 0..1000 {\n+            let x = rng.gen_range(-10, 10);\n+            match m.entry(x) {\n+                Vacant(_) => {},\n+                Occupied(e) => {\n+                    println!(\"{}: remove {}\", i, x);\n+                    e.remove();\n+                },\n+            }\n+\n+            check(&m);\n+        }\n+    }\n+}"}, {"sha": "39c1458b720019cd84f52245f7e7204f085cfe88", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -12,6 +12,14 @@\n \n mod bench;\n mod table;\n+#[cfg(stage0)]\n+#[path = \"map_stage0.rs\"]\n pub mod map;\n+#[cfg(not(stage0))]\n+pub mod map;\n+#[cfg(stage0)]\n+#[path = \"set_stage0.rs\"]\n+pub mod set;\n+#[cfg(not(stage0))]\n pub mod set;\n pub mod state;"}, {"sha": "7ff76452c1a804f9b4647acbc9ba031b1497d6bb", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 48, "deletions": 73, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -17,14 +17,14 @@ use core::marker::Sized;\n use default::Default;\n use fmt::Debug;\n use fmt;\n-use hash::{self, Hash};\n+use hash::Hash;\n use iter::{\n     Iterator, IntoIterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend,\n };\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n-use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState, Hasher};\n+use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState};\n use super::state::HashState;\n \n // Future Optimization (FIXME!)\n@@ -97,7 +97,7 @@ pub struct HashSet<T, S = RandomState> {\n     map: HashMap<T, (), S>\n }\n \n-impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n+impl<T: Hash + Eq> HashSet<T, RandomState> {\n     /// Create an empty HashSet.\n     ///\n     /// # Example\n@@ -128,10 +128,8 @@ impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     }\n }\n \n-impl<T, S, H> HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> HashSet<T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n@@ -462,7 +460,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<H> + Eq\n+        where Q: BorrowFrom<T> + Hash + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -572,17 +570,15 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<H> + Eq\n+        where Q: BorrowFrom<T> + Hash + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> PartialEq for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> PartialEq for HashSet<T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     fn eq(&self, other: &HashSet<T, S>) -> bool {\n         if self.len() != other.len() { return false; }\n@@ -592,17 +588,14 @@ impl<T, S, H> PartialEq for HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Eq for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> Eq for HashSet<T, S>\n+    where T: Eq + Hash, S: HashState\n {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> fmt::Debug for HashSet<T, S>\n-    where T: Eq + Hash<H> + fmt::Debug,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> fmt::Debug for HashSet<T, S>\n+    where T: Eq + Hash + fmt::Debug,\n+          S: HashState\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashSet {{\"));\n@@ -617,10 +610,9 @@ impl<T, S, H> fmt::Debug for HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> FromIterator<T> for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> FromIterator<T> for HashSet<T, S>\n+    where T: Eq + Hash,\n+          S: HashState + Default,\n {\n     fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, S> {\n         let lower = iter.size_hint().0;\n@@ -631,10 +623,9 @@ impl<T, S, H> FromIterator<T> for HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Extend<T> for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> Extend<T> for HashSet<T, S>\n+    where T: Eq + Hash,\n+          S: HashState,\n {\n     fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n         for k in iter {\n@@ -644,10 +635,9 @@ impl<T, S, H> Extend<T> for HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> Default for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> Default for HashSet<T, S>\n+    where T: Eq + Hash,\n+          S: HashState + Default,\n {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn default() -> HashSet<T, S> {\n@@ -656,10 +646,9 @@ impl<T, S, H> Default for HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, 'b, T, S> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash + Clone,\n+          S: HashState + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -689,10 +678,9 @@ impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, 'b, T, S> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash + Clone,\n+          S: HashState + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -722,10 +710,9 @@ impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, 'b, T, S> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash + Clone,\n+          S: HashState + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -755,10 +742,9 @@ impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n-    where T: Eq + Hash<H> + Clone,\n-          S: HashState<Hasher=H> + Default,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, 'b, T, S> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash + Clone,\n+          S: HashState + Default,\n {\n     type Output = HashSet<T, S>;\n \n@@ -836,10 +822,8 @@ pub struct Union<'a, T: 'a, S: 'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, T, S> IntoIterator for &'a HashSet<T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     type Item = &'a T;\n     type IntoIter = Iter<'a, T>;\n@@ -850,10 +834,9 @@ impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T, S, H> IntoIterator for HashSet<T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<T, S> IntoIterator for HashSet<T, S>\n+    where T: Eq + Hash,\n+          S: HashState\n {\n     type Item = T;\n     type IntoIter = IntoIter<T>;\n@@ -900,10 +883,8 @@ impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, T, S> Iterator for Intersection<'a, T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     type Item = &'a T;\n \n@@ -925,10 +906,8 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, T, S> Iterator for Difference<'a, T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     type Item = &'a T;\n \n@@ -950,10 +929,8 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, T, S> Iterator for SymmetricDifference<'a, T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     type Item = &'a T;\n \n@@ -962,10 +939,8 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T, S, H> Iterator for Union<'a, T, S>\n-    where T: Eq + Hash<H>,\n-          S: HashState<Hasher=H>,\n-          H: hash::Hasher<Output=u64>\n+impl<'a, T, S> Iterator for Union<'a, T, S>\n+    where T: Eq + Hash, S: HashState\n {\n     type Item = &'a T;\n "}, {"sha": "3bc22236a47f25a4c546d822831e869161c7b21c", "filename": "src/libstd/collections/hash/set_stage0.rs", "status": "added", "additions": 1251, "deletions": 0, "changes": 1251, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -0,0 +1,1251 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// ignore-lexer-test FIXME #15883\n+\n+use borrow::BorrowFrom;\n+use clone::Clone;\n+use cmp::{Eq, PartialEq};\n+use core::marker::Sized;\n+use default::Default;\n+use fmt::Debug;\n+use fmt;\n+use hash::{self, Hash};\n+use iter::{\n+    Iterator, IntoIterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend,\n+};\n+use ops::{BitOr, BitAnd, BitXor, Sub};\n+use option::Option::{Some, None, self};\n+\n+use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState, Hasher};\n+use super::state::HashState;\n+\n+// Future Optimization (FIXME!)\n+// =============================\n+//\n+// Iteration over zero sized values is a noop. There is no need\n+// for `bucket.val` in the case of HashSet. I suppose we would need HKT\n+// to get rid of it properly.\n+\n+/// An implementation of a hash set using the underlying representation of a\n+/// HashMap where the value is (). As with the `HashMap` type, a `HashSet`\n+/// requires that the elements implement the `Eq` and `Hash` traits.\n+///\n+/// # Example\n+///\n+/// ```\n+/// use std::collections::HashSet;\n+/// // Type inference lets us omit an explicit type signature (which\n+/// // would be `HashSet<&str>` in this example).\n+/// let mut books = HashSet::new();\n+///\n+/// // Add some books.\n+/// books.insert(\"A Dance With Dragons\");\n+/// books.insert(\"To Kill a Mockingbird\");\n+/// books.insert(\"The Odyssey\");\n+/// books.insert(\"The Great Gatsby\");\n+///\n+/// // Check for a specific one.\n+/// if !books.contains(&(\"The Winds of Winter\")) {\n+///     println!(\"We have {} books, but The Winds of Winter ain't one.\",\n+///              books.len());\n+/// }\n+///\n+/// // Remove a book.\n+/// books.remove(&\"The Odyssey\");\n+///\n+/// // Iterate over everything.\n+/// for book in books.iter() {\n+///     println!(\"{}\", *book);\n+/// }\n+/// ```\n+///\n+/// The easiest way to use `HashSet` with a custom type is to derive\n+/// `Eq` and `Hash`. We must also derive `PartialEq`, this will in the\n+/// future be implied by `Eq`.\n+///\n+/// ```\n+/// use std::collections::HashSet;\n+/// #[derive(Hash, Eq, PartialEq, Debug)]\n+/// struct Viking<'a> {\n+///     name: &'a str,\n+///     power: usize,\n+/// }\n+///\n+/// let mut vikings = HashSet::new();\n+///\n+/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n+/// vikings.insert(Viking { name: \"Einar\", power: 9 });\n+/// vikings.insert(Viking { name: \"Olaf\", power: 4 });\n+/// vikings.insert(Viking { name: \"Harald\", power: 8 });\n+///\n+/// // Use derived implementation to print the vikings.\n+/// for x in vikings.iter() {\n+///     println!(\"{:?}\", x);\n+/// }\n+/// ```\n+#[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct HashSet<T, S = RandomState> {\n+    map: HashMap<T, (), S>\n+}\n+\n+impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n+    /// Create an empty HashSet.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn new() -> HashSet<T, RandomState> {\n+        HashSet::with_capacity(INITIAL_CAPACITY)\n+    }\n+\n+    /// Create an empty HashSet with space for at least `n` elements in\n+    /// the hash table.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::with_capacity(10);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn with_capacity(capacity: usize) -> HashSet<T, RandomState> {\n+        HashSet { map: HashMap::with_capacity(capacity) }\n+    }\n+}\n+\n+impl<T, S, H> HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    /// Creates a new empty hash set which will use the given hasher to hash\n+    /// keys.\n+    ///\n+    /// The hash set is also created with the default initial capacity.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let mut set = HashSet::with_hash_state(s);\n+    /// set.insert(2);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n+        HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n+    }\n+\n+    /// Create an empty HashSet with space for at least `capacity`\n+    /// elements in the hash table, using `hasher` to hash the keys.\n+    ///\n+    /// Warning: `hasher` is normally randomly generated, and\n+    /// is designed to allow `HashSet`s to be resistant to attacks that\n+    /// cause many collisions and very poor performance. Setting it\n+    /// manually using this function can expose a DoS attack vector.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let s = RandomState::new();\n+    /// let mut set = HashSet::with_capacity_and_hash_state(10, s);\n+    /// set.insert(1);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n+    pub fn with_capacity_and_hash_state(capacity: usize, hash_state: S)\n+                                        -> HashSet<T, S> {\n+        HashSet {\n+            map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n+        }\n+    }\n+\n+    /// Returns the number of elements the set can hold without reallocating.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let set: HashSet<int> = HashSet::with_capacity(100);\n+    /// assert!(set.capacity() >= 100);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn capacity(&self) -> usize {\n+        self.map.capacity()\n+    }\n+\n+    /// Reserves capacity for at least `additional` more elements to be inserted\n+    /// in the `HashSet`. The collection may reserve more space to avoid\n+    /// frequent reallocations.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the new allocation size overflows `usize`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set: HashSet<int> = HashSet::new();\n+    /// set.reserve(10);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn reserve(&mut self, additional: usize) {\n+        self.map.reserve(additional)\n+    }\n+\n+    /// Shrinks the capacity of the set as much as possible. It will drop\n+    /// down as much as possible while maintaining the internal rules\n+    /// and possibly leaving some space in accordance with the resize policy.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<int> = HashSet::with_capacity(100);\n+    /// set.insert(1);\n+    /// set.insert(2);\n+    /// assert!(set.capacity() >= 100);\n+    /// set.shrink_to_fit();\n+    /// assert!(set.capacity() >= 2);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.map.shrink_to_fit()\n+    }\n+\n+    /// An iterator visiting all elements in arbitrary order.\n+    /// Iterator element type is &'a T.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\");\n+    /// set.insert(\"b\");\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in set.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn iter(&self) -> Iter<T> {\n+        Iter { iter: self.map.keys() }\n+    }\n+\n+    /// Creates a consuming iterator, that is, one that moves each value out\n+    /// of the set in arbitrary order. The set cannot be used after calling\n+    /// this.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let mut set = HashSet::new();\n+    /// set.insert(\"a\".to_string());\n+    /// set.insert(\"b\".to_string());\n+    ///\n+    /// // Not possible to collect to a Vec<String> with a regular `.iter()`.\n+    /// let v: Vec<String> = set.into_iter().collect();\n+    ///\n+    /// // Will print in an arbitrary order.\n+    /// for x in v.iter() {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_iter(self) -> IntoIter<T> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first;\n+\n+        IntoIter { iter: self.map.into_iter().map(first) }\n+    }\n+\n+    /// Visit the values representing the difference.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Can be seen as `a - b`.\n+    /// for x in a.difference(&b) {\n+    ///     println!(\"{}\", x); // Print 1\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.difference(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1].iter().map(|&x| x).collect());\n+    ///\n+    /// // Note that difference is not symmetric,\n+    /// // and `b - a` means something else:\n+    /// let diff: HashSet<int> = b.difference(&a).map(|&x| x).collect();\n+    /// assert_eq!(diff, [4].iter().map(|&x| x).collect());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n+        Difference {\n+            iter: self.iter(),\n+            other: other,\n+        }\n+    }\n+\n+    /// Visit the values representing the symmetric difference.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 4 in arbitrary order.\n+    /// for x in a.symmetric_difference(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff1: HashSet<int> = a.symmetric_difference(&b).map(|&x| x).collect();\n+    /// let diff2: HashSet<int> = b.symmetric_difference(&a).map(|&x| x).collect();\n+    ///\n+    /// assert_eq!(diff1, diff2);\n+    /// assert_eq!(diff1, [1, 4].iter().map(|&x| x).collect());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n+        -> SymmetricDifference<'a, T, S> {\n+        SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n+    }\n+\n+    /// Visit the values representing the intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 2, 3 in arbitrary order.\n+    /// for x in a.intersection(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.intersection(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [2, 3].iter().map(|&x| x).collect());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n+        Intersection {\n+            iter: self.iter(),\n+            other: other,\n+        }\n+    }\n+\n+    /// Visit the values representing the union.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// let a: HashSet<int> = [1, 2, 3].iter().map(|&x| x).collect();\n+    /// let b: HashSet<int> = [4, 2, 3, 4].iter().map(|&x| x).collect();\n+    ///\n+    /// // Print 1, 2, 3, 4 in arbitrary order.\n+    /// for x in a.union(&b) {\n+    ///     println!(\"{}\", x);\n+    /// }\n+    ///\n+    /// let diff: HashSet<int> = a.union(&b).map(|&x| x).collect();\n+    /// assert_eq!(diff, [1, 2, 3, 4].iter().map(|&x| x).collect());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n+        Union { iter: self.iter().chain(other.difference(self)) }\n+    }\n+\n+    /// Return the number of elements in the set\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert_eq!(v.len(), 0);\n+    /// v.insert(1);\n+    /// assert_eq!(v.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn len(&self) -> usize { self.map.len() }\n+\n+    /// Returns true if the set contains no elements\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// assert!(v.is_empty());\n+    /// v.insert(1);\n+    /// assert!(!v.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_empty(&self) -> bool { self.map.len() == 0 }\n+\n+    /// Clears the set, returning all elements in an iterator.\n+    #[inline]\n+    #[unstable(feature = \"std_misc\",\n+               reason = \"matches collection reform specification, waiting for dust to settle\")]\n+    pub fn drain(&mut self) -> Drain<T> {\n+        fn first<A, B>((a, _): (A, B)) -> A { a }\n+        let first: fn((T, ())) -> T = first; // coerce to fn pointer\n+\n+        Drain { iter: self.map.drain().map(first) }\n+    }\n+\n+    /// Clears the set, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut v = HashSet::new();\n+    /// v.insert(1);\n+    /// v.clear();\n+    /// assert!(v.is_empty());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn clear(&mut self) { self.map.clear() }\n+\n+    /// Returns `true` if the set contains a value.\n+    ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// assert_eq!(set.contains(&1), true);\n+    /// assert_eq!(set.contains(&4), false);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<H> + Eq\n+    {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Returns `true` if the set has no elements in common with `other`.\n+    /// This is equivalent to checking for an empty intersection.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut b = HashSet::new();\n+    ///\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(4);\n+    /// assert_eq!(a.is_disjoint(&b), true);\n+    /// b.insert(1);\n+    /// assert_eq!(a.is_disjoint(&b), false);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n+        self.iter().all(|v| !other.contains(v))\n+    }\n+\n+    /// Returns `true` if the set is a subset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let sup: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// let mut set = HashSet::new();\n+    ///\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_subset(&sup), true);\n+    /// set.insert(4);\n+    /// assert_eq!(set.is_subset(&sup), false);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n+        self.iter().all(|v| other.contains(v))\n+    }\n+\n+    /// Returns `true` if the set is a superset of another.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let sub: HashSet<_> = [1, 2].iter().cloned().collect();\n+    /// let mut set = HashSet::new();\n+    ///\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(0);\n+    /// set.insert(1);\n+    /// assert_eq!(set.is_superset(&sub), false);\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.is_superset(&sub), true);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n+        other.is_subset(self)\n+    }\n+\n+    /// Adds a value to the set. Returns `true` if the value was not already\n+    /// present in the set.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set = HashSet::new();\n+    ///\n+    /// assert_eq!(set.insert(2), true);\n+    /// assert_eq!(set.insert(2), false);\n+    /// assert_eq!(set.len(), 1);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, value: T) -> bool { self.map.insert(value, ()).is_none() }\n+\n+    /// Removes a value from the set. Returns `true` if the value was\n+    /// present in the set.\n+    ///\n+    /// The value may be any borrowed form of the set's value type, but\n+    /// `Hash` and `Eq` on the borrowed form *must* match those for\n+    /// the value type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set = HashSet::new();\n+    ///\n+    /// set.insert(2);\n+    /// assert_eq!(set.remove(&2), true);\n+    /// assert_eq!(set.remove(&2), false);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n+        where Q: BorrowFrom<T> + Hash<H> + Eq\n+    {\n+        self.map.remove(value).is_some()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, S, H> PartialEq for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn eq(&self, other: &HashSet<T, S>) -> bool {\n+        if self.len() != other.len() { return false; }\n+\n+        self.iter().all(|key| other.contains(key))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, S, H> Eq for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, S, H> fmt::Debug for HashSet<T, S>\n+    where T: Eq + Hash<H> + fmt::Debug,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        try!(write!(f, \"HashSet {{\"));\n+\n+        for (i, x) in self.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{:?}\", *x));\n+        }\n+\n+        write!(f, \"}}\")\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, S, H> FromIterator<T> for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, S> {\n+        let lower = iter.size_hint().0;\n+        let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n+        set.extend(iter);\n+        set\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, S, H> Extend<T> for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn extend<I: Iterator<Item=T>>(&mut self, iter: I) {\n+        for k in iter {\n+            self.insert(k);\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T, S, H> Default for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn default() -> HashSet<T, S> {\n+        HashSet::with_hash_state(Default::default())\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n+\n+    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set = &a | &b;\n+    ///\n+    /// let mut i = 0;\n+    /// let expected = [1, 2, 3, 4, 5];\n+    /// for x in set.iter() {\n+    ///     assert!(expected.contains(x));\n+    ///     i += 1;\n+    /// }\n+    /// assert_eq!(i, expected.len());\n+    /// ```\n+    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n+        self.union(rhs).cloned().collect()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n+\n+    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![2, 3, 4].into_iter().collect();\n+    ///\n+    /// let set = &a & &b;\n+    ///\n+    /// let mut i = 0;\n+    /// let expected = [2, 3];\n+    /// for x in set.iter() {\n+    ///     assert!(expected.contains(x));\n+    ///     i += 1;\n+    /// }\n+    /// assert_eq!(i, expected.len());\n+    /// ```\n+    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n+        self.intersection(rhs).cloned().collect()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n+\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set = &a ^ &b;\n+    ///\n+    /// let mut i = 0;\n+    /// let expected = [1, 2, 4, 5];\n+    /// for x in set.iter() {\n+    ///     assert!(expected.contains(x));\n+    ///     i += 1;\n+    /// }\n+    /// assert_eq!(i, expected.len());\n+    /// ```\n+    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n+        self.symmetric_difference(rhs).cloned().collect()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n+\n+    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let a: HashSet<_> = vec![1, 2, 3].into_iter().collect();\n+    /// let b: HashSet<_> = vec![3, 4, 5].into_iter().collect();\n+    ///\n+    /// let set = &a - &b;\n+    ///\n+    /// let mut i = 0;\n+    /// let expected = [1, 2];\n+    /// for x in set.iter() {\n+    ///     assert!(expected.contains(x));\n+    ///     i += 1;\n+    /// }\n+    /// assert_eq!(i, expected.len());\n+    /// ```\n+    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n+        self.difference(rhs).cloned().collect()\n+    }\n+}\n+\n+/// HashSet iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Iter<'a, K: 'a> {\n+    iter: Keys<'a, K, ()>\n+}\n+\n+/// HashSet move iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct IntoIter<K> {\n+    iter: Map<map::IntoIter<K, ()>, fn((K, ())) -> K>\n+}\n+\n+/// HashSet drain iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Drain<'a, K: 'a> {\n+    iter: Map<map::Drain<'a, K, ()>, fn((K, ())) -> K>,\n+}\n+\n+/// Intersection iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Intersection<'a, T: 'a, S: 'a> {\n+    // iterator of the first set\n+    iter: Iter<'a, T>,\n+    // the second set\n+    other: &'a HashSet<T, S>,\n+}\n+\n+/// Difference iterator\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Difference<'a, T: 'a, S: 'a> {\n+    // iterator of the first set\n+    iter: Iter<'a, T>,\n+    // the second set\n+    other: &'a HashSet<T, S>,\n+}\n+\n+/// Symmetric difference iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n+    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n+}\n+\n+/// Set union iterator.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Union<'a, T: 'a, S: 'a> {\n+    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n+}\n+\n+impl<'a, T, S, H> IntoIterator for &'a HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+impl<T, S, H> IntoIterator for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+\n+    fn into_iter(self) -> IntoIter<T> {\n+        self.into_iter()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K> Iterator for Iter<'a, K> {\n+    type Item = &'a K;\n+\n+    fn next(&mut self) -> Option<&'a K> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K> ExactSizeIterator for Iter<'a, K> {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K> Iterator for IntoIter<K> {\n+    type Item = K;\n+\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<K> ExactSizeIterator for IntoIter<K> {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K> Iterator for Drain<'a, K> {\n+    type Item = K;\n+\n+    fn next(&mut self) -> Option<K> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K> ExactSizeIterator for Drain<'a, K> {\n+    fn len(&self) -> usize { self.iter.len() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = &'a T;\n+\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match self.iter.next() {\n+                None => return None,\n+                Some(elt) => if self.other.contains(elt) {\n+                    return Some(elt)\n+                },\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = &'a T;\n+\n+    fn next(&mut self) -> Option<&'a T> {\n+        loop {\n+            match self.iter.next() {\n+                None => return None,\n+                Some(elt) => if !self.other.contains(elt) {\n+                    return Some(elt)\n+                },\n+            }\n+        }\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = &'a T;\n+\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, T, S, H> Iterator for Union<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Item = &'a T;\n+\n+    fn next(&mut self) -> Option<&'a T> { self.iter.next() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n+}\n+\n+#[cfg(test)]\n+mod test_set {\n+    use prelude::v1::*;\n+\n+    use super::HashSet;\n+\n+    #[test]\n+    fn test_disjoint() {\n+        let mut xs = HashSet::new();\n+        let mut ys = HashSet::new();\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(5));\n+        assert!(ys.insert(11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(xs.insert(7));\n+        assert!(xs.insert(19));\n+        assert!(xs.insert(4));\n+        assert!(ys.insert(2));\n+        assert!(ys.insert(-11));\n+        assert!(xs.is_disjoint(&ys));\n+        assert!(ys.is_disjoint(&xs));\n+        assert!(ys.insert(7));\n+        assert!(!xs.is_disjoint(&ys));\n+        assert!(!ys.is_disjoint(&xs));\n+    }\n+\n+    #[test]\n+    fn test_subset_and_superset() {\n+        let mut a = HashSet::new();\n+        assert!(a.insert(0));\n+        assert!(a.insert(5));\n+        assert!(a.insert(11));\n+        assert!(a.insert(7));\n+\n+        let mut b = HashSet::new();\n+        assert!(b.insert(0));\n+        assert!(b.insert(7));\n+        assert!(b.insert(19));\n+        assert!(b.insert(250));\n+        assert!(b.insert(11));\n+        assert!(b.insert(200));\n+\n+        assert!(!a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(!b.is_superset(&a));\n+\n+        assert!(b.insert(5));\n+\n+        assert!(a.is_subset(&b));\n+        assert!(!a.is_superset(&b));\n+        assert!(!b.is_subset(&a));\n+        assert!(b.is_superset(&a));\n+    }\n+\n+    #[test]\n+    fn test_iterate() {\n+        let mut a = HashSet::new();\n+        for i in 0..32 {\n+            assert!(a.insert(i));\n+        }\n+        let mut observed: u32 = 0;\n+        for k in &a {\n+            observed |= 1 << *k;\n+        }\n+        assert_eq!(observed, 0xFFFF_FFFF);\n+    }\n+\n+    #[test]\n+    fn test_intersection() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(11));\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(77));\n+        assert!(a.insert(103));\n+        assert!(a.insert(5));\n+        assert!(a.insert(-5));\n+\n+        assert!(b.insert(2));\n+        assert!(b.insert(11));\n+        assert!(b.insert(77));\n+        assert!(b.insert(-9));\n+        assert!(b.insert(-42));\n+        assert!(b.insert(5));\n+        assert!(b.insert(3));\n+\n+        let mut i = 0;\n+        let expected = [3, 5, 11, 77];\n+        for x in a.intersection(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_difference() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+\n+        let mut i = 0;\n+        let expected = [1, 5, 11];\n+        for x in a.difference(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_symmetric_difference() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+\n+        assert!(b.insert(-2));\n+        assert!(b.insert(3));\n+        assert!(b.insert(9));\n+        assert!(b.insert(14));\n+        assert!(b.insert(22));\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 5, 11, 14, 22];\n+        for x in a.symmetric_difference(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_union() {\n+        let mut a = HashSet::new();\n+        let mut b = HashSet::new();\n+\n+        assert!(a.insert(1));\n+        assert!(a.insert(3));\n+        assert!(a.insert(5));\n+        assert!(a.insert(9));\n+        assert!(a.insert(11));\n+        assert!(a.insert(16));\n+        assert!(a.insert(19));\n+        assert!(a.insert(24));\n+\n+        assert!(b.insert(-2));\n+        assert!(b.insert(1));\n+        assert!(b.insert(5));\n+        assert!(b.insert(9));\n+        assert!(b.insert(13));\n+        assert!(b.insert(19));\n+\n+        let mut i = 0;\n+        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n+        for x in a.union(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+    }\n+\n+    #[test]\n+    fn test_from_iter() {\n+        let xs = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n+\n+        let set: HashSet<_> = xs.iter().cloned().collect();\n+\n+        for x in &xs {\n+            assert!(set.contains(x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_move_iter() {\n+        let hs = {\n+            let mut hs = HashSet::new();\n+\n+            hs.insert('a');\n+            hs.insert('b');\n+\n+            hs\n+        };\n+\n+        let v = hs.into_iter().collect::<Vec<char>>();\n+        assert!(['a', 'b'] == v || ['b', 'a'] == v);\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n+        // These constants once happened to expose a bug in insert().\n+        // I'm keeping them around to prevent a regression.\n+        let mut s1 = HashSet::new();\n+\n+        s1.insert(1);\n+        s1.insert(2);\n+        s1.insert(3);\n+\n+        let mut s2 = HashSet::new();\n+\n+        s2.insert(1);\n+        s2.insert(2);\n+\n+        assert!(s1 != s2);\n+\n+        s2.insert(3);\n+\n+        assert_eq!(s1, s2);\n+    }\n+\n+    #[test]\n+    fn test_show() {\n+        let mut set = HashSet::new();\n+        let empty = HashSet::<i32>::new();\n+\n+        set.insert(1);\n+        set.insert(2);\n+\n+        let set_str = format!(\"{:?}\", set);\n+\n+        assert!(set_str == \"HashSet {1, 2}\" || set_str == \"HashSet {2, 1}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"HashSet {}\");\n+    }\n+\n+    #[test]\n+    fn test_trivial_drain() {\n+        let mut s = HashSet::<i32>::new();\n+        for _ in s.drain() {}\n+        assert!(s.is_empty());\n+        drop(s);\n+\n+        let mut s = HashSet::<i32>::new();\n+        drop(s.drain());\n+        assert!(s.is_empty());\n+    }\n+\n+    #[test]\n+    fn test_drain() {\n+        let mut s: HashSet<_> = (1..100).collect();\n+\n+        // try this a bunch of times to make sure we don't screw up internal state.\n+        for _ in 0..20 {\n+            assert_eq!(s.len(), 99);\n+\n+            {\n+                let mut last_i = 0;\n+                let mut d = s.drain();\n+                for (i, x) in d.by_ref().take(50).enumerate() {\n+                    last_i = i;\n+                    assert!(x != 0);\n+                }\n+                assert_eq!(last_i, 49);\n+            }\n+\n+            for _ in &s { panic!(\"s should be empty!\"); }\n+\n+            // reset to try again.\n+            s.extend(1..100);\n+        }\n+    }\n+}"}, {"sha": "7114da93ea0277f95653cf4ece8470434b3fe3e3", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -141,6 +141,7 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n+#[cfg(stage0)]\n pub fn make_hash<T: ?Sized, S, H>(hash_state: &S, t: &T) -> SafeHash\n     where T: Hash<H>,\n           S: HashState<Hasher=H>,\n@@ -155,6 +156,22 @@ pub fn make_hash<T: ?Sized, S, H>(hash_state: &S, t: &T) -> SafeHash\n     SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n }\n \n+/// We need to remove hashes of 0. That's reserved for empty buckets.\n+/// This function wraps up `hash_keyed` to be the only way outside this\n+/// module to generate a SafeHash.\n+#[cfg(not(stage0))]\n+pub fn make_hash<T: ?Sized, S>(hash_state: &S, t: &T) -> SafeHash\n+    where T: Hash, S: HashState\n+{\n+    let mut state = hash_state.hasher();\n+    t.hash(&mut state);\n+    // We need to avoid 0u64 in order to prevent collisions with\n+    // EMPTY_HASH. We can maintain our precious uniform distribution\n+    // of initial indexes by unconditionally setting the MSB,\n+    // effectively reducing 64-bits hashes to 63 bits.\n+    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n+}\n+\n // `replace` casts a `*u64` to a `*SafeHash`. Since we statically\n // ensure that a `FullBucket` points to an index with a non-zero hash,\n // and a `SafeHash` is just a `u64` with a different name, this is"}, {"sha": "4e50e1c293fb5d33fdabbbe6d1b802f47a4eb881", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -40,7 +40,8 @@ use mem;\n use string::{String, CowString};\n use ops;\n use cmp;\n-use hash::{Hash, Hasher, Writer};\n+use hash::{Hash, Hasher};\n+#[cfg(stage0)] use hash::Writer;\n use old_path::{Path, GenericPath};\n \n use sys::os_str::{Buf, Slice};\n@@ -162,12 +163,21 @@ impl Ord for OsString {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'a, S: Hasher + Writer> Hash<S> for OsString {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (&**self).hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Hash for OsString {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (&**self).hash(state)\n+    }\n+}\n \n impl OsStr {\n     /// Coerce directly from a `&str` slice to a `&OsStr` slice.\n@@ -253,12 +263,21 @@ impl Ord for OsStr {\n     fn cmp(&self, other: &OsStr) -> cmp::Ordering { self.bytes().cmp(other.bytes()) }\n }\n \n+#[cfg(stage0)]\n impl<'a, S: Hasher + Writer> Hash<S> for OsStr {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.bytes().hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Hash for OsStr {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.bytes().hash(state)\n+    }\n+}\n \n impl Debug for OsStr {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {"}, {"sha": "51944adf3b40395f7adb88b57943ce2fb21a5b3d", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -147,6 +147,7 @@ impl PartialEq for Repr {\n }\n impl Eq for Repr {}\n \n+#[cfg(stage0)]\n impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Repr {\n     fn hash(&self, s: &mut S) {\n         match *self {\n@@ -160,6 +161,21 @@ impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Repr {\n         }\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for Repr {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        match *self {\n+            Repr::V4(ref a) => {\n+                (a.sin_family, a.sin_port, a.sin_addr.s_addr).hash(s)\n+            }\n+            Repr::V6(ref a) => {\n+                (a.sin6_family, a.sin6_port, &a.sin6_addr.s6_addr,\n+                 a.sin6_flowinfo, a.sin6_scope_id).hash(s)\n+            }\n+        }\n+    }\n+}\n \n /// A trait for objects which can be converted or resolved to one or more\n /// `SocketAddr` values."}, {"sha": "571a1b03ef07fbd879a1e98c7caafe1838506d87", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -189,11 +189,19 @@ impl PartialEq for Ipv4Addr {\n }\n impl Eq for Ipv4Addr {}\n \n+#[cfg(stage0)]\n impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv4Addr {\n     fn hash(&self, s: &mut S) {\n         self.inner.s_addr.hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for Ipv4Addr {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        self.inner.s_addr.hash(s)\n+    }\n+}\n \n impl PartialOrd for Ipv4Addr {\n     fn partial_cmp(&self, other: &Ipv4Addr) -> Option<Ordering> {\n@@ -421,11 +429,19 @@ impl PartialEq for Ipv6Addr {\n }\n impl Eq for Ipv6Addr {}\n \n+#[cfg(stage0)]\n impl<S: hash::Hasher + hash::Writer> hash::Hash<S> for Ipv6Addr {\n     fn hash(&self, s: &mut S) {\n         self.inner.s6_addr.hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for Ipv6Addr {\n+    fn hash<H: hash::Hasher>(&self, s: &mut H) {\n+        self.inner.s6_addr.hash(s)\n+    }\n+}\n \n impl PartialOrd for Ipv6Addr {\n     fn partial_cmp(&self, other: &Ipv6Addr) -> Option<Ordering> {"}, {"sha": "b0fec102103da4dc4e981a8402c56664accbb084", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -100,12 +100,21 @@ impl FromStr for Path {\n #[derive(Debug, Clone, PartialEq, Copy)]\n pub struct ParsePathError;\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.repr.hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for Path {\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.repr.hash(state)\n+    }\n+}\n \n impl BytesContainer for Path {\n     #[inline]"}, {"sha": "4754efbd1fe8072c9cfc276b41d341e4f543bf0f", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -127,6 +127,7 @@ impl FromStr for Path {\n #[derive(Debug, Clone, PartialEq, Copy)]\n pub struct ParsePathError;\n \n+#[cfg(stage0)]\n impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n     #[cfg(not(test))]\n     #[inline]\n@@ -140,6 +141,21 @@ impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Path {\n         // No-op because the `hash` implementation will be wrong.\n     }\n }\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl hash::Hash for Path {\n+    #[cfg(not(test))]\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        self.repr.hash(state)\n+    }\n+\n+    #[cfg(test)]\n+    #[inline]\n+    fn hash<H: hash::Hasher>(&self, _: &mut H) {\n+        // No-op because the `hash` implementation will be wrong.\n+    }\n+}\n \n impl BytesContainer for Path {\n     #[inline]"}, {"sha": "c4f2de7fb45cb8b7b9f18921d0b5f20558cade36", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -31,7 +31,8 @@ use ascii::*;\n use borrow::Cow;\n use cmp;\n use fmt;\n-use hash::{Hash, Writer, Hasher};\n+use hash::{Hash, Hasher};\n+#[cfg(stage0)] use hash::Writer;\n use iter::FromIterator;\n use mem;\n use num::Int;\n@@ -794,28 +795,54 @@ impl<'a> Iterator for EncodeWide<'a> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: Writer + Hasher> Hash<S> for CodePoint {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.value.hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+impl Hash for CodePoint {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.value.hash(state)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<S: Writer + Hasher> Hash<S> for Wtf8Buf {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         state.write(&self.bytes);\n         0xfeu8.hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+impl Hash for Wtf8Buf {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        state.write(&self.bytes);\n+        0xfeu8.hash(state)\n+    }\n+}\n \n+#[cfg(stage0)]\n impl<'a, S: Writer + Hasher> Hash<S> for Wtf8 {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         state.write(&self.bytes);\n         0xfeu8.hash(state)\n     }\n }\n+#[cfg(not(stage0))]\n+impl Hash for Wtf8 {\n+    #[inline]\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        state.write(&self.bytes);\n+        0xfeu8.hash(state)\n+    }\n+}\n \n impl AsciiExt for Wtf8 {\n     type Owned = Wtf8Buf;"}, {"sha": "b30ac889120c229343f6d48938c50658c24d891f", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -12,6 +12,7 @@ use prelude::v1::*;\n use self::Req::*;\n \n use collections::HashMap;\n+#[cfg(stage0)]\n use collections::hash_map::Hasher;\n use ffi::CString;\n use hash::Hash;\n@@ -63,6 +64,7 @@ impl Process {\n         mkerr_libc(r)\n     }\n \n+    #[cfg(stage0)]\n     pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n                               out_fd: Option<P>, err_fd: Option<P>)\n                               -> IoResult<Process>\n@@ -278,6 +280,214 @@ impl Process {\n             })\n         })\n     }\n+    #[cfg(not(stage0))]\n+    pub fn spawn<K, V, C, P>(cfg: &C, in_fd: Option<P>,\n+                              out_fd: Option<P>, err_fd: Option<P>)\n+                              -> IoResult<Process>\n+        where C: ProcessConfig<K, V>, P: AsInner<FileDesc>,\n+              K: BytesContainer + Eq + Hash, V: BytesContainer\n+    {\n+        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n+        use libc::funcs::bsd44::getdtablesize;\n+\n+        mod rustrt {\n+            extern {\n+                pub fn rust_unset_sigprocmask();\n+            }\n+        }\n+\n+        unsafe fn set_cloexec(fd: c_int) {\n+            let ret = c::ioctl(fd, c::FIOCLEX);\n+            assert_eq!(ret, 0);\n+        }\n+\n+        let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n+\n+        // temporary until unboxed closures land\n+        let cfg = unsafe {\n+            mem::transmute::<&ProcessConfig<K,V>,&'static ProcessConfig<K,V>>(cfg)\n+        };\n+\n+        with_envp(cfg.env(), move|envp: *const c_void| {\n+            with_argv(cfg.program(), cfg.args(), move|argv: *const *const libc::c_char| unsafe {\n+                let (input, mut output) = try!(sys::os::pipe());\n+\n+                // We may use this in the child, so perform allocations before the\n+                // fork\n+                let devnull = b\"/dev/null\\0\";\n+\n+                set_cloexec(output.fd());\n+\n+                let pid = fork();\n+                if pid < 0 {\n+                    return Err(super::last_error())\n+                } else if pid > 0 {\n+                    #[inline]\n+                    fn combine(arr: &[u8]) -> i32 {\n+                        let a = arr[0] as u32;\n+                        let b = arr[1] as u32;\n+                        let c = arr[2] as u32;\n+                        let d = arr[3] as u32;\n+\n+                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+                    }\n+\n+                    let p = Process{ pid: pid };\n+                    drop(output);\n+                    let mut bytes = [0; 8];\n+                    return match input.read(&mut bytes) {\n+                        Ok(8) => {\n+                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                                \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                            let errno = combine(&bytes[0.. 4]);\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            Err(super::decode_error(errno))\n+                        }\n+                        Err(ref e) if e.kind == EndOfFile => Ok(p),\n+                        Err(e) => {\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                        },\n+                        Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                            assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n+                            panic!(\"short read on the CLOEXEC pipe\")\n+                        }\n+                    };\n+                }\n+\n+                // And at this point we've reached a special time in the life of the\n+                // child. The child must now be considered hamstrung and unable to\n+                // do anything other than syscalls really. Consider the following\n+                // scenario:\n+                //\n+                //      1. Thread A of process 1 grabs the malloc() mutex\n+                //      2. Thread B of process 1 forks(), creating thread C\n+                //      3. Thread C of process 2 then attempts to malloc()\n+                //      4. The memory of process 2 is the same as the memory of\n+                //         process 1, so the mutex is locked.\n+                //\n+                // This situation looks a lot like deadlock, right? It turns out\n+                // that this is what pthread_atfork() takes care of, which is\n+                // presumably implemented across platforms. The first thing that\n+                // threads to *before* forking is to do things like grab the malloc\n+                // mutex, and then after the fork they unlock it.\n+                //\n+                // Despite this information, libnative's spawn has been witnessed to\n+                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+                // all collected backtraces point at malloc/free traffic in the\n+                // child spawned process.\n+                //\n+                // For this reason, the block of code below should contain 0\n+                // invocations of either malloc of free (or their related friends).\n+                //\n+                // As an example of not having malloc/free traffic, we don't close\n+                // this file descriptor by dropping the FileDesc (which contains an\n+                // allocation). Instead we just close it manually. This will never\n+                // have the drop glue anyway because this code never returns (the\n+                // child will either exec() or invoke libc::exit)\n+                let _ = libc::close(input.fd());\n+\n+                fn fail(output: &mut FileDesc) -> ! {\n+                    let errno = sys::os::errno() as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(output.write(&bytes).is_ok());\n+                    unsafe { libc::_exit(1) }\n+                }\n+\n+                rustrt::rust_unset_sigprocmask();\n+\n+                // If a stdio file descriptor is set to be ignored (via a -1 file\n+                // descriptor), then we don't actually close it, but rather open\n+                // up /dev/null into that file descriptor. Otherwise, the first file\n+                // descriptor opened up in the child would be numbered as one of the\n+                // stdio file descriptors, which is likely to wreak havoc.\n+                let setup = |src: Option<P>, dst: c_int| {\n+                    let src = match src {\n+                        None => {\n+                            let flags = if dst == libc::STDIN_FILENO {\n+                                libc::O_RDONLY\n+                            } else {\n+                                libc::O_RDWR\n+                            };\n+                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n+                        }\n+                        Some(obj) => {\n+                            let fd = obj.as_inner().fd();\n+                            // Leak the memory and the file descriptor. We're in the\n+                            // child now an all our resources are going to be\n+                            // cleaned up very soon\n+                            mem::forget(obj);\n+                            fd\n+                        }\n+                    };\n+                    src != -1 && retry(|| dup2(src, dst)) != -1\n+                };\n+\n+                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+\n+                // close all other fds\n+                for fd in (3..getdtablesize()).rev() {\n+                    if fd != output.fd() {\n+                        let _ = close(fd as c_int);\n+                    }\n+                }\n+\n+                match cfg.gid() {\n+                    Some(u) => {\n+                        if libc::setgid(u as libc::gid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                match cfg.uid() {\n+                    Some(u) => {\n+                        // When dropping privileges from root, the `setgroups` call\n+                        // will remove any extraneous groups. If we don't call this,\n+                        // then even though our uid has dropped, we may still have\n+                        // groups that enable us to do super-user things. This will\n+                        // fail if we aren't root, so don't bother checking the\n+                        // return value, this is just done as an optimistic\n+                        // privilege dropping function.\n+                        extern {\n+                            fn setgroups(ngroups: libc::c_int,\n+                                         ptr: *const libc::c_void) -> libc::c_int;\n+                        }\n+                        let _ = setgroups(0, ptr::null());\n+\n+                        if libc::setuid(u as libc::uid_t) != 0 {\n+                            fail(&mut output);\n+                        }\n+                    }\n+                    None => {}\n+                }\n+                if cfg.detach() {\n+                    // Don't check the error of setsid because it fails if we're the\n+                    // process leader already. We just forked so it shouldn't return\n+                    // error, but ignore it anyway.\n+                    let _ = libc::setsid();\n+                }\n+                if !dirp.is_null() && chdir(dirp) == -1 {\n+                    fail(&mut output);\n+                }\n+                if !envp.is_null() {\n+                    *sys::os::environ() = envp as *const _;\n+                }\n+                let _ = execvp(*argv, argv as *mut _);\n+                fail(&mut output);\n+            })\n+        })\n+    }\n \n     pub fn wait(&self, deadline: u64) -> IoResult<ProcessExit> {\n         use cmp;\n@@ -556,6 +766,7 @@ fn with_argv<T,F>(prog: &CString, args: &[CString],\n     cb(ptrs.as_ptr())\n }\n \n+#[cfg(stage0)]\n fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n                       cb: F)\n                       -> T\n@@ -593,6 +804,44 @@ fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n         _ => cb(ptr::null())\n     }\n }\n+#[cfg(not(stage0))]\n+fn with_envp<K,V,T,F>(env: Option<&HashMap<K, V>>,\n+                      cb: F)\n+                      -> T\n+    where F : FnOnce(*const c_void) -> T,\n+          K : BytesContainer + Eq + Hash,\n+          V : BytesContainer\n+{\n+    // On posixy systems we can pass a char** for envp, which is a\n+    // null-terminated array of \"k=v\\0\" strings. Since we must create\n+    // these strings locally, yet expose a raw pointer to them, we\n+    // create a temporary vector to own the CStrings that outlives the\n+    // call to cb.\n+    match env {\n+        Some(env) => {\n+            let mut tmps = Vec::with_capacity(env.len());\n+\n+            for pair in env {\n+                let mut kv = Vec::new();\n+                kv.push_all(pair.0.container_as_bytes());\n+                kv.push('=' as u8);\n+                kv.push_all(pair.1.container_as_bytes());\n+                kv.push(0); // terminating null\n+                tmps.push(kv);\n+            }\n+\n+            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n+            let mut ptrs: Vec<*const libc::c_char> =\n+                tmps.iter()\n+                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n+                    .collect();\n+            ptrs.push(ptr::null());\n+\n+            cb(ptrs.as_ptr() as *const c_void)\n+        }\n+        _ => cb(ptr::null())\n+    }\n+}\n \n fn translate_status(status: c_int) -> ProcessExit {\n     #![allow(non_snake_case)]"}, {"sha": "48d11d16f2bc5d6cd0bb52e640b84cf600f3da3c", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -11,7 +11,6 @@\n use prelude::v1::*;\n \n use collections::HashMap;\n-use collections::hash_map::Hasher;\n use env;\n use ffi::{OsString, OsStr, CString};\n use fmt;"}, {"sha": "2149c7a7f77a7da72d86848fd952f24a415865ca", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -14,7 +14,6 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n-use parse::token::InternedString;\n use ptr::P;\n \n pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n@@ -26,30 +25,26 @@ pub fn expand_deriving_hash<F>(cx: &mut ExtCtxt,\n {\n \n     let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None,\n-                          vec!(box Literal(Path::new_local(\"__S\"))), true);\n-    let generics = LifetimeBounds {\n-        lifetimes: Vec::new(),\n-        bounds: vec!((\"__S\",\n-                      vec!(path_std!(cx, core::hash::Writer),\n-                           path_std!(cx, core::hash::Hasher)))),\n-    };\n-    let args = Path::new_local(\"__S\");\n-    let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n+                          vec!(), true);\n+    let arg = Path::new_local(\"__H\");\n     let hash_trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path,\n         additional_bounds: Vec::new(),\n-        generics: generics,\n+        generics: LifetimeBounds::empty(),\n         methods: vec!(\n             MethodDef {\n                 name: \"hash\",\n-                generics: LifetimeBounds::empty(),\n+                generics: LifetimeBounds {\n+                    lifetimes: Vec::new(),\n+                    bounds: vec![(\"__H\",\n+                                  vec![path_std!(cx, core::hash::Hasher)])],\n+                },\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(box Literal(args), Borrowed(None, MutMutable))),\n+                args: vec!(Ptr(box Literal(arg), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n-                attributes: attrs,\n+                attributes: vec![],\n                 combine_substructure: combine_substructure(box |a, b, c| {\n                     hash_substructure(a, b, c)\n                 })"}, {"sha": "3a7fa54edbdd772ab633557e8962b8041340846a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -28,7 +28,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(env)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(libc)]"}, {"sha": "adb5383a8fd544d0f666dbf74d92e2fb729f20d5", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -111,11 +111,18 @@ impl<T: Display> Display for P<T> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: Hasher, T: Hash<S>> Hash<S> for P<T> {\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<T: Hash> Hash for P<T> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        (**self).hash(state);\n+    }\n+}\n \n impl<T: 'static + Decodable> Decodable for P<T> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<P<T>, D::Error> {"}, {"sha": "58b5c44c960753288e97bab7f5106345aa485f97", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 75, "deletions": 1, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -18,9 +18,9 @@ use std::borrow::BorrowFrom;\n use std::cell::RefCell;\n use std::cmp::Ordering;\n use std::collections::HashMap;\n+#[cfg(stage0)] use std::collections::hash_map::Hasher;\n use std::fmt;\n use std::hash::Hash;\n-use std::collections::hash_map::Hasher;\n use std::ops::Deref;\n use std::rc::Rc;\n \n@@ -30,6 +30,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<Name,T> to get []\n+#[cfg(stage0)]\n impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n@@ -92,6 +93,70 @@ impl<T: Eq + Hash<Hasher> + Clone + 'static> Interner<T> {\n         *self.vect.borrow_mut() = Vec::new();\n     }\n }\n+// when traits can extend traits, we should extend index<Name,T> to get []\n+#[cfg(not(stage0))]\n+impl<T: Eq + Hash + Clone + 'static> Interner<T> {\n+    pub fn new() -> Interner<T> {\n+        Interner {\n+            map: RefCell::new(HashMap::new()),\n+            vect: RefCell::new(Vec::new()),\n+        }\n+    }\n+\n+    pub fn prefill(init: &[T]) -> Interner<T> {\n+        let rv = Interner::new();\n+        for v in init {\n+            rv.intern((*v).clone());\n+        }\n+        rv\n+    }\n+\n+    pub fn intern(&self, val: T) -> Name {\n+        let mut map = self.map.borrow_mut();\n+        match (*map).get(&val) {\n+            Some(&idx) => return idx,\n+            None => (),\n+        }\n+\n+        let mut vect = self.vect.borrow_mut();\n+        let new_idx = Name((*vect).len() as u32);\n+        (*map).insert(val.clone(), new_idx);\n+        (*vect).push(val);\n+        new_idx\n+    }\n+\n+    pub fn gensym(&self, val: T) -> Name {\n+        let mut vect = self.vect.borrow_mut();\n+        let new_idx = Name((*vect).len() as u32);\n+        // leave out of .map to avoid colliding\n+        (*vect).push(val);\n+        new_idx\n+    }\n+\n+    pub fn get(&self, idx: Name) -> T {\n+        let vect = self.vect.borrow();\n+        (*vect)[idx.usize()].clone()\n+    }\n+\n+    pub fn len(&self) -> usize {\n+        let vect = self.vect.borrow();\n+        (*vect).len()\n+    }\n+\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n+    where Q: BorrowFrom<T> + Eq + Hash {\n+        let map = self.map.borrow();\n+        match (*map).get(val) {\n+            Some(v) => Some(*v),\n+            None => None,\n+        }\n+    }\n+\n+    pub fn clear(&self) {\n+        *self.map.borrow_mut() = HashMap::new();\n+        *self.vect.borrow_mut() = Vec::new();\n+    }\n+}\n \n #[derive(Clone, PartialEq, Hash, PartialOrd)]\n pub struct RcStr {\n@@ -210,13 +275,22 @@ impl StrInterner {\n         self.vect.borrow().len()\n     }\n \n+    #[cfg(stage0)]\n     pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n     where Q: BorrowFrom<RcStr> + Eq + Hash<Hasher> {\n         match (*self.map.borrow()).get(val) {\n             Some(v) => Some(*v),\n             None => None,\n         }\n     }\n+    #[cfg(not(stage0))]\n+    pub fn find<Q: ?Sized>(&self, val: &Q) -> Option<Name>\n+    where Q: BorrowFrom<RcStr> + Eq + Hash {\n+        match (*self.map.borrow()).get(val) {\n+            Some(v) => Some(*v),\n+            None => None,\n+        }\n+    }\n \n     pub fn clear(&self) {\n         *self.map.borrow_mut() = HashMap::new();"}, {"sha": "a03048e39b9824f5547bd39fbdb28885de667c99", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -37,7 +37,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(env)]\n-#![feature(hash)]\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(old_path)]"}, {"sha": "e7b5820006b34d027c79eb27d6470b69b5b66b9d", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -12,7 +12,7 @@\n \n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n-use std::collections::hash_map::{self, Hasher};\n+use std::collections::hash_map;\n use std::hash::Hash;\n use std::mem;\n use std::num::{Float, FromPrimitive};\n@@ -333,7 +333,7 @@ pub fn winsorize<T: Float + FromPrimitive>(samples: &mut [T], pct: T) {\n /// Returns a HashMap with the number of occurrences of every element in the\n /// sequence that the iterator exposes.\n pub fn freq_count<T, U>(iter: T) -> hash_map::HashMap<U, uint>\n-  where T: Iterator<Item=U>, U: Eq + Clone + Hash<Hasher>\n+  where T: Iterator<Item=U>, U: Eq + Clone + Hash\n {\n     let mut map: hash_map::HashMap<U,uint> = hash_map::HashMap::new();\n     for elem in iter {"}, {"sha": "7cbc4e1d7af83ddc88ce72c749be707549e7131b", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -18,7 +18,6 @@ extern crate rand;\n use std::collections::BTreeSet;\n use std::collections::BitvSet;\n use std::collections::HashSet;\n-use std::collections::hash_map::Hasher;\n use std::hash::Hash;\n use std::env;\n use std::time::Duration;\n@@ -43,7 +42,7 @@ trait MutableSet<T> {\n     fn contains(&self, k: &T) -> bool;\n }\n \n-impl<T: Hash<Hasher> + Eq> MutableSet<T> for HashSet<T> {\n+impl<T: Hash + Eq> MutableSet<T> for HashSet<T> {\n     fn insert(&mut self, k: T) { self.insert(k); }\n     fn remove(&mut self, k: &T) -> bool { self.remove(k) }\n     fn contains(&self, k: &T) -> bool { self.contains(k) }"}, {"sha": "557bf518a3cfbee46c02c4d65970a6c1df316a2f", "filename": "src/test/compile-fail/issue-21160.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -16,6 +16,6 @@ impl Bar {\n \n #[derive(Hash)]\n struct Foo(Bar);\n-//~^ error: the trait `core::hash::Hash<_>` is not implemented for the type `Bar`\n+//~^ error: the trait `core::hash::Hash` is not implemented for the type `Bar`\n \n fn main() {}"}, {"sha": "5fe7c8bb94b4f2487b08aa027ea42af58a66a91b", "filename": "src/test/run-pass/deriving-hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Frun-pass%2Fderiving-hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-hash.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -17,7 +17,7 @@ struct Person {\n     phone: uint,\n }\n \n-fn hash<T: Hash<SipHasher>>(t: &T) -> u64 {\n+fn hash<T: Hash>(t: &T) -> u64 {\n     std::hash::hash::<T, SipHasher>(t)\n }\n "}, {"sha": "62ec2f8e5902d80bc3bc894a56108339bb05e1bb", "filename": "src/test/run-pass/deriving-meta-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta-multiple.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -20,7 +20,7 @@ struct Foo {\n     baz: int\n }\n \n-fn hash<T: Hash<SipHasher>>(_t: &T) {}\n+fn hash<T: Hash>(_t: &T) {}\n \n pub fn main() {\n     let a = Foo {bar: 4, baz: -3};"}, {"sha": "82cf9db3232c0f2251c2dded55bbff40820f931b", "filename": "src/test/run-pass/deriving-meta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9774b7e64b7ff8323b4f8160cc38eb793f447217/src%2Ftest%2Frun-pass%2Fderiving-meta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-meta.rs?ref=9774b7e64b7ff8323b4f8160cc38eb793f447217", "patch": "@@ -17,7 +17,7 @@ struct Foo {\n     baz: int\n }\n \n-fn hash<T: Hash<SipHasher>>(_t: &T) {}\n+fn hash<T: Hash>(_t: &T) {}\n \n pub fn main() {\n     let a = Foo {bar: 4, baz: -3};"}]}