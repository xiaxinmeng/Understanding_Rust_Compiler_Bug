{"sha": "30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwZmU1NTA2NmEyOWExNGZmZmQyYTVmNDFlMGFiMjFlNzA1NmZiMzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-23T05:01:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-23T05:01:32Z"}, "message": "auto merge of #13597 : bjz/rust/float-api, r=brson\n\nThis pull request:\r\n\r\n- Merges the `Round` trait into the `Float` trait, continuing issue #10387.\r\n- Has floating point functions take their parameters by value.\r\n- Cleans up the formatting and organisation in the definition and implementations of the `Float` trait.\r\n\r\nMore information on the breaking changes can be found in the commit messages.", "tree": {"sha": "d3f1b728cbb4e6a74970de28ad65931ee228e407", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3f1b728cbb4e6a74970de28ad65931ee228e407"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "html_url": "https://github.com/rust-lang/rust/commit/30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "696f16ec2e54e8563702b1cdbbaaa1877562aa60", "url": "https://api.github.com/repos/rust-lang/rust/commits/696f16ec2e54e8563702b1cdbbaaa1877562aa60", "html_url": "https://github.com/rust-lang/rust/commit/696f16ec2e54e8563702b1cdbbaaa1877562aa60"}, {"sha": "2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "html_url": "https://github.com/rust-lang/rust/commit/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca"}], "stats": {"total": 1055, "additions": 572, "deletions": 483}, "files": [{"sha": "e6eb4f235e5fd71b3e3223842543f982e4e6ffc8", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -306,7 +306,7 @@ be distributed on the available cores.\n fn partial_sum(start: uint) -> f64 {\n     let mut local_sum = 0f64;\n     for num in range(start*100000, (start+1)*100000) {\n-        local_sum += (num as f64 + 1.0).powf(&-2.0);\n+        local_sum += (num as f64 + 1.0).powf(-2.0);\n     }\n     local_sum\n }\n@@ -343,7 +343,7 @@ extern crate sync;\n use sync::Arc;\n \n fn pnorm(nums: &[f64], p: uint) -> f64 {\n-    nums.iter().fold(0.0, |a,b| a+(*b).powf(&(p as f64)) ).powf(&(1.0 / (p as f64)))\n+    nums.iter().fold(0.0, |a, b| a + b.powf(p as f64)).powf(1.0 / (p as f64))\n }\n \n fn main() {"}, {"sha": "930dbe40ec7e687ccf83d51eb871639272c733d6", "filename": "src/libnum/complex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fcomplex.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -82,15 +82,15 @@ impl<T: Clone + Float> Cmplx<T> {\n     /// Calculate |self|\n     #[inline]\n     pub fn norm(&self) -> T {\n-        self.re.hypot(&self.im)\n+        self.re.hypot(self.im)\n     }\n }\n \n impl<T: Clone + Float> Cmplx<T> {\n     /// Calculate the principal Arg of self.\n     #[inline]\n     pub fn arg(&self) -> T {\n-        self.im.atan2(&self.re)\n+        self.im.atan2(self.re)\n     }\n     /// Convert to polar form (r, theta), such that `self = r * exp(i\n     /// * theta)`"}, {"sha": "825890e561930d5c54e585e2ce1e987514e20690", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -15,7 +15,7 @@ use Integer;\n use std::cmp;\n use std::fmt;\n use std::from_str::FromStr;\n-use std::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n+use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use bigint::{BigInt, BigUint, Sign, Plus, Minus};\n \n /// Represents the ratio between 2 numbers.\n@@ -113,6 +113,40 @@ impl<T: Clone + Integer + Ord>\n     pub fn recip(&self) -> Ratio<T> {\n         Ratio::new_raw(self.denom.clone(), self.numer.clone())\n     }\n+\n+    pub fn floor(&self) -> Ratio<T> {\n+        if *self < Zero::zero() {\n+            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n+        } else {\n+            Ratio::from_integer(self.numer / self.denom)\n+        }\n+    }\n+\n+    pub fn ceil(&self) -> Ratio<T> {\n+        if *self < Zero::zero() {\n+            Ratio::from_integer(self.numer / self.denom)\n+        } else {\n+            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn round(&self) -> Ratio<T> {\n+        if *self < Zero::zero() {\n+            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n+        } else {\n+            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn trunc(&self) -> Ratio<T> {\n+        Ratio::from_integer(self.numer / self.denom)\n+    }\n+\n+    pub fn fract(&self) -> Ratio<T> {\n+        Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n+    }\n }\n \n impl Ratio<BigInt> {\n@@ -238,45 +272,6 @@ impl<T: Clone + Integer + Ord>\n impl<T: Clone + Integer + Ord>\n     Num for Ratio<T> {}\n \n-/* Utils */\n-impl<T: Clone + Integer + Ord>\n-    Round for Ratio<T> {\n-\n-    fn floor(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n-        } else {\n-            Ratio::from_integer(self.numer / self.denom)\n-        }\n-    }\n-\n-    fn ceil(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer(self.numer / self.denom)\n-        } else {\n-            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n-        }\n-    }\n-\n-    #[inline]\n-    fn round(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            Ratio::from_integer((self.numer - self.denom + One::one()) / self.denom)\n-        } else {\n-            Ratio::from_integer((self.numer + self.denom - One::one()) / self.denom)\n-        }\n-    }\n-\n-    #[inline]\n-    fn trunc(&self) -> Ratio<T> {\n-        Ratio::from_integer(self.numer / self.denom)\n-    }\n-\n-    fn fract(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n-    }\n-}\n-\n /* String conversions */\n impl<T: fmt::Show> fmt::Show for Ratio<T> {\n     /// Renders as `numer/denom`.\n@@ -636,19 +631,19 @@ mod test {\n \n         // f32\n         test(3.14159265359f32, (\"13176795\", \"4194304\"));\n-        test(2f32.powf(&100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f32.powf(&100.), (\"-1267650600228229401496703205376\", \"1\"));\n-        test(1.0 / 2f32.powf(&100.), (\"1\", \"1267650600228229401496703205376\"));\n+        test(2f32.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n+        test(-2f32.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n+        test(1.0 / 2f32.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n         test(684729.48391f32, (\"1369459\", \"2\"));\n         test(-8573.5918555f32, (\"-4389679\", \"512\"));\n \n         // f64\n         test(3.14159265359f64, (\"3537118876014453\", \"1125899906842624\"));\n-        test(2f64.powf(&100.), (\"1267650600228229401496703205376\", \"1\"));\n-        test(-2f64.powf(&100.), (\"-1267650600228229401496703205376\", \"1\"));\n+        test(2f64.powf(100.), (\"1267650600228229401496703205376\", \"1\"));\n+        test(-2f64.powf(100.), (\"-1267650600228229401496703205376\", \"1\"));\n         test(684729.48391f64, (\"367611342500051\", \"536870912\"));\n         test(-8573.5918555, (\"-4713381968463931\", \"549755813888\"));\n-        test(1.0 / 2f64.powf(&100.), (\"1\", \"1267650600228229401496703205376\"));\n+        test(1.0 / 2f64.powf(100.), (\"1\", \"1267650600228229401496703205376\"));\n     }\n \n     #[test]"}, {"sha": "1bb2c35bce206bd05ba6be5913f540fca6e4c188", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -147,7 +147,7 @@ impl IndependentSample<f64> for GammaSmallShape {\n     fn ind_sample<R: Rng>(&self, rng: &mut R) -> f64 {\n         let Open01(u) = rng.gen::<Open01<f64>>();\n \n-        self.large_shape.ind_sample(rng) * u.powf(&self.inv_shape)\n+        self.large_shape.ind_sample(rng) * u.powf(self.inv_shape)\n     }\n }\n impl IndependentSample<f64> for GammaLargeShape {"}, {"sha": "bf31f36d22d2575da3cc62e36eff6d4fb9577ad3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 212, "deletions": 146, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -14,6 +14,7 @@\n \n use prelude::*;\n \n+use cast;\n use default::Default;\n use from_str::FromStr;\n use libc::{c_int};\n@@ -216,12 +217,17 @@ impl Neg<f32> for f32 {\n impl Signed for f32 {\n     /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n-    fn abs(&self) -> f32 { unsafe{intrinsics::fabsf32(*self)} }\n+    fn abs(&self) -> f32 {\n+        unsafe { intrinsics::fabsf32(*self) }\n+    }\n \n-    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    /// The positive difference of two numbers. Returns `0.0` if the number is\n+    /// less than or equal to `other`, otherwise the difference between`self`\n+    /// and `other` is returned.\n     #[inline]\n-    fn abs_sub(&self, other: &f32) -> f32 { unsafe{cmath::fdimf(*self, *other)} }\n+    fn abs_sub(&self, other: &f32) -> f32 {\n+        unsafe { cmath::fdimf(*self, *other) }\n+    }\n \n     /// # Returns\n     ///\n@@ -230,7 +236,9 @@ impl Signed for f32 {\n     /// - `NAN` if the number is NaN\n     #[inline]\n     fn signum(&self) -> f32 {\n-        if self.is_nan() { NAN } else { unsafe{intrinsics::copysignf32(1.0, *self)} }\n+        if self.is_nan() { NAN } else {\n+            unsafe { intrinsics::copysignf32(1.0, *self) }\n+        }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n@@ -242,33 +250,6 @@ impl Signed for f32 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n }\n \n-impl Round for f32 {\n-    /// Round half-way cases toward `NEG_INFINITY`\n-    #[inline]\n-    fn floor(&self) -> f32 { unsafe{intrinsics::floorf32(*self)} }\n-\n-    /// Round half-way cases toward `INFINITY`\n-    #[inline]\n-    fn ceil(&self) -> f32 { unsafe{intrinsics::ceilf32(*self)} }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(&self) -> f32 { unsafe{intrinsics::roundf32(*self)} }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(&self) -> f32 { unsafe{intrinsics::truncf32(*self)} }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// let x = 1.65f32;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(&self) -> f32 { *self - self.trunc() }\n-}\n-\n impl Bounded for f32 {\n     #[inline]\n     fn min_value() -> f32 { 1.17549435e-38 }\n@@ -280,18 +261,6 @@ impl Bounded for f32 {\n impl Primitive for f32 {}\n \n impl Float for f32 {\n-    fn powi(&self, n: i32) -> f32 { unsafe{intrinsics::powif32(*self, n)} }\n-\n-    #[inline]\n-    fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::fmaxf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::fminf(self, other) }\n-    }\n-\n     #[inline]\n     fn nan() -> f32 { 0.0 / 0.0 }\n \n@@ -306,33 +275,34 @@ impl Float for f32 {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_nan(&self) -> bool { *self != *self }\n+    fn is_nan(self) -> bool { self != self }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n     #[inline]\n-    fn is_finite(&self) -> bool {\n+    fn is_finite(self) -> bool {\n         !(self.is_nan() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n     #[inline]\n-    fn is_normal(&self) -> bool {\n+    fn is_normal(self) -> bool {\n         self.classify() == FPNormal\n     }\n \n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n-    fn classify(&self) -> FPCategory {\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    fn classify(self) -> FPCategory {\n         static EXP_MASK: u32 = 0x7f800000;\n         static MAN_MASK: u32 = 0x007fffff;\n \n-        let bits: u32 = unsafe {::cast::transmute(*self)};\n+        let bits: u32 = unsafe { cast::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -363,48 +333,30 @@ impl Float for f32 {\n     #[inline]\n     fn max_10_exp(_: Option<f32>) -> int { 38 }\n \n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n+    /// power of `exp`\n     #[inline]\n-    fn ldexp(x: f32, exp: int) -> f32 { unsafe{cmath::ldexpf(x, exp as c_int)} }\n+    fn ldexp(x: f32, exp: int) -> f32 {\n+        unsafe { cmath::ldexpf(x, exp as c_int) }\n+    }\n \n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    /// Breaks the number into a normalized fraction and a base-2 exponent,\n+    /// satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(&self) -> (f32, int) {\n+    fn frexp(self) -> (f32, int) {\n         unsafe {\n             let mut exp = 0;\n-            let x = cmath::frexpf(*self, &mut exp);\n+            let x = cmath::frexpf(self, &mut exp);\n             (x, exp as int)\n         }\n     }\n \n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(&self) -> f32 { unsafe{cmath::expm1f(*self)} }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(&self) -> f32 { unsafe{cmath::log1pf(*self)} }\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    #[inline]\n-    fn mul_add(&self, a: f32, b: f32) -> f32 { unsafe{intrinsics::fmaf32(*self, a, b)} }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(&self, other: f32) -> f32 { unsafe{cmath::nextafterf(*self, other)} }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(&self) -> (u64, i16, i8) {\n-        let bits: u32 = unsafe {\n-            ::cast::transmute(*self)\n-        };\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u32 = unsafe { cast::transmute(self) };\n         let sign: i8 = if bits >> 31 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 23) & 0xff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -417,45 +369,76 @@ impl Float for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n-    /// Archimedes' constant\n+    /// Returns the next representable floating-point value in the direction of\n+    /// `other`.\n     #[inline]\n-    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n+    fn next_after(self, other: f32) -> f32 {\n+        unsafe { cmath::nextafterf(self, other) }\n+    }\n \n-    /// 2.0 * pi\n+    /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n+    fn floor(self) -> f32 {\n+        unsafe { intrinsics::floorf32(self) }\n+    }\n \n-    /// pi / 2.0\n+    /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n+    fn ceil(self) -> f32 {\n+        unsafe { intrinsics::ceilf32(self) }\n+    }\n \n-    /// pi / 3.0\n+    /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+    fn round(self) -> f32 {\n+        unsafe { intrinsics::roundf32(self) }\n+    }\n \n-    /// pi / 4.0\n+    /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+    fn trunc(self) -> f32 {\n+        unsafe { intrinsics::truncf32(self) }\n+    }\n \n-    /// pi / 6.0\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ```rust\n+    /// let x = 1.65f32;\n+    /// assert!(x == x.trunc() + x.fract())\n+    /// ```\n     #[inline]\n-    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+    fn fract(self) -> f32 { self - self.trunc() }\n \n-    /// pi / 8.0\n     #[inline]\n-    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+    fn max(self, other: f32) -> f32 {\n+        unsafe { cmath::fmaxf(self, other) }\n+    }\n \n-    /// 1 .0/ pi\n     #[inline]\n-    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+    fn min(self, other: f32) -> f32 {\n+        unsafe { cmath::fminf(self, other) }\n+    }\n \n-    /// 2.0 / pi\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n     #[inline]\n-    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+    fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n \n-    /// 2.0 / sqrt(pi)\n+    /// The reciprocal (multiplicative inverse) of the number\n     #[inline]\n-    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+    fn recip(self) -> f32 { 1.0 / self }\n+\n+    fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n+\n+    #[inline]\n+    fn powf(self, n: f32) -> f32 {\n+        unsafe { intrinsics::powf32(self, n) }\n+    }\n \n     /// sqrt(2.0)\n     #[inline]\n@@ -465,104 +448,187 @@ impl Float for f32 {\n     #[inline]\n     fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n \n-    /// Euler's number\n     #[inline]\n-    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+    fn sqrt(self) -> f32 {\n+        unsafe { intrinsics::sqrtf32(self) }\n+    }\n \n-    /// log2(e)\n     #[inline]\n-    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n \n-    /// log10(e)\n     #[inline]\n-    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+    fn cbrt(self) -> f32 {\n+        unsafe { cmath::cbrtf(self) }\n+    }\n \n-    /// ln(2.0)\n     #[inline]\n-    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n+    fn hypot(self, other: f32) -> f32 {\n+        unsafe { cmath::hypotf(self, other) }\n+    }\n \n-    /// ln(10.0)\n+    /// Archimedes' constant\n     #[inline]\n-    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n+    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n \n-    /// The reciprocal (multiplicative inverse) of the number\n+    /// 2.0 * pi\n     #[inline]\n-    fn recip(&self) -> f32 { 1.0 / *self }\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline]\n-    fn powf(&self, n: &f32) -> f32 { unsafe{intrinsics::powf32(*self, *n)} }\n+    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline]\n-    fn sqrt(&self) -> f32 { unsafe{intrinsics::sqrtf32(*self)} }\n+    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline]\n-    fn rsqrt(&self) -> f32 { self.sqrt().recip() }\n+    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline]\n-    fn cbrt(&self) -> f32 { unsafe{cmath::cbrtf(*self)} }\n+    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n \n+    /// pi / 8.0\n     #[inline]\n-    fn hypot(&self, other: &f32) -> f32 { unsafe{cmath::hypotf(*self, *other)} }\n+    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n \n+    /// 1 .0/ pi\n     #[inline]\n-    fn sin(&self) -> f32 { unsafe{intrinsics::sinf32(*self)} }\n+    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline]\n-    fn cos(&self) -> f32 { unsafe{intrinsics::cosf32(*self)} }\n+    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn tan(&self) -> f32 { unsafe{cmath::tanf(*self)} }\n+    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n \n     #[inline]\n-    fn asin(&self) -> f32 { unsafe{cmath::asinf(*self)} }\n+    fn sin(self) -> f32 {\n+        unsafe { intrinsics::sinf32(self) }\n+    }\n \n     #[inline]\n-    fn acos(&self) -> f32 { unsafe{cmath::acosf(*self)} }\n+    fn cos(self) -> f32 {\n+        unsafe { intrinsics::cosf32(self) }\n+    }\n \n     #[inline]\n-    fn atan(&self) -> f32 { unsafe{cmath::atanf(*self)} }\n+    fn tan(self) -> f32 {\n+        unsafe { cmath::tanf(self) }\n+    }\n \n     #[inline]\n-    fn atan2(&self, other: &f32) -> f32 { unsafe{cmath::atan2f(*self, *other)} }\n+    fn asin(self) -> f32 {\n+        unsafe { cmath::asinf(self) }\n+    }\n+\n+    #[inline]\n+    fn acos(self) -> f32 {\n+        unsafe { cmath::acosf(self) }\n+    }\n+\n+    #[inline]\n+    fn atan(self) -> f32 {\n+        unsafe { cmath::atanf(self) }\n+    }\n+\n+    #[inline]\n+    fn atan2(self, other: f32) -> f32 {\n+        unsafe { cmath::atan2f(self, other) }\n+    }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n-    fn sin_cos(&self) -> (f32, f32) {\n+    fn sin_cos(self) -> (f32, f32) {\n         (self.sin(), self.cos())\n     }\n \n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n+\n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(&self) -> f32 { unsafe{intrinsics::expf32(*self)} }\n+    fn exp(self) -> f32 {\n+        unsafe { intrinsics::expf32(self) }\n+    }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(&self) -> f32 { unsafe{intrinsics::exp2f32(*self)} }\n+    fn exp2(self) -> f32 {\n+        unsafe { intrinsics::exp2f32(self) }\n+    }\n+\n+    /// Returns the exponential of the number, minus `1`, in a way that is\n+    /// accurate even if the number is close to zero\n+    #[inline]\n+    fn exp_m1(self) -> f32 {\n+        unsafe { cmath::expm1f(self) }\n+    }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(&self) -> f32 { unsafe{intrinsics::logf32(*self)} }\n+    fn ln(self) -> f32 {\n+        unsafe { intrinsics::logf32(self) }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n-    fn log(&self, base: &f32) -> f32 { self.ln() / base.ln() }\n+    fn log(self, base: f32) -> f32 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(&self) -> f32 { unsafe{intrinsics::log2f32(*self)} }\n+    fn log2(self) -> f32 {\n+        unsafe { intrinsics::log2f32(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(&self) -> f32 { unsafe{intrinsics::log10f32(*self)} }\n+    fn log10(self) -> f32 {\n+        unsafe { intrinsics::log10f32(self) }\n+    }\n+\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n+    /// accurately than if the operations were performed separately\n+    #[inline]\n+    fn ln_1p(self) -> f32 {\n+        unsafe { cmath::log1pf(self) }\n+    }\n \n     #[inline]\n-    fn sinh(&self) -> f32 { unsafe{cmath::sinhf(*self)} }\n+    fn sinh(self) -> f32 {\n+        unsafe { cmath::sinhf(self) }\n+    }\n \n     #[inline]\n-    fn cosh(&self) -> f32 { unsafe{cmath::coshf(*self)} }\n+    fn cosh(self) -> f32 {\n+        unsafe { cmath::coshf(self) }\n+    }\n \n     #[inline]\n-    fn tanh(&self) -> f32 { unsafe{cmath::tanhf(*self)} }\n+    fn tanh(self) -> f32 {\n+        unsafe { cmath::tanhf(self) }\n+    }\n \n     /// Inverse hyperbolic sine\n     ///\n@@ -572,8 +638,8 @@ impl Float for f32 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n     #[inline]\n-    fn asinh(&self) -> f32 {\n-        match *self {\n+    fn asinh(self) -> f32 {\n+        match self {\n             NEG_INFINITY => NEG_INFINITY,\n             x => (x + ((x * x) + 1.0).sqrt()).ln(),\n         }\n@@ -587,8 +653,8 @@ impl Float for f32 {\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n     #[inline]\n-    fn acosh(&self) -> f32 {\n-        match *self {\n+    fn acosh(self) -> f32 {\n+        match self {\n             x if x < 1.0 => Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n@@ -605,19 +671,19 @@ impl Float for f32 {\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n     #[inline]\n-    fn atanh(&self) -> f32 {\n-        0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n+    fn atanh(self) -> f32 {\n+        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f32 { *self * (180.0f32 / Float::pi()) }\n+    fn to_degrees(self) -> f32 { self * (180.0f32 / Float::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f32 {\n+    fn to_radians(self) -> f32 {\n         let value: f32 = Float::pi();\n-        *self * (value / 180.0f32)\n+        self * (value / 180.0f32)\n     }\n }\n \n@@ -1167,7 +1233,7 @@ mod tests {\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f32.integer_decode(), (13176795u64, -22i16, 1i8));\n         assert_eq!((-8573.5918555f32).integer_decode(), (8779358u64, -10i16, -1i8));\n-        assert_eq!(2f32.powf(&100.0).integer_decode(), (8388608u64, 77i16, 1i8));\n+        assert_eq!(2f32.powf(100.0).integer_decode(), (8388608u64, 77i16, 1i8));\n         assert_eq!(0f32.integer_decode(), (0u64, -150i16, 1i8));\n         assert_eq!((-0f32).integer_decode(), (0u64, -150i16, -1i8));\n         assert_eq!(INFINITY.integer_decode(), (8388608u64, 105i16, 1i8));"}, {"sha": "39eba0825fc3c351c77c8e2d81471d1bda069497", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 208, "deletions": 143, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -14,6 +14,7 @@\n \n use prelude::*;\n \n+use cast;\n use default::Default;\n use from_str::FromStr;\n use libc::{c_int};\n@@ -224,12 +225,16 @@ impl Neg<f64> for f64 {\n impl Signed for f64 {\n     /// Computes the absolute value. Returns `NAN` if the number is `NAN`.\n     #[inline]\n-    fn abs(&self) -> f64 { unsafe{intrinsics::fabsf64(*self)} }\n+    fn abs(&self) -> f64 {\n+        unsafe { intrinsics::fabsf64(*self) }\n+    }\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n     /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n     #[inline]\n-    fn abs_sub(&self, other: &f64) -> f64 { unsafe{cmath::fdim(*self, *other)} }\n+    fn abs_sub(&self, other: &f64) -> f64 {\n+        unsafe { cmath::fdim(*self, *other) }\n+    }\n \n     /// # Returns\n     ///\n@@ -238,7 +243,9 @@ impl Signed for f64 {\n     /// - `NAN` if the number is NaN\n     #[inline]\n     fn signum(&self) -> f64 {\n-        if self.is_nan() { NAN } else { unsafe{intrinsics::copysignf64(1.0, *self)} }\n+        if self.is_nan() { NAN } else {\n+            unsafe { intrinsics::copysignf64(1.0, *self) }\n+        }\n     }\n \n     /// Returns `true` if the number is positive, including `+0.0` and `INFINITY`\n@@ -250,33 +257,6 @@ impl Signed for f64 {\n     fn is_negative(&self) -> bool { *self < 0.0 || (1.0 / *self) == NEG_INFINITY }\n }\n \n-impl Round for f64 {\n-    /// Round half-way cases toward `NEG_INFINITY`\n-    #[inline]\n-    fn floor(&self) -> f64 { unsafe{intrinsics::floorf64(*self)} }\n-\n-    /// Round half-way cases toward `INFINITY`\n-    #[inline]\n-    fn ceil(&self) -> f64 { unsafe{intrinsics::ceilf64(*self)} }\n-\n-    /// Round half-way cases away from `0.0`\n-    #[inline]\n-    fn round(&self) -> f64 { unsafe{intrinsics::roundf64(*self)} }\n-\n-    /// The integer part of the number (rounds towards `0.0`)\n-    #[inline]\n-    fn trunc(&self) -> f64 { unsafe{intrinsics::truncf64(*self)} }\n-\n-    /// The fractional part of the number, satisfying:\n-    ///\n-    /// ```rust\n-    /// let x = 1.65f64;\n-    /// assert!(x == x.trunc() + x.fract())\n-    /// ```\n-    #[inline]\n-    fn fract(&self) -> f64 { *self - self.trunc() }\n-}\n-\n impl Bounded for f64 {\n     #[inline]\n     fn min_value() -> f64 { 2.2250738585072014e-308 }\n@@ -288,16 +268,6 @@ impl Bounded for f64 {\n impl Primitive for f64 {}\n \n impl Float for f64 {\n-    #[inline]\n-    fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::fmax(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::fmin(self, other) }\n-    }\n-\n     #[inline]\n     fn nan() -> f64 { 0.0 / 0.0 }\n \n@@ -312,33 +282,34 @@ impl Float for f64 {\n \n     /// Returns `true` if the number is NaN\n     #[inline]\n-    fn is_nan(&self) -> bool { *self != *self }\n+    fn is_nan(self) -> bool { self != self }\n \n     /// Returns `true` if the number is infinite\n     #[inline]\n-    fn is_infinite(&self) -> bool {\n-        *self == Float::infinity() || *self == Float::neg_infinity()\n+    fn is_infinite(self) -> bool {\n+        self == Float::infinity() || self == Float::neg_infinity()\n     }\n \n     /// Returns `true` if the number is neither infinite or NaN\n     #[inline]\n-    fn is_finite(&self) -> bool {\n+    fn is_finite(self) -> bool {\n         !(self.is_nan() || self.is_infinite())\n     }\n \n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN\n     #[inline]\n-    fn is_normal(&self) -> bool {\n+    fn is_normal(self) -> bool {\n         self.classify() == FPNormal\n     }\n \n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n-    fn classify(&self) -> FPCategory {\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n+    fn classify(self) -> FPCategory {\n         static EXP_MASK: u64 = 0x7ff0000000000000;\n         static MAN_MASK: u64 = 0x000fffffffffffff;\n \n-        let bits: u64 = unsafe {::cast::transmute(*self)};\n+        let bits: u64 = unsafe { cast::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n             (0, 0)        => FPZero,\n             (_, 0)        => FPSubnormal,\n@@ -369,48 +340,30 @@ impl Float for f64 {\n     #[inline]\n     fn max_10_exp(_: Option<f64>) -> int { 308 }\n \n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n+    /// power of `exp`\n     #[inline]\n-    fn ldexp(x: f64, exp: int) -> f64 { unsafe{cmath::ldexp(x, exp as c_int)} }\n+    fn ldexp(x: f64, exp: int) -> f64 {\n+        unsafe { cmath::ldexp(x, exp as c_int) }\n+    }\n \n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    /// Breaks the number into a normalized fraction and a base-2 exponent,\n+    /// satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n     #[inline]\n-    fn frexp(&self) -> (f64, int) {\n+    fn frexp(self) -> (f64, int) {\n         unsafe {\n             let mut exp = 0;\n-            let x = cmath::frexp(*self, &mut exp);\n+            let x = cmath::frexp(self, &mut exp);\n             (x, exp as int)\n         }\n     }\n \n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(&self) -> f64 { unsafe{cmath::expm1(*self)} }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(&self) -> f64 { unsafe{cmath::log1p(*self)} }\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    #[inline]\n-    fn mul_add(&self, a: f64, b: f64) -> f64 { unsafe{intrinsics::fmaf64(*self, a, b)} }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(&self, other: f64) -> f64 { unsafe{cmath::nextafter(*self, other)} }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n-    fn integer_decode(&self) -> (u64, i16, i8) {\n-        let bits: u64 = unsafe {\n-            ::cast::transmute(*self)\n-        };\n+    fn integer_decode(self) -> (u64, i16, i8) {\n+        let bits: u64 = unsafe { cast::transmute(self) };\n         let sign: i8 = if bits >> 63 == 0 { 1 } else { -1 };\n         let mut exponent: i16 = ((bits >> 52) & 0x7ff) as i16;\n         let mantissa = if exponent == 0 {\n@@ -423,45 +376,77 @@ impl Float for f64 {\n         (mantissa, exponent, sign)\n     }\n \n-    /// Archimedes' constant\n+    /// Returns the next representable floating-point value in the direction of\n+    /// `other`.\n     #[inline]\n-    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n+    fn next_after(self, other: f64) -> f64 {\n+        unsafe { cmath::nextafter(self, other) }\n+    }\n \n-    /// 2.0 * pi\n+    /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n-    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n+    fn floor(self) -> f64 {\n+        unsafe { intrinsics::floorf64(self) }\n+    }\n \n-    /// pi / 2.0\n+    /// Round half-way cases toward `INFINITY`\n     #[inline]\n-    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n+    fn ceil(self) -> f64 {\n+        unsafe { intrinsics::ceilf64(self) }\n+    }\n \n-    /// pi / 3.0\n+    /// Round half-way cases away from `0.0`\n     #[inline]\n-    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n+    fn round(self) -> f64 {\n+        unsafe { intrinsics::roundf64(self) }\n+    }\n \n-    /// pi / 4.0\n+    /// The integer part of the number (rounds towards `0.0`)\n     #[inline]\n-    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+    fn trunc(self) -> f64 {\n+        unsafe { intrinsics::truncf64(self) }\n+    }\n \n-    /// pi / 6.0\n+    /// The fractional part of the number, satisfying:\n+    ///\n+    /// ```rust\n+    /// let x = 1.65f64;\n+    /// assert!(x == x.trunc() + x.fract())\n+    /// ```\n     #[inline]\n-    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+    fn fract(self) -> f64 { self - self.trunc() }\n \n-    /// pi / 8.0\n     #[inline]\n-    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+    fn max(self, other: f64) -> f64 {\n+        unsafe { cmath::fmax(self, other) }\n+    }\n \n-    /// 1.0 / pi\n     #[inline]\n-    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+    fn min(self, other: f64) -> f64 {\n+        unsafe { cmath::fmin(self, other) }\n+    }\n \n-    /// 2.0 / pi\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n     #[inline]\n-    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+    fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n \n-    /// 2.0 / sqrt(pi)\n+    /// The reciprocal (multiplicative inverse) of the number\n     #[inline]\n-    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+    fn recip(self) -> f64 { 1.0 / self }\n+\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n \n     /// sqrt(2.0)\n     #[inline]\n@@ -471,107 +456,187 @@ impl Float for f64 {\n     #[inline]\n     fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n \n-    /// Euler's number\n     #[inline]\n-    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+    fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n \n-    /// log2(e)\n     #[inline]\n-    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n \n-    /// log10(e)\n     #[inline]\n-    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+    fn cbrt(self) -> f64 {\n+        unsafe { cmath::cbrt(self) }\n+    }\n \n-    /// ln(2.0)\n     #[inline]\n-    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n+    fn hypot(self, other: f64) -> f64 {\n+        unsafe { cmath::hypot(self, other) }\n+    }\n \n-    /// ln(10.0)\n+    /// Archimedes' constant\n     #[inline]\n-    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n+    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n \n-    /// The reciprocal (multiplicative inverse) of the number\n+    /// 2.0 * pi\n     #[inline]\n-    fn recip(&self) -> f64 { 1.0 / *self }\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline]\n-    fn powf(&self, n: &f64) -> f64 { unsafe{intrinsics::powf64(*self, *n)} }\n+    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline]\n-    fn powi(&self, n: i32) -> f64 { unsafe{intrinsics::powif64(*self, n)} }\n+    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline]\n-    fn sqrt(&self) -> f64 { unsafe{intrinsics::sqrtf64(*self)} }\n+    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline]\n-    fn rsqrt(&self) -> f64 { self.sqrt().recip() }\n+    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n \n+    /// pi / 8.0\n+    #[inline]\n+    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+\n+    /// 1.0 / pi\n     #[inline]\n-    fn cbrt(&self) -> f64 { unsafe{cmath::cbrt(*self)} }\n+    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline]\n+    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn hypot(&self, other: &f64) -> f64 { unsafe{cmath::hypot(*self, *other)} }\n+    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n \n     #[inline]\n-    fn sin(&self) -> f64 { unsafe{intrinsics::sinf64(*self)} }\n+    fn sin(self) -> f64 {\n+        unsafe { intrinsics::sinf64(self) }\n+    }\n \n     #[inline]\n-    fn cos(&self) -> f64 { unsafe{intrinsics::cosf64(*self)} }\n+    fn cos(self) -> f64 {\n+        unsafe { intrinsics::cosf64(self) }\n+    }\n \n     #[inline]\n-    fn tan(&self) -> f64 { unsafe{cmath::tan(*self)} }\n+    fn tan(self) -> f64 {\n+        unsafe { cmath::tan(self) }\n+    }\n \n     #[inline]\n-    fn asin(&self) -> f64 { unsafe{cmath::asin(*self)} }\n+    fn asin(self) -> f64 {\n+        unsafe { cmath::asin(self) }\n+    }\n \n     #[inline]\n-    fn acos(&self) -> f64 { unsafe{cmath::acos(*self)} }\n+    fn acos(self) -> f64 {\n+        unsafe { cmath::acos(self) }\n+    }\n \n     #[inline]\n-    fn atan(&self) -> f64 { unsafe{cmath::atan(*self)} }\n+    fn atan(self) -> f64 {\n+        unsafe { cmath::atan(self) }\n+    }\n \n     #[inline]\n-    fn atan2(&self, other: &f64) -> f64 { unsafe{cmath::atan2(*self, *other)} }\n+    fn atan2(self, other: f64) -> f64 {\n+        unsafe { cmath::atan2(self, other) }\n+    }\n \n     /// Simultaneously computes the sine and cosine of the number\n     #[inline]\n-    fn sin_cos(&self) -> (f64, f64) {\n+    fn sin_cos(self) -> (f64, f64) {\n         (self.sin(), self.cos())\n     }\n \n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n+\n     /// Returns the exponential of the number\n     #[inline]\n-    fn exp(&self) -> f64 { unsafe{intrinsics::expf64(*self)} }\n+    fn exp(self) -> f64 {\n+        unsafe { intrinsics::expf64(self) }\n+    }\n \n     /// Returns 2 raised to the power of the number\n     #[inline]\n-    fn exp2(&self) -> f64 { unsafe{intrinsics::exp2f64(*self)} }\n+    fn exp2(self) -> f64 {\n+        unsafe { intrinsics::exp2f64(self) }\n+    }\n+\n+    /// Returns the exponential of the number, minus `1`, in a way that is\n+    /// accurate even if the number is close to zero\n+    #[inline]\n+    fn exp_m1(self) -> f64 {\n+        unsafe { cmath::expm1(self) }\n+    }\n \n     /// Returns the natural logarithm of the number\n     #[inline]\n-    fn ln(&self) -> f64 { unsafe{intrinsics::logf64(*self)} }\n+    fn ln(self) -> f64 {\n+        unsafe { intrinsics::logf64(self) }\n+    }\n \n     /// Returns the logarithm of the number with respect to an arbitrary base\n     #[inline]\n-    fn log(&self, base: &f64) -> f64 { self.ln() / base.ln() }\n+    fn log(self, base: f64) -> f64 { self.ln() / base.ln() }\n \n     /// Returns the base 2 logarithm of the number\n     #[inline]\n-    fn log2(&self) -> f64 { unsafe{intrinsics::log2f64(*self)} }\n+    fn log2(self) -> f64 {\n+        unsafe { intrinsics::log2f64(self) }\n+    }\n \n     /// Returns the base 10 logarithm of the number\n     #[inline]\n-    fn log10(&self) -> f64 { unsafe{intrinsics::log10f64(*self)} }\n+    fn log10(self) -> f64 {\n+        unsafe { intrinsics::log10f64(self) }\n+    }\n+\n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n+    /// accurately than if the operations were performed separately\n+    #[inline]\n+    fn ln_1p(self) -> f64 {\n+        unsafe { cmath::log1p(self) }\n+    }\n \n     #[inline]\n-    fn sinh(&self) -> f64 { unsafe{cmath::sinh(*self)} }\n+    fn sinh(self) -> f64 {\n+        unsafe { cmath::sinh(self) }\n+    }\n \n     #[inline]\n-    fn cosh(&self) -> f64 { unsafe{cmath::cosh(*self)} }\n+    fn cosh(self) -> f64 {\n+        unsafe { cmath::cosh(self) }\n+    }\n \n     #[inline]\n-    fn tanh(&self) -> f64 { unsafe{cmath::tanh(*self)} }\n+    fn tanh(self) -> f64 {\n+        unsafe { cmath::tanh(self) }\n+    }\n \n     /// Inverse hyperbolic sine\n     ///\n@@ -581,8 +646,8 @@ impl Float for f64 {\n     /// - `self` if `self` is `0.0`, `-0.0`, `INFINITY`, or `NEG_INFINITY`\n     /// - `NAN` if `self` is `NAN`\n     #[inline]\n-    fn asinh(&self) -> f64 {\n-        match *self {\n+    fn asinh(self) -> f64 {\n+        match self {\n             NEG_INFINITY => NEG_INFINITY,\n             x => (x + ((x * x) + 1.0).sqrt()).ln(),\n         }\n@@ -596,8 +661,8 @@ impl Float for f64 {\n     /// - `INFINITY` if `self` is `INFINITY`\n     /// - `NAN` if `self` is `NAN` or `self < 1.0` (including `NEG_INFINITY`)\n     #[inline]\n-    fn acosh(&self) -> f64 {\n-        match *self {\n+    fn acosh(self) -> f64 {\n+        match self {\n             x if x < 1.0 => Float::nan(),\n             x => (x + ((x * x) - 1.0).sqrt()).ln(),\n         }\n@@ -614,19 +679,19 @@ impl Float for f64 {\n     /// - `NAN` if the `self` is `NAN` or outside the domain of `-1.0 <= self <= 1.0`\n     ///   (including `INFINITY` and `NEG_INFINITY`)\n     #[inline]\n-    fn atanh(&self) -> f64 {\n-        0.5 * ((2.0 * *self) / (1.0 - *self)).ln_1p()\n+    fn atanh(self) -> f64 {\n+        0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n     /// Converts to degrees, assuming the number is in radians\n     #[inline]\n-    fn to_degrees(&self) -> f64 { *self * (180.0f64 / Float::pi()) }\n+    fn to_degrees(self) -> f64 { self * (180.0f64 / Float::pi()) }\n \n     /// Converts to radians, assuming the number is in degrees\n     #[inline]\n-    fn to_radians(&self) -> f64 {\n+    fn to_radians(self) -> f64 {\n         let value: f64 = Float::pi();\n-        *self * (value / 180.0)\n+        self * (value / 180.0)\n     }\n }\n \n@@ -1170,7 +1235,7 @@ mod tests {\n     fn test_integer_decode() {\n         assert_eq!(3.14159265359f64.integer_decode(), (7074237752028906u64, -51i16, 1i8));\n         assert_eq!((-8573.5918555f64).integer_decode(), (4713381968463931u64, -39i16, -1i8));\n-        assert_eq!(2f64.powf(&100.0).integer_decode(), (4503599627370496u64, 48i16, 1i8));\n+        assert_eq!(2f64.powf(100.0).integer_decode(), (4503599627370496u64, 48i16, 1i8));\n         assert_eq!(0f64.integer_decode(), (0u64, -1075i16, 1i8));\n         assert_eq!((-0f64).integer_decode(), (0u64, -1075i16, -1i8));\n         assert_eq!(INFINITY.integer_decode(), (4503599627370496u64, 972i16, 1i8));"}, {"sha": "c498892e76cb4942d1e8e6279087b630c00fc302", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 99, "deletions": 136, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -162,25 +162,6 @@ pub fn abs_sub<T: Signed>(x: T, y: T) -> T {\n /// A trait for values which cannot be negative\n pub trait Unsigned: Num {}\n \n-/// A collection of rounding operations.\n-pub trait Round {\n-    /// Return the largest integer less than or equal to a number.\n-    fn floor(&self) -> Self;\n-\n-    /// Return the smallest integer greater than or equal to a number.\n-    fn ceil(&self) -> Self;\n-\n-    /// Return the nearest integer to a number. Round half-way cases away from\n-    /// `0.0`.\n-    fn round(&self) -> Self;\n-\n-    /// Return the integer part of a number.\n-    fn trunc(&self) -> Self;\n-\n-    /// Return the fractional part of a number.\n-    fn fract(&self) -> Self;\n-}\n-\n /// Raises a value to the power of exp, using exponentiation by squaring.\n ///\n /// # Example\n@@ -353,217 +334,199 @@ pub enum FPCategory {\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-pub trait Float: Signed + Round + Primitive {\n-    /// Returns the maximum of the two numbers.\n-    fn max(self, other: Self) -> Self;\n-    /// Returns the minimum of the two numbers.\n-    fn min(self, other: Self) -> Self;\n-\n+pub trait Float: Signed + Primitive {\n     /// Returns the NaN value.\n     fn nan() -> Self;\n-\n     /// Returns the infinite value.\n     fn infinity() -> Self;\n-\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n-\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n-    fn is_nan(&self) -> bool;\n-\n-    /// Returns true if this value is positive infinity or negative infinity and false otherwise.\n-    fn is_infinite(&self) -> bool;\n-\n+    fn is_nan(self) -> bool;\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    fn is_infinite(self) -> bool;\n     /// Returns true if this number is neither infinite nor NaN.\n-    fn is_finite(&self) -> bool;\n-\n+    fn is_finite(self) -> bool;\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    fn is_normal(&self) -> bool;\n-\n+    fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n-    fn classify(&self) -> FPCategory;\n+    fn classify(self) -> FPCategory;\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n-\n     /// Returns the number of binary digits of exponent that this type supports.\n     fn digits(unused_self: Option<Self>) -> uint;\n-\n     /// Returns the smallest positive number that this type can represent.\n     fn epsilon() -> Self;\n-\n     /// Returns the minimum binary exponent that this type can represent.\n     fn min_exp(unused_self: Option<Self>) -> int;\n-\n     /// Returns the maximum binary exponent that this type can represent.\n     fn max_exp(unused_self: Option<Self>) -> int;\n-\n     /// Returns the minimum base-10 exponent that this type can represent.\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n-\n     /// Returns the maximum base-10 exponent that this type can represent.\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n \n-    /// Constructs a floating point number created by multiplying `x` by 2 raised to the power of\n-    /// `exp`.\n+    /// Constructs a floating point number created by multiplying `x` by 2\n+    /// raised to the power of `exp`.\n     fn ldexp(x: Self, exp: int) -> Self;\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    /// Breaks the number into a normalized fraction and a base-2 exponent,\n+    /// satisfying:\n     ///\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n-    fn frexp(&self) -> (Self, int);\n+    fn frexp(self) -> (Self, int);\n+    /// Returns the mantissa, exponent and sign as integers, respectively.\n+    fn integer_decode(self) -> (u64, i16, i8);\n+\n+    /// Returns the next representable floating-point value in the direction of\n+    /// `other`.\n+    fn next_after(self, other: Self) -> Self;\n+\n+    /// Return the largest integer less than or equal to a number.\n+    fn floor(self) -> Self;\n+    /// Return the smallest integer greater than or equal to a number.\n+    fn ceil(self) -> Self;\n+    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// `0.0`.\n+    fn round(self) -> Self;\n+    /// Return the integer part of a number.\n+    fn trunc(self) -> Self;\n+    /// Return the fractional part of a number.\n+    fn fract(self) -> Self;\n \n-    /// Returns the exponential of the number, minus 1, in a way that is accurate even if the\n-    /// number is close to zero.\n-    fn exp_m1(&self) -> Self;\n+    /// Returns the maximum of the two numbers.\n+    fn max(self, other: Self) -> Self;\n+    /// Returns the minimum of the two numbers.\n+    fn min(self, other: Self) -> Self;\n \n-    /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more accurately than if the\n-    /// operations were performed separately.\n-    fn ln_1p(&self) -> Self;\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    fn recip(self) -> Self;\n \n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This produces a\n-    /// more accurate result with better performance than a separate multiplication operation\n-    /// followed by an add.\n-    fn mul_add(&self, a: Self, b: Self) -> Self;\n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    fn powi(self, n: i32) -> Self;\n+    /// Raise a number to a floating point power.\n+    fn powf(self, n: Self) -> Self;\n \n-    /// Returns the next representable floating-point value in the direction of `other`.\n-    fn next_after(&self, other: Self) -> Self;\n+    /// sqrt(2.0).\n+    fn sqrt2() -> Self;\n+    /// 1.0 / sqrt(2.0).\n+    fn frac_1_sqrt2() -> Self;\n \n-    /// Returns the mantissa, exponent and sign as integers, respectively.\n-    fn integer_decode(&self) -> (u64, i16, i8);\n+    /// Take the square root of a number.\n+    fn sqrt(self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    fn rsqrt(self) -> Self;\n+    /// Take the cubic root of a number.\n+    fn cbrt(self) -> Self;\n+    /// Calculate the length of the hypotenuse of a right-angle triangle given\n+    /// legs of length `x` and `y`.\n+    fn hypot(self, other: Self) -> Self;\n \n     /// Archimedes' constant.\n     fn pi() -> Self;\n-\n     /// 2.0 * pi.\n     fn two_pi() -> Self;\n-\n     /// pi / 2.0.\n     fn frac_pi_2() -> Self;\n-\n     /// pi / 3.0.\n     fn frac_pi_3() -> Self;\n-\n     /// pi / 4.0.\n     fn frac_pi_4() -> Self;\n-\n     /// pi / 6.0.\n     fn frac_pi_6() -> Self;\n-\n     /// pi / 8.0.\n     fn frac_pi_8() -> Self;\n-\n     /// 1.0 / pi.\n     fn frac_1_pi() -> Self;\n-\n     /// 2.0 / pi.\n     fn frac_2_pi() -> Self;\n-\n     /// 2.0 / sqrt(pi).\n     fn frac_2_sqrtpi() -> Self;\n \n-    /// sqrt(2.0).\n-    fn sqrt2() -> Self;\n-\n-    /// 1.0 / sqrt(2.0).\n-    fn frac_1_sqrt2() -> Self;\n-\n-    /// Euler's number.\n-    fn e() -> Self;\n-\n-    /// log2(e).\n-    fn log2_e() -> Self;\n-\n-    /// log10(e).\n-    fn log10_e() -> Self;\n-\n-    /// ln(2.0).\n-    fn ln_2() -> Self;\n-\n-    /// ln(10.0).\n-    fn ln_10() -> Self;\n-\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(&self) -> Self;\n-\n-    /// Raise a number to a power.\n-    fn powf(&self, n: &Self) -> Self;\n-\n-    /// Raise a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    fn powi(&self, n: i32) -> Self;\n-\n-    /// Take the square root of a number.\n-    fn sqrt(&self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(&self) -> Self;\n-    /// Take the cubic root of a number.\n-    fn cbrt(&self) -> Self;\n-    /// Calculate the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n-    fn hypot(&self, other: &Self) -> Self;\n-\n     /// Computes the sine of a number (in radians).\n-    fn sin(&self) -> Self;\n+    fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n-    fn cos(&self) -> Self;\n+    fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n-    fn tan(&self) -> Self;\n+    fn tan(self) -> Self;\n \n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n-    fn asin(&self) -> Self;\n+    fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n-    fn acos(&self) -> Self;\n+    fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n-    fn atan(&self) -> Self;\n+    fn atan(self) -> Self;\n     /// Computes the four quadrant arctangent of a number, `y`, and another\n     /// number `x`. Return value is in radians in the range [-pi, pi].\n-    fn atan2(&self, other: &Self) -> Self;\n+    fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n-    fn sin_cos(&self) -> (Self, Self);\n+    fn sin_cos(self) -> (Self, Self);\n+\n+    /// Euler's number.\n+    fn e() -> Self;\n+    /// log2(e).\n+    fn log2_e() -> Self;\n+    /// log10(e).\n+    fn log10_e() -> Self;\n+    /// ln(2.0).\n+    fn ln_2() -> Self;\n+    /// ln(10.0).\n+    fn ln_10() -> Self;\n \n     /// Returns `e^(self)`, (the exponential function).\n-    fn exp(&self) -> Self;\n+    fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n-    fn exp2(&self) -> Self;\n+    fn exp2(self) -> Self;\n+    /// Returns the exponential of the number, minus 1, in a way that is\n+    /// accurate even if the number is close to zero.\n+    fn exp_m1(self) -> Self;\n     /// Returns the natural logarithm of the number.\n-    fn ln(&self) -> Self;\n+    fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n-    fn log(&self, base: &Self) -> Self;\n+    fn log(self, base: Self) -> Self;\n     /// Returns the base 2 logarithm of the number.\n-    fn log2(&self) -> Self;\n+    fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n-    fn log10(&self) -> Self;\n+    fn log10(self) -> Self;\n+    /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n+    /// accurately than if the operations were performed separately.\n+    fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n-    fn sinh(&self) -> Self;\n+    fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n-    fn cosh(&self) -> Self;\n+    fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n-    fn tanh(&self) -> Self;\n+    fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n-    fn asinh(&self) -> Self;\n+    fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n-    fn acosh(&self) -> Self;\n+    fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n-    fn atanh(&self) -> Self;\n+    fn atanh(self) -> Self;\n \n     /// Convert radians to degrees.\n-    fn to_degrees(&self) -> Self;\n+    fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    fn to_radians(&self) -> Self;\n+    fn to_radians(self) -> Self;\n }\n \n /// A generic trait for converting a value to a number."}, {"sha": "bb2fd2a4e257e2bba68bc3d4243b9c2fea71402b", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -15,7 +15,7 @@ use clone::Clone;\n use container::Container;\n use iter::Iterator;\n use num::{NumCast, Zero, One, cast, Int};\n-use num::{Round, Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n use num;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n@@ -258,7 +258,7 @@ pub fn int_to_str_bytes_common<T: Int>(num: T, radix: uint, sign: SignFormat, f:\n  * - Fails if `radix` > 25 and `exp_format` is `ExpBin` due to conflict\n  *   between digit and exponent sign `'p'`.\n  */\n-pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n+pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+\n                                   Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_upper: bool\n@@ -310,7 +310,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n                     ExpNone => unreachable!()\n                 };\n \n-                (num / exp_base.powf(&exp), cast::<T, i32>(exp).unwrap())\n+                (num / exp_base.powf(exp), cast::<T, i32>(exp).unwrap())\n             }\n         }\n     };\n@@ -491,7 +491,7 @@ pub fn float_to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Float+Round+\n  * `to_str_bytes_common()`, for details see there.\n  */\n #[inline]\n-pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+Round+\n+pub fn float_to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Float+\n                              Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits, exp_format: ExponentFormat, exp_capital: bool"}, {"sha": "724c4ca72ad0e445adb59fcfc7f9cc42166035c8", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -45,7 +45,7 @@ pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, CloneableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};\n pub use num::{Num, NumCast, CheckedAdd, CheckedSub, CheckedMul};\n-pub use num::{Signed, Unsigned, Round};\n+pub use num::{Signed, Unsigned};\n pub use num::{Primitive, Int, Float, ToPrimitive, FromPrimitive};\n pub use path::{GenericPath, Path, PosixPath, WindowsPath};\n pub use ptr::RawPtr;"}, {"sha": "67b5c557b595c58d6f5dd35542f0a3e6b8ebc116", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30fe55066a29a14fffd2a5f41e0ab21e7056fb34/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=30fe55066a29a14fffd2a5f41e0ab21e7056fb34", "patch": "@@ -352,8 +352,8 @@ pub fn write_boxplot(w: &mut io::Writer, s: &Summary,\n     let (q1,q2,q3) = s.quartiles;\n \n     // the .abs() handles the case where numbers are negative\n-    let lomag = (10.0_f64).powf(&(s.min.abs().log10().floor()));\n-    let himag = (10.0_f64).powf(&(s.max.abs().log10().floor()));\n+    let lomag = 10.0_f64.powf(s.min.abs().log10().floor());\n+    let himag = 10.0_f64.powf(s.max.abs().log10().floor());\n \n     // need to consider when the limit is zero\n     let lo = if lomag == 0.0 {"}]}