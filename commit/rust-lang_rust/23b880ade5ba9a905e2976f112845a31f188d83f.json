{"sha": "23b880ade5ba9a905e2976f112845a31f188d83f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzYjg4MGFkZTViYTlhOTA1ZTI5NzZmMTEyODQ1YTMxZjE4OGQ4M2Y=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-03-25T14:20:56Z"}, "committer": {"name": "Seiichi Uchida", "email": "seiichi.uchida@dena.com", "date": "2018-04-12T05:49:03Z"}, "message": "Run rustfmt on build_helper", "tree": {"sha": "b994fa8651e34758494a4e972a18e958e5cf11a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b994fa8651e34758494a4e972a18e958e5cf11a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23b880ade5ba9a905e2976f112845a31f188d83f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23b880ade5ba9a905e2976f112845a31f188d83f", "html_url": "https://github.com/rust-lang/rust/commit/23b880ade5ba9a905e2976f112845a31f188d83f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23b880ade5ba9a905e2976f112845a31f188d83f/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47778811d9752d9db0d1d4621bbc225317ad216b", "url": "https://api.github.com/repos/rust-lang/rust/commits/47778811d9752d9db0d1d4621bbc225317ad216b", "html_url": "https://github.com/rust-lang/rust/commit/47778811d9752d9db0d1d4621bbc225317ad216b"}], "stats": {"total": 117, "additions": 70, "deletions": 47}, "files": [{"sha": "2f9953330f42c8403a3304603c5eb851164dcfb6", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 70, "deletions": 47, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/23b880ade5ba9a905e2976f112845a31f188d83f/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23b880ade5ba9a905e2976f112845a31f188d83f/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=23b880ade5ba9a905e2976f112845a31f188d83f", "patch": "@@ -8,12 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n-use std::{fs, env};\n use std::time::{SystemTime, UNIX_EPOCH};\n+use std::{env, fs};\n \n /// A helper macro to `unwrap` a result except also print out details like:\n ///\n@@ -25,10 +24,12 @@ use std::time::{SystemTime, UNIX_EPOCH};\n /// using a `Result` with `try!`, but this may change one day...\n #[macro_export]\n macro_rules! t {\n-    ($e:expr) => (match $e {\n-        Ok(e) => e,\n-        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n-    })\n+    ($e:expr) => {\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+        }\n+    };\n }\n \n pub fn run(cmd: &mut Command) {\n@@ -45,14 +46,17 @@ pub fn run_silent(cmd: &mut Command) {\n pub fn try_run_silent(cmd: &mut Command) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n-                                cmd, e)),\n+        Err(e) => fail(&format!(\n+            \"failed to execute command: {:?}\\nerror: {}\",\n+            cmd, e\n+        )),\n     };\n     if !status.success() {\n-        println!(\"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-                  expected success, got: {}\\n\\n\",\n-                 cmd,\n-                 status);\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\",\n+            cmd, status\n+        );\n     }\n     status.success()\n }\n@@ -66,18 +70,22 @@ pub fn run_suppressed(cmd: &mut Command) {\n pub fn try_run_suppressed(cmd: &mut Command) -> bool {\n     let output = match cmd.output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n-                                cmd, e)),\n+        Err(e) => fail(&format!(\n+            \"failed to execute command: {:?}\\nerror: {}\",\n+            cmd, e\n+        )),\n     };\n     if !output.status.success() {\n-        println!(\"\\n\\ncommand did not execute successfully: {:?}\\n\\\n-                  expected success, got: {}\\n\\n\\\n-                  stdout ----\\n{}\\n\\\n-                  stderr ----\\n{}\\n\\n\",\n-                 cmd,\n-                 output.status,\n-                 String::from_utf8_lossy(&output.stdout),\n-                 String::from_utf8_lossy(&output.stderr));\n+        println!(\n+            \"\\n\\ncommand did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\\n\\n\\\n+             stdout ----\\n{}\\n\\\n+             stderr ----\\n{}\\n\\n\",\n+            cmd,\n+            output.status,\n+            String::from_utf8_lossy(&output.stdout),\n+            String::from_utf8_lossy(&output.stderr)\n+        );\n     }\n     output.status.success()\n }\n@@ -93,9 +101,9 @@ pub fn gnu_target(target: &str) -> String {\n }\n \n pub fn make(host: &str) -> PathBuf {\n-    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") ||\n-        host.contains(\"freebsd\") || host.contains(\"netbsd\") ||\n-        host.contains(\"openbsd\") {\n+    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n+        || host.contains(\"netbsd\") || host.contains(\"openbsd\")\n+    {\n         PathBuf::from(\"gmake\")\n     } else {\n         PathBuf::from(\"make\")\n@@ -105,23 +113,27 @@ pub fn make(host: &str) -> PathBuf {\n pub fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n-                                cmd, e)),\n+        Err(e) => fail(&format!(\n+            \"failed to execute command: {:?}\\nerror: {}\",\n+            cmd, e\n+        )),\n     };\n     if !output.status.success() {\n-        panic!(\"command did not execute successfully: {:?}\\n\\\n-                expected success, got: {}\",\n-               cmd,\n-               output.status);\n+        panic!(\n+            \"command did not execute successfully: {:?}\\n\\\n+             expected success, got: {}\",\n+            cmd, output.status\n+        );\n     }\n     String::from_utf8(output.stdout).unwrap()\n }\n \n pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n-    let mut stack = dir.read_dir().unwrap()\n-                       .map(|e| e.unwrap())\n-                       .filter(|e| &*e.file_name() != \".git\")\n-                       .collect::<Vec<_>>();\n+    let mut stack = dir.read_dir()\n+        .unwrap()\n+        .map(|e| e.unwrap())\n+        .filter(|e| &*e.file_name() != \".git\")\n+        .collect::<Vec<_>>();\n     while let Some(entry) = stack.pop() {\n         let path = entry.path();\n         if entry.file_type().unwrap().is_dir() {\n@@ -134,7 +146,9 @@ pub fn rerun_if_changed_anything_in_dir(dir: &Path) {\n \n /// Returns the last-modified time for `path`, or zero if it doesn't exist.\n pub fn mtime(path: &Path) -> SystemTime {\n-    fs::metadata(path).and_then(|f| f.modified()).unwrap_or(UNIX_EPOCH)\n+    fs::metadata(path)\n+        .and_then(|f| f.modified())\n+        .unwrap_or(UNIX_EPOCH)\n }\n \n /// Returns whether `dst` is up to date given that the file or files in `src`\n@@ -175,11 +189,12 @@ impl Drop for NativeLibBoilerplate {\n // If Err is returned, then everything is up-to-date and further build actions can be skipped.\n // Timestamps are created automatically when the result of `native_lib_boilerplate` goes out\n // of scope, so all the build actions should be completed until then.\n-pub fn native_lib_boilerplate(src_name: &str,\n-                              out_name: &str,\n-                              link_name: &str,\n-                              search_subdir: &str)\n-                              -> Result<NativeLibBoilerplate, ()> {\n+pub fn native_lib_boilerplate(\n+    src_name: &str,\n+    out_name: &str,\n+    link_name: &str,\n+    search_subdir: &str,\n+) -> Result<NativeLibBoilerplate, ()> {\n     let current_dir = PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\").unwrap());\n     let src_dir = current_dir.join(\"..\").join(src_name);\n     rerun_if_changed_anything_in_dir(&src_dir);\n@@ -192,11 +207,17 @@ pub fn native_lib_boilerplate(src_name: &str,\n     } else {\n         println!(\"cargo:rustc-link-lib=static={}\", link_name);\n     }\n-    println!(\"cargo:rustc-link-search=native={}\", out_dir.join(search_subdir).display());\n+    println!(\n+        \"cargo:rustc-link-search=native={}\",\n+        out_dir.join(search_subdir).display()\n+    );\n \n     let timestamp = out_dir.join(\"rustbuild.timestamp\");\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(&src_dir, &timestamp) {\n-        Ok(NativeLibBoilerplate { src_dir: src_dir, out_dir: out_dir })\n+        Ok(NativeLibBoilerplate {\n+            src_dir: src_dir,\n+            out_dir: out_dir,\n+        })\n     } else {\n         Err(())\n     }\n@@ -214,10 +235,12 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str) -> Result<NativeLibBoiler\n         ),\n         _ => return Err(()),\n     };\n-    native_lib_boilerplate(\"libcompiler_builtins/compiler-rt\",\n-                           sanitizer_name,\n-                           &link_name,\n-                           search_path)\n+    native_lib_boilerplate(\n+        \"libcompiler_builtins/compiler-rt\",\n+        sanitizer_name,\n+        &link_name,\n+        search_path,\n+    )\n }\n \n fn dir_up_to_date(src: &Path, threshold: SystemTime) -> bool {"}]}