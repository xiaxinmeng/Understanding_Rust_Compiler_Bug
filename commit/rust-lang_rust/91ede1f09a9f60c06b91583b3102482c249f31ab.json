{"sha": "91ede1f09a9f60c06b91583b3102482c249f31ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxZWRlMWYwOWE5ZjYwYzA2YjkxNTgzYjMxMDI0ODJjMjQ5ZjMxYWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-01T05:54:25Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-07T15:15:58Z"}, "message": "core: Inherit non-allocating slice functionality\n\nThis commit adds a new trait, MutableVectorAllocating, which represents\nfunctions on vectors which can allocate.\n\nThis is another extension trait to slices which should be removed once a lang\nitem exists for the ~ allocation.", "tree": {"sha": "ad767f7063447ba190702e5f83c5968ea4f8c1e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad767f7063447ba190702e5f83c5968ea4f8c1e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91ede1f09a9f60c06b91583b3102482c249f31ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91ede1f09a9f60c06b91583b3102482c249f31ab", "html_url": "https://github.com/rust-lang/rust/commit/91ede1f09a9f60c06b91583b3102482c249f31ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91ede1f09a9f60c06b91583b3102482c249f31ab/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be0a11729e5226a758261ba4f095978ef2105837", "url": "https://api.github.com/repos/rust-lang/rust/commits/be0a11729e5226a758261ba4f095978ef2105837", "html_url": "https://github.com/rust-lang/rust/commit/be0a11729e5226a758261ba4f095978ef2105837"}], "stats": {"total": 3216, "additions": 1599, "deletions": 1617}, "files": [{"sha": "d0cfb7c1b9fdd8dbee984ab64f91af55b12efeda", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -69,4 +69,5 @@ pub mod iter;\n pub mod option;\n pub mod raw;\n pub mod char;\n+pub mod slice;\n pub mod tuple;"}, {"sha": "b828ad3361effbab67a7201cee2476daea64f7d1", "filename": "src/libcore/slice.rs", "status": "added", "additions": 1483, "deletions": 0, "changes": 1483, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -0,0 +1,1483 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Slice management and manipulation\n+//!\n+//! For more details `std::slice`.\n+\n+use cast;\n+use cast::transmute;\n+use clone::Clone;\n+use container::Container;\n+use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp;\n+use default::Default;\n+use iter::*;\n+use num::{CheckedAdd, Saturating, div_rem};\n+use option::{None, Option, Some};\n+use ptr;\n+use ptr::RawPtr;\n+use mem;\n+use mem::size_of;\n+use kinds::marker;\n+use raw::{Repr, Slice};\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n+    unsafe {\n+        transmute(Slice { data: s, len: 1 })\n+    }\n+}\n+\n+/**\n+ * Converts a pointer to A into a slice of length 1 (without copying).\n+ */\n+pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n+    unsafe {\n+        let ptr: *A = transmute(s);\n+        transmute(Slice { data: ptr, len: 1 })\n+    }\n+}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function.\n+pub struct Splits<'a, T> {\n+    v: &'a [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(0, idx));\n+                self.v = self.v.slice(idx + 1, self.v.len());\n+                ret\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                Some(self.v)\n+            }\n+            Some(idx) => {\n+                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n+                self.v = self.v.slice(0, idx);\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over the slices of a vector separated by elements that\n+/// match a predicate function, splitting at most a fixed number of times.\n+pub struct SplitsN<'a, T> {\n+    iter: Splits<'a, T>,\n+    count: uint,\n+    invert: bool\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.count == 0 {\n+            if self.iter.finished {\n+                None\n+            } else {\n+                self.iter.finished = true;\n+                Some(self.iter.v)\n+            }\n+        } else {\n+            self.count -= 1;\n+            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.iter.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n+        }\n+    }\n+}\n+\n+// Functional utilities\n+\n+/// An iterator over the (overlapping) slices of length `size` within\n+/// a vector.\n+#[deriving(Clone)]\n+pub struct Windows<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.size > self.v.len() {\n+            None\n+        } else {\n+            let ret = Some(self.v.slice(0, self.size));\n+            self.v = self.v.slice(1, self.v.len());\n+            ret\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.size > self.v.len() {\n+            (0, Some(0))\n+        } else {\n+            let x = self.v.len() - self.size;\n+            (x.saturating_add(1), x.checked_add(&1u))\n+        }\n+    }\n+}\n+\n+/// An iterator over a vector in (non-overlapping) chunks (`size`\n+/// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainder.\n+#[deriving(Clone)]\n+pub struct Chunks<'a, T> {\n+    v: &'a [T],\n+    size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.size);\n+            let n = if rem > 0 { n+1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n+    }\n+\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            let mut hi = lo + self.size;\n+            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n+\n+            Some(self.v.slice(lo, hi))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+// Equality\n+\n+#[cfg(not(test))]\n+#[allow(missing_doc)]\n+pub mod traits {\n+    use super::*;\n+\n+    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n+    use iter::{order, Iterator};\n+    use container::Container;\n+\n+    impl<'a,T:Eq> Eq for &'a [T] {\n+        fn eq(&self, other: & &'a [T]) -> bool {\n+            self.len() == other.len() &&\n+                order::eq(self.iter(), other.iter())\n+        }\n+        fn ne(&self, other: & &'a [T]) -> bool {\n+            self.len() != other.len() ||\n+                order::ne(self.iter(), other.iter())\n+        }\n+    }\n+\n+    impl<T:Eq> Eq for ~[T] {\n+        #[inline]\n+        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n+        #[inline]\n+        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n+    }\n+\n+    impl<'a,T:TotalEq> TotalEq for &'a [T] {}\n+\n+    impl<T:TotalEq> TotalEq for ~[T] {}\n+\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n+\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+        #[inline]\n+        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n+    }\n+\n+    impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n+        fn cmp(&self, other: & &'a [T]) -> Ordering {\n+            order::cmp(self.iter(), other.iter())\n+        }\n+    }\n+\n+    impl<T: TotalOrd> TotalOrd for ~[T] {\n+        #[inline]\n+        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n+    }\n+\n+    impl<'a, T: Ord> Ord for &'a [T] {\n+        fn lt(&self, other: & &'a [T]) -> bool {\n+            order::lt(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn le(&self, other: & &'a [T]) -> bool {\n+            order::le(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn ge(&self, other: & &'a [T]) -> bool {\n+            order::ge(self.iter(), other.iter())\n+        }\n+        #[inline]\n+        fn gt(&self, other: & &'a [T]) -> bool {\n+            order::gt(self.iter(), other.iter())\n+        }\n+    }\n+\n+    impl<T: Ord> Ord for ~[T] {\n+        #[inline]\n+        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n+        #[inline]\n+        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n+        #[inline]\n+        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n+        #[inline]\n+        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n+    }\n+}\n+\n+#[cfg(test)]\n+pub mod traits {}\n+\n+/// Any vector that can be represented as a slice.\n+pub trait Vector<T> {\n+    /// Work with `self` as a slice.\n+    fn as_slice<'a>(&'a self) -> &'a [T];\n+}\n+\n+impl<'a,T> Vector<T> for &'a [T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n+}\n+\n+impl<T> Vector<T> for ~[T] {\n+    #[inline(always)]\n+    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n+}\n+\n+impl<'a, T> Container for &'a [T] {\n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.repr().len\n+    }\n+}\n+\n+impl<T> Container for ~[T] {\n+    /// Returns the length of a vector\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.as_slice().len()\n+    }\n+}\n+\n+/// Extension methods for vectors\n+pub trait ImmutableVector<'a, T> {\n+    /**\n+     * Returns a slice of self between `start` and `end`.\n+     *\n+     * Fails when `start` or `end` point outside the bounds of self,\n+     * or when `start` > `end`.\n+     */\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    fn slice_from(&self, start: uint) -> &'a [T];\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    fn slice_to(&self, end: uint) -> &'a [T];\n+    /// Returns an iterator over the vector\n+    fn iter(self) -> Items<'a, T>;\n+    /// Returns a reversed iterator over a vector\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`.  The matched element\n+    /// is not contained in the subslices.\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`, limited to splitting\n+    /// at most `n` times.  The matched element is not contained in\n+    /// the subslices.\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred`. This starts at the\n+    /// end of the vector and works backwards.  The matched element is\n+    /// not contained in the subslices.\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n+    /// Returns an iterator over the subslices of the vector which are\n+    /// separated by elements that match `pred` limited to splitting\n+    /// at most `n` times. This starts at the end of the vector and\n+    /// works backwards.  The matched element is not contained in the\n+    /// subslices.\n+    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+\n+    /**\n+     * Returns an iterator over all contiguous windows of length\n+     * `size`. The windows overlap. If the vector is shorter than\n+     * `size`, the iterator returns no values.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n+     * `[3,4]`):\n+     *\n+     * ```rust\n+     * let v = &[1,2,3,4];\n+     * for win in v.windows(2) {\n+     *     println!(\"{:?}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn windows(self, size: uint) -> Windows<'a, T>;\n+    /**\n+     *\n+     * Returns an iterator over `size` elements of the vector at a\n+     * time. The chunks do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     *\n+     * # Example\n+     *\n+     * Print the vector two elements at a time (i.e. `[1,2]`,\n+     * `[3,4]`, `[5]`):\n+     *\n+     * ```rust\n+     * let v = &[1,2,3,4,5];\n+     * for win in v.chunks(2) {\n+     *     println!(\"{:?}\", win);\n+     * }\n+     * ```\n+     *\n+     */\n+    fn chunks(self, size: uint) -> Chunks<'a, T>;\n+\n+    /// Returns the element of a vector at the given index, or `None` if the\n+    /// index is out of bounds\n+    fn get(&self, index: uint) -> Option<&'a T>;\n+    /// Returns the first element of a vector, or `None` if it is empty\n+    fn head(&self) -> Option<&'a T>;\n+    /// Returns all but the first element of a vector\n+    fn tail(&self) -> &'a [T];\n+    /// Returns all but the first `n' elements of a vector\n+    fn tailn(&self, n: uint) -> &'a [T];\n+    /// Returns all but the last element of a vector\n+    fn init(&self) -> &'a [T];\n+    /// Returns all but the last `n' elements of a vector\n+    fn initn(&self, n: uint) -> &'a [T];\n+    /// Returns the last element of a vector, or `None` if it is empty.\n+    fn last(&self) -> Option<&'a T>;\n+\n+    /// Returns a pointer to the element at the given index, without doing\n+    /// bounds checking.\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n+\n+    /**\n+     * Returns an unsafe pointer to the vector's buffer\n+     *\n+     * The caller must ensure that the vector outlives the pointer this\n+     * function returns, or else it will end up pointing to garbage.\n+     *\n+     * Modifying the vector may cause its buffer to be reallocated, which\n+     * would also make any pointers to it invalid.\n+     */\n+    fn as_ptr(&self) -> *T;\n+\n+    /**\n+     * Binary search a sorted vector with a comparator function.\n+     *\n+     * The comparator function should implement an order consistent\n+     * with the sort order of the underlying vector, returning an\n+     * order code that indicates whether its argument is `Less`,\n+     * `Equal` or `Greater` the desired target.\n+     *\n+     * Returns the index where the comparator returned `Equal`, or `None` if\n+     * not found.\n+     */\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+\n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None }\n+     *     let head = &self[0];\n+     *     *self = self.slice_from(1);\n+     *     Some(head)\n+     * ```\n+     *\n+     * Returns `None` if vector is empty\n+     */\n+    fn shift_ref(&mut self) -> Option<&'a T>;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let tail = &self[self.len() - 1];\n+     *     *self = self.slice_to(self.len() - 1);\n+     *     Some(tail)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty.\n+     */\n+    fn pop_ref(&mut self) -> Option<&'a T>;\n+}\n+\n+impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_ptr().offset(start as int),\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n+        self.slice(start, self.len())\n+    }\n+\n+    #[inline]\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n+        self.slice(0, end)\n+    }\n+\n+    #[inline]\n+    fn iter(self) -> Items<'a, T> {\n+        unsafe {\n+            let p = self.as_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                Items{ptr: p,\n+                      end: (p as uint + self.len()) as *T,\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            } else {\n+                Items{ptr: p,\n+                      end: p.offset(self.len() as int),\n+                      marker: marker::ContravariantLifetime::<'a>}\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .iter().rev()\"]\n+    fn rev_iter(self) -> Rev<Items<'a, T>> {\n+        self.iter().rev()\n+    }\n+\n+    #[inline]\n+    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n+        Splits {\n+            v: self,\n+            pred: pred,\n+            finished: false\n+        }\n+    }\n+\n+    #[inline]\n+    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: false\n+        }\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .split(pred).rev()\"]\n+    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n+        self.split(pred).rev()\n+    }\n+\n+    #[inline]\n+    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n+        SplitsN {\n+            iter: self.split(pred),\n+            count: n,\n+            invert: true\n+        }\n+    }\n+\n+    #[inline]\n+    fn windows(self, size: uint) -> Windows<'a, T> {\n+        assert!(size != 0);\n+        Windows { v: self, size: size }\n+    }\n+\n+    #[inline]\n+    fn chunks(self, size: uint) -> Chunks<'a, T> {\n+        assert!(size != 0);\n+        Chunks { v: self, size: size }\n+    }\n+\n+    #[inline]\n+    fn get(&self, index: uint) -> Option<&'a T> {\n+        if index < self.len() { Some(&self[index]) } else { None }\n+    }\n+\n+    #[inline]\n+    fn head(&self) -> Option<&'a T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n+    }\n+\n+    #[inline]\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n+\n+    #[inline]\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n+\n+    #[inline]\n+    fn init(&self) -> &'a [T] {\n+        self.slice(0, self.len() - 1)\n+    }\n+\n+    #[inline]\n+    fn initn(&self, n: uint) -> &'a [T] {\n+        self.slice(0, self.len() - n)\n+    }\n+\n+    #[inline]\n+    fn last(&self) -> Option<&'a T> {\n+            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n+        transmute(self.repr().data.offset(index as int))\n+    }\n+\n+    #[inline]\n+    fn as_ptr(&self) -> *T {\n+        self.repr().data\n+    }\n+\n+\n+    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n+        let mut base : uint = 0;\n+        let mut lim : uint = self.len();\n+\n+        while lim != 0 {\n+            let ix = base + (lim >> 1);\n+            match f(&self[ix]) {\n+                Equal => return Some(ix),\n+                Less => {\n+                    base = ix + 1;\n+                    lim -= 1;\n+                }\n+                Greater => ()\n+            }\n+            lim >>= 1;\n+        }\n+        return None;\n+    }\n+\n+    fn shift_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            Some(&*raw::shift_ptr(s))\n+        }\n+    }\n+\n+    fn pop_ref(&mut self) -> Option<&'a T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            Some(&*raw::pop_ptr(s))\n+        }\n+    }\n+}\n+\n+/// Extension methods for vectors contain `Eq` elements.\n+pub trait ImmutableEqVector<T:Eq> {\n+    /// Find the first index containing a matching value\n+    fn position_elem(&self, t: &T) -> Option<uint>;\n+\n+    /// Find the last index containing a matching value\n+    fn rposition_elem(&self, t: &T) -> Option<uint>;\n+\n+    /// Return true if a vector contains an element with the given value\n+    fn contains(&self, x: &T) -> bool;\n+\n+    /// Returns true if `needle` is a prefix of the vector.\n+    fn starts_with(&self, needle: &[T]) -> bool;\n+\n+    /// Returns true if `needle` is a suffix of the vector.\n+    fn ends_with(&self, needle: &[T]) -> bool;\n+}\n+\n+impl<'a,T:Eq> ImmutableEqVector<T> for &'a [T] {\n+    #[inline]\n+    fn position_elem(&self, x: &T) -> Option<uint> {\n+        self.iter().position(|y| *x == *y)\n+    }\n+\n+    #[inline]\n+    fn rposition_elem(&self, t: &T) -> Option<uint> {\n+        self.iter().rposition(|x| *x == *t)\n+    }\n+\n+    #[inline]\n+    fn contains(&self, x: &T) -> bool {\n+        self.iter().any(|elt| *x == *elt)\n+    }\n+\n+    #[inline]\n+    fn starts_with(&self, needle: &[T]) -> bool {\n+        let n = needle.len();\n+        self.len() >= n && needle == self.slice_to(n)\n+    }\n+\n+    #[inline]\n+    fn ends_with(&self, needle: &[T]) -> bool {\n+        let (m, n) = (self.len(), needle.len());\n+        m >= n && needle == self.slice_from(m - n)\n+    }\n+}\n+\n+/// Extension methods for vectors containing `TotalOrd` elements.\n+pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n+    /**\n+     * Binary search a sorted vector for a given element.\n+     *\n+     * Returns the index of the element or None if not found.\n+     */\n+    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n+}\n+\n+impl<'a, T: TotalOrd> ImmutableTotalOrdVector<T> for &'a [T] {\n+    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n+        self.bsearch(|p| p.cmp(x))\n+    }\n+}\n+\n+/// Extension methods for vectors such that their elements are\n+/// mutable.\n+pub trait MutableVector<'a, T> {\n+    /// Work with `self` as a mut slice.\n+    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n+    fn as_mut_slice(self) -> &'a mut [T];\n+\n+    /// Return a slice that points into another slice.\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n+\n+    /**\n+     * Returns a slice of self from `start` to the end of the vec.\n+     *\n+     * Fails when `start` points outside the bounds of self.\n+     */\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n+\n+    /**\n+     * Returns a slice of self from the start of the vec to `end`.\n+     *\n+     * Fails when `end` points outside the bounds of self.\n+     */\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n+\n+    /// Returns an iterator that allows modifying each value\n+    fn mut_iter(self) -> MutItems<'a, T>;\n+\n+    /// Returns a mutable pointer to the last item in the vector.\n+    fn mut_last(self) -> Option<&'a mut T>;\n+\n+    /// Returns a reversed iterator that allows modifying each value\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>>;\n+\n+    /// Returns an iterator over the mutable subslices of the vector\n+    /// which are separated by elements that match `pred`.  The\n+    /// matched element is not contained in the subslices.\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n+\n+    /**\n+     * Returns an iterator over `size` elements of the vector at a time.\n+     * The chunks are mutable and do not overlap. If `size` does not divide the\n+     * length of the vector, then the last chunk will not have length\n+     * `size`.\n+     *\n+     * # Failure\n+     *\n+     * Fails if `size` is 0.\n+     */\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n+\n+    /**\n+     * Returns a mutable reference to the first element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let head = &mut self[0];\n+     *     *self = self.mut_slice_from(1);\n+     *     Some(head)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty\n+     */\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n+\n+    /**\n+     * Returns a mutable reference to the last element in this slice\n+     * and adjusts the slice in place so that it no longer contains\n+     * that element. O(1).\n+     *\n+     * Equivalent to:\n+     *\n+     * ```ignore\n+     *     if self.len() == 0 { return None; }\n+     *     let tail = &mut self[self.len() - 1];\n+     *     *self = self.mut_slice_to(self.len() - 1);\n+     *     Some(tail)\n+     * ```\n+     *\n+     * Returns `None` if slice is empty.\n+     */\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n+\n+    /// Swaps two elements in a vector.\n+    ///\n+    /// Fails if `a` or `b` are out of bounds.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// * a - The index of the first element\n+    /// * b - The index of the second element\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n+    /// v.swap(1, 3);\n+    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n+    /// ```\n+    fn swap(self, a: uint, b: uint);\n+\n+\n+    /// Divides one `&mut` into two at an index.\n+    ///\n+    /// The first will contain all indices from `[0, mid)` (excluding\n+    /// the index `mid` itself) and the second will contain all\n+    /// indices from `[mid, len)` (excluding the index `len` itself).\n+    ///\n+    /// Fails if `mid > len`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3, 4, 5, 6];\n+    ///\n+    /// // scoped to restrict the lifetime of the borrows\n+    /// {\n+    ///    let (left, right) = v.mut_split_at(0);\n+    ///    assert!(left == &mut []);\n+    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(2);\n+    ///     assert!(left == &mut [1, 2]);\n+    ///     assert!(right == &mut [3, 4, 5, 6]);\n+    /// }\n+    ///\n+    /// {\n+    ///     let (left, right) = v.mut_split_at(6);\n+    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n+    ///     assert!(right == &mut []);\n+    /// }\n+    /// ```\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n+\n+    /// Reverse the order of elements in a vector, in place.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [1, 2, 3];\n+    /// v.reverse();\n+    /// assert!(v == [3, 2, 1]);\n+    /// ```\n+    fn reverse(self);\n+\n+    /// Returns an unsafe mutable pointer to the element in index\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n+\n+    /// Return an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    ///\n+    /// Modifying the vector may cause its buffer to be reallocated, which\n+    /// would also make any pointers to it invalid.\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T;\n+\n+    /// Unsafely sets the element in index to the value.\n+    ///\n+    /// This performs no bounds checks, and it is undefined behaviour\n+    /// if `index` is larger than the length of `self`. However, it\n+    /// does run the destructor at `index`. It is equivalent to\n+    /// `self[index] = val`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = ~[\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned()];\n+    ///\n+    /// unsafe {\n+    ///     // `\"baz\".to_owned()` is deallocated.\n+    ///     v.unsafe_set(2, \"qux\".to_owned());\n+    ///\n+    ///     // Out of bounds: could cause a crash, or overwriting\n+    ///     // other data, or something else.\n+    ///     // v.unsafe_set(10, \"oops\".to_owned());\n+    /// }\n+    /// ```\n+    unsafe fn unsafe_set(self, index: uint, val: T);\n+\n+    /// Unchecked vector index assignment.  Does not drop the\n+    /// old value and hence is only suitable when the vector\n+    /// is newly allocated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let mut v = [\"foo\".to_owned(), \"bar\".to_owned()];\n+    ///\n+    /// // memory leak! `\"bar\".to_owned()` is not deallocated.\n+    /// unsafe { v.init_elem(1, \"baz\".to_owned()); }\n+    /// ```\n+    unsafe fn init_elem(self, i: uint, val: T);\n+\n+    /// Copies raw bytes from `src` to `self`.\n+    ///\n+    /// This does not run destructors on the overwritten elements, and\n+    /// ignores move semantics. `self` and `src` must not\n+    /// overlap. Fails if `self` is shorter than `src`.\n+    unsafe fn copy_memory(self, src: &[T]);\n+}\n+\n+impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n+    #[inline]\n+    fn as_mut_slice(self) -> &'a mut [T] { self }\n+\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n+        assert!(start <= end);\n+        assert!(end <= self.len());\n+        unsafe {\n+            transmute(Slice {\n+                    data: self.as_mut_ptr().offset(start as int) as *T,\n+                    len: (end - start)\n+                })\n+        }\n+    }\n+\n+    #[inline]\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n+        let len = self.len();\n+        self.mut_slice(start, len)\n+    }\n+\n+    #[inline]\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n+        self.mut_slice(0, end)\n+    }\n+\n+    #[inline]\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n+        unsafe {\n+            let len = self.len();\n+            let self2: &'a mut [T] = cast::transmute_copy(&self);\n+            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n+        }\n+    }\n+\n+    #[inline]\n+    fn mut_iter(self) -> MutItems<'a, T> {\n+        unsafe {\n+            let p = self.as_mut_ptr();\n+            if mem::size_of::<T>() == 0 {\n+                MutItems{ptr: p,\n+                         end: (p as uint + self.len()) as *mut T,\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            } else {\n+                MutItems{ptr: p,\n+                         end: p.offset(self.len() as int),\n+                         marker: marker::ContravariantLifetime::<'a>,\n+                         marker2: marker::NoCopy}\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn mut_last(self) -> Option<&'a mut T> {\n+        let len = self.len();\n+        if len == 0 { return None; }\n+        Some(&mut self[len - 1])\n+    }\n+\n+    #[inline]\n+    #[deprecated = \"replaced by .mut_iter().rev()\"]\n+    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>> {\n+        self.mut_iter().rev()\n+    }\n+\n+    #[inline]\n+    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n+        MutSplits { v: self, pred: pred, finished: false }\n+    }\n+\n+    #[inline]\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n+        assert!(chunk_size > 0);\n+        MutChunks { v: self, chunk_size: chunk_size }\n+    }\n+\n+    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::shift_ptr(s) as *mut _))\n+        }\n+    }\n+\n+    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n+        if self.len() == 0 { return None; }\n+        unsafe {\n+            let s: &mut Slice<T> = transmute(self);\n+            // FIXME #13933: this `&` -> `&mut` cast is a little\n+            // dubious\n+            Some(&mut *(raw::pop_ptr(s) as *mut _))\n+        }\n+    }\n+\n+    fn swap(self, a: uint, b: uint) {\n+        unsafe {\n+            // Can't take two mutable loans from one vector, so instead just cast\n+            // them to their raw pointers to do the swap\n+            let pa: *mut T = &mut self[a];\n+            let pb: *mut T = &mut self[b];\n+            ptr::swap(pa, pb);\n+        }\n+    }\n+\n+    fn reverse(self) {\n+        let mut i: uint = 0;\n+        let ln = self.len();\n+        while i < ln / 2 {\n+            self.swap(i, ln - i - 1);\n+            i += 1;\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n+        transmute((self.repr().data as *mut T).offset(index as int))\n+    }\n+\n+    #[inline]\n+    fn as_mut_ptr(self) -> *mut T {\n+        self.repr().data as *mut T\n+    }\n+\n+    #[inline]\n+    unsafe fn unsafe_set(self, index: uint, val: T) {\n+        *self.unsafe_mut_ref(index) = val;\n+    }\n+\n+    #[inline]\n+    unsafe fn init_elem(self, i: uint, val: T) {\n+        mem::move_val_init(&mut (*self.as_mut_ptr().offset(i as int)), val);\n+    }\n+\n+    #[inline]\n+    unsafe fn copy_memory(self, src: &[T]) {\n+        let len_src = src.len();\n+        assert!(self.len() >= len_src);\n+        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n+    }\n+}\n+\n+/// Trait for &[T] where T is Cloneable\n+pub trait MutableCloneableVector<T> {\n+    /// Copies as many elements from `src` as it can into `self` (the\n+    /// shorter of `self.len()` and `src.len()`). Returns the number\n+    /// of elements copied.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// use std::slice::MutableCloneableVector;\n+    ///\n+    /// let mut dst = [0, 0, 0];\n+    /// let src = [1, 2];\n+    ///\n+    /// assert!(dst.copy_from(src) == 2);\n+    /// assert!(dst == [1, 2, 0]);\n+    ///\n+    /// let src2 = [3, 4, 5, 6];\n+    /// assert!(dst.copy_from(src2) == 3);\n+    /// assert!(dst == [3, 4, 5]);\n+    /// ```\n+    fn copy_from(self, &[T]) -> uint;\n+}\n+\n+impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n+    #[inline]\n+    fn copy_from(self, src: &[T]) -> uint {\n+        for (a, b) in self.mut_iter().zip(src.iter()) {\n+            a.clone_from(b);\n+        }\n+        cmp::min(self.len(), src.len())\n+    }\n+}\n+\n+/// Unsafe operations\n+pub mod raw {\n+    use cast::transmute;\n+    use iter::Iterator;\n+    use ptr::RawPtr;\n+    use raw::Slice;\n+\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n+                               -> U {\n+        f(transmute(Slice {\n+            data: p,\n+            len: len\n+        }))\n+    }\n+\n+    /**\n+     * Form a slice from a pointer and length (as a number of units,\n+     * not bytes).\n+     */\n+    #[inline]\n+    pub unsafe fn mut_buf_as_slice<T,\n+                                   U>(\n+                                   p: *mut T,\n+                                   len: uint,\n+                                   f: |v: &mut [T]| -> U)\n+                                   -> U {\n+        f(transmute(Slice {\n+            data: p as *T,\n+            len: len\n+        }))\n+    }\n+\n+    /**\n+     * Returns a pointer to first element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n+        let head: *T = slice.data;\n+        slice.data = slice.data.offset(1);\n+        slice.len -= 1;\n+        head\n+    }\n+\n+    /**\n+     * Returns a pointer to last element in slice and adjusts\n+     * slice so it no longer contains that element. Fails if\n+     * slice is empty. O(1).\n+     */\n+    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n+        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n+        let tail: *T = slice.data.offset((slice.len - 1) as int);\n+        slice.len -= 1;\n+        tail\n+    }\n+}\n+\n+/// Operations on `[u8]`.\n+pub mod bytes {\n+    use container::Container;\n+    use ptr;\n+    use slice::MutableVector;\n+\n+    /// A trait for operations on mutable `[u8]`s.\n+    pub trait MutableByteVector {\n+        /// Sets all bytes of the receiver to the given value.\n+        fn set_memory(self, value: u8);\n+    }\n+\n+    impl<'a> MutableByteVector for &'a mut [u8] {\n+        #[inline]\n+        fn set_memory(self, value: u8) {\n+            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n+        }\n+    }\n+\n+    /// Copies data from `src` to `dst`\n+    ///\n+    /// `src` and `dst` must not overlap. Fails if the length of `dst`\n+    /// is less than the length of `src`.\n+    #[inline]\n+    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n+        // Bound checks are done at .copy_memory.\n+        unsafe { dst.copy_memory(src) }\n+    }\n+}\n+\n+/// Immutable slice iterator\n+pub struct Items<'a, T> {\n+    ptr: *T,\n+    end: *T,\n+    marker: marker::ContravariantLifetime<'a>\n+}\n+\n+/// Mutable slice iterator\n+pub struct MutItems<'a, T> {\n+    ptr: *mut T,\n+    end: *mut T,\n+    marker: marker::ContravariantLifetime<'a>,\n+    marker2: marker::NoCopy\n+}\n+\n+macro_rules! iterator {\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.ptr == self.end {\n+                        None\n+                    } else {\n+                        let old = self.ptr;\n+                        self.ptr = if mem::size_of::<T>() == 0 {\n+                            // purposefully don't use 'ptr.offset' because for\n+                            // vectors with 0-size elements this would return the\n+                            // same pointer.\n+                            transmute(self.ptr as uint + 1)\n+                        } else {\n+                            self.ptr.offset(1)\n+                        };\n+\n+                        Some(transmute(old))\n+                    }\n+                }\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                let diff = (self.end as uint) - (self.ptr as uint);\n+                let exact = diff / mem::nonzero_size_of::<T>();\n+                (exact, Some(exact))\n+            }\n+        }\n+\n+        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n+            #[inline]\n+            fn next_back(&mut self) -> Option<$elem> {\n+                // could be implemented with slices, but this avoids bounds checks\n+                unsafe {\n+                    if self.end == self.ptr {\n+                        None\n+                    } else {\n+                        self.end = if mem::size_of::<T>() == 0 {\n+                            // See above for why 'ptr.offset' isn't used\n+                            transmute(self.end as uint - 1)\n+                        } else {\n+                            self.end.offset(-1)\n+                        };\n+                        Some(transmute(self.end))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        let (exact, _) = self.size_hint();\n+        exact\n+    }\n+\n+    #[inline]\n+    fn idx(&mut self, index: uint) -> Option<&'a T> {\n+        unsafe {\n+            if index < self.indexable() {\n+                transmute(self.ptr.offset(index as int))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+iterator!{struct Items -> *T, &'a T}\n+#[deprecated = \"replaced by Rev<Items<'a, T>>\"]\n+pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n+\n+impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n+impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n+\n+impl<'a, T> Clone for Items<'a, T> {\n+    fn clone(&self) -> Items<'a, T> { *self }\n+}\n+\n+iterator!{struct MutItems -> *mut T, &'a mut T}\n+#[deprecated = \"replaced by Rev<MutItems<'a, T>>\"]\n+pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n+\n+/// An iterator over the subslices of the vector which are separated\n+/// by elements that match `pred`.\n+pub struct MutSplits<'a, T> {\n+    v: &'a mut [T],\n+    pred: |t: &T|: 'a -> bool,\n+    finished: bool\n+}\n+\n+impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().position(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let len = tmp.len();\n+                let (head, tail) = tmp.mut_split_at(len);\n+                self.v = tail;\n+                Some(head)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = tail.mut_slice_from(1);\n+                Some(head)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let pred = &mut self.pred;\n+        match self.v.iter().rposition(|x| (*pred)(x)) {\n+            None => {\n+                self.finished = true;\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                Some(tmp)\n+            }\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.mut_split_at(idx);\n+                self.v = head;\n+                Some(tail.mut_slice_from(1))\n+            }\n+        }\n+    }\n+}\n+\n+/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n+/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n+/// the remainder.\n+pub struct MutChunks<'a, T> {\n+    v: &'a mut [T],\n+    chunk_size: uint\n+}\n+\n+impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let sz = cmp::min(self.v.len(), self.chunk_size);\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let (head, tail) = tmp.mut_split_at(sz);\n+            self.v = tail;\n+            Some(head)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.v.len() == 0 {\n+            (0, Some(0))\n+        } else {\n+            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n+            let n = if rem > 0 { n + 1 } else { n };\n+            (n, Some(n))\n+        }\n+    }\n+}\n+\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.chunk_size;\n+            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n+            let tmp = mem::replace(&mut self.v, &mut []);\n+            let tmp_len = tmp.len();\n+            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n+            self.v = head;\n+            Some(tail)\n+        }\n+    }\n+}\n+\n+impl<'a, T> Default for &'a [T] {\n+    fn default() -> &'a [T] { &[] }\n+}\n+\n+impl<T> Default for ~[T] {\n+    fn default() -> ~[T] { ~[] }\n+}"}, {"sha": "29315c458108fa20ff8d3c2b71788843d14f986e", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -1398,7 +1398,6 @@ impl<T: Iterator<char>> Parser<T> {\n                     'n' => res.push_char('\\n'),\n                     'r' => res.push_char('\\r'),\n                     't' => res.push_char('\\t'),\n-//<<<<<<< HEAD\n                     'u' => match try!(self.decode_hex_escape()) {\n                         0xDC00 .. 0xDFFF => return self.error(LoneLeadingSurrogateInHexEscape),\n "}, {"sha": "c80177b464444567affd4e58484db84a5930df73", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -1291,6 +1291,39 @@ impl<T: Show> Show for Option<T> {\n     }\n }\n \n+impl<'a, T: Show> Show for &'a [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        if f.flags & (1 << (parse::FlagAlternate as uint)) == 0 {\n+            try!(write!(f.buf, \"[\"));\n+        }\n+        let mut is_first = true;\n+        for x in self.iter() {\n+            if is_first {\n+                is_first = false;\n+            } else {\n+                try!(write!(f.buf, \", \"));\n+            }\n+            try!(write!(f.buf, \"{}\", *x))\n+        }\n+        if f.flags & (1 << (parse::FlagAlternate as uint)) == 0 {\n+            try!(write!(f.buf, \"]\"));\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, T: Show> Show for &'a mut [T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n+impl<T: Show> Show for ~[T] {\n+    fn fmt(&self, f: &mut Formatter) -> Result {\n+        secret_show(&self.as_slice(), f)\n+    }\n+}\n+\n impl Show for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")"}, {"sha": "d4440e4a7dac06fec1dd5870ebb47ff11ba851c6", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -76,7 +76,7 @@ pub use tuple::{Tuple5, Tuple6, Tuple7, Tuple8};\n pub use tuple::{Tuple9, Tuple10, Tuple11, Tuple12};\n pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVector};\n pub use slice::{OwnedVector};\n-pub use slice::{MutableVector, MutableTotalOrdVector};\n+pub use slice::{MutableVector, MutableTotalOrdVector, MutableVectorAllocating};\n pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n pub use strbuf::StrBuf;\n pub use vec::Vec;"}, {"sha": "3f5ac5351136ef0672a4069070f66914484a9b8e", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 80, "deletions": 1615, "changes": 1695, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -97,138 +97,28 @@ There are a number of free functions that create or take vectors, for example:\n \n */\n \n-use cast;\n use cast::transmute;\n-use ops::Drop;\n+use cast;\n use clone::Clone;\n-use container::Container;\n-use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n+use cmp::{TotalOrd, Ordering, Less, Greater};\n use cmp;\n-use default::Default;\n-use fmt;\n+use container::Container;\n use iter::*;\n-use num::{CheckedAdd, Saturating, div_rem};\n-use num::CheckedMul;\n+use mem::size_of;\n+use mem;\n+use ops::Drop;\n use option::{None, Option, Some};\n-use ptr;\n use ptr::RawPtr;\n-use rt::global_heap::{malloc_raw, exchange_free};\n-use result::{Ok, Err};\n-use mem;\n-use mem::size_of;\n-use kinds::marker;\n+use ptr;\n+use rt::global_heap::{exchange_free};\n use unstable::finally::try_finally;\n-use raw::{Repr, Slice};\n-use RawVec = raw::Vec;\n use vec::Vec;\n \n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n-    unsafe {\n-        transmute(Slice { data: s, len: 1 })\n-    }\n-}\n-\n-/**\n- * Converts a pointer to A into a slice of length 1 (without copying).\n- */\n-pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n-    unsafe {\n-        let ptr: *A = transmute(s);\n-        transmute(Slice { data: ptr, len: 1 })\n-    }\n-}\n-\n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function.\n-pub struct Splits<'a, T> {\n-    v: &'a [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for Splits<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().position(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(0, idx));\n-                self.v = self.v.slice(idx + 1, self.v.len());\n-                ret\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(self.v.len() + 1))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Splits<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                Some(self.v)\n-            }\n-            Some(idx) => {\n-                let ret = Some(self.v.slice(idx + 1, self.v.len()));\n-                self.v = self.v.slice(0, idx);\n-                ret\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator over the slices of a vector separated by elements that\n-/// match a predicate function, splitting at most a fixed number of times.\n-pub struct SplitsN<'a, T> {\n-    iter: Splits<'a, T>,\n-    count: uint,\n-    invert: bool\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for SplitsN<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.count == 0 {\n-            if self.iter.finished {\n-                None\n-            } else {\n-                self.iter.finished = true;\n-                Some(self.iter.v)\n-            }\n-        } else {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.iter.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(cmp::min(self.count, self.iter.v.len()) + 1))\n-        }\n-    }\n-}\n+pub use core::slice::{ref_slice, mut_ref_slice, Splits, Windows};\n+pub use core::slice::{Chunks, Vector, ImmutableVector, ImmutableEqVector};\n+pub use core::slice::{ImmutableTotalOrdVector, MutableVector, Items, MutItems};\n+pub use core::slice::{RevItems, RevMutItems, MutSplits, MutChunks};\n+pub use core::slice::{bytes, MutableCloneableVector};\n \n // Functional utilities\n \n@@ -410,249 +300,6 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n     }\n }\n \n-/// An iterator over the (overlapping) slices of length `size` within\n-/// a vector.\n-#[deriving(Clone)]\n-pub struct Windows<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for Windows<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.size > self.v.len() {\n-            None\n-        } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(1, self.v.len());\n-            ret\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.size > self.v.len() {\n-            (0, Some(0))\n-        } else {\n-            let x = self.v.len() - self.size;\n-            (x.saturating_add(1), x.checked_add(&1u))\n-        }\n-    }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) chunks (`size`\n-/// elements at a time).\n-///\n-/// When the vector len is not evenly divided by the chunk size,\n-/// the last slice of the iteration will be the remainder.\n-#[deriving(Clone)]\n-pub struct Chunks<'a, T> {\n-    v: &'a [T],\n-    size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a [T]> for Chunks<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let chunksz = cmp::min(self.v.len(), self.size);\n-            let (fst, snd) = (self.v.slice_to(chunksz),\n-                              self.v.slice_from(chunksz));\n-            self.v = snd;\n-            Some(fst)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.size);\n-            let n = if rem > 0 { n+1 } else { n };\n-            (n, Some(n))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a [T]> for Chunks<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.size;\n-            let chunksz = if remainder != 0 { remainder } else { self.size };\n-            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n-                              self.v.slice_from(self.v.len() - chunksz));\n-            self.v = fst;\n-            Some(snd)\n-        }\n-    }\n-}\n-\n-impl<'a, T> RandomAccessIterator<&'a [T]> for Chunks<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> uint {\n-        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n-        if index < self.indexable() {\n-            let lo = index * self.size;\n-            let mut hi = lo + self.size;\n-            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n-\n-            Some(self.v.slice(lo, hi))\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-// Equality\n-\n-#[cfg(not(test))]\n-#[allow(missing_doc)]\n-pub mod traits {\n-    use super::*;\n-\n-    use container::Container;\n-    use clone::Clone;\n-    use cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Equiv};\n-    use iter::{order, Iterator};\n-    use ops::Add;\n-    use vec::Vec;\n-\n-    impl<'a,T:Eq> Eq for &'a [T] {\n-        fn eq(&self, other: & &'a [T]) -> bool {\n-            self.len() == other.len() &&\n-                order::eq(self.iter(), other.iter())\n-        }\n-        fn ne(&self, other: & &'a [T]) -> bool {\n-            self.len() != other.len() ||\n-                order::ne(self.iter(), other.iter())\n-        }\n-    }\n-\n-    impl<T:Eq> Eq for ~[T] {\n-        #[inline]\n-        fn eq(&self, other: &~[T]) -> bool { self.as_slice() == *other }\n-        #[inline]\n-        fn ne(&self, other: &~[T]) -> bool { !self.eq(other) }\n-    }\n-\n-    impl<'a,T:TotalEq> TotalEq for &'a [T] {}\n-\n-    impl<T:TotalEq> TotalEq for ~[T] {}\n-\n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n-    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n-        #[inline]\n-        fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n-    }\n-\n-    impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n-        fn cmp(&self, other: & &'a [T]) -> Ordering {\n-            order::cmp(self.iter(), other.iter())\n-        }\n-    }\n-\n-    impl<T: TotalOrd> TotalOrd for ~[T] {\n-        #[inline]\n-        fn cmp(&self, other: &~[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n-    }\n-\n-    impl<'a, T: Ord> Ord for &'a [T] {\n-        fn lt(&self, other: & &'a [T]) -> bool {\n-            order::lt(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn le(&self, other: & &'a [T]) -> bool {\n-            order::le(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn ge(&self, other: & &'a [T]) -> bool {\n-            order::ge(self.iter(), other.iter())\n-        }\n-        #[inline]\n-        fn gt(&self, other: & &'a [T]) -> bool {\n-            order::gt(self.iter(), other.iter())\n-        }\n-    }\n-\n-    impl<T: Ord> Ord for ~[T] {\n-        #[inline]\n-        fn lt(&self, other: &~[T]) -> bool { self.as_slice() < other.as_slice() }\n-        #[inline]\n-        fn le(&self, other: &~[T]) -> bool { self.as_slice() <= other.as_slice() }\n-        #[inline]\n-        fn ge(&self, other: &~[T]) -> bool { self.as_slice() >= other.as_slice() }\n-        #[inline]\n-        fn gt(&self, other: &~[T]) -> bool { self.as_slice() > other.as_slice() }\n-    }\n-\n-    impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> ~[T] {\n-            let mut res = Vec::with_capacity(self.len() + rhs.as_slice().len());\n-            res.push_all(*self);\n-            res.push_all(rhs.as_slice());\n-            res.move_iter().collect()\n-        }\n-    }\n-\n-    impl<T:Clone, V: Vector<T>> Add<V, ~[T]> for ~[T] {\n-        #[inline]\n-        fn add(&self, rhs: &V) -> ~[T] {\n-            self.as_slice() + rhs.as_slice()\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-pub mod traits {}\n-\n-/// Any vector that can be represented as a slice.\n-pub trait Vector<T> {\n-    /// Work with `self` as a slice.\n-    fn as_slice<'a>(&'a self) -> &'a [T];\n-}\n-\n-impl<'a,T> Vector<T> for &'a [T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n-}\n-\n-impl<T> Vector<T> for ~[T] {\n-    #[inline(always)]\n-    fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n-}\n-\n-impl<'a, T> Container for &'a [T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.repr().len\n-    }\n-}\n-\n-impl<T> Container for ~[T] {\n-    /// Returns the length of a vector\n-    #[inline]\n-    fn len(&self) -> uint {\n-        self.as_slice().len()\n-    }\n-}\n-\n /// Extension methods for vector slices with cloneable elements\n pub trait CloneableVector<T> {\n     /// Copy `self` into a new owned vector\n@@ -703,496 +350,85 @@ impl<T: Clone> CloneableVector<T> for ~[T] {\n     fn into_owned(self) -> ~[T] { self }\n }\n \n-/// Extension methods for vectors\n-pub trait ImmutableVector<'a, T> {\n-    /**\n-     * Returns a slice of self between `start` and `end`.\n-     *\n-     * Fails when `start` or `end` point outside the bounds of self,\n-     * or when `start` > `end`.\n-     */\n-    fn slice(&self, start: uint, end: uint) -> &'a [T];\n+/// Extension methods for vectors containing `Clone` elements.\n+pub trait ImmutableCloneableVector<T> {\n+    /// Partitions the vector into two vectors `(A,B)`, where all\n+    /// elements of `A` satisfy `f` and all elements of `B` do not.\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n \n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n-    fn slice_from(&self, start: uint) -> &'a [T];\n+    /// Create an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    fn permutations(self) -> Permutations<T>;\n+}\n \n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n-    fn slice_to(&self, end: uint) -> &'a [T];\n-    /// Returns an iterator over the vector\n-    fn iter(self) -> Items<'a, T>;\n-    /// Returns a reversed iterator over a vector\n-    #[deprecated = \"replaced by .iter().rev()\"]\n-    fn rev_iter(self) -> Rev<Items<'a, T>>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`.  The matched element\n-    /// is not contained in the subslices.\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`, limited to splitting\n-    /// at most `n` times.  The matched element is not contained in\n-    /// the subslices.\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred`. This starts at the\n-    /// end of the vector and works backwards.  The matched element is\n-    /// not contained in the subslices.\n-    #[deprecated = \"replaced by .split(pred).rev()\"]\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>>;\n-    /// Returns an iterator over the subslices of the vector which are\n-    /// separated by elements that match `pred` limited to splitting\n-    /// at most `n` times. This starts at the end of the vector and\n-    /// works backwards.  The matched element is not contained in the\n-    /// subslices.\n-    fn rsplitn(self,  n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T>;\n+impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n+    #[inline]\n+    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n+        let mut lefts  = Vec::new();\n+        let mut rights = Vec::new();\n \n-    /**\n-     * Returns an iterator over all contiguous windows of length\n-     * `size`. The windows overlap. If the vector is shorter than\n-     * `size`, the iterator returns no values.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n-     * `[3,4]`):\n-     *\n-     * ```rust\n-     * let v = &[1,2,3,4];\n-     * for win in v.windows(2) {\n-     *     println!(\"{:?}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn windows(self, size: uint) -> Windows<'a, T>;\n-    /**\n-     *\n-     * Returns an iterator over `size` elements of the vector at a\n-     * time. The chunks do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     *\n-     * # Example\n-     *\n-     * Print the vector two elements at a time (i.e. `[1,2]`,\n-     * `[3,4]`, `[5]`):\n-     *\n-     * ```rust\n-     * let v = &[1,2,3,4,5];\n-     * for win in v.chunks(2) {\n-     *     println!(\"{:?}\", win);\n-     * }\n-     * ```\n-     *\n-     */\n-    fn chunks(self, size: uint) -> Chunks<'a, T>;\n-\n-    /// Returns the element of a vector at the given index, or `None` if the\n-    /// index is out of bounds\n-    fn get(&self, index: uint) -> Option<&'a T>;\n-    /// Returns the first element of a vector, or `None` if it is empty\n-    fn head(&self) -> Option<&'a T>;\n-    /// Returns all but the first element of a vector\n-    fn tail(&self) -> &'a [T];\n-    /// Returns all but the first `n' elements of a vector\n-    fn tailn(&self, n: uint) -> &'a [T];\n-    /// Returns all but the last element of a vector\n-    fn init(&self) -> &'a [T];\n-    /// Returns all but the last `n' elements of a vector\n-    fn initn(&self, n: uint) -> &'a [T];\n-    /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last(&self) -> Option<&'a T>;\n-\n-    /// Returns a pointer to the element at the given index, without doing\n-    /// bounds checking.\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T;\n+        for elt in self.iter() {\n+            if f(elt) {\n+                lefts.push((*elt).clone());\n+            } else {\n+                rights.push((*elt).clone());\n+            }\n+        }\n \n-    /**\n-     * Returns an unsafe pointer to the vector's buffer\n-     *\n-     * The caller must ensure that the vector outlives the pointer this\n-     * function returns, or else it will end up pointing to garbage.\n-     *\n-     * Modifying the vector may cause its buffer to be reallocated, which\n-     * would also make any pointers to it invalid.\n-     */\n-    fn as_ptr(&self) -> *T;\n+        (lefts.move_iter().collect(), rights.move_iter().collect())\n+    }\n \n-    /**\n-     * Binary search a sorted vector with a comparator function.\n-     *\n-     * The comparator function should implement an order consistent\n-     * with the sort order of the underlying vector, returning an\n-     * order code that indicates whether its argument is `Less`,\n-     * `Equal` or `Greater` the desired target.\n-     *\n-     * Returns the index where the comparator returned `Equal`, or `None` if\n-     * not found.\n-     */\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint>;\n+    fn permutations(self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_owned(),\n+        }\n+    }\n \n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None }\n-     *     let head = &self[0];\n-     *     *self = self.slice_from(1);\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if vector is empty\n-     */\n-    fn shift_ref(&mut self) -> Option<&'a T>;\n+}\n+\n+/// Extension methods for owned vectors.\n+pub trait OwnedVector<T> {\n+    /// Creates a consuming iterator, that is, one that moves each\n+    /// value out of the vector (from start to end). The vector cannot\n+    /// be used after calling this.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// let v = ~[\"a\".to_owned(), \"b\".to_owned()];\n+    /// for s in v.move_iter() {\n+    ///   // s has type ~str, not &~str\n+    ///   println!(\"{}\", s);\n+    /// }\n+    /// ```\n+    fn move_iter(self) -> MoveItems<T>;\n+    /// Creates a consuming iterator that moves out of the vector in\n+    /// reverse order.\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>>;\n \n     /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &self[self.len() - 1];\n-     *     *self = self.slice_to(self.len() - 1);\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n+     * Partitions the vector into two vectors `(A,B)`, where all\n+     * elements of `A` satisfy `f` and all elements of `B` do not.\n      */\n-    fn pop_ref(&mut self) -> Option<&'a T>;\n+    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n }\n \n-impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n+impl<T> OwnedVector<T> for ~[T] {\n     #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n+    fn move_iter(self) -> MoveItems<T> {\n         unsafe {\n-            transmute(Slice {\n-                    data: self.as_ptr().offset(start as int),\n-                    len: (end - start)\n-                })\n+            let iter = transmute(self.iter());\n+            let ptr = transmute(self);\n+            MoveItems { allocation: ptr, iter: iter }\n         }\n     }\n \n     #[inline]\n-    fn slice_from(&self, start: uint) -> &'a [T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &'a [T] {\n-        self.slice(0, end)\n-    }\n-\n-    #[inline]\n-    fn iter(self) -> Items<'a, T> {\n-        unsafe {\n-            let p = self.as_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                Items{ptr: p,\n-                      end: (p as uint + self.len()) as *T,\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            } else {\n-                Items{ptr: p,\n-                      end: p.offset(self.len() as int),\n-                      marker: marker::ContravariantLifetime::<'a>}\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .iter().rev()\"]\n-    fn rev_iter(self) -> Rev<Items<'a, T>> {\n-        self.iter().rev()\n-    }\n-\n-    #[inline]\n-    fn split(self, pred: |&T|: 'a -> bool) -> Splits<'a, T> {\n-        Splits {\n-            v: self,\n-            pred: pred,\n-            finished: false\n-        }\n-    }\n-\n-    #[inline]\n-    fn splitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: false\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .split(pred).rev()\"]\n-    fn rsplit(self, pred: |&T|: 'a -> bool) -> Rev<Splits<'a, T>> {\n-        self.split(pred).rev()\n-    }\n-\n-    #[inline]\n-    fn rsplitn(self, n: uint, pred: |&T|: 'a -> bool) -> SplitsN<'a, T> {\n-        SplitsN {\n-            iter: self.split(pred),\n-            count: n,\n-            invert: true\n-        }\n-    }\n-\n-    #[inline]\n-    fn windows(self, size: uint) -> Windows<'a, T> {\n-        assert!(size != 0);\n-        Windows { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn chunks(self, size: uint) -> Chunks<'a, T> {\n-        assert!(size != 0);\n-        Chunks { v: self, size: size }\n-    }\n-\n-    #[inline]\n-    fn get(&self, index: uint) -> Option<&'a T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n-    }\n-\n-    #[inline]\n-    fn head(&self) -> Option<&'a T> {\n-        if self.len() == 0 { None } else { Some(&self[0]) }\n-    }\n-\n-    #[inline]\n-    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n-\n-    #[inline]\n-    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n-\n-    #[inline]\n-    fn init(&self) -> &'a [T] {\n-        self.slice(0, self.len() - 1)\n-    }\n-\n-    #[inline]\n-    fn initn(&self, n: uint) -> &'a [T] {\n-        self.slice(0, self.len() - n)\n-    }\n-\n-    #[inline]\n-    fn last(&self) -> Option<&'a T> {\n-            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n-    }\n-\n-    #[inline]\n-    unsafe fn unsafe_ref(self, index: uint) -> &'a T {\n-        transmute(self.repr().data.offset(index as int))\n-    }\n-\n-    #[inline]\n-    fn as_ptr(&self) -> *T {\n-        self.repr().data\n-    }\n-\n-\n-    fn bsearch(&self, f: |&T| -> Ordering) -> Option<uint> {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n-\n-        while lim != 0 {\n-            let ix = base + (lim >> 1);\n-            match f(&self[ix]) {\n-                Equal => return Some(ix),\n-                Less => {\n-                    base = ix + 1;\n-                    lim -= 1;\n-                }\n-                Greater => ()\n-            }\n-            lim >>= 1;\n-        }\n-        return None;\n-    }\n-\n-    fn shift_ref(&mut self) -> Option<&'a T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            Some(&*raw::shift_ptr(s))\n-        }\n-    }\n-\n-    fn pop_ref(&mut self) -> Option<&'a T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            Some(&*raw::pop_ptr(s))\n-        }\n-    }\n-}\n-\n-/// Extension methods for vectors contain `Eq` elements.\n-pub trait ImmutableEqVector<T:Eq> {\n-    /// Find the first index containing a matching value\n-    fn position_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Find the last index containing a matching value\n-    fn rposition_elem(&self, t: &T) -> Option<uint>;\n-\n-    /// Return true if a vector contains an element with the given value\n-    fn contains(&self, x: &T) -> bool;\n-\n-    /// Returns true if `needle` is a prefix of the vector.\n-    fn starts_with(&self, needle: &[T]) -> bool;\n-\n-    /// Returns true if `needle` is a suffix of the vector.\n-    fn ends_with(&self, needle: &[T]) -> bool;\n-}\n-\n-impl<'a,T:Eq> ImmutableEqVector<T> for &'a [T] {\n-    #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> {\n-        self.iter().position(|y| *x == *y)\n-    }\n-\n-    #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> {\n-        self.iter().rposition(|x| *x == *t)\n-    }\n-\n-    #[inline]\n-    fn contains(&self, x: &T) -> bool {\n-        self.iter().any(|elt| *x == *elt)\n-    }\n-\n-    #[inline]\n-    fn starts_with(&self, needle: &[T]) -> bool {\n-        let n = needle.len();\n-        self.len() >= n && needle == self.slice_to(n)\n-    }\n-\n-    #[inline]\n-    fn ends_with(&self, needle: &[T]) -> bool {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self.slice_from(m - n)\n-    }\n-}\n-\n-/// Extension methods for vectors containing `TotalOrd` elements.\n-pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n-    /**\n-     * Binary search a sorted vector for a given element.\n-     *\n-     * Returns the index of the element or None if not found.\n-     */\n-    fn bsearch_elem(&self, x: &T) -> Option<uint>;\n-}\n-\n-impl<'a, T: TotalOrd> ImmutableTotalOrdVector<T> for &'a [T] {\n-    fn bsearch_elem(&self, x: &T) -> Option<uint> {\n-        self.bsearch(|p| p.cmp(x))\n-    }\n-}\n-\n-/// Extension methods for vectors containing `Clone` elements.\n-pub trait ImmutableCloneableVector<T> {\n-    /// Partitions the vector into two vectors `(A,B)`, where all\n-    /// elements of `A` satisfy `f` and all elements of `B` do not.\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]);\n-\n-    /// Create an iterator that yields every possible permutation of the\n-    /// vector in succession.\n-    fn permutations(self) -> Permutations<T>;\n-}\n-\n-impl<'a,T:Clone> ImmutableCloneableVector<T> for &'a [T] {\n-    #[inline]\n-    fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n-        let mut lefts  = Vec::new();\n-        let mut rights = Vec::new();\n-\n-        for elt in self.iter() {\n-            if f(elt) {\n-                lefts.push((*elt).clone());\n-            } else {\n-                rights.push((*elt).clone());\n-            }\n-        }\n-\n-        (lefts.move_iter().collect(), rights.move_iter().collect())\n-    }\n-\n-    fn permutations(self) -> Permutations<T> {\n-        Permutations{\n-            swaps: ElementSwaps::new(self.len()),\n-            v: self.to_owned(),\n-        }\n-    }\n-\n-}\n-\n-/// Extension methods for owned vectors.\n-pub trait OwnedVector<T> {\n-    /// Creates a consuming iterator, that is, one that moves each\n-    /// value out of the vector (from start to end). The vector cannot\n-    /// be used after calling this.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// let v = ~[\"a\".to_owned(), \"b\".to_owned()];\n-    /// for s in v.move_iter() {\n-    ///   // s has type ~str, not &~str\n-    ///   println!(\"{}\", s);\n-    /// }\n-    /// ```\n-    fn move_iter(self) -> MoveItems<T>;\n-    /// Creates a consuming iterator that moves out of the vector in\n-    /// reverse order.\n-    #[deprecated = \"replaced by .move_iter().rev()\"]\n-    fn move_rev_iter(self) -> Rev<MoveItems<T>>;\n-\n-    /**\n-     * Partitions the vector into two vectors `(A,B)`, where all\n-     * elements of `A` satisfy `f` and all elements of `B` do not.\n-     */\n-    fn partition(self, f: |&T| -> bool) -> (~[T], ~[T]);\n-}\n-\n-impl<T> OwnedVector<T> for ~[T] {\n-    #[inline]\n-    fn move_iter(self) -> MoveItems<T> {\n-        unsafe {\n-            let iter = transmute(self.iter());\n-            let ptr = transmute(self);\n-            MoveItems { allocation: ptr, iter: iter }\n-        }\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .move_iter().rev()\"]\n-    fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n-        self.move_iter().rev()\n+    #[deprecated = \"replaced by .move_iter().rev()\"]\n+    fn move_rev_iter(self) -> Rev<MoveItems<T>> {\n+        self.move_iter().rev()\n     }\n \n     #[inline]\n@@ -1417,155 +653,7 @@ fn merge_sort<T>(v: &mut [T], compare: |&T, &T| -> Ordering) {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n-pub trait MutableVector<'a, T> {\n-    /// Work with `self` as a mut slice.\n-    /// Primarily intended for getting a &mut [T] from a [T, ..N].\n-    fn as_mut_slice(self) -> &'a mut [T];\n-\n-    /// Return a slice that points into another slice.\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n-\n-    /**\n-     * Returns a slice of self from `start` to the end of the vec.\n-     *\n-     * Fails when `start` points outside the bounds of self.\n-     */\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n-\n-    /**\n-     * Returns a slice of self from the start of the vec to `end`.\n-     *\n-     * Fails when `end` points outside the bounds of self.\n-     */\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n-\n-    /// Returns an iterator that allows modifying each value\n-    fn mut_iter(self) -> MutItems<'a, T>;\n-\n-    /// Returns a mutable pointer to the last item in the vector.\n-    fn mut_last(self) -> Option<&'a mut T>;\n-\n-    /// Returns a reversed iterator that allows modifying each value\n-    #[deprecated = \"replaced by .mut_iter().rev()\"]\n-    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>>;\n-\n-    /// Returns an iterator over the mutable subslices of the vector\n-    /// which are separated by elements that match `pred`.  The\n-    /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T>;\n-\n-    /**\n-     * Returns an iterator over `size` elements of the vector at a time.\n-     * The chunks are mutable and do not overlap. If `size` does not divide the\n-     * length of the vector, then the last chunk will not have length\n-     * `size`.\n-     *\n-     * # Failure\n-     *\n-     * Fails if `size` is 0.\n-     */\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T>;\n-\n-    /**\n-     * Returns a mutable reference to the first element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let head = &mut self[0];\n-     *     *self = self.mut_slice_from(1);\n-     *     Some(head)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty\n-     */\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /**\n-     * Returns a mutable reference to the last element in this slice\n-     * and adjusts the slice in place so that it no longer contains\n-     * that element. O(1).\n-     *\n-     * Equivalent to:\n-     *\n-     * ```ignore\n-     *     if self.len() == 0 { return None; }\n-     *     let tail = &mut self[self.len() - 1];\n-     *     *self = self.mut_slice_to(self.len() - 1);\n-     *     Some(tail)\n-     * ```\n-     *\n-     * Returns `None` if slice is empty.\n-     */\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T>;\n-\n-    /// Swaps two elements in a vector.\n-    ///\n-    /// Fails if `a` or `b` are out of bounds.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * a - The index of the first element\n-    /// * b - The index of the second element\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"a\", \"b\", \"c\", \"d\"];\n-    /// v.swap(1, 3);\n-    /// assert!(v == [\"a\", \"d\", \"c\", \"b\"]);\n-    /// ```\n-    fn swap(self, a: uint, b: uint);\n-\n-\n-    /// Divides one `&mut` into two at an index.\n-    ///\n-    /// The first will contain all indices from `[0, mid)` (excluding\n-    /// the index `mid` itself) and the second will contain all\n-    /// indices from `[mid, len)` (excluding the index `len` itself).\n-    ///\n-    /// Fails if `mid > len`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1, 2, 3, 4, 5, 6];\n-    ///\n-    /// // scoped to restrict the lifetime of the borrows\n-    /// {\n-    ///    let (left, right) = v.mut_split_at(0);\n-    ///    assert!(left == &mut []);\n-    ///    assert!(right == &mut [1, 2, 3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(2);\n-    ///     assert!(left == &mut [1, 2]);\n-    ///     assert!(right == &mut [3, 4, 5, 6]);\n-    /// }\n-    ///\n-    /// {\n-    ///     let (left, right) = v.mut_split_at(6);\n-    ///     assert!(left == &mut [1, 2, 3, 4, 5, 6]);\n-    ///     assert!(right == &mut []);\n-    /// }\n-    /// ```\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]);\n-\n-    /// Reverse the order of elements in a vector, in place.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [1, 2, 3];\n-    /// v.reverse();\n-    /// assert!(v == [3, 2, 1]);\n-    /// ```\n-    fn reverse(self);\n-\n+pub trait MutableVectorAllocating<'a, T> {\n     /// Sort the vector, in place, using `compare` to compare\n     /// elements.\n     ///\n@@ -1599,181 +687,9 @@ pub trait MutableVector<'a, T> {\n      * * end - The index into `str` to stop copying from\n      */\n     fn move_from(self, src: ~[T], start: uint, end: uint) -> uint;\n-\n-    /// Returns an unsafe mutable pointer to the element in index\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T;\n-\n-    /// Return an unsafe mutable pointer to the vector's buffer.\n-    ///\n-    /// The caller must ensure that the vector outlives the pointer this\n-    /// function returns, or else it will end up pointing to garbage.\n-    ///\n-    /// Modifying the vector may cause its buffer to be reallocated, which\n-    /// would also make any pointers to it invalid.\n-    #[inline]\n-    fn as_mut_ptr(self) -> *mut T;\n-\n-    /// Unsafely sets the element in index to the value.\n-    ///\n-    /// This performs no bounds checks, and it is undefined behaviour\n-    /// if `index` is larger than the length of `self`. However, it\n-    /// does run the destructor at `index`. It is equivalent to\n-    /// `self[index] = val`.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = ~[\"foo\".to_owned(), \"bar\".to_owned(), \"baz\".to_owned()];\n-    ///\n-    /// unsafe {\n-    ///     // `\"baz\".to_owned()` is deallocated.\n-    ///     v.unsafe_set(2, \"qux\".to_owned());\n-    ///\n-    ///     // Out of bounds: could cause a crash, or overwriting\n-    ///     // other data, or something else.\n-    ///     // v.unsafe_set(10, \"oops\".to_owned());\n-    /// }\n-    /// ```\n-    unsafe fn unsafe_set(self, index: uint, val: T);\n-\n-    /// Unchecked vector index assignment.  Does not drop the\n-    /// old value and hence is only suitable when the vector\n-    /// is newly allocated.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let mut v = [\"foo\".to_owned(), \"bar\".to_owned()];\n-    ///\n-    /// // memory leak! `\"bar\".to_owned()` is not deallocated.\n-    /// unsafe { v.init_elem(1, \"baz\".to_owned()); }\n-    /// ```\n-    unsafe fn init_elem(self, i: uint, val: T);\n-\n-    /// Copies raw bytes from `src` to `self`.\n-    ///\n-    /// This does not run destructors on the overwritten elements, and\n-    /// ignores move semantics. `self` and `src` must not\n-    /// overlap. Fails if `self` is shorter than `src`.\n-    unsafe fn copy_memory(self, src: &[T]);\n }\n \n-impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n-    #[inline]\n-    fn as_mut_slice(self) -> &'a mut [T] { self }\n-\n-    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(Slice {\n-                    data: self.as_mut_ptr().offset(start as int) as *T,\n-                    len: (end - start)\n-                })\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n-        let len = self.len();\n-        self.mut_slice(start, len)\n-    }\n-\n-    #[inline]\n-    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n-        self.mut_slice(0, end)\n-    }\n-\n-    #[inline]\n-    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n-        unsafe {\n-            let len = self.len();\n-            let self2: &'a mut [T] = cast::transmute_copy(&self);\n-            (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_iter(self) -> MutItems<'a, T> {\n-        unsafe {\n-            let p = self.as_mut_ptr();\n-            if mem::size_of::<T>() == 0 {\n-                MutItems{ptr: p,\n-                         end: (p as uint + self.len()) as *mut T,\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n-            } else {\n-                MutItems{ptr: p,\n-                         end: p.offset(self.len() as int),\n-                         marker: marker::ContravariantLifetime::<'a>,\n-                         marker2: marker::NoCopy}\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn mut_last(self) -> Option<&'a mut T> {\n-        let len = self.len();\n-        if len == 0 { return None; }\n-        Some(&mut self[len - 1])\n-    }\n-\n-    #[inline]\n-    #[deprecated = \"replaced by .mut_iter().rev()\"]\n-    fn mut_rev_iter(self) -> Rev<MutItems<'a, T>> {\n-        self.mut_iter().rev()\n-    }\n-\n-    #[inline]\n-    fn mut_split(self, pred: |&T|: 'a -> bool) -> MutSplits<'a, T> {\n-        MutSplits { v: self, pred: pred, finished: false }\n-    }\n-\n-    #[inline]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunks<'a, T> {\n-        assert!(chunk_size > 0);\n-        MutChunks { v: self, chunk_size: chunk_size }\n-    }\n-\n-    fn mut_shift_ref(&mut self) -> Option<&'a mut T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            // FIXME #13933: this `&` -> `&mut` cast is a little\n-            // dubious\n-            Some(&mut *(raw::shift_ptr(s) as *mut _))\n-        }\n-    }\n-\n-    fn mut_pop_ref(&mut self) -> Option<&'a mut T> {\n-        if self.len() == 0 { return None; }\n-        unsafe {\n-            let s: &mut Slice<T> = transmute(self);\n-            // FIXME #13933: this `&` -> `&mut` cast is a little\n-            // dubious\n-            Some(&mut *(raw::pop_ptr(s) as *mut _))\n-        }\n-    }\n-\n-    fn swap(self, a: uint, b: uint) {\n-        unsafe {\n-            // Can't take two mutable loans from one vector, so instead just cast\n-            // them to their raw pointers to do the swap\n-            let pa: *mut T = &mut self[a];\n-            let pb: *mut T = &mut self[b];\n-            ptr::swap(pa, pb);\n-        }\n-    }\n-\n-    fn reverse(self) {\n-        let mut i: uint = 0;\n-        let ln = self.len();\n-        while i < ln / 2 {\n-            self.swap(i, ln - i - 1);\n-            i += 1;\n-        }\n-    }\n-\n+impl<'a,T> MutableVectorAllocating<'a, T> for &'a mut [T] {\n     #[inline]\n     fn sort_by(self, compare: |&T, &T| -> Ordering) {\n         merge_sort(self, compare)\n@@ -1786,67 +702,6 @@ impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n         }\n         cmp::min(self.len(), end-start)\n     }\n-\n-    #[inline]\n-    unsafe fn unsafe_mut_ref(self, index: uint) -> &'a mut T {\n-        transmute((self.repr().data as *mut T).offset(index as int))\n-    }\n-\n-    #[inline]\n-    fn as_mut_ptr(self) -> *mut T {\n-        self.repr().data as *mut T\n-    }\n-\n-    #[inline]\n-    unsafe fn unsafe_set(self, index: uint, val: T) {\n-        *self.unsafe_mut_ref(index) = val;\n-    }\n-\n-    #[inline]\n-    unsafe fn init_elem(self, i: uint, val: T) {\n-        mem::move_val_init(&mut (*self.as_mut_ptr().offset(i as int)), val);\n-    }\n-\n-    #[inline]\n-    unsafe fn copy_memory(self, src: &[T]) {\n-        let len_src = src.len();\n-        assert!(self.len() >= len_src);\n-        ptr::copy_nonoverlapping_memory(self.as_mut_ptr(), src.as_ptr(), len_src)\n-    }\n-}\n-\n-/// Trait for &[T] where T is Cloneable\n-pub trait MutableCloneableVector<T> {\n-    /// Copies as many elements from `src` as it can into `self` (the\n-    /// shorter of `self.len()` and `src.len()`). Returns the number\n-    /// of elements copied.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// use std::slice::MutableCloneableVector;\n-    ///\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2];\n-    ///\n-    /// assert!(dst.copy_from(src) == 2);\n-    /// assert!(dst == [1, 2, 0]);\n-    ///\n-    /// let src2 = [3, 4, 5, 6];\n-    /// assert!(dst.copy_from(src2) == 3);\n-    /// assert!(dst == [3, 4, 5]);\n-    /// ```\n-    fn copy_from(self, &[T]) -> uint;\n-}\n-\n-impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n-    #[inline]\n-    fn copy_from(self, src: &[T]) -> uint {\n-        for (a, b) in self.mut_iter().zip(src.iter()) {\n-            a.clone_from(b);\n-        }\n-        cmp::min(self.len(), src.len())\n-    }\n }\n \n /// Methods for mutable vectors with orderable elements, such as\n@@ -1866,6 +721,7 @@ pub trait MutableTotalOrdVector<T> {\n     /// ```\n     fn sort(self);\n }\n+\n impl<'a, T: TotalOrd> MutableTotalOrdVector<T> for &'a mut [T] {\n     #[inline]\n     fn sort(self) {\n@@ -1888,43 +744,13 @@ pub unsafe fn from_buf<T>(ptr: *T, elts: uint) -> ~[T] {\n \n /// Unsafe operations\n pub mod raw {\n-    use cast::transmute;\n     use iter::Iterator;\n-    use ptr::RawPtr;\n     use ptr;\n-    use raw::Slice;\n     use slice::{MutableVector, OwnedVector};\n     use vec::Vec;\n \n-    /**\n-     * Form a slice from a pointer and length (as a number of units,\n-     * not bytes).\n-     */\n-    #[inline]\n-    pub unsafe fn buf_as_slice<T,U>(p: *T, len: uint, f: |v: &[T]| -> U)\n-                               -> U {\n-        f(transmute(Slice {\n-            data: p,\n-            len: len\n-        }))\n-    }\n-\n-    /**\n-     * Form a slice from a pointer and length (as a number of units,\n-     * not bytes).\n-     */\n-    #[inline]\n-    pub unsafe fn mut_buf_as_slice<T,\n-                                   U>(\n-                                   p: *mut T,\n-                                   len: uint,\n-                                   f: |v: &mut [T]| -> U)\n-                                   -> U {\n-        f(transmute(Slice {\n-            data: p as *T,\n-            len: len\n-        }))\n-    }\n+    pub use core::slice::raw::{buf_as_slice, mut_buf_as_slice};\n+    pub use core::slice::raw::{shift_ptr, pop_ptr};\n \n     /**\n     * Constructs a vector from an unsafe pointer to a buffer\n@@ -1942,332 +768,6 @@ pub mod raw {\n         ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n         dst.move_iter().collect()\n     }\n-\n-    /**\n-     * Returns a pointer to first element in slice and adjusts\n-     * slice so it no longer contains that element. Fails if\n-     * slice is empty. O(1).\n-     */\n-    pub unsafe fn shift_ptr<T>(slice: &mut Slice<T>) -> *T {\n-        if slice.len == 0 { fail!(\"shift on empty slice\"); }\n-        let head: *T = slice.data;\n-        slice.data = slice.data.offset(1);\n-        slice.len -= 1;\n-        head\n-    }\n-\n-    /**\n-     * Returns a pointer to last element in slice and adjusts\n-     * slice so it no longer contains that element. Fails if\n-     * slice is empty. O(1).\n-     */\n-    pub unsafe fn pop_ptr<T>(slice: &mut Slice<T>) -> *T {\n-        if slice.len == 0 { fail!(\"pop on empty slice\"); }\n-        let tail: *T = slice.data.offset((slice.len - 1) as int);\n-        slice.len -= 1;\n-        tail\n-    }\n-}\n-\n-/// Operations on `[u8]`.\n-pub mod bytes {\n-    use container::Container;\n-    use slice::MutableVector;\n-    use ptr;\n-\n-    /// A trait for operations on mutable `[u8]`s.\n-    pub trait MutableByteVector {\n-        /// Sets all bytes of the receiver to the given value.\n-        fn set_memory(self, value: u8);\n-    }\n-\n-    impl<'a> MutableByteVector for &'a mut [u8] {\n-        #[inline]\n-        fn set_memory(self, value: u8) {\n-            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n-        }\n-    }\n-\n-    /// Copies data from `src` to `dst`\n-    ///\n-    /// `src` and `dst` must not overlap. Fails if the length of `dst`\n-    /// is less than the length of `src`.\n-    #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &[u8]) {\n-        // Bound checks are done at .copy_memory.\n-        unsafe { dst.copy_memory(src) }\n-    }\n-}\n-\n-impl<A: Clone> Clone for ~[A] {\n-    #[inline]\n-    fn clone(&self) -> ~[A] {\n-        // Use the fast to_owned on &[A] for cloning\n-        self.as_slice().to_owned()\n-    }\n-}\n-\n-impl<'a, T: fmt::Show> fmt::Show for &'a [T] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if f.flags & (1 << (fmt::parse::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"[\"));\n-        }\n-        let mut is_first = true;\n-        for x in self.iter() {\n-            if is_first {\n-                is_first = false;\n-            } else {\n-                try!(write!(f.buf, \", \"));\n-            }\n-            try!(write!(f.buf, \"{}\", *x))\n-        }\n-        if f.flags & (1 << (fmt::parse::FlagAlternate as uint)) == 0 {\n-            try!(write!(f.buf, \"]\"));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, T: fmt::Show> fmt::Show for &'a mut [T] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n-    }\n-}\n-\n-impl<T: fmt::Show> fmt::Show for ~[T] {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.as_slice().fmt(f)\n-    }\n-}\n-\n-// This works because every lifetime is a sub-lifetime of 'static\n-impl<'a, A> Default for &'a [A] {\n-    fn default() -> &'a [A] { &'a [] }\n-}\n-\n-impl<A> Default for ~[A] {\n-    fn default() -> ~[A] { box [] }\n-}\n-\n-/// Immutable slice iterator\n-pub struct Items<'a, T> {\n-    ptr: *T,\n-    end: *T,\n-    marker: marker::ContravariantLifetime<'a>\n-}\n-\n-/// Mutable slice iterator\n-pub struct MutItems<'a, T> {\n-    ptr: *mut T,\n-    end: *mut T,\n-    marker: marker::ContravariantLifetime<'a>,\n-    marker2: marker::NoCopy\n-}\n-\n-macro_rules! iterator {\n-    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n-        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.ptr == self.end {\n-                        None\n-                    } else {\n-                        let old = self.ptr;\n-                        self.ptr = if mem::size_of::<T>() == 0 {\n-                            // purposefully don't use 'ptr.offset' because for\n-                            // vectors with 0-size elements this would return the\n-                            // same pointer.\n-                            transmute(self.ptr as uint + 1)\n-                        } else {\n-                            self.ptr.offset(1)\n-                        };\n-\n-                        Some(transmute(old))\n-                    }\n-                }\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n-                let exact = diff / mem::nonzero_size_of::<T>();\n-                (exact, Some(exact))\n-            }\n-        }\n-\n-        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$elem> {\n-                // could be implemented with slices, but this avoids bounds checks\n-                unsafe {\n-                    if self.end == self.ptr {\n-                        None\n-                    } else {\n-                        self.end = if mem::size_of::<T>() == 0 {\n-                            // See above for why 'ptr.offset' isn't used\n-                            transmute(self.end as uint - 1)\n-                        } else {\n-                            self.end.offset(-1)\n-                        };\n-                        Some(transmute(self.end))\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, T> RandomAccessIterator<&'a T> for Items<'a, T> {\n-    #[inline]\n-    fn indexable(&self) -> uint {\n-        let (exact, _) = self.size_hint();\n-        exact\n-    }\n-\n-    #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a T> {\n-        unsafe {\n-            if index < self.indexable() {\n-                transmute(self.ptr.offset(index as int))\n-            } else {\n-                None\n-            }\n-        }\n-    }\n-}\n-\n-iterator!{struct Items -> *T, &'a T}\n-#[deprecated = \"replaced by Rev<Items<'a, T>>\"]\n-pub type RevItems<'a, T> = Rev<Items<'a, T>>;\n-\n-impl<'a, T> ExactSize<&'a T> for Items<'a, T> {}\n-impl<'a, T> ExactSize<&'a mut T> for MutItems<'a, T> {}\n-\n-impl<'a, T> Clone for Items<'a, T> {\n-    fn clone(&self) -> Items<'a, T> { *self }\n-}\n-\n-iterator!{struct MutItems -> *mut T, &'a mut T}\n-#[deprecated = \"replaced by Rev<MutItems<'a, T>>\"]\n-pub type RevMutItems<'a, T> = Rev<MutItems<'a, T>>;\n-\n-/// An iterator over the subslices of the vector which are separated\n-/// by elements that match `pred`.\n-pub struct MutSplits<'a, T> {\n-    v: &'a mut [T],\n-    pred: |t: &T|: 'a -> bool,\n-    finished: bool\n-}\n-\n-impl<'a, T> Iterator<&'a mut [T]> for MutSplits<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n-\n-        let pred = &mut self.pred;\n-        match self.v.iter().position(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let len = tmp.len();\n-                let (head, tail) = tmp.mut_split_at(len);\n-                self.v = tail;\n-                Some(head)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = tail.mut_slice_from(1);\n-                Some(head)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            // if the predicate doesn't match anything, we yield one slice\n-            // if it matches every element, we yield len+1 empty slices.\n-            (1, Some(self.v.len() + 1))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplits<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n-\n-        let pred = &mut self.pred;\n-        match self.v.iter().rposition(|x| (*pred)(x)) {\n-            None => {\n-                self.finished = true;\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                Some(tmp)\n-            }\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.mut_split_at(idx);\n-                self.v = head;\n-                Some(tail.mut_slice_from(1))\n-            }\n-        }\n-    }\n-}\n-\n-/// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n-/// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n-/// the remainder.\n-pub struct MutChunks<'a, T> {\n-    v: &'a mut [T],\n-    chunk_size: uint\n-}\n-\n-impl<'a, T> Iterator<&'a mut [T]> for MutChunks<'a, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let sz = cmp::min(self.v.len(), self.chunk_size);\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let (head, tail) = tmp.mut_split_at(sz);\n-            self.v = tail;\n-            Some(head)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if self.v.len() == 0 {\n-            (0, Some(0))\n-        } else {\n-            let (n, rem) = div_rem(self.v.len(), self.chunk_size);\n-            let n = if rem > 0 { n + 1 } else { n };\n-            (n, Some(n))\n-        }\n-    }\n-}\n-\n-impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunks<'a, T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.v.len() == 0 {\n-            None\n-        } else {\n-            let remainder = self.v.len() % self.chunk_size;\n-            let sz = if remainder != 0 { remainder } else { self.chunk_size };\n-            let tmp = mem::replace(&mut self.v, &mut []);\n-            let tmp_len = tmp.len();\n-            let (head, tail) = tmp.mut_split_at(tmp_len - sz);\n-            self.v = head;\n-            Some(tail)\n-        }\n-    }\n }\n \n /// An iterator that moves out of a vector.\n@@ -2314,41 +814,6 @@ impl<T> Drop for MoveItems<T> {\n #[deprecated = \"replaced by Rev<MoveItems<'a, T>>\"]\n pub type RevMoveItems<T> = Rev<MoveItems<T>>;\n \n-impl<A> FromIterator<A> for ~[A] {\n-    fn from_iter<T: Iterator<A>>(mut iterator: T) -> ~[A] {\n-        let mut xs: Vec<A> = iterator.collect();\n-\n-        // Must shrink so the capacity is the same as the length. The length of\n-        // the ~[T] vector must exactly match the length of the allocation.\n-        xs.shrink_to_fit();\n-\n-        let len = xs.len();\n-        assert!(len == xs.capacity());\n-        let data = xs.as_mut_ptr();\n-\n-        let data_size = len.checked_mul(&mem::size_of::<A>());\n-        let data_size = data_size.expect(\"overflow in from_iter()\");\n-        let size = mem::size_of::<RawVec<()>>().checked_add(&data_size);\n-        let size = size.expect(\"overflow in from_iter()\");\n-\n-\n-        // This is some terribly awful code. Note that all of this will go away\n-        // with DST because creating ~[T] from Vec<T> will just be some pointer\n-        // swizzling.\n-        unsafe {\n-            let ret = malloc_raw(size) as *mut RawVec<()>;\n-\n-            (*ret).fill = len * mem::nonzero_size_of::<A>();\n-            (*ret).alloc = len * mem::nonzero_size_of::<A>();\n-            ptr::copy_nonoverlapping_memory(&mut (*ret).data as *mut _ as *mut u8,\n-                                            data as *u8,\n-                                            data_size);\n-            xs.set_len(0); // ownership has been transferred\n-            cast::transmute(ret)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use prelude::*;"}, {"sha": "35eb53593115d3e39c77bc71aaec01b67ae558a9", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91ede1f09a9f60c06b91583b3102482c249f31ab/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=91ede1f09a9f60c06b91583b3102482c249f31ab", "patch": "@@ -30,6 +30,7 @@ use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n+use slice::{MutableVectorAllocating};\n \n /// An owned, growable vector.\n ///"}]}