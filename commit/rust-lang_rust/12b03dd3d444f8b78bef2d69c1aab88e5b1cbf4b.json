{"sha": "12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyYjAzZGQzZDQ0NGY4Yjc4YmVmMmQ2OWMxYWFiODhlNWIxY2JmNGI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T21:08:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-12T23:13:13Z"}, "message": "Add an ivec interface to the #fmt library functions\n\nIt will take a snapshot to finish the ivec conversion for #fmt", "tree": {"sha": "667e2519df42e018f2c5f54353df2c68537d8c9b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/667e2519df42e018f2c5f54353df2c68537d8c9b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b", "html_url": "https://github.com/rust-lang/rust/commit/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2421312deab6311dc9b4cd8b610f799c07f50071", "url": "https://api.github.com/repos/rust-lang/rust/commits/2421312deab6311dc9b4cd8b610f799c07f50071", "html_url": "https://github.com/rust-lang/rust/commit/2421312deab6311dc9b4cd8b610f799c07f50071"}], "stats": {"total": 90, "additions": 57, "deletions": 33}, "files": [{"sha": "8aa9ce308a7b388653794873d6dbb461b84d20c6", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b", "patch": "@@ -34,7 +34,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n-    let pieces = parse_fmt_string_ivec(fmt, parse_fmt_err);\n+    let pieces = parse_fmt_string(fmt, parse_fmt_err);\n     ret pieces_to_expr(cx, sp, pieces, args);\n }\n \n@@ -73,7 +73,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_vec_expr(cx: &ext_ctxt, sp: span, exprs: &[@ast::expr]) ->\n        @ast::expr {\n-        let vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_rc);\n+        let vecexpr = ast::expr_vec(exprs, ast::imm, ast::sk_unique);\n         ret @{id: cx.next_id(), node: vecexpr, span: sp};\n     }\n     fn make_call(cx: &ext_ctxt, sp: span, fn_path: &[ast::ident],\n@@ -173,7 +173,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n                                 {ident: \"precision\", ex: precision_expr},\n                                 {ident: \"ty\", ex: ty_expr}]);\n         }\n-        let rt_conv_flags = make_flags(cx, sp, ivec::from_vec(cnv.flags));\n+        let rt_conv_flags = make_flags(cx, sp, cnv.flags);\n         let rt_conv_width = make_count(cx, sp, cnv.width);\n         let rt_conv_precision = make_count(cx, sp, cnv.precision);\n         let rt_conv_ty = make_ty(cx, sp, cnv.ty);\n@@ -182,7 +182,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: str, cnv: &conv,\n                       arg: @ast::expr) -> @ast::expr {\n-        let fname = \"conv_\" + conv_type;\n+        let fname = \"conv_\" + conv_type + \"_ivec\";\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg];"}, {"sha": "4ca7d873d1f153aa933359bbb0ada9a4593eaeec", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 53, "deletions": 29, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=12b03dd3d444f8b78bef2d69c1aab88e5b1cbf4b", "patch": "@@ -61,7 +61,7 @@ mod ct {\n     // A formatted conversion from an expression to a string\n     type conv =\n         {param: option::t[int],\n-         flags: vec[flag],\n+         flags: [flag],\n          width: count,\n          precision: count,\n          ty: ty};\n@@ -71,14 +71,14 @@ mod ct {\n     tag piece { piece_string(str); piece_conv(conv); }\n     type error_fn = fn(str) -> !  ;\n \n-    fn parse_fmt_string(s: str, error: error_fn) -> vec[piece] {\n-        let pieces: vec[piece] = [];\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n+        let pieces: [piece] = ~[];\n         let lim = str::byte_len(s);\n         let buf = \"\";\n-        fn flush_buf(buf: str, pieces: &mutable vec[piece]) -> str {\n+        fn flush_buf(buf: str, pieces: &mutable [piece]) -> str {\n             if str::byte_len(buf) > 0u {\n                 let piece = piece_string(buf);\n-                pieces += [piece];\n+                pieces += ~[piece];\n             }\n             ret \"\";\n         }\n@@ -96,7 +96,7 @@ mod ct {\n                 } else {\n                     buf = flush_buf(buf, pieces);\n                     let rs = parse_conversion(s, i, lim, error);\n-                    pieces += [rs.piece];\n+                    pieces += ~[rs.piece];\n                     i = rs.next;\n                 }\n             } else { buf += curr; i += 1u; }\n@@ -150,29 +150,32 @@ mod ct {\n             };\n     }\n     fn parse_flags(s: str, i: uint, lim: uint) ->\n-       {flags: vec[flag], next: uint} {\n-        let noflags: vec[flag] = [];\n+       {flags: [flag], next: uint} {\n+        let noflags: [flag] = ~[];\n         if i >= lim { ret {flags: noflags, next: i}; }\n+\n+        // FIXME: This recursion generates illegal instructions if the return\n+        // value isn't boxed. Only started happening after the ivec conversion\n         fn more_(f: flag, s: str, i: uint, lim: uint) ->\n-           {flags: vec[flag], next: uint} {\n+           @{flags: [flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n             let j = next.next;\n-            let curr: vec[flag] = [f];\n-            ret {flags: curr + rest, next: j};\n+            let curr: [flag] = ~[f];\n+            ret @{flags: curr + rest, next: j};\n         }\n         let more = bind more_(_, s, i, lim);\n         let f = s.(i);\n         ret if f == '-' as u8 {\n-                more(flag_left_justify)\n+                *more(flag_left_justify)\n             } else if (f == '0' as u8) {\n-                more(flag_left_zero_pad)\n+                *more(flag_left_zero_pad)\n             } else if (f == ' ' as u8) {\n-                more(flag_space_for_sign)\n+                *more(flag_space_for_sign)\n             } else if (f == '+' as u8) {\n-                more(flag_sign_always)\n+                *more(flag_sign_always)\n             } else if (f == '#' as u8) {\n-                more(flag_alternate)\n+                *more(flag_alternate)\n             } else { {flags: noflags, next: i} };\n     }\n     fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n@@ -239,10 +242,6 @@ mod ct {\n             } else { error(\"unknown type in conversion: \" + tstr) };\n         ret {ty: t, next: i + 1u};\n     }\n-\n-    fn parse_fmt_string_ivec(s: str, error: error_fn) -> [piece] {\n-        ivec::from_vec(parse_fmt_string(s, error))\n-    }\n }\n \n \n@@ -271,7 +270,32 @@ mod rt {\n     // instead just use a bool per flag\n     type conv = {flags: vec[flag], width: count, precision: count, ty: ty};\n \n+    type conv_ivec = {flags: [flag], width: count, precision: count, ty: ty};\n+\n+    fn to_conv_ivec(cv: &conv) -> conv_ivec {\n+        {flags: ivec::from_vec(cv.flags),\n+         width: cv.width,\n+         precision: cv.precision,\n+         ty: cv.ty}\n+    }\n+\n     fn conv_int(cv: &conv, i: int) -> str {\n+        conv_int_ivec(to_conv_ivec(cv), i)\n+    }\n+    fn conv_uint(cv: &conv, u: uint) -> str {\n+        conv_uint_ivec(to_conv_ivec(cv), u)\n+    }\n+    fn conv_bool(cv: &conv, b: bool) -> str {\n+        conv_bool_ivec(to_conv_ivec(cv), b)\n+    }\n+    fn conv_char(cv: &conv, c: char) -> str {\n+        conv_char_ivec(to_conv_ivec(cv), c)\n+    }\n+    fn conv_str(cv: &conv, s: str) -> str {\n+        conv_str_ivec(to_conv_ivec(cv), s)\n+    }\n+\n+    fn conv_int_ivec(cv: &conv_ivec, i: int) -> str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let s = int_to_str_prec(i, radix, prec);\n@@ -284,7 +308,7 @@ mod rt {\n         }\n         ret pad(cv, s, pad_signed);\n     }\n-    fn conv_uint(cv: &conv, u: uint) -> str {\n+    fn conv_uint_ivec(cv: &conv_ivec, u: uint) -> str {\n         let prec = get_int_precision(cv);\n         let rs =\n             alt cv.ty {\n@@ -296,17 +320,17 @@ mod rt {\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n-    fn conv_bool(cv: &conv, b: bool) -> str {\n+    fn conv_bool_ivec(cv: &conv_ivec, b: bool) -> str {\n         let s = if b { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n \n-        ret conv_str(cv, s);\n+        ret conv_str_ivec(cv, s);\n     }\n-    fn conv_char(cv: &conv, c: char) -> str {\n+    fn conv_char_ivec(cv: &conv_ivec, c: char) -> str {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n-    fn conv_str(cv: &conv, s: str) -> str {\n+    fn conv_str_ivec(cv: &conv_ivec, s: str) -> str {\n         // For strings, precision is the maximum characters\n         // displayed\n \n@@ -347,7 +371,7 @@ mod rt {\n                 } else { s }\n             };\n     }\n-    fn get_int_precision(cv: &conv) -> uint {\n+    fn get_int_precision(cv: &conv_ivec) -> uint {\n         ret alt cv.precision {\n               count_is(c) { c as uint }\n               count_implied. { 1u }\n@@ -361,7 +385,7 @@ mod rt {\n         ret str::unsafe_from_bytes(svec);\n     }\n     tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n-    fn pad(cv: &conv, s: str, mode: pad_mode) -> str {\n+    fn pad(cv: &conv_ivec, s: str, mode: pad_mode) -> str {\n         let uwidth;\n         alt cv.width {\n           count_implied. { ret s; }\n@@ -389,7 +413,7 @@ mod rt {\n           pad_signed. { might_zero_pad = true; signed = true; }\n           pad_unsigned. { might_zero_pad = true; }\n         }\n-        fn have_precision(cv: &conv) -> bool {\n+        fn have_precision(cv: &conv_ivec) -> bool {\n             ret alt cv.precision { count_implied. { false } _ { true } };\n         }\n         let zero_padding = false;\n@@ -415,7 +439,7 @@ mod rt {\n         }\n         ret padstr + s;\n     }\n-    fn have_flag(flags: vec[flag], f: flag) -> bool {\n+    fn have_flag(flags: &[flag], f: flag) -> bool {\n         for candidate: flag  in flags { if candidate == f { ret true; } }\n         ret false;\n     }"}]}