{"sha": "8da059beaaa88d463fc5c1a642ab26900c85e2b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYTA1OWJlYWFhODhkNDYzZmM1YzFhNjQyYWIyNjkwMGM4NWUyYjI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:46:47Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-15T00:46:47Z"}, "message": "typeck/expr.rs: extract out check_expr_index.", "tree": {"sha": "c5e7048e0db02b4965ec55aa65c8f617b0294cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5e7048e0db02b4965ec55aa65c8f617b0294cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8da059beaaa88d463fc5c1a642ab26900c85e2b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8da059beaaa88d463fc5c1a642ab26900c85e2b2", "html_url": "https://github.com/rust-lang/rust/commit/8da059beaaa88d463fc5c1a642ab26900c85e2b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8da059beaaa88d463fc5c1a642ab26900c85e2b2/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aa068a01bcb2f3d78a63ac50962f2e0150e3327", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aa068a01bcb2f3d78a63ac50962f2e0150e3327", "html_url": "https://github.com/rust-lang/rust/commit/1aa068a01bcb2f3d78a63ac50962f2e0150e3327"}], "stats": {"total": 109, "additions": 59, "deletions": 50}, "files": [{"sha": "ed2c9be02129a517eeb49d5b59c5ddfc0ffa7162", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8da059beaaa88d463fc5c1a642ab26900c85e2b2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8da059beaaa88d463fc5c1a642ab26900c85e2b2/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=8da059beaaa88d463fc5c1a642ab26900c85e2b2", "patch": "@@ -141,56 +141,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_field(expr, needs, &base, field)\n             }\n             ExprKind::Index(ref base, ref idx) => {\n-                let base_t = self.check_expr_with_needs(&base, needs);\n-                let idx_t = self.check_expr(&idx);\n-\n-                if base_t.references_error() {\n-                    base_t\n-                } else if idx_t.references_error() {\n-                    idx_t\n-                } else {\n-                    let base_t = self.structurally_resolved_type(base.span, base_t);\n-                    match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n-                        Some((index_ty, element_ty)) => {\n-                            // two-phase not needed because index_ty is never mutable\n-                            self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n-                            element_ty\n-                        }\n-                        None => {\n-                            let mut err =\n-                                type_error_struct!(tcx.sess, expr.span, base_t, E0608,\n-                                                   \"cannot index into a value of type `{}`\",\n-                                                   base_t);\n-                            // Try to give some advice about indexing tuples.\n-                            if let ty::Tuple(..) = base_t.sty {\n-                                let mut needs_note = true;\n-                                // If the index is an integer, we can show the actual\n-                                // fixed expression:\n-                                if let ExprKind::Lit(ref lit) = idx.node {\n-                                    if let ast::LitKind::Int(i,\n-                                            ast::LitIntType::Unsuffixed) = lit.node {\n-                                        let snip = tcx.sess.source_map().span_to_snippet(base.span);\n-                                        if let Ok(snip) = snip {\n-                                            err.span_suggestion(\n-                                                expr.span,\n-                                                \"to access tuple elements, use\",\n-                                                format!(\"{}.{}\", snip, i),\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                            needs_note = false;\n-                                        }\n-                                    }\n-                                }\n-                                if needs_note {\n-                                    err.help(\"to access tuple elements, use tuple indexing \\\n-                                              syntax (e.g., `tuple.0`)\");\n-                                }\n-                            }\n-                            err.emit();\n-                            self.tcx.types.err\n-                        }\n-                    }\n-                }\n+                self.check_expr_index(base, idx, needs, expr)\n             }\n             ExprKind::Yield(ref value) => {\n                 match self.yield_ty {\n@@ -905,4 +856,62 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.require_type_is_sized(adt_ty, expr.span, traits::StructInitializerSized);\n         adt_ty\n     }\n+\n+    fn check_expr_index(\n+        &self,\n+        base: &'tcx hir::Expr,\n+        idx: &'tcx hir::Expr,\n+        needs: Needs,\n+        expr: &'tcx hir::Expr,\n+    ) -> Ty<'tcx> {\n+        let base_t = self.check_expr_with_needs(&base, needs);\n+        let idx_t = self.check_expr(&idx);\n+\n+        if base_t.references_error() {\n+            base_t\n+        } else if idx_t.references_error() {\n+            idx_t\n+        } else {\n+            let base_t = self.structurally_resolved_type(base.span, base_t);\n+            match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n+                Some((index_ty, element_ty)) => {\n+                    // two-phase not needed because index_ty is never mutable\n+                    self.demand_coerce(idx, idx_t, index_ty, AllowTwoPhase::No);\n+                    element_ty\n+                }\n+                None => {\n+                    let mut err =\n+                        type_error_struct!(self.tcx.sess, expr.span, base_t, E0608,\n+                                            \"cannot index into a value of type `{}`\",\n+                                            base_t);\n+                    // Try to give some advice about indexing tuples.\n+                    if let ty::Tuple(..) = base_t.sty {\n+                        let mut needs_note = true;\n+                        // If the index is an integer, we can show the actual\n+                        // fixed expression:\n+                        if let ExprKind::Lit(ref lit) = idx.node {\n+                            if let ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) = lit.node {\n+                                let snip = self.tcx.sess.source_map().span_to_snippet(base.span);\n+                                if let Ok(snip) = snip {\n+                                    err.span_suggestion(\n+                                        expr.span,\n+                                        \"to access tuple elements, use\",\n+                                        format!(\"{}.{}\", snip, i),\n+                                        Applicability::MachineApplicable,\n+                                    );\n+                                    needs_note = false;\n+                                }\n+                            }\n+                        }\n+                        if needs_note {\n+                            err.help(\"to access tuple elements, use tuple indexing \\\n+                                        syntax (e.g., `tuple.0`)\");\n+                        }\n+                    }\n+                    err.emit();\n+                    self.tcx.types.err\n+                }\n+            }\n+        }\n+    }\n }"}]}