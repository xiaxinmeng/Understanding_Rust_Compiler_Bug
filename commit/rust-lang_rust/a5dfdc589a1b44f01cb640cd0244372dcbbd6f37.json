{"sha": "a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZGZkYzU4OWExYjQ0ZjAxY2I2NDBjZDAyNDQzNzJkY2JiZDZmMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-04T02:31:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-04T02:31:46Z"}, "message": "Auto merge of #59684 - Centril:rollup-n7pnare, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #59316 (Internal lints take 2)\n - #59663 (Be more direct about borrow contract)\n - #59664 (Updated the documentation of spin_loop and spin_loop_hint)\n - #59666 (Updated the environment description in rustc.)\n - #59669 (Reduce repetition in librustc(_lint) wrt. impl LintPass by using macros)\n - #59677 (rustfix coverage: Skip UI tests with non-json error-format)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "2e64cd0111d47ed14ffdfbde912e5a746ac8b454", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e64cd0111d47ed14ffdfbde912e5a746ac8b454"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "html_url": "https://github.com/rust-lang/rust/commit/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "314a79cd80ed905f80d24b79fd7acb4c8c72789b", "url": "https://api.github.com/repos/rust-lang/rust/commits/314a79cd80ed905f80d24b79fd7acb4c8c72789b", "html_url": "https://github.com/rust-lang/rust/commit/314a79cd80ed905f80d24b79fd7acb4c8c72789b"}, {"sha": "231bd482c6d2f2aae463f2d5b57ed3c8f5a0803e", "url": "https://api.github.com/repos/rust-lang/rust/commits/231bd482c6d2f2aae463f2d5b57ed3c8f5a0803e", "html_url": "https://github.com/rust-lang/rust/commit/231bd482c6d2f2aae463f2d5b57ed3c8f5a0803e"}], "stats": {"total": 1655, "additions": 939, "deletions": 716}, "files": [{"sha": "86ce5fd01a812421323089946b223372b9b2cf30", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -316,6 +316,11 @@ fn main() {\n         }\n     }\n \n+    // This is required for internal lints.\n+    if stage != \"0\" {\n+        cmd.arg(\"-Zunstable-options\");\n+    }\n+\n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates\n     // also in the sysroot. We also do this for host crates, since those"}, {"sha": "2faf0c2e3e1fa95cca918a5b553191de109ea63e", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -265,8 +265,8 @@ Optimize with possible levels 0\\[en]3\n \n .SH ENVIRONMENT\n \n-Some of these affect the output of the compiler, while others affect programs\n-which link to the standard library.\n+Some of these affect only test harness programs (generated via rustc --test);\n+others affect all programs which link to the Rust standard library.\n \n .TP\n \\fBRUST_TEST_THREADS\\fR"}, {"sha": "6fa15884f5abb12139a3e321655938b90584670d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -12,6 +12,7 @@\n        test(no_crate_inject, attr(deny(warnings))))]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(alloc)]\n #![feature(core_intrinsics)]"}, {"sha": "4d58aaca941833ac047d7282c25261bfad9e329c", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -32,6 +32,10 @@\n /// on the identical behavior of these additional trait implementations.\n /// These traits will likely appear as additional trait bounds.\n ///\n+/// In particular `Eq`, `Ord` and `Hash` must be equivalent for\n+/// borrowed and owned values: `x.borrow() == y.borrow()` should give the\n+/// same result as `x == y`.\n+///\n /// If generic code merely needs to work for all types that can\n /// provide a reference to related type `T`, it is often better to use\n /// [`AsRef<T>`] as more types can safely implement it."}, {"sha": "7b9e19e36a293be5a2af5b1f996a94c275452610", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -105,11 +105,13 @@ pub const fn identity<T>(x: T) -> T { x }\n /// `&T` or write a custom function.\n ///\n ///\n-/// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n+/// `AsRef` has the same signature as [`Borrow`], but `Borrow` is different in few aspects:\n ///\n-/// - Use `AsRef` when the goal is to simply convert into a reference\n-/// - Use `Borrow` when the goal is related to writing code that is agnostic to\n-///   the type of borrow and whether it is a reference or value\n+/// - Unlike `AsRef`, `Borrow` has a blanket impl for any `T`, and can be used to accept either\n+///   a reference or a value.\n+/// - `Borrow` also requires that `Hash`, `Eq` and `Ord` for borrowed value are\n+///   equivalent to those of the owned value. For this reason, if you want to\n+///   borrow only a single field of a struct you can implement `AsRef`, but not `Borrow`.\n ///\n /// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n ///"}, {"sha": "d43e6c49f4c99e5bad0ce803cf80700396878caf", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -50,15 +50,28 @@ pub unsafe fn unreachable_unchecked() -> ! {\n     intrinsics::unreachable()\n }\n \n-/// Save power or switch hyperthreads in a busy-wait spin-loop.\n+/// Signals the processor that it is entering a busy-wait spin-loop.\n ///\n-/// This function is deliberately more primitive than\n-/// [`std::thread::yield_now`](../../std/thread/fn.yield_now.html) and\n-/// does not directly yield to the system's scheduler.\n-/// In some cases it might be useful to use a combination of both functions.\n-/// Careful benchmarking is advised.\n+/// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n+/// power or switching hyper-threads.\n ///\n-/// On some platforms this function may not do anything at all.\n+/// This function is different than [`std::thread::yield_now`] which directly yields to the\n+/// system's scheduler, whereas `spin_loop` only signals the processor that it is entering a\n+/// busy-wait spin-loop without yielding control to the system's scheduler.\n+///\n+/// Using a busy-wait spin-loop with `spin_loop` is ideally used in situations where a\n+/// contended lock is held by another thread executed on a different CPU and where the waiting\n+/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n+/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n+/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n+/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n+/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n+/// use [`std::thread::yield_now`].\n+///\n+/// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n+/// do anything at all.\n+///\n+/// [`std::thread::yield_now`]: ../../std/thread/fn.yield_now.html\n #[inline]\n #[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\n pub fn spin_loop() {"}, {"sha": "26b59969e18afc20c4b31736f0eaed9d6cfb4fc5", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -124,15 +124,28 @@ use fmt;\n \n use hint::spin_loop;\n \n-/// Save power or switch hyperthreads in a busy-wait spin-loop.\n+/// Signals the processor that it is entering a busy-wait spin-loop.\n ///\n-/// This function is deliberately more primitive than\n-/// [`std::thread::yield_now`](../../../std/thread/fn.yield_now.html) and\n-/// does not directly yield to the system's scheduler.\n-/// In some cases it might be useful to use a combination of both functions.\n-/// Careful benchmarking is advised.\n+/// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n+/// power or switching hyper-threads.\n ///\n-/// On some platforms this function may not do anything at all.\n+/// This function is different than [`std::thread::yield_now`] which directly yields to the\n+/// system's scheduler, whereas `spin_loop_hint` only signals the processor that it is entering a\n+/// busy-wait spin-loop without yielding control to the system's scheduler.\n+///\n+/// Using a busy-wait spin-loop with `spin_loop_hint` is ideally used in situations where a\n+/// contended lock is held by another thread executed on a different CPU and where the waiting\n+/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n+/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n+/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n+/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n+/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n+/// use [`std::thread::yield_now`].\n+///\n+/// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n+/// do anything at all.\n+///\n+/// [`std::thread::yield_now`]: ../../../std/thread/fn.yield_now.html\n #[inline]\n #[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n pub fn spin_loop_hint() {"}, {"sha": "2536121c7a3247da618679eeea97c298e361de9a", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -9,6 +9,7 @@\n        test(attr(deny(warnings))))]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(nll)]\n #![feature(rustc_private)]"}, {"sha": "abfa96841d9f6ce1fe16eb03001a06cc6f2336ee", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 104, "deletions": 3, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1,10 +1,10 @@\n-use crate::ty;\n-use crate::ty::TyCtxt;\n-use crate::hir::map::definitions::FIRST_FREE_HIGH_DEF_INDEX;\n+use crate::ty::{self, print::Printer, subst::Kind, Ty, TyCtxt};\n+use crate::hir::map::definitions::{DisambiguatedDefPathData, FIRST_FREE_HIGH_DEF_INDEX};\n use rustc_data_structures::indexed_vec::Idx;\n use serialize;\n use std::fmt;\n use std::u32;\n+use syntax::symbol::{LocalInternedString, Symbol};\n \n newtype_index! {\n     pub struct CrateId {\n@@ -252,6 +252,107 @@ impl DefId {\n             format!(\"module `{}`\", tcx.def_path_str(*self))\n         }\n     }\n+\n+    /// Check if a `DefId`'s path matches the given absolute type path usage.\n+    // Uplifted from rust-lang/rust-clippy\n+    pub fn match_path<'a, 'tcx>(self, tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &[&str]) -> bool {\n+        pub struct AbsolutePathPrinter<'a, 'tcx> {\n+            pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        }\n+\n+        impl<'tcx> Printer<'tcx, 'tcx> for AbsolutePathPrinter<'_, 'tcx> {\n+            type Error = !;\n+\n+            type Path = Vec<LocalInternedString>;\n+            type Region = ();\n+            type Type = ();\n+            type DynExistential = ();\n+\n+            fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+                self.tcx\n+            }\n+\n+            fn print_region(self, _region: ty::Region<'_>) -> Result<Self::Region, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_type(self, _ty: Ty<'tcx>) -> Result<Self::Type, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn print_dyn_existential(\n+                self,\n+                _predicates: &'tcx ty::List<ty::ExistentialPredicate<'tcx>>,\n+                ) -> Result<Self::DynExistential, Self::Error> {\n+                Ok(())\n+            }\n+\n+            fn path_crate(self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {\n+                Ok(vec![self.tcx.original_crate_name(cnum).as_str()])\n+            }\n+\n+            fn path_qualified(\n+                self,\n+                self_ty: Ty<'tcx>,\n+                trait_ref: Option<ty::TraitRef<'tcx>>,\n+                ) -> Result<Self::Path, Self::Error> {\n+                if trait_ref.is_none() {\n+                    if let ty::Adt(def, substs) = self_ty.sty {\n+                        return self.print_def_path(def.did, substs);\n+                    }\n+                }\n+\n+                // This shouldn't ever be needed, but just in case:\n+                Ok(vec![match trait_ref {\n+                    Some(trait_ref) => Symbol::intern(&format!(\"{:?}\", trait_ref)).as_str(),\n+                    None => Symbol::intern(&format!(\"<{}>\", self_ty)).as_str(),\n+                }])\n+            }\n+\n+            fn path_append_impl(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _disambiguated_data: &DisambiguatedDefPathData,\n+                self_ty: Ty<'tcx>,\n+                trait_ref: Option<ty::TraitRef<'tcx>>,\n+                ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+\n+                // This shouldn't ever be needed, but just in case:\n+                path.push(match trait_ref {\n+                    Some(trait_ref) => {\n+                        Symbol::intern(&format!(\"<impl {} for {}>\", trait_ref, self_ty)).as_str()\n+                    },\n+                    None => Symbol::intern(&format!(\"<impl {}>\", self_ty)).as_str(),\n+                });\n+\n+                Ok(path)\n+            }\n+\n+            fn path_append(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                disambiguated_data: &DisambiguatedDefPathData,\n+                ) -> Result<Self::Path, Self::Error> {\n+                let mut path = print_prefix(self)?;\n+                path.push(disambiguated_data.data.as_interned_str().as_str());\n+                Ok(path)\n+            }\n+\n+            fn path_generic_args(\n+                self,\n+                print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n+                _args: &[Kind<'tcx>],\n+                ) -> Result<Self::Path, Self::Error> {\n+                print_prefix(self)\n+            }\n+        }\n+\n+        let names = AbsolutePathPrinter { tcx }.print_def_path(self, &[]).unwrap();\n+\n+        names.len() == path.len()\n+            && names.into_iter().zip(path.iter()).all(|(a, &b)| *a == *b)\n+    }\n }\n \n impl serialize::UseSpecializedEncodable for DefId {}"}, {"sha": "a8e5db26eadc137c36789c59d45261ec4326264d", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -9,7 +9,6 @@ use crate::session::Session;\n \n use std::cmp::Ord;\n use std::hash as std_hash;\n-use std::collections::HashMap;\n use std::cell::RefCell;\n \n use syntax::ast;\n@@ -394,13 +393,12 @@ impl<'a> HashStable<StableHashingContext<'a>> for DelimSpan {\n     }\n }\n \n-pub fn hash_stable_trait_impls<'a, 'gcx, W, R>(\n+pub fn hash_stable_trait_impls<'a, 'gcx, W>(\n     hcx: &mut StableHashingContext<'a>,\n     hasher: &mut StableHasher<W>,\n     blanket_impls: &[DefId],\n-    non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)\n-    where W: StableHasherResult,\n-          R: std_hash::BuildHasher,\n+    non_blanket_impls: &FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>)\n+    where W: StableHasherResult\n {\n     {\n         let mut blanket_impls: SmallVec<[_; 8]> = blanket_impls"}, {"sha": "19663161fe3fa45bd5f49811a9e916cf433156b5", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -56,7 +56,7 @@ use crate::hir::Node;\n use crate::middle::region;\n use crate::traits::{ObligationCause, ObligationCauseCode};\n use crate::ty::error::TypeError;\n-use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TyKind, TypeFoldable};\n+use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use std::{cmp, fmt};\n use syntax_pos::{Pos, Span};\n@@ -1094,14 +1094,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 (_, false, _) => {\n                     if let Some(exp_found) = exp_found {\n                         let (def_id, ret_ty) = match exp_found.found.sty {\n-                            TyKind::FnDef(def, _) => {\n+                            ty::FnDef(def, _) => {\n                                 (Some(def), Some(self.tcx.fn_sig(def).output()))\n                             }\n                             _ => (None, None),\n                         };\n \n                         let exp_is_struct = match exp_found.expected.sty {\n-                            TyKind::Adt(def, _) => def.is_struct(),\n+                            ty::Adt(def, _) => def.is_struct(),\n                             _ => false,\n                         };\n \n@@ -1140,8 +1140,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         diag: &mut DiagnosticBuilder<'tcx>,\n     ) {\n         match (&exp_found.expected.sty, &exp_found.found.sty) {\n-            (TyKind::Adt(exp_def, exp_substs), TyKind::Ref(_, found_ty, _)) => {\n-                if let TyKind::Adt(found_def, found_substs) = found_ty.sty {\n+            (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) => {\n+                if let ty::Adt(found_def, found_substs) = found_ty.sty {\n                     let path_str = format!(\"{:?}\", exp_def);\n                     if exp_def == &found_def {\n                         let opt_msg = \"you can convert from `&Option<T>` to `Option<&T>` using \\\n@@ -1164,17 +1164,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             let mut show_suggestion = true;\n                             for (exp_ty, found_ty) in exp_substs.types().zip(found_substs.types()) {\n                                 match exp_ty.sty {\n-                                    TyKind::Ref(_, exp_ty, _) => {\n+                                    ty::Ref(_, exp_ty, _) => {\n                                         match (&exp_ty.sty, &found_ty.sty) {\n-                                            (_, TyKind::Param(_)) |\n-                                            (_, TyKind::Infer(_)) |\n-                                            (TyKind::Param(_), _) |\n-                                            (TyKind::Infer(_), _) => {}\n+                                            (_, ty::Param(_)) |\n+                                            (_, ty::Infer(_)) |\n+                                            (ty::Param(_), _) |\n+                                            (ty::Infer(_), _) => {}\n                                             _ if ty::TyS::same_type(exp_ty, found_ty) => {}\n                                             _ => show_suggestion = false,\n                                         };\n                                     }\n-                                    TyKind::Param(_) | TyKind::Infer(_) => {}\n+                                    ty::Param(_) | ty::Infer(_) => {}\n                                     _ => show_suggestion = false,\n                                 }\n                             }"}, {"sha": "0b75cb6c8a3e29b7c18f79cb805302d484e67957", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -29,6 +29,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n #![allow(explicit_outlives_requirements)]\n \n #![feature(arbitrary_self_types)]"}, {"sha": "dc5894cd6b91ff00ad34f7275108696378cbb7a2", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 66, "deletions": 75, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -392,81 +392,72 @@ declare_lint! {\n     \"nested occurrence of `impl Trait` type\"\n }\n \n-/// Does nothing as a lint pass, but registers some `Lint`s\n-/// that are used by other parts of the compiler.\n-#[derive(Copy, Clone)]\n-pub struct HardwiredLints;\n-\n-impl LintPass for HardwiredLints {\n-    fn name(&self) -> &'static str {\n-        \"HardwiredLints\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(\n-            ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-            EXCEEDING_BITSHIFTS,\n-            UNUSED_IMPORTS,\n-            UNUSED_EXTERN_CRATES,\n-            UNUSED_QUALIFICATIONS,\n-            UNKNOWN_LINTS,\n-            UNUSED_VARIABLES,\n-            UNUSED_ASSIGNMENTS,\n-            DEAD_CODE,\n-            UNREACHABLE_CODE,\n-            UNREACHABLE_PATTERNS,\n-            UNUSED_MACROS,\n-            WARNINGS,\n-            UNUSED_FEATURES,\n-            STABLE_FEATURES,\n-            UNKNOWN_CRATE_TYPES,\n-            TRIVIAL_CASTS,\n-            TRIVIAL_NUMERIC_CASTS,\n-            PRIVATE_IN_PUBLIC,\n-            EXPORTED_PRIVATE_DEPENDENCIES,\n-            PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n-            INVALID_TYPE_PARAM_DEFAULT,\n-            CONST_ERR,\n-            RENAMED_AND_REMOVED_LINTS,\n-            SAFE_EXTERN_STATICS,\n-            SAFE_PACKED_BORROWS,\n-            PATTERNS_IN_FNS_WITHOUT_BODY,\n-            LEGACY_DIRECTORY_OWNERSHIP,\n-            LEGACY_CONSTRUCTOR_VISIBILITY,\n-            MISSING_FRAGMENT_SPECIFIER,\n-            PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-            LATE_BOUND_LIFETIME_ARGUMENTS,\n-            INCOHERENT_FUNDAMENTAL_IMPLS,\n-            ORDER_DEPENDENT_TRAIT_OBJECTS,\n-            DEPRECATED,\n-            UNUSED_UNSAFE,\n-            UNUSED_MUT,\n-            UNCONDITIONAL_RECURSION,\n-            SINGLE_USE_LIFETIMES,\n-            UNUSED_LIFETIMES,\n-            UNUSED_LABELS,\n-            TYVAR_BEHIND_RAW_POINTER,\n-            ELIDED_LIFETIMES_IN_PATHS,\n-            BARE_TRAIT_OBJECTS,\n-            ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n-            UNSTABLE_NAME_COLLISIONS,\n-            IRREFUTABLE_LET_PATTERNS,\n-            DUPLICATE_MACRO_EXPORTS,\n-            INTRA_DOC_LINK_RESOLUTION_FAILURE,\n-            MISSING_DOC_CODE_EXAMPLES,\n-            PRIVATE_DOC_TESTS,\n-            WHERE_CLAUSES_OBJECT_SAFETY,\n-            PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-            MACRO_USE_EXTERN_CRATE,\n-            MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n-            parser::QUESTION_MARK_MACRO_SEP,\n-            parser::ILL_FORMED_ATTRIBUTE_INPUT,\n-            DEPRECATED_IN_FUTURE,\n-            AMBIGUOUS_ASSOCIATED_ITEMS,\n-            NESTED_IMPL_TRAIT,\n-            DUPLICATE_MATCHER_BINDING_NAME,\n-        )\n-    }\n+declare_lint_pass! {\n+    /// Does nothing as a lint pass, but registers some `Lint`s\n+    /// that are used by other parts of the compiler.\n+    HardwiredLints => [\n+        ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+        EXCEEDING_BITSHIFTS,\n+        UNUSED_IMPORTS,\n+        UNUSED_EXTERN_CRATES,\n+        UNUSED_QUALIFICATIONS,\n+        UNKNOWN_LINTS,\n+        UNUSED_VARIABLES,\n+        UNUSED_ASSIGNMENTS,\n+        DEAD_CODE,\n+        UNREACHABLE_CODE,\n+        UNREACHABLE_PATTERNS,\n+        UNUSED_MACROS,\n+        WARNINGS,\n+        UNUSED_FEATURES,\n+        STABLE_FEATURES,\n+        UNKNOWN_CRATE_TYPES,\n+        TRIVIAL_CASTS,\n+        TRIVIAL_NUMERIC_CASTS,\n+        PRIVATE_IN_PUBLIC,\n+        EXPORTED_PRIVATE_DEPENDENCIES,\n+        PUB_USE_OF_PRIVATE_EXTERN_CRATE,\n+        INVALID_TYPE_PARAM_DEFAULT,\n+        CONST_ERR,\n+        RENAMED_AND_REMOVED_LINTS,\n+        SAFE_EXTERN_STATICS,\n+        SAFE_PACKED_BORROWS,\n+        PATTERNS_IN_FNS_WITHOUT_BODY,\n+        LEGACY_DIRECTORY_OWNERSHIP,\n+        LEGACY_CONSTRUCTOR_VISIBILITY,\n+        MISSING_FRAGMENT_SPECIFIER,\n+        PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+        LATE_BOUND_LIFETIME_ARGUMENTS,\n+        INCOHERENT_FUNDAMENTAL_IMPLS,\n+        ORDER_DEPENDENT_TRAIT_OBJECTS,\n+        DEPRECATED,\n+        UNUSED_UNSAFE,\n+        UNUSED_MUT,\n+        UNCONDITIONAL_RECURSION,\n+        SINGLE_USE_LIFETIMES,\n+        UNUSED_LIFETIMES,\n+        UNUSED_LABELS,\n+        TYVAR_BEHIND_RAW_POINTER,\n+        ELIDED_LIFETIMES_IN_PATHS,\n+        BARE_TRAIT_OBJECTS,\n+        ABSOLUTE_PATHS_NOT_STARTING_WITH_CRATE,\n+        UNSTABLE_NAME_COLLISIONS,\n+        IRREFUTABLE_LET_PATTERNS,\n+        DUPLICATE_MACRO_EXPORTS,\n+        INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        MISSING_DOC_CODE_EXAMPLES,\n+        PRIVATE_DOC_TESTS,\n+        WHERE_CLAUSES_OBJECT_SAFETY,\n+        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+        MACRO_USE_EXTERN_CRATE,\n+        MACRO_EXPANDED_MACRO_EXPORTS_ACCESSED_BY_ABSOLUTE_PATHS,\n+        parser::QUESTION_MARK_MACRO_SEP,\n+        parser::ILL_FORMED_ATTRIBUTE_INPUT,\n+        DEPRECATED_IN_FUTURE,\n+        AMBIGUOUS_ASSOCIATED_ITEMS,\n+        NESTED_IMPL_TRAIT,\n+        DUPLICATE_MATCHER_BINDING_NAME,\n+    ]\n }\n \n // this could be a closure, but then implementing derive traits"}, {"sha": "d5f8876d1621f0dbc036c0b05e747c208e9f8ce9", "filename": "src/librustc/lint/internal.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -0,0 +1,127 @@\n+//! Some lints that are only useful in the compiler or crates that use compiler internals, such as\n+//! Clippy.\n+\n+use crate::hir::{HirId, Path, PathSegment, QPath, Ty, TyKind};\n+use crate::lint::{\n+    EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintArray, LintContext, LintPass,\n+};\n+use errors::Applicability;\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax::ast::Ident;\n+\n+declare_lint! {\n+    pub DEFAULT_HASH_TYPES,\n+    Allow,\n+    \"forbid HashMap and HashSet and suggest the FxHash* variants\"\n+}\n+\n+pub struct DefaultHashTypes {\n+    map: FxHashMap<String, String>,\n+}\n+\n+impl DefaultHashTypes {\n+    pub fn new() -> Self {\n+        let mut map = FxHashMap::default();\n+        map.insert(\"HashMap\".to_string(), \"FxHashMap\".to_string());\n+        map.insert(\"HashSet\".to_string(), \"FxHashSet\".to_string());\n+        Self { map }\n+    }\n+}\n+\n+impl LintPass for DefaultHashTypes {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEFAULT_HASH_TYPES)\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        \"DefaultHashTypes\"\n+    }\n+}\n+\n+impl EarlyLintPass for DefaultHashTypes {\n+    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: Ident) {\n+        let ident_string = ident.to_string();\n+        if let Some(replace) = self.map.get(&ident_string) {\n+            let msg = format!(\n+                \"Prefer {} over {}, it has better performance\",\n+                replace, ident_string\n+            );\n+            let mut db = cx.struct_span_lint(DEFAULT_HASH_TYPES, ident.span, &msg);\n+            db.span_suggestion(\n+                ident.span,\n+                \"use\",\n+                replace.to_string(),\n+                Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n+            );\n+            db.note(&format!(\n+                \"a `use rustc_data_structures::fx::{}` may be necessary\",\n+                replace\n+            ))\n+            .emit();\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub USAGE_OF_TY_TYKIND,\n+    Allow,\n+    \"Usage of `ty::TyKind` outside of the `ty::sty` module\"\n+}\n+\n+pub struct TyKindUsage;\n+\n+impl LintPass for TyKindUsage {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(USAGE_OF_TY_TYKIND)\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        \"TyKindUsage\"\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyKindUsage {\n+    fn check_path(&mut self, cx: &LateContext<'_, '_>, path: &'tcx Path, _: HirId) {\n+        let segments = path.segments.iter().rev().skip(1).rev();\n+\n+        if let Some(last) = segments.last() {\n+            let span = path.span.with_hi(last.ident.span.hi());\n+            if lint_ty_kind_usage(cx, last) {\n+                cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, \"usage of `ty::TyKind::<kind>`\")\n+                    .span_suggestion(\n+                        span,\n+                        \"try using ty::<kind> directly\",\n+                        \"ty\".to_string(),\n+                        Applicability::MaybeIncorrect, // ty maybe needs an import\n+                    )\n+                    .emit();\n+            }\n+        }\n+    }\n+\n+    fn check_ty(&mut self, cx: &LateContext<'_, '_>, ty: &'tcx Ty) {\n+        if let TyKind::Path(qpath) = &ty.node {\n+            if let QPath::Resolved(_, path) = qpath {\n+                if let Some(last) = path.segments.iter().last() {\n+                    if lint_ty_kind_usage(cx, last) {\n+                        cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, \"usage of `ty::TyKind`\")\n+                            .help(\"try using `ty::Ty` instead\")\n+                            .emit();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n+    if segment.ident.as_str() == \"TyKind\" {\n+        if let Some(def) = segment.def {\n+            if let Some(did) = def.opt_def_id() {\n+                return did.match_path(cx.tcx, &[\"rustc\", \"ty\", \"sty\", \"TyKind\"]);\n+            }\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "57d1ce9cad426c6a2e7c18e9b7df7dc6afe4ed22", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -181,6 +181,27 @@ pub trait LintPass {\n     fn get_lints(&self) -> LintArray;\n }\n \n+/// Implements `LintPass for $name` with the given list of `Lint` statics.\n+#[macro_export]\n+macro_rules! impl_lint_pass {\n+    ($name:ident => [$($lint:expr),* $(,)?]) => {\n+        impl LintPass for $name {\n+            fn name(&self) -> &'static str { stringify!($name) }\n+            fn get_lints(&self) -> LintArray { $crate::lint_array!($($lint),*) }\n+        }\n+    };\n+}\n+\n+/// Declares a type named `$name` which implements `LintPass`.\n+/// To the right of `=>` a comma separated list of `Lint` statics is given.\n+#[macro_export]\n+macro_rules! declare_lint_pass {\n+    ($(#[$m:meta])* $name:ident => [$($lint:expr),* $(,)?]) => {\n+        $(#[$m])* #[derive(Copy, Clone)] pub struct $name;\n+        $crate::impl_lint_pass!($name => [$($lint),*]);\n+    };\n+}\n+\n #[macro_export]\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n@@ -574,6 +595,7 @@ impl_stable_hash_for!(enum self::LintSource {\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;\n+pub mod internal;\n mod context;\n mod levels;\n "}, {"sha": "23be1bbf6c6877c2eb323bf6828a13c25f77f783", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n     pub fn field_ty(self, tcx: TyCtxt<'a, 'gcx, 'tcx>, f: &Field) -> Ty<'tcx>\n     {\n         let answer = match self.ty.sty {\n-            ty::TyKind::Adt(adt_def, substs) => {\n+            ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n                     None => adt_def.non_enum_variant(),\n                     Some(variant_index) => {"}, {"sha": "aa5610739fd6da8cb2ff853be6130cd0b99a21f2", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -219,6 +219,11 @@ pub struct CommonTypes<'tcx> {\n     pub never: Ty<'tcx>,\n     pub err: Ty<'tcx>,\n \n+    /// Dummy type used for the `Self` of a `TraitRef` created for converting\n+    /// a trait object, and which gets removed in `ExistentialTraitRef`.\n+    /// This type must not appear anywhere in other converted types.\n+    pub trait_object_dummy_self: Ty<'tcx>,\n+\n     pub re_empty: Region<'tcx>,\n     pub re_static: Region<'tcx>,\n     pub re_erased: Region<'tcx>,\n@@ -955,6 +960,8 @@ impl<'tcx> CommonTypes<'tcx> {\n             f32: mk(Float(ast::FloatTy::F32)),\n             f64: mk(Float(ast::FloatTy::F64)),\n \n+            trait_object_dummy_self: mk(Infer(ty::FreshTy(0))),\n+\n             re_empty: mk_region(RegionKind::ReEmpty),\n             re_static: mk_region(RegionKind::ReStatic),\n             re_erased: mk_region(RegionKind::ReErased),"}, {"sha": "7d47867cea12573b2ba5e34f821acf777ba58097", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1,3 +1,5 @@\n+#![cfg_attr(not(stage0), allow(usage_of_ty_tykind))]\n+\n pub use self::Variance::*;\n pub use self::AssociatedItemContainer::*;\n pub use self::BorrowKind::*;"}, {"sha": "26194176350ac2a177e36a8c61649675d2a5db38", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1,11 +1,10 @@\n #![allow(non_camel_case_types)]\n \n-use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::{fx::FxHashMap, sync::Lock};\n \n use std::cell::{RefCell, Cell};\n-use std::collections::HashMap;\n use std::fmt::Debug;\n-use std::hash::{Hash, BuildHasher};\n+use std::hash::Hash;\n use std::panic;\n use std::env;\n use std::time::{Duration, Instant};\n@@ -341,8 +340,8 @@ pub trait MemoizationMap {\n         where OP: FnOnce() -> Self::Value;\n }\n \n-impl<K, V, S> MemoizationMap for RefCell<HashMap<K,V,S>>\n-    where K: Hash+Eq+Clone, V: Clone, S: BuildHasher\n+impl<K, V> MemoizationMap for RefCell<FxHashMap<K,V>>\n+    where K: Hash+Eq+Clone, V: Clone\n {\n     type Key = K;\n     type Value = V;"}, {"sha": "a9e422fb238b8ef3b173928745a0062cd1754379", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -2,6 +2,7 @@\n #![feature(rustc_private)]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n pub mod expand;\n "}, {"sha": "3761a52bcccf2d8da1c4a2edfbcabf3e8b2de739", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(non_camel_case_types)]\n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(nll)]\n "}, {"sha": "e2917578c0ece4c3c098113fd1601ffa5d1f418c", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -14,6 +14,7 @@\n #![allow(unused_attributes)]\n #![allow(dead_code)]\n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n #![allow(explicit_outlives_requirements)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "330cfe154e302814e9034e6e354cfc6314f6ea93", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -16,6 +16,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #[macro_use]\n extern crate rustc;"}, {"sha": "2781bfa3ec8495a8324836e96404a8639df8f86d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -17,6 +17,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n pub extern crate getopts;\n #[cfg(unix)]"}, {"sha": "71bef54cd17a12c30ce796f1e14e241d97f8b0e6", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -6,6 +6,7 @@\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #[allow(unused_extern_crates)]\n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "d7db324f3463efa9b723295a2c9c7ae8c0477baf", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -8,6 +8,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #[macro_use] extern crate rustc;\n #[allow(unused_extern_crates)]"}, {"sha": "74085123f89ee345d075f83d5492d52778a9edb0", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -12,7 +12,6 @@ use rustc_data_structures::OnDrop;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_metadata::cstore::CStore;\n-use std::collections::HashSet;\n use std::io::Write;\n use std::path::PathBuf;\n use std::result;"}, {"sha": "353ff6a57a5efee02c99134bc49e470b7c4aa4a2", "filename": "src/librustc_interface/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_interface%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_interface%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -7,6 +7,7 @@\n #![cfg_attr(unix, feature(libc))]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![allow(unused_imports)]\n "}, {"sha": "17523aedffb58ef2a0e4ec79c3fdf3f3b3543e52", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -21,7 +21,6 @@ use rustc_plugin;\n use rustc_privacy;\n use rustc_resolve;\n use rustc_typeck;\n-use std::collections::HashSet;\n use std::env;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n use std::io::{self, Write};\n@@ -109,6 +108,9 @@ pub fn create_session(\n     let codegen_backend = get_codegen_backend(&sess);\n \n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+    if sess.unstable_options() {\n+        rustc_lint::register_internals(&mut sess.lint_store.borrow_mut(), Some(&sess));\n+    }\n \n     let mut cfg = config::build_configuration(&sess, config::to_crate_config(cfg));\n     add_configuration(&mut cfg, &sess, &*codegen_backend);"}, {"sha": "7fe047ec2c65a56b7be4b253ef8192ee1ba817ae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 84, "deletions": 317, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -63,18 +63,7 @@ declare_lint! {\n     \"suggest using `loop { }` instead of `while true { }`\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct WhileTrue;\n-\n-impl LintPass for WhileTrue {\n-    fn name(&self) -> &'static str {\n-        \"WhileTrue\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(WHILE_TRUE)\n-    }\n-}\n+declare_lint_pass!(WhileTrue => [WHILE_TRUE]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n@@ -105,8 +94,7 @@ declare_lint! {\n     \"use of owned (Box type) heap memory\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct BoxPointers;\n+declare_lint_pass!(BoxPointers => [BOX_POINTERS]);\n \n impl BoxPointers {\n     fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n@@ -119,16 +107,6 @@ impl BoxPointers {\n     }\n }\n \n-impl LintPass for BoxPointers {\n-    fn name(&self) -> &'static str {\n-        \"BoxPointers\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(BOX_POINTERS)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n@@ -169,18 +147,7 @@ declare_lint! {\n     \"using `Struct { x: x }` instead of `Struct { x }` in a pattern\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct NonShorthandFieldPatterns;\n-\n-impl LintPass for NonShorthandFieldPatterns {\n-    fn name(&self) -> &'static str {\n-        \"NonShorthandFieldPatterns\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_SHORTHAND_FIELD_PATTERNS)\n-    }\n-}\n+declare_lint_pass!(NonShorthandFieldPatterns => [NON_SHORTHAND_FIELD_PATTERNS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat) {\n@@ -226,18 +193,7 @@ declare_lint! {\n     \"usage of `unsafe` code\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnsafeCode;\n-\n-impl LintPass for UnsafeCode {\n-    fn name(&self) -> &'static str {\n-        \"UnsafeCode\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSAFE_CODE)\n-    }\n-}\n+declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);\n \n impl UnsafeCode {\n     fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, desc: &'static str) {\n@@ -327,6 +283,8 @@ pub struct MissingDoc {\n     private_traits: FxHashSet<hir::HirId>,\n }\n \n+impl_lint_pass!(MissingDoc => [MISSING_DOCS]);\n+\n fn has_doc(attr: &ast::Attribute) -> bool {\n     if !attr.check_name(\"doc\") {\n         return false;\n@@ -394,16 +352,6 @@ impl MissingDoc {\n     }\n }\n \n-impl LintPass for MissingDoc {\n-    fn name(&self) -> &'static str {\n-        \"MissingDoc\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_DOCS)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     fn enter_lint_attrs(&mut self, _: &LateContext<'_, '_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n@@ -541,18 +489,7 @@ declare_lint! {\n     \"detects potentially-forgotten implementations of `Copy`\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct MissingCopyImplementations;\n-\n-impl LintPass for MissingCopyImplementations {\n-    fn name(&self) -> &'static str {\n-        \"MissingCopyImplementations\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_COPY_IMPLEMENTATIONS)\n-    }\n-}\n+declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n@@ -609,22 +546,14 @@ pub struct MissingDebugImplementations {\n     impling_types: Option<HirIdSet>,\n }\n \n+impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n+\n impl MissingDebugImplementations {\n     pub fn new() -> MissingDebugImplementations {\n         MissingDebugImplementations { impling_types: None }\n     }\n }\n \n-impl LintPass for MissingDebugImplementations {\n-    fn name(&self) -> &'static str {\n-        \"MissingDebugImplementations\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_DEBUG_IMPLEMENTATIONS)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.hir_id) {\n@@ -672,19 +601,10 @@ declare_lint! {\n     \"detects anonymous parameters\"\n }\n \n-/// Checks for use of anonymous parameters (RFC 1685).\n-#[derive(Copy, Clone)]\n-pub struct AnonymousParameters;\n-\n-impl LintPass for AnonymousParameters {\n-    fn name(&self) -> &'static str {\n-        \"AnonymousParameters\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(ANONYMOUS_PARAMETERS)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Checks for use of anonymous parameters (RFC 1685).\n+    AnonymousParameters => [ANONYMOUS_PARAMETERS]\n+);\n \n impl EarlyLintPass for AnonymousParameters {\n     fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::TraitItem) {\n@@ -736,6 +656,8 @@ pub struct DeprecatedAttr {\n     depr_attrs: Vec<&'static (&'static str, AttributeType, AttributeTemplate, AttributeGate)>,\n }\n \n+impl_lint_pass!(DeprecatedAttr => []);\n+\n impl DeprecatedAttr {\n     pub fn new() -> DeprecatedAttr {\n         DeprecatedAttr {\n@@ -744,16 +666,6 @@ impl DeprecatedAttr {\n     }\n }\n \n-impl LintPass for DeprecatedAttr {\n-    fn name(&self) -> &'static str {\n-        \"DeprecatedAttr\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!()\n-    }\n-}\n-\n impl EarlyLintPass for DeprecatedAttr {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         let name = attr.name_or_empty();\n@@ -786,18 +698,7 @@ declare_lint! {\n     \"detects doc comments that aren't used by rustdoc\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedDocComment;\n-\n-impl LintPass for UnusedDocComment {\n-    fn name(&self) -> &'static str {\n-        \"UnusedDocComment\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![UNUSED_DOC_COMMENTS]\n-    }\n-}\n+declare_lint_pass!(UnusedDocComment => [UNUSED_DOC_COMMENTS]);\n \n impl UnusedDocComment {\n     fn warn_if_doc(\n@@ -884,18 +785,7 @@ declare_lint! {\n     \"compiler plugin used as ordinary library in non-plugin crate\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct PluginAsLibrary;\n-\n-impl LintPass for PluginAsLibrary {\n-    fn name(&self) -> &'static str {\n-        \"PluginAsLibrary\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![PLUGIN_AS_LIBRARY]\n-    }\n-}\n+declare_lint_pass!(PluginAsLibrary => [PLUGIN_AS_LIBRARY]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n@@ -940,19 +830,7 @@ declare_lint! {\n     \"generic items must be mangled\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct InvalidNoMangleItems;\n-\n-impl LintPass for InvalidNoMangleItems {\n-    fn name(&self) -> &'static str {\n-        \"InvalidNoMangleItems\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NO_MANGLE_CONST_ITEMS,\n-                    NO_MANGLE_GENERIC_ITEMS)\n-    }\n-}\n+declare_lint_pass!(InvalidNoMangleItems => [NO_MANGLE_CONST_ITEMS, NO_MANGLE_GENERIC_ITEMS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n@@ -1011,32 +889,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     }\n }\n \n-#[derive(Clone, Copy)]\n-pub struct MutableTransmutes;\n-\n declare_lint! {\n     MUTABLE_TRANSMUTES,\n     Deny,\n     \"mutating transmuted &mut T from &T may cause undefined behavior\"\n }\n \n-impl LintPass for MutableTransmutes {\n-    fn name(&self) -> &'static str {\n-        \"MutableTransmutes\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MUTABLE_TRANSMUTES)\n-    }\n-}\n+declare_lint_pass!(MutableTransmutes => [MUTABLE_TRANSMUTES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n                    consider instead using an UnsafeCell\";\n-        match get_transmute_from_to(cx, expr) {\n+        match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.sty, &ty2.sty)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::MutMutable &&\n                    from_mt == hir::Mutability::MutImmutable {\n@@ -1049,7 +916,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         fn get_transmute_from_to<'a, 'tcx>\n             (cx: &LateContext<'a, 'tcx>,\n              expr: &hir::Expr)\n-             -> Option<(&'tcx ty::TyKind<'tcx>, &'tcx ty::TyKind<'tcx>)> {\n+             -> Option<(Ty<'tcx>, Ty<'tcx>)> {\n             let def = if let hir::ExprKind::Path(ref qpath) = expr.node {\n                 cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {\n@@ -1062,7 +929,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n                 let sig = cx.tables.node_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();\n-                return Some((&from.sty, &to.sty));\n+                return Some((from, to));\n             }\n             None\n         }\n@@ -1074,25 +941,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n     }\n }\n \n-/// Forbids using the `#[feature(...)]` attribute\n-#[derive(Copy, Clone)]\n-pub struct UnstableFeatures;\n-\n declare_lint! {\n     UNSTABLE_FEATURES,\n     Allow,\n     \"enabling unstable features (deprecated. do not use)\"\n }\n \n-impl LintPass for UnstableFeatures {\n-    fn name(&self) -> &'static str {\n-        \"UnstableFeatures\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNSTABLE_FEATURES)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Forbids using the `#[feature(...)]` attribute\n+    UnstableFeatures => [UNSTABLE_FEATURES]\n+);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     fn check_attribute(&mut self, ctx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n@@ -1106,24 +964,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     }\n }\n \n-/// Lint for unions that contain fields with possibly non-trivial destructors.\n-pub struct UnionsWithDropFields;\n-\n declare_lint! {\n     UNIONS_WITH_DROP_FIELDS,\n     Warn,\n     \"use of unions that contain fields with possibly non-trivial drop code\"\n }\n \n-impl LintPass for UnionsWithDropFields {\n-    fn name(&self) -> &'static str {\n-        \"UnionsWithDropFields\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNIONS_WITH_DROP_FIELDS)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Lint for unions that contain fields with possibly non-trivial destructors.\n+    UnionsWithDropFields => [UNIONS_WITH_DROP_FIELDS]\n+);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n@@ -1143,25 +993,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     }\n }\n \n-/// Lint for items marked `pub` that aren't reachable from other crates.\n-#[derive(Copy, Clone)]\n-pub struct UnreachablePub;\n-\n declare_lint! {\n     pub UNREACHABLE_PUB,\n     Allow,\n     \"`pub` items not reachable from crate root\"\n }\n \n-impl LintPass for UnreachablePub {\n-    fn name(&self) -> &'static str {\n-        \"UnreachablePub\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNREACHABLE_PUB)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Lint for items marked `pub` that aren't reachable from other crates.\n+    UnreachablePub => [UNREACHABLE_PUB]\n+);\n \n impl UnreachablePub {\n     fn perform_lint(&self, cx: &LateContext<'_, '_>, what: &str, id: hir::HirId,\n@@ -1197,7 +1038,6 @@ impl UnreachablePub {\n     }\n }\n \n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         self.perform_lint(cx, \"item\", item.hir_id, &item.vis, item.span, true);\n@@ -1217,27 +1057,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n     }\n }\n \n-/// Lint for trait and lifetime bounds in type aliases being mostly ignored.\n-/// They are relevant when using associated types, but otherwise neither checked\n-/// at definition site nor enforced at use site.\n-\n-pub struct TypeAliasBounds;\n-\n declare_lint! {\n     TYPE_ALIAS_BOUNDS,\n     Warn,\n     \"bounds in type aliases are not enforced\"\n }\n \n-impl LintPass for TypeAliasBounds {\n-    fn name(&self) -> &'static str {\n-        \"TypeAliasBounds\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TYPE_ALIAS_BOUNDS)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Lint for trait and lifetime bounds in type aliases being mostly ignored.\n+    /// They are relevant when using associated types, but otherwise neither checked\n+    /// at definition site nor enforced at use site.\n+    TypeAliasBounds => [TYPE_ALIAS_BOUNDS]\n+);\n \n impl TypeAliasBounds {\n     fn is_type_variable_assoc(qpath: &hir::QPath) -> bool {\n@@ -1331,21 +1162,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n     }\n }\n \n-/// Lint constants that are erroneous.\n-/// Without this lint, we might not get any diagnostic if the constant is\n-/// unused within this crate, even though downstream crates can't use it\n-/// without producing an error.\n-pub struct UnusedBrokenConst;\n-\n-impl LintPass for UnusedBrokenConst {\n-    fn name(&self) -> &'static str {\n-        \"UnusedBrokenConst\"\n-    }\n+declare_lint_pass!(\n+    /// Lint constants that are erroneous.\n+    /// Without this lint, we might not get any diagnostic if the constant is\n+    /// unused within this crate, even though downstream crates can't use it\n+    /// without producing an error.\n+    UnusedBrokenConst => []\n+);\n \n-    fn get_lints(&self) -> LintArray {\n-        lint_array!()\n-    }\n-}\n fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n     let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let is_static = cx.tcx.is_static(def_id).is_some();\n@@ -1378,25 +1202,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n     }\n }\n \n-/// Lint for trait and lifetime bounds that don't depend on type parameters\n-/// which either do nothing, or stop the item from being used.\n-pub struct TrivialConstraints;\n-\n declare_lint! {\n     TRIVIAL_BOUNDS,\n     Warn,\n     \"these bounds don't depend on an type parameters\"\n }\n \n-impl LintPass for TrivialConstraints {\n-    fn name(&self) -> &'static str {\n-        \"TrivialConstraints\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TRIVIAL_BOUNDS)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Lint for trait and lifetime bounds that don't depend on type parameters\n+    /// which either do nothing, or stop the item from being used.\n+    TrivialConstraints => [TRIVIAL_BOUNDS]\n+);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     fn check_item(\n@@ -1440,59 +1256,38 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n     }\n }\n \n-\n-/// Does nothing as a lint pass, but registers some `Lint`s\n-/// which are used by other parts of the compiler.\n-#[derive(Copy, Clone)]\n-pub struct SoftLints;\n-\n-impl LintPass for SoftLints {\n-    fn name(&self) -> &'static str {\n-        \"SoftLints\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(\n-            WHILE_TRUE,\n-            BOX_POINTERS,\n-            NON_SHORTHAND_FIELD_PATTERNS,\n-            UNSAFE_CODE,\n-            MISSING_DOCS,\n-            MISSING_COPY_IMPLEMENTATIONS,\n-            MISSING_DEBUG_IMPLEMENTATIONS,\n-            ANONYMOUS_PARAMETERS,\n-            UNUSED_DOC_COMMENTS,\n-            PLUGIN_AS_LIBRARY,\n-            NO_MANGLE_CONST_ITEMS,\n-            NO_MANGLE_GENERIC_ITEMS,\n-            MUTABLE_TRANSMUTES,\n-            UNSTABLE_FEATURES,\n-            UNIONS_WITH_DROP_FIELDS,\n-            UNREACHABLE_PUB,\n-            TYPE_ALIAS_BOUNDS,\n-            TRIVIAL_BOUNDS\n-        )\n-    }\n-}\n+declare_lint_pass!(\n+    /// Does nothing as a lint pass, but registers some `Lint`s\n+    /// which are used by other parts of the compiler.\n+    SoftLints => [\n+        WHILE_TRUE,\n+        BOX_POINTERS,\n+        NON_SHORTHAND_FIELD_PATTERNS,\n+        UNSAFE_CODE,\n+        MISSING_DOCS,\n+        MISSING_COPY_IMPLEMENTATIONS,\n+        MISSING_DEBUG_IMPLEMENTATIONS,\n+        ANONYMOUS_PARAMETERS,\n+        UNUSED_DOC_COMMENTS,\n+        PLUGIN_AS_LIBRARY,\n+        NO_MANGLE_CONST_ITEMS,\n+        NO_MANGLE_GENERIC_ITEMS,\n+        MUTABLE_TRANSMUTES,\n+        UNSTABLE_FEATURES,\n+        UNIONS_WITH_DROP_FIELDS,\n+        UNREACHABLE_PUB,\n+        TYPE_ALIAS_BOUNDS,\n+        TRIVIAL_BOUNDS\n+    ]\n+);\n \n declare_lint! {\n     pub ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n     Allow,\n     \"`...` range patterns are deprecated\"\n }\n \n-\n-pub struct EllipsisInclusiveRangePatterns;\n-\n-impl LintPass for EllipsisInclusiveRangePatterns {\n-    fn name(&self) -> &'static str {\n-        \"EllipsisInclusiveRangePatterns\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS)\n-    }\n-}\n+declare_lint_pass!(EllipsisInclusiveRangePatterns => [ELLIPSIS_INCLUSIVE_RANGE_PATTERNS]);\n \n impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n     fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &ast::Pat, visit_subpats: &mut bool) {\n@@ -1553,6 +1348,8 @@ pub struct UnnameableTestItems {\n     items_nameable: bool,\n }\n \n+impl_lint_pass!(UnnameableTestItems => [UNNAMEABLE_TEST_ITEMS]);\n+\n impl UnnameableTestItems {\n     pub fn new() -> Self {\n         Self {\n@@ -1562,16 +1359,6 @@ impl UnnameableTestItems {\n     }\n }\n \n-impl LintPass for UnnameableTestItems {\n-    fn name(&self) -> &'static str {\n-        \"UnnameableTestItems\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNAMEABLE_TEST_ITEMS)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if self.items_nameable {\n@@ -1605,19 +1392,10 @@ declare_lint! {\n     \"detects edition keywords being used as an identifier\"\n }\n \n-/// Check for uses of edition keywords used as an identifier.\n-#[derive(Copy, Clone)]\n-pub struct KeywordIdents;\n-\n-impl LintPass for KeywordIdents {\n-    fn name(&self) -> &'static str {\n-        \"KeywordIdents\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(KEYWORD_IDENTS)\n-    }\n-}\n+declare_lint_pass!(\n+    /// Check for uses of edition keywords used as an identifier.\n+    KeywordIdents => [KEYWORD_IDENTS]\n+);\n \n struct UnderMacro(bool);\n \n@@ -1740,18 +1518,7 @@ impl EarlyLintPass for KeywordIdents {\n     }\n }\n \n-\n-pub struct ExplicitOutlivesRequirements;\n-\n-impl LintPass for ExplicitOutlivesRequirements {\n-    fn name(&self) -> &'static str {\n-        \"ExplicitOutlivesRequirements\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array![EXPLICIT_OUTLIVES_REQUIREMENTS]\n-    }\n-}\n+declare_lint_pass!(ExplicitOutlivesRequirements => [EXPLICIT_OUTLIVES_REQUIREMENTS]);\n \n impl ExplicitOutlivesRequirements {\n     fn collect_outlives_bound_spans("}, {"sha": "7e77962a16e0bda1f154cc03135c4c4e582de9ac", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -20,6 +20,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #[macro_use]\n extern crate rustc;\n@@ -61,6 +62,7 @@ use nonstandard_style::*;\n use builtin::*;\n use types::*;\n use unused::*;\n+use rustc::lint::internal::*;\n \n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n@@ -488,3 +490,18 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     store.register_removed(\"bad_repr\",\n         \"replaced with a generic attribute input check\");\n }\n+\n+pub fn register_internals(store: &mut lint::LintStore, sess: Option<&Session>) {\n+    store.register_early_pass(sess, false, false, box DefaultHashTypes::new());\n+    store.register_late_pass(sess, false, false, false, box TyKindUsage);\n+    store.register_group(\n+        sess,\n+        false,\n+        \"internal\",\n+        None,\n+        vec![\n+            LintId::of(DEFAULT_HASH_TYPES),\n+            LintId::of(USAGE_OF_TY_TYKIND),\n+        ],\n+    );\n+}"}, {"sha": "1d8979f7d1c1bdc3fe494662ab9c4cf58bf056e3", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 4, "deletions": 37, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -38,6 +38,8 @@ declare_lint! {\n     \"types, variants, traits and type parameters should have camel case names\"\n }\n \n+declare_lint_pass!(NonCamelCaseTypes => [NON_CAMEL_CASE_TYPES]);\n+\n fn char_has_case(c: char) -> bool {\n     c.is_lowercase() || c.is_uppercase()\n }\n@@ -105,9 +107,6 @@ fn to_camel_case(s: &str) -> String {\n         .0\n }\n \n-#[derive(Copy, Clone)]\n-pub struct NonCamelCaseTypes;\n-\n impl NonCamelCaseTypes {\n     fn check_case(&self, cx: &EarlyContext<'_>, sort: &str, ident: &Ident) {\n         let name = &ident.name.as_str();\n@@ -126,16 +125,6 @@ impl NonCamelCaseTypes {\n     }\n }\n \n-impl LintPass for NonCamelCaseTypes {\n-    fn name(&self) -> &'static str {\n-        \"NonCamelCaseTypes\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_CAMEL_CASE_TYPES)\n-    }\n-}\n-\n impl EarlyLintPass for NonCamelCaseTypes {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         let has_repr_c = it.attrs\n@@ -173,8 +162,7 @@ declare_lint! {\n     \"variables, methods, functions, lifetime parameters and modules should have snake case names\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct NonSnakeCase;\n+declare_lint_pass!(NonSnakeCase => [NON_SNAKE_CASE]);\n \n impl NonSnakeCase {\n     fn to_snake_case(mut str: &str) -> String {\n@@ -256,16 +244,6 @@ impl NonSnakeCase {\n     }\n }\n \n-impl LintPass for NonSnakeCase {\n-    fn name(&self) -> &'static str {\n-        \"NonSnakeCase\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_SNAKE_CASE)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_mod(&mut self, cx: &LateContext<'_, '_>, _: &'tcx hir::Mod, _: Span, id: hir::HirId) {\n         if id != hir::CRATE_HIR_ID {\n@@ -387,8 +365,7 @@ declare_lint! {\n     \"static constants should have uppercase identifiers\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct NonUpperCaseGlobals;\n+declare_lint_pass!(NonUpperCaseGlobals => [NON_UPPER_CASE_GLOBALS]);\n \n impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n@@ -410,16 +387,6 @@ impl NonUpperCaseGlobals {\n     }\n }\n \n-impl LintPass for NonUpperCaseGlobals {\n-    fn name(&self) -> &'static str {\n-        \"NonUpperCaseGlobals\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(NON_UPPER_CASE_GLOBALS)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {"}, {"sha": "7423ce2e76010dec93e25676e38e6d99d0cd2738", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 16, "deletions": 50, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -49,23 +49,14 @@ pub struct TypeLimits {\n     negated_expr_id: hir::HirId,\n }\n \n+impl_lint_pass!(TypeLimits => [UNUSED_COMPARISONS, OVERFLOWING_LITERALS]);\n+\n impl TypeLimits {\n     pub fn new() -> TypeLimits {\n         TypeLimits { negated_expr_id: hir::DUMMY_HIR_ID }\n     }\n }\n \n-impl LintPass for TypeLimits {\n-    fn name(&self) -> &'static str {\n-        \"TypeLimits\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_COMPARISONS,\n-                    OVERFLOWING_LITERALS)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         match e.node {\n@@ -104,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                         report_bin_hex_error(\n                                             cx,\n                                             e,\n-                                            ty::Int(t),\n+                                            attr::IntType::SignedInt(t),\n                                             repr_str,\n                                             v,\n                                             negative,\n@@ -159,7 +150,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                 report_bin_hex_error(\n                                     cx,\n                                     e,\n-                                    ty::Uint(t),\n+                                    attr::IntType::UnsignedInt(t),\n                                     repr_str,\n                                     lit_val,\n                                     false,\n@@ -321,7 +312,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         //\n         // No suggestion for: `isize`, `usize`.\n         fn get_type_suggestion<'a>(\n-            t: &ty::TyKind<'_>,\n+            t: Ty<'_>,\n             val: u128,\n             negative: bool,\n         ) -> Option<String> {\n@@ -347,14 +338,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     }\n                 }\n             }\n-            match t {\n-                &ty::Int(i) => find_fit!(i, val, negative,\n+            match t.sty {\n+                ty::Int(i) => find_fit!(i, val, negative,\n                               I8 => [U8] => [I16, I32, I64, I128],\n                               I16 => [U16] => [I32, I64, I128],\n                               I32 => [U32] => [I64, I128],\n                               I64 => [U64] => [I128],\n                               I128 => [U128] => []),\n-                &ty::Uint(u) => find_fit!(u, val, negative,\n+                ty::Uint(u) => find_fit!(u, val, negative,\n                               U8 => [U8, U16, U32, U64, U128] => [],\n                               U16 => [U16, U32, U64, U128] => [],\n                               U32 => [U32, U64, U128] => [],\n@@ -367,25 +358,21 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         fn report_bin_hex_error(\n             cx: &LateContext<'_, '_>,\n             expr: &hir::Expr,\n-            ty: ty::TyKind<'_>,\n+            ty: attr::IntType,\n             repr_str: String,\n             val: u128,\n             negative: bool,\n         ) {\n+            let size = layout::Integer::from_attr(&cx.tcx, ty).size();\n             let (t, actually) = match ty {\n-                ty::Int(t) => {\n-                    let ity = attr::IntType::SignedInt(t);\n-                    let size = layout::Integer::from_attr(&cx.tcx, ity).size();\n+                attr::IntType::SignedInt(t) => {\n                     let actually = sign_extend(val, size) as i128;\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n-                ty::Uint(t) => {\n-                    let ity = attr::IntType::UnsignedInt(t);\n-                    let size = layout::Integer::from_attr(&cx.tcx, ity).size();\n+                attr::IntType::UnsignedInt(t) => {\n                     let actually = truncate(val, size);\n                     (format!(\"{:?}\", t), actually.to_string())\n                 }\n-                _ => bug!(),\n             };\n             let mut err = cx.struct_span_lint(\n                 OVERFLOWING_LITERALS,\n@@ -398,7 +385,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 repr_str, val, t, actually, t\n             ));\n             if let Some(sugg_ty) =\n-                get_type_suggestion(&cx.tables.node_type(expr.hir_id).sty, val, negative)\n+                get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n             {\n                 if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n                     let (sans_suffix, _) = repr_str.split_at(pos);\n@@ -424,6 +411,8 @@ declare_lint! {\n     \"proper use of libc types in foreign modules\"\n }\n \n+declare_lint_pass!(ImproperCTypes => [IMPROPER_CTYPES]);\n+\n struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n }\n@@ -793,19 +782,6 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-pub struct ImproperCTypes;\n-\n-impl LintPass for ImproperCTypes {\n-    fn name(&self) -> &'static str {\n-        \"ImproperCTypes\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(IMPROPER_CTYPES)\n-    }\n-}\n-\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n@@ -824,17 +800,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n     }\n }\n \n-pub struct VariantSizeDifferences;\n-\n-impl LintPass for VariantSizeDifferences {\n-    fn name(&self) -> &'static str {\n-        \"VariantSizeDifferences\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(VARIANT_SIZE_DIFFERENCES)\n-    }\n-}\n+declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {"}, {"sha": "d41d97f58bcbe0aea788c1acf62ad2110439ee57", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 72, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -32,18 +32,7 @@ declare_lint! {\n     \"unused result of an expression in a statement\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedResults;\n-\n-impl LintPass for UnusedResults {\n-    fn name(&self) -> &'static str {\n-        \"UnusedResults\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_MUST_USE, UNUSED_RESULTS)\n-    }\n-}\n+declare_lint_pass!(UnusedResults => [UNUSED_MUST_USE, UNUSED_RESULTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n@@ -203,18 +192,7 @@ declare_lint! {\n     \"path statements with no effect\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct PathStatements;\n-\n-impl LintPass for PathStatements {\n-    fn name(&self) -> &'static str {\n-        \"PathStatements\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(PATH_STATEMENTS)\n-    }\n-}\n+declare_lint_pass!(PathStatements => [PATH_STATEMENTS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n@@ -232,18 +210,7 @@ declare_lint! {\n     \"detects attributes that were not used by the compiler\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedAttributes;\n-\n-impl LintPass for UnusedAttributes {\n-    fn name(&self) -> &'static str {\n-        \"UnusedAttributes\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ATTRIBUTES)\n-    }\n-}\n+declare_lint_pass!(UnusedAttributes => [UNUSED_ATTRIBUTES]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n@@ -305,8 +272,7 @@ declare_lint! {\n     \"`if`, `match`, `while` and `return` do not need parentheses\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedParens;\n+declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n \n impl UnusedParens {\n     fn check_unused_parens_expr(&self,\n@@ -383,16 +349,6 @@ impl UnusedParens {\n     }\n }\n \n-impl LintPass for UnusedParens {\n-    fn name(&self) -> &'static str {\n-        \"UnusedParens\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_PARENS)\n-    }\n-}\n-\n impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n@@ -465,8 +421,7 @@ declare_lint! {\n     \"unnecessary braces around an imported item\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedImportBraces;\n+declare_lint_pass!(UnusedImportBraces => [UNUSED_IMPORT_BRACES]);\n \n impl UnusedImportBraces {\n     fn check_use_tree(&self, cx: &EarlyContext<'_>, use_tree: &ast::UseTree, item: &ast::Item) {\n@@ -505,16 +460,6 @@ impl UnusedImportBraces {\n     }\n }\n \n-impl LintPass for UnusedImportBraces {\n-    fn name(&self) -> &'static str {\n-        \"UnusedImportBraces\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_IMPORT_BRACES)\n-    }\n-}\n-\n impl EarlyLintPass for UnusedImportBraces {\n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         if let ast::ItemKind::Use(ref use_tree) = item.node {\n@@ -529,18 +474,7 @@ declare_lint! {\n     \"detects unnecessary allocations that can be eliminated\"\n }\n \n-#[derive(Copy, Clone)]\n-pub struct UnusedAllocation;\n-\n-impl LintPass for UnusedAllocation {\n-    fn name(&self) -> &'static str {\n-        \"UnusedAllocation\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_ALLOCATION)\n-    }\n-}\n+declare_lint_pass!(UnusedAllocation => [UNUSED_ALLOCATION]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {"}, {"sha": "4078171733fc3fd5862ae3028743f835734cee33", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -14,6 +14,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n extern crate libc;\n #[allow(unused_extern_crates)]"}, {"sha": "01c06739e290363546343253a6d12b89ab89065d", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -223,7 +223,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     Some(ref name) => format!(\"`{}`\", name),\n                     None => \"value\".to_owned(),\n                 };\n-                if let ty::TyKind::Param(param_ty) = ty.sty {\n+                if let ty::Param(param_ty) = ty.sty {\n                     let tcx = self.infcx.tcx;\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let def_id = generics.type_param(&param_ty, tcx).def_id;\n@@ -1529,7 +1529,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n                 literal: ty::Const {\n-                    ty: &ty::TyS { sty: ty::TyKind::FnDef(id, _), ..  },\n+                    ty: &ty::TyS { sty: ty::FnDef(id, _), ..  },\n                     ..\n                 },\n                 ..\n@@ -1547,7 +1547,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 };\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n-                if let ty::TyKind::Closure(did, _) = self.mir.local_decls[closure].ty.sty {\n+                if let ty::Closure(did, _) = self.mir.local_decls[closure].ty.sty {\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                     if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -1570,7 +1570,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n-            if let ty::TyKind::Closure(did, _) = self.mir.local_decls[target].ty.sty {\n+            if let ty::Closure(did, _) = self.mir.local_decls[target].ty.sty {\n                 let hir_id = self.infcx.tcx.hir().as_local_hir_id(did).unwrap();\n \n                 if let Some((span, name)) = self.infcx.tcx.typeck_tables_of(did)\n@@ -1919,7 +1919,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             } else {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n                 match ty.sty {\n-                    ty::TyKind::FnDef(_, _) | ty::TyKind::FnPtr(_) => self.annotate_fn_sig(\n+                    ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n                         self.mir_def_id,\n                         self.infcx.tcx.fn_sig(self.mir_def_id),\n                     ),\n@@ -2164,12 +2164,12 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //    anything.\n         let return_ty = sig.output();\n         match return_ty.skip_binder().sty {\n-            ty::TyKind::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n+            ty::Ref(return_region, _, _) if return_region.has_name() && !is_closure => {\n                 // This is case 1 from above, return type is a named reference so we need to\n                 // search for relevant arguments.\n                 let mut arguments = Vec::new();\n                 for (index, argument) in sig.inputs().skip_binder().iter().enumerate() {\n-                    if let ty::TyKind::Ref(argument_region, _, _) = argument.sty {\n+                    if let ty::Ref(argument_region, _, _) = argument.sty {\n                         if argument_region == return_region {\n                             // Need to use the `rustc::ty` types to compare against the\n                             // `return_region`. Then use the `rustc::hir` type to get only\n@@ -2206,7 +2206,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     return_span,\n                 })\n             }\n-            ty::TyKind::Ref(_, _, _) if is_closure => {\n+            ty::Ref(_, _, _) if is_closure => {\n                 // This is case 2 from above but only for closures, return type is anonymous\n                 // reference so we select\n                 // the first argument.\n@@ -2215,9 +2215,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // Closure arguments are wrapped in a tuple, so we need to get the first\n                 // from that.\n-                if let ty::TyKind::Tuple(elems) = argument_ty.sty {\n+                if let ty::Tuple(elems) = argument_ty.sty {\n                     let argument_ty = elems.first()?;\n-                    if let ty::TyKind::Ref(_, _, _) = argument_ty.sty {\n+                    if let ty::Ref(_, _, _) = argument_ty.sty {\n                         return Some(AnnotatedBorrowFnSignature::Closure {\n                             argument_ty,\n                             argument_span,\n@@ -2227,7 +2227,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 None\n             }\n-            ty::TyKind::Ref(_, _, _) => {\n+            ty::Ref(_, _, _) => {\n                 // This is also case 2 from above but for functions, return type is still an\n                 // anonymous reference so we select the first argument.\n                 let argument_span = fn_decl.inputs.first()?.span;\n@@ -2238,7 +2238,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 // We expect the first argument to be a reference.\n                 match argument_ty.sty {\n-                    ty::TyKind::Ref(_, _, _) => {}\n+                    ty::Ref(_, _, _) => {}\n                     _ => return None,\n                 }\n \n@@ -2366,8 +2366,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // this by hooking into the pretty printer and telling it to label the\n         // lifetimes without names with the value `'0`.\n         match ty.sty {\n-            ty::TyKind::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n-            | ty::TyKind::Ref(\n+            ty::Ref(ty::RegionKind::ReLateBound(_, br), _, _)\n+            | ty::Ref(\n                 ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n@@ -2386,7 +2386,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut printer = ty::print::FmtPrinter::new(self.infcx.tcx, &mut s, Namespace::TypeNS);\n \n         let region = match ty.sty {\n-            ty::TyKind::Ref(region, _, _) => {\n+            ty::Ref(region, _, _) => {\n                 match region {\n                     ty::RegionKind::ReLateBound(_, br)\n                     | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {"}, {"sha": "bf297ae0debf0b4b212565db140fe9af80d57cb7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1741,7 +1741,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // no move out from an earlier location) then this is an attempt at initialization\n                 // of the union - we should error in that case.\n                 let tcx = this.infcx.tcx;\n-                if let ty::TyKind::Adt(def, _) = base.ty(this.mir, tcx).ty.sty {\n+                if let ty::Adt(def, _) = base.ty(this.mir, tcx).ty.sty {\n                     if def.is_union() {\n                         if this.move_data.path_map[mpi].iter().any(|moi| {\n                             this.move_data.moves[*moi].source.is_predecessor_of("}, {"sha": "7efe1d83c2e5fc119e1491e3f615e0ec4a127a8f", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -532,7 +532,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     if let StatementKind::Assign(_, box Rvalue::Ref(_, _, source)) = &stmt.kind {\n                         let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n-                            ty::TyKind::Ref(_, ty, _) => ty,\n+                            ty::Ref(_, ty, _) => ty,\n                             _ => ty,\n                         };\n                         debug!(\"borrowed_content_source: ty={:?}\", ty);\n@@ -557,7 +557,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n                         let ty = source.ty(self.mir, self.infcx.tcx).ty;\n                         let ty = match ty.sty {\n-                            ty::TyKind::Ref(_, ty, _) => ty,\n+                            ty::Ref(_, ty, _) => ty,\n                             _ => ty,\n                         };\n                         debug!(\"borrowed_content_source: ty={:?}\", ty);"}, {"sha": "b780511315d81a021a7041fc7d1ad169f7f817f8", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -5,7 +5,7 @@ use rustc::mir::{\n     Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind,\n };\n use rustc::mir::{Terminator, TerminatorKind};\n-use rustc::ty::{self, Const, DefIdTree, TyS, TyKind, TyCtxt};\n+use rustc::ty::{self, Const, DefIdTree, TyS, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n use syntax_pos::symbol::keywords;\n@@ -261,7 +261,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             // Otherwise, check if the name is the self kewyord - in which case\n                             // we have an explicit self. Do the same thing in this case and check\n                             // for a `self: &mut Self` to suggest removing the `&mut`.\n-                            if let ty::TyKind::Ref(\n+                            if let ty::Ref(\n                                 _, _, hir::Mutability::MutMutable\n                             ) = local_decl.ty.sty {\n                                 true\n@@ -476,7 +476,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                                     func: Operand::Constant(box Constant {\n                                         literal: Const {\n                                             ty: &TyS {\n-                                                sty: TyKind::FnDef(id, substs),\n+                                                sty: ty::FnDef(id, substs),\n                                                 ..\n                                             },\n                                             ..\n@@ -633,8 +633,8 @@ fn annotate_struct_field(\n     field: &mir::Field,\n ) -> Option<(Span, String)> {\n     // Expect our local to be a reference to a struct of some kind.\n-    if let ty::TyKind::Ref(_, ty, _) = ty.sty {\n-        if let ty::TyKind::Adt(def, _) = ty.sty {\n+    if let ty::Ref(_, ty, _) = ty.sty {\n+        if let ty::Adt(def, _) = ty.sty {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n             let hir_id = tcx.hir().as_local_hir_id(field.did)?;"}, {"sha": "e30938bc32659397f136593ebfd597cc78523894", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -589,7 +589,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                 // Check the type for a trait object.\n                                 return match ty.sty {\n                                     // `&dyn Trait`\n-                                    ty::TyKind::Ref(_, ty, _) if ty.is_trait() => true,\n+                                    ty::Ref(_, ty, _) if ty.is_trait() => true,\n                                     // `Box<dyn Trait>`\n                                     _ if ty.is_box() && ty.boxed_ty().is_trait() => true,\n                                     // `dyn Trait`"}, {"sha": "917e383cae82783b06f571047c206b2390691ca6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -583,7 +583,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             (self.to_error_region(fr), self.to_error_region(outlived_fr))\n         {\n             if let Some(ty::TyS {\n-                sty: ty::TyKind::Opaque(did, substs),\n+                sty: ty::Opaque(did, substs),\n                 ..\n             }) = infcx\n                 .tcx"}, {"sha": "ec5637d17072d4840148ee91990b5809ec71b015", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -39,7 +39,7 @@ use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef, UnpackedKind, UserSubsts};\n use rustc::ty::{\n-    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserType,\n+    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, UserType,\n     CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,\n     UserTypeAnnotationIndex,\n };\n@@ -746,7 +746,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let (variant, substs) = match base_ty {\n             PlaceTy { ty, variant_index: Some(variant_index) } => {\n                 match ty.sty {\n-                    ty::TyKind::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n+                    ty::Adt(adt_def, substs) => (&adt_def.variants[variant_index], substs),\n                     _ => bug!(\"can't have downcast of non-adt type\"),\n                 }\n             }\n@@ -1136,7 +1136,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         category: ConstraintCategory,\n     ) -> Fallible<()> {\n         if let Err(terr) = self.sub_types(sub, sup, locations, category) {\n-            if let TyKind::Opaque(..) = sup.sty {\n+            if let ty::Opaque(..) = sup.sty {\n                 // When you have `let x: impl Foo = ...` in a closure,\n                 // the resulting inferend values are stored with the\n                 // def-id of the base function.\n@@ -1389,7 +1389,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             } => {\n                 let place_type = place.ty(mir, tcx).ty;\n                 let adt = match place_type.sty {\n-                    TyKind::Adt(adt, _) if adt.is_enum() => adt,\n+                    ty::Adt(adt, _) if adt.is_enum() => adt,\n                     _ => {\n                         span_bug!(\n                             stmt.source_info.span,"}, {"sha": "2471c01e3f3d0f4f20aef0439a95b56cc847d306", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -425,7 +425,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 base,\n                 elem: ProjectionElem::Field(_, _),\n             }) if match base.ty(self.builder.mir, self.builder.tcx).ty.sty {\n-                    ty::TyKind::Adt(def, _) if def.is_union() => true,\n+                    ty::Adt(def, _) if def.is_union() => true,\n                     _ => false,\n             } => base,\n             // Otherwise, lookup the place."}, {"sha": "a9c521f59a96c4aa39dfa96d76cbebe30e375d65", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1754,7 +1754,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n                     let (opt_ptr, n, ty) = match value.ty.sty {\n-                        ty::TyKind::Array(t, n) => {\n+                        ty::Array(t, n) => {\n                             match value.val {\n                                 ConstValue::ByRef(ptr, alloc) => (\n                                     Some((ptr, alloc)),\n@@ -1767,7 +1767,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                                 ),\n                             }\n                         },\n-                        ty::TyKind::Slice(t) => {\n+                        ty::Slice(t) => {\n                             match value.val {\n                                 ConstValue::Slice(ptr, n) => (\n                                     ptr.to_ptr().ok().map(|ptr| ("}, {"sha": "7ded973701edcd37724211dc6112778a076703b8", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -10,7 +10,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::region;\n use rustc::session::Session;\n-use rustc::ty::{self, Ty, TyCtxt, TyKind};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::lint;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n@@ -481,7 +481,7 @@ fn check_exhaustive<'p, 'a: 'p, 'tcx: 'a>(\n             }\n             let patterns = witnesses.iter().map(|p| (**p).clone()).collect::<Vec<Pattern<'_>>>();\n             if patterns.len() < 4 {\n-                for sp in maybe_point_at_variant(cx, &scrut_ty.sty, patterns.as_slice()) {\n+                for sp in maybe_point_at_variant(cx, scrut_ty, patterns.as_slice()) {\n                     err.span_label(sp, \"not covered\");\n                 }\n             }\n@@ -498,11 +498,11 @@ fn check_exhaustive<'p, 'a: 'p, 'tcx: 'a>(\n \n fn maybe_point_at_variant(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-    sty: &TyKind<'tcx>,\n+    ty: Ty<'tcx>,\n     patterns: &[Pattern<'_>],\n ) -> Vec<Span> {\n     let mut covered = vec![];\n-    if let ty::Adt(def, _) = sty {\n+    if let ty::Adt(def, _) = ty.sty {\n         // Don't point at variants that have already been covered due to other patterns to avoid\n         // visual clutter\n         for pattern in patterns {\n@@ -518,15 +518,15 @@ fn maybe_point_at_variant(\n                         .map(|field_pattern| field_pattern.pattern.clone())\n                         .collect::<Vec<_>>();\n                     covered.extend(\n-                        maybe_point_at_variant(cx, sty, subpatterns.as_slice()),\n+                        maybe_point_at_variant(cx, ty, subpatterns.as_slice()),\n                     );\n                 }\n             }\n             if let PatternKind::Leaf { subpatterns } = pk {\n                 let subpatterns = subpatterns.iter()\n                     .map(|field_pattern| field_pattern.pattern.clone())\n                     .collect::<Vec<_>>();\n-                covered.extend(maybe_point_at_variant(cx, sty, subpatterns.as_slice()));\n+                covered.extend(maybe_point_at_variant(cx, ty, subpatterns.as_slice()));\n             }\n         }\n     }"}, {"sha": "deeed9a0b9846ecc4892e66fc5de96f3c8550ea0", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -28,6 +28,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n #![allow(explicit_outlives_requirements)]\n \n #[macro_use] extern crate log;"}, {"sha": "572f7133cad84eb48190563dba2c3e491d97d006", "filename": "src/librustc_mir/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flints.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc::mir::{self, Mir, TerminatorKind};\n-use rustc::ty::{AssociatedItem, AssociatedItemContainer, Instance, TyCtxt, TyKind};\n+use rustc::ty::{self, AssociatedItem, AssociatedItemContainer, Instance, TyCtxt};\n use rustc::ty::subst::InternalSubsts;\n \n pub fn check(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -86,7 +86,7 @@ fn check_fn_for_unconditional_recursion(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 TerminatorKind::Call { ref func, .. } => {\n                     let func_ty = func.ty(mir, tcx);\n \n-                    if let TyKind::FnDef(fn_def_id, substs) = func_ty.sty {\n+                    if let ty::FnDef(fn_def_id, substs) = func_ty.sty {\n                         let (call_fn_id, call_substs) =\n                             if let Some(instance) = Instance::resolve(tcx,\n                                                                         param_env,"}, {"sha": "8187a81f0edab4c3f1731ea423f9d82189956b07", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -2,7 +2,7 @@\n \n use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::visit::{MutVisitor, Visitor};\n-use rustc::ty::{TyCtxt, TyKind};\n+use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n use std::mem;\n@@ -90,7 +90,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for OptimizationFinder<'b, 'a, 'tcx> {\n \n         if let Rvalue::Len(ref place) = *rvalue {\n             let place_ty = place.ty(&self.mir.local_decls, self.tcx).ty;\n-            if let TyKind::Array(_, len) = place_ty.sty {\n+            if let ty::Array(_, len) = place_ty.sty {\n                 let span = self.mir.source_info(location).span;\n                 let ty = self.tcx.types.usize;\n                 let constant = Constant { span, ty, literal: len, user_ty: None };"}, {"sha": "fd9d6bb5760b1b0646cf97ece7cda0594b9d9a1a", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -3,7 +3,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::LangItem;\n use rustc::mir::*;\n-use rustc::ty::{List, Ty, TyCtxt, TyKind};\n+use rustc::ty::{self, List, Ty, TyCtxt};\n use rustc_data_structures::indexed_vec::{Idx};\n use crate::transform::{MirPass, MirSource};\n \n@@ -183,8 +183,8 @@ impl RhsKind {\n \n fn sign_of_128bit(ty: Ty<'_>) -> Option<bool> {\n     match ty.sty {\n-        TyKind::Int(syntax::ast::IntTy::I128) => Some(true),\n-        TyKind::Uint(syntax::ast::UintTy::U128) => Some(false),\n+        ty::Int(syntax::ast::IntTy::I128) => Some(true),\n+        ty::Uint(syntax::ast::UintTy::U128) => Some(false),\n         _ => None,\n     }\n }"}, {"sha": "20442a4a566ece72d545793798884de7118bf043", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -12,6 +12,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #[macro_use]\n extern crate rustc;"}, {"sha": "9a8970b2935e091540478ad025818ec5ec88e50e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(nll)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "5216156c0cab81d14b0ff2cbdfb40c28edc8cae9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -8,6 +8,7 @@\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n pub use rustc::hir::def::{Namespace, PerNS};\n "}, {"sha": "a363fe114189158816e228e893e9fe07573903c7", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -2,6 +2,7 @@\n #![feature(custom_attribute)]\n #![feature(nll)]\n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n #![allow(unused_attributes)]\n \n #![recursion_limit=\"256\"]"}, {"sha": "f1812c20dccde3bab91d7005aa09ef4bb46d5493", "filename": "src/librustc_target/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_target%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_target%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -16,6 +16,7 @@\n #![feature(step_trait)]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #[macro_use] extern crate log;\n "}, {"sha": "bc034e1fb16278fd6d0836a67ea141c14fbc072f", "filename": "src/librustc_traits/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_traits%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_traits%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -2,6 +2,7 @@\n //! the guts are broken up into modules; see the comments in those modules.\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(crate_visibility_modifier)]\n #![feature(in_band_lifetimes)]"}, {"sha": "8805dade40e4c2a5d2a1fadd5c8caf0f4a9236e9", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -99,11 +99,6 @@ enum GenericArgPosition {\n     MethodCall,\n }\n \n-/// Dummy type used for the `Self` of a `TraitRef` created for converting\n-/// a trait object, and which gets removed in `ExistentialTraitRef`.\n-/// This type must not appear anywhere in other converted types.\n-const TRAIT_OBJECT_DUMMY_SELF: ty::TyKind<'static> = ty::Infer(ty::FreshTy(0));\n-\n impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     pub fn ast_region_to_region(&self,\n         lifetime: &hir::Lifetime,\n@@ -595,7 +590,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             infer_types,\n         );\n \n-        let is_object = self_ty.map_or(false, |ty| ty.sty == TRAIT_OBJECT_DUMMY_SELF);\n+        let is_object = self_ty.map_or(false, |ty| {\n+            ty == self.tcx().types.trait_object_dummy_self\n+        });\n         let default_needs_object_self = |param: &ty::GenericParamDef| {\n             if let GenericParamDefKind::Type { has_default, .. } = param.kind {\n                 if is_object && has_default {\n@@ -956,10 +953,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n \n     /// Transform a `PolyTraitRef` into a `PolyExistentialTraitRef` by\n-    /// removing the dummy `Self` type (`TRAIT_OBJECT_DUMMY_SELF`).\n+    /// removing the dummy `Self` type (`trait_object_dummy_self`).\n     fn trait_ref_to_existential(&self, trait_ref: ty::TraitRef<'tcx>)\n                                 -> ty::ExistentialTraitRef<'tcx> {\n-        if trait_ref.self_ty().sty != TRAIT_OBJECT_DUMMY_SELF {\n+        if trait_ref.self_ty() != self.tcx().types.trait_object_dummy_self {\n             bug!(\"trait_ref_to_existential called on {:?} with non-dummy Self\", trait_ref);\n         }\n         ty::ExistentialTraitRef::erase_self_ty(self.tcx(), trait_ref)\n@@ -980,7 +977,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         }\n \n         let mut projection_bounds = Vec::new();\n-        let dummy_self = tcx.mk_ty(TRAIT_OBJECT_DUMMY_SELF);\n+        let dummy_self = self.tcx().types.trait_object_dummy_self;\n         let (principal, potential_assoc_types) = self.instantiate_poly_trait_ref(\n             &trait_bounds[0],\n             dummy_self,\n@@ -1030,7 +1027,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }\n                 ty::Predicate::Projection(pred) => {\n                     // A `Self` within the original bound will be substituted with a\n-                    // `TRAIT_OBJECT_DUMMY_SELF`, so check for that.\n+                    // `trait_object_dummy_self`, so check for that.\n                     let references_self =\n                         pred.skip_binder().ty.walk().any(|t| t == dummy_self);\n \n@@ -1130,7 +1127,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             err.emit();\n         }\n \n-        // Erase the `dummy_self` (`TRAIT_OBJECT_DUMMY_SELF`) used above.\n+        // Erase the `dummy_self` (`trait_object_dummy_self`) used above.\n         let existential_principal = principal.map_bound(|trait_ref| {\n             self.trait_ref_to_existential(trait_ref)\n         });"}, {"sha": "d108e7c3107afdde3fa02294f7979fa5e63d21b6", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -3,7 +3,7 @@ use crate::constrained_generic_params::{identify_constrained_generic_params, Par\n \n use crate::hir::def_id::DefId;\n use rustc::traits::{self, ObligationCauseCode};\n-use rustc::ty::{self, Lift, Ty, TyCtxt, TyKind, GenericParamDefKind, TypeFoldable, ToPredicate};\n+use rustc::ty::{self, Lift, Ty, TyCtxt, GenericParamDefKind, TypeFoldable, ToPredicate};\n use rustc::ty::subst::{Subst, InternalSubsts};\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::ConstValue;\n@@ -354,7 +354,7 @@ fn check_item_type<'a, 'tcx>(\n \n         let mut forbid_unsized = true;\n         if allow_foreign_ty {\n-            if let TyKind::Foreign(_) = fcx.tcx.struct_tail(item_ty).sty {\n+            if let ty::Foreign(_) = fcx.tcx.struct_tail(item_ty).sty {\n                 forbid_unsized = false;\n             }\n         }"}, {"sha": "4a7b1e67366e8359a389e7fa83a1504bb2a24776", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -71,6 +71,7 @@ This API is completely unstable and subject to change.\n #![recursion_limit=\"256\"]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n #![allow(explicit_outlives_requirements)]\n \n #[macro_use] extern crate log;"}, {"sha": "6cb937d9216ac857b3773c2a27ea1ea9457dea1d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -1,4 +1,5 @@\n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"https://play.rust-lang.org/\")]"}, {"sha": "9905b981395c0d886c7a50691dbaf89a60a670e6", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -8,6 +8,7 @@\n        test(attr(deny(warnings))))]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(crate_visibility_modifier)]\n #![feature(label_break_value)]"}, {"sha": "ee0b86963f31dcdc9f7da4b3a298b0b82ed6f8e1", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -3,6 +3,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(in_band_lifetimes)]\n #![feature(proc_macro_diagnostic)]"}, {"sha": "db1543ff13f7e3a678bd5564f245815677d8e987", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -7,6 +7,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![deny(rust_2018_idioms)]\n+#![cfg_attr(not(stage0), deny(internal))]\n \n #![feature(const_fn)]\n #![feature(crate_visibility_modifier)]"}, {"sha": "76d0906f97c9a85e9179ff5e0b493b7dfc4104d5", "filename": "src/test/run-pass-fulldeps/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fissue-40001-plugin.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -26,21 +26,14 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_attribute(\"whitelisted_attr\".to_string(), Whitelisted);\n }\n \n-declare_lint!(MISSING_WHITELISTED_ATTR, Deny,\n-              \"Checks for missing `whitelisted_attr` attribute\");\n-\n-struct MissingWhitelistedAttrPass;\n-\n-impl LintPass for MissingWhitelistedAttrPass {\n-    fn name(&self) -> &'static str {\n-        \"MissingWhitelistedAttrPass\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(MISSING_WHITELISTED_ATTR)\n-    }\n+declare_lint! {\n+    MISSING_WHITELISTED_ATTR,\n+    Deny,\n+    \"Checks for missing `whitelisted_attr` attribute\"\n }\n \n+declare_lint_pass!(MissingWhitelistedAttrPass => [MISSING_WHITELISTED_ATTR]);\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n     fn check_fn(&mut self,\n                 cx: &LateContext<'a, 'tcx>,"}, {"sha": "e8f1d2eedf559cc44979d2e4f8ab356b6d2b4fe3", "filename": "src/test/ui-fulldeps/auxiliary/lint-for-crate.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-for-crate.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -12,20 +12,14 @@ use rustc_plugin::Registry;\n use rustc::hir;\n use syntax::attr;\n \n-declare_lint!(CRATE_NOT_OKAY, Warn, \"crate not marked with #![crate_okay]\");\n-\n-struct Pass;\n-\n-impl LintPass for Pass {\n-    fn name(&self) -> &'static str {\n-        \"Pass\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(CRATE_NOT_OKAY)\n-    }\n+declare_lint! {\n+    CRATE_NOT_OKAY,\n+    Warn,\n+    \"crate not marked with #![crate_okay]\"\n }\n \n+declare_lint_pass!(Pass => [CRATE_NOT_OKAY]);\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n         if !attr::contains_name(&krate.attrs, \"crate_okay\") {"}, {"sha": "941fe25b14c70172e094bdf2acde7fe7a1aeb01f", "filename": "src/test/ui-fulldeps/auxiliary/lint-group-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-group-plugin-test.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -16,17 +16,7 @@ declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n declare_lint!(PLEASE_LINT, Warn, \"Warn about items named 'pleaselintme'\");\n \n-struct Pass;\n-\n-impl LintPass for Pass {\n-    fn name(&self) -> &'static str {\n-        \"Pass\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT, PLEASE_LINT)\n-    }\n-}\n+declare_lint_pass!(Pass => [TEST_LINT, PLEASE_LINT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {"}, {"sha": "1d204e7bfcffabaf87f413df39960095b286f096", "filename": "src/test/ui-fulldeps/auxiliary/lint-plugin-test.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-plugin-test.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -16,17 +16,7 @@ use rustc_plugin::Registry;\n use syntax::ast;\n declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n-struct Pass;\n-\n-impl LintPass for Pass {\n-    fn name(&self) -> &'static str {\n-        \"Pass\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT)\n-    }\n-}\n+declare_lint_pass!(Pass => [TEST_LINT]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {"}, {"sha": "182d2899da1853ee4d51c4e2e1ca7cb85d876399", "filename": "src/test/ui-fulldeps/auxiliary/lint-tool-test.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint-tool-test.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -19,17 +19,7 @@ declare_tool_lint!(\n     Warn, \"Warn about other stuff\"\n );\n \n-struct Pass;\n-\n-impl LintPass for Pass {\n-    fn name(&self) -> &'static str {\n-        \"Pass\"\n-    }\n-\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(TEST_LINT, TEST_GROUP)\n-    }\n-}\n+declare_lint_pass!(Pass => [TEST_LINT, TEST_GROUP]);\n \n impl EarlyLintPass for Pass {\n     fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {"}, {"sha": "3264099c876d0bbf178be2de6a1764078e1fa9ea", "filename": "src/test/ui-fulldeps/internal-lints/default_hash_types.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -Z unstable-options\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc_data_structures;\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use std::collections::{HashMap, HashSet};\n+\n+#[deny(default_hash_types)]\n+fn main() {\n+    let _map: HashMap<String, String> = HashMap::default();\n+    //~^ ERROR Prefer FxHashMap over HashMap, it has better performance\n+    //~^^ ERROR Prefer FxHashMap over HashMap, it has better performance\n+    let _set: HashSet<String> = HashSet::default();\n+    //~^ ERROR Prefer FxHashSet over HashSet, it has better performance\n+    //~^^ ERROR Prefer FxHashSet over HashSet, it has better performance\n+\n+    // test that the lint doesn't also match the Fx variants themselves\n+    let _fx_map: FxHashMap<String, String> = FxHashMap::default();\n+    let _fx_set: FxHashSet<String> = FxHashSet::default();\n+}"}, {"sha": "64f322cb0c165b13ddfe34d7babb3019b3e636f0", "filename": "src/test/ui-fulldeps/internal-lints/default_hash_types.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdefault_hash_types.stderr?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -0,0 +1,39 @@\n+error: Prefer FxHashMap over HashMap, it has better performance\n+  --> $DIR/default_hash_types.rs:12:15\n+   |\n+LL |     let _map: HashMap<String, String> = HashMap::default();\n+   |               ^^^^^^^ help: use: `FxHashMap`\n+   |\n+note: lint level defined here\n+  --> $DIR/default_hash_types.rs:10:8\n+   |\n+LL | #[deny(default_hash_types)]\n+   |        ^^^^^^^^^^^^^^^^^^\n+   = note: a `use rustc_data_structures::fx::FxHashMap` may be necessary\n+\n+error: Prefer FxHashMap over HashMap, it has better performance\n+  --> $DIR/default_hash_types.rs:12:41\n+   |\n+LL |     let _map: HashMap<String, String> = HashMap::default();\n+   |                                         ^^^^^^^ help: use: `FxHashMap`\n+   |\n+   = note: a `use rustc_data_structures::fx::FxHashMap` may be necessary\n+\n+error: Prefer FxHashSet over HashSet, it has better performance\n+  --> $DIR/default_hash_types.rs:15:15\n+   |\n+LL |     let _set: HashSet<String> = HashSet::default();\n+   |               ^^^^^^^ help: use: `FxHashSet`\n+   |\n+   = note: a `use rustc_data_structures::fx::FxHashSet` may be necessary\n+\n+error: Prefer FxHashSet over HashSet, it has better performance\n+  --> $DIR/default_hash_types.rs:15:33\n+   |\n+LL |     let _set: HashSet<String> = HashSet::default();\n+   |                                 ^^^^^^^ help: use: `FxHashSet`\n+   |\n+   = note: a `use rustc_data_structures::fx::FxHashSet` may be necessary\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "dba0db69b7f39543ca46f2216d97dc5022d7b8a3", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -0,0 +1,49 @@\n+// compile-flags: -Z unstable-options\n+\n+#![feature(rustc_private)]\n+\n+extern crate rustc;\n+\n+use rustc::ty::{self, Ty, TyKind};\n+\n+#[deny(usage_of_ty_tykind)]\n+fn main() {\n+    let sty = TyKind::Bool; //~ ERROR usage of `ty::TyKind::<kind>`\n+\n+    match sty {\n+        TyKind::Bool => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Char => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Int(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Uint(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Float(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Adt(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Foreign(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Str => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Array(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Slice(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::RawPtr(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Ref(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::FnDef(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::FnPtr(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Dynamic(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Closure(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Generator(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::GeneratorWitness(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Never => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Tuple(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Projection(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::UnnormalizedProjection(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Opaque(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Param(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Bound(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Placeholder(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Infer(..) => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+        TyKind::Error => (), //~ ERROR usage of `ty::TyKind::<kind>`\n+    }\n+\n+    if let ty::Int(int_ty) = sty {}\n+\n+    if let TyKind::Int(int_ty) = sty {} //~ ERROR usage of `ty::TyKind::<kind>`\n+\n+    fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {} //~ ERROR usage of `ty::TyKind`\n+}"}, {"sha": "4e94af12453cdaf35716d5d2812056d4036d032a", "filename": "src/test/ui-fulldeps/internal-lints/ty_tykind_usage.stderr", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fty_tykind_usage.stderr?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -0,0 +1,196 @@\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:11:15\n+   |\n+LL |     let sty = TyKind::Bool;\n+   |               ^^^^^^ help: try using ty::<kind> directly: `ty`\n+   |\n+note: lint level defined here\n+  --> $DIR/ty_tykind_usage.rs:9:8\n+   |\n+LL | #[deny(usage_of_ty_tykind)]\n+   |        ^^^^^^^^^^^^^^^^^^\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:14:9\n+   |\n+LL |         TyKind::Bool => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:15:9\n+   |\n+LL |         TyKind::Char => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:16:9\n+   |\n+LL |         TyKind::Int(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:17:9\n+   |\n+LL |         TyKind::Uint(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:18:9\n+   |\n+LL |         TyKind::Float(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:19:9\n+   |\n+LL |         TyKind::Adt(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:20:9\n+   |\n+LL |         TyKind::Foreign(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:21:9\n+   |\n+LL |         TyKind::Str => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:22:9\n+   |\n+LL |         TyKind::Array(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:23:9\n+   |\n+LL |         TyKind::Slice(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:24:9\n+   |\n+LL |         TyKind::RawPtr(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:25:9\n+   |\n+LL |         TyKind::Ref(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:26:9\n+   |\n+LL |         TyKind::FnDef(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:27:9\n+   |\n+LL |         TyKind::FnPtr(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:28:9\n+   |\n+LL |         TyKind::Dynamic(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:29:9\n+   |\n+LL |         TyKind::Closure(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:30:9\n+   |\n+LL |         TyKind::Generator(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:31:9\n+   |\n+LL |         TyKind::GeneratorWitness(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:32:9\n+   |\n+LL |         TyKind::Never => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:33:9\n+   |\n+LL |         TyKind::Tuple(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:34:9\n+   |\n+LL |         TyKind::Projection(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:35:9\n+   |\n+LL |         TyKind::UnnormalizedProjection(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:36:9\n+   |\n+LL |         TyKind::Opaque(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:37:9\n+   |\n+LL |         TyKind::Param(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:38:9\n+   |\n+LL |         TyKind::Bound(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:39:9\n+   |\n+LL |         TyKind::Placeholder(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:40:9\n+   |\n+LL |         TyKind::Infer(..) => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:41:9\n+   |\n+LL |         TyKind::Error => (),\n+   |         ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind::<kind>`\n+  --> $DIR/ty_tykind_usage.rs:46:12\n+   |\n+LL |     if let TyKind::Int(int_ty) = sty {}\n+   |            ^^^^^^ help: try using ty::<kind> directly: `ty`\n+\n+error: usage of `ty::TyKind`\n+  --> $DIR/ty_tykind_usage.rs:48:24\n+   |\n+LL |     fn ty_kind(ty_bad: TyKind<'_>, ty_good: Ty<'_>) {}\n+   |                        ^^^^^^^^^^\n+   |\n+   = help: try using `ty::Ty` instead\n+\n+error: aborting due to 31 previous errors\n+"}, {"sha": "2021dd513aa6209c3207715f24c19c11c2899397", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5dfdc589a1b44f01cb640cd0244372dcbbd6f37/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=a5dfdc589a1b44f01cb640cd0244372dcbbd6f37", "patch": "@@ -2820,12 +2820,15 @@ impl<'test> TestCx<'test> {\n             // don't test rustfix with nll right now\n         } else if self.config.rustfix_coverage {\n             // Find out which tests have `MachineApplicable` suggestions but are missing\n-            // `run-rustfix` or `run-rustfix-only-machine-applicable` headers\n+            // `run-rustfix` or `run-rustfix-only-machine-applicable` headers.\n+            //\n+            // This will return an empty `Vec` in case the executed test file has a\n+            // `compile-flags: --error-format=xxxx` header with a value other than `json`.\n             let suggestions = get_suggestions_from_json(\n                 &proc_res.stderr,\n                 &HashSet::new(),\n                 Filter::MachineApplicableOnly\n-            ).unwrap();\n+            ).unwrap_or_default();\n             if suggestions.len() > 0\n                 && !self.props.run_rustfix\n                 && !self.props.rustfix_only_machine_applicable {"}]}