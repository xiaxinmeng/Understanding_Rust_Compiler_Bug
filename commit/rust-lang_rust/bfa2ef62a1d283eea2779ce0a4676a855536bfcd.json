{"sha": "bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYTJlZjYyYTFkMjgzZWVhMjc3OWNlMGE0Njc2YTg1NTUzNmJmY2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-24T23:03:15Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-05-25T05:52:05Z"}, "message": "Hygienize `librustc_typeck`.", "tree": {"sha": "6f975fa9c0b699448069c165590c113f0a8615cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f975fa9c0b699448069c165590c113f0a8615cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "html_url": "https://github.com/rust-lang/rust/commit/bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f175fa35d4263f1d2c4c3433a495a78996305f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f175fa35d4263f1d2c4c3433a495a78996305f4", "html_url": "https://github.com/rust-lang/rust/commit/1f175fa35d4263f1d2c4c3433a495a78996305f4"}], "stats": {"total": 231, "additions": 170, "deletions": 61}, "files": [{"sha": "7ff7ad6a90e860ebf3be6bd9d8353191581a37d2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -47,7 +47,7 @@ use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n-use util::nodemap::{DefIdMap, NodeMap};\n+use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::collections::BTreeMap;\n use std::fmt::Debug;\n@@ -77,6 +77,7 @@ pub struct LoweringContext<'a> {\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n     resolver: &'a mut Resolver,\n+    name_map: FxHashMap<Ident, Name>,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n@@ -126,6 +127,7 @@ pub fn lower_crate(sess: &Session,\n         sess: sess,\n         parent_def: None,\n         resolver: resolver,\n+        name_map: FxHashMap(),\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -495,6 +497,14 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn lower_ident(&mut self, ident: Ident) -> Name {\n+        let ident = ident.modern();\n+        if ident.ctxt == SyntaxContext::empty() {\n+            return ident.name;\n+        }\n+        *self.name_map.entry(ident).or_insert_with(|| Symbol::from_ident(ident))\n+    }\n+\n     fn lower_opt_sp_ident(&mut self, o_id: Option<Spanned<Ident>>) -> Option<Spanned<Name>> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n@@ -546,7 +556,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: self.lower_node_id(b.id),\n-            name: b.ident.name,\n+            name: self.lower_ident(b.ident),\n             ty: self.lower_ty(&b.ty),\n             span: b.span,\n         }\n@@ -844,7 +854,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::PathSegment {\n-            name: segment.identifier.name,\n+            name: self.lower_ident(segment.identifier),\n             parameters: parameters,\n         }\n     }\n@@ -941,7 +951,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_ty_param(&mut self, tp: &TyParam, add_bounds: &[TyParamBound]) -> hir::TyParam {\n-        let mut name = tp.ident.name;\n+        let mut name = self.lower_ident(tp.ident);\n \n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n         // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n@@ -1137,7 +1147,11 @@ impl<'a> LoweringContext<'a> {\n         hir::StructField {\n             span: f.span,\n             id: self.lower_node_id(f.id),\n-            name: f.ident.map(|ident| ident.name).unwrap_or(Symbol::intern(&index.to_string())),\n+            name: self.lower_ident(match f.ident {\n+                Some(ident) => ident,\n+                // FIXME(jseyfried) positional field hygiene\n+                None => Ident { name: Symbol::intern(&index.to_string()), ctxt: f.span.ctxt },\n+            }),\n             vis: self.lower_visibility(&f.vis, None),\n             ty: self.lower_ty(&f.ty),\n             attrs: self.lower_attrs(&f.attrs),\n@@ -1146,7 +1160,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_field(&mut self, f: &Field) -> hir::Field {\n         hir::Field {\n-            name: respan(f.ident.span, f.ident.node.name),\n+            name: respan(f.ident.span, self.lower_ident(f.ident.node)),\n             expr: P(self.lower_expr(&f.expr)),\n             span: f.span,\n             is_shorthand: f.is_shorthand,\n@@ -1371,7 +1385,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_parent_def(i.id, |this| {\n             hir::TraitItem {\n                 id: this.lower_node_id(i.id),\n-                name: i.ident.name,\n+                name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n                     TraitItemKind::Const(ref ty, ref default) => {\n@@ -1421,7 +1435,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitItemRef {\n             id: hir::TraitItemId { node_id: i.id },\n-            name: i.ident.name,\n+            name: self.lower_ident(i.ident),\n             span: i.span,\n             defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n             kind: kind,\n@@ -1432,7 +1446,7 @@ impl<'a> LoweringContext<'a> {\n         self.with_parent_def(i.id, |this| {\n             hir::ImplItem {\n                 id: this.lower_node_id(i.id),\n-                name: i.ident.name,\n+                name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n                 defaultness: this.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -1461,7 +1475,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { node_id: i.id },\n-            name: i.ident.name,\n+            name: self.lower_ident(i.ident),\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -1655,7 +1669,7 @@ impl<'a> LoweringContext<'a> {\n                                        Spanned {\n                                            span: f.span,\n                                            node: hir::FieldPat {\n-                                               name: f.node.ident.name,\n+                                               name: self.lower_ident(f.node.ident),\n                                                pat: self.lower_pat(&f.node.pat),\n                                                is_shorthand: f.node.is_shorthand,\n                                            },\n@@ -1825,7 +1839,7 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::MethodCall(i, ref tps, ref args) => {\n                 let tps = tps.iter().map(|x| self.lower_ty(x)).collect();\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n-                hir::ExprMethodCall(respan(i.span, i.node.name), tps, args)\n+                hir::ExprMethodCall(respan(i.span, self.lower_ident(i.node)), tps, args)\n             }\n             ExprKind::Binary(binop, ref lhs, ref rhs) => {\n                 let binop = self.lower_binop(binop);\n@@ -1924,7 +1938,8 @@ impl<'a> LoweringContext<'a> {\n                                   P(self.lower_expr(er)))\n             }\n             ExprKind::Field(ref el, ident) => {\n-                hir::ExprField(P(self.lower_expr(el)), respan(ident.span, ident.node.name))\n+                hir::ExprField(P(self.lower_expr(el)),\n+                               respan(ident.span, self.lower_ident(ident.node)))\n             }\n             ExprKind::TupField(ref el, ident) => {\n                 hir::ExprTupField(P(self.lower_expr(el)), ident)\n@@ -2643,10 +2658,8 @@ impl<'a> LoweringContext<'a> {\n         let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n-            let def_index = defs.create_def_with_parent(parent_def,\n-                                                        id,\n-                                                        def_path_data,\n-                                                        REGULAR_SPACE);\n+            let def_index = defs\n+                .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n             DefId::local(def_index)\n         };\n "}, {"sha": "88750ce3acdeb91069ed2eb06a8d864e4cb3f905", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -22,6 +22,7 @@ use hir::map::{ITEM_LIKE_SPACE, REGULAR_SPACE};\n pub struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n     parent_def: Option<DefIndex>,\n+    expansion: Mark,\n     pub visit_macro_invoc: Option<&'a mut FnMut(MacroInvocationData)>,\n }\n \n@@ -32,9 +33,10 @@ pub struct MacroInvocationData {\n }\n \n impl<'a> DefCollector<'a> {\n-    pub fn new(definitions: &'a mut Definitions) -> Self {\n+    pub fn new(definitions: &'a mut Definitions, expansion: Mark) -> Self {\n         DefCollector {\n             definitions: definitions,\n+            expansion: expansion,\n             parent_def: None,\n             visit_macro_invoc: None,\n         }\n@@ -54,7 +56,8 @@ impl<'a> DefCollector<'a> {\n                   -> DefIndex {\n         let parent_def = self.parent_def.unwrap();\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n-        self.definitions.create_def_with_parent(parent_def, node_id, data, address_space)\n+        self.definitions\n+            .create_def_with_parent(parent_def, node_id, data, address_space, self.expansion)\n     }\n \n     pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {"}, {"sha": "7d9f92e17b9f20b21e0f371558c74f0ec042bed0", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -24,6 +24,7 @@ use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n+use syntax::ext::hygiene::Mark;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n@@ -180,6 +181,8 @@ pub struct Definitions {\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: [Vec<ast::NodeId>; 2],\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+    macro_def_scopes: FxHashMap<Mark, DefId>,\n+    expansions: FxHashMap<DefIndex, Mark>,\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -194,6 +197,8 @@ impl Clone for Definitions {\n                 self.def_index_to_node[1].clone(),\n             ],\n             node_to_hir_id: self.node_to_hir_id.clone(),\n+            macro_def_scopes: self.macro_def_scopes.clone(),\n+            expansions: self.expansions.clone(),\n         }\n     }\n }\n@@ -379,6 +384,8 @@ impl Definitions {\n             node_to_def_index: NodeMap(),\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n+            macro_def_scopes: FxHashMap(),\n+            expansions: FxHashMap(),\n         }\n     }\n \n@@ -472,7 +479,8 @@ impl Definitions {\n                                   parent: DefIndex,\n                                   node_id: ast::NodeId,\n                                   data: DefPathData,\n-                                  address_space: DefIndexAddressSpace)\n+                                  address_space: DefIndexAddressSpace,\n+                                  expansion: Mark)\n                                   -> DefIndex {\n         debug!(\"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n                parent, node_id, data);\n@@ -510,6 +518,7 @@ impl Definitions {\n         assert_eq!(index.as_array_index(),\n                    self.def_index_to_node[address_space.index()].len());\n         self.def_index_to_node[address_space.index()].push(node_id);\n+        self.expansions.insert(index, expansion);\n \n         debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n         self.node_to_def_index.insert(node_id, index);\n@@ -525,6 +534,18 @@ impl Definitions {\n                 \"Trying initialize NodeId -> HirId mapping twice\");\n         self.node_to_hir_id = mapping;\n     }\n+\n+    pub fn expansion(&self, index: DefIndex) -> Mark {\n+        self.expansions[&index]\n+    }\n+\n+    pub fn macro_def_scope(&self, mark: Mark) -> DefId {\n+        self.macro_def_scopes[&mark]\n+    }\n+\n+    pub fn add_macro_def_scope(&mut self, mark: Mark, scope: DefId) {\n+        self.macro_def_scopes.insert(mark, scope);\n+    }\n }\n \n impl DefPathData {"}, {"sha": "09e9d7c5b2f7d81cd8355e0bfc1254cec19e4721", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -637,14 +637,15 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub fn get_module_parent(&self, id: NodeId) -> NodeId {\n-        match self.walk_parent_nodes(id, |node| match *node {\n+    pub fn get_module_parent(&self, id: NodeId) -> DefId {\n+        let id = match self.walk_parent_nodes(id, |node| match *node {\n             NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n             _ => false,\n         }) {\n             Ok(id) => id,\n             Err(id) => id,\n-        }\n+        };\n+        self.local_def_id(id)\n     }\n \n     /// Returns the nearest enclosing scope. A scope is an item or block."}, {"sha": "963ee9b7165e5c28acff4414b27755618f2c81ac", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -45,8 +45,9 @@ use std::rc::Rc;\n use std::slice;\n use std::vec::IntoIter;\n use std::mem;\n-use syntax::ast::{self, DUMMY_NODE_ID, Name, NodeId};\n+use syntax::ast::{self, DUMMY_NODE_ID, Name, Ident, NodeId};\n use syntax::attr;\n+use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n use rustc_const_math::ConstInt;\n@@ -268,7 +269,7 @@ impl Visibility {\n                 def => Visibility::Restricted(def.def_id()),\n             },\n             hir::Inherited => {\n-                Visibility::Restricted(tcx.hir.local_def_id(tcx.hir.get_module_parent(id)))\n+                Visibility::Restricted(tcx.hir.get_module_parent(id))\n             }\n         }\n     }\n@@ -1823,17 +1824,22 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     #[inline]\n-    pub fn find_field_named(&self,\n-                            name: ast::Name)\n-                            -> Option<&FieldDef> {\n-        self.fields.iter().find(|f| f.name == name)\n+    pub fn find_field_named(&self, name: ast::Name) -> Option<&FieldDef> {\n+        self.index_of_field_named(name).map(|index| &self.fields[index])\n     }\n \n-    #[inline]\n-    pub fn index_of_field_named(&self,\n-                                name: ast::Name)\n-                                -> Option<usize> {\n-        self.fields.iter().position(|f| f.name == name)\n+    pub fn index_of_field_named(&self, name: ast::Name) -> Option<usize> {\n+        if let Some(index) = self.fields.iter().position(|f| f.name == name) {\n+            return Some(index);\n+        }\n+        let mut ident = name.to_ident();\n+        while ident.ctxt != SyntaxContext::empty() {\n+            ident.ctxt.remove_mark();\n+            if let Some(field) = self.fields.iter().position(|f| f.name.to_ident() == ident) {\n+                return Some(field);\n+            }\n+        }\n+        None\n     }\n \n     #[inline]\n@@ -2257,10 +2263,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn vis_is_accessible_from(self, vis: Visibility, block: NodeId) -> bool {\n-        vis.is_accessible_from(self.hir.local_def_id(self.hir.get_module_parent(block)), self)\n-    }\n-\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.hir.as_local_node_id(id) {\n             self.hir.name(id)\n@@ -2372,6 +2374,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             Err(self.sess.cstore.crate_name(impl_did.krate))\n         }\n     }\n+\n+    pub fn adjust(self, name: Name, scope: DefId, block: NodeId) -> (Ident, DefId) {\n+        self.adjust_ident(name.to_ident(), scope, block)\n+    }\n+\n+    pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n+        let expansion = match scope.krate {\n+            LOCAL_CRATE => self.hir.definitions().expansion(scope.index),\n+            _ => Mark::root(),\n+        };\n+        let scope = match ident.ctxt.adjust(expansion) {\n+            Some(macro_def) => self.hir.definitions().macro_def_scope(macro_def),\n+            None => self.hir.get_module_parent(block),\n+        };\n+        (ident, scope)\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {"}, {"sha": "b35b0865991659d29b461f44f441bc2991ab9d2d", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             }\n         }\n \n-        let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+        let module = self.tcx.hir.get_module_parent(scrut.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut have_errors = false;\n \n@@ -182,7 +182,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n             let pat_ty = self.tables.node_id_to_type(scrut.id);\n-            let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(scrut.id));\n+            let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n                     pat_ty.is_uninhabited_from(module, self.tcx)\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             \"local binding\"\n         };\n \n-        let module = self.tcx.hir.local_def_id(self.tcx.hir.get_module_parent(pat.id));\n+        let module = self.tcx.hir.get_module_parent(pat.id);\n         MatchCheckCtxt::create_and_enter(self.tcx, module, |ref mut cx| {\n             let mut patcx = PatternContext::new(self.tcx, self.tables);\n             let pattern = patcx.lower_pattern(pat);"}, {"sha": "552023d022f4e392bb414540004d9c06dc2c96f9", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -1320,7 +1320,7 @@ impl<'a> Resolver<'a> {\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n         let mut definitions = Definitions::new();\n-        DefCollector::new(&mut definitions)\n+        DefCollector::new(&mut definitions, Mark::root())\n             .collect_root(crate_name, &session.local_crate_disambiguator().as_str());\n \n         let mut invocations = FxHashMap();"}, {"sha": "8957312e1521712656f4e6812abaab4374dc7028", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -158,7 +158,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn visit_expansion(&mut self, mark: Mark, expansion: &Expansion, derives: &[Mark]) {\n         let invocation = self.invocations[&mark];\n-        self.collect_def_ids(invocation, expansion);\n+        self.collect_def_ids(mark, invocation, expansion);\n \n         self.current_module = invocation.module.get();\n         self.current_module.unresolved_invocations.borrow_mut().remove(&mark);\n@@ -290,7 +290,12 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 Err(determinacy) => return Err(determinacy),\n             },\n         };\n+\n         self.macro_defs.insert(invoc.expansion_data.mark, def.def_id());\n+        let normal_module_def_id =\n+            self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n+        self.definitions.add_macro_def_scope(invoc.expansion_data.mark, normal_module_def_id);\n+\n         self.unused_macros.remove(&def.def_id());\n         let ext = self.get_macro(def);\n         if ext.is_modern() {\n@@ -665,7 +670,10 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn collect_def_ids(&mut self, invocation: &'a InvocationData<'a>, expansion: &Expansion) {\n+    fn collect_def_ids(&mut self,\n+                       mark: Mark,\n+                       invocation: &'a InvocationData<'a>,\n+                       expansion: &Expansion) {\n         let Resolver { ref mut invocations, arenas, graph_root, .. } = *self;\n         let InvocationData { def_index, const_expr, .. } = *invocation;\n \n@@ -681,7 +689,7 @@ impl<'a> Resolver<'a> {\n             });\n         };\n \n-        let mut def_collector = DefCollector::new(&mut self.definitions);\n+        let mut def_collector = DefCollector::new(&mut self.definitions, mark);\n         def_collector.visit_macro_invoc = Some(visit_macro_invoc);\n         def_collector.with_parent(def_index, |def_collector| {\n             if const_expr {"}, {"sha": "d1ff3ed4f490f291d1521acaf80803ed39c0eeb5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -891,7 +891,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let item = tcx.associated_items(trait_did).find(|i| i.name == assoc_name)\n                                                   .expect(\"missing associated type\");\n         let def = Def::AssociatedTy(item.def_id);\n-        if !tcx.vis_is_accessible_from(item.vis, ref_id) {\n+        let def_scope = tcx.adjust(assoc_name, item.container.id(), ref_id).1;\n+        if !item.vis.is_accessible_from(def_scope, tcx) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n             tcx.sess.span_err(span, &msg);\n         }"}, {"sha": "43bf702935ac31e3d232821aa85bf28c150c99bb", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -338,6 +338,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// and return it, or `None`, if no such item was defined there.\n     pub fn associated_item(&self, def_id: DefId, item_name: ast::Name)\n                            -> Option<ty::AssociatedItem> {\n-        self.tcx.associated_items(def_id).find(|item| item.name == item_name)\n+        let ident = self.tcx.adjust(item_name, def_id, self.body_id).0;\n+        self.tcx.associated_items(def_id).find(|item| item.name.to_ident() == ident)\n     }\n }"}, {"sha": "b32eb9ac5fbf6df24a04ca92753c816c369ea325", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -371,7 +371,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn push_inherent_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n                                kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n+            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n+            item.vis.is_accessible_from(def_scope, self.tcx)\n+        } else {\n+            true\n+        };\n+        if is_accessible {\n             self.inherent_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n         } else if self.private_candidate.is_none() {\n             self.private_candidate = Some(item.def());\n@@ -380,7 +386,13 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n     fn push_extension_candidate(&mut self, xform_self_ty: Ty<'tcx>, item: ty::AssociatedItem,\n                                kind: CandidateKind<'tcx>, import_id: Option<ast::NodeId>) {\n-        if self.tcx.vis_is_accessible_from(item.vis, self.body_id) {\n+        let is_accessible = if let LookingFor::MethodName(name) = self.looking_for {\n+            let def_scope = self.tcx.adjust(name, item.container.id(), self.body_id).1;\n+            item.vis.is_accessible_from(def_scope, self.tcx)\n+        } else {\n+            true\n+        };\n+        if is_accessible {\n             self.extension_candidates.push(Candidate { xform_self_ty, item, kind, import_id });\n         } else if self.private_candidate.is_none() {\n             self.private_candidate = Some(item.def());"}, {"sha": "edaaa863ecc34f458357cb0ecfe1175c7874edc6", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -195,8 +195,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     };\n \n                                     let field_ty = field.ty(tcx, substs);\n-\n-                                    if tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                                    let scope = self.tcx.hir.get_module_parent(self.body_id);\n+                                    if field.vis.is_accessible_from(scope, self.tcx) {\n                                         if self.is_fn_ty(&field_ty, span) {\n                                             err.help(&format!(\"use `({0}.{1})(...)` if you \\\n                                                                meant to call the function \\"}, {"sha": "1ad3914854d342bff3b54aec232cb24103a1a463", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -2916,9 +2916,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match base_t.sty {\n                 ty::TyAdt(base_def, substs) if !base_def.is_enum() => {\n                     debug!(\"struct named {:?}\",  base_t);\n-                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust(field.node, base_def.did, self.body_id);\n+                    let fields = &base_def.struct_variant().fields;\n+                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n-                        if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             autoderef.finalize(lvalue_pref, base);\n                             self.apply_autoderef_adjustment(base.id, autoderefs, base_t);\n \n@@ -3024,16 +3027,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if !tuple_like { continue }\n \n                     debug!(\"tuple struct named {:?}\",  base_t);\n-                    base_def.struct_variant().fields.get(idx.node).and_then(|field| {\n+                    let ident = ast::Ident {\n+                        name: Symbol::intern(&idx.node.to_string()),\n+                        ctxt: idx.span.ctxt.modern(),\n+                    };\n+                    let (ident, def_scope) =\n+                        self.tcx.adjust_ident(ident, base_def.did, self.body_id);\n+                    let fields = &base_def.struct_variant().fields;\n+                    if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n-                        private_candidate = Some((base_def.did, field_ty));\n-                        if self.tcx.vis_is_accessible_from(field.vis, self.body_id) {\n+                        if field.vis.is_accessible_from(def_scope, self.tcx) {\n                             self.tcx.check_stability(field.did, expr.id, expr.span);\n                             Some(field_ty)\n                         } else {\n+                            private_candidate = Some((base_def.did, field_ty));\n                             None\n                         }\n-                    })\n+                    } else {\n+                        None\n+                    }\n                 }\n                 ty::TyTuple(ref v, _) => {\n                     tuple_like = true;\n@@ -3142,7 +3154,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut remaining_fields = FxHashMap();\n         for field in &variant.fields {\n-            remaining_fields.insert(field.name, field);\n+            remaining_fields.insert(field.name.to_ident(), field);\n         }\n \n         let mut seen_fields = FxHashMap();\n@@ -3154,7 +3166,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let final_field_type;\n             let field_type_hint;\n \n-            if let Some(v_field) = remaining_fields.remove(&field.name.node) {\n+            let ident = tcx.adjust(field.name.node, variant.did, self.body_id).0;\n+            if let Some(v_field) = remaining_fields.remove(&ident) {\n                 final_field_type = self.field_ty(field.span, v_field, substs);\n                 field_type_hint = self.field_ty(field.span, v_field, hint_substs);\n \n@@ -3205,7 +3218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             let mut displayable_field_names = remaining_fields\n                                               .keys()\n-                                              .map(|x| x.as_str())\n+                                              .map(|ident| ident.name.as_str())\n                                               .collect::<Vec<_>>();\n \n             displayable_field_names.sort();"}, {"sha": "f23398bda6b4ae8ea71a97fbbaa880a60f11efd4", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfa2ef62a1d283eea2779ce0a4676a855536bfcd/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=bfa2ef62a1d283eea2779ce0a4676a855536bfcd", "patch": "@@ -16,7 +16,7 @@\n //! DOI=10.1017/S0956796812000093 http://dx.doi.org/10.1017/S0956796812000093\n \n use Span;\n-use symbol::Symbol;\n+use symbol::{Ident, Symbol};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n@@ -106,6 +106,7 @@ struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    idents: HashMap<Symbol, Ident>,\n }\n \n impl HygieneData {\n@@ -114,6 +115,7 @@ impl HygieneData {\n             marks: vec![MarkData::default()],\n             syntax_contexts: vec![SyntaxContextData::default()],\n             markings: HashMap::new(),\n+            idents: HashMap::new(),\n         }\n     }\n \n@@ -348,3 +350,19 @@ impl Decodable for SyntaxContext {\n         Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n     }\n }\n+\n+impl Symbol {\n+    pub fn from_ident(ident: Ident) -> Symbol {\n+        HygieneData::with(|data| {\n+            let symbol = Symbol::gensym(&ident.name.as_str());\n+            data.idents.insert(symbol, ident);\n+            symbol\n+        })\n+    }\n+\n+    pub fn to_ident(self) -> Ident {\n+        HygieneData::with(|data| {\n+            data.idents.get(&self).cloned().unwrap_or(Ident::with_empty_ctxt(self))\n+        })\n+    }\n+}"}]}