{"sha": "15358818363f66fc8b99e3711e6eb99a5e8684b9", "node_id": "C_kwDOAAsO6NoAKDE1MzU4ODE4MzYzZjY2ZmM4Yjk5ZTM3MTFlNmViOTlhNWU4Njg0Yjk", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-21T16:29:07Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-01-21T16:55:45Z"}, "message": "Replace SmolStr usage with lang item enum for lang items", "tree": {"sha": "e3630300168fb34f6aab485874ff9ccbdee88fb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3630300168fb34f6aab485874ff9ccbdee88fb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15358818363f66fc8b99e3711e6eb99a5e8684b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15358818363f66fc8b99e3711e6eb99a5e8684b9", "html_url": "https://github.com/rust-lang/rust/commit/15358818363f66fc8b99e3711e6eb99a5e8684b9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15358818363f66fc8b99e3711e6eb99a5e8684b9/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1afa032f34db45a7018ced2c1a59798139e95bfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1afa032f34db45a7018ced2c1a59798139e95bfc", "html_url": "https://github.com/rust-lang/rust/commit/1afa032f34db45a7018ced2c1a59798139e95bfc"}], "stats": {"total": 625, "additions": 432, "deletions": 193}, "files": [{"sha": "b23427a73b3456f307009aadc51b93bdc301f50d", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -6,7 +6,7 @@ use either::Either;\n use hir_expand::{db::AstDatabase, HirFileId};\n use intern::Interned;\n use la_arena::ArenaMap;\n-use syntax::{ast, AstPtr, SmolStr};\n+use syntax::{ast, AstPtr};\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -19,7 +19,7 @@ use crate::{\n     generics::GenericParams,\n     import_map::ImportMap,\n     item_tree::{AttrOwner, ItemTree},\n-    lang_item::{LangItemTarget, LangItems},\n+    lang_item::{LangItem, LangItemTarget, LangItems},\n     nameres::{diagnostics::DefDiagnostic, DefMap},\n     visibility::{self, Visibility},\n     AttrDefId, BlockId, BlockLoc, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, ExternBlockId,\n@@ -183,7 +183,7 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n     fn crate_lang_items(&self, krate: CrateId) -> Arc<LangItems>;\n \n     #[salsa::invoke(LangItems::lang_item_query)]\n-    fn lang_item(&self, start_crate: CrateId, item: SmolStr) -> Option<LangItemTarget>;\n+    fn lang_item(&self, start_crate: CrateId, item: LangItem) -> Option<LangItemTarget>;\n \n     #[salsa::invoke(ImportMap::import_map_query)]\n     fn import_map(&self, krate: CrateId) -> Arc<ImportMap>;"}, {"sha": "ab9bc615daf55aeea42b0ab32c5f9d202f14fd20", "filename": "crates/hir-def/src/lang_item.rs", "status": "modified", "additions": 269, "deletions": 29, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flang_item.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -8,19 +8,21 @@ use rustc_hash::FxHashMap;\n use syntax::SmolStr;\n \n use crate::{\n-    db::DefDatabase, AdtId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId, ImplId,\n-    ModuleDefId, StaticId, StructId, TraitId,\n+    db::DefDatabase, AdtId, AssocItemId, AttrDefId, CrateId, EnumId, EnumVariantId, FunctionId,\n+    ImplId, ModuleDefId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum LangItemTarget {\n     EnumId(EnumId),\n-    FunctionId(FunctionId),\n-    ImplDefId(ImplId),\n-    StaticId(StaticId),\n-    StructId(StructId),\n-    TraitId(TraitId),\n-    EnumVariantId(EnumVariantId),\n+    Function(FunctionId),\n+    ImplDef(ImplId),\n+    Static(StaticId),\n+    Struct(StructId),\n+    Union(UnionId),\n+    TypeAlias(TypeAliasId),\n+    Trait(TraitId),\n+    EnumVariant(EnumVariantId),\n }\n \n impl LangItemTarget {\n@@ -33,55 +35,55 @@ impl LangItemTarget {\n \n     pub fn as_function(self) -> Option<FunctionId> {\n         match self {\n-            LangItemTarget::FunctionId(id) => Some(id),\n+            LangItemTarget::Function(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_impl_def(self) -> Option<ImplId> {\n         match self {\n-            LangItemTarget::ImplDefId(id) => Some(id),\n+            LangItemTarget::ImplDef(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_static(self) -> Option<StaticId> {\n         match self {\n-            LangItemTarget::StaticId(id) => Some(id),\n+            LangItemTarget::Static(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_struct(self) -> Option<StructId> {\n         match self {\n-            LangItemTarget::StructId(id) => Some(id),\n+            LangItemTarget::Struct(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_trait(self) -> Option<TraitId> {\n         match self {\n-            LangItemTarget::TraitId(id) => Some(id),\n+            LangItemTarget::Trait(id) => Some(id),\n             _ => None,\n         }\n     }\n \n     pub fn as_enum_variant(self) -> Option<EnumVariantId> {\n         match self {\n-            LangItemTarget::EnumVariantId(id) => Some(id),\n+            LangItemTarget::EnumVariant(id) => Some(id),\n             _ => None,\n         }\n     }\n }\n \n #[derive(Default, Debug, Clone, PartialEq, Eq)]\n pub struct LangItems {\n-    items: FxHashMap<SmolStr, LangItemTarget>,\n+    items: FxHashMap<LangItem, LangItemTarget>,\n }\n \n impl LangItems {\n-    pub fn target(&self, item: &str) -> Option<LangItemTarget> {\n-        self.items.get(item).copied()\n+    pub fn target(&self, item: LangItem) -> Option<LangItemTarget> {\n+        self.items.get(&item).copied()\n     }\n \n     /// Salsa query. This will look for lang items in a specific crate.\n@@ -94,16 +96,27 @@ impl LangItems {\n \n         for (_, module_data) in crate_def_map.modules() {\n             for impl_def in module_data.scope.impls() {\n-                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDefId)\n+                lang_items.collect_lang_item(db, impl_def, LangItemTarget::ImplDef);\n+                for assoc in db.impl_data(impl_def).items.iter().copied() {\n+                    match assoc {\n+                        AssocItemId::FunctionId(f) => {\n+                            lang_items.collect_lang_item(db, f, LangItemTarget::Function)\n+                        }\n+                        AssocItemId::TypeAliasId(t) => {\n+                            lang_items.collect_lang_item(db, t, LangItemTarget::TypeAlias)\n+                        }\n+                        AssocItemId::ConstId(_) => (),\n+                    }\n+                }\n             }\n \n             for def in module_data.scope.declarations() {\n                 match def {\n                     ModuleDefId::TraitId(trait_) => {\n-                        lang_items.collect_lang_item(db, trait_, LangItemTarget::TraitId);\n+                        lang_items.collect_lang_item(db, trait_, LangItemTarget::Trait);\n                         db.trait_data(trait_).items.iter().for_each(|&(_, assoc_id)| {\n-                            if let crate::AssocItemId::FunctionId(f) = assoc_id {\n-                                lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                            if let AssocItemId::FunctionId(f) = assoc_id {\n+                                lang_items.collect_lang_item(db, f, LangItemTarget::Function);\n                             }\n                         });\n                     }\n@@ -113,18 +126,24 @@ impl LangItems {\n                             lang_items.collect_lang_item(\n                                 db,\n                                 EnumVariantId { parent: e, local_id },\n-                                LangItemTarget::EnumVariantId,\n+                                LangItemTarget::EnumVariant,\n                             );\n                         });\n                     }\n                     ModuleDefId::AdtId(AdtId::StructId(s)) => {\n-                        lang_items.collect_lang_item(db, s, LangItemTarget::StructId);\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::Struct);\n+                    }\n+                    ModuleDefId::AdtId(AdtId::UnionId(u)) => {\n+                        lang_items.collect_lang_item(db, u, LangItemTarget::Union);\n                     }\n                     ModuleDefId::FunctionId(f) => {\n-                        lang_items.collect_lang_item(db, f, LangItemTarget::FunctionId);\n+                        lang_items.collect_lang_item(db, f, LangItemTarget::Function);\n                     }\n                     ModuleDefId::StaticId(s) => {\n-                        lang_items.collect_lang_item(db, s, LangItemTarget::StaticId);\n+                        lang_items.collect_lang_item(db, s, LangItemTarget::Static);\n+                    }\n+                    ModuleDefId::TypeAliasId(t) => {\n+                        lang_items.collect_lang_item(db, t, LangItemTarget::TypeAlias);\n                     }\n                     _ => {}\n                 }\n@@ -139,7 +158,7 @@ impl LangItems {\n     pub(crate) fn lang_item_query(\n         db: &dyn DefDatabase,\n         start_crate: CrateId,\n-        item: SmolStr,\n+        item: LangItem,\n     ) -> Option<LangItemTarget> {\n         let _p = profile::span(\"lang_item_query\");\n         let lang_items = db.crate_lang_items(start_crate);\n@@ -150,7 +169,7 @@ impl LangItems {\n         db.crate_graph()[start_crate]\n             .dependencies\n             .iter()\n-            .find_map(|dep| db.lang_item(dep.crate_id, item.clone()))\n+            .find_map(|dep| db.lang_item(dep.crate_id, item))\n     }\n \n     fn collect_lang_item<T>(\n@@ -162,8 +181,8 @@ impl LangItems {\n         T: Into<AttrDefId> + Copy,\n     {\n         let _p = profile::span(\"collect_lang_item\");\n-        if let Some(lang_item_name) = lang_attr(db, item) {\n-            self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n+        if let Some(lang_item) = lang_attr(db, item).and_then(|it| LangItem::from_str(&it)) {\n+            self.items.entry(lang_item).or_insert_with(|| constructor(item));\n         }\n     }\n }\n@@ -172,3 +191,224 @@ pub fn lang_attr(db: &dyn DefDatabase, item: impl Into<AttrDefId> + Copy) -> Opt\n     let attrs = db.attrs(item.into());\n     attrs.by_key(\"lang\").string_value().cloned()\n }\n+\n+pub enum GenericRequirement {\n+    None,\n+    Minimum(usize),\n+    Exact(usize),\n+}\n+\n+macro_rules! language_item_table {\n+    (\n+        $( $(#[$attr:meta])* $variant:ident, $name:ident, $method:ident, $target:expr, $generics:expr; )*\n+    ) => {\n+\n+        /// A representation of all the valid language items in Rust.\n+        #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+        pub enum LangItem {\n+            $(\n+                #[doc = concat!(\"The `\", stringify!($name), \"` lang item.\")]\n+                $(#[$attr])*\n+                $variant,\n+            )*\n+        }\n+\n+        impl LangItem {\n+            pub fn name(self) -> SmolStr {\n+                match self {\n+                    $( LangItem::$variant => SmolStr::new(stringify!($name)), )*\n+                }\n+            }\n+\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_name(name: &hir_expand::name::Name) -> Option<Self> {\n+                Self::from_str(name.as_str()?)\n+            }\n+\n+            /// Opposite of [`LangItem::name`]\n+            pub fn from_str(name: &str) -> Option<Self> {\n+                match name {\n+                    $( stringify!($name) => Some(LangItem::$variant), )*\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+language_item_table! {\n+//  Variant name,            Name,                     Getter method name,         Target                  Generic requirements;\n+    Sized,                   sized,               sized_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    Unsize,                  unsize,              unsize_trait,               Target::Trait,          GenericRequirement::Minimum(1);\n+    /// Trait injected by `#[derive(PartialEq)]`, (i.e. \"Partial EQ\").\n+    StructuralPeq,           structural_peq,      structural_peq_trait,       Target::Trait,          GenericRequirement::None;\n+    /// Trait injected by `#[derive(Eq)]`, (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeq,           structural_teq,      structural_teq_trait,       Target::Trait,          GenericRequirement::None;\n+    Copy,                    copy,                copy_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    Clone,                   clone,               clone_trait,                Target::Trait,          GenericRequirement::None;\n+    Sync,                    sync,                sync_trait,                 Target::Trait,          GenericRequirement::Exact(0);\n+    DiscriminantKind,        discriminant_kind,   discriminant_kind_trait,    Target::Trait,          GenericRequirement::None;\n+    /// The associated item of the [`DiscriminantKind`] trait.\n+    Discriminant,            discriminant_type,   discriminant_type,          Target::AssocTy,        GenericRequirement::None;\n+\n+    PointeeTrait,            pointee_trait,       pointee_trait,              Target::Trait,          GenericRequirement::None;\n+    Metadata,                metadata_type,       metadata_type,              Target::AssocTy,        GenericRequirement::None;\n+    DynMetadata,             dyn_metadata,        dyn_metadata,               Target::Struct,         GenericRequirement::None;\n+\n+    Freeze,                  freeze,              freeze_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Drop,                    drop,                drop_trait,                 Target::Trait,          GenericRequirement::None;\n+    Destruct,                destruct,            destruct_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    CoerceUnsized,           coerce_unsized,      coerce_unsized_trait,       Target::Trait,          GenericRequirement::Minimum(1);\n+    DispatchFromDyn,         dispatch_from_dyn,   dispatch_from_dyn_trait,    Target::Trait,          GenericRequirement::Minimum(1);\n+\n+    // language items relating to transmutability\n+    TransmuteOpts,           transmute_opts,      transmute_opts,             Target::Struct,         GenericRequirement::Exact(0);\n+    TransmuteTrait,          transmute_trait,     transmute_trait,            Target::Trait,          GenericRequirement::Exact(3);\n+\n+    Add,                     add,                 add_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Sub,                     sub,                 sub_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Mul,                     mul,                 mul_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Div,                     div,                 div_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Rem,                     rem,                 rem_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Neg,                     neg,                 neg_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    Not,                     not,                 not_trait,                  Target::Trait,          GenericRequirement::Exact(0);\n+    BitXor,                  bitxor,              bitxor_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitAnd,                  bitand,              bitand_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    BitOr,                   bitor,               bitor_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    Shl,                     shl,                 shl_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    Shr,                     shr,                 shr_trait,                  Target::Trait,          GenericRequirement::Exact(1);\n+    AddAssign,               add_assign,          add_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    SubAssign,               sub_assign,          sub_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    MulAssign,               mul_assign,          mul_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    DivAssign,               div_assign,          div_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    RemAssign,               rem_assign,          rem_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    BitXorAssign,            bitxor_assign,       bitxor_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitAndAssign,            bitand_assign,       bitand_assign_trait,        Target::Trait,          GenericRequirement::Exact(1);\n+    BitOrAssign,             bitor_assign,        bitor_assign_trait,         Target::Trait,          GenericRequirement::Exact(1);\n+    ShlAssign,               shl_assign,          shl_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    ShrAssign,               shr_assign,          shr_assign_trait,           Target::Trait,          GenericRequirement::Exact(1);\n+    Index,                   index,               index_trait,                Target::Trait,          GenericRequirement::Exact(1);\n+    IndexMut,                index_mut,           index_mut_trait,            Target::Trait,          GenericRequirement::Exact(1);\n+\n+    UnsafeCell,              unsafe_cell,         unsafe_cell_type,           Target::Struct,         GenericRequirement::None;\n+    VaList,                  va_list,             va_list,                    Target::Struct,         GenericRequirement::None;\n+\n+    Deref,                   deref,               deref_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+    DerefMut,                deref_mut,           deref_mut_trait,            Target::Trait,          GenericRequirement::Exact(0);\n+    DerefTarget,             deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n+    Receiver,                receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n+\n+    Fn,                      fn,                  fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut,                   fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce,                  fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+\n+    FnOnceOutput,            fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n+\n+    Future,                  future_trait,        future_trait,               Target::Trait,          GenericRequirement::Exact(0);\n+    GeneratorState,          generator_state,     gen_state,                  Target::Enum,           GenericRequirement::None;\n+    Generator,               generator,           gen_trait,                  Target::Trait,          GenericRequirement::Minimum(1);\n+    Unpin,                   unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n+    Pin,                     pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n+\n+    PartialEq,               eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd,              partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+\n+    // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n+    // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays.\n+    //\n+    // The `begin_unwind` lang item has a predefined symbol name and is sort of a \"weak lang item\"\n+    // in the sense that a crate is not required to have it defined to use it, but a final product\n+    // is required to define it somewhere. Additionally, there are restrictions on crates that use\n+    // a weak lang item, but do not have it defined.\n+    Panic,                   panic,               panic_fn,                   Target::Fn,             GenericRequirement::Exact(0);\n+    PanicNounwind,           panic_nounwind,      panic_nounwind,             Target::Fn,             GenericRequirement::Exact(0);\n+    PanicFmt,                panic_fmt,           panic_fmt,                  Target::Fn,             GenericRequirement::None;\n+    PanicDisplay,            panic_display,       panic_display,              Target::Fn,             GenericRequirement::None;\n+    ConstPanicFmt,           const_panic_fmt,     const_panic_fmt,            Target::Fn,             GenericRequirement::None;\n+    PanicBoundsCheck,        panic_bounds_check,  panic_bounds_check_fn,      Target::Fn,             GenericRequirement::Exact(0);\n+    PanicInfo,               panic_info,          panic_info,                 Target::Struct,         GenericRequirement::None;\n+    PanicLocation,           panic_location,      panic_location,             Target::Struct,         GenericRequirement::None;\n+    PanicImpl,               panic_impl,          panic_impl,                 Target::Fn,             GenericRequirement::None;\n+    PanicCannotUnwind,       panic_cannot_unwind, panic_cannot_unwind,        Target::Fn,             GenericRequirement::Exact(0);\n+    /// libstd panic entry point. Necessary for const eval to be able to catch it\n+    BeginPanic,              begin_panic,         begin_panic_fn,             Target::Fn,             GenericRequirement::None;\n+\n+    ExchangeMalloc,          exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n+    BoxFree,                 box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n+    DropInPlace,             drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n+    AllocLayout,             alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n+\n+    Start,                   start,               start_fn,                   Target::Fn,             GenericRequirement::Exact(1);\n+\n+    EhPersonality,           eh_personality,      eh_personality,             Target::Fn,             GenericRequirement::None;\n+    EhCatchTypeinfo,         eh_catch_typeinfo,   eh_catch_typeinfo,          Target::Static,         GenericRequirement::None;\n+\n+    OwnedBox,                owned_box,           owned_box,                  Target::Struct,         GenericRequirement::Minimum(1);\n+\n+    PhantomData,             phantom_data,        phantom_data,               Target::Struct,         GenericRequirement::Exact(1);\n+\n+    ManuallyDrop,            manually_drop,       manually_drop,              Target::Struct,         GenericRequirement::None;\n+\n+    MaybeUninit,             maybe_uninit,        maybe_uninit,               Target::Union,          GenericRequirement::None;\n+\n+    /// Align offset for stride != 1; must not panic.\n+    AlignOffset,             align_offset,        align_offset_fn,            Target::Fn,             GenericRequirement::None;\n+\n+    Termination,             termination,         termination,                Target::Trait,          GenericRequirement::None;\n+\n+    Try,                     Try,                 try_trait,                  Target::Trait,          GenericRequirement::None;\n+\n+    Tuple,                   tuple_trait,         tuple_trait,                Target::Trait,          GenericRequirement::Exact(0);\n+\n+    SliceLen,                slice_len_fn,        slice_len_fn,               Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+\n+    // Language items from AST lowering\n+    TryTraitFromResidual,    from_residual,       from_residual_fn,           Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromOutput,      from_output,         from_output_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitBranch,          branch,              branch_fn,                  Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    TryTraitFromYeet,        from_yeet,           from_yeet_fn,               Target::Fn,             GenericRequirement::None;\n+\n+    PointerSized,            pointer_sized,       pointer_sized,              Target::Trait,          GenericRequirement::Exact(0);\n+\n+    Poll,                    Poll,                poll,                       Target::Enum,           GenericRequirement::None;\n+    PollReady,               Ready,               poll_ready_variant,         Target::Variant,        GenericRequirement::None;\n+    PollPending,             Pending,             poll_pending_variant,       Target::Variant,        GenericRequirement::None;\n+\n+    // FIXME(swatinem): the following lang items are used for async lowering and\n+    // should become obsolete eventually.\n+    ResumeTy,                ResumeTy,            resume_ty,                  Target::Struct,         GenericRequirement::None;\n+    IdentityFuture,          identity_future,     identity_future_fn,         Target::Fn,             GenericRequirement::None;\n+    GetContext,              get_context,         get_context_fn,             Target::Fn,             GenericRequirement::None;\n+\n+    Context,                 Context,             context,                    Target::Struct,         GenericRequirement::None;\n+    FuturePoll,              poll,                future_poll_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    FromFrom,                from,                from_fn,                    Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+\n+    OptionSome,              Some,                option_some_variant,        Target::Variant,        GenericRequirement::None;\n+    OptionNone,              None,                option_none_variant,        Target::Variant,        GenericRequirement::None;\n+\n+    ResultOk,                Ok,                  result_ok_variant,          Target::Variant,        GenericRequirement::None;\n+    ResultErr,               Err,                 result_err_variant,         Target::Variant,        GenericRequirement::None;\n+\n+    ControlFlowContinue,     Continue,            cf_continue_variant,        Target::Variant,        GenericRequirement::None;\n+    ControlFlowBreak,        Break,               cf_break_variant,           Target::Variant,        GenericRequirement::None;\n+\n+    IntoFutureIntoFuture,    into_future,         into_future_fn,             Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IntoIterIntoIter,        into_iter,           into_iter_fn,               Target::Method(MethodKind::Trait { body: false }), GenericRequirement::None;\n+    IteratorNext,            next,                next_fn,                    Target::Method(MethodKind::Trait { body: false}), GenericRequirement::None;\n+\n+    PinNewUnchecked,         new_unchecked,       new_unchecked_fn,           Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+\n+    RangeFrom,               RangeFrom,           range_from_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeFull,               RangeFull,           range_full_struct,          Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveStruct,    RangeInclusive,      range_inclusive_struct,     Target::Struct,         GenericRequirement::None;\n+    RangeInclusiveNew,       range_inclusive_new, range_inclusive_new_method, Target::Method(MethodKind::Inherent), GenericRequirement::None;\n+    Range,                   Range,               range_struct,               Target::Struct,         GenericRequirement::None;\n+    RangeToInclusive,        RangeToInclusive,    range_to_inclusive_struct,  Target::Struct,         GenericRequirement::None;\n+    RangeTo,                 RangeTo,             range_to_struct,            Target::Struct,         GenericRequirement::None;\n+\n+    String,                  String,              string,                     Target::Struct,         GenericRequirement::None;\n+}"}, {"sha": "9e4e0dcc96cc6a294e7771beddbe3559414b0269", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -634,7 +634,6 @@ pub trait Lookup {\n pub trait HasModule {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId;\n }\n-\n impl HasModule for ItemContainerId {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match *self {"}, {"sha": "b62f4fe77016021c61ebaea3cb75352ecadaf903", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -133,6 +133,14 @@ impl Name {\n         }\n     }\n \n+    /// Returns the text this name represents if it isn't a tuple field.\n+    pub fn as_str(&self) -> Option<&str> {\n+        match &self.0 {\n+            Repr::Text(it) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns the textual representation of this name as a [`SmolStr`].\n     /// Prefer using this over [`ToString::to_string`] if possible as this conversion is cheaper in\n     /// the general case."}, {"sha": "caddca6d9152e0afc6714043317e996f4a93f0ca", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -6,9 +6,9 @@\n use std::sync::Arc;\n \n use chalk_ir::cast::Cast;\n+use hir_def::lang_item::LangItem;\n use hir_expand::name::name;\n use limit::Limit;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, Canonical, Goal, Interner, ProjectionTyExt,\n@@ -117,9 +117,8 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     }\n \n     let db = table.db;\n-    let deref_trait = db\n-        .lang_item(table.trait_env.krate, SmolStr::new_inline(\"deref\"))\n-        .and_then(|l| l.as_trait())?;\n+    let deref_trait =\n+        db.lang_item(table.trait_env.krate, LangItem::Deref).and_then(|l| l.as_trait())?;\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {"}, {"sha": "bbb6625855d32e55fefd63947da63f0182f3ec71", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 40, "deletions": 41, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -3,7 +3,6 @@\n use std::sync::Arc;\n \n use cov_mark::hit;\n-use syntax::SmolStr;\n use tracing::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n@@ -12,7 +11,7 @@ use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n use base_db::CrateId;\n use hir_def::{\n     expr::Movability,\n-    lang_item::{lang_attr, LangItemTarget},\n+    lang_item::{lang_attr, LangItem, LangItemTarget},\n     AssocItemId, GenericDefId, HasModule, ItemContainerId, Lookup, ModuleId, TypeAliasId,\n };\n use hir_expand::name::name;\n@@ -182,9 +181,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         &self,\n         well_known_trait: rust_ir::WellKnownTrait,\n     ) -> Option<chalk_ir::TraitId<Interner>> {\n-        let lang_attr = lang_attr_from_well_known_trait(well_known_trait);\n+        let lang_attr = lang_item_from_well_known_trait(well_known_trait);\n         let trait_ = match self.db.lang_item(self.krate, lang_attr.into()) {\n-            Some(LangItemTarget::TraitId(trait_)) => trait_,\n+            Some(LangItemTarget::Trait(trait_)) => trait_,\n             _ => return None,\n         };\n         Some(to_chalk_trait_id(trait_))\n@@ -216,7 +215,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             crate::ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                 if let Some((future_trait, future_output)) = self\n                     .db\n-                    .lang_item(self.krate, SmolStr::new_inline(\"future_trait\"))\n+                    .lang_item(self.krate, LangItem::Future)\n                     .and_then(|item| item.as_trait())\n                     .and_then(|trait_| {\n                         let alias =\n@@ -246,7 +245,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     binder.push(crate::wrap_empty_binders(impl_bound));\n                     let sized_trait = self\n                         .db\n-                        .lang_item(self.krate, SmolStr::new_inline(\"sized\"))\n+                        .lang_item(self.krate, LangItem::Sized)\n                         .and_then(|item| item.as_trait());\n                     if let Some(sized_trait_) = sized_trait {\n                         let sized_bound = WhereClause::Implemented(TraitRef {\n@@ -493,7 +492,7 @@ pub(crate) fn associated_ty_data_query(\n \n     if !ctx.unsized_types.borrow().contains(&self_ty) {\n         let sized_trait = db\n-            .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n+            .lang_item(resolver.krate(), LangItem::Sized)\n             .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n         let sized_bound = sized_trait.into_iter().map(|sized_trait| {\n             let trait_bound =\n@@ -541,8 +540,8 @@ pub(crate) fn trait_datum_query(\n     let where_clauses = convert_where_clauses(db, trait_.into(), &bound_vars);\n     let associated_ty_ids = trait_data.associated_types().map(to_assoc_type_id).collect();\n     let trait_datum_bound = rust_ir::TraitDatumBound { where_clauses };\n-    let well_known =\n-        lang_attr(db.upcast(), trait_).and_then(|name| well_known_trait_from_lang_attr(&name));\n+    let well_known = lang_attr(db.upcast(), trait_)\n+        .and_then(|name| well_known_trait_from_lang_item(LangItem::from_str(&name)?));\n     let trait_datum = TraitDatum {\n         id: trait_id,\n         binders: make_binders(db, &generic_params, trait_datum_bound),\n@@ -553,42 +552,42 @@ pub(crate) fn trait_datum_query(\n     Arc::new(trait_datum)\n }\n \n-fn well_known_trait_from_lang_attr(name: &str) -> Option<WellKnownTrait> {\n-    Some(match name {\n-        \"clone\" => WellKnownTrait::Clone,\n-        \"coerce_unsized\" => WellKnownTrait::CoerceUnsized,\n-        \"copy\" => WellKnownTrait::Copy,\n-        \"discriminant_kind\" => WellKnownTrait::DiscriminantKind,\n-        \"dispatch_from_dyn\" => WellKnownTrait::DispatchFromDyn,\n-        \"drop\" => WellKnownTrait::Drop,\n-        \"fn\" => WellKnownTrait::Fn,\n-        \"fn_mut\" => WellKnownTrait::FnMut,\n-        \"fn_once\" => WellKnownTrait::FnOnce,\n-        \"generator\" => WellKnownTrait::Generator,\n-        \"sized\" => WellKnownTrait::Sized,\n-        \"unpin\" => WellKnownTrait::Unpin,\n-        \"unsize\" => WellKnownTrait::Unsize,\n-        \"tuple_trait\" => WellKnownTrait::Tuple,\n+fn well_known_trait_from_lang_item(item: LangItem) -> Option<WellKnownTrait> {\n+    Some(match item {\n+        LangItem::Clone => WellKnownTrait::Clone,\n+        LangItem::CoerceUnsized => WellKnownTrait::CoerceUnsized,\n+        LangItem::Copy => WellKnownTrait::Copy,\n+        LangItem::DiscriminantKind => WellKnownTrait::DiscriminantKind,\n+        LangItem::DispatchFromDyn => WellKnownTrait::DispatchFromDyn,\n+        LangItem::Drop => WellKnownTrait::Drop,\n+        LangItem::Fn => WellKnownTrait::Fn,\n+        LangItem::FnMut => WellKnownTrait::FnMut,\n+        LangItem::FnOnce => WellKnownTrait::FnOnce,\n+        LangItem::Generator => WellKnownTrait::Generator,\n+        LangItem::Sized => WellKnownTrait::Sized,\n+        LangItem::Unpin => WellKnownTrait::Unpin,\n+        LangItem::Unsize => WellKnownTrait::Unsize,\n+        LangItem::Tuple => WellKnownTrait::Tuple,\n         _ => return None,\n     })\n }\n \n-fn lang_attr_from_well_known_trait(attr: WellKnownTrait) -> &'static str {\n-    match attr {\n-        WellKnownTrait::Clone => \"clone\",\n-        WellKnownTrait::CoerceUnsized => \"coerce_unsized\",\n-        WellKnownTrait::Copy => \"copy\",\n-        WellKnownTrait::DiscriminantKind => \"discriminant_kind\",\n-        WellKnownTrait::DispatchFromDyn => \"dispatch_from_dyn\",\n-        WellKnownTrait::Drop => \"drop\",\n-        WellKnownTrait::Fn => \"fn\",\n-        WellKnownTrait::FnMut => \"fn_mut\",\n-        WellKnownTrait::FnOnce => \"fn_once\",\n-        WellKnownTrait::Generator => \"generator\",\n-        WellKnownTrait::Sized => \"sized\",\n-        WellKnownTrait::Tuple => \"tuple_trait\",\n-        WellKnownTrait::Unpin => \"unpin\",\n-        WellKnownTrait::Unsize => \"unsize\",\n+fn lang_item_from_well_known_trait(trait_: WellKnownTrait) -> LangItem {\n+    match trait_ {\n+        WellKnownTrait::Clone => LangItem::Clone,\n+        WellKnownTrait::CoerceUnsized => LangItem::CoerceUnsized,\n+        WellKnownTrait::Copy => LangItem::Copy,\n+        WellKnownTrait::DiscriminantKind => LangItem::DiscriminantKind,\n+        WellKnownTrait::DispatchFromDyn => LangItem::DispatchFromDyn,\n+        WellKnownTrait::Drop => LangItem::Drop,\n+        WellKnownTrait::Fn => LangItem::Fn,\n+        WellKnownTrait::FnMut => LangItem::FnMut,\n+        WellKnownTrait::FnOnce => LangItem::FnOnce,\n+        WellKnownTrait::Generator => LangItem::Generator,\n+        WellKnownTrait::Sized => LangItem::Sized,\n+        WellKnownTrait::Tuple => LangItem::Tuple,\n+        WellKnownTrait::Unpin => LangItem::Unpin,\n+        WellKnownTrait::Unsize => LangItem::Unsize,\n     }\n }\n "}, {"sha": "329c87c74e97ebf4f8af9aeb745f3e67246f6d4c", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -4,10 +4,10 @@ use chalk_ir::{FloatTy, IntTy, Mutability, Scalar, TyVariableKind, UintTy};\n use hir_def::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinType, BuiltinUint},\n     generics::TypeOrConstParamData,\n+    lang_item::LangItem,\n     type_ref::Rawness,\n     FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n@@ -214,9 +214,8 @@ impl TyExt for Ty {\n                 match db.lookup_intern_impl_trait_id((*opaque_ty_id).into()) {\n                     ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n                         let krate = def.module(db.upcast()).krate();\n-                        if let Some(future_trait) = db\n-                            .lang_item(krate, SmolStr::new_inline(\"future_trait\"))\n-                            .and_then(|item| item.as_trait())\n+                        if let Some(future_trait) =\n+                            db.lang_item(krate, LangItem::Future).and_then(|item| item.as_trait())\n                         {\n                             // This is only used by type walking.\n                             // Parameters will be walked outside, and projection predicate is not used."}, {"sha": "ae2162dd7cd248c2242a778f833b1f7a696e7400", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -12,6 +12,7 @@ use hir_def::{\n     find_path,\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_scope::ItemInNs,\n+    lang_item::LangItem,\n     path::{Path, PathKind},\n     type_ref::{ConstScalar, TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n@@ -21,7 +22,6 @@ use hir_expand::{hygiene::Hygiene, name::Name};\n use intern::{Internable, Interned};\n use itertools::Itertools;\n use smallvec::SmallVec;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase,\n@@ -925,7 +925,7 @@ impl SizedByDefault {\n             Self::NotSized => false,\n             Self::Sized { anchor } => {\n                 let sized_trait = db\n-                    .lang_item(anchor, SmolStr::new_inline(\"sized\"))\n+                    .lang_item(anchor, LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait());\n                 Some(trait_) == sized_trait\n             }\n@@ -1057,8 +1057,7 @@ fn write_bounds_like_dyn_trait(\n     }\n     if let SizedByDefault::Sized { anchor } = default_sized {\n         let sized_trait =\n-            f.db.lang_item(anchor, SmolStr::new_inline(\"sized\"))\n-                .and_then(|lang_item| lang_item.as_trait());\n+            f.db.lang_item(anchor, LangItem::Sized).and_then(|lang_item| lang_item.as_trait());\n         if !is_sized {\n             if !first {\n                 write!(f, \" + \")?;"}, {"sha": "d06b22fff9a3d8eb979ddaaeec0ccf89601ea9fb", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -22,15 +22,15 @@ use hir_def::{\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     data::{ConstData, StaticData},\n     expr::{BindingAnnotation, ExprId, ExprOrPatId, PatId},\n-    lang_item::LangItemTarget,\n+    lang_item::{LangItem, LangItemTarget},\n     layout::Integer,\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n     AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n     ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n-use hir_expand::name::{name, Name};\n+use hir_expand::name::name;\n use itertools::Either;\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n@@ -917,9 +917,9 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n-    fn resolve_lang_item(&self, name: Name) -> Option<LangItemTarget> {\n+    fn resolve_lang_item(&self, item: LangItem) -> Option<LangItemTarget> {\n         let krate = self.resolver.krate();\n-        self.db.lang_item(krate, name.to_smol_str())\n+        self.db.lang_item(krate, item)\n     }\n \n     fn resolve_into_iter_item(&self) -> Option<TypeAliasId> {\n@@ -946,25 +946,25 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_ops_neg_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![neg])?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(LangItem::Neg)?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_ops_not_output(&self) -> Option<TypeAliasId> {\n-        let trait_ = self.resolve_lang_item(name![not])?.as_trait()?;\n+        let trait_ = self.resolve_lang_item(LangItem::Not)?.as_trait()?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_future_future_output(&self) -> Option<TypeAliasId> {\n         let trait_ = self\n             .resolver\n             .resolve_known_trait(self.db.upcast(), &path![core::future::IntoFuture])\n-            .or_else(|| self.resolve_lang_item(name![future_trait])?.as_trait())?;\n+            .or_else(|| self.resolve_lang_item(LangItem::Future)?.as_trait())?;\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(name![owned_box])?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(LangItem::OwnedBox)?.as_struct()?;\n         Some(struct_.into())\n     }\n \n@@ -1005,7 +1005,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_ops_index(&self) -> Option<TraitId> {\n-        self.resolve_lang_item(name![index])?.as_trait()\n+        self.resolve_lang_item(LangItem::Index)?.as_trait()\n     }\n \n     fn resolve_ops_index_output(&self) -> Option<TypeAliasId> {\n@@ -1014,7 +1014,7 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_va_list(&self) -> Option<AdtId> {\n-        let struct_ = self.resolve_lang_item(name![va_list])?.as_struct()?;\n+        let struct_ = self.resolve_lang_item(LangItem::VaList)?.as_struct()?;\n         Some(struct_.into())\n     }\n }"}, {"sha": "3293534a068bd7dba56c0e4ff0e79a304ad68fdb", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -8,9 +8,11 @@\n use std::{iter, sync::Arc};\n \n use chalk_ir::{cast::Cast, BoundVar, Goal, Mutability, TyVariableKind};\n-use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n+use hir_def::{\n+    expr::ExprId,\n+    lang_item::{LangItem, LangItemTarget},\n+};\n use stdx::always;\n-use syntax::SmolStr;\n \n use crate::{\n     autoderef::{Autoderef, AutoderefKind},\n@@ -570,11 +572,10 @@ impl<'a> InferenceTable<'a> {\n             reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n         let krate = self.trait_env.krate;\n-        let coerce_unsized_trait =\n-            match self.db.lang_item(krate, SmolStr::new_inline(\"coerce_unsized\")) {\n-                Some(LangItemTarget::TraitId(trait_)) => trait_,\n-                _ => return Err(TypeError),\n-            };\n+        let coerce_unsized_trait = match self.db.lang_item(krate, LangItem::CoerceUnsized) {\n+            Some(LangItemTarget::Trait(trait_)) => trait_,\n+            _ => return Err(TypeError),\n+        };\n \n         let coerce_unsized_tref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);"}, {"sha": "7ae85d20611a80f9b367f80e3d2bb08f3b71471d", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -29,7 +29,7 @@ use crate::{\n         const_or_path_to_chalk, generic_arg_to_chalk, lower_to_chalk_mutability, ParamLoweringMode,\n     },\n     mapping::{from_chalk, ToChalk},\n-    method_resolution::{self, lang_names_for_bin_op, VisibleFromModule},\n+    method_resolution::{self, lang_items_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::{generics, Generics},\n@@ -1008,7 +1008,7 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+        let trait_func = lang_items_for_bin_op(op).and_then(|(name, lang_item)| {\n             let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n             let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n             Some((trait_id, func))"}, {"sha": "5308c72161b26bb233a0566b0cddbb2f0ea2deae", "filename": "crates/hir-ty/src/lang_items.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flang_items.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -1,20 +1,19 @@\n //! Functions to detect special lang items\n \n-use hir_def::{AdtId, HasModule};\n-use hir_expand::name;\n+use hir_def::{lang_item::LangItem, AdtId, HasModule};\n \n use crate::db::HirDatabase;\n \n pub fn is_box(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![owned_box].to_smol_str();\n     let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    let box_adt =\n+        db.lang_item(krate, LangItem::OwnedBox).and_then(|it| it.as_struct()).map(AdtId::from);\n     Some(adt) == box_adt\n }\n \n pub fn is_unsafe_cell(adt: AdtId, db: &dyn HirDatabase) -> bool {\n-    let owned_box = name![unsafe_cell].to_smol_str();\n     let krate = adt.module(db.upcast()).krate();\n-    let box_adt = db.lang_item(krate, owned_box).and_then(|it| it.as_struct()).map(AdtId::from);\n+    let box_adt =\n+        db.lang_item(krate, LangItem::UnsafeCell).and_then(|it| it.as_struct()).map(AdtId::from);\n     Some(adt) == box_adt\n }"}, {"sha": "b1a7ad3e940ed2a41e4a4e60d1c68afb6ac6d804", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -23,7 +23,7 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n-    lang_item::lang_attr,\n+    lang_item::{lang_attr, LangItem},\n     path::{GenericArg, ModPath, Path, PathKind, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::{\n@@ -40,7 +40,7 @@ use la_arena::ArenaMap;\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n-use syntax::{ast, SmolStr};\n+use syntax::ast;\n \n use crate::{\n     all_super_traits,\n@@ -954,7 +954,7 @@ impl<'a> TyLoweringContext<'a> {\n             TypeBound::Path(path, TraitBoundModifier::Maybe) => {\n                 let sized_trait = self\n                     .db\n-                    .lang_item(self.resolver.krate(), SmolStr::new_inline(\"sized\"))\n+                    .lang_item(self.resolver.krate(), LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait());\n                 // Don't lower associated type bindings as the only possible relaxed trait bound\n                 // `?Sized` has no of them.\n@@ -1150,7 +1150,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let krate = func.lookup(ctx.db.upcast()).module(ctx.db.upcast()).krate();\n                 let sized_trait = ctx\n                     .db\n-                    .lang_item(krate, SmolStr::new_inline(\"sized\"))\n+                    .lang_item(krate, LangItem::Sized)\n                     .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n                 let sized_clause = sized_trait.map(|trait_id| {\n                     let clause = WhereClause::Implemented(TraitRef {\n@@ -1489,7 +1489,7 @@ fn implicitly_sized_clauses<'a>(\n     let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n     let generic_args = &substitution.as_slice(Interner)[is_trait_def as usize..];\n     let sized_trait = db\n-        .lang_item(resolver.krate(), SmolStr::new_inline(\"sized\"))\n+        .lang_item(resolver.krate(), LangItem::Sized)\n         .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n \n     sized_trait.into_iter().flat_map(move |sized_trait| {"}, {"sha": "858de0005962c0c4cb7989290281e302ddc09a03", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -7,8 +7,9 @@ use std::{ops::ControlFlow, sync::Arc};\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n-    data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n-    FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    data::ImplData, item_scope::ItemScope, lang_item::LangItem, nameres::DefMap, AssocItemId,\n+    BlockId, ConstId, FunctionId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId,\n+    ModuleId, TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -437,49 +438,49 @@ pub fn def_crates(\n     }\n }\n \n-pub fn lang_names_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, Name)> {\n+pub fn lang_items_for_bin_op(op: syntax::ast::BinaryOp) -> Option<(Name, LangItem)> {\n     use hir_expand::name;\n     use syntax::ast::{ArithOp, BinaryOp, CmpOp, Ordering};\n     Some(match op {\n         BinaryOp::LogicOp(_) => return None,\n         BinaryOp::ArithOp(aop) => match aop {\n-            ArithOp::Add => (name!(add), name!(add)),\n-            ArithOp::Mul => (name!(mul), name!(mul)),\n-            ArithOp::Sub => (name!(sub), name!(sub)),\n-            ArithOp::Div => (name!(div), name!(div)),\n-            ArithOp::Rem => (name!(rem), name!(rem)),\n-            ArithOp::Shl => (name!(shl), name!(shl)),\n-            ArithOp::Shr => (name!(shr), name!(shr)),\n-            ArithOp::BitXor => (name!(bitxor), name!(bitxor)),\n-            ArithOp::BitOr => (name!(bitor), name!(bitor)),\n-            ArithOp::BitAnd => (name!(bitand), name!(bitand)),\n+            ArithOp::Add => (name![add], LangItem::Add),\n+            ArithOp::Mul => (name![mul], LangItem::Mul),\n+            ArithOp::Sub => (name![sub], LangItem::Sub),\n+            ArithOp::Div => (name![div], LangItem::Div),\n+            ArithOp::Rem => (name![rem], LangItem::Rem),\n+            ArithOp::Shl => (name![shl], LangItem::Shl),\n+            ArithOp::Shr => (name![shr], LangItem::Shr),\n+            ArithOp::BitXor => (name![bitxor], LangItem::BitXor),\n+            ArithOp::BitOr => (name![bitor], LangItem::BitOr),\n+            ArithOp::BitAnd => (name![bitand], LangItem::BitAnd),\n         },\n         BinaryOp::Assignment { op: Some(aop) } => match aop {\n-            ArithOp::Add => (name!(add_assign), name!(add_assign)),\n-            ArithOp::Mul => (name!(mul_assign), name!(mul_assign)),\n-            ArithOp::Sub => (name!(sub_assign), name!(sub_assign)),\n-            ArithOp::Div => (name!(div_assign), name!(div_assign)),\n-            ArithOp::Rem => (name!(rem_assign), name!(rem_assign)),\n-            ArithOp::Shl => (name!(shl_assign), name!(shl_assign)),\n-            ArithOp::Shr => (name!(shr_assign), name!(shr_assign)),\n-            ArithOp::BitXor => (name!(bitxor_assign), name!(bitxor_assign)),\n-            ArithOp::BitOr => (name!(bitor_assign), name!(bitor_assign)),\n-            ArithOp::BitAnd => (name!(bitand_assign), name!(bitand_assign)),\n+            ArithOp::Add => (name![add_assign], LangItem::AddAssign),\n+            ArithOp::Mul => (name![mul_assign], LangItem::MulAssign),\n+            ArithOp::Sub => (name![sub_assign], LangItem::SubAssign),\n+            ArithOp::Div => (name![div_assign], LangItem::DivAssign),\n+            ArithOp::Rem => (name![rem_assign], LangItem::RemAssign),\n+            ArithOp::Shl => (name![shl_assign], LangItem::ShlAssign),\n+            ArithOp::Shr => (name![shr_assign], LangItem::ShrAssign),\n+            ArithOp::BitXor => (name![bitxor_assign], LangItem::BitXorAssign),\n+            ArithOp::BitOr => (name![bitor_assign], LangItem::BitOrAssign),\n+            ArithOp::BitAnd => (name![bitand_assign], LangItem::BitAndAssign),\n         },\n         BinaryOp::CmpOp(cop) => match cop {\n-            CmpOp::Eq { negated: false } => (name!(eq), name!(eq)),\n-            CmpOp::Eq { negated: true } => (name!(ne), name!(eq)),\n+            CmpOp::Eq { negated: false } => (name![eq], LangItem::PartialEq),\n+            CmpOp::Eq { negated: true } => (name![ne], LangItem::PartialEq),\n             CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n-                (name!(le), name!(partial_ord))\n+                (name![le], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Less, strict: true } => {\n-                (name!(lt), name!(partial_ord))\n+                (name![lt], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n-                (name!(ge), name!(partial_ord))\n+                (name![ge], LangItem::PartialOrd)\n             }\n             CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n-                (name!(gt), name!(partial_ord))\n+                (name![gt], LangItem::PartialOrd)\n             }\n         },\n         BinaryOp::Assignment { op: None } => return None,"}, {"sha": "3ab85c68f5b9db67e809a8d60c8ff1a821c570cf", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -7,9 +7,11 @@ use chalk_recursive::Cache;\n use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n \n use base_db::CrateId;\n-use hir_def::{lang_item::LangItemTarget, TraitId};\n+use hir_def::{\n+    lang_item::{LangItem, LangItemTarget},\n+    TraitId,\n+};\n use stdx::panic_context;\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, infer::unify::InferenceTable, AliasEq, AliasTy, Canonical, DomainGoal, Goal,\n@@ -177,18 +179,18 @@ pub enum FnTrait {\n }\n \n impl FnTrait {\n-    const fn lang_item_name(self) -> &'static str {\n+    const fn lang_item(self) -> LangItem {\n         match self {\n-            FnTrait::FnOnce => \"fn_once\",\n-            FnTrait::FnMut => \"fn_mut\",\n-            FnTrait::Fn => \"fn\",\n+            FnTrait::FnOnce => LangItem::FnOnce,\n+            FnTrait::FnMut => LangItem::FnMut,\n+            FnTrait::Fn => LangItem::Fn,\n         }\n     }\n \n     pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n-        let target = db.lang_item(krate, SmolStr::new_inline(self.lang_item_name()))?;\n+        let target = db.lang_item(krate, self.lang_item())?;\n         match target {\n-            LangItemTarget::TraitId(t) => Some(t),\n+            LangItemTarget::Trait(t) => Some(t),\n             _ => None,\n         }\n     }"}, {"sha": "396cba89b67d74403aadee4eb290f6731a7c7268", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -11,6 +11,7 @@ use hir_def::{\n         GenericParams, TypeOrConstParamData, TypeParamProvenance, WherePredicate,\n         WherePredicateTypeTarget,\n     },\n+    lang_item::LangItem,\n     resolver::{HasResolver, TypeNs},\n     type_ref::{TraitBoundModifier, TypeRef},\n     ConstParamId, FunctionId, GenericDefId, ItemContainerId, Lookup, TraitId, TypeAliasId,\n@@ -21,17 +22,16 @@ use intern::Interned;\n use itertools::Either;\n use rustc_hash::FxHashSet;\n use smallvec::{smallvec, SmallVec};\n-use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n     [\n-        db.lang_item(krate, SmolStr::new_inline(\"fn\")),\n-        db.lang_item(krate, SmolStr::new_inline(\"fn_mut\")),\n-        db.lang_item(krate, SmolStr::new_inline(\"fn_once\")),\n+        db.lang_item(krate, LangItem::Fn),\n+        db.lang_item(krate, LangItem::FnMut),\n+        db.lang_item(krate, LangItem::FnOnce),\n     ]\n     .into_iter()\n     .flatten()"}, {"sha": "0d19420127f54fd171dccb521161b1ed0db9c900", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -4,6 +4,7 @@ use hir_def::{\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n+    lang_item::LangItem,\n     type_ref::{TypeBound, TypeRef},\n     AdtId, GenericDefId,\n };\n@@ -14,7 +15,6 @@ use hir_ty::{\n     },\n     Interner, TraitRefExt, WhereClause,\n };\n-use syntax::SmolStr;\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n@@ -261,8 +261,7 @@ impl HirDisplay for TypeParam {\n             bounds.iter().cloned().map(|b| b.substitute(Interner, &substs)).collect();\n         let krate = self.id.parent().krate(f.db).id;\n         let sized_trait =\n-            f.db.lang_item(krate, SmolStr::new_inline(\"sized\"))\n-                .and_then(|lang_item| lang_item.as_trait());\n+            f.db.lang_item(krate, LangItem::Sized).and_then(|lang_item| lang_item.as_trait());\n         let has_only_sized_bound = predicates.iter().all(move |pred| match pred.skip_binders() {\n             WhereClause::Implemented(it) => Some(it.hir_trait_id()) == sized_trait,\n             _ => false,"}, {"sha": "6ec39dfd73fd5177388c579d3670afd0191712ac", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -44,7 +44,7 @@ use hir_def::{\n     expr::{BindingAnnotation, ExprOrPatId, LabelId, Pat, PatId},\n     generics::{TypeOrConstParamData, TypeParamProvenance},\n     item_tree::ItemTreeNode,\n-    lang_item::LangItemTarget,\n+    lang_item::{LangItem, LangItemTarget},\n     layout::{Layout, LayoutError, ReprOptions},\n     nameres::{self, diagnostics::DefDiagnostic},\n     per_ns::PerNs,\n@@ -1836,7 +1836,7 @@ pub struct Trait {\n \n impl Trait {\n     pub fn lang(db: &dyn HirDatabase, krate: Crate, name: &Name) -> Option<Trait> {\n-        db.lang_item(krate.into(), name.to_smol_str())\n+        db.lang_item(krate.into(), LangItem::from_name(name)?)\n             .and_then(LangItemTarget::as_trait)\n             .map(Into::into)\n     }\n@@ -3009,16 +3009,15 @@ impl Type {\n     /// This function is used in `.await` syntax completion.\n     pub fn impls_into_future(&self, db: &dyn HirDatabase) -> bool {\n         let trait_ = db\n-            .lang_item(self.env.krate, SmolStr::new_inline(\"into_future\"))\n+            .lang_item(self.env.krate, LangItem::IntoFutureIntoFuture)\n             .and_then(|it| {\n                 let into_future_fn = it.as_function()?;\n                 let assoc_item = as_assoc_item(db, AssocItem::Function, into_future_fn)?;\n                 let into_future_trait = assoc_item.containing_trait_or_trait_impl(db)?;\n                 Some(into_future_trait.id)\n             })\n             .or_else(|| {\n-                let future_trait =\n-                    db.lang_item(self.env.krate, SmolStr::new_inline(\"future_trait\"))?;\n+                let future_trait = db.lang_item(self.env.krate, LangItem::Future)?;\n                 future_trait.as_trait()\n             });\n \n@@ -3111,9 +3110,9 @@ impl Type {\n     }\n \n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n-        let lang_item = db.lang_item(self.env.krate, SmolStr::new_inline(\"copy\"));\n+        let lang_item = db.lang_item(self.env.krate, LangItem::Copy);\n         let copy_trait = match lang_item {\n-            Some(LangItemTarget::TraitId(it)) => it,\n+            Some(LangItemTarget::Trait(it)) => it,\n             _ => return false,\n         };\n         self.impls_trait(db, copy_trait.into(), &[])"}, {"sha": "5e0c9933a7b6be762406ca917bb26ef4f2de7531", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -17,6 +17,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    lang_item::LangItem,\n     macro_id_to_def_id,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n@@ -37,7 +38,7 @@ use hir_ty::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    method_resolution::{self, lang_names_for_bin_op},\n+    method_resolution::{self, lang_items_for_bin_op},\n     Adjustment, InferenceResult, Interner, Substitution, Ty, TyExt, TyKind, TyLoweringContext,\n };\n use itertools::Itertools;\n@@ -294,12 +295,8 @@ impl SourceAnalyzer {\n             }\n         }\n \n-        let future_trait = db\n-            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n-            .as_trait()?;\n-        let poll_fn = db\n-            .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n-            .as_function()?;\n+        let future_trait = db.lang_item(self.resolver.krate(), LangItem::Future)?.as_trait()?;\n+        let poll_fn = db.lang_item(self.resolver.krate(), LangItem::FuturePoll)?.as_function()?;\n         // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n@@ -311,14 +308,14 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         prefix_expr: &ast::PrefixExpr,\n     ) -> Option<FunctionId> {\n-        let lang_item_name = match prefix_expr.op_kind()? {\n-            ast::UnaryOp::Deref => name![deref],\n-            ast::UnaryOp::Not => name![not],\n-            ast::UnaryOp::Neg => name![neg],\n+        let (lang_item, fn_name) = match prefix_expr.op_kind()? {\n+            ast::UnaryOp::Deref => (LangItem::Deref, name![deref]),\n+            ast::UnaryOp::Not => (LangItem::Not, name![not]),\n+            ast::UnaryOp::Neg => (LangItem::Neg, name![neg]),\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?)?;\n \n-        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, lang_item, &fn_name)?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n@@ -334,9 +331,7 @@ impl SourceAnalyzer {\n         let base_ty = self.ty_of_expr(db, &index_expr.base()?)?;\n         let index_ty = self.ty_of_expr(db, &index_expr.index()?)?;\n \n-        let lang_item_name = name![index];\n-\n-        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, LangItem::Index, &name![index])?;\n         // HACK: subst for all methods coincides with that for their trait because the methods\n         // don't have any generic parameters, so we skip building another subst for the methods.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n@@ -355,8 +350,8 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?)?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?)?;\n \n-        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n-            .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n+        let (op_trait, op_fn) = lang_items_for_bin_op(op)\n+            .and_then(|(name, lang_item)| self.lang_trait_fn(db, lang_item, &name))?;\n         // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n         // doesn't have any generic parameters, so we skip building another subst for `index()`.\n         let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n@@ -374,8 +369,7 @@ impl SourceAnalyzer {\n     ) -> Option<FunctionId> {\n         let ty = self.ty_of_expr(db, &try_expr.expr()?)?;\n \n-        let op_fn =\n-            db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n+        let op_fn = db.lang_item(self.resolver.krate(), LangItem::TryTraitBranch)?.as_function()?;\n         let op_trait = match op_fn.lookup(db.upcast()).container {\n             ItemContainerId::TraitId(id) => id,\n             _ => return None,\n@@ -821,10 +815,10 @@ impl SourceAnalyzer {\n     fn lang_trait_fn(\n         &self,\n         db: &dyn HirDatabase,\n-        lang_trait: &Name,\n+        lang_trait: LangItem,\n         method_name: &Name,\n     ) -> Option<(TraitId, FunctionId)> {\n-        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait)?.as_trait()?;\n         let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n         Some((trait_id, fn_id))\n     }"}, {"sha": "046786580e7a49d6a0d7fdd4d594924b389df417", "filename": "crates/project-model/src/sysroot.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fproject-model%2Fsrc%2Fsysroot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fsysroot.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -7,6 +7,7 @@\n use std::{env, fs, iter, ops, path::PathBuf, process::Command};\n \n use anyhow::{format_err, Result};\n+use base_db::CrateName;\n use la_arena::{Arena, Idx};\n use paths::{AbsPath, AbsPathBuf};\n use rustc_hash::FxHashMap;\n@@ -50,14 +51,16 @@ impl Sysroot {\n         &self.src_root\n     }\n \n-    pub fn public_deps(&self) -> impl Iterator<Item = (&'static str, SysrootCrate, bool)> + '_ {\n+    pub fn public_deps(&self) -> impl Iterator<Item = (CrateName, SysrootCrate, bool)> + '_ {\n         // core is added as a dependency before std in order to\n         // mimic rustcs dependency order\n         [\"core\", \"alloc\", \"std\"]\n             .into_iter()\n             .zip(iter::repeat(true))\n             .chain(iter::once((\"test\", false)))\n-            .filter_map(move |(name, prelude)| Some((name, self.by_name(name)?, prelude)))\n+            .filter_map(move |(name, prelude)| {\n+                Some((CrateName::new(name).unwrap(), self.by_name(name)?, prelude))\n+            })\n     }\n \n     pub fn proc_macro(&self) -> Option<SysrootCrate> {"}, {"sha": "755bf95199906ce69945f227be296189782244ac", "filename": "crates/project-model/src/workspace.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15358818363f66fc8b99e3711e6eb99a5e8684b9/crates%2Fproject-model%2Fsrc%2Fworkspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproject-model%2Fsrc%2Fworkspace.rs?ref=15358818363f66fc8b99e3711e6eb99a5e8684b9", "patch": "@@ -1162,9 +1162,7 @@ fn sysroot_to_crate_graph(\n     let public_deps = SysrootPublicDeps {\n         deps: sysroot\n             .public_deps()\n-            .map(|(name, idx, prelude)| {\n-                (CrateName::new(name).unwrap(), sysroot_crates[&idx], prelude)\n-            })\n+            .map(|(name, idx, prelude)| (name, sysroot_crates[&idx], prelude))\n             .collect::<Vec<_>>(),\n     };\n "}]}