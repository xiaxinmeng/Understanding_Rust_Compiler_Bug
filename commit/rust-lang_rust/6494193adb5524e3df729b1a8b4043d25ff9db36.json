{"sha": "6494193adb5524e3df729b1a8b4043d25ff9db36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0OTQxOTNhZGI1NTI0ZTNkZjcyOWIxYThiNDA0M2QyNWZmOWRiMzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-23T14:59:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-23T14:59:26Z"}, "message": "Merge #9681\n\n9681: Respect `#[doc(hidden)]` in dot-completion r=jonas-schievink a=jonas-schievink\n\nThis adds `CompletionContext::is_visible` as a convenience method that checks visibility, presence of `doc(hidden)`, and whether the completed item is in the same crate as the completion site or not. We only complete `doc(hidden)` items from the same crate.\r\n\r\nThis doesn't yet work for *all* completions: `qualified_path` completions use `Module::scope` and `ScopeDef`, which doesn't work with this.\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/7718\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "000d6df6aeee4ba77d888e792fb416c502425cfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/000d6df6aeee4ba77d888e792fb416c502425cfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6494193adb5524e3df729b1a8b4043d25ff9db36", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg+tlOCRBK7hj4Ov3rIwAAmYMIAKCuo1nLis3yEvPTrn1YY5FQ\nQHzzFLLPl525poBDv1GigPMXyxTQuZg+EtaRzULXG9a9Eol9ZmHO/K8774+dppDq\nybmAUZh9g/eZqF+tv6eCTcvk38415axyU5720ftTd1ivVqTH4e6WXt5lhTPhtLTw\nMowf6sJ5d+y2ba0PrrULfAxPKFQUu7mNO9A3hMFZiit7sEU5DkrMgihTSBH9Fuf3\nPQv2EisA5M3X4wBVufmF+OcackQHpfy716CToLxKvNV3dTQ+elAOK4uJ5OPTLzPw\nO4rJlwz0XChP+cu9hOToKIvl8yc1jS36vFbtSuheucSh6mL3WoeetkP5CNgnrIE=\n=J7DA\n-----END PGP SIGNATURE-----\n", "payload": "tree 000d6df6aeee4ba77d888e792fb416c502425cfb\nparent 4107106e674ae699ba1b5d50e44e6c8c3f37698b\nparent c8d915e2ea704ab349600b81bdad18e75d67cbd6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1627052366 +0000\ncommitter GitHub <noreply@github.com> 1627052366 +0000\n\nMerge #9681\n\n9681: Respect `#[doc(hidden)]` in dot-completion r=jonas-schievink a=jonas-schievink\n\nThis adds `CompletionContext::is_visible` as a convenience method that checks visibility, presence of `doc(hidden)`, and whether the completed item is in the same crate as the completion site or not. We only complete `doc(hidden)` items from the same crate.\r\n\r\nThis doesn't yet work for *all* completions: `qualified_path` completions use `Module::scope` and `ScopeDef`, which doesn't work with this.\r\n\r\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/7718\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6494193adb5524e3df729b1a8b4043d25ff9db36", "html_url": "https://github.com/rust-lang/rust/commit/6494193adb5524e3df729b1a8b4043d25ff9db36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6494193adb5524e3df729b1a8b4043d25ff9db36/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4107106e674ae699ba1b5d50e44e6c8c3f37698b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4107106e674ae699ba1b5d50e44e6c8c3f37698b", "html_url": "https://github.com/rust-lang/rust/commit/4107106e674ae699ba1b5d50e44e6c8c3f37698b"}, {"sha": "c8d915e2ea704ab349600b81bdad18e75d67cbd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8d915e2ea704ab349600b81bdad18e75d67cbd6", "html_url": "https://github.com/rust-lang/rust/commit/c8d915e2ea704ab349600b81bdad18e75d67cbd6"}], "stats": {"total": 149, "additions": 136, "deletions": 13}, "files": [{"sha": "9332cfc06749155978ff06a44a1f3557fc3752c9", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=6494193adb5524e3df729b1a8b4043d25ff9db36", "patch": "@@ -11,8 +11,8 @@ use hir_ty::db::HirDatabase;\n use syntax::ast;\n \n use crate::{\n-    Adt, Const, ConstParam, Enum, Field, Function, GenericParam, Impl, LifetimeParam, MacroDef,\n-    Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n+    Adt, AssocItem, Const, ConstParam, Enum, Field, Function, GenericParam, Impl, LifetimeParam,\n+    MacroDef, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n };\n \n pub trait HasAttrs {\n@@ -86,6 +86,37 @@ macro_rules! impl_has_attrs_enum {\n impl_has_attrs_enum![Struct, Union, Enum for Adt];\n impl_has_attrs_enum![TypeParam, ConstParam, LifetimeParam for GenericParam];\n \n+impl HasAttrs for AssocItem {\n+    fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner {\n+        match self {\n+            AssocItem::Function(it) => it.attrs(db),\n+            AssocItem::Const(it) => it.attrs(db),\n+            AssocItem::TypeAlias(it) => it.attrs(db),\n+        }\n+    }\n+\n+    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n+        match self {\n+            AssocItem::Function(it) => it.docs(db),\n+            AssocItem::Const(it) => it.docs(db),\n+            AssocItem::TypeAlias(it) => it.docs(db),\n+        }\n+    }\n+\n+    fn resolve_doc_path(\n+        self,\n+        db: &dyn HirDatabase,\n+        link: &str,\n+        ns: Option<Namespace>,\n+    ) -> Option<ModuleDef> {\n+        match self {\n+            AssocItem::Function(it) => it.resolve_doc_path(db, link, ns),\n+            AssocItem::Const(it) => it.resolve_doc_path(db, link, ns),\n+            AssocItem::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n+        }\n+    }\n+}\n+\n fn resolve_doc_path(\n     db: &dyn HirDatabase,\n     def: AttrDefId,"}, {"sha": "9673885e739491f72aaa8aefc8e5b1a6cfe85ade", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=6494193adb5524e3df729b1a8b4043d25ff9db36", "patch": "@@ -2744,3 +2744,32 @@ pub trait HasVisibility {\n         vis.is_visible_from(db.upcast(), module.id)\n     }\n }\n+\n+/// Trait for obtaining the defining crate of an item.\n+pub trait HasCrate {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate;\n+}\n+\n+impl<T: hir_def::HasModule> HasCrate for T {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db.upcast()).krate().into()\n+    }\n+}\n+\n+impl HasCrate for AssocItem {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n+    }\n+}\n+\n+impl HasCrate for Field {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.parent_def(db).module(db).krate()\n+    }\n+}\n+\n+impl HasCrate for Function {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n+    }\n+}"}, {"sha": "e79b301c8c3ba40732a6ecc30606972cb915e4b8", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=6494193adb5524e3df729b1a8b4043d25ff9db36", "patch": "@@ -12,7 +12,7 @@ use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n-use mbe::ast_to_token_tree;\n+use mbe::{ast_to_token_tree, DelimiterKind};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n@@ -290,6 +290,13 @@ impl Attrs {\n             Some(Documentation(buf))\n         }\n     }\n+\n+    pub fn has_doc_hidden(&self) -> bool {\n+        self.by_key(\"doc\").tt_values().any(|tt| {\n+            tt.delimiter_kind() == Some(DelimiterKind::Parenthesis) &&\n+                matches!(&*tt.token_trees, [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"hidden\")\n+        })\n+    }\n }\n \n impl AttrsWithOwner {"}, {"sha": "97be0f0e4fa08a1d769c6a8106755554508ec912", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=6494193adb5524e3df729b1a8b4043d25ff9db36", "patch": "@@ -1,7 +1,7 @@\n //! Completes references after dot (fields and method calls).\n \n use either::Either;\n-use hir::{HasVisibility, ScopeDef};\n+use hir::ScopeDef;\n use rustc_hash::FxHashSet;\n \n use crate::{context::CompletionContext, patterns::ImmediateLocation, Completions};\n@@ -63,9 +63,7 @@ fn complete_fields(\n ) {\n     for receiver in receiver.autoderef(ctx.db) {\n         for (field, ty) in receiver.fields(ctx.db) {\n-            if ctx.scope.module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n-                // Skip private field. FIXME: If the definition location of the\n-                // field is editable, we should show the completion\n+            if !ctx.is_visible(&field) {\n                 continue;\n             }\n             f(Either::Left(field), ty);\n@@ -87,7 +85,7 @@ fn complete_methods(\n         let traits_in_scope = ctx.scope.traits_in_scope();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n             if func.self_param(ctx.db).is_some()\n-                && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n+                && ctx.is_visible(&func)\n                 && seen_methods.insert(func.name(ctx.db))\n             {\n                 f(func);\n@@ -210,6 +208,33 @@ fn foo(a: A) { a.$0 }\n         );\n     }\n \n+    #[test]\n+    fn test_doc_hidden_filtering() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn foo(a: dep::A) { a.$0 }\n+//- /dep.rs crate:dep\n+pub struct A {\n+    #[doc(hidden)]\n+    pub hidden_field: u32,\n+    pub pub_field: u32,\n+}\n+\n+impl A {\n+    pub fn pub_method(&self) {}\n+\n+    #[doc(hidden)]\n+    pub fn hidden_method(&self) {}\n+}\n+            \"#,\n+            expect![[r#\"\n+                fd pub_field    u32\n+                me pub_method() fn(&self)\n+            \"#]],\n+        )\n+    }\n+\n     #[test]\n     fn test_union_field_completion() {\n         check("}, {"sha": "608398584dff4e5bc3f365b80150abbc2a5cc326", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=6494193adb5524e3df729b1a8b4043d25ff9db36", "patch": "@@ -2,7 +2,6 @@\n \n use std::iter;\n \n-use hir::HasVisibility;\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n@@ -120,6 +119,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     _ => true,\n                 };\n \n+                // FIXME: respect #[doc(hidden)] (see `CompletionContext::is_visible`)\n                 if add_resolution {\n                     acc.add_resolution(ctx, name, &def);\n                 }\n@@ -163,7 +163,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope.traits_in_scope();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n-                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    if !ctx.is_visible(&item) {\n                         return None;\n                     }\n                     add_assoc_item(acc, ctx, item);\n@@ -172,7 +172,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n                 // Iterate assoc types separately\n                 ty.iterate_assoc_items(ctx.db, krate, |item| {\n-                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    if !ctx.is_visible(&item) {\n                         return None;\n                     }\n                     if let hir::AssocItem::TypeAlias(ty) = item {\n@@ -185,7 +185,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n             // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n             for item in t.items(ctx.db) {\n-                if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                if !ctx.is_visible(&item) {\n                     continue;\n                 }\n                 add_assoc_item(acc, ctx, item);\n@@ -206,7 +206,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 let traits_in_scope = ctx.scope.traits_in_scope();\n                 let mut seen = FxHashSet::default();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n-                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    if !ctx.is_visible(&item) {\n                         return None;\n                     }\n "}, {"sha": "a056b5405a52c6e5e64de23f668308813e74b700", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6494193adb5524e3df729b1a8b4043d25ff9db36/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=6494193adb5524e3df729b1a8b4043d25ff9db36", "patch": "@@ -361,6 +361,37 @@ impl<'a> CompletionContext<'a> {\n         self.path_context.as_ref().and_then(|it| it.qualifier.as_ref())\n     }\n \n+    /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n+    pub(crate) fn is_visible<I>(&self, item: &I) -> bool\n+    where\n+        I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy,\n+    {\n+        self.is_visible_impl(&item.visibility(self.db), &item.attrs(self.db), item.krate(self.db))\n+    }\n+\n+    fn is_visible_impl(\n+        &self,\n+        vis: &hir::Visibility,\n+        attrs: &hir::Attrs,\n+        defining_crate: hir::Crate,\n+    ) -> bool {\n+        let module = match self.scope.module() {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+        if !vis.is_visible_from(self.db, module.into()) {\n+            // FIXME: if the definition location is editable, also show private items\n+            return false;\n+        }\n+\n+        if module.krate() != defining_crate && attrs.has_doc_hidden() {\n+            // `doc(hidden)` items are only completed within the defining crate.\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n     fn fill_impl_def(&mut self) {\n         self.impl_def = self\n             .sema"}]}