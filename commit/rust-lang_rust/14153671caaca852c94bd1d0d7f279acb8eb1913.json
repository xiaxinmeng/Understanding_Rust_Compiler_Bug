{"sha": "14153671caaca852c94bd1d0d7f279acb8eb1913", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MTUzNjcxY2FhY2E4NTJjOTRiZDFkMGQ3ZjI3OWFjYjhlYjE5MTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-03T16:17:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-03T16:17:25Z"}, "message": "Merge #9128\n\n9128: feat: expand procedural attribute macros r=jonas-schievink a=jonas-schievink\n\nThis adds experimental support for attribute macros. They can be enabled by setting `rust-analyzer.experimental.procAttrMacros` to `true`.\r\n\r\nKnown issues:\r\n* Tokens aren't remapped, presumably because we edit the input syntax tree (this causes IDE features to not work inside items with attribute macros on them)\r\n* Macro errors aren't reported correctly\r\n\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/8971\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8964 / https://github.com/la10736/rstest/issues/120\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/2984\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5412\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6029\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6687\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/issues/6740 is still not fixed \u2013 we now expand `#[proc_macro_hack]`, but fail to expand the resulting `proc_macro_call!()` macro.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "eb377999a5e8677c210791440b18593f909198e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb377999a5e8677c210791440b18593f909198e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14153671caaca852c94bd1d0d7f279acb8eb1913", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJguQCVCRBK7hj4Ov3rIwAAcqAIAE6ZQoV3Uq+g3Mfmi3dlCjw0\n2qrzIHQiS8ylvyeH3HHCGhQUVHcOobrJkAwCA5AGyiiBBlF9nxc2JZpkNrBvLYci\nsMMcHVLGXxfUuwICvGP8fsGQUkvxxOj3ZdM552Rdxik4S0jESBdBZonYbmRXQqYb\n0xs9XUYaqeLHS1mvXsLyq3vOcInVU4jDaghwfPY849HUz0tBBdue28XR2ryH1MDm\nq+OguOKEDGUOxQsAz1fcs/YV6iGa85vRkgQeJ6OOwXB59jHf2ULBCmqtyacBMV4V\nMb0sE3fqYUuvSiv2bbNBH130RVabI72rkcG9sYD1xmWAr2IYFqWjCfWU9hla3VE=\n=Rg4r\n-----END PGP SIGNATURE-----\n", "payload": "tree eb377999a5e8677c210791440b18593f909198e6\nparent 7f9c4a59d9a84cd8c734286937439b5cd215be27\nparent 17565f4deafab800d8d87208cff1e27d028e9b0e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622737045 +0000\ncommitter GitHub <noreply@github.com> 1622737045 +0000\n\nMerge #9128\n\n9128: feat: expand procedural attribute macros r=jonas-schievink a=jonas-schievink\n\nThis adds experimental support for attribute macros. They can be enabled by setting `rust-analyzer.experimental.procAttrMacros` to `true`.\r\n\r\nKnown issues:\r\n* Tokens aren't remapped, presumably because we edit the input syntax tree (this causes IDE features to not work inside items with attribute macros on them)\r\n* Macro errors aren't reported correctly\r\n\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/8971\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/8964 / https://github.com/la10736/rstest/issues/120\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/2984\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/5412\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6029\r\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/6687\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/issues/6740 is still not fixed \u2013 we now expand `#[proc_macro_hack]`, but fail to expand the resulting `proc_macro_call!()` macro.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14153671caaca852c94bd1d0d7f279acb8eb1913", "html_url": "https://github.com/rust-lang/rust/commit/14153671caaca852c94bd1d0d7f279acb8eb1913", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14153671caaca852c94bd1d0d7f279acb8eb1913/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9c4a59d9a84cd8c734286937439b5cd215be27", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9c4a59d9a84cd8c734286937439b5cd215be27", "html_url": "https://github.com/rust-lang/rust/commit/7f9c4a59d9a84cd8c734286937439b5cd215be27"}, {"sha": "17565f4deafab800d8d87208cff1e27d028e9b0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/17565f4deafab800d8d87208cff1e27d028e9b0e", "html_url": "https://github.com/rust-lang/rust/commit/17565f4deafab800d8d87208cff1e27d028e9b0e"}], "stats": {"total": 269, "additions": 234, "deletions": 35}, "files": [{"sha": "b43d61d0e8bb74fe8357fa78f4ab3d14febf5eae", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -534,6 +534,18 @@ impl Module {\n                                 Some(derive_name.clone()),\n                             )\n                         }\n+                        MacroCallKind::Attr { ast_id, invoc_attr_index, attr_name, .. } => {\n+                            let node = ast_id.to_node(db.upcast());\n+                            let attr =\n+                                node.attrs().nth((*invoc_attr_index) as usize).unwrap_or_else(\n+                                    || panic!(\"cannot find attribute #{}\", invoc_attr_index),\n+                                );\n+                            (\n+                                ast_id.file_id,\n+                                SyntaxNodePtr::from(AstPtr::new(&attr)),\n+                                Some(attr_name.clone()),\n+                            )\n+                        }\n                     };\n                     sink.push(UnresolvedProcMacro {\n                         file,\n@@ -558,7 +570,9 @@ impl Module {\n                             let node = ast_id.to_node(db.upcast());\n                             (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n                         }\n-                        MacroCallKind::Derive { ast_id, .. } => {\n+                        MacroCallKind::Derive { ast_id, .. }\n+                        | MacroCallKind::Attr { ast_id, .. } => {\n+                            // FIXME: point to the attribute instead, this creates very large diagnostics\n                             let node = ast_id.to_node(db.upcast());\n                             (ast_id.file_id, SyntaxNodePtr::from(AstPtr::new(&node)))\n                         }"}, {"sha": "39c7f84f7e4fda8c6967b6b128ce66a07d35f3b7", "filename": "crates/hir_def/src/builtin_attr.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbuiltin_attr.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The actual definitions were copied from rustc's `compiler/rustc_feature/src/builtin_attrs.rs`.\n //!\n-//! It was last synchronized with upstream commit 2225ee1b62ff089917434aefd9b2bf509cfa087f.\n+//! It was last synchronized with upstream commit 835150e70288535bc57bb624792229b9dc94991d.\n //!\n //! The macros were adjusted to only expand to the attribute name, since that is all we need to do\n //! name resolution, and `BUILTIN_ATTRIBUTES` is almost entirely unchanged from the original, to\n@@ -58,7 +58,6 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     ungated!(reexport_test_harness_main, Normal, template!(NameValueStr: \"name\")),\n \n     // Macros:\n-    ungated!(derive, Normal, template!(List: \"Trait1, Trait2, ...\")),\n     ungated!(automatically_derived, Normal, template!(Word)),\n     // FIXME(#14407)\n     ungated!(macro_use, Normal, template!(Word, List: \"name1, name2, ...\")),\n@@ -98,8 +97,8 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(List: r#\"name = \"...\", /*opt*/ kind = \"dylib|static|...\", /*opt*/ wasm_import_module = \"...\"\"#),\n     ),\n     ungated!(link_name, AssumedUsed, template!(NameValueStr: \"name\")),\n-    ungated!(no_link, Normal, template!(Word)),\n-    ungated!(repr, Normal, template!(List: \"C\")),\n+    ungated!(no_link, AssumedUsed, template!(Word)),\n+    ungated!(repr, AssumedUsed, template!(List: \"C\")),\n     ungated!(export_name, AssumedUsed, template!(NameValueStr: \"name\")),\n     ungated!(link_section, AssumedUsed, template!(NameValueStr: \"name\")),\n     ungated!(no_mangle, AssumedUsed, template!(Word)),\n@@ -112,6 +111,10 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         const_eval_limit, CrateLevel, template!(NameValueStr: \"N\"), const_eval_limit,\n         experimental!(const_eval_limit)\n     ),\n+    gated!(\n+        move_size_limit, CrateLevel, template!(NameValueStr: \"N\"), large_assignments,\n+        experimental!(move_size_limit)\n+    ),\n \n     // Entry point:\n     ungated!(main, Normal, template!(Word)),\n@@ -140,6 +143,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(List: \"address, memory, thread\"),\n         experimental!(no_sanitize)\n     ),\n+    gated!(no_coverage, AssumedUsed, template!(Word), experimental!(no_coverage)),\n \n     // FIXME: #14408 assume docs are used since rustdoc looks at them.\n     ungated!(doc, AssumedUsed, template!(List: \"hidden|inline|...\", NameValueStr: \"string\")),\n@@ -150,11 +154,6 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n \n     // Linking:\n     gated!(naked, AssumedUsed, template!(Word), naked_functions, experimental!(naked)),\n-    gated!(\n-        link_args, Normal, template!(NameValueStr: \"args\"),\n-        \"the `link_args` attribute is experimental and not portable across platforms, \\\n-        it is recommended to use `#[link(name = \\\"foo\\\")] instead\",\n-    ),\n     gated!(\n         link_ordinal, AssumedUsed, template!(List: \"ordinal\"), raw_dylib,\n         experimental!(link_ordinal)\n@@ -172,7 +171,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         \"custom test frameworks are an unstable feature\",\n     ),\n     // RFC #1268\n-    gated!(marker, Normal, template!(Word), marker_trait_attr, experimental!(marker)),\n+    gated!(marker, AssumedUsed, template!(Word), marker_trait_attr, experimental!(marker)),\n     gated!(\n         thread_local, AssumedUsed, template!(Word),\n         \"`#[thread_local]` is an experimental feature, and does not currently handle destructors\",\n@@ -291,7 +290,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes, Macro related:\n     // ==========================================================================\n \n-    rustc_attr!(rustc_builtin_macro, AssumedUsed, template!(Word), IMPL_DETAIL),\n+    rustc_attr!(rustc_builtin_macro, AssumedUsed, template!(Word, NameValueStr: \"name\"), IMPL_DETAIL),\n     rustc_attr!(rustc_proc_macro_decls, Normal, template!(Word), INTERNAL_UNSTABLE),\n     rustc_attr!(\n         rustc_macro_transparency, AssumedUsed,\n@@ -319,7 +318,7 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // ==========================================================================\n \n     rustc_attr!(rustc_promotable, AssumedUsed, template!(Word), IMPL_DETAIL),\n-    rustc_attr!(rustc_args_required_const, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n+    rustc_attr!(rustc_legacy_const_generics, AssumedUsed, template!(List: \"N\"), INTERNAL_UNSTABLE),\n \n     // ==========================================================================\n     // Internal attributes, Layout related:\n@@ -380,13 +379,23 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         rustc_specialization_trait, Normal, template!(Word),\n         \"the `#[rustc_specialization_trait]` attribute is used to check specializations\"\n     ),\n+    rustc_attr!(\n+        rustc_main, Normal, template!(Word),\n+        \"the `#[rustc_main]` attribute is used internally to specify test entry point function\",\n+    ),\n+    rustc_attr!(\n+        rustc_skip_array_during_method_dispatch, Normal, template!(Word),\n+        \"the `#[rustc_skip_array_during_method_dispatch]` attribute is used to exclude a trait \\\n+        from method dispatch when the receiver is an array, for compatibility in editions < 2021.\"\n+    ),\n \n     // ==========================================================================\n     // Internal attributes, Testing:\n     // ==========================================================================\n \n     rustc_attr!(TEST, rustc_outlives, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word)),\n+    rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_variance, Normal, template!(Word)),\n     rustc_attr!(TEST, rustc_layout, Normal, template!(List: \"field1, field2, ...\")),\n     rustc_attr!(TEST, rustc_regions, Normal, template!(Word)),\n@@ -395,12 +404,9 @@ pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &[\n         template!(Word, List: \"delay_span_bug_from_inside_query\")\n     ),\n     rustc_attr!(TEST, rustc_dump_user_substs, AssumedUsed, template!(Word)),\n+    rustc_attr!(TEST, rustc_evaluate_where_clauses, AssumedUsed, template!(Word)),\n     rustc_attr!(TEST, rustc_if_this_changed, AssumedUsed, template!(Word, List: \"DepNode\")),\n     rustc_attr!(TEST, rustc_then_this_would_need, AssumedUsed, template!(List: \"DepNode\")),\n-    rustc_attr!(\n-        TEST, rustc_dirty, AssumedUsed,\n-        template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),\n-    ),\n     rustc_attr!(\n         TEST, rustc_clean, AssumedUsed,\n         template!(List: r#\"cfg = \"...\", /*opt*/ label = \"...\", /*opt*/ except = \"...\"\"#),"}, {"sha": "c977971cd484d1ec687e813f5d8c4809b1983b18", "filename": "crates/hir_def/src/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -51,6 +51,9 @@ pub trait InternDatabase: SourceDatabase {\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n+    #[salsa::input]\n+    fn enable_proc_attr_macros(&self) -> bool;\n+\n     #[salsa::invoke(ItemTree::file_item_tree_query)]\n     fn file_item_tree(&self, file_id: HirFileId) -> Arc<ItemTree>;\n "}, {"sha": "987485accc17c18f8491fd6e3a0f987418329bdd", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -55,6 +55,7 @@ use std::{\n     sync::Arc,\n };\n \n+use attr::Attr;\n use base_db::{impl_intern_key, salsa, CrateId};\n use hir_expand::{\n     ast_id_map::FileAstId,\n@@ -768,3 +769,42 @@ fn derive_macro_as_call_id(\n         .into();\n     Ok(res)\n }\n+\n+fn attr_macro_as_call_id(\n+    item_attr: &AstIdWithPath<ast::Item>,\n+    macro_attr: &Attr,\n+    db: &dyn db::DefDatabase,\n+    krate: CrateId,\n+    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+) -> Result<MacroCallId, UnresolvedMacro> {\n+    let def: MacroDefId = resolver(item_attr.path.clone())\n+        .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n+    let last_segment = item_attr\n+        .path\n+        .segments()\n+        .last()\n+        .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n+    let mut arg = match &macro_attr.input {\n+        Some(input) => match &**input {\n+            attr::AttrInput::Literal(_) => tt::Subtree::default(),\n+            attr::AttrInput::TokenTree(tt) => tt.clone(),\n+        },\n+        None => tt::Subtree::default(),\n+    };\n+    // The parentheses are always disposed here.\n+    arg.delimiter = None;\n+\n+    let res = def\n+        .as_lazy_macro(\n+            db.upcast(),\n+            krate,\n+            MacroCallKind::Attr {\n+                ast_id: item_attr.ast_id,\n+                attr_name: last_segment.to_string(),\n+                attr_args: arg,\n+                invoc_attr_index: macro_attr.id.ast_index,\n+            },\n+        )\n+        .into();\n+    Ok(res)\n+}"}, {"sha": "b2ce739bdbe14e9607c869592cc3e3a1cc7ad1a0", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -23,7 +23,7 @@ use syntax::ast;\n \n use crate::{\n     attr::{Attr, AttrId, AttrInput, Attrs},\n-    builtin_attr,\n+    attr_macro_as_call_id, builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n     intern::Interned,\n@@ -223,7 +223,7 @@ struct MacroDirective {\n enum MacroDirectiveKind {\n     FnLike { ast_id: AstIdWithPath<ast::MacroCall>, fragment: FragmentKind },\n     Derive { ast_id: AstIdWithPath<ast::Item>, derive_attr: AttrId },\n-    Attr { ast_id: AstIdWithPath<ast::Item>, attr: AttrId, mod_item: ModItem },\n+    Attr { ast_id: AstIdWithPath<ast::Item>, attr: Attr, mod_item: ModItem },\n }\n \n struct DefData<'a> {\n@@ -419,7 +419,7 @@ impl DefCollector<'_> {\n         let mut unresolved_macros = std::mem::replace(&mut self.unresolved_macros, Vec::new());\n         let pos = unresolved_macros.iter().position(|directive| {\n             if let MacroDirectiveKind::Attr { ast_id, mod_item, attr } = &directive.kind {\n-                self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), *attr);\n+                self.skip_attrs.insert(ast_id.ast_id.with_value(*mod_item), attr.id);\n \n                 let file_id = ast_id.ast_id.file_id;\n                 let item_tree = self.db.file_item_tree(file_id);\n@@ -1050,7 +1050,7 @@ impl DefCollector<'_> {\n                                 let file_id = ast_id.ast_id.file_id;\n                                 let item_tree = self.db.file_item_tree(file_id);\n                                 let mod_dir = self.mod_dirs[&directive.module_id].clone();\n-                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), *attr);\n+                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n                                 ModCollector {\n                                     def_collector: &mut *self,\n                                     macro_depth: directive.depth,\n@@ -1067,8 +1067,56 @@ impl DefCollector<'_> {\n                         }\n                     }\n \n+                    if !self.db.enable_proc_attr_macros() {\n+                        return true;\n+                    }\n+\n                     // Not resolved to a derive helper, so try to resolve as a macro.\n-                    // FIXME: not yet :)\n+                    match attr_macro_as_call_id(\n+                        ast_id,\n+                        attr,\n+                        self.db,\n+                        self.def_map.krate,\n+                        &resolver,\n+                    ) {\n+                        Ok(call_id) => {\n+                            let loc: MacroCallLoc = self.db.lookup_intern_macro(call_id);\n+                            if let MacroDefKind::ProcMacro(exp, ..) = &loc.def.kind {\n+                                if exp.is_dummy() {\n+                                    // Proc macros that cannot be expanded are treated as not\n+                                    // resolved, in order to fall back later.\n+                                    self.def_map.diagnostics.push(\n+                                        DefDiagnostic::unresolved_proc_macro(\n+                                            directive.module_id,\n+                                            loc.kind,\n+                                        ),\n+                                    );\n+\n+                                    let file_id = ast_id.ast_id.file_id;\n+                                    let item_tree = self.db.file_item_tree(file_id);\n+                                    let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                                    self.skip_attrs\n+                                        .insert(InFile::new(file_id, *mod_item), attr.id);\n+                                    ModCollector {\n+                                        def_collector: &mut *self,\n+                                        macro_depth: directive.depth,\n+                                        module_id: directive.module_id,\n+                                        file_id,\n+                                        item_tree: &item_tree,\n+                                        mod_dir,\n+                                    }\n+                                    .collect(&[*mod_item]);\n+\n+                                    // Remove the macro directive.\n+                                    return false;\n+                                }\n+                            }\n+                            resolved.push((directive.module_id, call_id, directive.depth));\n+                            res = ReachedFixedPoint::No;\n+                            return false;\n+                        }\n+                        Err(UnresolvedMacro { .. }) => (),\n+                    }\n                 }\n             }\n \n@@ -1628,7 +1676,7 @@ impl ModCollector<'_, '_> {\n                 self.def_collector.unresolved_macros.push(MacroDirective {\n                     module_id: self.module_id,\n                     depth: self.macro_depth + 1,\n-                    kind: MacroDirectiveKind::Attr { ast_id, attr: attr.id, mod_item },\n+                    kind: MacroDirectiveKind::Attr { ast_id, attr: attr.clone(), mod_item },\n                 });\n \n                 return Err(());"}, {"sha": "b20b066e24a1320fc4138dd4f45ab03c501f56d9", "filename": "crates/hir_def/src/test_db.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -30,12 +30,19 @@ use crate::{\n     crate::db::InternDatabaseStorage,\n     crate::db::DefDatabaseStorage\n )]\n-#[derive(Default)]\n pub(crate) struct TestDB {\n     storage: salsa::Storage<TestDB>,\n     events: Mutex<Option<Vec<salsa::Event>>>,\n }\n \n+impl Default for TestDB {\n+    fn default() -> Self {\n+        let mut this = Self { storage: Default::default(), events: Default::default() };\n+        this.set_enable_proc_attr_macros(true);\n+        this\n+    }\n+}\n+\n impl Upcast<dyn AstDatabase> for TestDB {\n     fn upcast(&self) -> &(dyn AstDatabase + 'static) {\n         &*self"}, {"sha": "3ebe194e405f3f028391944dc1e3f6bc686be8c2", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -13,8 +13,8 @@ use syntax::{\n \n use crate::{\n     ast_id_map::AstIdMap, hygiene::HygieneFrame, input::process_macro_input, BuiltinDeriveExpander,\n-    BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc, MacroDefId,\n-    MacroDefKind, MacroFile, ProcMacroExpander,\n+    BuiltinFnLikeExpander, HirFileId, HirFileIdRepr, MacroCallId, MacroCallKind, MacroCallLoc,\n+    MacroDefId, MacroDefKind, MacroFile, ProcMacroExpander,\n };\n \n /// Total limit on the number of tokens produced by any macro invocation.\n@@ -377,7 +377,12 @@ fn expand_proc_macro(\n         _ => unreachable!(),\n     };\n \n-    expander.expand(db, loc.krate, &macro_arg.0)\n+    let attr_arg = match &loc.kind {\n+        MacroCallKind::Attr { attr_args, .. } => Some(attr_args),\n+        _ => None,\n+    };\n+\n+    expander.expand(db, loc.krate, &macro_arg.0, attr_arg)\n }\n \n fn is_self_replicating(from: &SyntaxNode, to: &SyntaxNode) -> bool {"}, {"sha": "40116a479bda1922dc8dc4742586a8dce48a50f3", "filename": "crates/hir_expand/src/input.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Finput.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -28,6 +28,14 @@ pub(crate) fn process_macro_input(\n \n             remove_derives_up_to(item, derive_attr_index as usize).syntax().clone()\n         }\n+        MacroCallKind::Attr { invoc_attr_index, .. } => {\n+            let item = match ast::Item::cast(node.clone()) {\n+                Some(item) => item,\n+                None => return node,\n+            };\n+\n+            remove_attr_invoc(item, invoc_attr_index as usize).syntax().clone()\n+        }\n     }\n }\n \n@@ -46,6 +54,17 @@ fn remove_derives_up_to(item: ast::Item, attr_index: usize) -> ast::Item {\n     item\n }\n \n+/// Removes the attribute invoking an attribute macro from `item`.\n+fn remove_attr_invoc(item: ast::Item, attr_index: usize) -> ast::Item {\n+    let item = item.clone_for_update();\n+    let attr = item\n+        .attrs()\n+        .nth(attr_index)\n+        .unwrap_or_else(|| panic!(\"cannot find attribute #{}\", attr_index));\n+    attr.syntax().detach();\n+    item\n+}\n+\n #[cfg(test)]\n mod tests {\n     use base_db::fixture::WithFixture;"}, {"sha": "618f26b9546bf8af797f3d49a621fd664dd241df", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -258,14 +258,29 @@ pub enum MacroCallKind {\n         /// out-of-line modules, which may have attributes spread across 2 files!\n         derive_attr_index: u32,\n     },\n+    Attr {\n+        ast_id: AstId<ast::Item>,\n+        attr_name: String,\n+        attr_args: tt::Subtree,\n+        /// Syntactical index of the invoking `#[attribute]`.\n+        ///\n+        /// Outer attributes are counted first, then inner attributes. This does not support\n+        /// out-of-line modules, which may have attributes spread across 2 files!\n+        invoc_attr_index: u32,\n+    },\n }\n \n+// FIXME: attribute indices do not account for `cfg_attr`, which means that we'll strip the whole\n+// `cfg_attr` instead of just one of the attributes it expands to\n+\n impl MacroCallKind {\n     /// Returns the file containing the macro invocation.\n     fn file_id(&self) -> HirFileId {\n         match self {\n             MacroCallKind::FnLike { ast_id, .. } => ast_id.file_id,\n-            MacroCallKind::Derive { ast_id, .. } => ast_id.file_id,\n+            MacroCallKind::Derive { ast_id, .. } | MacroCallKind::Attr { ast_id, .. } => {\n+                ast_id.file_id\n+            }\n         }\n     }\n \n@@ -274,7 +289,7 @@ impl MacroCallKind {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }\n-            MacroCallKind::Derive { ast_id, .. } => {\n+            MacroCallKind::Derive { ast_id, .. } | MacroCallKind::Attr { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }\n         }\n@@ -285,14 +300,17 @@ impl MacroCallKind {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 Some(ast_id.to_node(db).token_tree()?.syntax().clone())\n             }\n-            MacroCallKind::Derive { ast_id, .. } => Some(ast_id.to_node(db).syntax().clone()),\n+            MacroCallKind::Derive { ast_id, .. } | MacroCallKind::Attr { ast_id, .. } => {\n+                Some(ast_id.to_node(db).syntax().clone())\n+            }\n         }\n     }\n \n     fn fragment_kind(&self) -> FragmentKind {\n         match self {\n             MacroCallKind::FnLike { fragment, .. } => *fragment,\n             MacroCallKind::Derive { .. } => FragmentKind::Items,\n+            MacroCallKind::Attr { .. } => FragmentKind::Items, // is this always correct?\n         }\n     }\n }"}, {"sha": "dbe1b446e01ac14015806a06e6d311f4135a641e", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -28,11 +28,16 @@ impl ProcMacroExpander {\n         Self { krate, proc_macro_id: None }\n     }\n \n+    pub fn is_dummy(&self) -> bool {\n+        self.proc_macro_id.is_none()\n+    }\n+\n     pub fn expand(\n         self,\n         db: &dyn AstDatabase,\n         calling_crate: CrateId,\n         tt: &tt::Subtree,\n+        attr_arg: Option<&tt::Subtree>,\n     ) -> Result<tt::Subtree, mbe::ExpandError> {\n         match self.proc_macro_id {\n             Some(id) => {\n@@ -46,7 +51,7 @@ impl ProcMacroExpander {\n                 // Proc macros have access to the environment variables of the invoking crate.\n                 let env = &krate_graph[calling_crate].env;\n \n-                proc_macro.expander.expand(&tt, None, &env).map_err(mbe::ExpandError::from)\n+                proc_macro.expander.expand(&tt, attr_arg, &env).map_err(mbe::ExpandError::from)\n             }\n             None => Err(mbe::ExpandError::UnresolvedProcMacro),\n         }"}, {"sha": "4640ea8211d53b665fcd88c4c4702176612ea1e2", "filename": "crates/hir_ty/src/test_db.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -22,11 +22,19 @@ use test_utils::extract_annotations;\n     hir_def::db::DefDatabaseStorage,\n     crate::db::HirDatabaseStorage\n )]\n-#[derive(Default)]\n pub(crate) struct TestDB {\n     storage: salsa::Storage<TestDB>,\n     events: Mutex<Option<Vec<salsa::Event>>>,\n }\n+\n+impl Default for TestDB {\n+    fn default() -> Self {\n+        let mut this = Self { storage: Default::default(), events: Default::default() };\n+        this.set_enable_proc_attr_macros(true);\n+        this\n+    }\n+}\n+\n impl fmt::Debug for TestDB {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"TestDB\").finish()"}, {"sha": "105607dca475272ad39b9a3d89c33ff2cfa8f480", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -93,6 +93,7 @@ impl RootDatabase {\n         db.set_crate_graph_with_durability(Default::default(), Durability::HIGH);\n         db.set_local_roots_with_durability(Default::default(), Durability::HIGH);\n         db.set_library_roots_with_durability(Default::default(), Durability::HIGH);\n+        db.set_enable_proc_attr_macros(Default::default());\n         db.update_lru_capacity(lru_capacity);\n         db\n     }"}, {"sha": "d1f3c1b06f55c687b92e6b6af47893231affeb04", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -126,6 +126,9 @@ config_data! {\n         /// and a blue icon in the `Problems Panel`.\n         diagnostics_warningsAsInfo: Vec<String> = \"[]\",\n \n+        /// Expand attribute macros.\n+        experimental_procAttrMacros: bool = \"false\",\n+\n         /// Controls file watching implementation.\n         files_watcher: String = \"\\\"client\\\"\",\n         /// These directories will be ignored by rust-analyzer.\n@@ -546,6 +549,9 @@ impl Config {\n         let path = self.data.procMacro_server.clone().or_else(|| std::env::current_exe().ok())?;\n         Some((path, vec![\"proc-macro\".into()]))\n     }\n+    pub fn expand_proc_attr_macros(&self) -> bool {\n+        self.data.experimental_procAttrMacros\n+    }\n     pub fn files(&self) -> FilesConfig {\n         FilesConfig {\n             watcher: match self.data.files_watcher.as_str() {"}, {"sha": "582a89667761e4fb606e4d022ddb13dc5636647d", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -119,12 +119,12 @@ impl GlobalState {\n \n         let analysis_host = AnalysisHost::new(config.lru_capacity());\n         let (flycheck_sender, flycheck_receiver) = unbounded();\n-        GlobalState {\n+        let mut this = GlobalState {\n             sender,\n             req_queue: ReqQueue::default(),\n             task_pool,\n             loader,\n-            config: Arc::new(config),\n+            config: Arc::new(config.clone()),\n             analysis_host,\n             diagnostics: Default::default(),\n             mem_docs: FxHashMap::default(),\n@@ -151,7 +151,10 @@ impl GlobalState {\n \n             fetch_build_data_queue: OpQueue::default(),\n             latest_requests: Default::default(),\n-        }\n+        };\n+        // Apply any required database inputs from the config.\n+        this.update_configuration(config);\n+        this\n     }\n \n     pub(crate) fn process_changes(&mut self) -> bool {"}, {"sha": "bd31d1d13dc067995ad3d4f52e4d85f117b9824b", "filename": "crates/rust-analyzer/src/reload.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -2,6 +2,7 @@\n use std::{mem, sync::Arc};\n \n use flycheck::{FlycheckConfig, FlycheckHandle};\n+use hir::db::DefDatabase;\n use ide::Change;\n use ide_db::base_db::{CrateGraph, SourceRoot, VfsPath};\n use project_model::{BuildDataCollector, BuildDataResult, ProcMacroClient, ProjectWorkspace};\n@@ -47,6 +48,11 @@ impl GlobalState {\n         } else if self.config.flycheck() != old_config.flycheck() {\n             self.reload_flycheck();\n         }\n+\n+        // Apply experimental feature flags.\n+        self.analysis_host\n+            .raw_database_mut()\n+            .set_enable_proc_attr_macros(self.config.expand_proc_attr_macros());\n     }\n     pub(crate) fn maybe_refresh(&mut self, changes: &[(AbsPathBuf, ChangeKind)]) {\n         if !changes.iter().any(|(path, kind)| is_interesting(path, *kind)) {"}, {"sha": "4eec8455df2319586a4db2e11247511e9c1c0a3b", "filename": "docs/user/generated_config.adoc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/docs%2Fuser%2Fgenerated_config.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/docs%2Fuser%2Fgenerated_config.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_config.adoc?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -181,6 +181,11 @@ List of warnings that should be displayed with info severity.\n The warnings will be indicated by a blue squiggly underline in code\n and a blue icon in the `Problems Panel`.\n --\n+[[rust-analyzer.experimental.procAttrMacros]]rust-analyzer.experimental.procAttrMacros (default: `false`)::\n++\n+--\n+Expand attribute macros.\n+--\n [[rust-analyzer.files.watcher]]rust-analyzer.files.watcher (default: `\"client\"`)::\n +\n --"}, {"sha": "bffc1e05b73e7633e179f8f562ba5c8825293854", "filename": "editors/code/package.json", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14153671caaca852c94bd1d0d7f279acb8eb1913/editors%2Fcode%2Fpackage.json", "raw_url": "https://github.com/rust-lang/rust/raw/14153671caaca852c94bd1d0d7f279acb8eb1913/editors%2Fcode%2Fpackage.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fpackage.json?ref=14153671caaca852c94bd1d0d7f279acb8eb1913", "patch": "@@ -617,6 +617,11 @@\n                         \"type\": \"string\"\n                     }\n                 },\n+                \"rust-analyzer.experimental.procAttrMacros\": {\n+                    \"markdownDescription\": \"Expand attribute macros.\",\n+                    \"default\": false,\n+                    \"type\": \"boolean\"\n+                },\n                 \"rust-analyzer.files.watcher\": {\n                     \"markdownDescription\": \"Controls file watching implementation.\",\n                     \"default\": \"client\","}]}