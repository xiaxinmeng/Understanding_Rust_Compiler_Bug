{"sha": "06e47688bf15d0215edbe05b21603062f6d2eb5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZTQ3Njg4YmYxNWQwMjE1ZWRiZTA1YjIxNjAzMDYyZjZkMmViNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-13T15:50:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-13T15:50:56Z"}, "message": "Auto merge of #73316 - Dylan-DPC:rollup-zgouwou, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #72932 (Clarify the behaviour of Pattern when used with methods like str::contains)\n - #73066 (Querify whether a type has structural equality (Take 2))\n - #73194 (Prefer the associated constants for pattern matching error)\n - #73241 (Add/update comments about MinGW late_link_args)\n - #73267 (Use the built cargo for cargotest.)\n - #73290 (Fix links when pinging notification groups)\n - #73302 (Adjusted some doctests in libcore to use `should_panic`.)\n - #73308 (pretty/asm.rs should only be tested for x86_64 and not AArch64)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "dea015bf136b986e4e1a93f5c0ee50318095113d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dea015bf136b986e4e1a93f5c0ee50318095113d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06e47688bf15d0215edbe05b21603062f6d2eb5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06e47688bf15d0215edbe05b21603062f6d2eb5d", "html_url": "https://github.com/rust-lang/rust/commit/06e47688bf15d0215edbe05b21603062f6d2eb5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06e47688bf15d0215edbe05b21603062f6d2eb5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fb612bd15bb3ef098fd24c20d0727de573b4410", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fb612bd15bb3ef098fd24c20d0727de573b4410", "html_url": "https://github.com/rust-lang/rust/commit/1fb612bd15bb3ef098fd24c20d0727de573b4410"}, {"sha": "8d97ccf954582b9040298fb0541aa7380a4db109", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d97ccf954582b9040298fb0541aa7380a4db109", "html_url": "https://github.com/rust-lang/rust/commit/8d97ccf954582b9040298fb0541aa7380a4db109"}], "stats": {"total": 534, "additions": 300, "deletions": 234}, "files": [{"sha": "aeabb227cf5e97d07c9a248dc328b1953aee6f30", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -154,6 +154,7 @@ impl Step for Cargotest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = builder.compiler(self.stage, self.host);\n         builder.ensure(compile::Rustc { compiler, target: compiler.host });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target: compiler.host });\n \n         // Note that this is a short, cryptic, and not scoped directory name. This\n         // is currently to minimize the length of path on Windows where we otherwise\n@@ -165,7 +166,7 @@ impl Step for Cargotest {\n         let mut cmd = builder.tool_cmd(Tool::CargoTest);\n         try_run(\n             builder,\n-            cmd.arg(&builder.initial_cargo)\n+            cmd.arg(&cargo)\n                 .arg(&out_dir)\n                 .env(\"RUSTC\", builder.rustc(compiler))\n                 .env(\"RUSTDOC\", builder.rustdoc(compiler)),"}, {"sha": "c4293ed7bcfe2a557f2204175d86fd84d48ed39b", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -778,18 +778,13 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// An example of panic:\n     ///\n-    /// ```\n+    /// ```should_panic\n     /// use std::cell::RefCell;\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(move || {\n-    ///    let c = RefCell::new(5);\n-    ///    let m = c.borrow_mut();\n     ///\n-    ///    let b = c.borrow(); // this causes a panic\n-    /// }).join();\n+    /// let c = RefCell::new(5);\n     ///\n-    /// assert!(result.is_err());\n+    /// let m = c.borrow_mut();\n+    /// let b = c.borrow(); // this causes a panic\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -858,18 +853,13 @@ impl<T: ?Sized> RefCell<T> {\n     ///\n     /// An example of panic:\n     ///\n-    /// ```\n+    /// ```should_panic\n     /// use std::cell::RefCell;\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(move || {\n-    ///    let c = RefCell::new(5);\n-    ///    let m = c.borrow();\n     ///\n-    ///    let b = c.borrow_mut(); // this causes a panic\n-    /// }).join();\n+    /// let c = RefCell::new(5);\n+    /// let m = c.borrow();\n     ///\n-    /// assert!(result.is_err());\n+    /// let b = c.borrow_mut(); // this causes a panic\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "d7e39946148ed793fd1eb0b175f275305f92df08", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -278,16 +278,11 @@ impl fmt::Display for CharTryFromError {\n ///\n /// Passing a large radix, causing a panic:\n ///\n-/// ```\n-/// use std::thread;\n+/// ```should_panic\n /// use std::char;\n ///\n-/// let result = thread::spawn(|| {\n-///     // this panics\n-///     let c = char::from_digit(1, 37);\n-/// }).join();\n-///\n-/// assert!(result.is_err());\n+/// // this panics\n+/// let c = char::from_digit(1, 37);\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "dd2f01c679f7347a33ac6409f1fef7fa1b13d3c0", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 17, "deletions": 45, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -229,16 +229,11 @@ impl char {\n     ///\n     /// Passing a large radix, causing a panic:\n     ///\n-    /// ```\n-    /// use std::thread;\n+    /// ```should_panic\n     /// use std::char;\n     ///\n-    /// let result = thread::spawn(|| {\n-    ///     // this panics\n-    ///     let c = char::from_digit(1, 37);\n-    /// }).join();\n-    ///\n-    /// assert!(result.is_err());\n+    /// // this panics\n+    /// char::from_digit(1, 37);\n     /// ```\n     #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n     #[inline]\n@@ -282,15 +277,9 @@ impl char {\n     ///\n     /// Passing a large radix, causing a panic:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     // this panics\n-    ///     '1'.is_digit(37);\n-    /// }).join();\n-    ///\n-    /// assert!(result.is_err());\n+    /// ```should_panic\n+    /// // this panics\n+    /// '1'.is_digit(37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -337,14 +326,9 @@ impl char {\n     ///\n     /// Passing a large radix, causing a panic:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     '1'.to_digit(37);\n-    /// }).join();\n-    ///\n-    /// assert!(result.is_err());\n+    /// ```should_panic\n+    /// // this panics\n+    /// '1'.to_digit(37);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -646,17 +630,11 @@ impl char {\n     ///\n     /// A buffer that's too small:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     let mut b = [0; 1];\n-    ///\n-    ///     // this panics\n-    ///    '\u00df'.encode_utf8(&mut b);\n-    /// }).join();\n+    /// ```should_panic\n+    /// let mut b = [0; 1];\n     ///\n-    /// assert!(result.is_err());\n+    /// // this panics\n+    /// '\u00df'.encode_utf8(&mut b);\n     /// ```\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]\n@@ -687,17 +665,11 @@ impl char {\n     ///\n     /// A buffer that's too small:\n     ///\n-    /// ```\n-    /// use std::thread;\n-    ///\n-    /// let result = thread::spawn(|| {\n-    ///     let mut b = [0; 1];\n-    ///\n-    ///     // this panics\n-    ///     '\ud835\udd4a'.encode_utf16(&mut b);\n-    /// }).join();\n+    /// ```should_panic\n+    /// let mut b = [0; 1];\n     ///\n-    /// assert!(result.is_err());\n+    /// // this panics\n+    /// '\ud835\udd4a'.encode_utf16(&mut b);\n     /// ```\n     #[stable(feature = \"unicode_encode_char\", since = \"1.15.0\")]\n     #[inline]"}, {"sha": "263d6b5efdff94ccac0cd2a3e511a87a272e066a", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -60,6 +60,43 @@ use crate::slice::memchr;\n /// The trait itself acts as a builder for an associated\n /// `Searcher` type, which does the actual work of finding\n /// occurrences of the pattern in a string.\n+///\n+/// Depending on the type of the pattern, the behaviour of methods like\n+/// [`str::find`] and [`str::contains`] can change. The table below describes\n+/// some of those behaviours.\n+///\n+/// | Pattern type             | Match condition                           |\n+/// |--------------------------|-------------------------------------------|\n+/// | `&str`                   | is substring                              |\n+/// | `char`                   | is contained in string                    |\n+/// | `&[char]                 | any char in slice is contained in string  |\n+/// | `F: FnMut(char) -> bool` | `F` returns `true` for a char in string   |\n+/// | `&&str`                  | is substring                              |\n+/// | `&String`                | is substring                              |\n+///\n+/// # Examples\n+/// ```\n+/// // &str\n+/// assert_eq!(\"abaaa\".find(\"ba\"), Some(1));\n+/// assert_eq!(\"abaaa\".find(\"bac\"), None);\n+///\n+/// // char\n+/// assert_eq!(\"abaaa\".find('a'), Some(0));\n+/// assert_eq!(\"abaaa\".find('b'), Some(1));\n+/// assert_eq!(\"abaaa\".find('c'), None);\n+///\n+/// // &[char]\n+/// assert_eq!(\"ab\".find(&['b', 'a'][..]), Some(0));\n+/// assert_eq!(\"abaaa\".find(&['a', 'z'][..]), Some(0));\n+/// assert_eq!(\"abaaa\".find(&['c', 'd'][..]), None);\n+///\n+/// // FnMut(char) -> bool\n+/// assert_eq!(\"abcdef_z\".find(|ch| ch > 'd' && ch < 'y'), Some(4));\n+/// assert_eq!(\"abcddd_z\".find(|ch| ch > 'd' && ch < 'y'), None);\n+/// ```\n+///\n+/// [`str::find`]: ../../../std/primitive.str.html#method.find\n+/// [`str::contains`]: ../../../std/primitive.str.html#method.contains\n pub trait Pattern<'a>: Sized {\n     /// Associated searcher for this pattern\n     type Searcher: Searcher<'a>;"}, {"sha": "be15e6c576f69379f628818b89adda626770167b", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -789,6 +789,17 @@ rustc_queries! {\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// Query backing `TyS::is_structural_eq_shallow`.\n+        ///\n+        /// This is only correct for ADTs. Call `is_structural_eq_shallow` to handle all types\n+        /// correctly.\n+        query has_structural_eq_impls(ty: Ty<'tcx>) -> bool {\n+            desc {\n+                \"computing whether `{:?}` implements `PartialStructuralEq` and `StructuralEq`\",\n+                ty\n+            }\n+        }\n+\n         /// A list of types where the ADT requires drop if and only if any of\n         /// those types require drop. If the ADT is known to always need drop\n         /// then `Err(AlwaysRequiresDrop)` is returned."}, {"sha": "d782dd07a65889c4dbc4548e1d99a34b0e50ef00", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -986,7 +986,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let ui_str = ui.name_str();\n                 if data == max {\n-                    p!(write(\"std::{}::MAX\", ui_str))\n+                    p!(write(\"{}::MAX\", ui_str))\n                 } else {\n                     if print_ty { p!(write(\"{}{}\", data, ui_str)) } else { p!(write(\"{}\", data)) }\n                 };\n@@ -999,8 +999,8 @@ pub trait PrettyPrinter<'tcx>:\n \n                 let i_str = i.name_str();\n                 match data {\n-                    d if d == min => p!(write(\"std::{}::MIN\", i_str)),\n-                    d if d == max => p!(write(\"std::{}::MAX\", i_str)),\n+                    d if d == min => p!(write(\"{}::MIN\", i_str)),\n+                    d if d == max => p!(write(\"{}::MAX\", i_str)),\n                     _ => {\n                         let data = sign_extend(data, size) as i128;\n                         if print_ty {"}, {"sha": "c61e27528cef14f4c604890eb0d3af35a9d9b358", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -778,6 +778,57 @@ impl<'tcx> ty::TyS<'tcx> {\n         }\n     }\n \n+    /// Returns `true` if equality for this type is both reflexive and structural.\n+    ///\n+    /// Reflexive equality for a type is indicated by an `Eq` impl for that type.\n+    ///\n+    /// Primitive types (`u32`, `str`) have structural equality by definition. For composite data\n+    /// types, equality for the type as a whole is structural when it is the same as equality\n+    /// between all components (fields, array elements, etc.) of that type. For ADTs, structural\n+    /// equality is indicated by an implementation of `PartialStructuralEq` and `StructuralEq` for\n+    /// that type.\n+    ///\n+    /// This function is \"shallow\" because it may return `true` for a composite type whose fields\n+    /// are not `StructuralEq`. For example, `[T; 4]` has structural equality regardless of `T`\n+    /// because equality for arrays is determined by the equality of each array element. If you\n+    /// want to know whether a given call to `PartialEq::eq` will proceed structurally all the way\n+    /// down, you will need to use a type visitor.\n+    #[inline]\n+    pub fn is_structural_eq_shallow(&'tcx self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind {\n+            // Look for an impl of both `PartialStructuralEq` and `StructuralEq`.\n+            Adt(..) => tcx.has_structural_eq_impls(self),\n+\n+            // Primitive types that satisfy `Eq`.\n+            Bool | Char | Int(_) | Uint(_) | Str | Never => true,\n+\n+            // Composite types that satisfy `Eq` when all of their fields do.\n+            //\n+            // Because this function is \"shallow\", we return `true` for these composites regardless\n+            // of the type(s) contained within.\n+            Ref(..) | Array(..) | Slice(_) | Tuple(..) => true,\n+\n+            // Raw pointers use bitwise comparison.\n+            RawPtr(_) | FnPtr(_) => true,\n+\n+            // Floating point numbers are not `Eq`.\n+            Float(_) => false,\n+\n+            // Conservatively return `false` for all others...\n+\n+            // Anonymous function types\n+            FnDef(..) | Closure(..) | Dynamic(..) | Generator(..) => false,\n+\n+            // Generic or inferred types\n+            //\n+            // FIXME(ecstaticmorse): Maybe we should `bug` here? This should probably only be\n+            // called for known, fully-monomorphized types.\n+            Projection(_) | Opaque(..) | Param(_) | Bound(..) | Placeholder(_) | Infer(_) => false,\n+\n+            Foreign(_) | GeneratorWitness(..) | Error => false,\n+        }\n+    }\n+\n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n         match (&a.kind, &b.kind) {\n             (&Adt(did_a, substs_a), &Adt(did_b, substs_b)) => {"}, {"sha": "936c1a84e142eb9a595c042c016dfe695eac7303", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -2,7 +2,6 @@\n //!\n //! See the `Qualif` trait for more info.\n \n-use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n@@ -137,10 +136,7 @@ impl Qualif for CustomEq {\n         substs: SubstsRef<'tcx>,\n     ) -> bool {\n         let ty = cx.tcx.mk_ty(ty::Adt(adt, substs));\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id.as_local().unwrap());\n-        cx.tcx\n-            .infer_ctxt()\n-            .enter(|infcx| !traits::type_marked_structural(id, cx.body.span, &infcx, ty))\n+        !ty.is_structural_eq_shallow(cx.tcx)\n     }\n }\n "}, {"sha": "46b687d76e50431e89e1c1c33f43e10bfd769ebc", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -80,7 +80,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n-        traits::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+        ty.is_structural_eq_shallow(self.infcx.tcx)\n     }\n \n     fn to_pat("}, {"sha": "680dbbad4b0a02e91f0bc76ef1570f0f82d7b156", "filename": "src/librustc_target/spec/windows_gnu_base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_gnu_base.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -17,6 +17,8 @@ pub fn opts() -> TargetOptions {\n     let mut late_link_args = LinkArgs::new();\n     let mut late_link_args_dynamic = LinkArgs::new();\n     let mut late_link_args_static = LinkArgs::new();\n+    // Order of `late_link_args*` was found through trial and error to work with various\n+    // mingw-w64 versions (not tested on the CI). It's expected to change from time to time.\n     late_link_args.insert(\n         LinkerFlavor::Gcc,\n         vec![\n@@ -27,10 +29,9 @@ pub fn opts() -> TargetOptions {\n             // And it seems that the linker fails to use import symbols from msvcrt\n             // that are required from functions in msvcrt in certain cases. For example\n             // `_fmode` that is used by an implementation of `__p__fmode` in x86_64.\n-            // Listing the library twice seems to fix that, and seems to also be done\n-            // by mingw's gcc (Though not sure if it's done on purpose, or by mistake).\n+            // The library is purposely listed twice to fix that.\n             //\n-            // See https://github.com/rust-lang/rust/pull/47483\n+            // See https://github.com/rust-lang/rust/pull/47483 for some more details.\n             \"-lmsvcrt\".to_string(),\n             \"-luser32\".to_string(),\n             \"-lkernel32\".to_string(),"}, {"sha": "9ab87e6b6ca01f35c7f8616aa8ba36feecaee370", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -60,7 +60,6 @@ pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n pub use self::structural_match::NonStructuralMatchTy;\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n@@ -553,6 +552,7 @@ fn type_implements_trait<'tcx>(\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     object_safety::provide(providers);\n+    structural_match::provide(providers);\n     *providers = ty::query::Providers {\n         specialization_graph_of: specialize::specialization_graph_provider,\n         specializes: specialize::specializes,"}, {"sha": "e59fbd313c8bc0160c25ca022a4de4a02f036df7", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::ObligationCause;\n-use crate::traits::{self, ConstPatternStructural, TraitEngine};\n+use crate::traits::{self, TraitEngine};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::lang_items::{StructuralPeqTraitLangItem, StructuralTeqTraitLangItem};\n+use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_span::Span;\n \n@@ -45,14 +46,14 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n-    id: hir::HirId,\n+    _id: hir::HirId,\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n ) -> Option<NonStructuralMatchTy<'tcx>> {\n     // FIXME: we should instead pass in an `infcx` from the outside.\n     tcx.infer_ctxt().enter(|infcx| {\n-        let mut search = Search { id, span, infcx, found: None, seen: FxHashSet::default() };\n+        let mut search = Search { infcx, span, found: None, seen: FxHashSet::default() };\n         ty.visit_with(&mut search);\n         search.found\n     })\n@@ -65,27 +66,26 @@ pub fn search_for_structural_match_violation<'tcx>(\n ///\n /// Note that this does *not* recursively check if the substructure of `adt_ty`\n /// implements the traits.\n-pub fn type_marked_structural(\n-    id: hir::HirId,\n-    span: Span,\n+fn type_marked_structural(\n     infcx: &InferCtxt<'_, 'tcx>,\n     adt_ty: Ty<'tcx>,\n+    cause: ObligationCause<'tcx>,\n ) -> bool {\n     let mut fulfillment_cx = traits::FulfillmentContext::new();\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n     // require `#[derive(PartialEq)]`\n-    let structural_peq_def_id = infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(span));\n+    let structural_peq_def_id =\n+        infcx.tcx.require_lang_item(StructuralPeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n         adt_ty,\n         structural_peq_def_id,\n-        cause,\n+        cause.clone(),\n     );\n     // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n     // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n-    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n-    let structural_teq_def_id = infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(span));\n+    let structural_teq_def_id =\n+        infcx.tcx.require_lang_item(StructuralTeqTraitLangItem, Some(cause.span));\n     fulfillment_cx.register_bound(\n         infcx,\n         ty::ParamEnv::empty(),\n@@ -110,7 +110,6 @@ pub fn type_marked_structural(\n /// find instances of ADTs (specifically structs or enums) that do not implement\n /// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n struct Search<'a, 'tcx> {\n-    id: hir::HirId,\n     span: Span,\n \n     infcx: InferCtxt<'a, 'tcx>,\n@@ -129,7 +128,7 @@ impl Search<'a, 'tcx> {\n     }\n \n     fn type_marked_structural(&self, adt_ty: Ty<'tcx>) -> bool {\n-        type_marked_structural(self.id, self.span, &self.infcx, adt_ty)\n+        adt_ty.is_structural_eq_shallow(self.tcx())\n     }\n }\n \n@@ -266,3 +265,12 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n         false\n     }\n }\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.has_structural_eq_impls = |tcx, ty| {\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let cause = ObligationCause::dummy();\n+            type_marked_structural(&infcx, ty, cause)\n+        })\n+    };\n+}"}, {"sha": "de06e5334e0408adda32abc5a4925c9555eba157", "filename": "src/test/mir-opt/const_prop/bad_op_div_by_zero/rustc.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -59,7 +59,7 @@\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n -                                          // + literal: Const { ty: i32, val: Value(Scalar(0xffffffff)) }\n--         _6 = Eq(const 1i32, const std::i32::MIN); // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+-         _6 = Eq(const 1i32, const i32::MIN); // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n +                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n +         _6 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n                                            // ty::Const"}, {"sha": "7052c8387041b2d1772057268e918c5b7ea0ecb6", "filename": "src/test/mir-opt/const_prop/bad_op_mod_by_zero/rustc.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -59,7 +59,7 @@\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n -                                          // + literal: Const { ty: i32, val: Value(Scalar(0xffffffff)) }\n--         _6 = Eq(const 1i32, const std::i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+-         _6 = Eq(const 1i32, const i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n +                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n +         _6 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n                                            // ty::Const"}, {"sha": "4903050e08ed266e9f30b64864822be165d7cc86", "filename": "src/test/pretty/asm.pp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fpretty%2Fasm.pp", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fpretty%2Fasm.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.pp?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -8,6 +8,7 @@\n \n // pretty-mode:expanded\n // pp-exact:asm.pp\n+// only-x86_64\n \n pub fn main() {\n     let a: i32;"}, {"sha": "12c32e6721b334b6e69dd891819cde93989e0ffc", "filename": "src/test/pretty/asm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fpretty%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fpretty%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fasm.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -2,6 +2,7 @@\n \n // pretty-mode:expanded\n // pp-exact:asm.pp\n+// only-x86_64\n \n pub fn main() {\n     let a: i32;"}, {"sha": "12ba9cacabf7c333bd5e184b754134cb326f9cda", "filename": "src/test/ui/consts/const-match-check.eval1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval1.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:25:15\n    |\n LL |     A = { let 0 = 0; 0 },\n-   |               ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |               ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "2eed7abdc65701c99658a7c8aaf919e4eecd8b12", "filename": "src/test/ui/consts/const-match-check.eval2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.eval2.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:31:24\n    |\n LL |     let x: [i32; { let 0 = 0; 0 }] = [];\n-   |                        ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                        ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "1fa0cb17fe66e6a8b53a5e0e5e78e5f039620a4f", "filename": "src/test/ui/consts/const-match-check.matchck.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-match-check.matchck.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:4:22\n    |\n LL | const X: i32 = { let 0 = 0; 0 };\n-   |                      ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                      ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -12,11 +12,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL | const X: i32 = { if let 0 = 0 { /* */ } 0 };\n    |                  ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:8:23\n    |\n LL | static Y: i32 = { let 0 = 0; 0 };\n-   |                       ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                       ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -26,11 +26,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL | static Y: i32 = { if let 0 = 0 { /* */ } 0 };\n    |                   ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:13:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                          ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -40,11 +40,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL |     const X: i32 = { if let 0 = 0 { /* */ } 0 };\n    |                      ^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n   --> $DIR/const-match-check.rs:19:26\n    |\n LL |     const X: i32 = { let 0 = 0; 0 };\n-   |                          ^ patterns `std::i32::MIN..=-1i32` and `1i32..=std::i32::MAX` not covered\n+   |                          ^ patterns `i32::MIN..=-1i32` and `1i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "65f09eb80098c73c260f53aa75026a6bf35af121", "filename": "src/test/ui/consts/const-pattern-irrefutable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -9,8 +9,8 @@ use foo::d;\n const a: u8 = 2;\n \n fn main() {\n-    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n-    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n-    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX\n+    let a = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX\n+    let c = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX\n+    let d = 4; //~ ERROR refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX\n     fn f() {} // Check that the `NOTE`s still work with an item here (cf. issue #35115).\n }"}, {"sha": "bb2fdec72ba0dd6638b15ca2f9a92f39b2abe266", "filename": "src/test/ui/consts/const-pattern-irrefutable.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-pattern-irrefutable.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:12:9\n    |\n LL | const a: u8 = 2;\n@@ -12,7 +12,7 @@ LL |     let a = 4;\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:13:9\n    |\n LL |     pub const b: u8 = 2;\n@@ -26,7 +26,7 @@ LL |     let c = 4;\n    |\n    = note: the matched value is of type `u8`\n \n-error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=std::u8::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `0u8..=1u8` and `3u8..=u8::MAX` not covered\n   --> $DIR/const-pattern-irrefutable.rs:14:9\n    |\n LL |     pub const d: u8 = 2;"}, {"sha": "e32005e21a8e1b63df9ce58f44c08a209185bf51", "filename": "src/test/ui/for/for-loop-refutable-pattern-error-message.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-refutable-pattern-error-message.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in `for` loop binding: `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in `for` loop binding: `&i32::MIN..=0i32` and `&2i32..=i32::MAX` not covered\n   --> $DIR/for-loop-refutable-pattern-error-message.rs:2:9\n    |\n LL |     for &1 in [1].iter() {}\n-   |         ^^ patterns `&std::i32::MIN..=0i32` and `&2i32..=std::i32::MAX` not covered\n+   |         ^^ patterns `&i32::MIN..=0i32` and `&2i32..=i32::MAX` not covered\n    |\n    = note: the matched value is of type `&i32`\n "}, {"sha": "028bfb89312fc7174760aa9925efc48e4200ec87", "filename": "src/test/ui/half-open-range-patterns/half-open-range-pats-exhaustive-fail.stderr", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhalf-open-range-patterns%2Fhalf-open-range-pats-exhaustive-fail.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -70,20 +70,20 @@ LL |     m!('a', ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `char`\n \n-error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:41:12\n    |\n LL |         m!(0, ..core::u8::MAX);\n-   |            ^ pattern `std::u8::MAX` not covered\n+   |            ^ pattern `u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `254u8..=std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `254u8..=u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:42:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `254u8..=std::u8::MAX` not covered\n+   |            ^ pattern `254u8..=u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n@@ -97,11 +97,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:44:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u8::MAX` not covered\n+   |            ^ pattern `u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n@@ -124,20 +124,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:54:12\n    |\n LL |         m!(0, ..core::u16::MAX);\n-   |            ^ pattern `std::u16::MAX` not covered\n+   |            ^ pattern `u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n \n-error[E0004]: non-exhaustive patterns: `65534u16..=std::u16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `65534u16..=u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:55:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `65534u16..=std::u16::MAX` not covered\n+   |            ^ pattern `65534u16..=u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n@@ -151,11 +151,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n \n-error[E0004]: non-exhaustive patterns: `std::u16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:57:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u16::MAX` not covered\n+   |            ^ pattern `u16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n@@ -178,20 +178,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u16`\n \n-error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:67:12\n    |\n LL |         m!(0, ..core::u32::MAX);\n-   |            ^ pattern `std::u32::MAX` not covered\n+   |            ^ pattern `u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n \n-error[E0004]: non-exhaustive patterns: `4294967294u32..=std::u32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `4294967294u32..=u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:68:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `4294967294u32..=std::u32::MAX` not covered\n+   |            ^ pattern `4294967294u32..=u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n@@ -205,11 +205,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n \n-error[E0004]: non-exhaustive patterns: `std::u32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:70:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u32::MAX` not covered\n+   |            ^ pattern `u32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n@@ -232,20 +232,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u32`\n \n-error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:80:12\n    |\n LL |         m!(0, ..core::u64::MAX);\n-   |            ^ pattern `std::u64::MAX` not covered\n+   |            ^ pattern `u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n \n-error[E0004]: non-exhaustive patterns: `18446744073709551614u64..=std::u64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `18446744073709551614u64..=u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:81:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `18446744073709551614u64..=std::u64::MAX` not covered\n+   |            ^ pattern `18446744073709551614u64..=u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n@@ -259,11 +259,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n \n-error[E0004]: non-exhaustive patterns: `std::u64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:83:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u64::MAX` not covered\n+   |            ^ pattern `u64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n@@ -286,20 +286,20 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u64`\n \n-error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:93:12\n    |\n LL |         m!(0, ..core::u128::MAX);\n-   |            ^ pattern `std::u128::MAX` not covered\n+   |            ^ pattern `u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `340282366920938463463374607431768211454u128..=u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:94:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `340282366920938463463374607431768211454u128..=std::u128::MAX` not covered\n+   |            ^ pattern `340282366920938463463374607431768211454u128..=u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n@@ -313,11 +313,11 @@ LL |         m!(0, ALMOST_MIN..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:96:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::u128::MAX` not covered\n+   |            ^ pattern `u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n@@ -340,38 +340,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:109:12\n    |\n LL |         m!(0, ..core::i8::MAX);\n-   |            ^ pattern `std::i8::MAX` not covered\n+   |            ^ pattern `i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `126i8..=std::i8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `126i8..=i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:110:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `126i8..=std::i8::MAX` not covered\n+   |            ^ pattern `126i8..=i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:111:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i8::MIN` not covered\n+   |            ^ pattern `i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:112:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i8::MAX` not covered\n+   |            ^ pattern `i8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n@@ -394,38 +394,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:122:12\n    |\n LL |         m!(0, ..core::i16::MAX);\n-   |            ^ pattern `std::i16::MAX` not covered\n+   |            ^ pattern `i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `32766i16..=std::i16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `32766i16..=i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:123:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `32766i16..=std::i16::MAX` not covered\n+   |            ^ pattern `32766i16..=i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `std::i16::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i16::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:124:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i16::MIN` not covered\n+   |            ^ pattern `i16::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `std::i16::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i16::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:125:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i16::MAX` not covered\n+   |            ^ pattern `i16::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n@@ -448,38 +448,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:135:12\n    |\n LL |         m!(0, ..core::i32::MAX);\n-   |            ^ pattern `std::i32::MAX` not covered\n+   |            ^ pattern `i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `2147483646i32..=std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `2147483646i32..=i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:136:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `2147483646i32..=std::i32::MAX` not covered\n+   |            ^ pattern `2147483646i32..=i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:137:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i32::MIN` not covered\n+   |            ^ pattern `i32::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:138:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i32::MAX` not covered\n+   |            ^ pattern `i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n@@ -502,38 +502,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`\n \n-error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:148:12\n    |\n LL |         m!(0, ..core::i64::MAX);\n-   |            ^ pattern `std::i64::MAX` not covered\n+   |            ^ pattern `i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `9223372036854775806i64..=std::i64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `9223372036854775806i64..=i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:149:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `9223372036854775806i64..=std::i64::MAX` not covered\n+   |            ^ pattern `9223372036854775806i64..=i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `std::i64::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i64::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:150:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i64::MIN` not covered\n+   |            ^ pattern `i64::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `std::i64::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i64::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:151:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i64::MAX` not covered\n+   |            ^ pattern `i64::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n@@ -556,38 +556,38 @@ LL |         m!(0, ..VAL_1 | VAL_2..);\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i64`\n \n-error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:161:12\n    |\n LL |         m!(0, ..core::i128::MAX);\n-   |            ^ pattern `std::i128::MAX` not covered\n+   |            ^ pattern `i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n \n-error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `170141183460469231731687303715884105726i128..=i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:162:12\n    |\n LL |         m!(0, ..ALMOST_MAX);\n-   |            ^ pattern `170141183460469231731687303715884105726i128..=std::i128::MAX` not covered\n+   |            ^ pattern `170141183460469231731687303715884105726i128..=i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n \n-error[E0004]: non-exhaustive patterns: `std::i128::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i128::MIN` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:163:12\n    |\n LL |         m!(0, ALMOST_MIN..);\n-   |            ^ pattern `std::i128::MIN` not covered\n+   |            ^ pattern `i128::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`\n \n-error[E0004]: non-exhaustive patterns: `std::i128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i128::MAX` not covered\n   --> $DIR/half-open-range-pats-exhaustive-fail.rs:164:12\n    |\n LL |         m!(0, ..=ALMOST_MAX);\n-   |            ^ pattern `std::i128::MAX` not covered\n+   |            ^ pattern `i128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i128`"}, {"sha": "31b3407a46e08f371e6b85657d6ef67b4bf92365", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -4,15 +4,15 @@\n // We wrap patterns in a tuple because top-level or-patterns were special-cased.\n fn main() {\n     match (0u8, 0u8) {\n-        //~^ ERROR non-exhaustive patterns: `(2u8..=std::u8::MAX, _)`\n+        //~^ ERROR non-exhaustive patterns: `(2u8..=u8::MAX, _)`\n         (0 | 1, 2 | 3) => {}\n     }\n     match ((0u8,),) {\n-        //~^ ERROR non-exhaustive patterns: `((4u8..=std::u8::MAX))`\n+        //~^ ERROR non-exhaustive patterns: `((4u8..=u8::MAX))`\n         ((0 | 1,) | (2 | 3,),) => {}\n     }\n     match (Some(0u8),) {\n-        //~^ ERROR non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))`\n+        //~^ ERROR non-exhaustive patterns: `(Some(2u8..=u8::MAX))`\n         (None | Some(0 | 1),) => {}\n     }\n }"}, {"sha": "653f4978ab350c2fb5abfe4a3cfaa3b22917602d", "filename": "src/test/ui/or-patterns/exhaustiveness-non-exhaustive.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-non-exhaustive.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,26 +1,26 @@\n-error[E0004]: non-exhaustive patterns: `(2u8..=std::u8::MAX, _)` not covered\n+error[E0004]: non-exhaustive patterns: `(2u8..=u8::MAX, _)` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:6:11\n    |\n LL |     match (0u8, 0u8) {\n-   |           ^^^^^^^^^^ pattern `(2u8..=std::u8::MAX, _)` not covered\n+   |           ^^^^^^^^^^ pattern `(2u8..=u8::MAX, _)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(u8, u8)`\n \n-error[E0004]: non-exhaustive patterns: `((4u8..=std::u8::MAX))` not covered\n+error[E0004]: non-exhaustive patterns: `((4u8..=u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:10:11\n    |\n LL |     match ((0u8,),) {\n-   |           ^^^^^^^^^ pattern `((4u8..=std::u8::MAX))` not covered\n+   |           ^^^^^^^^^ pattern `((4u8..=u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `((u8,),)`\n \n-error[E0004]: non-exhaustive patterns: `(Some(2u8..=std::u8::MAX))` not covered\n+error[E0004]: non-exhaustive patterns: `(Some(2u8..=u8::MAX))` not covered\n   --> $DIR/exhaustiveness-non-exhaustive.rs:14:11\n    |\n LL |     match (Some(0u8),) {\n-   |           ^^^^^^^^^^^^ pattern `(Some(2u8..=std::u8::MAX))` not covered\n+   |           ^^^^^^^^^^^^ pattern `(Some(2u8..=u8::MAX))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(std::option::Option<u8>,)`"}, {"sha": "2eadef9cb5c118b870aec2e41ddd36451d6efabd", "filename": "src/test/ui/or-patterns/issue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fissue-69875-should-have-been-expanded-earlier-non-exhaustive.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:4:9\n    |\n LL |     let 0 | (1 | 2) = 0;\n-   |         ^^^^^^^^^^^ patterns `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+   |         ^^^^^^^^^^^ patterns `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n@@ -12,11 +12,11 @@ help: you might want to use `if let` to ignore the variant that isn't matched\n LL |     if let 0 | (1 | 2) = 0 { /* */ }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n   --> $DIR/issue-69875-should-have-been-expanded-earlier-non-exhaustive.rs:5:11\n    |\n LL |     match 0 {\n-   |           ^ patterns `std::i32::MIN..=-1i32` and `3i32..=std::i32::MAX` not covered\n+   |           ^ patterns `i32::MIN..=-1i32` and `3i32..=i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`"}, {"sha": "6427a30b8f2ed8354c91828924cd94c63534cb9e", "filename": "src/test/ui/pattern/usefulness/exhaustive_integer_patterns.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fexhaustive_integer_patterns.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -10,11 +10,11 @@ note: the lint level is defined here\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `128u8..=u8::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:28:11\n    |\n LL |     match x {\n-   |           ^ pattern `128u8..=std::u8::MAX` not covered\n+   |           ^ pattern `128u8..=u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n@@ -34,20 +34,20 @@ error: unreachable pattern\n LL |         -2..=20 => {}\n    |         ^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n+error[E0004]: non-exhaustive patterns: `i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n   --> $DIR/exhaustive_integer_patterns.rs:41:11\n    |\n LL |     match x {\n-   |           ^ patterns `std::i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n+   |           ^ patterns `i8::MIN..=-8i8`, `-6i8`, `121i8..=124i8` and 1 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n \n-error[E0004]: non-exhaustive patterns: `std::i8::MIN` not covered\n+error[E0004]: non-exhaustive patterns: `i8::MIN` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:83:11\n    |\n LL |     match 0i8 {\n-   |           ^^^ pattern `std::i8::MIN` not covered\n+   |           ^^^ pattern `i8::MIN` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i8`\n@@ -61,20 +61,20 @@ LL |     match 0i16 {\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i16`\n \n-error[E0004]: non-exhaustive patterns: `128u8..=std::u8::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `128u8..=u8::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:109:11\n    |\n LL |     match 0u8 {\n-   |           ^^^ pattern `128u8..=std::u8::MAX` not covered\n+   |           ^^^ pattern `128u8..=u8::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n+error[E0004]: non-exhaustive patterns: `(0u8, Some(_))` and `(2u8..=u8::MAX, Some(_))` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:121:11\n    |\n LL |     match (0u8, Some(())) {\n-   |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=std::u8::MAX, Some(_))` not covered\n+   |           ^^^^^^^^^^^^^^^ patterns `(0u8, Some(_))` and `(2u8..=u8::MAX, Some(_))` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(u8, std::option::Option<()>)`\n@@ -102,20 +102,20 @@ note: the lint level is defined here\n LL | #![deny(overlapping_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0004]: non-exhaustive patterns: `std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `u128::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:146:11\n    |\n LL |     match 0u128 {\n-   |           ^^^^^ pattern `std::u128::MAX` not covered\n+   |           ^^^^^ pattern `u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`\n \n-error[E0004]: non-exhaustive patterns: `5u128..=std::u128::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `5u128..=u128::MAX` not covered\n   --> $DIR/exhaustive_integer_patterns.rs:150:11\n    |\n LL |     match 0u128 {\n-   |           ^^^^^ pattern `5u128..=std::u128::MAX` not covered\n+   |           ^^^^^ pattern `5u128..=u128::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u128`"}, {"sha": "0e12b89de1b9104ca43eff20110ad0b51d2746af", "filename": "src/test/ui/pattern/usefulness/match-byte-array-patterns-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-byte-array-patterns-2.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n+error[E0004]: non-exhaustive patterns: `&[0u8..=64u8, _, _, _]` and `&[66u8..=u8::MAX, _, _, _]` not covered\n   --> $DIR/match-byte-array-patterns-2.rs:4:11\n    |\n LL |     match buf {\n-   |           ^^^ patterns `&[0u8..=64u8, _, _, _]` and `&[66u8..=std::u8::MAX, _, _, _]` not covered\n+   |           ^^^ patterns `&[0u8..=64u8, _, _, _]` and `&[66u8..=u8::MAX, _, _, _]` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `&[u8; 4]`"}, {"sha": "c6a9329f9e8e124ef31988d1823f8db06a9b132a", "filename": "src/test/ui/pattern/usefulness/match-non-exhaustive.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-non-exhaustive.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,8 +1,8 @@\n-error[E0004]: non-exhaustive patterns: `std::i32::MIN..=0i32` and `2i32..=std::i32::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `i32::MIN..=0i32` and `2i32..=i32::MAX` not covered\n   --> $DIR/match-non-exhaustive.rs:2:11\n    |\n LL |     match 0 { 1 => () }\n-   |           ^ patterns `std::i32::MIN..=0i32` and `2i32..=std::i32::MAX` not covered\n+   |           ^ patterns `i32::MIN..=0i32` and `2i32..=i32::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `i32`"}, {"sha": "9177345bc6f50603d757d492cccfe8ec0adff9c4", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -11,8 +11,8 @@ fn main() {\n     match Some(10) { //~ ERROR non-exhaustive patterns: `Some(_)` not covered\n       None => {}\n     }\n-    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)`\n-                      //  and `(_, _, 5i32..=std::i32::MAX)` not covered\n+    match (2, 3, 4) { //~ ERROR non-exhaustive patterns: `(_, _, i32::MIN..=3i32)`\n+                      //  and `(_, _, 5i32..=i32::MAX)` not covered\n       (_, _, 4) => {}\n     }\n     match (T::A, T::A) { //~ ERROR non-exhaustive patterns: `(A, A)` not covered"}, {"sha": "3cdbd8a3433f4144ca590d654cb1608ef656f516", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -36,11 +36,11 @@ LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `std::option::Option<i32>`\n \n-error[E0004]: non-exhaustive patterns: `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n+error[E0004]: non-exhaustive patterns: `(_, _, i32::MIN..=3i32)` and `(_, _, 5i32..=i32::MAX)` not covered\n   --> $DIR/non-exhaustive-match.rs:14:11\n    |\n LL |     match (2, 3, 4) {\n-   |           ^^^^^^^^^ patterns `(_, _, std::i32::MIN..=3i32)` and `(_, _, 5i32..=std::i32::MAX)` not covered\n+   |           ^^^^^^^^^ patterns `(_, _, i32::MIN..=3i32)` and `(_, _, 5i32..=i32::MAX)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `(i32, i32, i32)`"}, {"sha": "3ef2ead32cb7ceedf069e125748e228c6ff17bbf", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -5,5 +5,5 @@ fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n \n fn main() {\n     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-    //~^ ERROR refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+    //~^ ERROR refutable pattern in local binding: `(i32::MIN..=0i32, _)` and `(2i32..=i32::MAX, _)` not covered\n }"}, {"sha": "ac729ae9f7cdff4c5230ed9c51c6b36283c3ed0d", "filename": "src/test/ui/pattern/usefulness/refutable-pattern-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Frefutable-pattern-errors.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -6,11 +6,11 @@ LL | fn func((1, (Some(1), 2..=3)): (isize, (Option<isize>, isize))) { }\n    |\n    = note: the matched value is of type `(isize, (std::option::Option<isize>, isize))`\n \n-error[E0005]: refutable pattern in local binding: `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+error[E0005]: refutable pattern in local binding: `(i32::MIN..=0i32, _)` and `(2i32..=i32::MAX, _)` not covered\n   --> $DIR/refutable-pattern-errors.rs:7:9\n    |\n LL |     let (1, (Some(1), 2..=3)) = (1, (None, 2));\n-   |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(std::i32::MIN..=0i32, _)` and `(2i32..=std::i32::MAX, _)` not covered\n+   |         ^^^^^^^^^^^^^^^^^^^^^ patterns `(i32::MIN..=0i32, _)` and `(2i32..=i32::MAX, _)` not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "7b9e30f40fbb3ca48e4b878b0fcb44c13e3df5d8", "filename": "src/test/ui/precise_pointer_size_matching.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprecise_pointer_size_matching.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,17 +1,17 @@\n-error[E0004]: non-exhaustive patterns: `std::isize::MIN..=-6isize` and `21isize..=std::isize::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `isize::MIN..=-6isize` and `21isize..=isize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:24:11\n    |\n LL |     match 0isize {\n-   |           ^^^^^^ patterns `std::isize::MIN..=-6isize` and `21isize..=std::isize::MAX` not covered\n+   |           ^^^^^^ patterns `isize::MIN..=-6isize` and `21isize..=isize::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `isize`\n \n-error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=std::usize::MAX` not covered\n+error[E0004]: non-exhaustive patterns: `0usize` and `21usize..=usize::MAX` not covered\n   --> $DIR/precise_pointer_size_matching.rs:29:11\n    |\n LL |     match 0usize {\n-   |           ^^^^^^ patterns `0usize` and `21usize..=std::usize::MAX` not covered\n+   |           ^^^^^^ patterns `0usize` and `21usize..=usize::MAX` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `usize`"}, {"sha": "21fb8d4a2e68dc37d1b4276675c5a64f214362f6", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.rs?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let A = 3;\n-    //~^ ERROR refutable pattern in local binding: `std::i32::MIN..=1i32` and\n+    //~^ ERROR refutable pattern in local binding: `i32::MIN..=1i32` and\n     //~| interpreted as a constant pattern, not a new variable\n     //~| HELP introduce a variable instead\n     //~| SUGGESTION a_var"}, {"sha": "7a6269da07f3260658cf2c9eecdfd740bc291731", "filename": "src/test/ui/suggestions/const-pat-non-exaustive-let-new-var.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fconst-pat-non-exaustive-let-new-var.stderr?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -1,4 +1,4 @@\n-error[E0005]: refutable pattern in local binding: `std::i32::MIN..=1i32` and `3i32..=std::i32::MAX` not covered\n+error[E0005]: refutable pattern in local binding: `i32::MIN..=1i32` and `3i32..=i32::MAX` not covered\n   --> $DIR/const-pat-non-exaustive-let-new-var.rs:2:9\n    |\n LL |     let A = 3;"}, {"sha": "fc2dbb8d4402d7d5d39191d3be7835aa31698ef5", "filename": "triagebot.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e47688bf15d0215edbe05b21603062f6d2eb5d/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e47688bf15d0215edbe05b21603062f6d2eb5d/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=06e47688bf15d0215edbe05b21603062f6d2eb5d", "patch": "@@ -42,6 +42,7 @@ Hey Windows Group! This bug has been identified as a good \"Windows candidate\".\n In case it's useful, here are some [instructions] for tackling these sorts of\n bugs. Maybe take a look?\n Thanks! <3\n+\n [instructions]: https://rustc-dev-guide.rust-lang.org/notification-groups/windows.html\n \"\"\"\n label = \"O-windows\"\n@@ -52,6 +53,7 @@ Hey ARM Group! This bug has been identified as a good \"ARM candidate\".\n In case it's useful, here are some [instructions] for tackling these sorts of\n bugs. Maybe take a look?\n Thanks! <3\n+\n [instructions]: https://rustc-dev-guide.rust-lang.org/notification-groups/arm.html\n \"\"\"\n label = \"O-ARM\""}]}