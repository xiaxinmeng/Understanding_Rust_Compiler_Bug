{"sha": "b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "node_id": "C_kwDOAAsO6NoAKGIwNWJiMjkwMDgyNWU0ZDA2M2ViZjNmMGYxMWFmYjA4YmFlZDNiYzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T23:27:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-12T23:27:52Z"}, "message": "Auto merge of #108872 - cjgillot:simp-const-prop, r=oli-obk\n\nStrengthen state tracking in const-prop\n\nSome/many of the changes are replicated between both the const-prop lint and the const-prop optimization.\n\nBehaviour changes:\n- const-prop opt does not give a span to propagated values. This was useless as that span's primary purpose is to diagnose evaluation failure in codegen.\n- we remove the `OnlyPropagateInto` mode. It was only used for function arguments, which are better modeled by a write before entry.\n- the tracking of assignments and discriminants make clearer that we do nothing in `NoPropagation` mode or on indirect places.", "tree": {"sha": "7eab2ab2a52abf592a590cd143e93faae37b5a6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eab2ab2a52abf592a590cd143e93faae37b5a6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "html_url": "https://github.com/rust-lang/rust/commit/b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b4f48927dce585f747a58083b45ab62b9d73a53", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b4f48927dce585f747a58083b45ab62b9d73a53", "html_url": "https://github.com/rust-lang/rust/commit/7b4f48927dce585f747a58083b45ab62b9d73a53"}, {"sha": "8179b2e5f8ab3524aa7860d8b34897949dde4b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/8179b2e5f8ab3524aa7860d8b34897949dde4b65", "html_url": "https://github.com/rust-lang/rust/commit/8179b2e5f8ab3524aa7860d8b34897949dde4b65"}], "stats": {"total": 579, "additions": 249, "deletions": 330}, "files": [{"sha": "0918ffcd9821442a92ef261da3c2204f9606d4a2", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -536,24 +536,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         local: mir::Local,\n         layout: Option<TyAndLayout<'tcx>>,\n     ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n-        // `const_prop` runs into this with an invalid (empty) frame, so we\n-        // have to support that case (mostly by skipping all caching).\n-        match frame.locals.get(local).and_then(|state| state.layout.get()) {\n-            None => {\n-                let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n-                    let local_ty = frame.body.local_decls[local].ty;\n-                    let local_ty =\n-                        self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty)?;\n-                    self.layout_of(local_ty)\n-                })?;\n-                if let Some(state) = frame.locals.get(local) {\n-                    // Layouts of locals are requested a lot, so we cache them.\n-                    state.layout.set(Some(layout));\n-                }\n-                Ok(layout)\n-            }\n-            Some(layout) => Ok(layout),\n+        let state = &frame.locals[local];\n+        if let Some(layout) = state.layout.get() {\n+            return Ok(layout);\n         }\n+\n+        let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n+            let local_ty = frame.body.local_decls[local].ty;\n+            let local_ty = self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty)?;\n+            self.layout_of(local_ty)\n+        })?;\n+\n+        // Layouts of locals are requested a lot, so we cache them.\n+        state.layout.set(Some(layout));\n+        Ok(layout)\n     }\n \n     /// Returns the actual dynamic size and alignment of the place at the given type."}, {"sha": "de7b8c63fc87a02f686402e9f83da630898fb0fc", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 100, "deletions": 169, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -1,12 +1,9 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n use either::Right;\n \n use rustc_const_eval::const_eval::CheckAlignment;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -17,16 +14,16 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeVisitableExt};\n-use rustc_span::{def_id::DefId, Span};\n+use rustc_span::{def_id::DefId, Span, DUMMY_SP};\n use rustc_target::abi::{self, Align, HasDataLayout, Size, TargetDataLayout};\n use rustc_target::spec::abi::Abi as CallAbi;\n use rustc_trait_selection::traits;\n \n use crate::MirPass;\n use rustc_const_eval::interpret::{\n     self, compile_time_machine, AllocId, ConstAllocation, ConstValue, CtfeValidationMode, Frame,\n-    ImmTy, Immediate, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, PlaceTy,\n-    Pointer, Scalar, StackPopCleanup, StackPopUnwind,\n+    ImmTy, Immediate, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, PlaceTy, Pointer,\n+    Scalar, StackPopCleanup, StackPopUnwind,\n };\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n@@ -154,24 +151,12 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n pub struct ConstPropMachine<'mir, 'tcx> {\n     /// The virtual call stack.\n     stack: Vec<Frame<'mir, 'tcx>>,\n-    /// `OnlyInsideOwnBlock` locals that were written in the current block get erased at the end.\n-    pub written_only_inside_own_block_locals: FxHashSet<Local>,\n-    /// Locals that need to be cleared after every block terminates.\n-    pub only_propagate_inside_block_locals: BitSet<Local>,\n     pub can_const_prop: IndexVec<Local, ConstPropMode>,\n }\n \n impl ConstPropMachine<'_, '_> {\n-    pub fn new(\n-        only_propagate_inside_block_locals: BitSet<Local>,\n-        can_const_prop: IndexVec<Local, ConstPropMode>,\n-    ) -> Self {\n-        Self {\n-            stack: Vec::new(),\n-            written_only_inside_own_block_locals: Default::default(),\n-            only_propagate_inside_block_locals,\n-            can_const_prop,\n-        }\n+    pub fn new(can_const_prop: IndexVec<Local, ConstPropMode>) -> Self {\n+        Self { stack: Vec::new(), can_const_prop }\n     }\n }\n \n@@ -257,16 +242,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         frame: usize,\n         local: Local,\n     ) -> InterpResult<'tcx, &'a mut interpret::Operand<Self::Provenance>> {\n-        if ecx.machine.can_const_prop[local] == ConstPropMode::NoPropagation {\n-            throw_machine_stop_str!(\"tried to write to a local that is marked as not propagatable\")\n-        }\n-        if frame == 0 && ecx.machine.only_propagate_inside_block_locals.contains(local) {\n-            trace!(\n-                \"mutating local {:?} which is restricted to its block. \\\n-                Will remove it from const-prop after block is finished.\",\n-                local\n-            );\n-            ecx.machine.written_only_inside_own_block_locals.insert(local);\n+        assert_eq!(frame, 0);\n+        match ecx.machine.can_const_prop[local] {\n+            ConstPropMode::NoPropagation => {\n+                throw_machine_stop_str!(\n+                    \"tried to write to a local that is marked as not propagatable\"\n+                )\n+            }\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {}\n         }\n         ecx.machine.stack[frame].locals[local].access_mut()\n     }\n@@ -328,9 +311,6 @@ struct ConstPropagator<'mir, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     param_env: ParamEnv<'tcx>,\n     local_decls: &'mir IndexVec<Local, LocalDecl<'tcx>>,\n-    // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n-    // the last known `SourceInfo` here and just keep revisiting it.\n-    source_info: Option<SourceInfo>,\n }\n \n impl<'tcx> LayoutOfHelpers<'tcx> for ConstPropagator<'_, 'tcx> {\n@@ -374,17 +354,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let can_const_prop = CanConstProp::check(tcx, param_env, body);\n-        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n-        for (l, mode) in can_const_prop.iter_enumerated() {\n-            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n-                only_propagate_inside_block_locals.insert(l);\n-            }\n-        }\n         let mut ecx = InterpCx::new(\n             tcx,\n             tcx.def_span(def_id),\n             param_env,\n-            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n+            ConstPropMachine::new(can_const_prop),\n         );\n \n         let ret_layout = ecx\n@@ -411,13 +385,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         )\n         .expect(\"failed to push initial stack frame\");\n \n-        ConstPropagator {\n-            ecx,\n-            tcx,\n-            param_env,\n-            local_decls: &dummy_body.local_decls,\n-            source_info: None,\n-        }\n+        ConstPropagator { ecx, tcx, param_env, local_decls: &dummy_body.local_decls }\n     }\n \n     fn get_const(&self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n@@ -446,10 +414,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] = LocalState {\n-            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n-            layout: Cell::new(None),\n-        };\n+        ecx.frame_mut().locals[local].value =\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n     }\n \n     /// Returns the value, if any, of evaluating `c`.\n@@ -492,19 +458,15 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                         scalar,\n                     )) = *value\n                     {\n-                        *operand = self.operand_from_scalar(\n-                            scalar,\n-                            value.layout.ty,\n-                            self.source_info.unwrap().span,\n-                        );\n+                        *operand = self.operand_from_scalar(scalar, value.layout.ty);\n                     }\n                 }\n             }\n             Operand::Constant(_) => (),\n         }\n     }\n \n-    fn const_prop(&mut self, rvalue: &Rvalue<'tcx>, place: Place<'tcx>) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -561,7 +523,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.eval_rvalue_with_identities(rvalue, place)\n+        Some(())\n     }\n \n     // Attempt to use algebraic identities to eliminate constant expressions\n@@ -621,20 +583,24 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n \n     /// Creates a new `Operand::Constant` from a `Scalar` value\n-    fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {\n+    fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>) -> Operand<'tcx> {\n         Operand::Constant(Box::new(Constant {\n-            span,\n+            span: DUMMY_SP,\n             user_ty: None,\n             literal: ConstantKind::from_scalar(self.tcx, scalar, ty),\n         }))\n     }\n \n-    fn replace_with_const(\n-        &mut self,\n-        rval: &mut Rvalue<'tcx>,\n-        value: &OpTy<'tcx>,\n-        source_info: SourceInfo,\n-    ) {\n+    fn replace_with_const(&mut self, place: Place<'tcx>, rval: &mut Rvalue<'tcx>) {\n+        // This will return None if the above `const_prop` invocation only \"wrote\" a\n+        // type whose creation requires no write. E.g. a generator whose initial state\n+        // consists solely of uninitialized memory (so it doesn't capture any locals).\n+        let Some(ref value) = self.get_const(place) else { return };\n+        if !self.should_const_prop(value) {\n+            return;\n+        }\n+        trace!(\"replacing {:?}={:?} with {:?}\", place, rval, value);\n+\n         if let Rvalue::Use(Operand::Constant(c)) = rval {\n             match c.literal {\n                 ConstantKind::Ty(c) if matches!(c.kind(), ConstKind::Unevaluated(..)) => {}\n@@ -664,11 +630,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if let Some(Right(imm)) = imm {\n             match *imm {\n                 interpret::Immediate::Scalar(scalar) => {\n-                    *rval = Rvalue::Use(self.operand_from_scalar(\n-                        scalar,\n-                        value.layout.ty,\n-                        source_info.span,\n-                    ));\n+                    *rval = Rvalue::Use(self.operand_from_scalar(scalar, value.layout.ty));\n                 }\n                 Immediate::ScalarPair(..) => {\n                     // Found a value represented as a pair. For now only do const-prop if the type\n@@ -701,7 +663,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                                 let const_val = ConstValue::ByRef { alloc, offset: Size::ZERO };\n                                 let literal = ConstantKind::Val(const_val, ty);\n                                 *rval = Rvalue::Use(Operand::Constant(Box::new(Constant {\n-                                    span: source_info.span,\n+                                    span: DUMMY_SP,\n                                     user_ty: None,\n                                     literal,\n                                 })));\n@@ -730,6 +692,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             _ => false,\n         }\n     }\n+\n+    fn ensure_not_propagated(&mut self, local: Local) {\n+        if cfg!(debug_assertions) {\n+            assert!(\n+                self.get_const(local.into()).is_none()\n+                    || self\n+                        .layout_of(self.local_decls[local].ty)\n+                        .map_or(true, |layout| layout.is_zst()),\n+                \"failed to remove values for `{local:?}`, value={:?}\",\n+                self.get_const(local.into()),\n+            )\n+        }\n+    }\n }\n \n /// The mode that `ConstProp` is allowed to run in for a given `Local`.\n@@ -739,8 +714,6 @@ pub enum ConstPropMode {\n     FullConstProp,\n     /// The `Local` can only be propagated into and from its own block.\n     OnlyInsideOwnBlock,\n-    /// The `Local` can be propagated into but reads cannot be propagated.\n-    OnlyPropagateInto,\n     /// The `Local` cannot be part of propagation at all. Any statement\n     /// referencing it either for reading or writing will not get propagated.\n     NoPropagation,\n@@ -750,8 +723,6 @@ pub struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // False at the beginning. Once set, no more assignments are allowed to that local.\n     found_assignment: BitSet<Local>,\n-    // Cache of locals' information\n-    local_kinds: IndexVec<Local, LocalKind>,\n }\n \n impl CanConstProp {\n@@ -764,10 +735,6 @@ impl CanConstProp {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n             found_assignment: BitSet::new_empty(body.local_decls.len()),\n-            local_kinds: IndexVec::from_fn_n(\n-                |local| body.local_kind(local),\n-                body.local_decls.len(),\n-            ),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n             let ty = body.local_decls[local].ty;\n@@ -780,24 +747,10 @@ impl CanConstProp {\n                     continue;\n                 }\n             }\n-            // Cannot use args at all\n-            // Cannot use locals because if x < y { y - x } else { x - y } would\n-            //        lint for x != y\n-            // FIXME(oli-obk): lint variables until they are used in a condition\n-            // FIXME(oli-obk): lint if return value is constant\n-            if cpv.local_kinds[local] == LocalKind::Arg {\n-                *val = ConstPropMode::OnlyPropagateInto;\n-                trace!(\n-                    \"local {:?} can't be const propagated because it's a function argument\",\n-                    local\n-                );\n-            } else if cpv.local_kinds[local] == LocalKind::Var {\n-                *val = ConstPropMode::OnlyInsideOwnBlock;\n-                trace!(\n-                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n-                    local\n-                );\n-            }\n+        }\n+        // Consider that arguments are assigned on entry.\n+        for arg in body.args_iter() {\n+            cpv.found_assignment.insert(arg);\n         }\n         cpv.visit_body(&body);\n         cpv.can_const_prop\n@@ -827,7 +780,6 @@ impl Visitor<'_> for CanConstProp {\n                         // states as applicable.\n                         ConstPropMode::OnlyInsideOwnBlock => {}\n                         ConstPropMode::NoPropagation => {}\n-                        ConstPropMode::OnlyPropagateInto => {}\n                         other @ ConstPropMode::FullConstProp => {\n                             trace!(\n                                 \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n@@ -892,42 +844,23 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.eval_constant(constant);\n     }\n \n-    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n-        trace!(\"visit_statement: {:?}\", statement);\n-        let source_info = statement.source_info;\n-        self.source_info = Some(source_info);\n-        match statement.kind {\n-            StatementKind::Assign(box (place, ref mut rval)) => {\n-                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-                if let Some(()) = self.const_prop(rval, place) {\n-                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                    // type whose creation requires no write. E.g. a generator whose initial state\n-                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                    if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n-                        trace!(\"replacing {:?} with {:?}\", rval, value);\n-                        self.replace_with_const(rval, value, source_info);\n-                        if can_const_prop == ConstPropMode::FullConstProp\n-                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                        {\n-                            trace!(\"propagated into {:?}\", place);\n-                        }\n-                    }\n-                    match can_const_prop {\n-                        ConstPropMode::OnlyInsideOwnBlock => {\n-                            trace!(\n-                                \"found local restricted to its block. \\\n-                                Will remove it from const-prop after block is finished. Local: {:?}\",\n-                                place.local\n-                            );\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            trace!(\"can't propagate into {:?}\", place);\n-                            if place.local != RETURN_PLACE {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                        }\n-                        ConstPropMode::FullConstProp => {}\n-                    }\n+    fn visit_assign(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        rvalue: &mut Rvalue<'tcx>,\n+        location: Location,\n+    ) {\n+        self.super_assign(place, rvalue, location);\n+\n+        let Some(()) = self.check_rvalue(rvalue) else { return };\n+\n+        match self.ecx.machine.can_const_prop[place.local] {\n+            // Do nothing if the place is indirect.\n+            _ if place.is_indirect() => {}\n+            ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n+                if let Some(()) = self.eval_rvalue_with_identities(rvalue, *place) {\n+                    self.replace_with_const(*place, rvalue);\n                 } else {\n                     // Const prop failed, so erase the destination, ensuring that whatever happens\n                     // from here on, does not know about the previous value.\n@@ -947,37 +880,45 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     Self::remove_const(&mut self.ecx, place.local);\n                 }\n             }\n+        }\n+    }\n+\n+    fn visit_statement(&mut self, statement: &mut Statement<'tcx>, location: Location) {\n+        trace!(\"visit_statement: {:?}\", statement);\n+\n+        // We want to evaluate operands before any change to the assigned-to value,\n+        // so we recurse first.\n+        self.super_statement(statement, location);\n+\n+        match statement.kind {\n             StatementKind::SetDiscriminant { ref place, .. } => {\n                 match self.ecx.machine.can_const_prop[place.local] {\n+                    // Do nothing if the place is indirect.\n+                    _ if place.is_indirect() => {}\n+                    ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n                     ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n                         if self.ecx.statement(statement).is_ok() {\n                             trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        Self::remove_const(&mut self.ecx, place.local);\n-                    }\n                 }\n             }\n-            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+            StatementKind::StorageLive(local) => {\n                 let frame = self.ecx.frame_mut();\n-                frame.locals[local].value = if let StatementKind::StorageLive(_) = statement.kind {\n-                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n-                } else {\n-                    LocalValue::Dead\n-                };\n+                frame.locals[local].value =\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+            }\n+            StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = LocalValue::Dead;\n             }\n             _ => {}\n         }\n-\n-        self.super_statement(statement, location);\n     }\n \n     fn visit_terminator(&mut self, terminator: &mut Terminator<'tcx>, location: Location) {\n-        let source_info = terminator.source_info;\n-        self.source_info = Some(source_info);\n         self.super_terminator(terminator, location);\n \n         match &mut terminator.kind {\n@@ -987,11 +928,7 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n                     && self.should_const_prop(value)\n                 {\n                     trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                    *cond = self.operand_from_scalar(\n-                        value_const,\n-                        self.tcx.types.bool,\n-                        source_info.span,\n-                    );\n+                    *cond = self.operand_from_scalar(value_const, self.tcx.types.bool);\n                 }\n             }\n             TerminatorKind::SwitchInt { ref mut discr, .. } => {\n@@ -1026,23 +963,17 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n-        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n-        for &local in locals.iter() {\n-            Self::remove_const(&mut self.ecx, local);\n-        }\n-        locals.clear();\n-        // Put it back so we reuse the heap of the storage\n-        self.ecx.machine.written_only_inside_own_block_locals = locals;\n-        if cfg!(debug_assertions) {\n-            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n-            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n-                assert!(\n-                    self.get_const(local.into()).is_none()\n-                        || self\n-                            .layout_of(self.local_decls[local].ty)\n-                            .map_or(true, |layout| layout.is_zst())\n-                )\n+        let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n+        for (local, &mode) in can_const_prop.iter_enumerated() {\n+            match mode {\n+                ConstPropMode::FullConstProp => {}\n+                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n+                ConstPropMode::OnlyInsideOwnBlock => {\n+                    Self::remove_const(&mut self.ecx, local);\n+                    self.ensure_not_propagated(local);\n+                }\n             }\n         }\n+        self.ecx.machine.can_const_prop = can_const_prop;\n     }\n }"}, {"sha": "68e50070e56e17cbc2b463aac36d7c60f4cc9c7e", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 95, "deletions": 108, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -1,24 +1,17 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use std::cell::Cell;\n-\n use either::{Left, Right};\n \n use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n-    self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n+    self, InterpCx, InterpResult, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n };\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor;\n-use rustc_middle::mir::{\n-    AssertKind, BinOp, Body, Constant, Local, LocalDecl, Location, Operand, Place, Rvalue,\n-    SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n-    UnOp, RETURN_PLACE,\n-};\n+use rustc_middle::mir::*;\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::InternalSubsts;\n use rustc_middle::ty::{\n@@ -185,17 +178,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let can_const_prop = CanConstProp::check(tcx, param_env, body);\n-        let mut only_propagate_inside_block_locals = BitSet::new_empty(can_const_prop.len());\n-        for (l, mode) in can_const_prop.iter_enumerated() {\n-            if *mode == ConstPropMode::OnlyInsideOwnBlock {\n-                only_propagate_inside_block_locals.insert(l);\n-            }\n-        }\n         let mut ecx = InterpCx::new(\n             tcx,\n             tcx.def_span(def_id),\n             param_env,\n-            ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n+            ConstPropMachine::new(can_const_prop),\n         );\n \n         let ret_layout = ecx\n@@ -258,10 +245,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Remove `local` from the pool of `Locals`. Allows writing to them,\n     /// but not reading from them anymore.\n     fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n-        ecx.frame_mut().locals[local] = LocalState {\n-            value: LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit)),\n-            layout: Cell::new(None),\n-        };\n+        ecx.frame_mut().locals[local].value =\n+            LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n     }\n \n     fn lint_root(&self, source_info: SourceInfo) -> Option<HirId> {\n@@ -420,12 +405,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Some(())\n     }\n \n-    fn const_prop(\n-        &mut self,\n-        rvalue: &Rvalue<'tcx>,\n-        source_info: SourceInfo,\n-        place: Place<'tcx>,\n-    ) -> Option<()> {\n+    fn check_rvalue(&mut self, rvalue: &Rvalue<'tcx>, source_info: SourceInfo) -> Option<()> {\n         // Perform any special handling for specific Rvalue types.\n         // Generally, checks here fall into one of two categories:\n         //   1. Additional checking to provide useful lints to the user\n@@ -501,7 +481,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n-        self.use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+        Some(())\n+    }\n+\n+    fn ensure_not_propagated(&mut self, local: Local) {\n+        if cfg!(debug_assertions) {\n+            assert!(\n+                self.get_const(local.into()).is_none()\n+                    || self\n+                        .layout_of(self.local_decls[local].ty)\n+                        .map_or(true, |layout| layout.is_zst()),\n+                \"failed to remove values for `{local:?}`, value={:?}\",\n+                self.get_const(local.into()),\n+            )\n+        }\n     }\n }\n \n@@ -522,82 +515,78 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         self.eval_constant(constant, self.source_info.unwrap());\n     }\n \n+    fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_assign(place, rvalue, location);\n+\n+        let source_info = self.source_info.unwrap();\n+        let Some(()) = self.check_rvalue(rvalue, source_info) else { return };\n+\n+        match self.ecx.machine.can_const_prop[place.local] {\n+            // Do nothing if the place is indirect.\n+            _ if place.is_indirect() => {}\n+            ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+            ConstPropMode::OnlyInsideOwnBlock | ConstPropMode::FullConstProp => {\n+                if self\n+                    .use_ecx(source_info, |this| this.ecx.eval_rvalue_into_place(rvalue, *place))\n+                    .is_none()\n+                {\n+                    // Const prop failed, so erase the destination, ensuring that whatever happens\n+                    // from here on, does not know about the previous value.\n+                    // This is important in case we have\n+                    // ```rust\n+                    // let mut x = 42;\n+                    // x = SOME_MUTABLE_STATIC;\n+                    // // x must now be uninit\n+                    // ```\n+                    // FIXME: we overzealously erase the entire local, because that's easier to\n+                    // implement.\n+                    trace!(\n+                        \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                        place,\n+                    );\n+                    Self::remove_const(&mut self.ecx, place.local);\n+                }\n+            }\n+        }\n+    }\n+\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, location: Location) {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (place, ref rval)) = statement.kind {\n-            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-            if let Some(()) = self.const_prop(rval, source_info, place) {\n-                match can_const_prop {\n-                    ConstPropMode::OnlyInsideOwnBlock => {\n-                        trace!(\n-                            \"found local restricted to its block. \\\n-                                Will remove it from const-prop after block is finished. Local: {:?}\",\n-                            place.local\n-                        );\n-                    }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        trace!(\"can't propagate into {:?}\", place);\n-                        if place.local != RETURN_PLACE {\n+\n+        // We want to evaluate operands before any change to the assigned-to value,\n+        // so we recurse first.\n+        self.super_statement(statement, location);\n+\n+        match statement.kind {\n+            StatementKind::SetDiscriminant { ref place, .. } => {\n+                match self.ecx.machine.can_const_prop[place.local] {\n+                    // Do nothing if the place is indirect.\n+                    _ if place.is_indirect() => {}\n+                    ConstPropMode::NoPropagation => self.ensure_not_propagated(place.local),\n+                    ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                        if self.use_ecx(source_info, |this| this.ecx.statement(statement)).is_some()\n+                        {\n+                            trace!(\"propped discriminant into {:?}\", place);\n+                        } else {\n                             Self::remove_const(&mut self.ecx, place.local);\n                         }\n                     }\n-                    ConstPropMode::FullConstProp => {}\n                 }\n-            } else {\n-                // Const prop failed, so erase the destination, ensuring that whatever happens\n-                // from here on, does not know about the previous value.\n-                // This is important in case we have\n-                // ```rust\n-                // let mut x = 42;\n-                // x = SOME_MUTABLE_STATIC;\n-                // // x must now be uninit\n-                // ```\n-                // FIXME: we overzealously erase the entire local, because that's easier to\n-                // implement.\n-                trace!(\n-                    \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                    place,\n-                );\n-                Self::remove_const(&mut self.ecx, place.local);\n             }\n-        } else {\n-            match statement.kind {\n-                StatementKind::SetDiscriminant { ref place, .. } => {\n-                    match self.ecx.machine.can_const_prop[place.local] {\n-                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                            if self\n-                                .use_ecx(source_info, |this| this.ecx.statement(statement))\n-                                .is_some()\n-                            {\n-                                trace!(\"propped discriminant into {:?}\", place);\n-                            } else {\n-                                Self::remove_const(&mut self.ecx, place.local);\n-                            }\n-                        }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            Self::remove_const(&mut self.ecx, place.local);\n-                        }\n-                    }\n-                }\n-                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n-                    let frame = self.ecx.frame_mut();\n-                    frame.locals[local].value =\n-                        if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Live(interpret::Operand::Immediate(\n-                                interpret::Immediate::Uninit,\n-                            ))\n-                        } else {\n-                            LocalValue::Dead\n-                        };\n-                }\n-                _ => {}\n+            StatementKind::StorageLive(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value =\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit));\n+            }\n+            StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = LocalValue::Dead;\n             }\n+            _ => {}\n         }\n-\n-        self.super_statement(statement, location);\n     }\n \n     fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n@@ -694,27 +683,25 @@ impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n             | TerminatorKind::Call { .. }\n             | TerminatorKind::InlineAsm { .. } => {}\n         }\n+    }\n+\n+    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.super_basic_block_data(block, data);\n \n         // We remove all Locals which are restricted in propagation to their containing blocks and\n         // which were modified in the current block.\n         // Take it out of the ecx so we can get a mutable reference to the ecx for `remove_const`.\n-        let mut locals = std::mem::take(&mut self.ecx.machine.written_only_inside_own_block_locals);\n-        for &local in locals.iter() {\n-            Self::remove_const(&mut self.ecx, local);\n-        }\n-        locals.clear();\n-        // Put it back so we reuse the heap of the storage\n-        self.ecx.machine.written_only_inside_own_block_locals = locals;\n-        if cfg!(debug_assertions) {\n-            // Ensure we are correctly erasing locals with the non-debug-assert logic.\n-            for local in self.ecx.machine.only_propagate_inside_block_locals.iter() {\n-                assert!(\n-                    self.get_const(local.into()).is_none()\n-                        || self\n-                            .layout_of(self.local_decls[local].ty)\n-                            .map_or(true, |layout| layout.is_zst())\n-                )\n+        let can_const_prop = std::mem::take(&mut self.ecx.machine.can_const_prop);\n+        for (local, &mode) in can_const_prop.iter_enumerated() {\n+            match mode {\n+                ConstPropMode::FullConstProp => {}\n+                ConstPropMode::NoPropagation => self.ensure_not_propagated(local),\n+                ConstPropMode::OnlyInsideOwnBlock => {\n+                    Self::remove_const(&mut self.ecx, local);\n+                    self.ensure_not_propagated(local);\n+                }\n             }\n         }\n+        self.ecx.machine.can_const_prop = can_const_prop;\n     }\n }"}, {"sha": "74985029e008a6c998707e3e54b18462cd6b0e43", "filename": "src/tools/clippy/tests/ui/erasing_op.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.rs?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -31,13 +31,15 @@ impl core::ops::Mul<i32> for Vec1 {\n \n #[allow(clippy::no_effect)]\n #[warn(clippy::erasing_op)]\n-fn main() {\n-    let x: u8 = 0;\n-\n+fn test(x: u8) {\n     x * 0;\n     0 & x;\n     0 / x;\n     0 * Meter; // no error: Output type is different from the non-zero argument\n     0 * Vec1 { x: 5 };\n     Vec1 { x: 5 } * 0;\n }\n+\n+fn main() {\n+    test(0)\n+}"}, {"sha": "97941252355af1271f8836c7052ccaedbc9f61cc", "filename": "src/tools/clippy/tests/ui/erasing_op.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ferasing_op.stderr?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -1,31 +1,31 @@\n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:37:5\n+  --> $DIR/erasing_op.rs:35:5\n    |\n LL |     x * 0;\n    |     ^^^^^\n    |\n    = note: `-D clippy::erasing-op` implied by `-D warnings`\n \n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:38:5\n+  --> $DIR/erasing_op.rs:36:5\n    |\n LL |     0 & x;\n    |     ^^^^^\n \n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:39:5\n+  --> $DIR/erasing_op.rs:37:5\n    |\n LL |     0 / x;\n    |     ^^^^^\n \n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:41:5\n+  --> $DIR/erasing_op.rs:39:5\n    |\n LL |     0 * Vec1 { x: 5 };\n    |     ^^^^^^^^^^^^^^^^^\n \n error: this operation will always return zero. This is likely not the intended outcome\n-  --> $DIR/erasing_op.rs:42:5\n+  --> $DIR/erasing_op.rs:40:5\n    |\n LL |     Vec1 { x: 5 } * 0;\n    |     ^^^^^^^^^^^^^^^^^"}, {"sha": "8dfdee662b9d7f8e21fd2a8d00a75e602c1b25f6", "filename": "src/tools/clippy/tests/ui/integer_arithmetic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Finteger_arithmetic.rs?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -4,7 +4,7 @@\n #[rustfmt::skip]\n fn main() {\n     let mut i = 1i32;\n-    let mut var1 = 0i32;\n+    let mut var1 = 13i32;\n     let mut var2 = -1i32;\n     1 + i;\n     i * 2;"}, {"sha": "e1e30114081ef0cb27d9caeac6c0eb33a12ac113", "filename": "src/tools/clippy/tests/ui/overflow_check_conditional.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foverflow_check_conditional.rs?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -1,9 +1,6 @@\n #![warn(clippy::overflow_check_conditional)]\n \n-fn main() {\n-    let a: u32 = 1;\n-    let b: u32 = 2;\n-    let c: u32 = 3;\n+fn test(a: u32, b: u32, c: u32) {\n     if a + b < a {}\n     if a > a + b {}\n     if a + b < b {}\n@@ -23,3 +20,7 @@ fn main() {\n     if i > i + j {}\n     if i - j < i {}\n }\n+\n+fn main() {\n+    test(1, 2, 3)\n+}"}, {"sha": "92d1d8ef911efcad667698a23b39e761001c70a5", "filename": "src/tools/clippy/tests/ui/overflow_check_conditional.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foverflow_check_conditional.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foverflow_check_conditional.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foverflow_check_conditional.stderr?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -1,49 +1,49 @@\n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:7:8\n+  --> $DIR/overflow_check_conditional.rs:4:8\n    |\n LL |     if a + b < a {}\n    |        ^^^^^^^^^\n    |\n    = note: `-D clippy::overflow-check-conditional` implied by `-D warnings`\n \n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:8:8\n+  --> $DIR/overflow_check_conditional.rs:5:8\n    |\n LL |     if a > a + b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:9:8\n+  --> $DIR/overflow_check_conditional.rs:6:8\n    |\n LL |     if a + b < b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C overflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:10:8\n+  --> $DIR/overflow_check_conditional.rs:7:8\n    |\n LL |     if b > a + b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:11:8\n+  --> $DIR/overflow_check_conditional.rs:8:8\n    |\n LL |     if a - b > b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:12:8\n+  --> $DIR/overflow_check_conditional.rs:9:8\n    |\n LL |     if b < a - b {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:13:8\n+  --> $DIR/overflow_check_conditional.rs:10:8\n    |\n LL |     if a - b > a {}\n    |        ^^^^^^^^^\n \n error: you are trying to use classic C underflow conditions that will fail in Rust\n-  --> $DIR/overflow_check_conditional.rs:14:8\n+  --> $DIR/overflow_check_conditional.rs:11:8\n    |\n LL |     if a < a - b {}\n    |        ^^^^^^^^^"}, {"sha": "bedfa5992ad59ea192bed4edc8d679494892e739", "filename": "tests/mir-opt/const_prop/bad_op_mod_by_zero.main.ConstProp.diff", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.main.ConstProp.diff?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -27,17 +27,19 @@\n       }\n   \n       bb1: {\n-          _5 = Eq(_1, const -1_i32);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+-         _5 = Eq(_1, const -1_i32);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n -         _6 = Eq(const 1_i32, const i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n -         _7 = BitAnd(move _5, move _6);   // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n -         assert(!move _7, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, _1) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n++         _5 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n +         _6 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n +         _7 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n-+         assert(!const false, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, _1) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n++         assert(!const false, \"attempt to compute the remainder of `{} % {}`, which would overflow\", const 1_i32, const 0_i32) -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n       }\n   \n       bb2: {\n-          _2 = Rem(const 1_i32, _1);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n+-         _2 = Rem(const 1_i32, _1);       // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n++         _2 = Rem(const 1_i32, const 0_i32); // scope 1 at $DIR/bad_op_mod_by_zero.rs:+2:14: +2:19\n           StorageDead(_2);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:+3:1: +3:2\n           return;                          // scope 0 at $DIR/bad_op_mod_by_zero.rs:+3:2: +3:2\n       }"}, {"sha": "6d8738aa61aaa4e7cb713b244501139d5bcd0955", "filename": "tests/mir-opt/const_prop/discriminant.main.ConstProp.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.32bit.diff?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -22,7 +22,7 @@\n -         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         _3 = const Option::<bool>::Some(true); // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:12:34: 12:44\n++                                          // + span: no-location\n +                                          // + literal: Const { ty: Option<bool>, val: Value(Scalar(0x01)) }\n +         _4 = const 1_isize;              // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         switchInt(const 1_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31"}, {"sha": "6d8738aa61aaa4e7cb713b244501139d5bcd0955", "filename": "tests/mir-opt/const_prop/discriminant.main.ConstProp.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Fdiscriminant.main.ConstProp.64bit.diff?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -22,7 +22,7 @@\n -         switchInt(move _4) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         _3 = const Option::<bool>::Some(true); // scope 2 at $DIR/discriminant.rs:+1:34: +1:44\n +                                          // mir::Constant\n-+                                          // + span: $DIR/discriminant.rs:12:34: 12:44\n++                                          // + span: no-location\n +                                          // + literal: Const { ty: Option<bool>, val: Value(Scalar(0x01)) }\n +         _4 = const 1_isize;              // scope 2 at $DIR/discriminant.rs:+1:21: +1:31\n +         switchInt(const 1_isize) -> [1: bb1, otherwise: bb3]; // scope 2 at $DIR/discriminant.rs:+1:21: +1:31"}, {"sha": "a38c1de2a7833f72ebf1c9ac540a8be443186ba6", "filename": "tests/mir-opt/const_prop/invalid_constant.main.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fconst_prop%2Finvalid_constant.main.ConstProp.diff?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -44,11 +44,11 @@\n -         _3 = [move _4];                  // scope 1 at $DIR/invalid_constant.rs:+13:24: +13:60\n +         _4 = const Scalar(0x00000004): E; // scope 4 at $DIR/invalid_constant.rs:+13:34: +13:57\n +                                          // mir::Constant\n-+                                          // + span: $DIR/invalid_constant.rs:28:34: 28:57\n++                                          // + span: no-location\n +                                          // + literal: Const { ty: E, val: Value(Scalar(0x00000004)) }\n +         _3 = [const Scalar(0x00000004): E]; // scope 1 at $DIR/invalid_constant.rs:+13:24: +13:60\n +                                          // mir::Constant\n-+                                          // + span: $DIR/invalid_constant.rs:28:24: 28:60\n++                                          // + span: no-location\n +                                          // + literal: Const { ty: E, val: Value(Scalar(0x00000004)) }\n           StorageDead(_4);                 // scope 1 at $DIR/invalid_constant.rs:+13:59: +13:60\n           StorageDead(_5);                 // scope 1 at $DIR/invalid_constant.rs:+13:60: +13:61"}, {"sha": "ec063294856c8cae24b9b3a9326d3ec6e6167312", "filename": "tests/mir-opt/funky_arms.float_to_exponential_common.ConstProp.diff", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Ffunky_arms.float_to_exponential_common.ConstProp.diff?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -54,7 +54,7 @@\n -         _6 = MinusPlus;                  // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n +         _6 = const MinusPlus;            // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n +                                          // mir::Constant\n-+                                          // + span: $DIR/funky_arms.rs:21:17: 21:41\n++                                          // + span: no-location\n +                                          // + literal: Const { ty: Sign, val: Value(Scalar(0x01)) }\n           goto -> bb4;                     // scope 1 at $DIR/funky_arms.rs:+10:17: +10:41\n       }\n@@ -63,7 +63,7 @@\n -         _6 = Minus;                      // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n +         _6 = const Minus;                // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n +                                          // mir::Constant\n-+                                          // + span: $DIR/funky_arms.rs:20:18: 20:38\n++                                          // + span: no-location\n +                                          // + literal: Const { ty: Sign, val: Value(Scalar(0x00)) }\n           goto -> bb4;                     // scope 1 at $DIR/funky_arms.rs:+9:18: +9:38\n       }"}, {"sha": "192b9ba204be34cd05cd732760b36d62de4e5e62", "filename": "tests/ui/consts/const-err-late.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fui%2Fconsts%2Fconst-err-late.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b05bb2900825e4d063ebf3f0f11afb08baed3bc6/tests%2Fui%2Fconsts%2Fconst-err-late.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconsts%2Fconst-err-late.stderr?ref=b05bb2900825e4d063ebf3f0f11afb08baed3bc6", "patch": "@@ -10,12 +10,6 @@ note: erroneous constant used\n LL |     black_box((S::<i32>::FOO, S::<u32>::FOO));\n    |                ^^^^^^^^^^^^^\n \n-note: erroneous constant used\n-  --> $DIR/const-err-late.rs:19:16\n-   |\n-LL |     black_box((S::<i32>::FOO, S::<u32>::FOO));\n-   |                ^^^^^^^^^^^^^\n-\n error[E0080]: evaluation of `S::<u32>::FOO` failed\n   --> $DIR/const-err-late.rs:13:21\n    |\n@@ -34,6 +28,12 @@ note: erroneous constant used\n LL |     black_box((S::<i32>::FOO, S::<u32>::FOO));\n    |                ^^^^^^^^^^^^^\n \n+note: erroneous constant used\n+  --> $DIR/const-err-late.rs:19:16\n+   |\n+LL |     black_box((S::<i32>::FOO, S::<u32>::FOO));\n+   |                ^^^^^^^^^^^^^\n+\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}