{"sha": "e7e9f2e6997ae12573cf4726935f232bf13fb40b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZTlmMmU2OTk3YWUxMjU3M2NmNDcyNjkzNWYyMzJiZjEzZmI0MGI=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-17T04:51:39Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-20T04:00:51Z"}, "message": "Remove IdxSet typedef and Rename {,Hybrid}IdxSetBuf as {,Hybrid}IdxSet.\n\nNow that the `Buf` vs. non-`Buf` distinction has been removed, it makes\nsense to drop the `Buf` suffix and use the shorter names everywhere.", "tree": {"sha": "1b4c91e3b9204a205ee2872240af79dc95b1175f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b4c91e3b9204a205ee2872240af79dc95b1175f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7e9f2e6997ae12573cf4726935f232bf13fb40b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e9f2e6997ae12573cf4726935f232bf13fb40b", "html_url": "https://github.com/rust-lang/rust/commit/e7e9f2e6997ae12573cf4726935f232bf13fb40b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7e9f2e6997ae12573cf4726935f232bf13fb40b/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab8dfbc7bb969378c2d7e8f7b0c29e26100707e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab8dfbc7bb969378c2d7e8f7b0c29e26100707e0", "html_url": "https://github.com/rust-lang/rust/commit/ab8dfbc7bb969378c2d7e8f7b0c29e26100707e0"}], "stats": {"total": 225, "additions": 111, "deletions": 114}, "files": [{"sha": "5f7c5190159c4ce8a1641469c069cebd42cdb291", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -49,7 +49,7 @@ use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use util::common::{ErrorReported};\n use util::profiling::ProfileCategory::*;\n \n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_target::spec::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -208,7 +208,7 @@ define_queries! { <'tcx>\n         /// Maps DefId's that have an associated Mir to the result\n         /// of the MIR qualify_consts pass. The actual meaning of\n         /// the value isn't known except to the pass itself.\n-        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSetBuf<mir::Local>>),\n+        [] fn mir_const_qualif: MirConstQualif(DefId) -> (u8, Lrc<IdxSet<mir::Local>>),\n \n         /// Fetch the MIR for a given def-id right after it's built - this includes\n         /// unreachable code."}, {"sha": "f21c898a28a340df42206d98ad594f4abea33aa3", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 58, "deletions": 61, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -27,33 +27,30 @@ use rustc_serialize;\n ///\n /// The representation is dense, using one bit per possible element.\n #[derive(Eq, PartialEq)]\n-pub struct IdxSetBuf<T: Idx> {\n+pub struct IdxSet<T: Idx> {\n     _pd: PhantomData<fn(&T)>,\n     bits: Vec<Word>,\n }\n \n-// FIXME: temporary\n-pub type IdxSet<T> = IdxSetBuf<T>;\n-\n-impl<T: Idx> Clone for IdxSetBuf<T> {\n+impl<T: Idx> Clone for IdxSet<T> {\n     fn clone(&self) -> Self {\n-        IdxSetBuf { _pd: PhantomData, bits: self.bits.clone() }\n+        IdxSet { _pd: PhantomData, bits: self.bits.clone() }\n     }\n }\n \n-impl<T: Idx> rustc_serialize::Encodable for IdxSetBuf<T> {\n+impl<T: Idx> rustc_serialize::Encodable for IdxSet<T> {\n     fn encode<E: rustc_serialize::Encoder>(&self,\n                                      encoder: &mut E)\n                                      -> Result<(), E::Error> {\n         self.bits.encode(encoder)\n     }\n }\n \n-impl<T: Idx> rustc_serialize::Decodable for IdxSetBuf<T> {\n-    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSetBuf<T>, D::Error> {\n+impl<T: Idx> rustc_serialize::Decodable for IdxSet<T> {\n+    fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<IdxSet<T>, D::Error> {\n         let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n \n-        Ok(IdxSetBuf {\n+        Ok(IdxSet {\n             _pd: PhantomData,\n             bits: words,\n         })\n@@ -62,18 +59,18 @@ impl<T: Idx> rustc_serialize::Decodable for IdxSetBuf<T> {\n \n const BITS_PER_WORD: usize = mem::size_of::<Word>() * 8;\n \n-impl<T: Idx> fmt::Debug for IdxSetBuf<T> {\n+impl<T: Idx> fmt::Debug for IdxSet<T> {\n     fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n         w.debug_list()\n          .entries(self.iter())\n          .finish()\n     }\n }\n \n-impl<T: Idx> IdxSetBuf<T> {\n+impl<T: Idx> IdxSet<T> {\n     fn new(init: Word, universe_size: usize) -> Self {\n         let num_words = (universe_size + (BITS_PER_WORD - 1)) / BITS_PER_WORD;\n-        IdxSetBuf {\n+        IdxSet {\n             _pd: Default::default(),\n             bits: vec![init; num_words],\n         }\n@@ -92,13 +89,13 @@ impl<T: Idx> IdxSetBuf<T> {\n     }\n \n     /// Duplicates as a hybrid set.\n-    pub fn to_hybrid(&self) -> HybridIdxSetBuf<T> {\n+    pub fn to_hybrid(&self) -> HybridIdxSet<T> {\n         // This universe_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n         let universe_size = self.bits.len() * BITS_PER_WORD;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n-        HybridIdxSetBuf::Dense(self.to_owned(), universe_size)\n+        HybridIdxSet::Dense(self.to_owned(), universe_size)\n     }\n \n     /// Removes all elements\n@@ -171,20 +168,20 @@ impl<T: Idx> IdxSetBuf<T> {\n         bitwise(self.words_mut(), other.words(), &Union)\n     }\n \n-    /// Like `union()`, but takes a `SparseIdxSetBuf` argument.\n-    fn union_sparse(&mut self, other: &SparseIdxSetBuf<T>) -> bool {\n+    /// Like `union()`, but takes a `SparseIdxSet` argument.\n+    fn union_sparse(&mut self, other: &SparseIdxSet<T>) -> bool {\n         let mut changed = false;\n         for elem in other.iter() {\n             changed |= self.add(&elem);\n         }\n         changed\n     }\n \n-    /// Like `union()`, but takes a `HybridIdxSetBuf` argument.\n-    pub fn union_hybrid(&mut self, other: &HybridIdxSetBuf<T>) -> bool {\n+    /// Like `union()`, but takes a `HybridIdxSet` argument.\n+    pub fn union_hybrid(&mut self, other: &HybridIdxSet<T>) -> bool {\n         match other {\n-            HybridIdxSetBuf::Sparse(sparse, _) => self.union_sparse(sparse),\n-            HybridIdxSetBuf::Dense(dense, _) => self.union(dense),\n+            HybridIdxSet::Sparse(sparse, _) => self.union_sparse(sparse),\n+            HybridIdxSet::Dense(dense, _) => self.union(dense),\n         }\n     }\n \n@@ -194,20 +191,20 @@ impl<T: Idx> IdxSetBuf<T> {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n \n-    /// Like `subtract()`, but takes a `SparseIdxSetBuf` argument.\n-    fn subtract_sparse(&mut self, other: &SparseIdxSetBuf<T>) -> bool {\n+    /// Like `subtract()`, but takes a `SparseIdxSet` argument.\n+    fn subtract_sparse(&mut self, other: &SparseIdxSet<T>) -> bool {\n         let mut changed = false;\n         for elem in other.iter() {\n             changed |= self.remove(&elem);\n         }\n         changed\n     }\n \n-    /// Like `subtract()`, but takes a `HybridIdxSetBuf` argument.\n-    pub fn subtract_hybrid(&mut self, other: &HybridIdxSetBuf<T>) -> bool {\n+    /// Like `subtract()`, but takes a `HybridIdxSet` argument.\n+    pub fn subtract_hybrid(&mut self, other: &HybridIdxSet<T>) -> bool {\n         match other {\n-            HybridIdxSetBuf::Sparse(sparse, _) => self.subtract_sparse(sparse),\n-            HybridIdxSetBuf::Dense(dense, _) => self.subtract(dense),\n+            HybridIdxSet::Sparse(sparse, _) => self.subtract_sparse(sparse),\n+            HybridIdxSet::Dense(dense, _) => self.subtract(dense),\n         }\n     }\n \n@@ -255,15 +252,15 @@ impl<'a, T: Idx> Iterator for Iter<'a, T> {\n const SPARSE_MAX: usize = 8;\n \n /// A sparse index set with a maximum of SPARSE_MAX elements. Used by\n-/// HybridIdxSetBuf; do not use directly.\n+/// HybridIdxSet; do not use directly.\n ///\n /// The elements are stored as an unsorted vector with no duplicates.\n #[derive(Clone, Debug)]\n-pub struct SparseIdxSetBuf<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n+pub struct SparseIdxSet<T: Idx>(ArrayVec<[T; SPARSE_MAX]>);\n \n-impl<T: Idx> SparseIdxSetBuf<T> {\n+impl<T: Idx> SparseIdxSet<T> {\n     fn new() -> Self {\n-        SparseIdxSetBuf(ArrayVec::new())\n+        SparseIdxSet(ArrayVec::new())\n     }\n \n     fn len(&self) -> usize {\n@@ -296,8 +293,8 @@ impl<T: Idx> SparseIdxSetBuf<T> {\n         }\n     }\n \n-    fn to_dense(&self, universe_size: usize) -> IdxSetBuf<T> {\n-        let mut dense = IdxSetBuf::new_empty(universe_size);\n+    fn to_dense(&self, universe_size: usize) -> IdxSet<T> {\n+        let mut dense = IdxSet::new_empty(universe_size);\n         for elem in self.0.iter() {\n             dense.add(elem);\n         }\n@@ -323,97 +320,97 @@ impl<'a, T: Idx> Iterator for SparseIter<'a, T> {\n     }\n }\n \n-/// Like IdxSetBuf, but with a hybrid representation: sparse when there are few\n+/// Like IdxSet, but with a hybrid representation: sparse when there are few\n /// elements in the set, but dense when there are many. It's especially\n /// efficient for sets that typically have a small number of elements, but a\n /// large `universe_size`, and are cleared frequently.\n #[derive(Clone, Debug)]\n-pub enum HybridIdxSetBuf<T: Idx> {\n-    Sparse(SparseIdxSetBuf<T>, usize),\n-    Dense(IdxSetBuf<T>, usize),\n+pub enum HybridIdxSet<T: Idx> {\n+    Sparse(SparseIdxSet<T>, usize),\n+    Dense(IdxSet<T>, usize),\n }\n \n-impl<T: Idx> HybridIdxSetBuf<T> {\n+impl<T: Idx> HybridIdxSet<T> {\n     pub fn new_empty(universe_size: usize) -> Self {\n-        HybridIdxSetBuf::Sparse(SparseIdxSetBuf::new(), universe_size)\n+        HybridIdxSet::Sparse(SparseIdxSet::new(), universe_size)\n     }\n \n     fn universe_size(&mut self) -> usize {\n         match *self {\n-            HybridIdxSetBuf::Sparse(_, size) => size,\n-            HybridIdxSetBuf::Dense(_, size) => size,\n+            HybridIdxSet::Sparse(_, size) => size,\n+            HybridIdxSet::Dense(_, size) => size,\n         }\n     }\n \n     pub fn clear(&mut self) {\n         let universe_size = self.universe_size();\n-        *self = HybridIdxSetBuf::new_empty(universe_size);\n+        *self = HybridIdxSet::new_empty(universe_size);\n     }\n \n     /// Returns true iff set `self` contains `elem`.\n     pub fn contains(&self, elem: &T) -> bool {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) => sparse.contains(elem),\n-            HybridIdxSetBuf::Dense(dense, _) => dense.contains(elem),\n+            HybridIdxSet::Sparse(sparse, _) => sparse.contains(elem),\n+            HybridIdxSet::Dense(dense, _) => dense.contains(elem),\n         }\n     }\n \n     /// Adds `elem` to the set `self`.\n     pub fn add(&mut self, elem: &T) -> bool {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n+            HybridIdxSet::Sparse(sparse, _) if sparse.len() < SPARSE_MAX => {\n                 // The set is sparse and has space for `elem`.\n                 sparse.add(elem)\n             }\n-            HybridIdxSetBuf::Sparse(sparse, _) if sparse.contains(elem) => {\n+            HybridIdxSet::Sparse(sparse, _) if sparse.contains(elem) => {\n                 // The set is sparse and does not have space for `elem`, but\n                 // that doesn't matter because `elem` is already present.\n                 false\n             }\n-            HybridIdxSetBuf::Sparse(_, _) => {\n+            HybridIdxSet::Sparse(_, _) => {\n                 // The set is sparse and full. Convert to a dense set.\n                 //\n                 // FIXME: This code is awful, but I can't work out how else to\n                 //        appease the borrow checker.\n-                let dummy = HybridIdxSetBuf::Sparse(SparseIdxSetBuf::new(), 0);\n+                let dummy = HybridIdxSet::Sparse(SparseIdxSet::new(), 0);\n                 match mem::replace(self, dummy) {\n-                    HybridIdxSetBuf::Sparse(sparse, universe_size) => {\n+                    HybridIdxSet::Sparse(sparse, universe_size) => {\n                         let mut dense = sparse.to_dense(universe_size);\n                         let changed = dense.add(elem);\n                         assert!(changed);\n-                        mem::replace(self, HybridIdxSetBuf::Dense(dense, universe_size));\n+                        mem::replace(self, HybridIdxSet::Dense(dense, universe_size));\n                         changed\n                     }\n                     _ => panic!(\"impossible\"),\n                 }\n             }\n \n-            HybridIdxSetBuf::Dense(dense, _) => dense.add(elem),\n+            HybridIdxSet::Dense(dense, _) => dense.add(elem),\n         }\n     }\n \n     /// Removes `elem` from the set `self`.\n     pub fn remove(&mut self, elem: &T) -> bool {\n         // Note: we currently don't bother going from Dense back to Sparse.\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) => sparse.remove(elem),\n-            HybridIdxSetBuf::Dense(dense, _) => dense.remove(elem),\n+            HybridIdxSet::Sparse(sparse, _) => sparse.remove(elem),\n+            HybridIdxSet::Dense(dense, _) => dense.remove(elem),\n         }\n     }\n \n     /// Converts to a dense set, consuming itself in the process.\n-    pub fn to_dense(self) -> IdxSetBuf<T> {\n+    pub fn to_dense(self) -> IdxSet<T> {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n-            HybridIdxSetBuf::Dense(dense, _) => dense,\n+            HybridIdxSet::Sparse(sparse, universe_size) => sparse.to_dense(universe_size),\n+            HybridIdxSet::Dense(dense, _) => dense,\n         }\n     }\n \n     /// Iteration order is unspecified.\n     pub fn iter(&self) -> HybridIter<T> {\n         match self {\n-            HybridIdxSetBuf::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n-            HybridIdxSetBuf::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n+            HybridIdxSet::Sparse(sparse, _) => HybridIter::Sparse(sparse.iter()),\n+            HybridIdxSet::Dense(dense, _) => HybridIter::Dense(dense.iter()),\n         }\n     }\n }\n@@ -439,7 +436,7 @@ fn test_trim_to() {\n     use std::cmp;\n \n     for i in 0..256 {\n-        let mut idx_buf: IdxSetBuf<usize> = IdxSetBuf::new_filled(128);\n+        let mut idx_buf: IdxSet<usize> = IdxSet::new_filled(128);\n         idx_buf.trim_to(i);\n \n         let elems: Vec<usize> = idx_buf.iter().collect();\n@@ -452,7 +449,7 @@ fn test_trim_to() {\n fn test_set_up_to() {\n     for i in 0..128 {\n         for mut idx_buf in\n-            vec![IdxSetBuf::new_empty(128), IdxSetBuf::new_filled(128)]\n+            vec![IdxSet::new_empty(128), IdxSet::new_filled(128)]\n             .into_iter()\n         {\n             idx_buf.set_up_to(i);\n@@ -467,7 +464,7 @@ fn test_set_up_to() {\n #[test]\n fn test_new_filled() {\n     for i in 0..128 {\n-        let idx_buf = IdxSetBuf::new_filled(i);\n+        let idx_buf = IdxSet::new_filled(i);\n         let elems: Vec<usize> = idx_buf.iter().collect();\n         let expected: Vec<usize> = (0..i).collect();\n         assert_eq!(elems, expected);"}, {"sha": "1024e69cc2b0e889b67d74b35ad75fbfba58240e", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -432,7 +432,7 @@ impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<\n }\n \n \n-impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSetBuf<I>\n+impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSet<I>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,"}, {"sha": "0c8ec753a18f6e6e126e7d263d4fce910c7c5506", "filename": "src/librustc_data_structures/work_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_data_structures%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_data_structures%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fwork_queue.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use indexed_set::IdxSetBuf;\n+use indexed_set::IdxSet;\n use indexed_vec::Idx;\n use std::collections::VecDeque;\n \n@@ -20,7 +20,7 @@ use std::collections::VecDeque;\n /// and also use a bit set to track occupancy.\n pub struct WorkQueue<T: Idx> {\n     deque: VecDeque<T>,\n-    set: IdxSetBuf<T>,\n+    set: IdxSet<T>,\n }\n \n impl<T: Idx> WorkQueue<T> {\n@@ -29,7 +29,7 @@ impl<T: Idx> WorkQueue<T> {\n     pub fn with_all(len: usize) -> Self {\n         WorkQueue {\n             deque: (0..len).map(T::new).collect(),\n-            set: IdxSetBuf::new_filled(len),\n+            set: IdxSet::new_filled(len),\n         }\n     }\n \n@@ -38,7 +38,7 @@ impl<T: Idx> WorkQueue<T> {\n     pub fn with_none(len: usize) -> Self {\n         WorkQueue {\n             deque: VecDeque::with_capacity(len),\n-            set: IdxSetBuf::new_empty(len),\n+            set: IdxSet::new_empty(len),\n         }\n     }\n "}, {"sha": "bbc4dbe09e147fe95319dbb94f0a661445bd47b4", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -43,7 +43,7 @@ use syntax::edition::Edition;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc::hir;\n \n macro_rules! provide {\n@@ -142,7 +142,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         mir\n     }\n     mir_const_qualif => {\n-        (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSetBuf::new_empty(0)))\n+        (cdata.mir_const_qualif(def_id.index), Lrc::new(IdxSet::new_empty(0)))\n     }\n     fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n     inherent_impls => { Lrc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }"}, {"sha": "fdec7e70622e4299fa1c4a957ddf400356f13bbc", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -27,7 +27,7 @@ use rustc::ty::{self, ParamEnv, TyCtxt, Ty};\n use rustc_errors::{Diagnostic, DiagnosticBuilder, Level};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::small_vec::SmallVec;\n \n@@ -166,7 +166,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         _ => Some(tcx.hir.body_owned_by(id)),\n     };\n \n-    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n     let mut flow_inits = FlowAtLocation::new(do_dataflow(\n         tcx,\n         mir,"}, {"sha": "ff68b5987e85a21d2ec9072e21c4dbb99f5a8b61", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -27,7 +27,7 @@ use rustc::mir::{\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common;\n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_data_structures::indexed_set::{IdxSet, IdxSetBuf};\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n \n@@ -468,7 +468,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // SCC. For each SCC, we visit its successors and compute\n         // their values, then we union all those values to get our\n         // own.\n-        let visited = &mut IdxSetBuf::new_empty(self.constraint_sccs.num_sccs());\n+        let visited = &mut IdxSet::new_empty(self.constraint_sccs.num_sccs());\n         for scc_index in self.constraint_sccs.all_sccs() {\n             self.propagate_constraint_sccs_if_new(scc_index, visited);\n         }"}, {"sha": "0dfc5b5b4b7e0cabd51c2845010c022b9e834c0f", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -12,7 +12,7 @@\n //! locations.\n \n use rustc::mir::{BasicBlock, Location};\n-use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSetBuf, Iter};\n+use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet, Iter};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dataflow::{BitDenotation, BlockSets, DataflowResults};\n@@ -67,9 +67,9 @@ where\n     BD: BitDenotation,\n {\n     base_results: DataflowResults<BD>,\n-    curr_state: IdxSetBuf<BD::Idx>,\n-    stmt_gen: HybridIdxSetBuf<BD::Idx>,\n-    stmt_kill: HybridIdxSetBuf<BD::Idx>,\n+    curr_state: IdxSet<BD::Idx>,\n+    stmt_gen: HybridIdxSet<BD::Idx>,\n+    stmt_kill: HybridIdxSet<BD::Idx>,\n }\n \n impl<BD> FlowAtLocation<BD>\n@@ -96,9 +96,9 @@ where\n \n     pub fn new(results: DataflowResults<BD>) -> Self {\n         let bits_per_block = results.sets().bits_per_block();\n-        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n-        let stmt_gen = HybridIdxSetBuf::new_empty(bits_per_block);\n-        let stmt_kill = HybridIdxSetBuf::new_empty(bits_per_block);\n+        let curr_state = IdxSet::new_empty(bits_per_block);\n+        let stmt_gen = HybridIdxSet::new_empty(bits_per_block);\n+        let stmt_kill = HybridIdxSet::new_empty(bits_per_block);\n         FlowAtLocation {\n             base_results: results,\n             curr_state: curr_state,"}, {"sha": "54f19428df76587e5d2eb352e9526b5e63849acf", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -11,7 +11,7 @@\n use syntax::ast::{self, MetaItem};\n \n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n-use rustc_data_structures::indexed_set::{HybridIdxSetBuf, IdxSet, IdxSetBuf};\n+use rustc_data_structures::indexed_set::{HybridIdxSet, IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::work_queue::WorkQueue;\n \n@@ -182,7 +182,7 @@ struct PropagationContext<'b, 'a: 'b, 'tcx: 'a, O> where O: 'b + BitDenotation\n impl<'a, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitDenotation\n {\n     fn propagate(&mut self) {\n-        let mut temp = IdxSetBuf::new_empty(self.flow_state.sets.bits_per_block);\n+        let mut temp = IdxSet::new_empty(self.flow_state.sets.bits_per_block);\n         let mut propcx = PropagationContext {\n             builder: self,\n         };\n@@ -353,7 +353,7 @@ pub fn state_for_location<'tcx, T: BitDenotation>(loc: Location,\n                                                   analysis: &T,\n                                                   result: &DataflowResults<T>,\n                                                   mir: &Mir<'tcx>)\n-    -> IdxSetBuf<T::Idx> {\n+    -> IdxSet<T::Idx> {\n     let mut on_entry = result.sets().on_entry_set_for(loc.block.index()).to_owned();\n     let mut kill_set = on_entry.to_hybrid();\n     let mut gen_set = kill_set.clone();\n@@ -437,7 +437,7 @@ impl<O: BitDenotation> DataflowState<O> {\n \n     pub(crate) fn interpret_hybrid_set<'c, P>(&self,\n                                               o: &'c O,\n-                                              set: &HybridIdxSetBuf<O::Idx>,\n+                                              set: &HybridIdxSet<O::Idx>,\n                                               render_idx: &P)\n                                               -> Vec<DebugFormatted>\n         where P: Fn(&O, O::Idx) -> DebugFormatted\n@@ -452,17 +452,17 @@ pub struct AllSets<E: Idx> {\n     bits_per_block: usize,\n \n     /// For each block, bits valid on entry to the block.\n-    on_entry_sets: Vec<IdxSetBuf<E>>,\n+    on_entry_sets: Vec<IdxSet<E>>,\n \n     /// For each block, bits generated by executing the statements in\n     /// the block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    gen_sets: Vec<HybridIdxSetBuf<E>>,\n+    gen_sets: Vec<HybridIdxSet<E>>,\n \n     /// For each block, bits killed by executing the statements in the\n     /// block. (For comparison, the Terminator for each block is\n     /// handled in a flow-specific manner during propagation.)\n-    kill_sets: Vec<HybridIdxSetBuf<E>>,\n+    kill_sets: Vec<HybridIdxSet<E>>,\n }\n \n /// Triple of sets associated with a given block.\n@@ -486,11 +486,11 @@ pub struct BlockSets<'a, E: Idx> {\n \n     /// Bits that are set to 1 by the time we exit the given block. Hybrid\n     /// because it usually contains only 0 or 1 elements.\n-    pub(crate) gen_set: &'a mut HybridIdxSetBuf<E>,\n+    pub(crate) gen_set: &'a mut HybridIdxSet<E>,\n \n     /// Bits that are set to 0 by the time we exit the given block. Hybrid\n     /// because it usually contains only 0 or 1 elements.\n-    pub(crate) kill_set: &'a mut HybridIdxSetBuf<E>,\n+    pub(crate) kill_set: &'a mut HybridIdxSet<E>,\n }\n \n impl<'a, E:Idx> BlockSets<'a, E> {\n@@ -549,13 +549,13 @@ impl<E:Idx> AllSets<E> {\n         }\n     }\n \n-    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSetBuf<E> {\n+    pub fn on_entry_set_for(&self, block_idx: usize) -> &IdxSet<E> {\n         &self.on_entry_sets[block_idx]\n     }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n+    pub fn gen_set_for(&self, block_idx: usize) -> &HybridIdxSet<E> {\n         &self.gen_sets[block_idx]\n     }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &HybridIdxSetBuf<E> {\n+    pub fn kill_set_for(&self, block_idx: usize) -> &HybridIdxSet<E> {\n         &self.kill_sets[block_idx]\n     }\n }\n@@ -713,11 +713,11 @@ impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D> where D: BitDenotation\n         let num_blocks = mir.basic_blocks().len();\n \n         let on_entry_sets = if D::bottom_value() {\n-            vec![IdxSetBuf::new_filled(bits_per_block); num_blocks]\n+            vec![IdxSet::new_filled(bits_per_block); num_blocks]\n         } else {\n-            vec![IdxSetBuf::new_empty(bits_per_block); num_blocks]\n+            vec![IdxSet::new_empty(bits_per_block); num_blocks]\n         };\n-        let gen_sets = vec![HybridIdxSetBuf::new_empty(bits_per_block); num_blocks];\n+        let gen_sets = vec![HybridIdxSet::new_empty(bits_per_block); num_blocks];\n         let kill_sets = gen_sets.clone();\n \n         DataflowAnalysis {"}, {"sha": "bbf896e624f205cd23ea692997ce2d13f5c57d92", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -18,7 +18,7 @@ use dataflow::{self, do_dataflow, DebugFormatted};\n use rustc::ty::{self, TyCtxt};\n use rustc::mir::*;\n use rustc::util::nodemap::FxHashMap;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n@@ -93,12 +93,12 @@ fn find_dead_unwinds<'a, 'tcx>(\n     mir: &Mir<'tcx>,\n     id: ast::NodeId,\n     env: &MoveDataParamEnv<'tcx, 'tcx>)\n-    -> IdxSetBuf<BasicBlock>\n+    -> IdxSet<BasicBlock>\n {\n     debug!(\"find_dead_unwinds({:?})\", mir.span);\n     // We only need to do this pass once, because unwind edges can only\n     // reach cleanup blocks, which can't have unwind edges themselves.\n-    let mut dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let mut dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n         do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n                     MaybeInitializedPlaces::new(tcx, mir, &env),\n@@ -112,7 +112,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n \n         let mut init_data = InitializationData {\n             live: flow_inits.sets().on_entry_set_for(bb.index()).to_owned(),\n-            dead: IdxSetBuf::new_empty(env.move_data.move_paths.len()),\n+            dead: IdxSet::new_empty(env.move_data.move_paths.len()),\n         };\n         debug!(\"find_dead_unwinds @ {:?}: {:?}; init_data={:?}\",\n                bb, bb_data, init_data.live);\n@@ -147,8 +147,8 @@ fn find_dead_unwinds<'a, 'tcx>(\n }\n \n struct InitializationData {\n-    live: IdxSetBuf<MovePathIndex>,\n-    dead: IdxSetBuf<MovePathIndex>\n+    live: IdxSet<MovePathIndex>,\n+    dead: IdxSet<MovePathIndex>\n }\n \n impl InitializationData {"}, {"sha": "744efb37832263d1a063ca1b6d9498a69c961458", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -68,7 +68,7 @@ use rustc::ty::subst::Substs;\n use util::dump_mir;\n use util::liveness::{self, IdentityMap, LivenessMode};\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use std::collections::HashMap;\n use std::borrow::Cow;\n use std::iter::once;\n@@ -369,7 +369,7 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                movable: bool) ->\n                                                (liveness::LiveVarSet<Local>,\n                                                 HashMap<BasicBlock, liveness::LiveVarSet<Local>>) {\n-    let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+    let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir.as_local_node_id(source.def_id).unwrap();\n \n     // Calculate when MIR locals have live storage. This gives us an upper bound of their\n@@ -381,7 +381,7 @@ fn locals_live_across_suspend_points<'a, 'tcx,>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Find the MIR locals which do not use StorageLive/StorageDead statements.\n     // The storage of these locals are always live.\n-    let mut ignored = StorageIgnored(IdxSetBuf::new_filled(mir.local_decls.len()));\n+    let mut ignored = StorageIgnored(IdxSet::new_filled(mir.local_decls.len()));\n     ignored.visit_mir(mir);\n \n     // Calculate the MIR locals which have been previously"}, {"sha": "22bf7645060391994cb567e278dbabef80e3027e", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -15,7 +15,7 @@\n //! diagnostics as to why a constant rvalue wasn't promoted.\n \n use rustc_data_structures::bitvec::BitArray;\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_data_structures::fx::FxHashSet;\n use rustc::hir;\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Qualify a whole const, static initializer or const fn.\n-    fn qualify_const(&mut self) -> (Qualif, Lrc<IdxSetBuf<Local>>) {\n+    fn qualify_const(&mut self) -> (Qualif, Lrc<IdxSet<Local>>) {\n         debug!(\"qualifying {} {:?}\", self.mode, self.def_id);\n \n         let mir = self.mir;\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n \n \n         // Collect all the temps we need to promote.\n-        let mut promoted_temps = IdxSetBuf::new_empty(self.temp_promotion_state.len());\n+        let mut promoted_temps = IdxSet::new_empty(self.temp_promotion_state.len());\n \n         for candidate in &self.promotion_candidates {\n             match *candidate {\n@@ -1082,7 +1082,7 @@ pub fn provide(providers: &mut Providers) {\n \n fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               def_id: DefId)\n-                              -> (u8, Lrc<IdxSetBuf<Local>>) {\n+                              -> (u8, Lrc<IdxSet<Local>>) {\n     // NB: This `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_validated()`, which steals\n     // from `mir_const(), forces this query to execute before\n@@ -1091,7 +1091,7 @@ fn mir_const_qualif<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if mir.return_ty().references_error() {\n         tcx.sess.delay_span_bug(mir.span, \"mir_const_qualif: Mir had errors\");\n-        return (Qualif::NOT_CONST.bits(), Lrc::new(IdxSetBuf::new_empty(0)));\n+        return (Qualif::NOT_CONST.bits(), Lrc::new(IdxSet::new_empty(0)));\n     }\n \n     let mut qualifier = Qualifier::new(tcx, def_id, mir, Mode::Const);"}, {"sha": "c471853175422abf627f6d9aa0a32ba4d5384280", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::Span;\n \n use rustc::ty::{self, TyCtxt};\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n \n@@ -47,7 +47,7 @@ impl MirPass for SanityCheck {\n         let param_env = tcx.param_env(def_id);\n         let move_data = MoveData::gather_moves(mir, tcx).unwrap();\n         let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n-        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let dead_unwinds = IdxSet::new_empty(mir.basic_blocks().len());\n         let flow_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                         MaybeInitializedPlaces::new(tcx, mir, &mdpe),"}, {"sha": "04fa516a655a66c9878e736128e2bc9d81927078", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e9f2e6997ae12573cf4726935f232bf13fb40b/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=e7e9f2e6997ae12573cf4726935f232bf13fb40b", "patch": "@@ -38,7 +38,7 @@ use rustc::mir::visit::{PlaceContext, Visitor};\n use rustc::mir::Local;\n use rustc::mir::*;\n use rustc::ty::{item_path, TyCtxt};\n-use rustc_data_structures::indexed_set::IdxSetBuf;\n+use rustc_data_structures::indexed_set::IdxSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::work_queue::WorkQueue;\n use std::fs;\n@@ -47,7 +47,7 @@ use std::path::{Path, PathBuf};\n use transform::MirSource;\n use util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LiveVarSet<V> = IdxSetBuf<V>;\n+pub type LiveVarSet<V> = IdxSet<V>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks. You can use `simulate_block` to obtain the"}]}