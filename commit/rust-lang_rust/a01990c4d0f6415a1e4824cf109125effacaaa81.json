{"sha": "a01990c4d0f6415a1e4824cf109125effacaaa81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEwMTk5MGM0ZDBmNjQxNWExZTQ4MjRjZjEwOTEyNWVmZmFjYWFhODE=", "commit": {"author": {"name": "wada314", "email": "pc@wada314.jp", "date": "2019-01-14T23:41:09Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2019-01-14T23:41:09Z"}, "message": "Use Unicode-standard char width to wrap comments or strings. (#3275)", "tree": {"sha": "2a425cd1cc09edbca042d745ae0e7d06f7e4306a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a425cd1cc09edbca042d745ae0e7d06f7e4306a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a01990c4d0f6415a1e4824cf109125effacaaa81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a01990c4d0f6415a1e4824cf109125effacaaa81", "html_url": "https://github.com/rust-lang/rust/commit/a01990c4d0f6415a1e4824cf109125effacaaa81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a01990c4d0f6415a1e4824cf109125effacaaa81/comments", "author": {"login": "wada314", "id": 1488411, "node_id": "MDQ6VXNlcjE0ODg0MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1488411?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wada314", "html_url": "https://github.com/wada314", "followers_url": "https://api.github.com/users/wada314/followers", "following_url": "https://api.github.com/users/wada314/following{/other_user}", "gists_url": "https://api.github.com/users/wada314/gists{/gist_id}", "starred_url": "https://api.github.com/users/wada314/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wada314/subscriptions", "organizations_url": "https://api.github.com/users/wada314/orgs", "repos_url": "https://api.github.com/users/wada314/repos", "events_url": "https://api.github.com/users/wada314/events{/privacy}", "received_events_url": "https://api.github.com/users/wada314/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "503cddeb0f4a4e95e001a92cd2ed1c40587b6105", "url": "https://api.github.com/repos/rust-lang/rust/commits/503cddeb0f4a4e95e001a92cd2ed1c40587b6105", "html_url": "https://github.com/rust-lang/rust/commit/503cddeb0f4a4e95e001a92cd2ed1c40587b6105"}], "stats": {"total": 195, "additions": 136, "deletions": 59}, "files": [{"sha": "ef4b6fd92a7511ff25d265adba4ffacb7a3a87da", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -595,6 +595,8 @@ dependencies = [\n  \"term 0.5.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"unicode_categories 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -748,6 +750,11 @@ name = \"unicode-xid\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n+[[package]]\n+name = \"unicode_categories\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+\n [[package]]\n name = \"unreachable\"\n version = \"1.0.0\"\n@@ -896,6 +903,7 @@ dependencies = [\n \"checksum unicode-segmentation 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\"\n \"checksum unicode-width 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526\"\n \"checksum unicode-xid 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n+\"checksum unicode_categories 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"39ec24b3121d976906ece63c9daad25b85969647682eee313cb5779fdd69e14e\"\n \"checksum unreachable 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"382810877fe448991dfc7f0dd6e3ae5d58088fd0ea5e35189655f84e6814fa56\"\n \"checksum utf8-ranges 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"796f7e48bef87609f7ade7e06495a87d5cd06c7866e6a5cbfceffc558a243737\"\n \"checksum version_check 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"914b1a6776c4c929a602fafd8bc742e06365d4bcbe48c30f9cca5824f70dc9dd\""}, {"sha": "9e0bce1dc08a183db4b9b64e22b09dd6ec885682", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -53,6 +53,8 @@ rustc-ap-syntax = \"306.0.0\"\n rustc-ap-syntax_pos = \"306.0.0\"\n failure = \"0.1.1\"\n bytecount = \"0.4\"\n+unicode-width = \"0.1.5\"\n+unicode_categories = \"0.1.1\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`"}, {"sha": "3841424904fc252dafede420455db9a6cdb44c57", "filename": "src/comment.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -19,7 +19,9 @@ use config::Config;\n use rewrite::RewriteContext;\n use shape::{Indent, Shape};\n use string::{rewrite_string, StringFormat};\n-use utils::{count_newlines, first_line_width, last_line_width, trim_left_preserve_layout};\n+use utils::{\n+    count_newlines, first_line_width, last_line_width, trim_left_preserve_layout, unicode_str_width,\n+};\n use {ErrorKind, FormattingError};\n \n fn is_custom_comment(comment: &str) -> bool {\n@@ -264,7 +266,8 @@ fn identify_comment(\n ) -> Option<String> {\n     let style = comment_style(orig, false);\n \n-    // Computes the len of line taking into account a newline if the line is part of a paragraph.\n+    // Computes the byte length of line taking into account a newline if the line is part of a\n+    // paragraph.\n     fn compute_len(orig: &str, line: &str) -> usize {\n         if orig.len() > line.len() {\n             if orig.as_bytes()[line.len()] == b'\\r' {\n@@ -498,7 +501,7 @@ struct CommentRewrite<'a> {\n     item_block: Option<ItemizedBlock>,\n     comment_line_separator: String,\n     indent_str: String,\n-    max_chars: usize,\n+    max_width: usize,\n     fmt_indent: Indent,\n     fmt: StringFormat<'a>,\n \n@@ -520,7 +523,7 @@ impl<'a> CommentRewrite<'a> {\n             comment_style(orig, config.normalize_comments()).to_str_tuplet()\n         };\n \n-        let max_chars = shape\n+        let max_width = shape\n             .width\n             .checked_sub(closer.len() + opener.len())\n             .unwrap_or(1);\n@@ -534,7 +537,7 @@ impl<'a> CommentRewrite<'a> {\n             code_block_attr: None,\n             item_block: None,\n             comment_line_separator: format!(\"{}{}\", indent_str, line_start),\n-            max_chars,\n+            max_width,\n             indent_str,\n             fmt_indent,\n \n@@ -543,7 +546,7 @@ impl<'a> CommentRewrite<'a> {\n                 closer: \"\",\n                 line_start,\n                 line_end: \"\",\n-                shape: Shape::legacy(max_chars, fmt_indent),\n+                shape: Shape::legacy(max_width, fmt_indent),\n                 trim_end: true,\n                 config,\n             },\n@@ -583,14 +586,14 @@ impl<'a> CommentRewrite<'a> {\n \n         if let Some(ref ib) = self.item_block {\n             // the last few lines are part of an itemized block\n-            self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+            self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n             let item_fmt = ib.create_string_format(&self.fmt);\n             self.result.push_str(&self.comment_line_separator);\n             self.result.push_str(&ib.opener);\n             match rewrite_string(\n                 &ib.trimmed_block_as_string(),\n                 &item_fmt,\n-                self.max_chars.saturating_sub(ib.indent),\n+                self.max_width.saturating_sub(ib.indent),\n             ) {\n                 Some(s) => self.result.push_str(&Self::join_block(\n                     &s,\n@@ -626,14 +629,14 @@ impl<'a> CommentRewrite<'a> {\n                 return false;\n             }\n             self.is_prev_line_multi_line = false;\n-            self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+            self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n             let item_fmt = ib.create_string_format(&self.fmt);\n             self.result.push_str(&self.comment_line_separator);\n             self.result.push_str(&ib.opener);\n             match rewrite_string(\n                 &ib.trimmed_block_as_string(),\n                 &item_fmt,\n-                self.max_chars.saturating_sub(ib.indent),\n+                self.max_width.saturating_sub(ib.indent),\n             ) {\n                 Some(s) => self.result.push_str(&Self::join_block(\n                     &s,\n@@ -710,8 +713,11 @@ impl<'a> CommentRewrite<'a> {\n             }\n         }\n \n-        if self.fmt.config.wrap_comments() && line.len() > self.fmt.shape.width && !has_url(line) {\n-            match rewrite_string(line, &self.fmt, self.max_chars) {\n+        if self.fmt.config.wrap_comments()\n+            && unicode_str_width(line) > self.fmt.shape.width\n+            && !has_url(line)\n+        {\n+            match rewrite_string(line, &self.fmt, self.max_width) {\n                 Some(ref s) => {\n                     self.is_prev_line_multi_line = s.contains('\\n');\n                     self.result.push_str(s);\n@@ -721,8 +727,8 @@ impl<'a> CommentRewrite<'a> {\n                     // Remove the trailing space, then start rewrite on the next line.\n                     self.result.pop();\n                     self.result.push_str(&self.comment_line_separator);\n-                    self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n-                    match rewrite_string(line, &self.fmt, self.max_chars) {\n+                    self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n+                    match rewrite_string(line, &self.fmt, self.max_width) {\n                         Some(ref s) => {\n                             self.is_prev_line_multi_line = s.contains('\\n');\n                             self.result.push_str(s);\n@@ -743,20 +749,20 @@ impl<'a> CommentRewrite<'a> {\n                 // 1 = \" \"\n                 let offset = 1 + last_line_width(&self.result) - self.line_start.len();\n                 Shape {\n-                    width: self.max_chars.saturating_sub(offset),\n+                    width: self.max_width.saturating_sub(offset),\n                     indent: self.fmt_indent,\n                     offset: self.fmt.shape.offset + offset,\n                 }\n             } else {\n-                Shape::legacy(self.max_chars, self.fmt_indent)\n+                Shape::legacy(self.max_width, self.fmt_indent)\n             };\n         } else {\n             if line.is_empty() && self.result.ends_with(' ') && !is_last {\n                 // Remove space if this is an empty comment or a doc comment.\n                 self.result.pop();\n             }\n             self.result.push_str(line);\n-            self.fmt.shape = Shape::legacy(self.max_chars, self.fmt_indent);\n+            self.fmt.shape = Shape::legacy(self.max_width, self.fmt_indent);\n             self.is_prev_line_multi_line = false;\n         }\n "}, {"sha": "ce28fce31827af44e199fdd6247198411dd94b1b", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -29,7 +29,9 @@ extern crate serde_json;\n extern crate syntax;\n extern crate syntax_pos;\n extern crate toml;\n+extern crate unicode_categories;\n extern crate unicode_segmentation;\n+extern crate unicode_width;\n \n use std::cell::RefCell;\n use std::collections::HashMap;"}, {"sha": "8c4bac2a8a50780e05b40ee63b521c2b8ca0f41a", "filename": "src/overflow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -431,7 +431,8 @@ impl<'a> Context<'a> {\n         };\n \n         if let Some(rewrite) = rewrite {\n-            let rewrite_first_line = Some(rewrite[..first_line_width(&rewrite)].to_owned());\n+            // splitn(2, *).next().unwrap() is always safe.\n+            let rewrite_first_line = Some(rewrite.splitn(2, '\\n').next().unwrap().to_owned());\n             last_list_item.item = rewrite_first_line;\n             Some(rewrite)\n         } else {"}, {"sha": "dc48a6b13fd02a589bb1dfadbd66ede5a397428e", "filename": "src/string.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -11,11 +11,12 @@\n // Format string literals.\n \n use regex::Regex;\n+use unicode_categories::UnicodeCategories;\n use unicode_segmentation::UnicodeSegmentation;\n \n use config::Config;\n use shape::Shape;\n-use utils::wrap_str;\n+use utils::{unicode_str_width, wrap_str};\n \n const MIN_STRING: usize = 10;\n \n@@ -53,7 +54,7 @@ impl<'a> StringFormat<'a> {\n     /// indentation into account.\n     ///\n     /// If we cannot put at least a single character per line, the rewrite won't succeed.\n-    fn max_chars_with_indent(&self) -> Option<usize> {\n+    fn max_width_with_indent(&self) -> Option<usize> {\n         Some(\n             self.shape\n                 .width\n@@ -62,10 +63,10 @@ impl<'a> StringFormat<'a> {\n         )\n     }\n \n-    /// Like max_chars_with_indent but the indentation is not subtracted.\n+    /// Like max_width_with_indent but the indentation is not subtracted.\n     /// This allows to fit more graphemes from the string on a line when\n     /// SnippetState::EndWithLineFeed.\n-    fn max_chars_without_indent(&self) -> Option<usize> {\n+    fn max_width_without_indent(&self) -> Option<usize> {\n         Some(self.config.max_width().checked_sub(self.line_end.len())?)\n     }\n }\n@@ -75,8 +76,8 @@ pub fn rewrite_string<'a>(\n     fmt: &StringFormat<'a>,\n     newline_max_chars: usize,\n ) -> Option<String> {\n-    let max_chars_with_indent = fmt.max_chars_with_indent()?;\n-    let max_chars_without_indent = fmt.max_chars_without_indent()?;\n+    let max_width_with_indent = fmt.max_width_with_indent()?;\n+    let max_width_without_indent = fmt.max_width_without_indent()?;\n     let indent_with_newline = fmt.shape.indent.to_string_with_newline(fmt.config);\n     let indent_without_newline = fmt.shape.indent.to_string(fmt.config);\n \n@@ -99,11 +100,11 @@ pub fn rewrite_string<'a>(\n \n     // Snip a line at a time from `stripped_str` until it is used up. Push the snippet\n     // onto result.\n-    let mut cur_max_chars = max_chars_with_indent;\n+    let mut cur_max_width = max_width_with_indent;\n     let is_bareline_ok = fmt.line_start.is_empty() || is_whitespace(fmt.line_start);\n     loop {\n         // All the input starting at cur_start fits on the current line\n-        if graphemes.len() - cur_start <= cur_max_chars {\n+        if graphemes_width(&graphemes[cur_start..]) <= cur_max_width {\n             for (i, grapheme) in graphemes[cur_start..].iter().enumerate() {\n                 if is_new_line(grapheme) {\n                     // take care of blank lines\n@@ -123,7 +124,7 @@ pub fn rewrite_string<'a>(\n \n         // The input starting at cur_start needs to be broken\n         match break_string(\n-            cur_max_chars,\n+            cur_max_width,\n             fmt.trim_end,\n             fmt.line_end,\n             &graphemes[cur_start..],\n@@ -133,7 +134,7 @@ pub fn rewrite_string<'a>(\n                 result.push_str(fmt.line_end);\n                 result.push_str(&indent_with_newline);\n                 result.push_str(fmt.line_start);\n-                cur_max_chars = newline_max_chars;\n+                cur_max_width = newline_max_chars;\n                 cur_start += len;\n             }\n             SnippetState::EndWithLineFeed(line, len) => {\n@@ -143,11 +144,11 @@ pub fn rewrite_string<'a>(\n                 result.push_str(&line);\n                 if is_bareline_ok {\n                     // the next line can benefit from the full width\n-                    cur_max_chars = max_chars_without_indent;\n+                    cur_max_width = max_width_without_indent;\n                 } else {\n                     result.push_str(&indent_without_newline);\n                     result.push_str(fmt.line_start);\n-                    cur_max_chars = max_chars_with_indent;\n+                    cur_max_width = max_width_with_indent;\n                 }\n                 cur_start += len;\n             }\n@@ -226,9 +227,10 @@ fn not_whitespace_except_line_feed(g: &str) -> bool {\n     is_new_line(g) || !is_whitespace(g)\n }\n \n-/// Break the input string at a boundary character around the offset `max_chars`. A boundary\n+/// Break the input string at a boundary character around the offset `max_width`. A boundary\n /// character is either a punctuation or a whitespace.\n-fn break_string(max_chars: usize, trim_end: bool, line_end: &str, input: &[&str]) -> SnippetState {\n+/// FIXME(issue#3281): We must follow UAX#14 algorithm instead of this.\n+fn break_string(max_width: usize, trim_end: bool, line_end: &str, input: &[&str]) -> SnippetState {\n     let break_at = |index /* grapheme at index is included */| {\n         // Take in any whitespaces to the left/right of `input[index]` while\n         // preserving line feeds\n@@ -272,19 +274,33 @@ fn break_string(max_chars: usize, trim_end: bool, line_end: &str, input: &[&str]\n         }\n     };\n \n+    // find a first index where the unicode width of input[0..x] become > max_width\n+    let max_width_index_in_input = {\n+        let mut cur_width = 0;\n+        let mut cur_index = 0;\n+        for (i, grapheme) in input.iter().enumerate() {\n+            cur_width += unicode_str_width(grapheme);\n+            cur_index = i;\n+            if cur_width > max_width {\n+                break;\n+            }\n+        }\n+        cur_index\n+    };\n+\n     // Find the position in input for breaking the string\n     if line_end.is_empty()\n         && trim_end\n-        && !is_whitespace(input[max_chars - 1])\n-        && is_whitespace(input[max_chars])\n+        && !is_whitespace(input[max_width_index_in_input - 1])\n+        && is_whitespace(input[max_width_index_in_input])\n     {\n         // At a breaking point already\n         // The line won't invalidate the rewriting because:\n         // - no extra space needed for the line_end character\n         // - extra whitespaces to the right can be trimmed\n-        return break_at(max_chars - 1);\n+        return break_at(max_width_index_in_input - 1);\n     }\n-    if let Some(url_index_end) = detect_url(input, max_chars) {\n+    if let Some(url_index_end) = detect_url(input, max_width_index_in_input) {\n         let index_plus_ws = url_index_end\n             + input[url_index_end..]\n                 .iter()\n@@ -297,27 +313,28 @@ fn break_string(max_chars: usize, trim_end: bool, line_end: &str, input: &[&str]\n             return SnippetState::LineEnd(input[..=index_plus_ws].concat(), index_plus_ws + 1);\n         };\n     }\n-    match input[0..max_chars]\n+\n+    match input[0..max_width_index_in_input]\n         .iter()\n         .rposition(|grapheme| is_whitespace(grapheme))\n     {\n         // Found a whitespace and what is on its left side is big enough.\n         Some(index) if index >= MIN_STRING => break_at(index),\n         // No whitespace found, try looking for a punctuation instead\n-        _ => match input[0..max_chars]\n+        _ => match input[0..max_width_index_in_input]\n             .iter()\n             .rposition(|grapheme| is_punctuation(grapheme))\n         {\n             // Found a punctuation and what is on its left side is big enough.\n             Some(index) if index >= MIN_STRING => break_at(index),\n             // Either no boundary character was found to the left of `input[max_chars]`, or the line\n             // got too small. We try searching for a boundary character to the right.\n-            _ => match input[max_chars..]\n+            _ => match input[max_width_index_in_input..]\n                 .iter()\n                 .position(|grapheme| is_whitespace(grapheme) || is_punctuation(grapheme))\n             {\n                 // A boundary was found after the line limit\n-                Some(index) => break_at(max_chars + index),\n+                Some(index) => break_at(max_width_index_in_input + index),\n                 // No boundary to the right, the input cannot be broken\n                 None => SnippetState::EndOfInput(input.concat()),\n             },\n@@ -335,10 +352,11 @@ fn is_whitespace(grapheme: &str) -> bool {\n }\n \n fn is_punctuation(grapheme: &str) -> bool {\n-    match grapheme.as_bytes()[0] {\n-        b':' | b',' | b';' | b'.' => true,\n-        _ => false,\n-    }\n+    grapheme.chars().all(|c| c.is_punctuation_other())\n+}\n+\n+fn graphemes_width(graphemes: &[&str]) -> usize {\n+    graphemes.iter().map(|s| unicode_str_width(s)).sum()\n }\n \n #[cfg(test)]"}, {"sha": "9efe57e727753590847aafee6d69d05a803be5a7", "filename": "src/utils.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -26,6 +26,8 @@ use config::Config;\n use rewrite::RewriteContext;\n use shape::{Indent, Shape};\n \n+use unicode_width::UnicodeWidthStr;\n+\n pub const DEPR_SKIP_ANNOTATION: &str = \"rustfmt_skip\";\n pub const SKIP_ANNOTATION: &str = \"rustfmt::skip\";\n \n@@ -193,19 +195,13 @@ pub fn is_attributes_extendable(attrs_str: &str) -> bool {\n // The width of the first line in s.\n #[inline]\n pub fn first_line_width(s: &str) -> usize {\n-    match s.find('\\n') {\n-        Some(n) => n,\n-        None => s.len(),\n-    }\n+    unicode_str_width(s.splitn(2, '\\n').next().unwrap_or(\"\"))\n }\n \n // The width of the last line in s.\n #[inline]\n pub fn last_line_width(s: &str) -> usize {\n-    match s.rfind('\\n') {\n-        Some(n) => s.len() - n - 1,\n-        None => s.len(),\n-    }\n+    unicode_str_width(s.rsplitn(2, '\\n').next().unwrap_or(\"\"))\n }\n \n // The total used width of the last line.\n@@ -214,16 +210,16 @@ pub fn last_line_used_width(s: &str, offset: usize) -> usize {\n     if s.contains('\\n') {\n         last_line_width(s)\n     } else {\n-        offset + s.len()\n+        offset + unicode_str_width(s)\n     }\n }\n \n #[inline]\n pub fn trimmed_last_line_width(s: &str) -> usize {\n-    match s.rfind('\\n') {\n-        Some(n) => s[(n + 1)..].trim().len(),\n-        None => s.trim().len(),\n-    }\n+    unicode_str_width(match s.rfind('\\n') {\n+        Some(n) => s[(n + 1)..].trim(),\n+        None => s.trim(),\n+    })\n }\n \n #[inline]\n@@ -370,11 +366,15 @@ fn is_valid_str(snippet: &str, max_width: usize, shape: Shape) -> bool {\n             return false;\n         }\n         // If the snippet does not include newline, we are done.\n-        if first_line_width(snippet) == snippet.len() {\n+        if is_single_line(snippet) {\n             return true;\n         }\n         // The other lines must fit within the maximum width.\n-        if snippet.lines().skip(1).any(|line| line.len() > max_width) {\n+        if snippet\n+            .lines()\n+            .skip(1)\n+            .any(|line| unicode_str_width(line) > max_width)\n+        {\n             return false;\n         }\n         // A special check for the last line, since the caller may\n@@ -593,6 +593,10 @@ impl NodeIdExt for NodeId {\n     }\n }\n \n+pub(crate) fn unicode_str_width(s: &str) -> usize {\n+    s.width()\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "e5d72113ce61f59ebe356c1977c536d027c9eecb", "filename": "tests/source/comment6.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Fsource%2Fcomment6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Fsource%2Fcomment6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcomment6.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -0,0 +1,10 @@\n+// rustfmt-wrap_comments: true\n+\n+// Pendant la nuit du 9 mars 1860, les nuages, se confondant avec la mer, limitaient \u00e0 quelques brasses la port\u00e9e de la vue.\n+// Sur cette mer d\u00e9mont\u00e9e, dont les lames d\u00e9ferlaient en projetant des lueurs livides, un l\u00e9ger b\u00e2timent fuyait presque \u00e0 sec de toile.\n+\n+pub mod foo {}\n+\n+// \u3086\u304f\u6cb3\u306e\u6d41\u308c\u306f\u7d76\u3048\u305a\u3057\u3066\u3001\u3057\u304b\u3082\u3082\u3068\u306e\u6c34\u306b\u3042\u3089\u305a\u3002\u6dc0\u307f\u306b\u6d6e\u304b\u3076\u3046\u305f\u304b\u305f\u306f\u3001\u304b\u3064\u6d88\u3048\u304b\u3064\u7d50\u3073\u3066\u3001\u4e45\u3057\u304f\u3068\u3069\u307e\u308a\u305f\u308b\u305f\u3081\u3057\u306a\u3057\u3002\u4e16\u306e\u4e2d\u306b\u3042\u308b\u4eba\u3068\u3059\u307f\u304b\u3068\u3001\u307e\u305f\u304b\u304f\u306e\u3054\u3068\u3057\u3002\n+\n+pub mod bar {}"}, {"sha": "552c461ed3481d6f9aa73f7e43febeef3dcb83e3", "filename": "tests/source/string_punctuation.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Fsource%2Fstring_punctuation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Fsource%2Fstring_punctuation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fstring_punctuation.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -4,4 +4,6 @@ fn main() {\n     println!(\"ThisIsAReallyLongStringWithNoSpaces.It_should_prefer_to_break_onpunctuation:Likethisssssssssssss\");\n     format!(\"{}__{}__{}ItShouldOnlyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyNoticeSemicolonsPeriodsColonsAndCommasAndResortToMid-CharBreaksAfterPunctuation{}{}\",x,y,z,a,b);\n     println!(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaalhijalfhiigjapdighjapdigjapdighdapighapdighpaidhg;adopgihadoguaadbadgad,qeoihapethae8t0aet8haetadbjtaeg;ooeouthaoeutgadlgajduabgoiuadogabudogubaodugbadgadgadga;adoughaoeugbaouea\");\n+    println!(\"sentuhaesnuthaesnutheasunteahusnaethuseantuihaesntdiastnidaetnuhaideuhsenathe\u3002WeShouldSupportNonAsciiPunctuations\u00a7ensuhatheasunteahsuneathusneathuasnuhaesnuhaesnuaethusnaetuheasnuth\");\n+    println!(\"ThisIsASampleOfCJKString.\u7947\u5712\u7cbe\u820d\u306e\u9418\u306e\u58f0\u3001\u8af8\u884c\u7121\u5e38\u306e\u97ff\u304d\u3042\u308a\u3002\u5a11\u7f85\u53cc\u6a39\u306e\u82b1\u306e\u8272\u3001\u76db\u8005\u5fc5\u8870\u306e\u7406\u3092\u3042\u3089\u306f\u3059\u3002\u5962\u308c\u308b\u4eba\u3082\u4e45\u3057\u304b\u3089\u305a\u3001\u305f\u3060\u6625\u306e\u591c\u306e\u5922\u306e\u3054\u3068\u3057\u3002\u731b\u304d\u8005\u3082\u3064\u3072\u306b\u306f\u307b\u308d\u3073\u306c\u3001\u3072\u3068\u3078\u306b\u98a8\u306e\u524d\u306e\u5875\u306b\u540c\u3058\u3002\");\n }"}, {"sha": "565fee632f57b6c705bb94b111e88207daa693d7", "filename": "tests/target/comment6.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Ftarget%2Fcomment6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Ftarget%2Fcomment6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcomment6.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -0,0 +1,14 @@\n+// rustfmt-wrap_comments: true\n+\n+// Pendant la nuit du 9 mars 1860, les nuages, se confondant avec la mer,\n+// limitaient \u00e0 quelques brasses la port\u00e9e de la vue. Sur cette mer d\u00e9mont\u00e9e,\n+// dont les lames d\u00e9ferlaient en projetant des lueurs livides, un l\u00e9ger b\u00e2timent\n+// fuyait presque \u00e0 sec de toile.\n+\n+pub mod foo {}\n+\n+// \u3086\u304f\u6cb3\u306e\u6d41\u308c\u306f\u7d76\u3048\u305a\u3057\u3066\u3001\u3057\u304b\u3082\u3082\u3068\u306e\u6c34\u306b\u3042\u3089\u305a\u3002\u6dc0\u307f\u306b\u6d6e\u304b\u3076\u3046\u305f\u304b\u305f\u306f\u3001\n+// \u304b\u3064\u6d88\u3048\u304b\u3064\u7d50\u3073\u3066\u3001\u4e45\u3057\u304f\u3068\u3069\u307e\u308a\u305f\u308b\u305f\u3081\u3057\u306a\u3057\u3002\u4e16\u306e\u4e2d\u306b\u3042\u308b\u4eba\u3068\u3059\u307f\u304b\u3068\u3001\n+// \u307e\u305f\u304b\u304f\u306e\u3054\u3068\u3057\u3002\n+\n+pub mod bar {}"}, {"sha": "0b8ec1b7f39350dcdabaf833a1652a56480de61a", "filename": "tests/target/string_punctuation.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Ftarget%2Fstring_punctuation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a01990c4d0f6415a1e4824cf109125effacaaa81/tests%2Ftarget%2Fstring_punctuation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring_punctuation.rs?ref=a01990c4d0f6415a1e4824cf109125effacaaa81", "patch": "@@ -11,4 +11,14 @@ fn main() {\n          adopgihadoguaadbadgad,qeoihapethae8t0aet8haetadbjtaeg;\\\n          ooeouthaoeutgadlgajduabgoiuadogabudogubaodugbadgadgadga;adoughaoeugbaouea\"\n     );\n+    println!(\n+        \"sentuhaesnuthaesnutheasunteahusnaethuseantuihaesntdiastnidaetnuhaideuhsenathe\u3002\\\n+         WeShouldSupportNonAsciiPunctuations\u00a7\\\n+         ensuhatheasunteahsuneathusneathuasnuhaesnuhaesnuaethusnaetuheasnuth\"\n+    );\n+    println!(\n+        \"ThisIsASampleOfCJKString.\u7947\u5712\u7cbe\u820d\u306e\u9418\u306e\u58f0\u3001\u8af8\u884c\u7121\u5e38\u306e\u97ff\u304d\u3042\u308a\u3002\u5a11\u7f85\u53cc\u6a39\u306e\u82b1\u306e\u8272\u3001\\\n+         \u76db\u8005\u5fc5\u8870\u306e\u7406\u3092\u3042\u3089\u306f\u3059\u3002\u5962\u308c\u308b\u4eba\u3082\u4e45\u3057\u304b\u3089\u305a\u3001\u305f\u3060\u6625\u306e\u591c\u306e\u5922\u306e\u3054\u3068\u3057\u3002\\\n+         \u731b\u304d\u8005\u3082\u3064\u3072\u306b\u306f\u307b\u308d\u3073\u306c\u3001\u3072\u3068\u3078\u306b\u98a8\u306e\u524d\u306e\u5875\u306b\u540c\u3058\u3002\"\n+    );\n }"}]}