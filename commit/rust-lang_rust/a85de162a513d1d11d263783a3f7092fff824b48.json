{"sha": "a85de162a513d1d11d263783a3f7092fff824b48", "node_id": "C_kwDOAAsO6NoAKGE4NWRlMTYyYTUxM2QxZDExZDI2Mzc4M2EzZjcwOTJmZmY4MjRiNDg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-11T11:06:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-11T11:06:49Z"}, "message": "Auto merge of #96924 - petrochenkov:nonon, r=nnethercote\n\nast: Introduce some traits to get AST node properties generically\n\nAnd use them to avoid constructing some artificial `Nonterminal` tokens during expansion\nr? `@nnethercote` `@Aaron1011`", "tree": {"sha": "3e76dd8041b17d20a69c9988b71eae34dd4e5e36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e76dd8041b17d20a69c9988b71eae34dd4e5e36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a85de162a513d1d11d263783a3f7092fff824b48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a85de162a513d1d11d263783a3f7092fff824b48", "html_url": "https://github.com/rust-lang/rust/commit/a85de162a513d1d11d263783a3f7092fff824b48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a85de162a513d1d11d263783a3f7092fff824b48/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f296b9a32a33bbbee495927cf13bee07e7658b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/f296b9a32a33bbbee495927cf13bee07e7658b89", "html_url": "https://github.com/rust-lang/rust/commit/f296b9a32a33bbbee495927cf13bee07e7658b89"}, {"sha": "f2b7fa484739d3f7d1303c7d42138040caaf435e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2b7fa484739d3f7d1303c7d42138040caaf435e", "html_url": "https://github.com/rust-lang/rust/commit/f2b7fa484739d3f7d1303c7d42138040caaf435e"}], "stats": {"total": 1093, "additions": 593, "deletions": 500}, "files": [{"sha": "5a4c997ed9bfc606ea775c2c1644e74c22b0585c", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -929,16 +929,6 @@ pub struct Stmt {\n }\n \n impl Stmt {\n-    pub fn tokens(&self) -> Option<&LazyTokenStream> {\n-        match self.kind {\n-            StmtKind::Local(ref local) => local.tokens.as_ref(),\n-            StmtKind::Item(ref item) => item.tokens.as_ref(),\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.tokens.as_ref(),\n-            StmtKind::Empty => None,\n-            StmtKind::MacCall(ref mac) => mac.tokens.as_ref(),\n-        }\n-    }\n-\n     pub fn has_trailing_semicolon(&self) -> bool {\n         match &self.kind {\n             StmtKind::Semi(_) => true,\n@@ -2684,13 +2674,6 @@ impl Item {\n     }\n }\n \n-impl<K: Into<ItemKind>> Item<K> {\n-    pub fn into_item(self) -> Item {\n-        let Item { attrs, id, span, vis, ident, kind, tokens } = self;\n-        Item { attrs, id, span, vis, ident, kind: kind.into(), tokens }\n-    }\n-}\n-\n /// `extern` qualifier on a function item or function type.\n #[derive(Clone, Copy, Encodable, Decodable, Debug)]\n pub enum Extern {"}, {"sha": "1a271b0adef921d09e340800f8d6a9e21bc7fb26", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "removed", "additions": 0, "deletions": 320, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/f296b9a32a33bbbee495927cf13bee07e7658b89/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f296b9a32a33bbbee495927cf13bee07e7658b89/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=f296b9a32a33bbbee495927cf13bee07e7658b89", "patch": "@@ -1,320 +0,0 @@\n-use super::ptr::P;\n-use super::token::Nonterminal;\n-use super::tokenstream::LazyTokenStream;\n-use super::{Arm, Crate, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n-use super::{AssocItem, Expr, ForeignItem, Item, Local, MacCallStmt};\n-use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n-use super::{AttrVec, Attribute, Stmt, StmtKind};\n-\n-use std::fmt;\n-use std::marker::PhantomData;\n-\n-/// An `AstLike` represents an AST node (or some wrapper around\n-/// and AST node) which stores some combination of attributes\n-/// and tokens.\n-pub trait AstLike: Sized + fmt::Debug {\n-    /// This is `true` if this `AstLike` might support 'custom' (proc-macro) inner\n-    /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n-    /// considered 'custom' attributes\n-    ///\n-    /// If this is `false`, then this `AstLike` definitely does\n-    /// not support 'custom' inner attributes, which enables some optimizations\n-    /// during token collection.\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n-    fn attrs(&self) -> &[Attribute];\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n-}\n-\n-impl<T: AstLike + 'static> AstLike for P<T> {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n-    fn attrs(&self) -> &[Attribute] {\n-        (**self).attrs()\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        (**self).visit_attrs(f);\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        (**self).tokens_mut()\n-    }\n-}\n-\n-impl AstLike for crate::token::Nonterminal {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n-    fn attrs(&self) -> &[Attribute] {\n-        match self {\n-            Nonterminal::NtItem(item) => item.attrs(),\n-            Nonterminal::NtStmt(stmt) => stmt.attrs(),\n-            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.attrs(),\n-            Nonterminal::NtPat(_)\n-            | Nonterminal::NtTy(_)\n-            | Nonterminal::NtMeta(_)\n-            | Nonterminal::NtPath(_)\n-            | Nonterminal::NtVis(_)\n-            | Nonterminal::NtBlock(_)\n-            | Nonterminal::NtIdent(..)\n-            | Nonterminal::NtLifetime(_) => &[],\n-        }\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        match self {\n-            Nonterminal::NtItem(item) => item.visit_attrs(f),\n-            Nonterminal::NtStmt(stmt) => stmt.visit_attrs(f),\n-            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.visit_attrs(f),\n-            Nonterminal::NtPat(_)\n-            | Nonterminal::NtTy(_)\n-            | Nonterminal::NtMeta(_)\n-            | Nonterminal::NtPath(_)\n-            | Nonterminal::NtVis(_)\n-            | Nonterminal::NtBlock(_)\n-            | Nonterminal::NtIdent(..)\n-            | Nonterminal::NtLifetime(_) => {}\n-        }\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        match self {\n-            Nonterminal::NtItem(item) => item.tokens_mut(),\n-            Nonterminal::NtStmt(stmt) => stmt.tokens_mut(),\n-            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.tokens_mut(),\n-            Nonterminal::NtPat(pat) => pat.tokens_mut(),\n-            Nonterminal::NtTy(ty) => ty.tokens_mut(),\n-            Nonterminal::NtMeta(attr_item) => attr_item.tokens_mut(),\n-            Nonterminal::NtPath(path) => path.tokens_mut(),\n-            Nonterminal::NtVis(vis) => vis.tokens_mut(),\n-            Nonterminal::NtBlock(block) => block.tokens_mut(),\n-            Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) => None,\n-        }\n-    }\n-}\n-\n-fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n-    crate::mut_visit::visit_clobber(attrs, |attrs| {\n-        let mut vec = attrs.into();\n-        f(&mut vec);\n-        vec.into()\n-    });\n-}\n-\n-impl AstLike for StmtKind {\n-    // This might be an `StmtKind::Item`, which contains\n-    // an item that supports inner attrs\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n-\n-    fn attrs(&self) -> &[Attribute] {\n-        match self {\n-            StmtKind::Local(local) => local.attrs(),\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.attrs(),\n-            StmtKind::Item(item) => item.attrs(),\n-            StmtKind::Empty => &[],\n-            StmtKind::MacCall(mac) => &mac.attrs,\n-        }\n-    }\n-\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        match self {\n-            StmtKind::Local(local) => local.visit_attrs(f),\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n-            StmtKind::Item(item) => item.visit_attrs(f),\n-            StmtKind::Empty => {}\n-            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n-        }\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        Some(match self {\n-            StmtKind::Local(local) => &mut local.tokens,\n-            StmtKind::Item(item) => &mut item.tokens,\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => &mut expr.tokens,\n-            StmtKind::Empty => return None,\n-            StmtKind::MacCall(mac) => &mut mac.tokens,\n-        })\n-    }\n-}\n-\n-impl AstLike for Stmt {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = StmtKind::SUPPORTS_CUSTOM_INNER_ATTRS;\n-\n-    fn attrs(&self) -> &[Attribute] {\n-        self.kind.attrs()\n-    }\n-\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        self.kind.visit_attrs(f);\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        self.kind.tokens_mut()\n-    }\n-}\n-\n-impl AstLike for Attribute {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n-\n-    fn attrs(&self) -> &[Attribute] {\n-        &[]\n-    }\n-    fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        Some(match &mut self.kind {\n-            AttrKind::Normal(_, tokens) => tokens,\n-            kind @ AttrKind::DocComment(..) => {\n-                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n-            }\n-        })\n-    }\n-}\n-\n-impl<T: AstLike> AstLike for Option<T> {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n-\n-    fn attrs(&self) -> &[Attribute] {\n-        self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        if let Some(inner) = self.as_mut() {\n-            inner.visit_attrs(f);\n-        }\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        self.as_mut().and_then(|inner| inner.tokens_mut())\n-    }\n-}\n-\n-/// Helper trait for the macros below. Abstracts over\n-/// the two types of attribute fields that AST nodes\n-/// may have (`Vec<Attribute>` or `AttrVec`)\n-trait VecOrAttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-}\n-\n-impl VecOrAttrVec for Vec<Attribute> {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        f(self)\n-    }\n-}\n-\n-impl VecOrAttrVec for AttrVec {\n-    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        visit_attrvec(self, f)\n-    }\n-}\n-\n-macro_rules! derive_has_tokens_and_attrs {\n-    (\n-        const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner_attrs:literal;\n-        $($ty:path),*\n-    ) => { $(\n-        impl AstLike for $ty {\n-            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner_attrs;\n-\n-            fn attrs(&self) -> &[Attribute] {\n-                &self.attrs\n-            }\n-\n-            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                VecOrAttrVec::visit(&mut self.attrs, f)\n-            }\n-\n-            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-                Some(&mut self.tokens)\n-            }\n-\n-        }\n-    )* }\n-}\n-\n-macro_rules! derive_has_attrs_no_tokens {\n-    ($($ty:path),*) => { $(\n-        impl AstLike for $ty {\n-            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n-\n-            fn attrs(&self) -> &[Attribute] {\n-                &self.attrs\n-            }\n-\n-            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                VecOrAttrVec::visit(&mut self.attrs, f)\n-            }\n-\n-            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-                None\n-            }\n-        }\n-    )* }\n-}\n-\n-macro_rules! derive_has_tokens_no_attrs {\n-    ($($ty:path),*) => { $(\n-        impl AstLike for $ty {\n-            const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n-\n-            fn attrs(&self) -> &[Attribute] {\n-                &[]\n-            }\n-\n-            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n-            fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-                Some(&mut self.tokens)\n-            }\n-        }\n-    )* }\n-}\n-\n-// These ast nodes support both active and inert attributes,\n-// so they have tokens collected to pass to proc macros\n-derive_has_tokens_and_attrs! {\n-    // Both `Item` and `AssocItem` can have bodies, which\n-    // can contain inner attributes\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n-    Item, AssocItem, ForeignItem\n-}\n-\n-derive_has_tokens_and_attrs! {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n-    Local, MacCallStmt, Expr\n-}\n-\n-// These ast nodes only support inert attributes, so they don't\n-// store tokens (since nothing can observe them)\n-derive_has_attrs_no_tokens! {\n-    FieldDef, Arm, ExprField, PatField, Variant, Param, GenericParam, Crate\n-}\n-\n-// These AST nodes don't support attributes, but can\n-// be captured by a `macro_rules!` matcher. Therefore,\n-// they need to store tokens.\n-derive_has_tokens_no_attrs! {\n-    Ty, Block, AttrItem, Pat, Path, Visibility\n-}\n-\n-/// A newtype around an `AstLike` node that implements `AstLike` itself.\n-pub struct AstLikeWrapper<Wrapped, Tag> {\n-    pub wrapped: Wrapped,\n-    pub tag: PhantomData<Tag>,\n-}\n-\n-impl<Wrapped, Tag> AstLikeWrapper<Wrapped, Tag> {\n-    pub fn new(wrapped: Wrapped, _tag: Tag) -> AstLikeWrapper<Wrapped, Tag> {\n-        AstLikeWrapper { wrapped, tag: Default::default() }\n-    }\n-}\n-\n-impl<Wrapped: fmt::Debug, Tag> fmt::Debug for AstLikeWrapper<Wrapped, Tag> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"AstLikeWrapper\")\n-            .field(\"wrapped\", &self.wrapped)\n-            .field(\"tag\", &self.tag)\n-            .finish()\n-    }\n-}\n-\n-impl<Wrapped: AstLike, Tag> AstLike for AstLikeWrapper<Wrapped, Tag> {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = Wrapped::SUPPORTS_CUSTOM_INNER_ATTRS;\n-    fn attrs(&self) -> &[Attribute] {\n-        self.wrapped.attrs()\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        self.wrapped.visit_attrs(f)\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n-        self.wrapped.tokens_mut()\n-    }\n-}"}, {"sha": "bd401ddbbee9f508ef82a29f15fad930c6894875", "filename": "compiler/rustc_ast/src/ast_traits.rs", "status": "added", "additions": 436, "deletions": 0, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_traits.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -0,0 +1,436 @@\n+//! A set of traits implemented for various AST nodes,\n+//! typically those used in AST fragments during macro expansion.\n+//! The traits are not implemented exhaustively, only when actually necessary.\n+\n+use crate::ptr::P;\n+use crate::token::Nonterminal;\n+use crate::tokenstream::LazyTokenStream;\n+use crate::{Arm, Crate, ExprField, FieldDef, GenericParam, Param, PatField, Variant};\n+use crate::{AssocItem, Expr, ForeignItem, Item, NodeId};\n+use crate::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n+use crate::{AttrVec, Attribute, Stmt, StmtKind};\n+\n+use rustc_span::Span;\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+\n+/// A utility trait to reduce boilerplate.\n+/// Standard `Deref(Mut)` cannot be reused due to coherence.\n+pub trait AstDeref {\n+    type Target;\n+    fn ast_deref(&self) -> &Self::Target;\n+    fn ast_deref_mut(&mut self) -> &mut Self::Target;\n+}\n+\n+macro_rules! impl_not_ast_deref {\n+    ($($T:ty),+ $(,)?) => {\n+        $(\n+            impl !AstDeref for $T {}\n+        )+\n+    };\n+}\n+\n+impl_not_ast_deref!(AssocItem, Expr, ForeignItem, Item, Stmt);\n+\n+impl<T> AstDeref for P<T> {\n+    type Target = T;\n+    fn ast_deref(&self) -> &Self::Target {\n+        self\n+    }\n+    fn ast_deref_mut(&mut self) -> &mut Self::Target {\n+        self\n+    }\n+}\n+\n+/// A trait for AST nodes having an ID.\n+pub trait HasNodeId {\n+    fn node_id(&self) -> NodeId;\n+    fn node_id_mut(&mut self) -> &mut NodeId;\n+}\n+\n+macro_rules! impl_has_node_id {\n+    ($($T:ty),+ $(,)?) => {\n+        $(\n+            impl HasNodeId for $T {\n+                fn node_id(&self) -> NodeId {\n+                    self.id\n+                }\n+                fn node_id_mut(&mut self) -> &mut NodeId {\n+                    &mut self.id\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_has_node_id!(\n+    Arm,\n+    AssocItem,\n+    Crate,\n+    Expr,\n+    ExprField,\n+    FieldDef,\n+    ForeignItem,\n+    GenericParam,\n+    Item,\n+    Param,\n+    Pat,\n+    PatField,\n+    Stmt,\n+    Ty,\n+    Variant,\n+);\n+\n+impl<T: AstDeref<Target: HasNodeId>> HasNodeId for T {\n+    fn node_id(&self) -> NodeId {\n+        self.ast_deref().node_id()\n+    }\n+    fn node_id_mut(&mut self) -> &mut NodeId {\n+        self.ast_deref_mut().node_id_mut()\n+    }\n+}\n+\n+/// A trait for AST nodes having a span.\n+pub trait HasSpan {\n+    fn span(&self) -> Span;\n+}\n+\n+macro_rules! impl_has_span {\n+    ($($T:ty),+ $(,)?) => {\n+        $(\n+            impl HasSpan for $T {\n+                fn span(&self) -> Span {\n+                    self.span\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_has_span!(AssocItem, Expr, ForeignItem, Item, Stmt);\n+\n+impl<T: AstDeref<Target: HasSpan>> HasSpan for T {\n+    fn span(&self) -> Span {\n+        self.ast_deref().span()\n+    }\n+}\n+\n+/// A trait for AST nodes having (or not having) collected tokens.\n+pub trait HasTokens {\n+    fn tokens(&self) -> Option<&LazyTokenStream>;\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>>;\n+}\n+\n+macro_rules! impl_has_tokens {\n+    ($($T:ty),+ $(,)?) => {\n+        $(\n+            impl HasTokens for $T {\n+                fn tokens(&self) -> Option<&LazyTokenStream> {\n+                    self.tokens.as_ref()\n+                }\n+                fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                    Some(&mut self.tokens)\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+macro_rules! impl_has_tokens_none {\n+    ($($T:ty),+ $(,)?) => {\n+        $(\n+            impl HasTokens for $T {\n+                fn tokens(&self) -> Option<&LazyTokenStream> {\n+                    None\n+                }\n+                fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+                    None\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_has_tokens!(AssocItem, AttrItem, Block, Expr, ForeignItem, Item, Pat, Path, Ty, Visibility);\n+impl_has_tokens_none!(Arm, ExprField, FieldDef, GenericParam, Param, PatField, Variant);\n+\n+impl<T: AstDeref<Target: HasTokens>> HasTokens for T {\n+    fn tokens(&self) -> Option<&LazyTokenStream> {\n+        self.ast_deref().tokens()\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.ast_deref_mut().tokens_mut()\n+    }\n+}\n+\n+impl<T: HasTokens> HasTokens for Option<T> {\n+    fn tokens(&self) -> Option<&LazyTokenStream> {\n+        self.as_ref().and_then(|inner| inner.tokens())\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.as_mut().and_then(|inner| inner.tokens_mut())\n+    }\n+}\n+\n+impl HasTokens for StmtKind {\n+    fn tokens(&self) -> Option<&LazyTokenStream> {\n+        match self {\n+            StmtKind::Local(local) => local.tokens.as_ref(),\n+            StmtKind::Item(item) => item.tokens(),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.tokens(),\n+            StmtKind::Empty => return None,\n+            StmtKind::MacCall(mac) => mac.tokens.as_ref(),\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            StmtKind::Local(local) => Some(&mut local.tokens),\n+            StmtKind::Item(item) => item.tokens_mut(),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.tokens_mut(),\n+            StmtKind::Empty => return None,\n+            StmtKind::MacCall(mac) => Some(&mut mac.tokens),\n+        }\n+    }\n+}\n+\n+impl HasTokens for Stmt {\n+    fn tokens(&self) -> Option<&LazyTokenStream> {\n+        self.kind.tokens()\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        self.kind.tokens_mut()\n+    }\n+}\n+\n+impl HasTokens for Attribute {\n+    fn tokens(&self) -> Option<&LazyTokenStream> {\n+        match &self.kind {\n+            AttrKind::Normal(_, tokens) => tokens.as_ref(),\n+            kind @ AttrKind::DocComment(..) => {\n+                panic!(\"Called tokens on doc comment attr {:?}\", kind)\n+            }\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        Some(match &mut self.kind {\n+            AttrKind::Normal(_, tokens) => tokens,\n+            kind @ AttrKind::DocComment(..) => {\n+                panic!(\"Called tokens_mut on doc comment attr {:?}\", kind)\n+            }\n+        })\n+    }\n+}\n+\n+impl HasTokens for Nonterminal {\n+    fn tokens(&self) -> Option<&LazyTokenStream> {\n+        match self {\n+            Nonterminal::NtItem(item) => item.tokens(),\n+            Nonterminal::NtStmt(stmt) => stmt.tokens(),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.tokens(),\n+            Nonterminal::NtPat(pat) => pat.tokens(),\n+            Nonterminal::NtTy(ty) => ty.tokens(),\n+            Nonterminal::NtMeta(attr_item) => attr_item.tokens(),\n+            Nonterminal::NtPath(path) => path.tokens(),\n+            Nonterminal::NtVis(vis) => vis.tokens(),\n+            Nonterminal::NtBlock(block) => block.tokens(),\n+            Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) => None,\n+        }\n+    }\n+    fn tokens_mut(&mut self) -> Option<&mut Option<LazyTokenStream>> {\n+        match self {\n+            Nonterminal::NtItem(item) => item.tokens_mut(),\n+            Nonterminal::NtStmt(stmt) => stmt.tokens_mut(),\n+            Nonterminal::NtExpr(expr) | Nonterminal::NtLiteral(expr) => expr.tokens_mut(),\n+            Nonterminal::NtPat(pat) => pat.tokens_mut(),\n+            Nonterminal::NtTy(ty) => ty.tokens_mut(),\n+            Nonterminal::NtMeta(attr_item) => attr_item.tokens_mut(),\n+            Nonterminal::NtPath(path) => path.tokens_mut(),\n+            Nonterminal::NtVis(vis) => vis.tokens_mut(),\n+            Nonterminal::NtBlock(block) => block.tokens_mut(),\n+            Nonterminal::NtIdent(..) | Nonterminal::NtLifetime(..) => None,\n+        }\n+    }\n+}\n+\n+/// A trait for AST nodes having (or not having) attributes.\n+pub trait HasAttrs {\n+    /// This is `true` if this `HasAttrs` might support 'custom' (proc-macro) inner\n+    /// attributes. Attributes like `#![cfg]` and `#![cfg_attr]` are not\n+    /// considered 'custom' attributes.\n+    ///\n+    /// If this is `false`, then this `HasAttrs` definitely does\n+    /// not support 'custom' inner attributes, which enables some optimizations\n+    /// during token collection.\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool;\n+    fn attrs(&self) -> &[Attribute];\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+}\n+\n+macro_rules! impl_has_attrs {\n+    (const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner:literal, $($T:ty),+ $(,)?) => {\n+        $(\n+            impl HasAttrs for $T {\n+                const SUPPORTS_CUSTOM_INNER_ATTRS: bool = $inner;\n+\n+                fn attrs(&self) -> &[Attribute] {\n+                    &self.attrs\n+                }\n+\n+                fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+                    VecOrAttrVec::visit(&mut self.attrs, f)\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+macro_rules! impl_has_attrs_none {\n+    ($($T:ty),+ $(,)?) => {\n+        $(\n+            impl HasAttrs for $T {\n+                const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false;\n+                fn attrs(&self) -> &[Attribute] {\n+                    &[]\n+                }\n+                fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+            }\n+        )+\n+    };\n+}\n+\n+impl_has_attrs!(\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true,\n+    AssocItem,\n+    ForeignItem,\n+    Item,\n+);\n+impl_has_attrs!(\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = false,\n+    Arm,\n+    Crate,\n+    Expr,\n+    ExprField,\n+    FieldDef,\n+    GenericParam,\n+    Param,\n+    PatField,\n+    Variant,\n+);\n+impl_has_attrs_none!(Attribute, AttrItem, Block, Pat, Path, Ty, Visibility);\n+\n+impl<T: AstDeref<Target: HasAttrs>> HasAttrs for T {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::Target::SUPPORTS_CUSTOM_INNER_ATTRS;\n+    fn attrs(&self) -> &[Attribute] {\n+        self.ast_deref().attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.ast_deref_mut().visit_attrs(f)\n+    }\n+}\n+\n+impl<T: HasAttrs> HasAttrs for Option<T> {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = T::SUPPORTS_CUSTOM_INNER_ATTRS;\n+    fn attrs(&self) -> &[Attribute] {\n+        self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        if let Some(inner) = self.as_mut() {\n+            inner.visit_attrs(f);\n+        }\n+    }\n+}\n+\n+impl HasAttrs for StmtKind {\n+    // This might be a `StmtKind::Item`, which contains\n+    // an item that supports inner attrs.\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n+\n+    fn attrs(&self) -> &[Attribute] {\n+        match self {\n+            StmtKind::Local(local) => &local.attrs,\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.attrs(),\n+            StmtKind::Item(item) => item.attrs(),\n+            StmtKind::Empty => &[],\n+            StmtKind::MacCall(mac) => &mac.attrs,\n+        }\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        match self {\n+            StmtKind::Local(local) => visit_attrvec(&mut local.attrs, f),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n+            StmtKind::Item(item) => item.visit_attrs(f),\n+            StmtKind::Empty => {}\n+            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n+        }\n+    }\n+}\n+\n+impl HasAttrs for Stmt {\n+    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = StmtKind::SUPPORTS_CUSTOM_INNER_ATTRS;\n+    fn attrs(&self) -> &[Attribute] {\n+        self.kind.attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.kind.visit_attrs(f);\n+    }\n+}\n+\n+/// Helper trait for the impls above. Abstracts over\n+/// the two types of attribute fields that AST nodes\n+/// may have (`Vec<Attribute>` or `AttrVec`).\n+trait VecOrAttrVec {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+}\n+\n+impl VecOrAttrVec for Vec<Attribute> {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        f(self)\n+    }\n+}\n+\n+impl VecOrAttrVec for AttrVec {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        visit_attrvec(self, f)\n+    }\n+}\n+\n+fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    crate::mut_visit::visit_clobber(attrs, |attrs| {\n+        let mut vec = attrs.into();\n+        f(&mut vec);\n+        vec.into()\n+    });\n+}\n+\n+/// A newtype around an AST node that implements the traits above if the node implements them.\n+pub struct AstNodeWrapper<Wrapped, Tag> {\n+    pub wrapped: Wrapped,\n+    pub tag: PhantomData<Tag>,\n+}\n+\n+impl<Wrapped, Tag> AstNodeWrapper<Wrapped, Tag> {\n+    pub fn new(wrapped: Wrapped, _tag: Tag) -> AstNodeWrapper<Wrapped, Tag> {\n+        AstNodeWrapper { wrapped, tag: Default::default() }\n+    }\n+}\n+\n+impl<Wrapped, Tag> AstDeref for AstNodeWrapper<Wrapped, Tag> {\n+    type Target = Wrapped;\n+    fn ast_deref(&self) -> &Self::Target {\n+        &self.wrapped\n+    }\n+    fn ast_deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.wrapped\n+    }\n+}\n+\n+impl<Wrapped: fmt::Debug, Tag> fmt::Debug for AstNodeWrapper<Wrapped, Tag> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"AstNodeWrapper\")\n+            .field(\"wrapped\", &self.wrapped)\n+            .field(\"tag\", &self.tag)\n+            .finish()\n+    }\n+}"}, {"sha": "124671691922aceb09709e81dbfc460d7542d81c", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -8,6 +8,7 @@\n     html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\",\n     test(attr(deny(warnings)))\n )]\n+#![feature(associated_type_bounds)]\n #![feature(box_patterns)]\n #![feature(const_default_impls)]\n #![feature(const_trait_impl)]\n@@ -16,6 +17,7 @@\n #![feature(label_break_value)]\n #![feature(let_chains)]\n #![feature(min_specialization)]\n+#![feature(negative_impls)]\n #![feature(nll)]\n #![feature(slice_internals)]\n #![feature(stmt_expr_attributes)]\n@@ -33,7 +35,7 @@ pub mod util {\n }\n \n pub mod ast;\n-pub mod ast_like;\n+pub mod ast_traits;\n pub mod attr;\n pub mod entry;\n pub mod expand;\n@@ -45,7 +47,7 @@ pub mod tokenstream;\n pub mod visit;\n \n pub use self::ast::*;\n-pub use self::ast_like::{AstLike, AstLikeWrapper};\n+pub use self::ast_traits::{AstDeref, AstNodeWrapper, HasAttrs, HasNodeId, HasSpan, HasTokens};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "95beccbb728b7eef9317e2fdff29718a26f24bd8", "filename": "compiler/rustc_ast_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Flib.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -1,5 +1,7 @@\n+#![feature(associated_type_bounds)]\n #![feature(crate_visibility_modifier)]\n #![feature(box_patterns)]\n+#![feature(with_negative_coherence)]\n #![recursion_limit = \"256\"]\n \n mod helpers;"}, {"sha": "d2e2fd520cd41c0e1516b14e9f80cad307b5a86d", "filename": "compiler/rustc_ast_pretty/src/pprust/mod.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fmod.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -4,12 +4,42 @@ mod tests;\n pub mod state;\n pub use state::{print_crate, AnnNode, Comments, PpAnn, PrintState, State};\n \n-use rustc_ast as ast;\n use rustc_ast::token::{Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::{self as ast, AstDeref};\n \n use std::borrow::Cow;\n \n+pub trait AstPrettyPrint {\n+    fn pretty_print(&self) -> String;\n+}\n+\n+impl<T: AstDeref<Target: AstPrettyPrint>> AstPrettyPrint for T {\n+    fn pretty_print(&self) -> String {\n+        self.ast_deref().pretty_print()\n+    }\n+}\n+\n+macro_rules! impl_ast_pretty_print {\n+    ($($T:ty => $method:ident),+ $(,)?) => {\n+        $(\n+            impl AstPrettyPrint for $T {\n+                fn pretty_print(&self) -> String {\n+                    State::new().$method(self)\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_ast_pretty_print! {\n+    ast::Item => item_to_string,\n+    ast::AssocItem => assoc_item_to_string,\n+    ast::ForeignItem => foreign_item_to_string,\n+    ast::Expr => expr_to_string,\n+    ast::Stmt => stmt_to_string,\n+}\n+\n pub fn nonterminal_to_string(nt: &Nonterminal) -> String {\n     State::new().nonterminal_to_string(nt)\n }"}, {"sha": "f520b54112464c424cfcde36dc89af87bf76ee37", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -858,6 +858,14 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         Self::to_string(|s| s.print_item(i))\n     }\n \n+    fn assoc_item_to_string(&self, i: &ast::AssocItem) -> String {\n+        Self::to_string(|s| s.print_assoc_item(i))\n+    }\n+\n+    fn foreign_item_to_string(&self, i: &ast::ForeignItem) -> String {\n+        Self::to_string(|s| s.print_foreign_item(i))\n+    }\n+\n     fn generic_params_to_string(&self, generic_params: &[ast::GenericParam]) -> String {\n         Self::to_string(|s| s.print_generic_params(generic_params))\n     }"}, {"sha": "23c5a92e352b135d99930fbe14e4cff5ba3ad4f5", "filename": "compiler/rustc_ast_pretty/src/pprust/state/item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fitem.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -19,7 +19,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n+    crate fn print_foreign_item(&mut self, item: &ast::ForeignItem) {\n         let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n         self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();\n@@ -496,7 +496,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n+    crate fn print_assoc_item(&mut self, item: &ast::AssocItem) {\n         let ast::Item { id, span, ident, ref attrs, ref kind, ref vis, tokens: _ } = *item;\n         self.ann.pre(self, AnnNode::SubItem(id));\n         self.hardbreak_if_not_bol();"}, {"sha": "4278fedfee9927cd282cb1b2245490e220ac7ce8", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::tokenstream::CanSynthesizeMissingTokens;\n use rustc_ast::visit::Visitor;\n use rustc_ast::NodeId;\n use rustc_ast::{mut_visit, visit};\n-use rustc_ast::{AstLike, Attribute};\n+use rustc_ast::{Attribute, HasAttrs, HasTokens};\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_expand::config::StripUnconfigured;\n use rustc_expand::configure;\n@@ -125,7 +125,7 @@ impl<'ast> visit::Visitor<'ast> for CfgFinder {\n }\n \n impl CfgEval<'_, '_> {\n-    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n+    fn configure<T: HasAttrs + HasTokens>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n \n@@ -173,13 +173,8 @@ impl CfgEval<'_, '_> {\n             }\n             _ => unreachable!(),\n         };\n-        let nt = annotatable.into_nonterminal();\n \n-        let mut orig_tokens = rustc_parse::nt_to_tokenstream(\n-            &nt,\n-            &self.cfg.sess.parse_sess,\n-            CanSynthesizeMissingTokens::No,\n-        );\n+        let mut orig_tokens = annotatable.to_tokens(&self.cfg.sess.parse_sess);\n \n         // 'Flatten' all nonterminals (i.e. `TokenKind::Interpolated`)\n         // to `None`-delimited groups containing the corresponding tokens. This"}, {"sha": "48b5502c20fa46a33b25df5813df24c0d9b5b7c9", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -6,14 +6,14 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, AstLike, Attribute, Item, NodeId, PatKind};\n+use rustc_ast::{self as ast, Attribute, HasAttrs, Item, NodeId, PatKind};\n use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_lint_defs::builtin::PROC_MACRO_BACK_COMPAT;\n use rustc_lint_defs::BuiltinLintDiagnostics;\n-use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n+use rustc_parse::{self, parser, to_token_stream, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit, Session};\n use rustc_span::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_span::edition::Edition;\n@@ -109,17 +109,20 @@ impl Annotatable {\n         }\n     }\n \n-    pub fn into_nonterminal(self) -> Nonterminal {\n+    pub fn to_tokens(&self, sess: &ParseSess) -> TokenStream {\n         match self {\n-            Annotatable::Item(item) => token::NtItem(item),\n-            Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n-                token::NtItem(P(item.and_then(ast::AssocItem::into_item)))\n+            Annotatable::Item(node) => to_token_stream(node, sess, CanSynthesizeMissingTokens::No),\n+            Annotatable::TraitItem(node) | Annotatable::ImplItem(node) => {\n+                to_token_stream(node, sess, CanSynthesizeMissingTokens::No)\n             }\n-            Annotatable::ForeignItem(item) => {\n-                token::NtItem(P(item.and_then(ast::ForeignItem::into_item)))\n+            Annotatable::ForeignItem(node) => {\n+                to_token_stream(node, sess, CanSynthesizeMissingTokens::No)\n             }\n-            Annotatable::Stmt(stmt) => token::NtStmt(stmt),\n-            Annotatable::Expr(expr) => token::NtExpr(expr),\n+            Annotatable::Stmt(node) => {\n+                assert!(!matches!(node.kind, ast::StmtKind::Empty));\n+                to_token_stream(node, sess, CanSynthesizeMissingTokens::No)\n+            }\n+            Annotatable::Expr(node) => to_token_stream(node, sess, CanSynthesizeMissingTokens::No),\n             Annotatable::Arm(..)\n             | Annotatable::ExprField(..)\n             | Annotatable::PatField(..)\n@@ -131,10 +134,6 @@ impl Annotatable {\n         }\n     }\n \n-    crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n-        nt_to_tokenstream(&self.into_nonterminal(), sess, CanSynthesizeMissingTokens::No)\n-    }\n-\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -1380,16 +1379,7 @@ pub fn parse_macro_name_and_helper_attrs(\n /// asserts in old versions of those crates and their wide use in the ecosystem.\n /// See issue #73345 for more details.\n /// FIXME(#73933): Remove this eventually.\n-pub(crate) fn pretty_printing_compatibility_hack(nt: &Nonterminal, sess: &ParseSess) -> bool {\n-    let item = match nt {\n-        Nonterminal::NtItem(item) => item,\n-        Nonterminal::NtStmt(stmt) => match &stmt.kind {\n-            ast::StmtKind::Item(item) => item,\n-            _ => return false,\n-        },\n-        _ => return false,\n-    };\n-\n+fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n     let name = item.ident.name;\n     if name == sym::ProceduralMasqueradeDummyType {\n         if let ast::ItemKind::Enum(enum_def, _) = &item.kind {\n@@ -1411,3 +1401,27 @@ pub(crate) fn pretty_printing_compatibility_hack(nt: &Nonterminal, sess: &ParseS\n     }\n     false\n }\n+\n+pub(crate) fn ann_pretty_printing_compatibility_hack(ann: &Annotatable, sess: &ParseSess) -> bool {\n+    let item = match ann {\n+        Annotatable::Item(item) => item,\n+        Annotatable::Stmt(stmt) => match &stmt.kind {\n+            ast::StmtKind::Item(item) => item,\n+            _ => return false,\n+        },\n+        _ => return false,\n+    };\n+    pretty_printing_compatibility_hack(item, sess)\n+}\n+\n+pub(crate) fn nt_pretty_printing_compatibility_hack(nt: &Nonterminal, sess: &ParseSess) -> bool {\n+    let item = match nt {\n+        Nonterminal::NtItem(item) => item,\n+        Nonterminal::NtStmt(stmt) => match &stmt.kind {\n+            ast::StmtKind::Item(item) => item,\n+            _ => return false,\n+        },\n+        _ => return false,\n+    };\n+    pretty_printing_compatibility_hack(item, sess)\n+}"}, {"sha": "0b8cb07a64afc26a3630189ed7553b482f3dd726", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -6,7 +6,7 @@ use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use rustc_ast::tokenstream::{DelimSpan, Spacing};\n use rustc_ast::tokenstream::{LazyTokenStream, TokenTree};\n use rustc_ast::NodeId;\n-use rustc_ast::{self as ast, AstLike, AttrStyle, Attribute, MetaItem};\n+use rustc_ast::{self as ast, AttrStyle, Attribute, HasAttrs, HasTokens, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -246,7 +246,7 @@ macro_rules! configure {\n }\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn configure<T: AstLike>(&self, mut node: T) -> Option<T> {\n+    pub fn configure<T: HasAttrs + HasTokens>(&self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) {\n             self.try_configure_tokens(&mut node);\n@@ -256,7 +256,7 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    fn try_configure_tokens<T: AstLike>(&self, node: &mut T) {\n+    fn try_configure_tokens<T: HasTokens>(&self, node: &mut T) {\n         if self.config_tokens {\n             if let Some(Some(tokens)) = node.tokens_mut() {\n                 let attr_annotated_tokens = tokens.create_token_stream();\n@@ -330,7 +330,7 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    fn process_cfg_attrs<T: AstLike>(&self, node: &mut T) {\n+    fn process_cfg_attrs<T: HasAttrs>(&self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });"}, {"sha": "a390e7a466ddec624365bf1495fb3c6a63b772dd", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 16, "deletions": 70, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -11,7 +11,8 @@ use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter};\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AssocItemKind, AstLike, AstLikeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{AssocItemKind, AstNodeWrapper, AttrStyle, ExprKind, ForeignItemKind};\n+use rustc_ast::{HasAttrs, HasNodeId};\n use rustc_ast::{Inline, ItemKind, MacArgs, MacStmtStyle, MetaItemKind, ModKind};\n use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n@@ -678,12 +679,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                     )\n                                 ) =>\n                         {\n-                            rustc_parse::fake_token_stream(\n-                                &self.cx.sess.parse_sess,\n-                                &item.into_nonterminal(),\n-                            )\n+                            rustc_parse::fake_token_stream(&self.cx.sess.parse_sess, item_inner)\n                         }\n-                        _ => item.into_tokens(&self.cx.sess.parse_sess),\n+                        _ => item.to_tokens(&self.cx.sess.parse_sess),\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n@@ -998,13 +996,12 @@ enum AddSemicolon {\n \n /// A trait implemented for all `AstFragment` nodes and providing all pieces\n /// of functionality used by `InvocationCollector`.\n-trait InvocationCollectorNode: AstLike {\n+trait InvocationCollectorNode: HasAttrs + HasNodeId + Sized {\n     type OutputTy = SmallVec<[Self; 1]>;\n     type AttrsTy: Deref<Target = [ast::Attribute]> = Vec<ast::Attribute>;\n     const KIND: AstFragmentKind;\n     fn to_annotatable(self) -> Annotatable;\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy;\n-    fn id(&mut self) -> &mut NodeId;\n     fn descr() -> &'static str {\n         unreachable!()\n     }\n@@ -1040,9 +1037,6 @@ impl InvocationCollectorNode for P<ast::Item> {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_items()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_item(self, visitor)\n     }\n@@ -1142,7 +1136,7 @@ impl InvocationCollectorNode for P<ast::Item> {\n }\n \n struct TraitItemTag;\n-impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag> {\n+impl InvocationCollectorNode for AstNodeWrapper<P<ast::AssocItem>, TraitItemTag> {\n     type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n     const KIND: AstFragmentKind = AstFragmentKind::TraitItems;\n     fn to_annotatable(self) -> Annotatable {\n@@ -1151,9 +1145,6 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag>\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_trait_items()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.wrapped.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_assoc_item(self.wrapped, visitor)\n     }\n@@ -1170,7 +1161,7 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, TraitItemTag>\n }\n \n struct ImplItemTag;\n-impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, ImplItemTag> {\n+impl InvocationCollectorNode for AstNodeWrapper<P<ast::AssocItem>, ImplItemTag> {\n     type OutputTy = SmallVec<[P<ast::AssocItem>; 1]>;\n     const KIND: AstFragmentKind = AstFragmentKind::ImplItems;\n     fn to_annotatable(self) -> Annotatable {\n@@ -1179,9 +1170,6 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::AssocItem>, ImplItemTag>\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_impl_items()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.wrapped.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_assoc_item(self.wrapped, visitor)\n     }\n@@ -1205,9 +1193,6 @@ impl InvocationCollectorNode for P<ast::ForeignItem> {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_foreign_items()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_foreign_item(self, visitor)\n     }\n@@ -1231,9 +1216,6 @@ impl InvocationCollectorNode for ast::Variant {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_variants()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_variant(self, visitor)\n     }\n@@ -1247,9 +1229,6 @@ impl InvocationCollectorNode for ast::FieldDef {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_field_defs()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_field_def(self, visitor)\n     }\n@@ -1263,9 +1242,6 @@ impl InvocationCollectorNode for ast::PatField {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_pat_fields()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_pat_field(self, visitor)\n     }\n@@ -1279,9 +1255,6 @@ impl InvocationCollectorNode for ast::ExprField {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_expr_fields()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_expr_field(self, visitor)\n     }\n@@ -1295,9 +1268,6 @@ impl InvocationCollectorNode for ast::Param {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_params()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_param(self, visitor)\n     }\n@@ -1311,9 +1281,6 @@ impl InvocationCollectorNode for ast::GenericParam {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_generic_params()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_generic_param(self, visitor)\n     }\n@@ -1327,9 +1294,6 @@ impl InvocationCollectorNode for ast::Arm {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_arms()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_arm(self, visitor)\n     }\n@@ -1344,9 +1308,6 @@ impl InvocationCollectorNode for ast::Stmt {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_stmts()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(self, visitor: &mut V) -> Self::OutputTy {\n         noop_flat_map_stmt(self, visitor)\n     }\n@@ -1403,9 +1364,6 @@ impl InvocationCollectorNode for ast::Crate {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_crate()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n         noop_visit_crate(self, visitor)\n     }\n@@ -1420,9 +1378,6 @@ impl InvocationCollectorNode for P<ast::Ty> {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_ty()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n         noop_visit_ty(self, visitor)\n     }\n@@ -1447,9 +1402,6 @@ impl InvocationCollectorNode for P<ast::Pat> {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_pat()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n         noop_visit_pat(self, visitor)\n     }\n@@ -1475,9 +1427,6 @@ impl InvocationCollectorNode for P<ast::Expr> {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_expr()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.id\n-    }\n     fn descr() -> &'static str {\n         \"an expression\"\n     }\n@@ -1497,7 +1446,7 @@ impl InvocationCollectorNode for P<ast::Expr> {\n }\n \n struct OptExprTag;\n-impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n+impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, OptExprTag> {\n     type OutputTy = Option<P<ast::Expr>>;\n     type AttrsTy = ast::AttrVec;\n     const KIND: AstFragmentKind = AstFragmentKind::OptExpr;\n@@ -1507,9 +1456,6 @@ impl InvocationCollectorNode for AstLikeWrapper<P<ast::Expr>, OptExprTag> {\n     fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n         fragment.make_opt_expr()\n     }\n-    fn id(&mut self) -> &mut NodeId {\n-        &mut self.wrapped.id\n-    }\n     fn noop_flat_map<V: MutVisitor>(mut self, visitor: &mut V) -> Self::OutputTy {\n         noop_visit_expr(&mut self.wrapped, visitor);\n         Some(self.wrapped)\n@@ -1584,7 +1530,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     /// legacy derive helpers (helpers written before derives that introduce them).\n     fn take_first_attr(\n         &self,\n-        item: &mut impl AstLike,\n+        item: &mut impl HasAttrs,\n     ) -> Option<(ast::Attribute, usize, Vec<ast::Path>)> {\n         let mut attr = None;\n \n@@ -1680,7 +1626,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n     fn expand_cfg_true(\n         &mut self,\n-        node: &mut impl AstLike,\n+        node: &mut impl HasAttrs,\n         attr: ast::Attribute,\n         pos: usize,\n     ) -> bool {\n@@ -1695,7 +1641,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         res\n     }\n \n-    fn expand_cfg_attr(&self, node: &mut impl AstLike, attr: ast::Attribute, pos: usize) {\n+    fn expand_cfg_attr(&self, node: &mut impl HasAttrs, attr: ast::Attribute, pos: usize) {\n         node.visit_attrs(|attrs| {\n             attrs.splice(pos..pos, self.cfg().expand_cfg_attr(attr, false));\n         });\n@@ -1733,7 +1679,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                 }\n                 None => {\n                     match Node::wrap_flat_map_node_noop_flat_map(node, self, |mut node, this| {\n-                        assign_id!(this, node.id(), || node.noop_flat_map(this))\n+                        assign_id!(this, node.node_id_mut(), || node.noop_flat_map(this))\n                     }) {\n                         Ok(output) => output,\n                         Err(returned_node) => {\n@@ -1781,7 +1727,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     })\n                 }\n                 None => {\n-                    assign_id!(self, node.id(), || node.noop_visit(self))\n+                    assign_id!(self, node.node_id_mut(), || node.noop_visit(self))\n                 }\n             };\n         }\n@@ -1794,11 +1740,11 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn flat_map_trait_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        self.flat_map_node(AstLikeWrapper::new(node, TraitItemTag))\n+        self.flat_map_node(AstNodeWrapper::new(node, TraitItemTag))\n     }\n \n     fn flat_map_impl_item(&mut self, node: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n-        self.flat_map_node(AstLikeWrapper::new(node, ImplItemTag))\n+        self.flat_map_node(AstNodeWrapper::new(node, ImplItemTag))\n     }\n \n     fn flat_map_foreign_item(\n@@ -1889,7 +1835,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n     }\n \n     fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        self.flat_map_node(AstLikeWrapper::new(node, OptExprTag))\n+        self.flat_map_node(AstNodeWrapper::new(node, OptExprTag))\n     }\n \n     fn visit_block(&mut self, node: &mut P<ast::Block>) {"}, {"sha": "6c74d462fb84c35d442e717494ee6fa68dd83429", "filename": "compiler/rustc_expand/src/proc_macro.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -4,10 +4,9 @@ use crate::proc_macro_server;\n use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token;\n-use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorGuaranteed;\n-use rustc_parse::nt_to_tokenstream;\n use rustc_parse::parser::ForceCollect;\n use rustc_span::profiling::SpannedEventArgRecorder;\n use rustc_span::{Span, DUMMY_SP};\n@@ -87,25 +86,17 @@ impl MultiItemModifier for ProcMacroDerive {\n     ) -> ExpandResult<Vec<Annotatable>, Annotatable> {\n         // We need special handling for statement items\n         // (e.g. `fn foo() { #[derive(Debug)] struct Bar; }`)\n-        let mut is_stmt = false;\n-        let item = match item {\n-            Annotatable::Item(item) => token::NtItem(item),\n-            Annotatable::Stmt(stmt) => {\n-                is_stmt = true;\n-                assert!(stmt.is_item());\n-\n-                // A proc macro can't observe the fact that we're passing\n-                // them an `NtStmt` - it can only see the underlying tokens\n-                // of the wrapped item\n-                token::NtStmt(stmt)\n-            }\n-            _ => unreachable!(),\n-        };\n-        let input = if crate::base::pretty_printing_compatibility_hack(&item, &ecx.sess.parse_sess)\n-        {\n-            TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n+        let is_stmt = matches!(item, Annotatable::Stmt(..));\n+        let hack = crate::base::ann_pretty_printing_compatibility_hack(&item, &ecx.sess.parse_sess);\n+        let input = if hack {\n+            let nt = match item {\n+                Annotatable::Item(item) => token::NtItem(item),\n+                Annotatable::Stmt(stmt) => token::NtStmt(stmt),\n+                _ => unreachable!(),\n+            };\n+            TokenTree::token(token::Interpolated(Lrc::new(nt)), DUMMY_SP).into()\n         } else {\n-            nt_to_tokenstream(&item, &ecx.sess.parse_sess, CanSynthesizeMissingTokens::No)\n+            item.to_tokens(&ecx.sess.parse_sess)\n         };\n \n         let stream = {"}, {"sha": "c0c786e4712e5f02a7c24896eca18cfff4f2a8bc", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -184,7 +184,7 @@ impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_, '_>)>\n                     delimiter: pm::Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess()),\n+                    flatten: crate::base::nt_pretty_printing_compatibility_hack(&nt, rustc.sess()),\n                 })\n             }\n "}, {"sha": "3ea68aea3cb5d61ac65840738cc146a7b2a29e66", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -18,8 +18,7 @@ use crate::context::{EarlyContext, LintContext, LintStore};\n use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self as ast_visit, Visitor};\n-use rustc_ast::AstLike;\n-use rustc_ast::{self as ast, walk_list};\n+use rustc_ast::{self as ast, walk_list, HasAttrs};\n use rustc_middle::ty::RegisteredTools;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;"}, {"sha": "423cddd88eeca610524683227721f9d3b264413b", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -17,17 +17,17 @@ use rustc_ast::token::{self, Nonterminal, Token, TokenKind};\n use rustc_ast::tokenstream::{self, AttributesData, CanSynthesizeMissingTokens, LazyTokenStream};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttrAnnotatedTokenTree};\n use rustc_ast::tokenstream::{Spacing, TokenStream};\n-use rustc_ast::AstLike;\n use rustc_ast::Attribute;\n use rustc_ast::{AttrItem, MetaItem};\n-use rustc_ast_pretty::pprust;\n+use rustc_ast::{HasAttrs, HasSpan, HasTokens};\n+use rustc_ast_pretty::pprust::{self, AstPrettyPrint};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic, FatalError, Level, PResult};\n use rustc_session::parse::ParseSess;\n use rustc_span::{FileName, SourceFile, Span};\n \n+use std::fmt;\n use std::path::Path;\n-use std::str;\n \n pub const MACRO_ARGUMENTS: Option<&str> = Some(\"macro arguments\");\n \n@@ -244,6 +244,20 @@ pub fn parse_in<'a, T>(\n // NOTE(Centril): The following probably shouldn't be here but it acknowledges the\n // fact that architecturally, we are using parsing (read on below to understand why).\n \n+pub fn to_token_stream(\n+    node: &(impl HasAttrs + HasSpan + HasTokens + AstPrettyPrint + fmt::Debug),\n+    sess: &ParseSess,\n+    synthesize_tokens: CanSynthesizeMissingTokens,\n+) -> TokenStream {\n+    if let Some(tokens) = prepend_attrs(&node.attrs(), node.tokens()) {\n+        return tokens;\n+    } else if matches!(synthesize_tokens, CanSynthesizeMissingTokens::Yes) {\n+        return fake_token_stream(sess, node);\n+    } else {\n+        panic!(\"Missing tokens for nt {:?} at {:?}: {:?}\", node, node.span(), node.pretty_print());\n+    }\n+}\n+\n pub fn nt_to_tokenstream(\n     nt: &Nonterminal,\n     sess: &ParseSess,\n@@ -298,7 +312,7 @@ pub fn nt_to_tokenstream(\n     if let Some(tokens) = tokens {\n         return tokens;\n     } else if matches!(synthesize_tokens, CanSynthesizeMissingTokens::Yes) {\n-        return fake_token_stream(sess, nt);\n+        return nt_fake_token_stream(sess, nt);\n     } else {\n         panic!(\n             \"Missing tokens for nt {:?} at {:?}: {:?}\",\n@@ -322,7 +336,13 @@ fn prepend_attrs(attrs: &[Attribute], tokens: Option<&LazyTokenStream>) -> Optio\n     Some(wrapped.to_tokenstream())\n }\n \n-pub fn fake_token_stream(sess: &ParseSess, nt: &Nonterminal) -> TokenStream {\n+pub fn fake_token_stream(sess: &ParseSess, node: &(impl AstPrettyPrint + HasSpan)) -> TokenStream {\n+    let source = node.pretty_print();\n+    let filename = FileName::macro_expansion_source_code(&source);\n+    parse_stream_from_source_str(filename, source, sess, Some(node.span()))\n+}\n+\n+fn nt_fake_token_stream(sess: &ParseSess, nt: &Nonterminal) -> TokenStream {\n     let source = pprust::nonterminal_to_string(nt);\n     let filename = FileName::macro_expansion_source_code(&source);\n     parse_stream_from_source_str(filename, source, sess, Some(nt.span()))"}, {"sha": "6c750ff428f5338acaf7b3d380d57d5e7440ed52", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -3,7 +3,7 @@ use rustc_ast::token::{self, Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenStream, AttributesData, CreateTokenStream};\n use rustc_ast::tokenstream::{AttrAnnotatedTokenTree, DelimSpan, LazyTokenStream, Spacing};\n use rustc_ast::{self as ast};\n-use rustc_ast::{AstLike, AttrVec, Attribute};\n+use rustc_ast::{AttrVec, Attribute, HasAttrs, HasTokens};\n use rustc_errors::PResult;\n use rustc_span::{sym, Span};\n \n@@ -192,7 +192,7 @@ impl<'a> Parser<'a> {\n     /// This restriction shouldn't be an issue in practice,\n     /// since this function is used to record the tokens for\n     /// a parsed AST item, which always has matching delimiters.\n-    pub fn collect_tokens_trailing_token<R: AstLike>(\n+    pub fn collect_tokens_trailing_token<R: HasAttrs + HasTokens>(\n         &mut self,\n         attrs: AttrWrapper,\n         force_collect: ForceCollect,"}, {"sha": "f32ee9fc9786341789d53264a67a8f0e2b6960a6", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -25,9 +25,9 @@ use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::AttrId;\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AnonConst, AstLike, AttrStyle, AttrVec, Const, CrateSugar, Extern};\n+use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, CrateSugar, Extern};\n use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacArgsEq, MacDelimiter, Mutability, StrLit};\n-use rustc_ast::{Unsafe, Visibility, VisibilityKind};\n+use rustc_ast::{HasAttrs, HasTokens, Unsafe, Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::PResult;\n@@ -1389,7 +1389,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn collect_tokens_no_attrs<R: AstLike>(\n+    pub fn collect_tokens_no_attrs<R: HasAttrs + HasTokens>(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n     ) -> PResult<'a, R> {"}, {"sha": "e215b6872bff82264899a4a27bfa18abea39eb68", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -1,6 +1,6 @@\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, NonterminalKind, Token};\n-use rustc_ast::AstLike;\n+use rustc_ast::HasTokens;\n use rustc_ast_pretty::pprust;\n use rustc_errors::PResult;\n use rustc_span::symbol::{kw, Ident};"}, {"sha": "56ebac0953b1996f2f80603406d93493da57e1e1", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -13,10 +13,8 @@ use rustc_ast as ast;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Delimiter, TokenKind};\n use rustc_ast::util::classify;\n-use rustc_ast::{\n-    AstLike, AttrStyle, AttrVec, Attribute, LocalKind, MacCall, MacCallStmt, MacStmtStyle,\n-};\n-use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt};\n+use rustc_ast::{AttrStyle, AttrVec, Attribute, LocalKind, MacCall, MacCallStmt, MacStmtStyle};\n+use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, HasAttrs, Local, Stmt};\n use rustc_ast::{StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, DiagnosticBuilder, ErrorGuaranteed, PResult};\n use rustc_span::source_map::{BytePos, Span};"}, {"sha": "41ba9a847e67a0bc2bf4167aac630782e8e3be2a", "filename": "src/tools/rustfmt/src/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fattr.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -1,7 +1,7 @@\n //! Format attributes and meta items.\n \n use rustc_ast::ast;\n-use rustc_ast::AstLike;\n+use rustc_ast::HasAttrs;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n use self::doc_comment::DocCommentFormatter;"}, {"sha": "ebadf3dd598bd1e0b49b15eacc2cd9eeaacd059a", "filename": "src/tools/rustfmt/src/formatting.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fformatting.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -5,7 +5,6 @@ use std::io::{self, Write};\n use std::time::{Duration, Instant};\n \n use rustc_ast::ast;\n-use rustc_ast::AstLike;\n use rustc_span::Span;\n \n use self::newline_style::apply_newline_style;"}, {"sha": "81da724329f02edc918bc6eaf5b91e76238dc011", "filename": "src/tools/rustfmt/src/modules.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fmodules.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -4,7 +4,6 @@ use std::path::{Path, PathBuf};\n \n use rustc_ast::ast;\n use rustc_ast::visit::Visitor;\n-use rustc_ast::AstLike;\n use rustc_span::symbol::{self, sym, Symbol};\n use rustc_span::Span;\n use thiserror::Error;\n@@ -50,19 +49,10 @@ impl<'a> Module<'a> {\n             ast_mod_kind,\n         }\n     }\n-}\n \n-impl<'a> AstLike for Module<'a> {\n-    const SUPPORTS_CUSTOM_INNER_ATTRS: bool = true;\n-    fn attrs(&self) -> &[ast::Attribute] {\n+    pub(crate) fn attrs(&self) -> &[ast::Attribute] {\n         &self.inner_attr\n     }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<ast::Attribute>)) {\n-        f(&mut self.inner_attr)\n-    }\n-    fn tokens_mut(&mut self) -> Option<&mut Option<rustc_ast::tokenstream::LazyTokenStream>> {\n-        unimplemented!()\n-    }\n }\n \n /// Maps each module to the corresponding file."}, {"sha": "9a0e0752c12f5ed3ec755a389ac1cd696a647fd5", "filename": "src/tools/rustfmt/src/visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a85de162a513d1d11d263783a3f7092fff824b48/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fvisitor.rs?ref=a85de162a513d1d11d263783a3f7092fff824b48", "patch": "@@ -1,7 +1,7 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_ast::{ast, token::Delimiter, visit, AstLike};\n+use rustc_ast::{ast, token::Delimiter, visit};\n use rustc_data_structures::sync::Lrc;\n use rustc_span::{symbol, BytePos, Pos, Span};\n "}]}