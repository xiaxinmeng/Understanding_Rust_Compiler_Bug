{"sha": "750d6f85459356db4838dc06db8b19406e1ed31a", "node_id": "C_kwDOAAsO6NoAKDc1MGQ2Zjg1NDU5MzU2ZGI0ODM4ZGMwNmRiOGIxOTQwNmUxZWQzMWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-02T17:05:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-02T17:05:13Z"}, "message": "Auto merge of #97585 - lqd:const-alloc-intern, r=RalfJung\n\nCTFE interning: don't walk allocations that don't need it\n\nThe interning of const allocations visits the mplace looking for references to intern. Walking big aggregates like big static arrays can be costly, so we only do it if the allocation we're interning contains references or interior mutability.\n\nWalking ZSTs was avoided before, and this optimization is now applied to cases where there are no references/relocations either.\n\n---\n\nWhile initially looking at this in the context of #93215, I've been testing with smaller allocations than the 16GB one in that issue, and with different init/uninit patterns (esp. via padding).\n\nIn that example, by default, `eval_to_allocation_raw` is the heaviest query followed by `incr_comp_serialize_result_cache`. So I'll show numbers when incremental compilation is disabled, to focus on the const allocations themselves at 95% of the compilation time, at bigger array sizes on these minimal examples like `static ARRAY: [u64; LEN] = [0; LEN];`.\n\nThat is a close construction to parts of the `ctfe-stress-test-5` benchmark, which has const allocations in the megabytes, while most crates usually have way smaller ones. This PR will have the most impact in these situations, as the walk during the interning starts to dominate the runtime.\n\nUnicode crates (some of which are present in our benchmarks) like `ucd`, `encoding_rs`, etc come to mind as having bigger than usual allocations as well, because of big tables of code points (in the hundreds of KB, so still an order of magnitude or 2 less than the stress test).\n\nIn a check build, for a single static array shown above, from 100 to 10^9 u64s (for lengths in powers of ten), the constant factors are lowered:\n\n(log scales for easier comparisons)\n![plot_log](https://user-images.githubusercontent.com/247183/171422958-16f1ea19-3ed4-4643-812c-1c7c60a97e19.png)\n\n(linear scale for absolute diff at higher Ns)\n![plot_linear](https://user-images.githubusercontent.com/247183/171401886-2a869a4d-5cd5-47d3-9a5f-8ce34b7a6917.png)\n\nFor one of the alternatives of that issue\n```rust\nconst ROWS: usize = 100_000;\nconst COLS: usize = 10_000;\n\nstatic TWODARRAY: [[u128; COLS]; ROWS] = [[0; COLS]; ROWS];\n```\n\nwe can see a similar reduction of around 3x (from 38s to 12s or so).\n\nFor the same size, the slowest case IIRC is when there are uninitialized bytes e.g. via padding\n\n```rust\nconst ROWS: usize = 100_000;\nconst COLS: usize = 10_000;\n\nstatic TWODARRAY: [[(u64, u8); COLS]; ROWS] = [[(0, 0); COLS]; ROWS];\n```\nthen interning/walking does not dominate anymore (but means there is likely still some interesting work left to do here).\n\nCompile times in this case rise up quite a bit, and avoiding interning walks has less impact: around 23%, from 730s on master to 568s with this PR.", "tree": {"sha": "fbc82087c5caa00be6c9431c677fddb7e4499465", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbc82087c5caa00be6c9431c677fddb7e4499465"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/750d6f85459356db4838dc06db8b19406e1ed31a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/750d6f85459356db4838dc06db8b19406e1ed31a", "html_url": "https://github.com/rust-lang/rust/commit/750d6f85459356db4838dc06db8b19406e1ed31a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/750d6f85459356db4838dc06db8b19406e1ed31a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a1092056441652fe5fe5c5b422644951e6b99ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a1092056441652fe5fe5c5b422644951e6b99ce", "html_url": "https://github.com/rust-lang/rust/commit/6a1092056441652fe5fe5c5b422644951e6b99ce"}, {"sha": "d634f14f26dc6640a9b6cd8b5f896aaf1ecc3cb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d634f14f26dc6640a9b6cd8b5f896aaf1ecc3cb6", "html_url": "https://github.com/rust-lang/rust/commit/d634f14f26dc6640a9b6cd8b5f896aaf1ecc3cb6"}], "stats": {"total": 69, "additions": 61, "deletions": 8}, "files": [{"sha": "9dfdafcb38e0b69f4039afa231d4f38a29e81abb", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/750d6f85459356db4838dc06db8b19406e1ed31a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750d6f85459356db4838dc06db8b19406e1ed31a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=750d6f85459356db4838dc06db8b19406e1ed31a", "patch": "@@ -168,8 +168,51 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n         mplace: &MPlaceTy<'tcx>,\n         fields: impl Iterator<Item = InterpResult<'tcx, Self::V>>,\n     ) -> InterpResult<'tcx> {\n-        // ZSTs cannot contain pointers, so we can skip them.\n-        if mplace.layout.is_zst() {\n+        // We want to walk the aggregate to look for references to intern. While doing that we\n+        // also need to take special care of interior mutability.\n+        //\n+        // As an optimization, however, if the allocation does not contain any references: we don't\n+        // need to do the walk. It can be costly for big arrays for example (e.g. issue #93215).\n+        let is_walk_needed = |mplace: &MPlaceTy<'tcx>| -> InterpResult<'tcx, bool> {\n+            // ZSTs cannot contain pointers, we can avoid the interning walk.\n+            if mplace.layout.is_zst() {\n+                return Ok(false);\n+            }\n+\n+            // Now, check whether this allocation could contain references.\n+            //\n+            // Note, this check may sometimes not be cheap, so we only do it when the walk we'd like\n+            // to avoid could be expensive: on the potentially larger types, arrays and slices,\n+            // rather than on all aggregates unconditionally.\n+            if matches!(mplace.layout.ty.kind(), ty::Array(..) | ty::Slice(..)) {\n+                let Some((size, align)) = self.ecx.size_and_align_of_mplace(&mplace)? else {\n+                    // We do the walk if we can't determine the size of the mplace: we may be\n+                    // dealing with extern types here in the future.\n+                    return Ok(true);\n+                };\n+\n+                // If there are no relocations in this allocation, it does not contain references\n+                // that point to another allocation, and we can avoid the interning walk.\n+                if let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, align)? {\n+                    if !alloc.has_relocations() {\n+                        return Ok(false);\n+                    }\n+                } else {\n+                    // We're encountering a ZST here, and can avoid the walk as well.\n+                    return Ok(false);\n+                }\n+            }\n+\n+            // In the general case, we do the walk.\n+            Ok(true)\n+        };\n+\n+        // If this allocation contains no references to intern, we avoid the potentially costly\n+        // walk.\n+        //\n+        // We can do this before the checks for interior mutability below, because only references\n+        // are relevant in that situation, and we're checking if there are any here.\n+        if !is_walk_needed(mplace)? {\n             return Ok(());\n         }\n "}, {"sha": "c2a5b71b8f9d4f13aa876df28439af0f6249776b", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/750d6f85459356db4838dc06db8b19406e1ed31a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750d6f85459356db4838dc06db8b19406e1ed31a/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=750d6f85459356db4838dc06db8b19406e1ed31a", "patch": "@@ -942,6 +942,11 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n             .check_bytes(&self.tcx, self.range.subrange(range), allow_uninit, allow_ptr)\n             .map_err(|e| e.to_interp_error(self.alloc_id))?)\n     }\n+\n+    /// Returns whether the allocation has relocations for the entire range of the `AllocRef`.\n+    pub(crate) fn has_relocations(&self) -> bool {\n+        self.alloc.has_relocations(&self.tcx, self.range)\n+    }\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {"}, {"sha": "1e2b53040d2d7d8b41f817ecacf3fea4a81dd142", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/750d6f85459356db4838dc06db8b19406e1ed31a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/750d6f85459356db4838dc06db8b19406e1ed31a/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=750d6f85459356db4838dc06db8b19406e1ed31a", "patch": "@@ -537,21 +537,26 @@ impl<Tag: Provenance, Extra> Allocation<Tag, Extra> {\n /// Relocations.\n impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Returns all relocations overlapping with the given pointer-offset pair.\n-    pub fn get_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Tag)] {\n+    fn get_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> &[(Size, Tag)] {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = range.start.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n         self.relocations.range(Size::from_bytes(start)..range.end())\n     }\n \n+    /// Returns whether this allocation has relocations overlapping with the given range.\n+    ///\n+    /// Note: this function exists to allow `get_relocations` to be private, in order to somewhat\n+    /// limit access to relocations outside of the `Allocation` abstraction.\n+    ///\n+    pub fn has_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> bool {\n+        !self.get_relocations(cx, range).is_empty()\n+    }\n+\n     /// Checks that there are no relocations overlapping with the given range.\n     #[inline(always)]\n     fn check_relocations(&self, cx: &impl HasDataLayout, range: AllocRange) -> AllocResult {\n-        if self.get_relocations(cx, range).is_empty() {\n-            Ok(())\n-        } else {\n-            Err(AllocError::ReadPointerAsBytes)\n-        }\n+        if self.has_relocations(cx, range) { Err(AllocError::ReadPointerAsBytes) } else { Ok(()) }\n     }\n \n     /// Removes all relocations inside the given range."}]}