{"sha": "944933ef4e81abd6048287b2c257e883c04f7757", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0NDkzM2VmNGU4MWFiZDYwNDgyODdiMmMyNTdlODgzYzA0Zjc3NTc=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-08T15:19:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-08T15:19:52Z"}, "message": "Rollup merge of #39582 - nikomatsakis:incr-comp-issue-39569, r=michaelwoerister\n\nHandle the case where an intermediate node can't be recreated\n\nThis solution grows the graph, but this is quite the corner case.\n\nr? @michaelwoerister", "tree": {"sha": "8ed214e3f98e6a97c74b430b2064abf131b306ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ed214e3f98e6a97c74b430b2064abf131b306ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/944933ef4e81abd6048287b2c257e883c04f7757", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/944933ef4e81abd6048287b2c257e883c04f7757", "html_url": "https://github.com/rust-lang/rust/commit/944933ef4e81abd6048287b2c257e883c04f7757", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/944933ef4e81abd6048287b2c257e883c04f7757/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0eeb6e63725ccd007a2d308924e91cc87e88fde", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0eeb6e63725ccd007a2d308924e91cc87e88fde", "html_url": "https://github.com/rust-lang/rust/commit/e0eeb6e63725ccd007a2d308924e91cc87e88fde"}, {"sha": "4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f5fc4e24219f64235f08ba91ccf4b447a8643ee", "html_url": "https://github.com/rust-lang/rust/commit/4f5fc4e24219f64235f08ba91ccf4b447a8643ee"}], "stats": {"total": 157, "additions": 122, "deletions": 35}, "files": [{"sha": "7724658a9d6fead0f25ec19c116c9b26fd0e654e", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 84, "deletions": 35, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/944933ef4e81abd6048287b2c257e883c04f7757/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944933ef4e81abd6048287b2c257e883c04f7757/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=944933ef4e81abd6048287b2c257e883c04f7757", "patch": "@@ -176,46 +176,32 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Recreate the edges in the graph that are still clean.\n     let mut clean_work_products = FxHashSet();\n     let mut dirty_work_products = FxHashSet(); // incomplete; just used to suppress debug output\n+    let mut extra_edges = vec![];\n     for (source, targets) in &edge_map {\n         for target in targets {\n-            // If the target is dirty, skip the edge. If this is an edge\n-            // that targets a work-product, we can print the blame\n-            // information now.\n-            if let Some(blame) = dirty_raw_nodes.get(target) {\n-                if let DepNode::WorkProduct(ref wp) = *target {\n-                    if tcx.sess.opts.debugging_opts.incremental_info {\n-                        if dirty_work_products.insert(wp.clone()) {\n-                            // It'd be nice to pretty-print these paths better than just\n-                            // using the `Debug` impls, but wev.\n-                            println!(\"incremental: module {:?} is dirty because {:?} \\\n-                                      changed or was removed\",\n-                                     wp,\n-                                     blame.map_def(|&index| {\n-                                         Some(directory.def_path_string(tcx, index))\n-                                     }).unwrap());\n-                        }\n-                    }\n-                }\n-                continue;\n-            }\n-\n-            // If the source is dirty, the target will be dirty.\n-            assert!(!dirty_raw_nodes.contains_key(source));\n-\n-            // Retrace the source -> target edges to def-ids and then\n-            // create an edge in the graph. Retracing may yield none if\n-            // some of the data happens to have been removed; this ought\n-            // to be impossible unless it is dirty, so we can unwrap.\n-            let source_node = retraced.map(source).unwrap();\n-            let target_node = retraced.map(target).unwrap();\n-            let _task = tcx.dep_graph.in_task(target_node);\n-            tcx.dep_graph.read(source_node);\n-            if let DepNode::WorkProduct(ref wp) = *target {\n-                clean_work_products.insert(wp.clone());\n-            }\n+            process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+                          &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n         }\n     }\n \n+    // Subtle. Sometimes we have intermediate nodes that we can't recreate in the new graph.\n+    // This is pretty unusual but it arises in a scenario like this:\n+    //\n+    //     Hir(X) -> Foo(Y) -> Bar\n+    //\n+    // Note that the `Hir(Y)` is not an input to `Foo(Y)` -- this\n+    // almost never happens, but can happen in some obscure\n+    // scenarios. In that case, if `Y` is removed, then we can't\n+    // recreate `Foo(Y)` (the def-id `Y` no longer exists); what we do\n+    // then is to push the edge `Hir(X) -> Bar` onto `extra_edges`\n+    // (along with any other targets of `Foo(Y)`). We will then add\n+    // the edge from `Hir(X)` to `Bar` (or, if `Bar` itself cannot be\n+    // recreated, to the targets of `Bar`).\n+    while let Some((source, target)) = extra_edges.pop() {\n+        process_edges(tcx, source, target, &edge_map, &directory, &retraced, &dirty_raw_nodes,\n+                      &mut clean_work_products, &mut dirty_work_products, &mut extra_edges);\n+    }\n+\n     // Add in work-products that are still clean, and delete those that are\n     // dirty.\n     reconcile_work_products(tcx, work_products, &clean_work_products);\n@@ -393,3 +379,66 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n            serialized_hashes.index_map.len());\n }\n \n+fn process_edges<'a, 'tcx, 'edges>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    source: &'edges DepNode<DefPathIndex>,\n+    target: &'edges DepNode<DefPathIndex>,\n+    edges: &'edges FxHashMap<DepNode<DefPathIndex>, Vec<DepNode<DefPathIndex>>>,\n+    directory: &DefIdDirectory,\n+    retraced: &RetracedDefIdDirectory,\n+    dirty_raw_nodes: &DirtyNodes,\n+    clean_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    dirty_work_products: &mut FxHashSet<Arc<WorkProductId>>,\n+    extra_edges: &mut Vec<(&'edges DepNode<DefPathIndex>, &'edges DepNode<DefPathIndex>)>)\n+{\n+    // If the target is dirty, skip the edge. If this is an edge\n+    // that targets a work-product, we can print the blame\n+    // information now.\n+    if let Some(blame) = dirty_raw_nodes.get(target) {\n+        if let DepNode::WorkProduct(ref wp) = *target {\n+            if tcx.sess.opts.debugging_opts.incremental_info {\n+                if dirty_work_products.insert(wp.clone()) {\n+                    // It'd be nice to pretty-print these paths better than just\n+                    // using the `Debug` impls, but wev.\n+                    println!(\"incremental: module {:?} is dirty because {:?} \\\n+                              changed or was removed\",\n+                             wp,\n+                             blame.map_def(|&index| {\n+                                 Some(directory.def_path_string(tcx, index))\n+                             }).unwrap());\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    // If the source is dirty, the target will be dirty.\n+    assert!(!dirty_raw_nodes.contains_key(source));\n+\n+    // Retrace the source -> target edges to def-ids and then create\n+    // an edge in the graph. Retracing may yield none if some of the\n+    // data happens to have been removed.\n+    if let Some(source_node) = retraced.map(source) {\n+        if let Some(target_node) = retraced.map(target) {\n+            let _task = tcx.dep_graph.in_task(target_node);\n+            tcx.dep_graph.read(source_node);\n+            if let DepNode::WorkProduct(ref wp) = *target {\n+                clean_work_products.insert(wp.clone());\n+            }\n+        } else {\n+            // As discussed in `decode_dep_graph` above, sometimes the\n+            // target cannot be recreated again, in which case we add\n+            // edges to go from `source` to the targets of `target`.\n+            extra_edges.extend(\n+                edges[target].iter().map(|t| (source, t)));\n+        }\n+    } else {\n+        // It's also possible that the source can't be created! But we\n+        // can ignore such cases, because (a) if `source` is a HIR\n+        // node, it would be considered dirty; and (b) in other cases,\n+        // there must be some input to this node that is clean, and so\n+        // we'll re-create the edges over in the case where target is\n+        // undefined.\n+    }\n+}\n+"}, {"sha": "5b53e94825300d2219b3b82e40423787e27af80e", "filename": "src/test/incremental/issue-39569.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/944933ef4e81abd6048287b2c257e883c04f7757/src%2Ftest%2Fincremental%2Fissue-39569.rs", "raw_url": "https://github.com/rust-lang/rust/raw/944933ef4e81abd6048287b2c257e883c04f7757/src%2Ftest%2Fincremental%2Fissue-39569.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39569.rs?ref=944933ef4e81abd6048287b2c257e883c04f7757", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for a weird corner case in our dep-graph reduction\n+// code. When we solve `CoerceUnsized<Foo>`, we find no impls, so we\n+// don't end up with an edge to any HIR nodes, but it still gets\n+// preserved in the dep graph.\n+\n+// revisions:rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n+\n+use std::sync::Arc;\n+\n+#[cfg(rpass1)]\n+struct Foo { x: usize }\n+\n+#[cfg(rpass1)]\n+fn main() {\n+    let x: Arc<Foo> = Arc::new(Foo { x: 22 });\n+    let y: Arc<Foo> = x;\n+}\n+\n+#[cfg(rpass2)]\n+struct FooX { x: usize }\n+\n+#[cfg(rpass2)]\n+fn main() {\n+    let x: Arc<FooX> = Arc::new(FooX { x: 22 });\n+    let y: Arc<FooX> = x;\n+}\n+"}]}