{"sha": "6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZGJhODJiYTE4ZmU2OWFjNDQ4ZjgxYjEwYmJiYzdkMGMxMGJjZTE=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-08T12:34:37Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-12T17:53:04Z"}, "message": "std::ops docs: incorporated changes suggested in review\n\n* fixed link typos and copy-paster errors\n* rewrote Fn* explanations\n* `RHS = Self` -> `RHS` is `Self` (added that to all applicable places as\n  well)\n* fixed up some links\n* s/MutDeref/DerefMut\n* removed remaining superfluous `fn main()`s\n* fixed some minor phrasings and factual errors and inaccuracies\n\nstd::ops docs: Fix phrasing and factual errors/inaccuracies", "tree": {"sha": "9cd2d82efcb018789a00ef327f89fcfe7bfb1868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cd2d82efcb018789a00ef327f89fcfe7bfb1868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "html_url": "https://github.com/rust-lang/rust/commit/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/comments", "author": null, "committer": null, "parents": [{"sha": "99e44d8680f91e908c39ab3d5f0be2c11558af01", "url": "https://api.github.com/repos/rust-lang/rust/commits/99e44d8680f91e908c39ab3d5f0be2c11558af01", "html_url": "https://github.com/rust-lang/rust/commit/99e44d8680f91e908c39ab3d5f0be2c11558af01"}], "stats": {"total": 140, "additions": 82, "deletions": 58}, "files": [{"sha": "62007caedd3fc425f6c50f05f7fb9a71dce18f01", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "patch": "@@ -10,8 +10,8 @@\n \n /// The addition operator `+`.\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n+/// Note that `RHS` is `Self` by default, but this is not mandatory. For\n+/// example, [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n /// operations of the form `SystemTime = SystemTime + Duration`.\n ///\n /// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n@@ -105,8 +105,8 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The subtraction operator `-`.\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n+/// Note that `RHS` is `Self` by default, but this is not mandatory. For\n+/// example, [`std::time::SystemTime`] implements `Sub<Duration>`, which permits\n /// operations of the form `SystemTime = SystemTime - Duration`.\n ///\n /// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n@@ -200,7 +200,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The multiplication operator `*`.\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory.\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n ///\n /// # Examples\n ///\n@@ -317,7 +317,7 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The division operator `/`.\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory.\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n ///\n /// # Examples\n ///\n@@ -455,6 +455,8 @@ div_impl_float! { f32 f64 }\n \n /// The remainder operator `%`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n /// This example implements `Rem` on a `SplitSlice` object. After `Rem` is"}, {"sha": "0bc5e554cb347d7cf2c3e76a94f21b685bf4a5a3", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "patch": "@@ -68,6 +68,8 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise AND operator `&`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n /// An implementation of `BitAnd` for a wrapper around `bool`.\n@@ -147,6 +149,8 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise OR operator `|`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n /// An implementation of `BitOr` for a wrapper around `bool`.\n@@ -226,6 +230,8 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise XOR operator `^`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n /// An implementation of `BitXor` that lifts `^` to a wrapper around `bool`."}, {"sha": "a2e7c44cb249fd08f6f36942133c0ecb469d8168", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "patch": "@@ -111,7 +111,7 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n ///\n /// # More on `Deref` coercion\n ///\n-/// If `T` implements `MutDeref<Target = U>`, and `x` is a value of type `T`,\n+/// If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`,\n /// then:\n /// * In mutable contexts, `*x` on non-pointer types is equivalent to\n ///   `*Deref::deref(&x)`."}, {"sha": "2cc4e72817ff175cf0b5204674936b5aeb29d085", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 60, "deletions": 33, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "patch": "@@ -8,27 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// A version of the call operator that takes an immutable receiver.\n+/// The version of the call operator that takes an immutable receiver.\n ///\n-/// Closures only taking immutable references to captured variables\n-/// automatically implement this trait, which allows them to be invoked.\n-/// For mutably referenced captures, see [`FnMut`], and for consuming the\n-/// capture, see [`FnOnce`].\n+/// Instances of `Fn` can be called repeatedly without mutating state.\n ///\n-/// You can use the [`Fn`] traits when you want to accept a closure as a\n-/// parameter. Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n-/// instance of `Fn` can be used where a [`FnMut`] or [`FnOnce`] is expected.\n+/// *This trait (`Fn`) is not to be confused with [function pointers][]\n+/// (`fn`).*\n+///\n+/// `Fn` is implemented automatically by closures which only take immutable\n+/// references to captured variables or don't capture anything at all, as well\n+/// as (safe) [function pointers][] (with some caveats, see their documentation\n+/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n+/// implements `Fn`, too.\n+///\n+/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n+/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n+/// is expected.\n+///\n+/// Use `Fn` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly and without mutating state (e.g. when\n+/// calling it concurrently). If you do not need such strict requirements, use\n+/// [`FnMut`] or [`FnOnce`] as bounds.\n ///\n /// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// more information about closures in general.\n+/// some more information on this topic.\n ///\n /// Also of note is the special syntax for `Fn` traits (e.g.\n /// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in *The Rustonomicon*][nomicon].\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n ///\n /// [book]: ../../book/second-edition/ch13-01-closures.html\n /// [`FnMut`]: trait.FnMut.html\n /// [`FnOnce`]: trait.FnOnce.html\n+/// [function pointers]: ../../std/primitive.fn.html\n /// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples\n@@ -61,29 +73,36 @@ pub trait Fn<Args> : FnMut<Args> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n-/// A version of the call operator that takes a mutable receiver.\n+/// The version of the call operator that takes a mutable receiver.\n+///\n+/// Instances of `FnMut` can be called repeatedly and may mutate state.\n ///\n-/// Closures that might mutably reference captured variables automatically\n-/// implement this trait, which allows them to be invoked. For immutably\n-/// referenced captures, see [`Fn`], and for consuming the captures, see\n-/// [`FnOnce`].\n+/// `FnMut` is implemented automatically by closures which take mutable\n+/// references to captured variables, as well as all types that implement\n+/// [`Fn`], e.g. (safe) [function pointers][] (since `FnMut` is a supertrait of\n+/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n+/// implements `FnMut`, too.\n ///\n-/// You can use the [`Fn`] traits when you want to accept a closure as a\n-/// parameter. Since [`FnOnce`] is a supertrait of `FnMut`, any instance of\n-/// `FnMut` can be used where a [`FnOnce`] is expected, and since [`Fn`] is a\n-/// subtrait of `FnMut`, any instance of [`Fn`] can be used where [`FnMut`] is\n-/// expected.\n+/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n+/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n+/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n+///\n+/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly, while allowing it to mutate state.\n+/// If you don't want the parameter to mutate state, use [`Fn`] as a\n+/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n ///\n /// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// more information about closures in general.\n+/// some more information on this topic.\n ///\n /// Also of note is the special syntax for `Fn` traits (e.g.\n /// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in *The Rustonomicon*][nomicon].\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n ///\n /// [book]: ../../book/second-edition/ch13-01-closures.html\n-/// [`Fn`]: trait.Fnhtml\n+/// [`Fn`]: trait.Fn.html\n /// [`FnOnce`]: trait.FnOnce.html\n+/// [function pointers]: ../../std/primitive.fn.html\n /// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples\n@@ -127,27 +146,35 @@ pub trait FnMut<Args> : FnOnce<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n-/// A version of the call operator that takes a by-value receiver.\n+/// The version of the call operator that takes a by-value receiver.\n+///\n+/// Instances of `FnOnce` can be called, but might not be callable multiple\n+/// times. Because of this, if the only thing known about a type is that it\n+/// implements `FnOnce`, it can only be called once.\n+///\n+/// `FnOnce` is implemented automatically by closure that might consume captured\n+/// variables, as well as all types that implement [`FnMut`], e.g. (safe)\n+/// [function pointers][] (since `FnOnce` is a supertrait of [`FnMut`]).\n ///\n-/// Closures that might take ownership of captured variables automatically\n-/// implement this trait, which allows them to be invoked. For immutably\n-/// referenced captures, see [`Fn`], and for mutably referenced captures,\n-/// see [`FnMut`].\n+/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n+/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n ///\n-/// You can use the [`Fn`] traits when you want to accept a closure as a\n-/// parameter. Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any\n-/// instance of [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n+/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n+/// type and only need to call it once. If you need to call the parameter\n+/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n+/// state, use [`Fn`].\n ///\n /// See the [chapter on closures in *The Rust Programming Language*][book] for\n-/// more information about closures in general.\n+/// some more information on this topic.\n ///\n /// Also of note is the special syntax for `Fn` traits (e.g.\n /// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n-/// this can refer to [the relevant section in *The Rustonomicon*][nomicon].\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n ///\n /// [book]: ../../book/second-edition/ch13-01-closures.html\n /// [`Fn`]: trait.Fn.html\n /// [`FnMut`]: trait.FnMut.html\n+/// [function pointers]: ../../std/primitive.fn.html\n /// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples"}, {"sha": "d65c0aba5048103fe80c67056102347f876ee742", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "patch": "@@ -77,11 +77,9 @@ pub trait Index<Idx: ?Sized> {\n /// `container[index]` is actually syntactic sugar for\n /// `*container.index_mut(index)`, but only when used as a mutable value. If\n /// an immutable value is requested, the [`Index`] trait is used instead. This\n-/// allows nice things such as `v[index] = value` if the type of `value`\n-/// implements [`Copy`].\n+/// allows nice things such as `v[index] = value`.\n ///\n /// [`Index`]: ../../std/ops/trait.Index.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///"}, {"sha": "463a50491a866e16a884973474a7622bd479dda6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=6bdba82ba18fe69ac448f81b10bbbc7d0c10bce1", "patch": "@@ -12,7 +12,7 @@ use fmt;\n \n /// An unbounded range (`..`).\n ///\n-/// `RangeFull` is primarily used as a [slicing index], it's shorthand is `..`.\n+/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\n /// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n@@ -101,15 +101,13 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// # fn main() {\n     /// assert!(!(3..5).contains(2));\n     /// assert!( (3..5).contains(3));\n     /// assert!( (3..5).contains(4));\n     /// assert!(!(3..5).contains(5));\n     ///\n     /// assert!(!(3..3).contains(3));\n     /// assert!(!(3..2).contains(3));\n-    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item) && (item < self.end)\n@@ -163,11 +161,9 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// # fn main() {\n     /// assert!(!(3..).contains(2));\n     /// assert!( (3..).contains(3));\n     /// assert!( (3..).contains(1_000_000_000));\n-    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item)\n@@ -191,6 +187,8 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n+/// // error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:\n+/// // std::iter::Iterator` is not satisfied\n /// for i in ..5 {\n ///     // ...\n /// }\n@@ -234,11 +232,9 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// ```\n     /// #![feature(range_contains)]\n     ///\n-    /// # fn main() {\n     /// assert!( (..5).contains(-1_000_000_000));\n     /// assert!( (..5).contains(4));\n     /// assert!(!(..5).contains(5));\n-    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item < self.end)\n@@ -255,14 +251,12 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n ///\n-/// # fn main() {\n /// assert_eq!((3...5), std::ops::RangeInclusive { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3...5).sum());\n ///\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ...2], [0,1,2  ]);\n /// assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n-/// # }\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n@@ -295,7 +289,6 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n     ///\n-    /// # fn main() {\n     /// assert!(!(3...5).contains(2));\n     /// assert!( (3...5).contains(3));\n     /// assert!( (3...5).contains(4));\n@@ -304,7 +297,6 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     ///\n     /// assert!( (3...3).contains(3));\n     /// assert!(!(3...2).contains(3));\n-    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n@@ -330,6 +322,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n ///\n /// ```compile_fail,E0277\n /// #![feature(inclusive_range_syntax)]\n+///\n+/// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n+/// // std::iter::Iterator` is not satisfied\n /// for i in ...5 {\n ///     // ...\n /// }\n@@ -341,11 +336,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n /// ```\n /// #![feature(inclusive_range_syntax)]\n ///\n-/// # fn main() {\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n /// assert_eq!(arr[1...2], [  1,2  ]);\n-/// # }\n /// ```\n ///\n /// [`IntoIterator`]: ../iter/trait.Iterator.html\n@@ -377,11 +370,9 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n     ///\n-    /// # fn main() {\n     /// assert!( (...5).contains(-1_000_000_000));\n     /// assert!( (...5).contains(5));\n     /// assert!(!(...5).contains(6));\n-    /// # }\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item <= self.end)"}]}