{"sha": "66847ff56b933609618b0899cb3bfdd74f9817d5", "node_id": "C_kwDOAAsO6NoAKDY2ODQ3ZmY1NmI5MzM2MDk2MThiMDg5OWNiM2JmZGQ3NGY5ODE3ZDU", "commit": {"author": {"name": "Lo\u00efc BRANSTETT", "email": "lolo.branstett@numericable.fr", "date": "2022-02-21T00:45:03Z"}, "committer": {"name": "Urgau", "email": "urgau@numericable.fr", "date": "2022-11-01T13:22:13Z"}, "message": "Test that target feature mix up with homogeneous floats is sound\n\nThis is basically is ripoff of src/test/ui/simd/target-feature-mixup.rs\nbut for floats and without #[repr(simd)]", "tree": {"sha": "3832382acba5d545f439639b6e894365dbd799a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3832382acba5d545f439639b6e894365dbd799a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66847ff56b933609618b0899cb3bfdd74f9817d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66847ff56b933609618b0899cb3bfdd74f9817d5", "html_url": "https://github.com/rust-lang/rust/commit/66847ff56b933609618b0899cb3bfdd74f9817d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66847ff56b933609618b0899cb3bfdd74f9817d5/comments", "author": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Urgau", "id": 3616612, "node_id": "MDQ6VXNlcjM2MTY2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3616612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Urgau", "html_url": "https://github.com/Urgau", "followers_url": "https://api.github.com/users/Urgau/followers", "following_url": "https://api.github.com/users/Urgau/following{/other_user}", "gists_url": "https://api.github.com/users/Urgau/gists{/gist_id}", "starred_url": "https://api.github.com/users/Urgau/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Urgau/subscriptions", "organizations_url": "https://api.github.com/users/Urgau/orgs", "repos_url": "https://api.github.com/users/Urgau/repos", "events_url": "https://api.github.com/users/Urgau/events{/privacy}", "received_events_url": "https://api.github.com/users/Urgau/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2afca78a0b03db144c5d8b9f8868feebfe096309", "url": "https://api.github.com/repos/rust-lang/rust/commits/2afca78a0b03db144c5d8b9f8868feebfe096309", "html_url": "https://github.com/rust-lang/rust/commit/2afca78a0b03db144c5d8b9f8868feebfe096309"}], "stats": {"total": 192, "additions": 192, "deletions": 0}, "files": [{"sha": "d7f5e19219ed6b7723adb8d9acc4a69910380110", "filename": "src/test/ui/abi/homogenous-floats-target-feature-mixup.rs", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/66847ff56b933609618b0899cb3bfdd74f9817d5/src%2Ftest%2Fui%2Fabi%2Fhomogenous-floats-target-feature-mixup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66847ff56b933609618b0899cb3bfdd74f9817d5/src%2Ftest%2Fui%2Fabi%2Fhomogenous-floats-target-feature-mixup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fabi%2Fhomogenous-floats-target-feature-mixup.rs?ref=66847ff56b933609618b0899cb3bfdd74f9817d5", "patch": "@@ -0,0 +1,192 @@\n+// This test check that even if we mixup target feature of function with homogenous floats,\n+// the abi is sound and still produce the right answer.\n+//\n+// This is basically the same test as src/test/ui/simd/target-feature-mixup.rs but for floats and\n+// without #[repr(simd)]\n+\n+// run-pass\n+// ignore-emscripten\n+// ignore-sgx no processes\n+\n+#![feature(avx512_target_feature)]\n+\n+#![allow(overflowing_literals)]\n+#![allow(unused_variables)]\n+\n+use std::process::{Command, ExitStatus};\n+use std::env;\n+\n+fn main() {\n+    if let Some(level) = env::args().nth(1) {\n+        return test::main(&level)\n+    }\n+\n+    match std::env::var(\"TARGET\") {\n+        Ok(s) => {\n+            // Skip this tests on i586-unknown-linux-gnu where sse2 is disabled\n+            if s.contains(\"i586\") {\n+                return\n+            }\n+        }\n+        Err(_) => return,\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+    for level in [\"sse\", \"avx\", \"avx512\"].iter() {\n+        let status = Command::new(&me).arg(level).status().unwrap();\n+        if status.success() {\n+            println!(\"success with {}\", level);\n+            continue\n+        }\n+\n+        // We don't actually know if our computer has the requisite target features\n+        // for the test below. Testing for that will get added to libstd later so\n+        // for now just assume sigill means this is a machine that can't run this test.\n+        if is_sigill(status) {\n+            println!(\"sigill with {}, assuming spurious\", level);\n+            continue\n+        }\n+        panic!(\"invalid status at {}: {}\", level, status);\n+    }\n+}\n+\n+#[cfg(unix)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    use std::os::unix::prelude::*;\n+    status.signal() == Some(4)\n+}\n+\n+#[cfg(windows)]\n+fn is_sigill(status: ExitStatus) -> bool {\n+    status.code() == Some(0xc000001d)\n+}\n+\n+#[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+#[allow(nonstandard_style)]\n+mod test {\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct f32x2(f32, f32);\n+\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct f32x4(f32, f32, f32, f32);\n+\n+    #[derive(PartialEq, Debug, Clone, Copy)]\n+    struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+\n+    pub fn main(level: &str) {\n+        unsafe {\n+            main_normal(level);\n+            main_sse(level);\n+            if level == \"sse\" {\n+                return\n+            }\n+            main_avx(level);\n+            if level == \"avx\" {\n+                return\n+            }\n+            main_avx512(level);\n+        }\n+    }\n+\n+    macro_rules! mains {\n+        ($(\n+            $(#[$attr:meta])*\n+            unsafe fn $main:ident(level: &str) {\n+                ...\n+            }\n+        )*) => ($(\n+            $(#[$attr])*\n+            unsafe fn $main(level: &str) {\n+                let m128 = f32x2(1., 2.);\n+                let m256 = f32x4(3., 4., 5., 6.);\n+                let m512 = f32x8(7., 8., 9., 10., 11., 12., 13., 14.);\n+                assert_eq!(id_sse_128(m128), m128);\n+                assert_eq!(id_sse_256(m256), m256);\n+                assert_eq!(id_sse_512(m512), m512);\n+\n+                if level == \"sse\" {\n+                    return\n+                }\n+                assert_eq!(id_avx_128(m128), m128);\n+                assert_eq!(id_avx_256(m256), m256);\n+                assert_eq!(id_avx_512(m512), m512);\n+\n+                if level == \"avx\" {\n+                    return\n+                }\n+                assert_eq!(id_avx512_128(m128), m128);\n+                assert_eq!(id_avx512_256(m256), m256);\n+                assert_eq!(id_avx512_512(m512), m512);\n+            }\n+        )*)\n+    }\n+\n+    mains! {\n+        unsafe fn main_normal(level: &str) { ... }\n+        #[target_feature(enable = \"sse2\")]\n+        unsafe fn main_sse(level: &str) { ... }\n+        #[target_feature(enable = \"avx\")]\n+        unsafe fn main_avx(level: &str) { ... }\n+        #[target_feature(enable = \"avx512bw\")]\n+        unsafe fn main_avx512(level: &str) { ... }\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_128(a: f32x2) -> f32x2 {\n+        assert_eq!(a, f32x2(1., 2.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_256(a: f32x4) -> f32x4 {\n+        assert_eq!(a, f32x4(3., 4., 5., 6.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"sse2\")]\n+    unsafe fn id_sse_512(a: f32x8) -> f32x8 {\n+        assert_eq!(a, f32x8(7., 8., 9., 10., 11., 12., 13., 14.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_128(a: f32x2) -> f32x2 {\n+        assert_eq!(a, f32x2(1., 2.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_256(a: f32x4) -> f32x4 {\n+        assert_eq!(a, f32x4(3., 4., 5., 6.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx\")]\n+    unsafe fn id_avx_512(a: f32x8) -> f32x8 {\n+        assert_eq!(a, f32x8(7., 8., 9., 10., 11., 12., 13., 14.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_128(a: f32x2) -> f32x2 {\n+        assert_eq!(a, f32x2(1., 2.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_256(a: f32x4) -> f32x4 {\n+        assert_eq!(a, f32x4(3., 4., 5., 6.));\n+        a.clone()\n+    }\n+\n+    #[target_feature(enable = \"avx512bw\")]\n+    unsafe fn id_avx512_512(a: f32x8) -> f32x8 {\n+        assert_eq!(a, f32x8(7., 8., 9., 10., 11., 12., 13., 14.));\n+        a.clone()\n+    }\n+}\n+\n+#[cfg(not(any(target_arch = \"x86\", target_arch = \"x86_64\")))]\n+mod test {\n+    pub fn main(level: &str) {}\n+}"}]}