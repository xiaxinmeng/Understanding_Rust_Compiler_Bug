{"sha": "66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2OTEwYmE2ODZlMWU4OWZmNmNmYmI0NmIzZTUzOTRiZWRiZTU1NjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-21T09:32:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-21T09:32:25Z"}, "message": "Auto merge of #55125 - RalfJung:stacked-borrows, r=oli-obk\n\nmiri engine: Hooks for basic stacked borrows\n\nr? @oli-obk", "tree": {"sha": "f7b9964b614212aeb2fcb331f19b79a0f402e023", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7b9964b614212aeb2fcb331f19b79a0f402e023"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "html_url": "https://github.com/rust-lang/rust/commit/66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "554b7874a9f720d1a1e83958f3137da4c8f3f33b", "url": "https://api.github.com/repos/rust-lang/rust/commits/554b7874a9f720d1a1e83958f3137da4c8f3f33b", "html_url": "https://github.com/rust-lang/rust/commit/554b7874a9f720d1a1e83958f3137da4c8f3f33b"}, {"sha": "3f5b55029632b840169717cd8c627191fe573553", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f5b55029632b840169717cd8c627191fe573553", "html_url": "https://github.com/rust-lang/rust/commit/3f5b55029632b840169717cd8c627191fe573553"}], "stats": {"total": 460, "additions": 312, "deletions": 148}, "files": [{"sha": "4c2b2b2d41d1ba6f36f391c9497316fc76c7a14a", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -524,7 +524,7 @@ impl<'tcx, M: fmt::Debug + Eq + Hash + Clone> AllocMap<'tcx, M> {\n }\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Allocation<Tag=()> {\n+pub struct Allocation<Tag=(),Extra=()> {\n     /// The actual bytes of the allocation.\n     /// Note that the bytes of a pointer represent the offset of the pointer\n     pub bytes: Vec<u8>,\n@@ -541,9 +541,11 @@ pub struct Allocation<Tag=()> {\n     /// Also used by codegen to determine if a static should be put into mutable memory,\n     /// which happens for `static mut` and `static` with interior mutability.\n     pub mutability: Mutability,\n+    /// Extra state for the machine.\n+    pub extra: Extra,\n }\n \n-impl<Tag> Allocation<Tag> {\n+impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n         let mut undef_mask = UndefMask::new(Size::ZERO);\n@@ -554,6 +556,7 @@ impl<Tag> Allocation<Tag> {\n             undef_mask,\n             align,\n             mutability: Mutability::Immutable,\n+            extra: Extra::default(),\n         }\n     }\n \n@@ -569,6 +572,7 @@ impl<Tag> Allocation<Tag> {\n             undef_mask: UndefMask::new(size),\n             align,\n             mutability: Mutability::Mutable,\n+            extra: Extra::default(),\n         }\n     }\n }"}, {"sha": "bc917140bbd679a7907d8ffdc54b63ba21499bc7", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -19,22 +19,19 @@ use std::collections::hash_map::Entry;\n use rustc::hir::{self, def_id::DefId};\n use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Instance, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::{self, Ty, TyCtxt, Instance, query::TyCtxtAt};\n+use rustc::ty::layout::{self, Size, LayoutOf, TyLayout};\n use rustc::ty::subst::Subst;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n \n use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n-use rustc::mir::interpret::{\n-    EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Scalar, Allocation, AllocId, ConstValue,\n-};\n use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Value,\n-    EvalContext, StackPopCleanup, MemoryKind,\n+    PlaceTy, MemPlace, OpTy, Operand, Value, Pointer, Scalar, ConstValue,\n+    EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n+    Allocation, AllocId, MemoryKind,\n     snapshot,\n };\n \n@@ -53,7 +50,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n ) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'mir, 'tcx>> {\n     debug!(\"mk_borrowck_eval_cx: {:?}\", instance);\n     let param_env = tcx.param_env(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n     // insert a stack frame so any queries have the correct substs\n     // cannot use `push_stack_frame`; if we do `const_prop` explodes\n     ecx.stack.push(interpret::Frame {\n@@ -76,7 +73,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n ) -> EvalResult<'tcx, CompileTimeEvalContext<'a, 'tcx, 'tcx>> {\n     debug!(\"mk_eval_cx: {:?}, {:?}\", instance, param_env);\n     let span = tcx.def_span(instance.def_id());\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n     let mir = ecx.load_mir(instance.def)?;\n     // insert a stack frame so any queries have the correct substs\n     ecx.push_stack_frame(\n@@ -155,7 +152,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n     let span = mir.map(|mir| mir.span).unwrap_or(span);\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), ());\n+    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n     let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n     (r, ecx)\n }\n@@ -333,16 +330,25 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n     EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n \n+impl interpret::MayLeak for ! {\n+    #[inline(always)]\n+    fn may_leak(self) -> bool {\n+        // `self` is uninhabited\n+        self\n+    }\n+}\n+\n impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     for CompileTimeInterpreter<'a, 'mir, 'tcx>\n {\n-    type MemoryData = ();\n     type MemoryKinds = !;\n+    type AllocExtra = ();\n     type PointerTag = ();\n \n-    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation<()>)>;\n+    type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n+    const ENABLE_PTR_TRACKING_HOOKS: bool = false; // we don't have no provenance\n \n     #[inline(always)]\n     fn enforce_validity(_ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {\n@@ -456,6 +462,26 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n             &ecx.stack[..],\n         )\n     }\n+\n+    #[inline(always)]\n+    fn tag_reference(\n+        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _pointee_ty: Ty<'tcx>,\n+        _pointee_size: Size,\n+        _borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Self::PointerTag> {\n+        Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn tag_dereference(\n+        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Self::PointerTag> {\n+        Ok(())\n+    }\n }\n \n /// Project to a field of a (variant of a) const"}, {"sha": "81e7a6e4373d2790f663b59048dc4080034fa96c", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -37,24 +37,35 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         kind: CastKind,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        let src_layout = src.layout;\n-        let dst_layout = dest.layout;\n         use rustc::mir::CastKind::*;\n         match kind {\n             Unsize => {\n                 self.unsize_into(src, dest)?;\n             }\n \n             Misc => {\n+                let src_layout = src.layout;\n                 let src = self.read_value(src)?;\n+\n+                let src = if M::ENABLE_PTR_TRACKING_HOOKS && src_layout.ty.is_region_ptr() {\n+                    // The only `Misc` casts on references are those creating raw pointers.\n+                    assert!(dest.layout.ty.is_unsafe_ptr());\n+                    // For the purpose of the \"ptr tag hooks\", treat this as creating\n+                    // a new, raw reference.\n+                    let place = self.ref_to_mplace(src)?;\n+                    self.create_ref(place, None)?\n+                } else {\n+                    *src\n+                };\n+\n                 if self.type_is_fat_ptr(src_layout.ty) {\n-                    match (*src, self.type_is_fat_ptr(dest.layout.ty)) {\n+                    match (src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Value::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Value::ScalarPair(..), true) => {\n                             // No change to value\n-                            self.write_value(*src, dest)?;\n+                            self.write_value(src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Value::ScalarPair(data, _), false) => {\n@@ -65,11 +76,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     match src_layout.variants {\n                         layout::Variants::Single { index } => {\n                             if let Some(def) = src_layout.ty.ty_adt_def() {\n+                                // Cast from a univariant enum\n+                                assert!(src_layout.is_zst());\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n                                 return self.write_scalar(\n-                                    Scalar::from_uint(discr_val, dst_layout.size),\n+                                    Scalar::from_uint(discr_val, dest.layout.size),\n                                     dest);\n                             }\n                         }\n@@ -85,7 +98,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             ReifyFnPointer => {\n                 // The src operand does not matter, just its type\n-                match src_layout.ty.sty {\n+                match src.layout.ty.sty {\n                     ty::FnDef(def_id, substs) => {\n                         if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                             bug!(\"reifying a fn ptr that requires \\\n@@ -117,7 +130,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             ClosureFnPointer => {\n                 // The src operand does not matter, just its type\n-                match src_layout.ty.sty {\n+                match src.layout.ty.sty {\n                     ty::Closure(def_id, substs) => {\n                         let substs = self.tcx.subst_and_normalize_erasing_regions(\n                             self.substs(),"}, {"sha": "92cc09f4867b9ea632aa81e088e9a9ec2375efa0", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 72, "deletions": 52, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -11,6 +11,7 @@\n use std::fmt::Write;\n use std::mem;\n \n+use syntax::source_map::{self, Span, DUMMY_SP};\n use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n@@ -29,8 +30,6 @@ use rustc::mir::interpret::{\n };\n use rustc_data_structures::fx::FxHashMap;\n \n-use syntax::source_map::{self, Span};\n-\n use super::{\n     Value, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n     Memory, Machine\n@@ -205,63 +204,59 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n-        memory_data: M::MemoryData,\n     ) -> Self {\n         EvalContext {\n             machine,\n             tcx,\n             param_env,\n-            memory: Memory::new(tcx, memory_data),\n+            memory: Memory::new(tcx),\n             stack: Vec::new(),\n             vtables: FxHashMap::default(),\n         }\n     }\n \n+    #[inline(always)]\n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n \n+    #[inline(always)]\n     pub fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n+    #[inline(always)]\n     pub fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag>] {\n         &self.stack\n     }\n \n-    #[inline]\n+    #[inline(always)]\n     pub fn cur_frame(&self) -> usize {\n         assert!(self.stack.len() > 0);\n         self.stack.len() - 1\n     }\n \n-    /// Mark a storage as live, killing the previous content and returning it.\n-    /// Remember to deallocate that!\n-    pub fn storage_live(\n-        &mut self,\n-        local: mir::Local\n-    ) -> EvalResult<'tcx, LocalValue<M::PointerTag>> {\n-        assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n-        trace!(\"{:?} is now live\", local);\n-\n-        let layout = self.layout_of_local(self.cur_frame(), local)?;\n-        let init = LocalValue::Live(self.uninit_operand(layout)?);\n-        // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local], init))\n+    #[inline(always)]\n+    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag> {\n+        self.stack.last().expect(\"no call frames exist\")\n     }\n \n-    /// Returns the old value of the local.\n-    /// Remember to deallocate that!\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n-        assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n-        trace!(\"{:?} is now dead\", local);\n+    #[inline(always)]\n+    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag> {\n+        self.stack.last_mut().expect(\"no call frames exist\")\n+    }\n \n-        mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n+    #[inline(always)]\n+    pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n+        self.frame().mir\n     }\n \n-    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value<M::PointerTag>> {\n-        let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n-        Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n+    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n+        if let Some(frame) = self.stack.last() {\n+            frame.instance.substs\n+        } else {\n+            Substs::empty()\n+        }\n     }\n \n     pub(super) fn resolve(\n@@ -285,10 +280,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         ).ok_or_else(|| EvalErrorKind::TooGeneric.into())\n     }\n \n-    pub(super) fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n         ty.is_sized(self.tcx, self.param_env)\n     }\n \n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+    }\n+\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -336,6 +335,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         self.layout_of(local_ty)\n     }\n \n+    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value<M::PointerTag>> {\n+        let ptr = self.memory.allocate_static_bytes(s.as_bytes());\n+        Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n+    }\n+\n     /// Return the actual dynamic size and alignment of the place at the given type.\n     /// Only the \"meta\" (metadata) part of the place matters.\n     /// This can fail to provide an answer for extern types.\n@@ -354,11 +358,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                 // and it also rounds up to alignment, which we want to avoid,\n                 // as the unsized field's alignment could be smaller.\n                 assert!(!layout.ty.is_simd());\n-                debug!(\"DST layout: {:?}\", layout);\n+                trace!(\"DST layout: {:?}\", layout);\n \n                 let sized_size = layout.fields.offset(layout.fields.count() - 1);\n                 let sized_align = layout.align;\n-                debug!(\n+                trace!(\n                     \"DST {} statically sized prefix size: {:?} align: {:?}\",\n                     layout.ty,\n                     sized_size,\n@@ -434,6 +438,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         return_place: Option<PlaceTy<'tcx, M::PointerTag>>,\n         return_to_block: StackPopCleanup,\n     ) -> EvalResult<'tcx> {\n+        if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n+            debug!(\"PAUSING({}) {}\", self.cur_frame(), self.frame().instance);\n+        }\n         ::log_settings::settings().indentation += 1;\n \n         // first push a stack frame so we have access to the local substs\n@@ -498,6 +505,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             self.frame_mut().locals = locals;\n         }\n \n+        if self.stack.len() > 1 { // FIXME no check should be needed, but some instances ICE\n+            debug!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n+        }\n+\n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n             err!(StackFrameLimitReached)\n         } else {\n@@ -506,6 +517,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n     }\n \n     pub(super) fn pop_stack_frame(&mut self) -> EvalResult<'tcx> {\n+        if self.stack.len() > 1 { // FIXME no check should be needed, but some instances ICE\n+            debug!(\"LEAVING({}) {}\", self.cur_frame(), self.frame().instance);\n+        }\n         ::log_settings::settings().indentation -= 1;\n         let frame = self.stack.pop().expect(\n             \"tried to pop a stack frame, but there were none\",\n@@ -549,9 +563,37 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             return err!(Unreachable);\n         }\n \n+        if self.stack.len() > 1 { // FIXME should be \"> 0\", printing topmost frame crashes rustc...\n+            debug!(\"CONTINUING({}) {}\", self.cur_frame(), self.frame().instance);\n+        }\n+\n         Ok(())\n     }\n \n+    /// Mark a storage as live, killing the previous content and returning it.\n+    /// Remember to deallocate that!\n+    pub fn storage_live(\n+        &mut self,\n+        local: mir::Local\n+    ) -> EvalResult<'tcx, LocalValue<M::PointerTag>> {\n+        assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n+        trace!(\"{:?} is now live\", local);\n+\n+        let layout = self.layout_of_local(self.cur_frame(), local)?;\n+        let init = LocalValue::Live(self.uninit_operand(layout)?);\n+        // StorageLive *always* kills the value that's currently stored\n+        Ok(mem::replace(&mut self.frame_mut().locals[local], init))\n+    }\n+\n+    /// Returns the old value of the local.\n+    /// Remember to deallocate that!\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue<M::PointerTag> {\n+        assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n+        trace!(\"{:?} is now dead\", local);\n+\n+        mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n+    }\n+\n     pub(super) fn deallocate_local(\n         &mut self,\n         local: LocalValue<M::PointerTag>,\n@@ -576,28 +618,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n             .map_err(|err| EvalErrorKind::ReferencedConstant(err).into())\n     }\n \n-    #[inline(always)]\n-    pub fn frame(&self) -> &Frame<'mir, 'tcx, M::PointerTag> {\n-        self.stack.last().expect(\"no call frames exist\")\n-    }\n-\n-    #[inline(always)]\n-    pub fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx, M::PointerTag> {\n-        self.stack.last_mut().expect(\"no call frames exist\")\n-    }\n-\n-    pub(super) fn mir(&self) -> &'mir mir::Mir<'tcx> {\n-        self.frame().mir\n-    }\n-\n-    pub fn substs(&self) -> &'tcx Substs<'tcx> {\n-        if let Some(frame) = self.stack.last() {\n-            frame.instance.substs\n-        } else {\n-            Substs::empty()\n-        }\n-    }\n-\n     pub fn dump_place(&self, place: Place<M::PointerTag>) {\n         // Debug output\n         if !log_enabled!(::log::Level::Trace) {"}, {"sha": "1318bbe1c2bf286d22ec255726afd7e001061f9c", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 81, "deletions": 18, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -16,11 +16,25 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::{Allocation, AllocId, EvalResult, Scalar};\n use rustc::mir;\n-use rustc::ty::{self, layout::TyLayout, query::TyCtxtAt};\n+use rustc::ty::{self, Ty, layout::{Size, TyLayout}, query::TyCtxtAt};\n+\n+use super::{\n+    Allocation, AllocId, EvalResult, Scalar,\n+    EvalContext, PlaceTy, OpTy, Pointer, MemoryKind,\n+};\n+\n+/// Classifying memory accesses\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum MemoryAccess {\n+    Read,\n+    Write,\n+}\n \n-use super::{EvalContext, PlaceTy, OpTy, MemoryKind};\n+/// Whether this kind of memory is allowed to leak\n+pub trait MayLeak: Copy {\n+    fn may_leak(self) -> bool;\n+}\n \n /// The functionality needed by memory to manage its allocations\n pub trait AllocMap<K: Hash + Eq, V> {\n@@ -62,29 +76,36 @@ pub trait AllocMap<K: Hash + Eq, V> {\n /// Methods of this trait signifies a point where CTFE evaluation would fail\n /// and some use case dependent behaviour can instead be applied.\n pub trait Machine<'a, 'mir, 'tcx>: Sized {\n-    /// Additional data that can be accessed via the Memory\n-    type MemoryData;\n-\n     /// Additional memory kinds a machine wishes to distinguish from the builtin ones\n-    type MemoryKinds: ::std::fmt::Debug + Copy + Eq;\n+    type MemoryKinds: ::std::fmt::Debug + MayLeak + Eq + 'static;\n+\n+    /// Tag tracked alongside every pointer.  This is used to implement \"Stacked Borrows\"\n+    /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n+    type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n+\n+    /// Extra data stored in every allocation.\n+    type AllocExtra: ::std::fmt::Debug + Default + Clone;\n \n     /// Memory's allocation map\n     type MemoryMap:\n-        AllocMap<AllocId, (MemoryKind<Self::MemoryKinds>, Allocation<Self::PointerTag>)> +\n+        AllocMap<\n+            AllocId,\n+            (MemoryKind<Self::MemoryKinds>, Allocation<Self::PointerTag, Self::AllocExtra>)\n+        > +\n         Default +\n         Clone;\n \n-    /// Tag tracked alongside every pointer.  This is inert for now, in preparation for\n-    /// a future implementation of \"Stacked Borrows\"\n-    /// <https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html>.\n-    type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n-\n     /// The memory kind to use for copied statics -- or None if those are not supported.\n     /// Statics are copied under two circumstances: When they are mutated, and when\n     /// `static_with_default_tag` or `find_foreign_static` (see below) returns an owned allocation\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// As an optimization, you can prevent the pointer tracking hooks from ever being\n+    /// called.  You should only do this if you do not care about provenance tracking.\n+    /// This controls the `tag_reference` and `tag_dereference` hooks.\n+    const ENABLE_PTR_TRACKING_HOOKS: bool;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool;\n \n@@ -127,7 +148,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     fn find_foreign_static(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         def_id: DefId,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>>;\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n     /// Called to turn an allocation obtained from the `tcx` into one that has\n     /// the appropriate tags on each pointer.\n@@ -138,7 +159,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// owned allocation to the map even when the map is shared.)\n     fn static_with_default_tag(\n         alloc: &'_ Allocation\n-    ) -> Cow<'_, Allocation<Self::PointerTag>>;\n+    ) -> Cow<'_, Allocation<Self::PointerTag, Self::AllocExtra>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n@@ -153,15 +174,57 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n-    /// Heap allocations via the `box` keyword\n-    ///\n-    /// Returns a pointer to the allocated memory\n+    /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n+    /// Hook for performing extra checks on a memory access.\n+    ///\n+    /// Takes read-only access to the allocation so we can keep all the memory read\n+    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// need to mutate.\n+    #[inline]\n+    fn memory_accessed(\n+        _alloc: &Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n+        _size: Size,\n+        _access: MemoryAccess,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks when memory gets deallocated.\n+    #[inline]\n+    fn memory_deallocated(\n+        _alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        _ptr: Pointer<Self::PointerTag>,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Executed when evaluating the `&` operator: Creating a new reference.\n+    /// This has the chance to adjust the tag.\n+    /// `borrow_kind` can be `None` in case a raw ptr is being created.\n+    fn tag_reference(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+        pointee_ty: Ty<'tcx>,\n+        pointee_size: Size,\n+        borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Self::PointerTag>;\n+\n+    /// Executed when evaluating the `*` operator: Following a reference.\n+    /// This has the change to adjust the tag.\n+    fn tag_dereference(\n+        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer<Self::PointerTag>,\n+        ptr_ty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx, Self::PointerTag>;\n+\n     /// Execute a validation operation\n+    #[inline]\n     fn validation_op(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         _op: ::rustc::mir::ValidationOp,"}, {"sha": "9febcceae068e60f90d4dd4b68b0b35c059b6fe1", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -22,17 +22,16 @@ use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size, HasDataLayout};\n-use rustc::mir::interpret::{\n-    Pointer, AllocId, Allocation, ConstValue, GlobalId,\n-    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n-    truncate\n-};\n-pub use rustc::mir::interpret::{write_target_uint, read_target_uint};\n+pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n \n-use super::{Machine, AllocMap, ScalarMaybeUndef};\n+use super::{\n+    Pointer, AllocId, Allocation, ConstValue, GlobalId,\n+    EvalResult, Scalar, EvalErrorKind, AllocType, PointerArithmetic,\n+    Machine, MemoryAccess, AllocMap, MayLeak, ScalarMaybeUndef,\n+};\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n pub enum MemoryKind<T> {\n@@ -44,12 +43,20 @@ pub enum MemoryKind<T> {\n     Machine(T),\n }\n \n+impl<T: MayLeak> MayLeak for MemoryKind<T> {\n+    #[inline]\n+    fn may_leak(self) -> bool {\n+        match self {\n+            MemoryKind::Stack => false,\n+            MemoryKind::Vtable => true,\n+            MemoryKind::Machine(k) => k.may_leak()\n+        }\n+    }\n+}\n+\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g. `get`) call a `Machine` hook.\n pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n-    /// Additional data required by the Machine\n-    pub data: M::MemoryData,\n-\n     /// Allocations local to this instance of the miri engine.  The kind\n     /// helps ensure that the same mechanism is used for allocation and\n     /// deallocation.  When an allocation is not found here, it is a\n@@ -91,11 +98,9 @@ impl<'a, 'b, 'c, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n // carefully copy only the reachable parts.\n impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n     Clone for Memory<'a, 'mir, 'tcx, M>\n-    where M::MemoryData: Clone\n {\n     fn clone(&self) -> Self {\n         Memory {\n-            data: self.data.clone(),\n             alloc_map: self.alloc_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n             tcx: self.tcx,\n@@ -104,9 +109,8 @@ impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n+    pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>) -> Self {\n         Memory {\n-            data,\n             alloc_map: Default::default(),\n             dead_alloc_map: FxHashMap::default(),\n             tcx,\n@@ -123,7 +127,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     pub fn allocate_with(\n         &mut self,\n-        alloc: Allocation<M::PointerTag>,\n+        alloc: Allocation<M::PointerTag, M::AllocExtra>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, AllocId> {\n         let id = self.tcx.alloc_map.lock().reserve();\n@@ -186,13 +190,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx> {\n-        debug!(\"deallocating: {}\", ptr.alloc_id);\n+        trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let (alloc_kind, alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n@@ -227,6 +231,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n+        // Let the machine take some extra action\n+        M::memory_deallocated(&mut alloc, ptr)?;\n+\n         // Don't forget to remember size and align of this now-dead allocation\n         let old = self.dead_alloc_map.insert(\n             ptr.alloc_id,\n@@ -334,7 +341,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn get_static_alloc(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag>>> {\n+    ) -> EvalResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let def_id = match alloc {\n             Some(AllocType::Memory(mem)) => {\n@@ -376,7 +383,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         })\n     }\n \n-    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::PointerTag>> {\n+    pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -409,7 +416,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn get_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> EvalResult<'tcx, &mut Allocation<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n         let tcx = self.tcx;\n         let a = self.alloc_map.get_mut_or(id, || {\n             // Need to make a copy, even if `get_static_alloc` is able\n@@ -482,12 +489,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.dump_allocs(vec![id]);\n     }\n \n-    fn dump_alloc_helper<Tag>(\n+    fn dump_alloc_helper<Tag, Extra>(\n         &self,\n         allocs_seen: &mut FxHashSet<AllocId>,\n         allocs_to_print: &mut VecDeque<AllocId>,\n         mut msg: String,\n-        alloc: &Allocation<Tag>,\n+        alloc: &Allocation<Tag, Extra>,\n         extra: String,\n     ) {\n         use std::fmt::Write;\n@@ -590,13 +597,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn leak_report(&self) -> usize {\n         trace!(\"### LEAK REPORT ###\");\n         let leaks: Vec<_> = self.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n-            // exclude statics and vtables\n-            let exclude = match kind {\n-                MemoryKind::Stack => false,\n-                MemoryKind::Vtable => true,\n-                MemoryKind::Machine(k) => Some(k) == M::STATIC_KIND,\n-            };\n-            if exclude { None } else { Some(id) }\n+            if kind.may_leak() { None } else { Some(id) }\n         });\n         let n = leaks.len();\n         self.dump_allocs(leaks);\n@@ -633,6 +634,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         let alloc = self.get(ptr.alloc_id)?;\n+        M::memory_accessed(alloc, ptr, size, MemoryAccess::Read)?;\n+\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -677,6 +680,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.clear_relocations(ptr, size)?;\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n+        M::memory_accessed(alloc, ptr, size, MemoryAccess::Write)?;\n+\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -687,8 +692,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n /// Interning (for CTFE)\n impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=()>,\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<()>)>,\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=()>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     /// mark an allocation as static and initialized, either mutable or not\n     pub fn intern_static("}, {"sha": "55037a99e0124827ce4adffb000862d856e30bcd", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -24,6 +24,8 @@ mod traits;\n mod validity;\n mod intrinsics;\n \n+pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n+\n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup, LocalValue,\n };\n@@ -32,7 +34,7 @@ pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind};\n \n-pub use self::machine::{Machine, AllocMap};\n+pub use self::machine::{Machine, AllocMap, MemoryAccess, MayLeak};\n \n pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n "}, {"sha": "af3d6948628398cb7b8134bf4fc17b6a18c6a3fb", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 41, "deletions": 18, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -144,17 +144,6 @@ impl<Tag> MemPlace<Tag> {\n         // it now must be aligned.\n         self.to_scalar_ptr_align().0.to_ptr()\n     }\n-\n-    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n-    /// This is the inverse of `ref_to_mplace`.\n-    pub fn to_ref(self) -> Value<Tag> {\n-        // We ignore the alignment of the place here -- special handling for packed structs ends\n-        // at the `&` operator.\n-        match self.meta {\n-            None => Value::Scalar(self.ptr.into()),\n-            Some(meta) => Value::ScalarPair(self.ptr.into(), meta.into()),\n-        }\n-    }\n }\n \n impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n@@ -267,25 +256,59 @@ impl<'a, 'mir, 'tcx, Tag, M> EvalContext<'a, 'mir, 'tcx, M>\n where\n     Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag>)>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n-    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n+    /// Alignment is just based on the type.  This is the inverse of `create_ref`.\n     pub fn ref_to_mplace(\n-        &self, val: ValTy<'tcx, M::PointerTag>\n+        &self,\n+        val: ValTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let ptr = match val.to_scalar_ptr()? {\n+            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n+                // Machine might want to track the `*` operator\n+                let tag = M::tag_dereference(self, ptr, val.layout.ty)?;\n+                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n+            }\n+            other => other,\n+        };\n+\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n         let align = layout.align;\n+\n         let mplace = match *val {\n-            Value::Scalar(ptr) =>\n-                MemPlace { ptr: ptr.not_undef()?, align, meta: None },\n-            Value::ScalarPair(ptr, meta) =>\n-                MemPlace { ptr: ptr.not_undef()?, align, meta: Some(meta.not_undef()?) },\n+            Value::Scalar(_) =>\n+                MemPlace { ptr, align, meta: None },\n+            Value::ScalarPair(_, meta) =>\n+                MemPlace { ptr, align, meta: Some(meta.not_undef()?) },\n         };\n         Ok(MPlaceTy { mplace, layout })\n     }\n \n+    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// This is the inverse of `ref_to_mplace`.\n+    pub fn create_ref(\n+        &mut self,\n+        place: MPlaceTy<'tcx, M::PointerTag>,\n+        borrow_kind: Option<mir::BorrowKind>,\n+    ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n+        let ptr = match place.ptr {\n+            Scalar::Ptr(ptr) if M::ENABLE_PTR_TRACKING_HOOKS => {\n+                // Machine might want to track the `&` operator\n+                let (size, _) = self.size_and_align_of_mplace(place)?\n+                    .expect(\"create_ref cannot determine size\");\n+                let tag = M::tag_reference(self, ptr, place.layout.ty, size, borrow_kind)?;\n+                Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n+            },\n+            other => other,\n+        };\n+        Ok(match place.meta {\n+            None => Value::Scalar(ptr.into()),\n+            Some(meta) => Value::ScalarPair(ptr.into(), meta.into()),\n+        })\n+    }\n+\n     /// Offset a pointer to project to a field. Unlike place_field, this is always\n     /// possible without allocating, so it can take &self. Also return the field's layout.\n     /// This supports both struct and array fields."}, {"sha": "047a0125f78af968bad83a63ec91696ed517d7f6", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -305,7 +305,7 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n     type Item = AllocationSnapshot<'a>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { bytes, relocations, undef_mask, align, mutability } = self;\n+        let Allocation { bytes, relocations, undef_mask, align, mutability, extra: () } = self;\n \n         AllocationSnapshot {\n             bytes,"}, {"sha": "1bab536e3e0f079d2d21eac24984f5c3e1a80b36", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -248,9 +248,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 )?;\n             }\n \n-            Ref(_, _, ref place) => {\n+            Ref(_, borrow_kind, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?.to_ref();\n+                let val = self.force_allocation(src)?;\n+                let val = self.create_ref(val, Some(borrow_kind))?;\n                 self.write_value(val, dest)?;\n             }\n "}, {"sha": "c759727f546c89b83e679aec7b88677fcbc0f848", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -446,7 +446,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         };\n \n         let arg = OpTy {\n-            op: Operand::Immediate(place.to_ref()),\n+            op: Operand::Immediate(self.create_ref(\n+                place,\n+                None // this is a \"raw reference\"\n+            )?),\n             layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n         };\n "}, {"sha": "a2d4eee2842c7ce7a6fc5fa31733ebf5dfdf3f74", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         ty: Ty<'tcx>,\n         poly_trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n     ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n-        debug!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n+        trace!(\"get_vtable(trait_ref={:?})\", poly_trait_ref);\n \n         let (ty, poly_trait_ref) = self.tcx.erase_regions(&(ty, poly_trait_ref));\n "}, {"sha": "38cf79d8fa0b9836fcf29422155a58a3ea1716df", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66910ba686e1e89ff6cfbb46b3e5394bedbe5564/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -163,6 +163,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     scalar_format(value), path, \"a valid unicode codepoint\");\n             },\n             ty::Float(_) | ty::Int(_) | ty::Uint(_) => {\n+                // NOTE: Keep this in sync with the array optimization for int/float\n+                // types below!\n                 let size = value.layout.size;\n                 let value = value.to_scalar_or_undef();\n                 if const_mode {\n@@ -511,6 +513,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         // This is the size in bytes of the whole array.\n                         let size = Size::from_bytes(ty_size * len);\n \n+                        // NOTE: Keep this in sync with the handling of integer and float\n+                        // types above, in `validate_primitive_type`.\n                         // In run-time mode, we accept pointers in here.  This is actually more\n                         // permissive than a per-element check would be, e.g. we accept\n                         // an &[u8] that contains a pointer even though bytewise checking would"}, {"sha": "bbb1d80703f272a5592ceeb3832a489776512251", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=66910ba686e1e89ff6cfbb46b3e5394bedbe5564", "patch": "@@ -1 +1 @@\n-Subproject commit 8b14b03368429e6ee2a8ac0e0c876505606ab1f1\n+Subproject commit bbb1d80703f272a5592ceeb3832a489776512251"}]}