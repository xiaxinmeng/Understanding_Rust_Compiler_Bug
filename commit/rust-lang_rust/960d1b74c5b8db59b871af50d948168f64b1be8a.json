{"sha": "960d1b74c5b8db59b871af50d948168f64b1be8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MGQxYjc0YzViOGRiNTliODcxYWY1MGQ5NDgxNjhmNjRiMWJlOGE=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-05-25T05:07:54Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-06-02T12:31:01Z"}, "message": "Don't allow pthread_rwlock_t to recursively lock itself\n\nThis is allowed by POSIX and can happen on glibc with processors\nthat support hardware lock elision.", "tree": {"sha": "cad7c2677c445b28a4d974e84eac926ee4916204", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cad7c2677c445b28a4d974e84eac926ee4916204"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/960d1b74c5b8db59b871af50d948168f64b1be8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/960d1b74c5b8db59b871af50d948168f64b1be8a", "html_url": "https://github.com/rust-lang/rust/commit/960d1b74c5b8db59b871af50d948168f64b1be8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/960d1b74c5b8db59b871af50d948168f64b1be8a/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73f5e65ecbcb6a0acb908b54226edfccf47eccc", "html_url": "https://github.com/rust-lang/rust/commit/d73f5e65ecbcb6a0acb908b54226edfccf47eccc"}], "stats": {"total": 61, "additions": 52, "deletions": 9}, "files": [{"sha": "72ab70aeac482515370ed5e96c396c7466d52479", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/960d1b74c5b8db59b871af50d948168f64b1be8a/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960d1b74c5b8db59b871af50d948168f64b1be8a/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=960d1b74c5b8db59b871af50d948168f64b1be8a", "patch": "@@ -11,14 +11,20 @@\n use libc;\n use cell::UnsafeCell;\n \n-pub struct RWLock { inner: UnsafeCell<libc::pthread_rwlock_t> }\n+pub struct RWLock {\n+    inner: UnsafeCell<libc::pthread_rwlock_t>,\n+    write_locked: UnsafeCell<bool>,\n+}\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER) }\n+        RWLock {\n+            inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n+            write_locked: UnsafeCell::new(false),\n+        }\n     }\n     #[inline]\n     pub unsafe fn read(&self) {\n@@ -35,37 +41,74 @@ impl RWLock {\n         //\n         // We roughly maintain the deadlocking behavior by panicking to ensure\n         // that this lock acquisition does not succeed.\n-        if r == libc::EDEADLK {\n+        //\n+        // We also check whether there this lock is already write locked. This\n+        // is only possible if it was write locked by the current thread and\n+        // the implementation allows recursive locking. The POSIX standard\n+        // doesn't require recursivly locking a rwlock to deadlock, but we can't\n+        // allow that because it could lead to aliasing issues.\n+        if r == libc::EDEADLK || *self.write_locked.get() {\n+            if r == 0 {\n+                self.raw_unlock();\n+            }\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n         }\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        libc::pthread_rwlock_tryrdlock(self.inner.get()) == 0\n+        let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n+        if r == 0 && *self.write_locked.get() {\n+            self.raw_unlock();\n+            false\n+        } else {\n+            r == 0\n+        }\n     }\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // see comments above for why we check for EDEADLK\n-        if r == libc::EDEADLK {\n+        // see comments above for why we check for EDEADLK and write_locked\n+        if r == libc::EDEADLK || *self.write_locked.get() {\n+            if r == 0 {\n+                self.raw_unlock();\n+            }\n             panic!(\"rwlock write lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n         }\n+        *self.write_locked.get() = true;\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        libc::pthread_rwlock_trywrlock(self.inner.get()) == 0\n+        let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n+        if r == 0 && *self.write_locked.get() {\n+            self.raw_unlock();\n+            false\n+        } else if r == 0 {\n+            *self.write_locked.get() = true;\n+            true\n+        } else {\n+            false\n+        }\n     }\n     #[inline]\n-    pub unsafe fn read_unlock(&self) {\n+    unsafe fn raw_unlock(&self) {\n         let r = libc::pthread_rwlock_unlock(self.inner.get());\n         debug_assert_eq!(r, 0);\n     }\n     #[inline]\n-    pub unsafe fn write_unlock(&self) { self.read_unlock() }\n+    pub unsafe fn read_unlock(&self) {\n+        debug_assert!(!*self.write_locked.get());\n+        self.raw_unlock();\n+    }\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        debug_assert!(*self.write_locked.get());\n+        *self.write_locked.get() = false;\n+        self.raw_unlock();\n+    }\n     #[inline]\n     pub unsafe fn destroy(&self) {\n         let r = libc::pthread_rwlock_destroy(self.inner.get());"}]}