{"sha": "ed54d10de6a0b330c9546ba7f7906084404efebe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNTRkMTBkZTZhMGIzMzBjOTU0NmJhN2Y3OTA2MDg0NDA0ZWZlYmU=", "commit": {"author": {"name": "chansuke", "email": "chansuke@georepublic.de", "date": "2019-06-05T15:55:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-16T10:08:09Z"}, "message": "Separate libgraphviz module", "tree": {"sha": "8ed887895c11491659a7ba04fb582befc6a4e667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ed887895c11491659a7ba04fb582befc6a4e667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed54d10de6a0b330c9546ba7f7906084404efebe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed54d10de6a0b330c9546ba7f7906084404efebe", "html_url": "https://github.com/rust-lang/rust/commit/ed54d10de6a0b330c9546ba7f7906084404efebe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed54d10de6a0b330c9546ba7f7906084404efebe/comments", "author": null, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40a0c835b512599a950f99a09dcf1685f7e1bb65", "url": "https://api.github.com/repos/rust-lang/rust/commits/40a0c835b512599a950f99a09dcf1685f7e1bb65", "html_url": "https://github.com/rust-lang/rust/commit/40a0c835b512599a950f99a09dcf1685f7e1bb65"}], "stats": {"total": 763, "additions": 381, "deletions": 382}, "files": [{"sha": "a34e4fb89ff27457ea5b21ec033438c50f21927f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 382, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/ed54d10de6a0b330c9546ba7f7906084404efebe/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed54d10de6a0b330c9546ba7f7906084404efebe/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=ed54d10de6a0b330c9546ba7f7906084404efebe", "patch": "@@ -684,385 +684,4 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n }\n \n #[cfg(test)]\n-mod tests {\n-    use NodeLabels::*;\n-    use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n-    use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n-    use std::io;\n-    use std::io::prelude::*;\n-\n-    /// each node is an index in a vector in the graph.\n-    type Node = usize;\n-    struct Edge {\n-        from: usize,\n-        to: usize,\n-        label: &'static str,\n-        style: Style,\n-    }\n-\n-    fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n-        Edge {\n-            from,\n-            to,\n-            label,\n-            style,\n-        }\n-    }\n-\n-    struct LabelledGraph {\n-        /// The name for this graph. Used for labeling generated `digraph`.\n-        name: &'static str,\n-\n-        /// Each node is an index into `node_labels`; these labels are\n-        /// used as the label text for each node. (The node *names*,\n-        /// which are unique identifiers, are derived from their index\n-        /// in this array.)\n-        ///\n-        /// If a node maps to None here, then just use its name as its\n-        /// text.\n-        node_labels: Vec<Option<&'static str>>,\n-\n-        node_styles: Vec<Style>,\n-\n-        /// Each edge relates a from-index to a to-index along with a\n-        /// label; `edges` collects them.\n-        edges: Vec<Edge>,\n-    }\n-\n-    // A simple wrapper around LabelledGraph that forces the labels to\n-    // be emitted as EscStr.\n-    struct LabelledGraphWithEscStrs {\n-        graph: LabelledGraph,\n-    }\n-\n-    enum NodeLabels<L> {\n-        AllNodesLabelled(Vec<L>),\n-        UnlabelledNodes(usize),\n-        SomeNodesLabelled(Vec<Option<L>>),\n-    }\n-\n-    type Trivial = NodeLabels<&'static str>;\n-\n-    impl NodeLabels<&'static str> {\n-        fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n-            match self {\n-                UnlabelledNodes(len) => vec![None; len],\n-                AllNodesLabelled(lbls) => lbls.into_iter().map(|l| Some(l)).collect(),\n-                SomeNodesLabelled(lbls) => lbls.into_iter().collect(),\n-            }\n-        }\n-\n-        fn len(&self) -> usize {\n-            match self {\n-                &UnlabelledNodes(len) => len,\n-                &AllNodesLabelled(ref lbls) => lbls.len(),\n-                &SomeNodesLabelled(ref lbls) => lbls.len(),\n-            }\n-        }\n-    }\n-\n-    impl LabelledGraph {\n-        fn new(name: &'static str,\n-               node_labels: Trivial,\n-               edges: Vec<Edge>,\n-               node_styles: Option<Vec<Style>>)\n-               -> LabelledGraph {\n-            let count = node_labels.len();\n-            LabelledGraph {\n-                name,\n-                node_labels: node_labels.to_opt_strs(),\n-                edges,\n-                node_styles: match node_styles {\n-                    Some(nodes) => nodes,\n-                    None => vec![Style::None; count],\n-                },\n-            }\n-        }\n-    }\n-\n-    impl LabelledGraphWithEscStrs {\n-        fn new(name: &'static str,\n-               node_labels: Trivial,\n-               edges: Vec<Edge>)\n-               -> LabelledGraphWithEscStrs {\n-            LabelledGraphWithEscStrs { graph: LabelledGraph::new(name, node_labels, edges, None) }\n-        }\n-    }\n-\n-    fn id_name<'a>(n: &Node) -> Id<'a> {\n-        Id::new(format!(\"N{}\", *n)).unwrap()\n-    }\n-\n-    impl<'a> Labeller<'a> for LabelledGraph {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name).unwrap()\n-        }\n-        fn node_id(&'a self, n: &Node) -> Id<'a> {\n-            id_name(n)\n-        }\n-        fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n-            match self.node_labels[*n] {\n-                Some(l) => LabelStr(l.into()),\n-                None => LabelStr(id_name(n).name()),\n-            }\n-        }\n-        fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n-            LabelStr(e.label.into())\n-        }\n-        fn node_style(&'a self, n: &Node) -> Style {\n-            self.node_styles[*n]\n-        }\n-        fn edge_style(&'a self, e: &&'a Edge) -> Style {\n-            e.style\n-        }\n-    }\n-\n-    impl<'a> Labeller<'a> for LabelledGraphWithEscStrs {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn graph_id(&'a self) -> Id<'a> {\n-            self.graph.graph_id()\n-        }\n-        fn node_id(&'a self, n: &Node) -> Id<'a> {\n-            self.graph.node_id(n)\n-        }\n-        fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n-            match self.graph.node_label(n) {\n-                LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n-            }\n-        }\n-        fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n-            match self.graph.edge_label(e) {\n-                LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n-            }\n-        }\n-    }\n-\n-    impl<'a> GraphWalk<'a> for LabelledGraph {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn nodes(&'a self) -> Nodes<'a, Node> {\n-            (0..self.node_labels.len()).collect()\n-        }\n-        fn edges(&'a self) -> Edges<'a, &'a Edge> {\n-            self.edges.iter().collect()\n-        }\n-        fn source(&'a self, edge: &&'a Edge) -> Node {\n-            edge.from\n-        }\n-        fn target(&'a self, edge: &&'a Edge) -> Node {\n-            edge.to\n-        }\n-    }\n-\n-    impl<'a> GraphWalk<'a> for LabelledGraphWithEscStrs {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn nodes(&'a self) -> Nodes<'a, Node> {\n-            self.graph.nodes()\n-        }\n-        fn edges(&'a self) -> Edges<'a, &'a Edge> {\n-            self.graph.edges()\n-        }\n-        fn source(&'a self, edge: &&'a Edge) -> Node {\n-            edge.from\n-        }\n-        fn target(&'a self, edge: &&'a Edge) -> Node {\n-            edge.to\n-        }\n-    }\n-\n-    fn test_input(g: LabelledGraph) -> io::Result<String> {\n-        let mut writer = Vec::new();\n-        render(&g, &mut writer).unwrap();\n-        let mut s = String::new();\n-        Read::read_to_string(&mut &*writer, &mut s)?;\n-        Ok(s)\n-    }\n-\n-    // All of the tests use raw-strings as the format for the expected outputs,\n-    // so that you can cut-and-paste the content into a .dot file yourself to\n-    // see what the graphviz visualizer would produce.\n-\n-    #[test]\n-    fn empty_graph() {\n-        let labels: Trivial = UnlabelledNodes(0);\n-        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph empty_graph {\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_node() {\n-        let labels: Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph single_node {\n-    N0[label=\"N0\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_node_with_style() {\n-        let labels: Trivial = UnlabelledNodes(1);\n-        let styles = Some(vec![Style::Dashed]);\n-        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph single_node {\n-    N0[label=\"N0\"][style=\"dashed\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_edge() {\n-        let labels: Trivial = UnlabelledNodes(2);\n-        let result = test_input(LabelledGraph::new(\"single_edge\",\n-                                                   labels,\n-                                                   vec![edge(0, 1, \"E\", Style::None)],\n-                                                   None));\n-        assert_eq!(result.unwrap(),\n-r#\"digraph single_edge {\n-    N0[label=\"N0\"];\n-    N1[label=\"N1\"];\n-    N0 -> N1[label=\"E\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_edge_with_style() {\n-        let labels: Trivial = UnlabelledNodes(2);\n-        let result = test_input(LabelledGraph::new(\"single_edge\",\n-                                                   labels,\n-                                                   vec![edge(0, 1, \"E\", Style::Bold)],\n-                                                   None));\n-        assert_eq!(result.unwrap(),\n-r#\"digraph single_edge {\n-    N0[label=\"N0\"];\n-    N1[label=\"N1\"];\n-    N0 -> N1[label=\"E\"][style=\"bold\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn test_some_labelled() {\n-        let labels: Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n-        let styles = Some(vec![Style::None, Style::Dotted]);\n-        let result = test_input(LabelledGraph::new(\"test_some_labelled\",\n-                                                   labels,\n-                                                   vec![edge(0, 1, \"A-1\", Style::None)],\n-                                                   styles));\n-        assert_eq!(result.unwrap(),\n-r#\"digraph test_some_labelled {\n-    N0[label=\"A\"];\n-    N1[label=\"N1\"][style=\"dotted\"];\n-    N0 -> N1[label=\"A-1\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_cyclic_node() {\n-        let labels: Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_cyclic_node\",\n-                                              labels,\n-                                              vec![edge(0, 0, \"E\", Style::None)],\n-                                              None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph single_cyclic_node {\n-    N0[label=\"N0\"];\n-    N0 -> N0[label=\"E\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn hasse_diagram() {\n-        let labels = AllNodesLabelled(vec![\"{x,y}\", \"{x}\", \"{y}\", \"{}\"]);\n-        let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n-                                              labels,\n-                                              vec![edge(0, 1, \"\", Style::None),\n-                                                   edge(0, 2, \"\", Style::None),\n-                                                   edge(1, 3, \"\", Style::None),\n-                                                   edge(2, 3, \"\", Style::None)],\n-                                              None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph hasse_diagram {\n-    N0[label=\"{x,y}\"];\n-    N1[label=\"{x}\"];\n-    N2[label=\"{y}\"];\n-    N3[label=\"{}\"];\n-    N0 -> N1[label=\"\"];\n-    N0 -> N2[label=\"\"];\n-    N1 -> N3[label=\"\"];\n-    N2 -> N3[label=\"\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn left_aligned_text() {\n-        let labels = AllNodesLabelled(vec![\n-            \"if test {\\\n-           \\\\l    branch1\\\n-           \\\\l} else {\\\n-           \\\\l    branch2\\\n-           \\\\l}\\\n-           \\\\lafterward\\\n-           \\\\l\",\n-            \"branch1\",\n-            \"branch2\",\n-            \"afterward\"]);\n-\n-        let mut writer = Vec::new();\n-\n-        let g = LabelledGraphWithEscStrs::new(\"syntax_tree\",\n-                                              labels,\n-                                              vec![edge(0, 1, \"then\", Style::None),\n-                                                   edge(0, 2, \"else\", Style::None),\n-                                                   edge(1, 3, \";\", Style::None),\n-                                                   edge(2, 3, \";\", Style::None)]);\n-\n-        render(&g, &mut writer).unwrap();\n-        let mut r = String::new();\n-        Read::read_to_string(&mut &*writer, &mut r).unwrap();\n-\n-        assert_eq!(r,\n-r#\"digraph syntax_tree {\n-    N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n-    N1[label=\"branch1\"];\n-    N2[label=\"branch2\"];\n-    N3[label=\"afterward\"];\n-    N0 -> N1[label=\"then\"];\n-    N0 -> N2[label=\"else\"];\n-    N1 -> N3[label=\";\"];\n-    N2 -> N3[label=\";\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn simple_id_construction() {\n-        let id1 = Id::new(\"hello\");\n-        match id1 {\n-            Ok(_) => {}\n-            Err(..) => panic!(\"'hello' is not a valid value for id anymore\"),\n-        }\n-    }\n-\n-    #[test]\n-    fn badly_formatted_id() {\n-        let id2 = Id::new(\"Weird { struct : ure } !!!\");\n-        match id2 {\n-            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            Err(..) => {}\n-        }\n-    }\n-}\n+mod tests;"}, {"sha": "2f713579b17fa0416204f8b0d5abc971d1494f91", "filename": "src/libgraphviz/tests.rs", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/ed54d10de6a0b330c9546ba7f7906084404efebe/src%2Flibgraphviz%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed54d10de6a0b330c9546ba7f7906084404efebe/src%2Flibgraphviz%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Ftests.rs?ref=ed54d10de6a0b330c9546ba7f7906084404efebe", "patch": "@@ -0,0 +1,380 @@\n+use NodeLabels::*;\n+use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n+use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n+use std::io;\n+use std::io::prelude::*;\n+\n+/// each node is an index in a vector in the graph.\n+type Node = usize;\n+struct Edge {\n+    from: usize,\n+    to: usize,\n+    label: &'static str,\n+    style: Style,\n+}\n+\n+fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n+    Edge {\n+        from,\n+        to,\n+        label,\n+        style,\n+    }\n+}\n+\n+struct LabelledGraph {\n+    /// The name for this graph. Used for labeling generated `digraph`.\n+    name: &'static str,\n+\n+    /// Each node is an index into `node_labels`; these labels are\n+    /// used as the label text for each node. (The node *names*,\n+    /// which are unique identifiers, are derived from their index\n+    /// in this array.)\n+    ///\n+    /// If a node maps to None here, then just use its name as its\n+    /// text.\n+    node_labels: Vec<Option<&'static str>>,\n+\n+    node_styles: Vec<Style>,\n+\n+    /// Each edge relates a from-index to a to-index along with a\n+    /// label; `edges` collects them.\n+    edges: Vec<Edge>,\n+}\n+\n+// A simple wrapper around LabelledGraph that forces the labels to\n+// be emitted as EscStr.\n+struct LabelledGraphWithEscStrs {\n+    graph: LabelledGraph,\n+}\n+\n+enum NodeLabels<L> {\n+    AllNodesLabelled(Vec<L>),\n+    UnlabelledNodes(usize),\n+    SomeNodesLabelled(Vec<Option<L>>),\n+}\n+\n+type Trivial = NodeLabels<&'static str>;\n+\n+impl NodeLabels<&'static str> {\n+    fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n+        match self {\n+            UnlabelledNodes(len) => vec![None; len],\n+            AllNodesLabelled(lbls) => lbls.into_iter().map(|l| Some(l)).collect(),\n+            SomeNodesLabelled(lbls) => lbls.into_iter().collect(),\n+        }\n+    }\n+\n+    fn len(&self) -> usize {\n+        match self {\n+            &UnlabelledNodes(len) => len,\n+            &AllNodesLabelled(ref lbls) => lbls.len(),\n+            &SomeNodesLabelled(ref lbls) => lbls.len(),\n+        }\n+    }\n+}\n+\n+impl LabelledGraph {\n+    fn new(name: &'static str,\n+           node_labels: Trivial,\n+           edges: Vec<Edge>,\n+           node_styles: Option<Vec<Style>>)\n+           -> LabelledGraph {\n+        let count = node_labels.len();\n+        LabelledGraph {\n+            name,\n+            node_labels: node_labels.to_opt_strs(),\n+            edges,\n+            node_styles: match node_styles {\n+                Some(nodes) => nodes,\n+                None => vec![Style::None; count],\n+            },\n+        }\n+    }\n+}\n+\n+impl LabelledGraphWithEscStrs {\n+    fn new(name: &'static str,\n+           node_labels: Trivial,\n+           edges: Vec<Edge>)\n+           -> LabelledGraphWithEscStrs {\n+        LabelledGraphWithEscStrs { graph: LabelledGraph::new(name, node_labels, edges, None) }\n+    }\n+}\n+\n+fn id_name<'a>(n: &Node) -> Id<'a> {\n+    Id::new(format!(\"N{}\", *n)).unwrap()\n+}\n+\n+impl<'a> Labeller<'a> for LabelledGraph {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn graph_id(&'a self) -> Id<'a> {\n+        Id::new(self.name).unwrap()\n+    }\n+    fn node_id(&'a self, n: &Node) -> Id<'a> {\n+        id_name(n)\n+    }\n+    fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n+        match self.node_labels[*n] {\n+            Some(l) => LabelStr(l.into()),\n+            None => LabelStr(id_name(n).name()),\n+        }\n+    }\n+    fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n+        LabelStr(e.label.into())\n+    }\n+    fn node_style(&'a self, n: &Node) -> Style {\n+        self.node_styles[*n]\n+    }\n+    fn edge_style(&'a self, e: &&'a Edge) -> Style {\n+        e.style\n+    }\n+}\n+\n+impl<'a> Labeller<'a> for LabelledGraphWithEscStrs {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn graph_id(&'a self) -> Id<'a> {\n+        self.graph.graph_id()\n+    }\n+    fn node_id(&'a self, n: &Node) -> Id<'a> {\n+        self.graph.node_id(n)\n+    }\n+    fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n+        match self.graph.node_label(n) {\n+            LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n+        }\n+    }\n+    fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n+        match self.graph.edge_label(e) {\n+            LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n+        }\n+    }\n+}\n+\n+impl<'a> GraphWalk<'a> for LabelledGraph {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn nodes(&'a self) -> Nodes<'a, Node> {\n+        (0..self.node_labels.len()).collect()\n+    }\n+    fn edges(&'a self) -> Edges<'a, &'a Edge> {\n+        self.edges.iter().collect()\n+    }\n+    fn source(&'a self, edge: &&'a Edge) -> Node {\n+        edge.from\n+    }\n+    fn target(&'a self, edge: &&'a Edge) -> Node {\n+        edge.to\n+    }\n+}\n+\n+impl<'a> GraphWalk<'a> for LabelledGraphWithEscStrs {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn nodes(&'a self) -> Nodes<'a, Node> {\n+        self.graph.nodes()\n+    }\n+    fn edges(&'a self) -> Edges<'a, &'a Edge> {\n+        self.graph.edges()\n+    }\n+    fn source(&'a self, edge: &&'a Edge) -> Node {\n+        edge.from\n+    }\n+    fn target(&'a self, edge: &&'a Edge) -> Node {\n+        edge.to\n+    }\n+}\n+\n+fn test_input(g: LabelledGraph) -> io::Result<String> {\n+    let mut writer = Vec::new();\n+    render(&g, &mut writer).unwrap();\n+    let mut s = String::new();\n+    Read::read_to_string(&mut &*writer, &mut s)?;\n+    Ok(s)\n+}\n+\n+// All of the tests use raw-strings as the format for the expected outputs,\n+// so that you can cut-and-paste the content into a .dot file yourself to\n+// see what the graphviz visualizer would produce.\n+\n+#[test]\n+fn empty_graph() {\n+    let labels: Trivial = UnlabelledNodes(0);\n+    let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph empty_graph {\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_node() {\n+    let labels: Trivial = UnlabelledNodes(1);\n+    let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_node_with_style() {\n+    let labels: Trivial = UnlabelledNodes(1);\n+    let styles = Some(vec![Style::Dashed]);\n+    let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"][style=\"dashed\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_edge() {\n+    let labels: Trivial = UnlabelledNodes(2);\n+    let result = test_input(LabelledGraph::new(\"single_edge\",\n+                                               labels,\n+                                               vec![edge(0, 1, \"E\", Style::None)],\n+                                               None));\n+    assert_eq!(result.unwrap(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_edge_with_style() {\n+    let labels: Trivial = UnlabelledNodes(2);\n+    let result = test_input(LabelledGraph::new(\"single_edge\",\n+                                               labels,\n+                                               vec![edge(0, 1, \"E\", Style::Bold)],\n+                                               None));\n+    assert_eq!(result.unwrap(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"][style=\"bold\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn test_some_labelled() {\n+    let labels: Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n+    let styles = Some(vec![Style::None, Style::Dotted]);\n+    let result = test_input(LabelledGraph::new(\"test_some_labelled\",\n+                                               labels,\n+                                               vec![edge(0, 1, \"A-1\", Style::None)],\n+                                               styles));\n+    assert_eq!(result.unwrap(),\n+r#\"digraph test_some_labelled {\n+    N0[label=\"A\"];\n+    N1[label=\"N1\"][style=\"dotted\"];\n+    N0 -> N1[label=\"A-1\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_cyclic_node() {\n+    let labels: Trivial = UnlabelledNodes(1);\n+    let r = test_input(LabelledGraph::new(\"single_cyclic_node\",\n+                                          labels,\n+                                          vec![edge(0, 0, \"E\", Style::None)],\n+                                          None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph single_cyclic_node {\n+    N0[label=\"N0\"];\n+    N0 -> N0[label=\"E\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn hasse_diagram() {\n+    let labels = AllNodesLabelled(vec![\"{x,y}\", \"{x}\", \"{y}\", \"{}\"]);\n+    let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n+                                          labels,\n+                                          vec![edge(0, 1, \"\", Style::None),\n+                                               edge(0, 2, \"\", Style::None),\n+                                               edge(1, 3, \"\", Style::None),\n+                                               edge(2, 3, \"\", Style::None)],\n+                                          None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph hasse_diagram {\n+    N0[label=\"{x,y}\"];\n+    N1[label=\"{x}\"];\n+    N2[label=\"{y}\"];\n+    N3[label=\"{}\"];\n+    N0 -> N1[label=\"\"];\n+    N0 -> N2[label=\"\"];\n+    N1 -> N3[label=\"\"];\n+    N2 -> N3[label=\"\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn left_aligned_text() {\n+    let labels = AllNodesLabelled(vec![\n+        \"if test {\\\n+       \\\\l    branch1\\\n+       \\\\l} else {\\\n+       \\\\l    branch2\\\n+       \\\\l}\\\n+       \\\\lafterward\\\n+       \\\\l\",\n+        \"branch1\",\n+        \"branch2\",\n+        \"afterward\"]);\n+\n+    let mut writer = Vec::new();\n+\n+    let g = LabelledGraphWithEscStrs::new(\"syntax_tree\",\n+                                          labels,\n+                                          vec![edge(0, 1, \"then\", Style::None),\n+                                               edge(0, 2, \"else\", Style::None),\n+                                               edge(1, 3, \";\", Style::None),\n+                                               edge(2, 3, \";\", Style::None)]);\n+\n+    render(&g, &mut writer).unwrap();\n+    let mut r = String::new();\n+    Read::read_to_string(&mut &*writer, &mut r).unwrap();\n+\n+    assert_eq!(r,\n+r#\"digraph syntax_tree {\n+    N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n+    N1[label=\"branch1\"];\n+    N2[label=\"branch2\"];\n+    N3[label=\"afterward\"];\n+    N0 -> N1[label=\"then\"];\n+    N0 -> N2[label=\"else\"];\n+    N1 -> N3[label=\";\"];\n+    N2 -> N3[label=\";\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn simple_id_construction() {\n+    let id1 = Id::new(\"hello\");\n+    match id1 {\n+        Ok(_) => {}\n+        Err(..) => panic!(\"'hello' is not a valid value for id anymore\"),\n+    }\n+}\n+\n+#[test]\n+fn badly_formatted_id() {\n+    let id2 = Id::new(\"Weird { struct : ure } !!!\");\n+    match id2 {\n+        Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+        Err(..) => {}\n+    }\n+}"}]}