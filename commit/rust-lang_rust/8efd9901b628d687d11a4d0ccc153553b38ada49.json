{"sha": "8efd9901b628d687d11a4d0ccc153553b38ada49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlZmQ5OTAxYjYyOGQ2ODdkMTFhNGQwY2NjMTUzNTUzYjM4YWRhNDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-06T13:30:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-06T13:30:29Z"}, "message": "auto merge of #20573 : huonw/rust/num-stab-2, r=alexcrichton\n\ncc #19260 \r\n\r\nOpen questions:\r\n\r\n- I still feel weird about marking functions like `exp` as `#[stable]` in `core` since they're highly likely to call into libm which is theoretically something core is designed to avoid and so we may be forced/want to move it at some point in the future, and so it feels like a lie to call it `#[stable]` (I know `core` is `#[experimental]`, but still...)\r\n- `abs_sub` is a horrible name IMO: it feels like it is `(a - b).abs()`, but it is actually `(a - b).max(0.)`. maybe something along the lines of `pos_diff` (\"positive difference\") is better.\r\n- the associated-function nature of `Int::from_be` and `Int::from_le` feel strange to me, it feels like they should be methods, but I cannot think of a good name.\r\n\r\nI'm also not hugely in favour of `ldexp` and `frexp` but the precedent from C is large. (e.g. AFAICT,  `ldexp` must mean \"load exponent\" which is essentially what it does... but only for a subset of its inputs.)", "tree": {"sha": "f6b1a31cdbbc5a5873b0b7d549f4842ddf888a83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f6b1a31cdbbc5a5873b0b7d549f4842ddf888a83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8efd9901b628d687d11a4d0ccc153553b38ada49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8efd9901b628d687d11a4d0ccc153553b38ada49", "html_url": "https://github.com/rust-lang/rust/commit/8efd9901b628d687d11a4d0ccc153553b38ada49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8efd9901b628d687d11a4d0ccc153553b38ada49/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "340ac040f7603e169a3739c65956ed2213622be5", "url": "https://api.github.com/repos/rust-lang/rust/commits/340ac040f7603e169a3739c65956ed2213622be5", "html_url": "https://github.com/rust-lang/rust/commit/340ac040f7603e169a3739c65956ed2213622be5"}, {"sha": "f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770", "html_url": "https://github.com/rust-lang/rust/commit/f3a80ab9d2f6ce61c4b7500fb23f4c6f59175770"}], "stats": {"total": 653, "additions": 570, "deletions": 83}, "files": [{"sha": "f8a85e788e9e57e41466a5cf4eb9a6b85f9df7f2", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -22,12 +22,12 @@ use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const RADIX: uint = 2u;\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MANTISSA_DIGITS: uint = 24u;\n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const DIGITS: uint = 6u;\n \n #[stable]\n@@ -43,14 +43,14 @@ pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n #[stable]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MIN_EXP: int = -125;\n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MAX_EXP: int = 128;\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MIN_10_EXP: int = -37;\n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MAX_10_EXP: int = 38;\n \n #[stable]\n@@ -177,33 +177,43 @@ impl Float for f32 {\n     }\n \n     #[inline]\n+    #[deprecated]\n     fn mantissa_digits(_: Option<f32>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n+    #[deprecated]\n     fn digits(_: Option<f32>) -> uint { DIGITS }\n \n     #[inline]\n+    #[deprecated]\n     fn epsilon() -> f32 { EPSILON }\n \n     #[inline]\n+    #[deprecated]\n     fn min_exp(_: Option<f32>) -> int { MIN_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn max_exp(_: Option<f32>) -> int { MAX_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn min_10_exp(_: Option<f32>) -> int { MIN_10_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn max_10_exp(_: Option<f32>) -> int { MAX_10_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn min_value() -> f32 { MIN_VALUE }\n \n     #[inline]\n+    #[deprecated]\n     fn min_pos_value(_: Option<f32>) -> f32 { MIN_POS_VALUE }\n \n     #[inline]\n+    #[deprecated]\n     fn max_value() -> f32 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "840428179cdce6b2664b44e38d330cfe7025ba38", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -26,12 +26,11 @@ use option::Option;\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const RADIX: uint = 2u;\n \n-#[stable]\n pub const MANTISSA_DIGITS: uint = 53u;\n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const DIGITS: uint = 15u;\n \n #[stable]\n@@ -47,14 +46,14 @@ pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n #[stable]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MIN_EXP: int = -1021;\n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MAX_EXP: int = 1024;\n \n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MIN_10_EXP: int = -307;\n-#[stable]\n+#[unstable = \"pending integer conventions\"]\n pub const MAX_10_EXP: int = 308;\n \n #[stable]\n@@ -185,33 +184,43 @@ impl Float for f64 {\n     }\n \n     #[inline]\n+    #[deprecated]\n     fn mantissa_digits(_: Option<f64>) -> uint { MANTISSA_DIGITS }\n \n     #[inline]\n+    #[deprecated]\n     fn digits(_: Option<f64>) -> uint { DIGITS }\n \n     #[inline]\n+    #[deprecated]\n     fn epsilon() -> f64 { EPSILON }\n \n     #[inline]\n+    #[deprecated]\n     fn min_exp(_: Option<f64>) -> int { MIN_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn max_exp(_: Option<f64>) -> int { MAX_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn min_10_exp(_: Option<f64>) -> int { MIN_10_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn max_10_exp(_: Option<f64>) -> int { MAX_10_EXP }\n \n     #[inline]\n+    #[deprecated]\n     fn min_value() -> f64 { MIN_VALUE }\n \n     #[inline]\n+    #[deprecated]\n     fn min_pos_value(_: Option<f64>) -> f64 { MIN_POS_VALUE }\n \n     #[inline]\n+    #[deprecated]\n     fn max_value() -> f64 { MAX_VALUE }\n \n     /// Returns the mantissa, exponent and sign as integers."}, {"sha": "192d6063f6bbc520b72256c601523b98230bcd59", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 66, "deletions": 27, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -30,7 +30,7 @@ use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n \n /// A built-in signed or unsigned integer.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[stable]\n pub trait Int\n     : Copy + Clone\n     + NumCast\n@@ -50,18 +50,22 @@ pub trait Int\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn zero() -> Self;\n \n     /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn one() -> Self;\n \n     /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn min_value() -> Self;\n \n     /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n+    #[unstable = \"unsure about its place in the world\"]\n     fn max_value() -> Self;\n \n     /// Returns the number of ones in the binary representation of `self`.\n@@ -75,6 +79,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn count_ones(self) -> uint;\n \n     /// Returns the number of zeros in the binary representation of `self`.\n@@ -88,6 +93,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     #[inline]\n     fn count_zeros(self) -> uint {\n         (!self).count_ones()\n@@ -105,6 +111,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn leading_zeros(self) -> uint;\n \n     /// Returns the number of trailing zeros in the binary representation\n@@ -119,6 +126,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn trailing_zeros(self) -> uint;\n \n     /// Shifts the bits to the left by a specified amount amount, `n`, wrapping\n@@ -134,6 +142,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn rotate_left(self, n: uint) -> Self;\n \n     /// Shifts the bits to the right by a specified amount amount, `n`, wrapping\n@@ -149,6 +158,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     fn rotate_right(self, n: uint) -> Self;\n \n     /// Reverses the byte order of the integer.\n@@ -163,6 +173,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.swap_bytes(), m);\n     /// ```\n+    #[stable]\n     fn swap_bytes(self) -> Self;\n \n     /// Convert an integer from big endian to the target's endianness.\n@@ -182,6 +193,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_be(n), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn from_be(x: Self) -> Self {\n         if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n@@ -204,6 +216,7 @@ pub trait Int\n     ///     assert_eq!(Int::from_le(n), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn from_le(x: Self) -> Self {\n         if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n@@ -226,6 +239,7 @@ pub trait Int\n     ///     assert_eq!(n.to_be(), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn to_be(self) -> Self { // or not to be?\n         if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n@@ -248,6 +262,7 @@ pub trait Int\n     ///     assert_eq!(n.to_le(), n.swap_bytes())\n     /// }\n     /// ```\n+    #[stable]\n     #[inline]\n     fn to_le(self) -> Self {\n         if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n@@ -264,6 +279,7 @@ pub trait Int\n     /// assert_eq!(5u16.checked_add(65530), Some(65535));\n     /// assert_eq!(6u16.checked_add(65530), None);\n     /// ```\n+    #[stable]\n     fn checked_add(self, other: Self) -> Option<Self>;\n \n     /// Checked integer subtraction. Computes `self - other`, returning `None`\n@@ -277,6 +293,7 @@ pub trait Int\n     /// assert_eq!((-127i8).checked_sub(1), Some(-128));\n     /// assert_eq!((-128i8).checked_sub(1), None);\n     /// ```\n+    #[stable]\n     fn checked_sub(self, other: Self) -> Option<Self>;\n \n     /// Checked integer multiplication. Computes `self * other`, returning\n@@ -290,6 +307,7 @@ pub trait Int\n     /// assert_eq!(5u8.checked_mul(51), Some(255));\n     /// assert_eq!(5u8.checked_mul(52), None);\n     /// ```\n+    #[stable]\n     fn checked_mul(self, other: Self) -> Option<Self>;\n \n     /// Checked integer division. Computes `self / other`, returning `None` if\n@@ -304,11 +322,12 @@ pub trait Int\n     /// assert_eq!((-128i8).checked_div(-1), None);\n     /// assert_eq!((1i8).checked_div(0), None);\n     /// ```\n-    #[inline]\n+    #[stable]\n     fn checked_div(self, other: Self) -> Option<Self>;\n \n     /// Saturating integer addition. Computes `self + other`, saturating at\n     /// the numeric bounds instead of overflowing.\n+    #[stable]\n     #[inline]\n     fn saturating_add(self, other: Self) -> Self {\n         match self.checked_add(other) {\n@@ -320,6 +339,7 @@ pub trait Int\n \n     /// Saturating integer subtraction. Computes `self - other`, saturating at\n     /// the numeric bounds instead of overflowing.\n+    #[stable]\n     #[inline]\n     fn saturating_sub(self, other: Self) -> Self {\n         match self.checked_sub(other) {\n@@ -338,6 +358,7 @@ pub trait Int\n     ///\n     /// assert_eq!(2i.pow(4), 16);\n     /// ```\n+    #[unstable = \"pending integer conventions\"]\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {\n         let mut base = self;\n@@ -369,7 +390,7 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[unstable = \"trait is unstable\"]\n+        #[stable]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -500,7 +521,7 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n-        #[unstable = \"trait is unstable\"]\n+        #[stable]\n         impl Int for $T {\n             #[inline]\n             fn zero() -> $T { 0 }\n@@ -593,33 +614,38 @@ int_impl! { int = i64, u64, 64,\n     intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[stable]\n pub trait SignedInt\n     : Int\n     + Neg<Output=Self>\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n+    #[unstable = \"overflow in debug builds?\"]\n     fn abs(self) -> Self;\n \n     /// Returns a number representing sign of `self`.\n     ///\n     /// - `0` if the number is zero\n     /// - `1` if the number is positive\n     /// - `-1` if the number is negative\n+    #[stable]\n     fn signum(self) -> Self;\n \n     /// Returns `true` if `self` is positive and `false` if the number\n     /// is zero or negative.\n+    #[stable]\n     fn is_positive(self) -> bool;\n \n     /// Returns `true` if `self` is negative and `false` if the number\n     /// is zero or positive.\n+    #[stable]\n     fn is_negative(self) -> bool;\n }\n \n macro_rules! signed_int_impl {\n     ($T:ty) => {\n+        #[stable]\n         impl SignedInt for $T {\n             #[inline]\n             fn abs(self) -> $T {\n@@ -651,16 +677,18 @@ signed_int_impl! { i64 }\n signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[stable]\n pub trait UnsignedInt: Int {\n     /// Returns `true` iff `self == 2^k` for some `k`.\n+    #[stable]\n     #[inline]\n     fn is_power_of_two(self) -> bool {\n         (self - Int::one()) & self == Int::zero() && !(self == Int::zero())\n     }\n \n     /// Returns the smallest power of two greater than or equal to `self`.\n     /// Unspecified behavior on overflow.\n+    #[stable]\n     #[inline]\n     fn next_power_of_two(self) -> Self {\n         let bits = size_of::<Self>() * 8;\n@@ -671,6 +699,7 @@ pub trait UnsignedInt: Int {\n     /// Returns the smallest power of two greater than or equal to `n`. If the\n     /// next power of two is greater than the type's maximum value, `None` is\n     /// returned, otherwise the power of two is wrapped in `Some`.\n+    #[stable]\n     fn checked_next_power_of_two(self) -> Option<Self> {\n         let npot = self.next_power_of_two();\n         if npot >= self {\n@@ -681,19 +710,19 @@ pub trait UnsignedInt: Int {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for uint {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u8 {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u16 {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u32 {}\n \n-#[unstable = \"trait is unstable\"]\n+#[stable]\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number.\n@@ -910,12 +939,12 @@ impl_to_primitive_uint! { u32 }\n impl_to_primitive_uint! { u64 }\n \n macro_rules! impl_to_primitive_float_to_float {\n-    ($SrcT:ty, $DstT:ty, $slf:expr) => (\n+    ($SrcT:ident, $DstT:ident, $slf:expr) => (\n         if size_of::<$SrcT>() <= size_of::<$DstT>() {\n             Some($slf as $DstT)\n         } else {\n             let n = $slf as f64;\n-            let max_value: $SrcT = Float::max_value();\n+            let max_value: $SrcT = ::$SrcT::MAX_VALUE;\n             if -max_value as f64 <= n && n <= max_value as f64 {\n                 Some($slf as $DstT)\n             } else {\n@@ -926,7 +955,7 @@ macro_rules! impl_to_primitive_float_to_float {\n }\n \n macro_rules! impl_to_primitive_float {\n-    ($T:ty) => (\n+    ($T:ident) => (\n         impl ToPrimitive for $T {\n             #[inline]\n             fn to_int(&self) -> Option<int> { Some(*self as int) }\n@@ -1222,7 +1251,7 @@ pub enum FpCategory {\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable = \"recently settled as part of numerics reform\"]\n+#[unstable = \"distribution of methods between core/std is unclear\"]\n pub trait Float\n     : Copy + Clone\n     + NumCast\n@@ -1248,41 +1277,51 @@ pub trait Float\n     /// Returns the `1` value.\n     fn one() -> Self;\n \n-    /// Returns true if this value is NaN and false otherwise.\n-    fn is_nan(self) -> bool;\n-    /// Returns true if this value is positive infinity or negative infinity and\n-    /// false otherwise.\n-    fn is_infinite(self) -> bool;\n-    /// Returns true if this number is neither infinite nor NaN.\n-    fn is_finite(self) -> bool;\n-    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    fn is_normal(self) -> bool;\n-    /// Returns the category that this number falls into.\n-    fn classify(self) -> FpCategory;\n-\n     // FIXME (#5527): These should be associated constants\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n+    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n     /// Returns the number of base-10 digits of precision that this type supports.\n+    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n     fn digits(unused_self: Option<Self>) -> uint;\n     /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n+    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n     fn epsilon() -> Self;\n     /// Returns the minimum binary exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n     fn min_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum binary exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n     fn max_exp(unused_self: Option<Self>) -> int;\n     /// Returns the minimum base-10 exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the maximum base-10 exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n     /// Returns the smallest finite value that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_VALUE` or `std::f64::MIN_VALUE` as appropriate\"]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_POS_VALUE` or `std::f64::MIN_POS_VALUE` as appropriate\"]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_VALUE` or `std::f64::MAX_VALUE` as appropriate\"]\n     fn max_value() -> Self;\n \n+    /// Returns true if this value is NaN and false otherwise.\n+    fn is_nan(self) -> bool;\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    fn is_infinite(self) -> bool;\n+    /// Returns true if this number is neither infinite nor NaN.\n+    fn is_finite(self) -> bool;\n+    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    fn is_normal(self) -> bool;\n+    /// Returns the category that this number falls into.\n+    fn classify(self) -> FpCategory;\n+\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n "}, {"sha": "0a1c17fab471e485c598df3c6749230349e25ec8", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 126, "deletions": 12, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -19,12 +19,14 @@ use prelude::v1::*;\n \n use intrinsics;\n use libc::c_int;\n-use num::{Float, FloatMath};\n+use num::{Float, FpCategory};\n use num::strconv;\n use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n use num::strconv::SignFormat::SignNeg;\n \n+use core::num;\n+\n pub use core::f32::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f32::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f32::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n@@ -71,8 +73,120 @@ mod cmath {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl FloatMath for f32 {\n+#[stable]\n+impl Float for f32 {\n+    #[inline]\n+    fn nan() -> f32 { num::Float::nan() }\n+    #[inline]\n+    fn infinity() -> f32 { num::Float::infinity() }\n+    #[inline]\n+    fn neg_infinity() -> f32 { num::Float::neg_infinity() }\n+    #[inline]\n+    fn zero() -> f32 { num::Float::zero() }\n+    #[inline]\n+    fn neg_zero() -> f32 { num::Float::neg_zero() }\n+    #[inline]\n+    fn one() -> f32 { num::Float::one() }\n+\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn mantissa_digits(unused_self: Option<f32>) -> uint {\n+        num::Float::mantissa_digits(unused_self)\n+    }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn digits(unused_self: Option<f32>) -> uint { num::Float::digits(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn epsilon() -> f32 { num::Float::epsilon() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_exp(unused_self: Option<f32>) -> int { num::Float::min_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_exp(unused_self: Option<f32>) -> int { num::Float::max_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_10_exp(unused_self: Option<f32>) -> int { num::Float::min_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_10_exp(unused_self: Option<f32>) -> int { num::Float::max_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_value() -> f32 { num::Float::min_value() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_pos_value(unused_self: Option<f32>) -> f32 { num::Float::min_pos_value(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_value() -> f32 { num::Float::max_value() }\n+\n+    #[inline]\n+    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n+    #[inline]\n+    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n+    #[inline]\n+    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n+    #[inline]\n+    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n+    #[inline]\n+    fn classify(self) -> FpCategory { num::Float::classify(self) }\n+\n+    #[inline]\n+    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n+\n+    #[inline]\n+    fn floor(self) -> f32 { num::Float::floor(self) }\n+    #[inline]\n+    fn ceil(self) -> f32 { num::Float::ceil(self) }\n+    #[inline]\n+    fn round(self) -> f32 { num::Float::round(self) }\n+    #[inline]\n+    fn trunc(self) -> f32 { num::Float::trunc(self) }\n+    #[inline]\n+    fn fract(self) -> f32 { num::Float::fract(self) }\n+\n+    #[inline]\n+    fn abs(self) -> f32 { num::Float::abs(self) }\n+    #[inline]\n+    fn signum(self) -> f32 { num::Float::signum(self) }\n+    #[inline]\n+    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n+    #[inline]\n+    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n+\n+    #[inline]\n+    fn mul_add(self, a: f32, b: f32) -> f32 { num::Float::mul_add(self, a, b) }\n+    #[inline]\n+    fn recip(self) -> f32 { num::Float::recip(self) }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f32 { num::Float::powi(self, n) }\n+    #[inline]\n+    fn powf(self, n: f32) -> f32 { num::Float::powf(self, n) }\n+\n+    #[inline]\n+    fn sqrt(self) -> f32 { num::Float::sqrt(self) }\n+    #[inline]\n+    fn rsqrt(self) -> f32 { num::Float::rsqrt(self) }\n+\n+    #[inline]\n+    fn exp(self) -> f32 { num::Float::exp(self) }\n+    #[inline]\n+    fn exp2(self) -> f32 { num::Float::exp(self) }\n+    #[inline]\n+    fn ln(self) -> f32 { num::Float::ln(self) }\n+    #[inline]\n+    fn log(self, base: f32) -> f32 { num::Float::log(self, base) }\n+    #[inline]\n+    fn log2(self) -> f32 { num::Float::log2(self) }\n+    #[inline]\n+    fn log10(self) -> f32 { num::Float::log10(self) }\n+    #[inline]\n+    fn to_degrees(self) -> f32 { num::Float::to_degrees(self) }\n+    #[inline]\n+    fn to_radians(self) -> f32 { num::Float::to_radians(self) }\n+\n     /// Constructs a floating point number by multiplying `x` by 2 raised to the\n     /// power of `exp`\n     #[inline]\n@@ -639,18 +753,18 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f32 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f32 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(FloatMath::ldexp(1f32, -123), f1);\n-        assert_eq!(FloatMath::ldexp(1f32, -111), f2);\n+        assert_eq!(Float::ldexp(1f32, -123), f1);\n+        assert_eq!(Float::ldexp(1f32, -111), f2);\n \n-        assert_eq!(FloatMath::ldexp(0f32, -123), 0f32);\n-        assert_eq!(FloatMath::ldexp(-0f32, -123), -0f32);\n+        assert_eq!(Float::ldexp(0f32, -123), 0f32);\n+        assert_eq!(Float::ldexp(-0f32, -123), -0f32);\n \n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n         let nan: f32 = Float::nan();\n-        assert_eq!(FloatMath::ldexp(inf, -123), inf);\n-        assert_eq!(FloatMath::ldexp(neg_inf, -123), neg_inf);\n-        assert!(FloatMath::ldexp(nan, -123).is_nan());\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -663,8 +777,8 @@ mod tests {\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f32, -122));\n         assert_eq!((x2, exp2), (0.5f32, -110));\n-        assert_eq!(FloatMath::ldexp(x1, exp1), f1);\n-        assert_eq!(FloatMath::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n \n         assert_eq!(0f32.frexp(), (0f32, 0));\n         assert_eq!((-0f32).frexp(), (-0f32, 0));"}, {"sha": "2806154a01681fb7440bca34fc6f4a1ef2bb453d", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 129, "deletions": 14, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -18,12 +18,14 @@ use prelude::v1::*;\n \n use intrinsics;\n use libc::c_int;\n-use num::{Float, FloatMath};\n+use num::{Float, FpCategory};\n use num::strconv;\n use num::strconv::ExponentFormat::{ExpNone, ExpDec};\n use num::strconv::SignificantDigits::{DigAll, DigMax, DigExact};\n use num::strconv::SignFormat::SignNeg;\n \n+use core::num;\n+\n pub use core::f64::{RADIX, MANTISSA_DIGITS, DIGITS, EPSILON, MIN_VALUE};\n pub use core::f64::{MIN_POS_VALUE, MAX_VALUE, MIN_EXP, MAX_EXP, MIN_10_EXP};\n pub use core::f64::{MAX_10_EXP, NAN, INFINITY, NEG_INFINITY};\n@@ -79,10 +81,123 @@ mod cmath {\n     }\n }\n \n-#[unstable = \"trait is unstable\"]\n-impl FloatMath for f64 {\n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n-    /// power of `exp`\n+#[stable]\n+impl Float for f64 {\n+    // inlined methods from `num::Float`\n+    #[inline]\n+    fn nan() -> f64 { num::Float::nan() }\n+    #[inline]\n+    fn infinity() -> f64 { num::Float::infinity() }\n+    #[inline]\n+    fn neg_infinity() -> f64 { num::Float::neg_infinity() }\n+    #[inline]\n+    fn zero() -> f64 { num::Float::zero() }\n+    #[inline]\n+    fn neg_zero() -> f64 { num::Float::neg_zero() }\n+    #[inline]\n+    fn one() -> f64 { num::Float::one() }\n+\n+\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn mantissa_digits(unused_self: Option<f64>) -> uint {\n+        num::Float::mantissa_digits(unused_self)\n+    }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn digits(unused_self: Option<f64>) -> uint { num::Float::digits(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn epsilon() -> f64 { num::Float::epsilon() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_exp(unused_self: Option<f64>) -> int { num::Float::min_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_exp(unused_self: Option<f64>) -> int { num::Float::max_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_10_exp(unused_self: Option<f64>) -> int { num::Float::min_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_10_exp(unused_self: Option<f64>) -> int { num::Float::max_10_exp(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_value() -> f64 { num::Float::min_value() }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn min_pos_value(unused_self: Option<f64>) -> f64 { num::Float::min_pos_value(unused_self) }\n+    #[allow(deprecated)]\n+    #[inline]\n+    fn max_value() -> f64 { num::Float::max_value() }\n+\n+    #[inline]\n+    fn is_nan(self) -> bool { num::Float::is_nan(self) }\n+    #[inline]\n+    fn is_infinite(self) -> bool { num::Float::is_infinite(self) }\n+    #[inline]\n+    fn is_finite(self) -> bool { num::Float::is_finite(self) }\n+    #[inline]\n+    fn is_normal(self) -> bool { num::Float::is_normal(self) }\n+    #[inline]\n+    fn classify(self) -> FpCategory { num::Float::classify(self) }\n+\n+    #[inline]\n+    fn integer_decode(self) -> (u64, i16, i8) { num::Float::integer_decode(self) }\n+\n+    #[inline]\n+    fn floor(self) -> f64 { num::Float::floor(self) }\n+    #[inline]\n+    fn ceil(self) -> f64 { num::Float::ceil(self) }\n+    #[inline]\n+    fn round(self) -> f64 { num::Float::round(self) }\n+    #[inline]\n+    fn trunc(self) -> f64 { num::Float::trunc(self) }\n+    #[inline]\n+    fn fract(self) -> f64 { num::Float::fract(self) }\n+\n+    #[inline]\n+    fn abs(self) -> f64 { num::Float::abs(self) }\n+    #[inline]\n+    fn signum(self) -> f64 { num::Float::signum(self) }\n+    #[inline]\n+    fn is_positive(self) -> bool { num::Float::is_positive(self) }\n+    #[inline]\n+    fn is_negative(self) -> bool { num::Float::is_negative(self) }\n+\n+    #[inline]\n+    fn mul_add(self, a: f64, b: f64) -> f64 { num::Float::mul_add(self, a, b) }\n+    #[inline]\n+    fn recip(self) -> f64 { num::Float::recip(self) }\n+\n+    #[inline]\n+    fn powi(self, n: i32) -> f64 { num::Float::powi(self, n) }\n+    #[inline]\n+    fn powf(self, n: f64) -> f64 { num::Float::powf(self, n) }\n+\n+    #[inline]\n+    fn sqrt(self) -> f64 { num::Float::sqrt(self) }\n+    #[inline]\n+    fn rsqrt(self) -> f64 { num::Float::rsqrt(self) }\n+\n+    #[inline]\n+    fn exp(self) -> f64 { num::Float::exp(self) }\n+    #[inline]\n+    fn exp2(self) -> f64 { num::Float::exp(self) }\n+    #[inline]\n+    fn ln(self) -> f64 { num::Float::ln(self) }\n+    #[inline]\n+    fn log(self, base: f64) -> f64 { num::Float::log(self, base) }\n+    #[inline]\n+    fn log2(self) -> f64 { num::Float::log2(self) }\n+    #[inline]\n+    fn log10(self) -> f64 { num::Float::log10(self) }\n+\n+    #[inline]\n+    fn to_degrees(self) -> f64 { num::Float::to_degrees(self) }\n+    #[inline]\n+    fn to_radians(self) -> f64 { num::Float::to_radians(self) }\n+\n     #[inline]\n     fn ldexp(x: f64, exp: int) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n@@ -640,18 +755,18 @@ mod tests {\n         // are supported in floating-point literals\n         let f1: f64 = FromStrRadix::from_str_radix(\"1p-123\", 16).unwrap();\n         let f2: f64 = FromStrRadix::from_str_radix(\"1p-111\", 16).unwrap();\n-        assert_eq!(FloatMath::ldexp(1f64, -123), f1);\n-        assert_eq!(FloatMath::ldexp(1f64, -111), f2);\n+        assert_eq!(Float::ldexp(1f64, -123), f1);\n+        assert_eq!(Float::ldexp(1f64, -111), f2);\n \n-        assert_eq!(FloatMath::ldexp(0f64, -123), 0f64);\n-        assert_eq!(FloatMath::ldexp(-0f64, -123), -0f64);\n+        assert_eq!(Float::ldexp(0f64, -123), 0f64);\n+        assert_eq!(Float::ldexp(-0f64, -123), -0f64);\n \n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n         let nan: f64 = Float::nan();\n-        assert_eq!(FloatMath::ldexp(inf, -123), inf);\n-        assert_eq!(FloatMath::ldexp(neg_inf, -123), neg_inf);\n-        assert!(FloatMath::ldexp(nan, -123).is_nan());\n+        assert_eq!(Float::ldexp(inf, -123), inf);\n+        assert_eq!(Float::ldexp(neg_inf, -123), neg_inf);\n+        assert!(Float::ldexp(nan, -123).is_nan());\n     }\n \n     #[test]\n@@ -664,8 +779,8 @@ mod tests {\n         let (x2, exp2) = f2.frexp();\n         assert_eq!((x1, exp1), (0.5f64, -122));\n         assert_eq!((x2, exp2), (0.5f64, -110));\n-        assert_eq!(FloatMath::ldexp(x1, exp1), f1);\n-        assert_eq!(FloatMath::ldexp(x2, exp2), f2);\n+        assert_eq!(Float::ldexp(x1, exp1), f1);\n+        assert_eq!(Float::ldexp(x2, exp2), f2);\n \n         assert_eq!(0f64.frexp(), (0f64, 0));\n         assert_eq!((-0f64).frexp(), (-0f64, 0));"}, {"sha": "e3402984ae5053a98bf6028ea46e1e4a67d46f69", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 210, "deletions": 8, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -16,104 +16,306 @@\n #![stable]\n #![allow(missing_docs)]\n \n-#[cfg(test)] use cmp::PartialEq;\n #[cfg(test)] use fmt::Show;\n-#[cfg(test)] use ops::{Add, Sub, Mul, Div, Rem};\n-#[cfg(test)] use kinds::Copy;\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n+\n+use kinds::Copy;\n+use clone::Clone;\n+use cmp::{PartialOrd, PartialEq};\n \n pub use core::num::{Int, SignedInt, UnsignedInt};\n pub use core::num::{cast, FromPrimitive, NumCast, ToPrimitive};\n pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n-pub use core::num::{FpCategory, Float};\n+pub use core::num::{FpCategory};\n+\n+use option::Option;\n \n #[experimental = \"may be removed or relocated\"]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n-#[unstable = \"may be altered to inline the Float trait\"]\n-pub trait FloatMath: Float {\n+#[stable]\n+pub trait Float\n+    : Copy + Clone\n+    + NumCast\n+    + PartialOrd\n+    + PartialEq\n+    + Neg<Output=Self>\n+    + Add<Output=Self>\n+    + Sub<Output=Self>\n+    + Mul<Output=Self>\n+    + Div<Output=Self>\n+    + Rem<Output=Self>\n+{\n+    // inlined methods from `num::Float`\n+    /// Returns the NaN value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn nan() -> Self;\n+    /// Returns the infinite value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn infinity() -> Self;\n+    /// Returns the negative infinite value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn neg_infinity() -> Self;\n+    /// Returns the `0` value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn zero() -> Self;\n+    /// Returns -0.0.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn neg_zero() -> Self;\n+    /// Returns the `1` value.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn one() -> Self;\n+\n+    // FIXME (#5527): These should be associated constants\n+\n+    /// Returns the number of binary digits of mantissa that this type supports.\n+    #[deprecated = \"use `std::f32::MANTISSA_DIGITS` or `std::f64::MANTISSA_DIGITS` as appropriate\"]\n+    fn mantissa_digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the number of base-10 digits of precision that this type supports.\n+    #[deprecated = \"use `std::f32::DIGITS` or `std::f64::DIGITS` as appropriate\"]\n+    fn digits(unused_self: Option<Self>) -> uint;\n+    /// Returns the difference between 1.0 and the smallest representable number larger than 1.0.\n+    #[deprecated = \"use `std::f32::EPSILON` or `std::f64::EPSILON` as appropriate\"]\n+    fn epsilon() -> Self;\n+    /// Returns the minimum binary exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_EXP` or `std::f64::MIN_EXP` as appropriate\"]\n+    fn min_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum binary exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_EXP` or `std::f64::MAX_EXP` as appropriate\"]\n+    fn max_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the minimum base-10 exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MIN_10_EXP` or `std::f64::MIN_10_EXP` as appropriate\"]\n+    fn min_10_exp(unused_self: Option<Self>) -> int;\n+    /// Returns the maximum base-10 exponent that this type can represent.\n+    #[deprecated = \"use `std::f32::MAX_10_EXP` or `std::f64::MAX_10_EXP` as appropriate\"]\n+    fn max_10_exp(unused_self: Option<Self>) -> int;\n+\n+    /// Returns the smallest finite value that this type can represent.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn min_value() -> Self;\n+    /// Returns the smallest normalized positive number that this type can represent.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn min_pos_value(unused_self: Option<Self>) -> Self;\n+    /// Returns the largest finite value that this type can represent.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn max_value() -> Self;\n+\n+    /// Returns true if this value is NaN and false otherwise.\n+    #[unstable = \"position is undecided\"]\n+    fn is_nan(self) -> bool;\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n+    #[unstable = \"position is undecided\"]\n+    fn is_infinite(self) -> bool;\n+    /// Returns true if this number is neither infinite nor NaN.\n+    #[unstable = \"position is undecided\"]\n+    fn is_finite(self) -> bool;\n+    /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n+    #[unstable = \"position is undecided\"]\n+    fn is_normal(self) -> bool;\n+    /// Returns the category that this number falls into.\n+    #[stable]\n+    fn classify(self) -> FpCategory;\n+\n+    /// Returns the mantissa, exponent and sign as integers, respectively.\n+    #[unstable = \"signature is undecided\"]\n+    fn integer_decode(self) -> (u64, i16, i8);\n+\n+    /// Return the largest integer less than or equal to a number.\n+    #[stable]\n+    fn floor(self) -> Self;\n+    /// Return the smallest integer greater than or equal to a number.\n+    #[stable]\n+    fn ceil(self) -> Self;\n+    /// Return the nearest integer to a number. Round half-way cases away from\n+    /// `0.0`.\n+    #[stable]\n+    fn round(self) -> Self;\n+    /// Return the integer part of a number.\n+    #[stable]\n+    fn trunc(self) -> Self;\n+    /// Return the fractional part of a number.\n+    #[stable]\n+    fn fract(self) -> Self;\n+\n+    /// Computes the absolute value of `self`. Returns `Float::nan()` if the\n+    /// number is `Float::nan()`.\n+    #[stable]\n+    fn abs(self) -> Self;\n+    /// Returns a number that represents the sign of `self`.\n+    ///\n+    /// - `1.0` if the number is positive, `+0.0` or `Float::infinity()`\n+    /// - `-1.0` if the number is negative, `-0.0` or `Float::neg_infinity()`\n+    /// - `Float::nan()` if the number is `Float::nan()`\n+    #[stable]\n+    fn signum(self) -> Self;\n+    /// Returns `true` if `self` is positive, including `+0.0` and\n+    /// `Float::infinity()`.\n+    #[stable]\n+    fn is_positive(self) -> bool;\n+    /// Returns `true` if `self` is negative, including `-0.0` and\n+    /// `Float::neg_infinity()`.\n+    #[stable]\n+    fn is_negative(self) -> bool;\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn recip(self) -> Self;\n+\n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    #[stable]\n+    fn powi(self, n: i32) -> Self;\n+    /// Raise a number to a floating point power.\n+    #[stable]\n+    fn powf(self, n: Self) -> Self;\n+\n+    /// Take the square root of a number.\n+    ///\n+    /// Returns NaN if `self` is a negative number.\n+    #[stable]\n+    fn sqrt(self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    #[unstable = \"unsure about its place in the world\"]\n+    fn rsqrt(self) -> Self;\n+\n+    /// Returns `e^(self)`, (the exponential function).\n+    #[stable]\n+    fn exp(self) -> Self;\n+    /// Returns 2 raised to the power of the number, `2^(self)`.\n+    #[stable]\n+    fn exp2(self) -> Self;\n+    /// Returns the natural logarithm of the number.\n+    #[stable]\n+    fn ln(self) -> Self;\n+    /// Returns the logarithm of the number with respect to an arbitrary base.\n+    #[stable]\n+    fn log(self, base: Self) -> Self;\n+    /// Returns the base 2 logarithm of the number.\n+    #[stable]\n+    fn log2(self) -> Self;\n+    /// Returns the base 10 logarithm of the number.\n+    #[stable]\n+    fn log10(self) -> Self;\n+\n+    /// Convert radians to degrees.\n+    #[unstable = \"desirability is unclear\"]\n+    fn to_degrees(self) -> Self;\n+    /// Convert degrees to radians.\n+    #[unstable = \"desirability is unclear\"]\n+    fn to_radians(self) -> Self;\n+\n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n+    #[unstable = \"pending integer conventions\"]\n     fn ldexp(x: Self, exp: int) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n     /// satisfying:\n     ///\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n+    #[unstable = \"pending integer conventions\"]\n     fn frexp(self) -> (Self, int);\n \n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n+    #[unstable = \"unsure about its place in the world\"]\n     fn next_after(self, other: Self) -> Self;\n \n     /// Returns the maximum of the two numbers.\n+    #[stable]\n     fn max(self, other: Self) -> Self;\n     /// Returns the minimum of the two numbers.\n+    #[stable]\n     fn min(self, other: Self) -> Self;\n \n     /// The positive difference of two numbers. Returns `0.0` if the number is\n     /// less than or equal to `other`, otherwise the difference between`self`\n     /// and `other` is returned.\n+    #[unstable = \"may be renamed\"]\n     fn abs_sub(self, other: Self) -> Self;\n \n     /// Take the cubic root of a number.\n+    #[unstable = \"may be renamed\"]\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n+    #[unstable = \"unsure about its place in the world\"]\n     fn hypot(self, other: Self) -> Self;\n \n     /// Computes the sine of a number (in radians).\n+    #[stable]\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n+    #[stable]\n     fn cos(self) -> Self;\n     /// Computes the tangent of a number (in radians).\n+    #[stable]\n     fn tan(self) -> Self;\n \n     /// Computes the arcsine of a number. Return value is in radians in\n     /// the range [-pi/2, pi/2] or NaN if the number is outside the range\n     /// [-1, 1].\n+    #[stable]\n     fn asin(self) -> Self;\n     /// Computes the arccosine of a number. Return value is in radians in\n     /// the range [0, pi] or NaN if the number is outside the range\n     /// [-1, 1].\n+    #[stable]\n     fn acos(self) -> Self;\n     /// Computes the arctangent of a number. Return value is in radians in the\n     /// range [-pi/2, pi/2];\n+    #[stable]\n     fn atan(self) -> Self;\n     /// Computes the four quadrant arctangent of a number, `y`, and another\n     /// number `x`. Return value is in radians in the range [-pi, pi].\n+    #[stable]\n     fn atan2(self, other: Self) -> Self;\n     /// Simultaneously computes the sine and cosine of the number, `x`. Returns\n     /// `(sin(x), cos(x))`.\n+    #[stable]\n     fn sin_cos(self) -> (Self, Self);\n \n     /// Returns the exponential of the number, minus 1, in a way that is\n     /// accurate even if the number is close to zero.\n+    #[unstable = \"may be renamed\"]\n     fn exp_m1(self) -> Self;\n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately.\n+    #[unstable = \"may be renamed\"]\n     fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n+    #[stable]\n     fn sinh(self) -> Self;\n     /// Hyperbolic cosine function.\n+    #[stable]\n     fn cosh(self) -> Self;\n     /// Hyperbolic tangent function.\n+    #[stable]\n     fn tanh(self) -> Self;\n     /// Inverse hyperbolic sine function.\n+    #[stable]\n     fn asinh(self) -> Self;\n     /// Inverse hyperbolic cosine function.\n+    #[stable]\n     fn acosh(self) -> Self;\n     /// Inverse hyperbolic tangent function.\n+    #[stable]\n     fn atanh(self) -> Self;\n }\n \n-// DEPRECATED\n-\n /// Helper function for testing numeric operations\n #[cfg(test)]\n pub fn test_num<T>(ten: T, two: T) where"}, {"sha": "4ce15491a0e539dd6bb7be481f171b994083521c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -14,8 +14,6 @@\n \n macro_rules! uint_module { ($T:ty) => (\n \n-// String conversion functions and impl num -> str\n-\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;"}, {"sha": "c417fd94e22eb953a9cd73955cbb63a729f8c52a", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -69,7 +69,7 @@ use std::io::stdio::StdWriter;\n use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::iter::repeat;\n-use std::num::{Float, FloatMath, Int};\n+use std::num::{Float, Int};\n use std::os;\n use std::str::FromStr;\n use std::sync::mpsc::{channel, Sender};"}, {"sha": "bdc05a50301d54bf0c9f5e1e85b7b1f7998200ab", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -17,7 +17,7 @@ use std::fmt::Show;\n use std::hash::Hash;\n use std::io;\n use std::mem;\n-use std::num::{Float, FloatMath, FromPrimitive};\n+use std::num::{Float, FromPrimitive};\n \n fn local_cmp<T:Float>(x: T, y: T) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -39,7 +39,7 @@ fn local_sort<T: Float>(v: &mut [T]) {\n }\n \n /// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n-pub trait Stats <T: FloatMath + FromPrimitive> {\n+pub trait Stats <T: Float + FromPrimitive> {\n \n     /// Sum of the samples.\n     ///\n@@ -144,7 +144,7 @@ pub struct Summary<T> {\n     pub iqr: T,\n }\n \n-impl<T: FloatMath + FromPrimitive> Summary<T> {\n+impl<T: Float + FromPrimitive> Summary<T> {\n     /// Construct a new summary of a sample set.\n     pub fn new(samples: &[T]) -> Summary<T> {\n         Summary {\n@@ -164,7 +164,7 @@ impl<T: FloatMath + FromPrimitive> Summary<T> {\n     }\n }\n \n-impl<T: FloatMath + FromPrimitive> Stats<T> for [T] {\n+impl<T: Float + FromPrimitive> Stats<T> for [T] {\n     // FIXME #11059 handle NaN, inf and overflow\n     fn sum(&self) -> T {\n         let mut partials = vec![];"}, {"sha": "3c7efb0336a012f525b07363b21dccd5a829d96d", "filename": "src/test/bench/noise.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Ftest%2Fbench%2Fnoise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8efd9901b628d687d11a4d0ccc153553b38ada49/src%2Ftest%2Fbench%2Fnoise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fnoise.rs?ref=8efd9901b628d687d11a4d0ccc153553b38ada49", "patch": "@@ -13,7 +13,7 @@\n // ignore-lexer-test FIXME #15679\n \n use std::f32::consts::PI;\n-use std::num::{Float, FloatMath};\n+use std::num::Float;\n use std::rand::{Rng, StdRng};\n \n struct Vec2 {"}]}