{"sha": "092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5MmJhNmE4NTYzYjVjOTVmNWFhNTNhNzA1ZWFiYTZjYzk0ZTJkYTc=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-18T00:15:47Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2015-01-21T15:45:45Z"}, "message": "Deprecate slicing methods in favor of notation\n\nThis commit deprecates `slice`, `slice_from`, `slice_to` and their\nmutable variants in favor of slice notation.\n\nThe `as_slice` methods are left intact, for now.\n\n[breaking-change]", "tree": {"sha": "17deb06bc801ba7201beeaa337716fbae6279195", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17deb06bc801ba7201beeaa337716fbae6279195"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "html_url": "https://github.com/rust-lang/rust/commit/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fba0bf63a90379e8825012a817167774e14a627f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fba0bf63a90379e8825012a817167774e14a627f", "html_url": "https://github.com/rust-lang/rust/commit/fba0bf63a90379e8825012a817167774e14a627f"}], "stats": {"total": 300, "additions": 115, "deletions": 185}, "files": [{"sha": "a640e4ee0e340d21f77e08612e76802211d72e04", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 18, "deletions": 44, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "patch": "@@ -169,29 +169,16 @@ pub trait SliceExt {\n     #[unstable = \"uncertain about this API approach\"]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[start .. end]` notation instead.\n+    #[deprecated = \"use &s[start .. end] instead\"]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[start..]` notation instead.\n+    #[deprecated = \"use &s[start..] isntead\"]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[..end]` notation instead.\n+    #[deprecated = \"use &s[..end] instead\"]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -378,29 +365,16 @@ pub trait SliceExt {\n     #[stable]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[start .. end]` instead.\n+    #[deprecated = \"use &mut s[start .. end] instead\"]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[start ..]` instead.\n+    #[deprecated = \"use &mut s[start ..] instead\"]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[.. end]` instead.\n+    #[deprecated = \"use &mut s[.. end] instead\"]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n@@ -720,17 +694,17 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+        &self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+        &self[start ..]\n     }\n \n     #[inline]\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n+        &self[.. end]\n     }\n \n     #[inline]\n@@ -834,17 +808,17 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n+        &mut self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n+        &mut self[start ..]\n     }\n \n     #[inline]\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n+        &mut self[.. end]\n     }\n \n     #[inline]"}, {"sha": "94554fd1e81db991d41d48a2ee2e9187004ded98", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 6, "deletions": 50, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "patch": "@@ -750,64 +750,20 @@ pub trait StrExt: Index<FullRange, Output = str> {\n         core_str::StrExt::lines_any(&self[])\n     }\n \n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n-    #[unstable = \"use slice notation [a..b] instead\"]\n+    /// Deprecated: use `s[a .. b]` instead.\n+    #[deprecated = \"use slice notation [a..b] instead\"]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice(&self[], begin, end)\n     }\n \n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n-    #[unstable = \"use slice notation [a..] instead\"]\n+    /// Deprecated: use `s[a..]` instead.\n+    #[deprecated = \"use slice notation [a..] instead\"]\n     fn slice_from(&self, begin: uint) -> &str {\n         core_str::StrExt::slice_from(&self[], begin)\n     }\n \n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n-    #[unstable = \"use slice notation [..a] instead\"]\n+    /// Deprecated: use `s[..a]` instead.\n+    #[deprecated = \"use slice notation [..a] instead\"]\n     fn slice_to(&self, end: uint) -> &str {\n         core_str::StrExt::slice_to(&self[], end)\n     }"}, {"sha": "4a73757baf97398ea829a102dedaf02e7e9437a8", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "patch": "@@ -848,27 +848,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+#[stable]\n impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::FullRange> for String {\n     type Output = str;\n     #[inline]"}, {"sha": "f02804ad9d197a9857d14df14c876d142b8f6835", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 18, "deletions": 50, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "patch": "@@ -67,9 +67,6 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n     fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n     fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n@@ -93,9 +90,6 @@ pub trait SliceExt {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n@@ -135,28 +129,6 @@ pub trait SliceExt {\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &[T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                data: self.as_ptr().offset(start as int),\n-                len: (end - start)\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &[T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &[T] {\n-        self.slice(0, end)\n-    }\n-\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n         (&self[..mid], &self[mid..])\n@@ -291,20 +263,6 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::Range { start: start, end: end } )\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeFrom { start: start } )\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeTo { end: end } )\n-    }\n-\n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -345,13 +303,13 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn tail_mut(&mut self) -> &mut [T] {\n-        self.slice_from_mut(1)\n+        &mut self[1 ..]\n     }\n \n     #[inline]\n     fn init_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n-        self.slice_to_mut(len-1)\n+        &mut self[.. (len - 1)]\n     }\n \n     #[inline]\n@@ -483,7 +441,7 @@ impl<T> SliceExt for [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         true\n     }\n@@ -505,7 +463,7 @@ impl<T> SliceExt for [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -522,15 +480,16 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n-        let dst = self.slice_to_mut(min);\n-        let src = src.slice_to(min);\n+        let dst = &mut self[.. min];\n+        let src = &src[.. min];\n         for i in range(0, min) {\n             dst[i].clone_from(&src[i]);\n         }\n         min\n     }\n }\n \n+#[stable]\n impl<T> ops::Index<uint> for [T] {\n     type Output = T;\n \n@@ -541,6 +500,7 @@ impl<T> ops::Index<uint> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<uint> for [T] {\n     type Output = T;\n \n@@ -551,6 +511,7 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::Index<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -565,20 +526,23 @@ impl<T> ops::Index<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -587,6 +551,7 @@ impl<T> ops::Index<ops::FullRange> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -601,13 +566,15 @@ impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -616,6 +583,7 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -1051,7 +1019,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail.slice_from_mut(1);\n+                self.v = &mut tail[1..];\n                 Some(head)\n             }\n         }\n@@ -1087,7 +1055,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.slice_from_mut(1))\n+                Some(&mut tail[1..])\n             }\n         }\n     }"}, {"sha": "42034a8bd7013cc1e0f6c0feec5583bb80b88b16", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/092ba6a8563b5c95f5aa53a705eaba6cc94e2da7/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=092ba6a8563b5c95f5aa53a705eaba6cc94e2da7", "patch": "@@ -902,13 +902,13 @@ impl<'a> Iterator for SplitStr<'a> {\n \n         match self.it.next() {\n             Some((from, to)) => {\n-                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                let ret = Some(&self.it.haystack[self.last_end .. from]);\n                 self.last_end = to;\n                 ret\n             }\n             None => {\n                 self.finished = true;\n-                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+                Some(&self.it.haystack[self.last_end .. self.it.haystack.len()])\n             }\n         }\n     }\n@@ -1115,27 +1115,90 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[stable]\n     impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::Range<uint>) -> &str {\n-            self.slice(index.start, index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self[0 .. end]`.\n+    ///\n+    /// Panics when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable]\n     impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n-            self.slice_to(index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self[begin .. self.len()]`.\n+    ///\n+    /// Panics when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable]\n     impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n-            self.slice_from(index.start)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n         }\n     }\n+\n+    #[stable]\n     impl ops::Index<ops::FullRange> for str {\n         type Output = str;\n         #[inline]\n@@ -1208,9 +1271,6 @@ pub trait StrExt {\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n-    fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n@@ -1332,7 +1392,7 @@ impl StrExt for str {\n     fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n-            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n             else { line }\n         }\n \n@@ -1343,38 +1403,6 @@ impl StrExt for str {\n     #[inline]\n     fn char_len(&self) -> uint { self.chars().count() }\n \n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if begin <= end &&\n-           self.is_char_boundary(begin) &&\n-           self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(begin, end) }\n-        } else {\n-            slice_error_fail(self, begin, end)\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(begin) {\n-            unsafe { self.slice_unchecked(begin, self.len()) }\n-        } else {\n-            slice_error_fail(self, begin, self.len())\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(0, end) }\n-        } else {\n-            slice_error_fail(self, 0, end)\n-        }\n-    }\n-\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;"}]}