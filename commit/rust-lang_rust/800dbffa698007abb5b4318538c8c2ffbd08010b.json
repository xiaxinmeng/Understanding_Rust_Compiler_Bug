{"sha": "800dbffa698007abb5b4318538c8c2ffbd08010b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwMGRiZmZhNjk4MDA3YWJiNWI0MzE4NTM4YzhjMmZmYmQwODAxMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-03T17:04:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-03T17:04:58Z"}, "message": "auto merge of #8219 : sstewartgallus/rust/fix_dynamic_lib, r=graydon\n\nA test case was also created for this situation to prevent the problem\r\noccuring again.\r\n\r\nA similar problem was also fixed for the symbol method.\r\n\r\nThere was some minor code cleanup.\r\n\r\nI am unsatisfied with using /dev/null as an invalid dynamic library. It is not cross platform.", "tree": {"sha": "81e846a1aa116a9c5e04472bca340d6e74c01aa7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81e846a1aa116a9c5e04472bca340d6e74c01aa7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/800dbffa698007abb5b4318538c8c2ffbd08010b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/800dbffa698007abb5b4318538c8c2ffbd08010b", "html_url": "https://github.com/rust-lang/rust/commit/800dbffa698007abb5b4318538c8c2ffbd08010b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/800dbffa698007abb5b4318538c8c2ffbd08010b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34101d2320583a0a95ab3afc4c2b6b75dadb5cd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/34101d2320583a0a95ab3afc4c2b6b75dadb5cd7", "html_url": "https://github.com/rust-lang/rust/commit/34101d2320583a0a95ab3afc4c2b6b75dadb5cd7"}, {"sha": "2047026fefa38773ecdb046998a65ca1e1dc9cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/2047026fefa38773ecdb046998a65ca1e1dc9cef", "html_url": "https://github.com/rust-lang/rust/commit/2047026fefa38773ecdb046998a65ca1e1dc9cef"}], "stats": {"total": 106, "additions": 70, "deletions": 36}, "files": [{"sha": "8d5654255f14a7264f50a9b3294dec4b49ffcc3c", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/800dbffa698007abb5b4318538c8c2ffbd08010b/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/800dbffa698007abb5b4318538c8c2ffbd08010b/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=800dbffa698007abb5b4318538c8c2ffbd08010b", "patch": "@@ -31,7 +31,7 @@ impl Drop for DynamicLibrary {\n                 dl::close(self.handle)\n             }\n         } {\n-            Ok(()) => { },\n+            Ok(()) => {},\n             Err(str) => fail!(str)\n         }\n     }\n@@ -41,14 +41,20 @@ impl DynamicLibrary {\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n-        do dl::check_for_errors_in {\n-            unsafe {\n-                DynamicLibrary { handle:\n-                    match filename {\n-                        Some(name) => dl::open_external(name),\n-                        None => dl::open_internal()\n-                    }\n+        unsafe {\n+            let maybe_library = do dl::check_for_errors_in {\n+                match filename {\n+                    Some(name) => dl::open_external(name),\n+                    None => dl::open_internal()\n                 }\n+            };\n+\n+            // The dynamic library must not be constructed if there is\n+            // an error opening the library so the destructor does not\n+            // run.\n+            match maybe_library {\n+                Err(err) => Err(err),\n+                Ok(handle) => Ok(DynamicLibrary { handle: handle })\n             }\n         }\n     }\n@@ -58,41 +64,69 @@ impl DynamicLibrary {\n         // This function should have a lifetime constraint of 'self on\n         // T but that feature is still unimplemented\n \n-        do dl::check_for_errors_in {\n-            let symbol_value = do symbol.as_c_str |raw_string| {\n+        let maybe_symbol_value = do dl::check_for_errors_in {\n+            do symbol.as_c_str |raw_string| {\n                 dl::symbol(self.handle, raw_string)\n-            };\n+            }\n+        };\n \n-            cast::transmute(symbol_value)\n+        // The value must not be constructed if there is an error so\n+        // the destructor does not run.\n+        match maybe_symbol_value {\n+            Err(err) => Err(err),\n+            Ok(symbol_value) => Ok(cast::transmute(symbol_value))\n         }\n     }\n }\n \n-#[test]\n-#[ignore(cfg(windows))]\n-priv fn test_loading_cosine () {\n-    // The math library does not need to be loaded since it is already\n-    // statically linked in\n-    let libm = match DynamicLibrary::open(None) {\n-        Err (error) => fail!(\"Could not load self as module: %s\", error),\n-        Ok (libm) => libm\n-    };\n-\n-    // Unfortunately due to issue #6194 it is not possible to call\n-    // this as a C function\n-    let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n-        match libm.symbol(\"cos\") {\n-            Err (error) => fail!(\"Could not load function cos: %s\", error),\n-            Ok (cosine) => cosine\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use option::*;\n+    use result::*;\n+    use path::*;\n+    use libc;\n+\n+    #[test]\n+    fn test_loading_cosine() {\n+        // The math library does not need to be loaded since it is already\n+        // statically linked in\n+        let libm = match DynamicLibrary::open(None) {\n+            Err(error) => fail!(\"Could not load self as module: %s\", error),\n+            Ok(libm) => libm\n+        };\n+\n+        // Unfortunately due to issue #6194 it is not possible to call\n+        // this as a C function\n+        let cosine: extern fn(libc::c_double) -> libc::c_double = unsafe {\n+            match libm.symbol(\"cos\") {\n+                Err(error) => fail!(\"Could not load function cos: %s\", error),\n+                Ok(cosine) => cosine\n+            }\n+        };\n+\n+        let argument = 0.0;\n+        let expected_result = 1.0;\n+        let result = cosine(argument);\n+        if result != expected_result {\n+            fail!(\"cos(%?) != %? but equaled %? instead\", argument,\n+                  expected_result, result)\n+        }\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn test_errors_do_not_crash() {\n+        // Open /dev/null as a library to get an error, and make sure\n+        // that only causes an error, and not a crash.\n+        let path = GenericPath::from_str(\"/dev/null\");\n+        match DynamicLibrary::open(Some(&path)) {\n+            Err(_) => {}\n+            Ok(_) => fail!(\"Successfully opened the empty library.\")\n         }\n-    };\n-\n-    let argument = 0.0;\n-    let expected_result = 1.0;\n-    let result = cosine(argument);\n-    if result != expected_result {\n-        fail!(\"cos(%?) != %? but equaled %? instead\", argument,\n-              expected_result, result)\n     }\n }\n "}]}