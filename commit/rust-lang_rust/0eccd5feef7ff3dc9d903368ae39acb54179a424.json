{"sha": "0eccd5feef7ff3dc9d903368ae39acb54179a424", "node_id": "C_kwDOAAsO6NoAKDBlY2NkNWZlZWY3ZmYzZGM5ZDkwMzM2OGFlMzlhY2I1NDE3OWE0MjQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-19T09:23:23Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-19T09:28:14Z"}, "message": "skip some layers in const drop confirmation", "tree": {"sha": "e5dcd6ef1412d4285137827b3612a7f65d983bfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5dcd6ef1412d4285137827b3612a7f65d983bfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0eccd5feef7ff3dc9d903368ae39acb54179a424", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0eccd5feef7ff3dc9d903368ae39acb54179a424", "html_url": "https://github.com/rust-lang/rust/commit/0eccd5feef7ff3dc9d903368ae39acb54179a424", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0eccd5feef7ff3dc9d903368ae39acb54179a424/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3f01b2b6ff177359504e42a99665a8abc388cb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f01b2b6ff177359504e42a99665a8abc388cb7", "html_url": "https://github.com/rust-lang/rust/commit/e3f01b2b6ff177359504e42a99665a8abc388cb7"}], "stats": {"total": 161, "additions": 91, "deletions": 70}, "files": [{"sha": "4c74627f3c67dd88aa01f90e89c3a9e147c9f59f", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 91, "deletions": 70, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/0eccd5feef7ff3dc9d903368ae39acb54179a424/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0eccd5feef7ff3dc9d903368ae39acb54179a424/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=0eccd5feef7ff3dc9d903368ae39acb54179a424", "patch": "@@ -1103,90 +1103,111 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let tcx = self.tcx();\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n \n-        // Skip binder here (*)\n-        let nested_tys = match *self_ty.skip_binder().kind() {\n-            ty::Bool\n-            | ty::Char\n-            | ty::Int(_)\n-            | ty::Uint(_)\n-            | ty::Float(_)\n-            | ty::Infer(ty::IntVar(_))\n-            | ty::Infer(ty::FloatVar(_))\n-            | ty::Str\n-            | ty::RawPtr(_)\n-            | ty::Ref(..)\n-            | ty::FnDef(..)\n-            | ty::FnPtr(_)\n-            | ty::Never => vec![],\n-\n-            ty::Adt(def, substs) => def.all_fields().map(|f| f.ty(tcx, substs)).collect(),\n-\n-            ty::Array(ty, _) | ty::Slice(ty) => vec![ty],\n-\n-            ty::Tuple(tys) => tys.iter().map(|ty| ty.expect_ty()).collect(),\n-\n-            ty::Closure(_, substs) => vec![substs.as_closure().tupled_upvars_ty()],\n-\n-            ty::Generator(_, substs, _) => {\n-                vec![substs.as_generator().tupled_upvars_ty(), substs.as_generator().witness()]\n-            }\n-\n-            ty::GeneratorWitness(tys) => tcx.erase_late_bound_regions(tys).to_vec(),\n-\n-            ty::Opaque(_, _)\n-            | ty::Dynamic(_, _)\n-            | ty::Error(_)\n-            | ty::Bound(_, _)\n-            | ty::Param(_)\n-            | ty::Placeholder(_)\n-            | ty::Foreign(_)\n-            | ty::Projection(_)\n-            | ty::Infer(_) => {\n-                unreachable!();\n-            }\n-        };\n-\n-        info!(\n-            \"confirm_const_drop_candidate: self_ty={:?}, nested_tys={:?} impl_def_id={:?}\",\n-            self_ty, nested_tys, impl_def_id\n-        );\n-\n-        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n         let mut nested = vec![];\n+        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n \n-        // If we have a custom `impl const Drop`, then check it like a regular impl candidate.\n+        // If we have a custom `impl const Drop`, then\n+        // first check it like a regular impl candidate\n         if let Some(impl_def_id) = impl_def_id {\n             nested.extend(self.confirm_impl_candidate(obligation, impl_def_id).nested);\n         }\n \n-        for ty in nested_tys {\n-            let predicate = self.infcx.commit_unconditionally(|_| {\n-                normalize_with_depth_to(\n-                    self,\n-                    obligation.param_env,\n-                    cause.clone(),\n-                    obligation.recursion_depth + 1,\n-                    // Rebinding here (*)\n-                    self_ty\n+        // We want to confirm the ADT's fields if we have an ADT\n+        let mut stack = match *self_ty.skip_binder().kind() {\n+            ty::Adt(def, substs) => def.all_fields().map(|f| f.ty(tcx, substs)).collect(),\n+            _ => vec![self_ty.skip_binder()],\n+        };\n+\n+        while let Some(nested_ty) = stack.pop() {\n+            match *nested_ty.kind() {\n+                // We know these types are trivially drop\n+                ty::Bool\n+                | ty::Char\n+                | ty::Int(_)\n+                | ty::Uint(_)\n+                | ty::Float(_)\n+                | ty::Infer(ty::IntVar(_))\n+                | ty::Infer(ty::FloatVar(_))\n+                | ty::Str\n+                | ty::RawPtr(_)\n+                | ty::Ref(..)\n+                | ty::FnDef(..)\n+                | ty::FnPtr(_)\n+                | ty::Never => {}\n+\n+                // These types are built-in, so we can fast-track by registering\n+                // nested predicates for their constituient type(s)\n+                ty::Array(ty, _) | ty::Slice(ty) => {\n+                    stack.push(ty);\n+                }\n+                ty::Tuple(tys) => {\n+                    stack.extend(tys.iter().map(|ty| ty.expect_ty()));\n+                }\n+                ty::Closure(_, substs) => {\n+                    stack.push(substs.as_closure().tupled_upvars_ty());\n+                }\n+                ty::Generator(_, substs, _) => {\n+                    let generator = substs.as_generator();\n+                    stack.extend([generator.tupled_upvars_ty(), generator.witness()]);\n+                }\n+                ty::GeneratorWitness(tys) => {\n+                    stack.extend(tcx.erase_late_bound_regions(tys).to_vec());\n+                }\n+\n+                // If we have a projection type, make sure to normalize it so we replace it\n+                // with a fresh infer variable\n+                ty::Projection(..) => {\n+                    self.infcx.commit_unconditionally(|_| {\n+                        let predicate = normalize_with_depth_to(\n+                            self,\n+                            obligation.param_env,\n+                            cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            self_ty\n+                                .rebind(ty::TraitPredicate {\n+                                    trait_ref: ty::TraitRef {\n+                                        def_id: self.tcx().require_lang_item(LangItem::Drop, None),\n+                                        substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n+                                    },\n+                                    constness: ty::BoundConstness::ConstIfConst,\n+                                    polarity: ty::ImplPolarity::Positive,\n+                                })\n+                                .to_predicate(tcx),\n+                            &mut nested,\n+                        );\n+\n+                        nested.push(Obligation::with_depth(\n+                            cause.clone(),\n+                            obligation.recursion_depth + 1,\n+                            obligation.param_env,\n+                            predicate,\n+                        ));\n+                    });\n+                }\n+\n+                // If we have any other type (e.g. an ADT), just register a nested obligation\n+                // since it's either not `const Drop` (and we raise an error during selection),\n+                // or it's an ADT (and we need to check for a custom impl during selection)\n+                _ => {\n+                    let predicate = self_ty\n                         .rebind(ty::TraitPredicate {\n                             trait_ref: ty::TraitRef {\n                                 def_id: self.tcx().require_lang_item(LangItem::Drop, None),\n-                                substs: self.tcx().mk_substs_trait(ty, &[]),\n+                                substs: self.tcx().mk_substs_trait(nested_ty, &[]),\n                             },\n                             constness: ty::BoundConstness::ConstIfConst,\n                             polarity: ty::ImplPolarity::Positive,\n                         })\n-                        .to_predicate(tcx),\n-                    &mut nested,\n-                )\n-            });\n+                        .to_predicate(tcx);\n \n-            nested.push(Obligation::with_depth(\n-                cause.clone(),\n-                obligation.recursion_depth + 1,\n-                obligation.param_env,\n-                predicate,\n-            ));\n+                    nested.push(Obligation::with_depth(\n+                        cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        obligation.param_env,\n+                        predicate,\n+                    ));\n+                }\n+            }\n         }\n \n         Ok(ImplSourceConstDropData { nested })"}]}