{"sha": "63d317c71a088bc20c6eee7d9ee71a7db44afde0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZDMxN2M3MWEwODhiYzIwYzZlZWU3ZDllZTcxYTdkYjQ0YWZkZTA=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-20T12:58:18Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-20T18:56:26Z"}, "message": "Compute missing arms lazily.", "tree": {"sha": "901579e6aa82a9ea66e1f0a71dcd61f3c731ec5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/901579e6aa82a9ea66e1f0a71dcd61f3c731ec5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63d317c71a088bc20c6eee7d9ee71a7db44afde0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63d317c71a088bc20c6eee7d9ee71a7db44afde0", "html_url": "https://github.com/rust-lang/rust/commit/63d317c71a088bc20c6eee7d9ee71a7db44afde0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63d317c71a088bc20c6eee7d9ee71a7db44afde0/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764241e38e46316b6370977e8b51e841e93e84b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/764241e38e46316b6370977e8b51e841e93e84b9", "html_url": "https://github.com/rust-lang/rust/commit/764241e38e46316b6370977e8b51e841e93e84b9"}], "stats": {"total": 47, "additions": 24, "deletions": 23}, "files": [{"sha": "12ea17d7a22db12653941afd4140d7a4c4354f44", "filename": "crates/ide_assists/src/handlers/fill_match_arms.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/63d317c71a088bc20c6eee7d9ee71a7db44afde0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63d317c71a088bc20c6eee7d9ee71a7db44afde0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=63d317c71a088bc20c6eee7d9ee71a7db44afde0", "patch": "@@ -1,4 +1,4 @@\n-use std::iter;\n+use std::iter::{self, Peekable};\n \n use either::Either;\n use hir::{Adt, HasSource, ModuleDef, Semantics};\n@@ -63,33 +63,33 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n \n     let module = ctx.sema.scope(expr.syntax()).module()?;\n \n-    let missing_arms: Vec<MatchArm> = if let Some(enum_def) = resolve_enum_def(&ctx.sema, &expr) {\n+    let mut missing_pats: Peekable<Box<dyn Iterator<Item = ast::Pat>>> = if let Some(enum_def) =\n+        resolve_enum_def(&ctx.sema, &expr)\n+    {\n         let variants = enum_def.variants(ctx.db());\n \n-        let mut variants = variants\n+        let missing_pats = variants\n             .into_iter()\n             .filter_map(|variant| build_pat(ctx.db(), module, variant))\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n-            .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n-            .map(|it| it.clone_for_update())\n-            .collect::<Vec<_>>();\n-        if Some(enum_def)\n-            == FamousDefs(&ctx.sema, Some(module.krate()))\n-                .core_option_Option()\n-                .map(|x| lift_enum(x))\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n+\n+        let missing_pats: Box<dyn Iterator<Item = _>> = if Some(enum_def)\n+            == FamousDefs(&ctx.sema, Some(module.krate())).core_option_Option().map(lift_enum)\n         {\n             // Match `Some` variant first.\n             cov_mark::hit!(option_order);\n-            variants.reverse()\n-        }\n-        variants\n+            Box::new(missing_pats.rev())\n+        } else {\n+            Box::new(missing_pats)\n+        };\n+        missing_pats.peekable()\n     } else if let Some(enum_defs) = resolve_tuple_of_enum_def(&ctx.sema, &expr) {\n         // When calculating the match arms for a tuple of enums, we want\n         // to create a match arm for each possible combination of enum\n         // values. The `multi_cartesian_product` method transforms\n         // Vec<Vec<EnumVariant>> into Vec<(EnumVariant, .., EnumVariant)>\n         // where each tuple represents a proposed match arm.\n-        enum_defs\n+        let missing_pats = enum_defs\n             .into_iter()\n             .map(|enum_def| enum_def.variants(ctx.db()))\n             .multi_cartesian_product()\n@@ -98,15 +98,13 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n                     variants.into_iter().filter_map(|variant| build_pat(ctx.db(), module, variant));\n                 ast::Pat::from(make::tuple_pat(patterns))\n             })\n-            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat))\n-            .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n-            .map(|it| it.clone_for_update())\n-            .collect()\n+            .filter(|variant_pat| is_variant_missing(&top_lvl_pats, variant_pat));\n+        (Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable()\n     } else {\n         return None;\n     };\n \n-    if missing_arms.is_empty() {\n+    if missing_pats.peek().is_none() {\n         return None;\n     }\n \n@@ -117,6 +115,9 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n         target,\n         |builder| {\n             let new_match_arm_list = match_arm_list.clone_for_update();\n+            let missing_arms = missing_pats\n+                .map(|pat| make::match_arm(iter::once(pat), make::expr_empty_block()))\n+                .map(|it| it.clone_for_update());\n \n             let catch_all_arm = new_match_arm_list\n                 .arms()\n@@ -167,13 +168,13 @@ fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     }\n }\n \n-#[derive(Eq, PartialEq, Clone)]\n+#[derive(Eq, PartialEq, Clone, Copy)]\n enum ExtendedEnum {\n     Bool,\n     Enum(hir::Enum),\n }\n \n-#[derive(Eq, PartialEq, Clone)]\n+#[derive(Eq, PartialEq, Clone, Copy)]\n enum ExtendedVariant {\n     True,\n     False,\n@@ -185,7 +186,7 @@ fn lift_enum(e: hir::Enum) -> ExtendedEnum {\n }\n \n impl ExtendedEnum {\n-    fn variants(&self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n+    fn variants(self, db: &RootDatabase) -> Vec<ExtendedVariant> {\n         match self {\n             ExtendedEnum::Enum(e) => {\n                 e.variants(db).into_iter().map(|x| ExtendedVariant::Variant(x)).collect::<Vec<_>>()"}]}