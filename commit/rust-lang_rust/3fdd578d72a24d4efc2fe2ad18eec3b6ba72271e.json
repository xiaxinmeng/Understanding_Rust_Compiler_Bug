{"sha": "3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "node_id": "C_kwDOAAsO6NoAKDNmZGQ1NzhkNzJhMjRkNGVmYzJmZTJhZDE4ZWVjM2I2YmE3MjI3MWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T09:45:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T09:45:27Z"}, "message": "Auto merge of #101115 - matthiaskrgr:rollup-iy14ztr, r=matthiaskrgr\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #97015 (std::io: migrate ReadBuf to BorrowBuf/BorrowCursor)\n - #98301 (Add GDB/LLDB pretty-printers for NonZero types)\n - #99570 (Box::from(slice): Clarify that contents are copied)\n - #100296 (Add standard C error function aliases to last_os_error)\n - #100520 (Add mention of `BufReader` in `Read::bytes` docs)\n - #100885 (Export Cancel from std::os::fortanix_sgx::usercalls::raw)\n - #100955 (Some papercuts on error::Error)\n - #101002 (Provide structured suggestion for `hashmap[idx] = val`)\n - #101038 (no alignment check during interning)\n - #101055 (Use smaller span for suggestions)\n - #101091 (Extend attrs if local_def_id exists)\n - #101098 (rustc_middle: Remove `Visibility::Invisible`)\n - #101102 (unstable-book-gen: use std::fs::write)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c16a91467031dd1db4408c338037e1a0206799cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c16a91467031dd1db4408c338037e1a0206799cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "html_url": "https://github.com/rust-lang/rust/commit/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5ef528bebbe0d8e350e547316fdc7d7476614d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5ef528bebbe0d8e350e547316fdc7d7476614d2", "html_url": "https://github.com/rust-lang/rust/commit/d5ef528bebbe0d8e350e547316fdc7d7476614d2"}, {"sha": "b3a4bc51d7df23cde0ad96ee4dbd27c0f9311b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3a4bc51d7df23cde0ad96ee4dbd27c0f9311b82", "html_url": "https://github.com/rust-lang/rust/commit/b3a4bc51d7df23cde0ad96ee4dbd27c0f9311b82"}], "stats": {"total": 1546, "additions": 936, "deletions": 610}, "files": [{"sha": "25cd960dbf1d0c232298fd6fee6f052f68392987", "filename": "compiler/rustc_attr/src/session_diagnostics.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fsession_diagnostics.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -223,14 +223,12 @@ impl<'a> SessionDiagnostic<'a> for UnsupportedLiteral {\n             error_code!(E0565),\n         );\n         if self.is_bytestr {\n-            if let Ok(lint_str) = sess.source_map().span_to_snippet(self.span) {\n-                diag.span_suggestion(\n-                    self.span,\n-                    fluent::attr::unsupported_literal_suggestion,\n-                    &lint_str[1..],\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n+            diag.span_suggestion(\n+                sess.source_map().start_point(self.span),\n+                fluent::attr::unsupported_literal_suggestion,\n+                \"\",\n+                Applicability::MaybeIncorrect,\n+            );\n         }\n         diag\n     }"}, {"sha": "dd9590016b990f27f98f64cd04cd49b3a3e005ea", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 113, "deletions": 3, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,5 +1,8 @@\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{\n+    Applicability, Diagnostic, DiagnosticBuilder, EmissionGuarantee, ErrorGuaranteed,\n+};\n use rustc_hir as hir;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n@@ -614,7 +617,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             \"trait `IndexMut` is required to modify indexed content, \\\n                                 but it is not implemented for `{ty}`\",\n                         ));\n-                        self.suggest_map_index_mut_alternatives(ty, &mut err);\n+                        self.suggest_map_index_mut_alternatives(ty, &mut err, span);\n                     }\n                     _ => (),\n                 }\n@@ -632,13 +635,120 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'_>,\n         err: &mut DiagnosticBuilder<'_, ErrorGuaranteed>,\n+        span: Span,\n     ) {\n         let Some(adt) = ty.ty_adt_def() else { return };\n         let did = adt.did();\n         if self.infcx.tcx.is_diagnostic_item(sym::HashMap, did)\n             || self.infcx.tcx.is_diagnostic_item(sym::BTreeMap, did)\n         {\n-            err.help(format!(\"to modify a `{ty}`, use `.get_mut()`, `.insert()` or the entry API\"));\n+            struct V<'a, 'b, 'tcx, G: EmissionGuarantee> {\n+                assign_span: Span,\n+                err: &'a mut DiagnosticBuilder<'b, G>,\n+                ty: Ty<'tcx>,\n+                suggested: bool,\n+            }\n+            impl<'a, 'b: 'a, 'hir, 'tcx, G: EmissionGuarantee> Visitor<'hir> for V<'a, 'b, 'tcx, G> {\n+                fn visit_stmt(&mut self, stmt: &'hir hir::Stmt<'hir>) {\n+                    hir::intravisit::walk_stmt(self, stmt);\n+                    let expr = match stmt.kind {\n+                        hir::StmtKind::Semi(expr) | hir::StmtKind::Expr(expr) => expr,\n+                        hir::StmtKind::Local(hir::Local { init: Some(expr), .. }) => expr,\n+                        _ => {\n+                            return;\n+                        }\n+                    };\n+                    if let hir::ExprKind::Assign(place, rv, _sp) = expr.kind\n+                        && let hir::ExprKind::Index(val, index) = place.kind\n+                        && (expr.span == self.assign_span || place.span == self.assign_span)\n+                    {\n+                        // val[index] = rv;\n+                        // ---------- place\n+                        self.err.multipart_suggestions(\n+                            &format!(\n+                                \"to modify a `{}`, use `.get_mut()`, `.insert()` or the entry API\",\n+                                self.ty,\n+                            ),\n+                            vec![\n+                                vec![ // val.insert(index, rv);\n+                                    (\n+                                        val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                        \".insert(\".to_string(),\n+                                    ),\n+                                    (\n+                                        index.span.shrink_to_hi().with_hi(rv.span.lo()),\n+                                        \", \".to_string(),\n+                                    ),\n+                                    (rv.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                                vec![ // val.get_mut(index).map(|v| { *v = rv; });\n+                                    (\n+                                        val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                        \".get_mut(\".to_string(),\n+                                    ),\n+                                    (\n+                                        index.span.shrink_to_hi().with_hi(place.span.hi()),\n+                                        \").map(|val| { *val\".to_string(),\n+                                    ),\n+                                    (\n+                                        rv.span.shrink_to_hi(),\n+                                        \"; })\".to_string(),\n+                                    ),\n+                                ],\n+                                vec![ // let x = val.entry(index).or_insert(rv);\n+                                    (val.span.shrink_to_lo(), \"let val = \".to_string()),\n+                                    (\n+                                        val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                        \".entry(\".to_string(),\n+                                    ),\n+                                    (\n+                                        index.span.shrink_to_hi().with_hi(rv.span.lo()),\n+                                        \").or_insert(\".to_string(),\n+                                    ),\n+                                    (rv.span.shrink_to_hi(), \")\".to_string()),\n+                                ],\n+                            ].into_iter(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        self.suggested = true;\n+                    } else if let hir::ExprKind::MethodCall(_path, args @ [_, ..], sp) = expr.kind\n+                        && let hir::ExprKind::Index(val, index) = args[0].kind\n+                        && expr.span == self.assign_span\n+                    {\n+                        // val[index].path(args..);\n+                        self.err.multipart_suggestion(\n+                            &format!(\"to modify a `{}` use `.get_mut()`\", self.ty),\n+                            vec![\n+                                (\n+                                    val.span.shrink_to_hi().with_hi(index.span.lo()),\n+                                    \".get_mut(\".to_string(),\n+                                ),\n+                                (\n+                                    index.span.shrink_to_hi().with_hi(args[0].span.hi()),\n+                                    \").map(|val| val\".to_string(),\n+                                ),\n+                                (sp.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MachineApplicable,\n+                        );\n+                        self.suggested = true;\n+                    }\n+                }\n+            }\n+            let hir_map = self.infcx.tcx.hir();\n+            let def_id = self.body.source.def_id();\n+            let hir_id = hir_map.local_def_id_to_hir_id(def_id.as_local().unwrap());\n+            let node = hir_map.find(hir_id);\n+            let Some(hir::Node::Item(item)) = node else { return; };\n+            let hir::ItemKind::Fn(.., body_id) = item.kind else { return; };\n+            let body = self.infcx.tcx.hir().body(body_id);\n+            let mut v = V { assign_span: span, err, ty, suggested: false };\n+            v.visit_body(body);\n+            if !v.suggested {\n+                err.help(&format!(\n+                    \"to modify a `{ty}`, use `.get_mut()`, `.insert()` or the entry API\",\n+                ));\n+            }\n         }\n     }\n "}, {"sha": "d0a6f216858b61575238b6101f2a34fd151d8bd0", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1500,24 +1500,18 @@ fn vcall_visibility_metadata<'ll, 'tcx>(\n         // If there is not LTO and the visibility in public, we have to assume that the vtable can\n         // be seen from anywhere. With multiple CGUs, the vtable is quasi-public.\n         (Lto::No | Lto::ThinLocal, Visibility::Public, _)\n-        | (Lto::No, Visibility::Restricted(_) | Visibility::Invisible, false) => {\n-            VCallVisibility::Public\n-        }\n+        | (Lto::No, Visibility::Restricted(_), false) => VCallVisibility::Public,\n         // With LTO and a quasi-public visibility, the usages of the functions of the vtable are\n         // all known by the `LinkageUnit`.\n         // FIXME: LLVM only supports this optimization for `Lto::Fat` currently. Once it also\n         // supports `Lto::Thin` the `VCallVisibility` may have to be adjusted for those.\n         (Lto::Fat | Lto::Thin, Visibility::Public, _)\n-        | (\n-            Lto::ThinLocal | Lto::Thin | Lto::Fat,\n-            Visibility::Restricted(_) | Visibility::Invisible,\n-            false,\n-        ) => VCallVisibility::LinkageUnit,\n+        | (Lto::ThinLocal | Lto::Thin | Lto::Fat, Visibility::Restricted(_), false) => {\n+            VCallVisibility::LinkageUnit\n+        }\n         // If there is only one CGU, private vtables can only be seen by that CGU/translation unit\n         // and therefore we know of all usages of functions in the vtable.\n-        (_, Visibility::Restricted(_) | Visibility::Invisible, true) => {\n-            VCallVisibility::TranslationUnit\n-        }\n+        (_, Visibility::Restricted(_), true) => VCallVisibility::TranslationUnit,\n     };\n \n     let trait_ref_typeid = typeid_for_trait_ref(cx.tcx, trait_ref);"}, {"sha": "4601914c25f88b70e7b99300970259196d9389f7", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -74,7 +74,9 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n+    ecx.machine.check_alignment = false; // interning doesn't need to respect alignment\n     intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n+    // we leave alignment checks off, since this `ecx` will not be used for further evaluation anyway\n \n     debug!(\"eval_body_using_ecx done: {:?}\", *ret);\n     Ok(ret)"}, {"sha": "6c1e61fccca194619b81e82d4ade8e7e2f60b006", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -89,10 +89,10 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     /// exhaustion error.\n     ///\n     /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n-    pub steps_remaining: usize,\n+    pub(super) steps_remaining: usize,\n \n     /// The virtual call stack.\n-    pub(crate) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n+    pub(super) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n \n     /// We need to make sure consts never point to anything mutable, even recursively. That is\n     /// relied on for pattern matching on consts with references.\n@@ -103,7 +103,7 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) can_access_statics: bool,\n \n     /// Whether to check alignment during evaluation.\n-    check_alignment: bool,\n+    pub(super) check_alignment: bool,\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {"}, {"sha": "d182929c40066c3691176ee529487e48de05437d", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -293,7 +293,7 @@ fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n         // These are not visible outside crate; therefore\n         // stability markers are irrelevant, if even present.\n-        ty::Visibility::Restricted(..) | ty::Visibility::Invisible => true,\n+        ty::Visibility::Restricted(..) => true,\n     }\n }\n "}, {"sha": "aaa66deb2a3ecf98223c69477a5321ac3962bd8a", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -169,14 +169,10 @@ impl<'tcx> FieldDef {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest<'tcx> {\n         let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n-        // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n-        // `Visibility::Invisible` so we need to override `self.vis` if we're\n-        // dealing with an enum.\n         if is_enum {\n             data_uninhabitedness()\n         } else {\n             match self.vis {\n-                Visibility::Invisible => DefIdForest::empty(),\n                 Visibility::Restricted(from) => {\n                     let forest = DefIdForest::from_id(from);\n                     let iter = Some(forest).into_iter().chain(Some(data_uninhabitedness()));"}, {"sha": "ed04e7660339e639c24868b5f68aed921c35c19f", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -268,8 +268,6 @@ pub enum Visibility {\n     Public,\n     /// Visible only in the given crate-local module.\n     Restricted(DefId),\n-    /// Not visible anywhere in the local crate. This is the visibility of private external items.\n-    Invisible,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable)]\n@@ -366,8 +364,6 @@ impl Visibility {\n         let restriction = match self {\n             // Public items are visible everywhere.\n             Visibility::Public => return true,\n-            // Private items from other crates are visible nowhere.\n-            Visibility::Invisible => return false,\n             // Restricted items are visible in an arbitrary local module.\n             Visibility::Restricted(other) if other.krate != module.krate => return false,\n             Visibility::Restricted(module) => module,\n@@ -380,7 +376,6 @@ impl Visibility {\n     pub fn is_at_least<T: DefIdTree>(self, vis: Visibility, tree: T) -> bool {\n         let vis_restriction = match vis {\n             Visibility::Public => return self == Visibility::Public,\n-            Visibility::Invisible => return true,\n             Visibility::Restricted(module) => module,\n         };\n \n@@ -392,7 +387,6 @@ impl Visibility {\n         match self {\n             Visibility::Public => true,\n             Visibility::Restricted(def_id) => def_id.is_local(),\n-            Visibility::Invisible => false,\n         }\n     }\n "}, {"sha": "5d562f18a815814785602fff35961933b7b32d0a", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1731,7 +1731,6 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n         if !vis.is_at_least(self.required_visibility, self.tcx) {\n             let vis_descr = match vis {\n                 ty::Visibility::Public => \"public\",\n-                ty::Visibility::Invisible => \"private\",\n                 ty::Visibility::Restricted(vis_def_id) => {\n                     if vis_def_id == self.tcx.parent_module(hir_id).to_def_id() {\n                         \"private\""}, {"sha": "8f3b6009bd6ef8a5f31fa6387c5badaceb443faf", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -380,7 +380,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             has_attributes: !item.attrs.is_empty(),\n             root_span,\n             root_id,\n-            vis: Cell::new(vis),\n+            vis: Cell::new(Some(vis)),\n             used: Cell::new(false),\n         });\n \n@@ -588,7 +588,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             ast::UseTreeKind::Glob => {\n                 let kind = ImportKind::Glob {\n                     is_prelude: self.r.session.contains_name(&item.attrs, sym::prelude_import),\n-                    max_vis: Cell::new(ty::Visibility::Invisible),\n+                    max_vis: Cell::new(None),\n                 };\n                 self.r.visibilities.insert(self.r.local_def_id(id), vis);\n                 self.add_import(prefix, kind, use_tree.span, id, item, root_span, item.id, vis);\n@@ -650,7 +650,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         true,\n                         // The whole `use` item\n                         item,\n-                        ty::Visibility::Invisible,\n+                        ty::Visibility::Restricted(self.parent_scope.module.nearest_parent_mod()),\n                         root_span,\n                     );\n                 }\n@@ -885,7 +885,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             root_span: item.span,\n             span: item.span,\n             module_path: Vec::new(),\n-            vis: Cell::new(vis),\n+            vis: Cell::new(Some(vis)),\n             used: Cell::new(used),\n         });\n         self.r.potentially_unused_imports.push(import);\n@@ -1118,7 +1118,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 root_span: span,\n                 span,\n                 module_path: Vec::new(),\n-                vis: Cell::new(ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id())),\n+                vis: Cell::new(Some(ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id()))),\n                 used: Cell::new(false),\n             })\n         };"}, {"sha": "8b58b32b65649bae91276c92375e13ceefa86cfb", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -227,7 +227,7 @@ impl Resolver<'_> {\n         for import in self.potentially_unused_imports.iter() {\n             match import.kind {\n                 _ if import.used.get()\n-                    || import.vis.get().is_public()\n+                    || import.expect_vis().is_public()\n                     || import.span.is_dummy() =>\n                 {\n                     if let ImportKind::MacroUse = import.kind {"}, {"sha": "23c0ca108d38582e838522f8d5d1009ea86ba699", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -953,7 +953,10 @@ impl<'a> Resolver<'a> {\n         // Check if one of single imports can still define the name,\n         // if it can then our result is not determined and can be invalidated.\n         for single_import in &resolution.single_imports {\n-            if !self.is_accessible_from(single_import.vis.get(), parent_scope.module) {\n+            let Some(import_vis) = single_import.vis.get() else {\n+                continue;\n+            };\n+            if !self.is_accessible_from(import_vis, parent_scope.module) {\n                 continue;\n             }\n             let Some(module) = single_import.imported_module.get() else {\n@@ -1018,7 +1021,10 @@ impl<'a> Resolver<'a> {\n         // Check if one of glob imports can still define the name,\n         // if it can then our \"no resolution\" result is not determined and can be invalidated.\n         for glob_import in module.globs.borrow().iter() {\n-            if !self.is_accessible_from(glob_import.vis.get(), parent_scope.module) {\n+            let Some(import_vis) = glob_import.vis.get() else {\n+                continue;\n+            };\n+            if !self.is_accessible_from(import_vis, parent_scope.module) {\n                 continue;\n             }\n             let module = match glob_import.imported_module.get() {"}, {"sha": "c2491c6ebdec08892d03f255f2f991b4484b902a", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -52,8 +52,8 @@ pub enum ImportKind<'a> {\n     },\n     Glob {\n         is_prelude: bool,\n-        max_vis: Cell<ty::Visibility>, // The visibility of the greatest re-export.\n-                                       // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n+        max_vis: Cell<Option<ty::Visibility>>, // The visibility of the greatest re-export.\n+                                               // n.b. `max_vis` is only used in `finalize_import` to check for re-export errors.\n     },\n     ExternCrate {\n         source: Option<Symbol>,\n@@ -144,7 +144,7 @@ pub(crate) struct Import<'a> {\n     pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n-    pub vis: Cell<ty::Visibility>,\n+    pub vis: Cell<Option<ty::Visibility>>,\n     pub used: Cell<bool>,\n }\n \n@@ -159,6 +159,10 @@ impl<'a> Import<'a> {\n             _ => false,\n         }\n     }\n+\n+    pub(crate) fn expect_vis(&self) -> ty::Visibility {\n+        self.vis.get().expect(\"encountered cleared import visibility\")\n+    }\n }\n \n /// Records information about the resolution of a name in a namespace of a module.\n@@ -199,7 +203,7 @@ fn pub_use_of_private_extern_crate_hack(import: &Import<'_>, binding: &NameBindi\n                 import: Import { kind: ImportKind::ExternCrate { .. }, .. },\n                 ..\n             },\n-        ) => import.vis.get().is_public(),\n+        ) => import.expect_vis().is_public(),\n         _ => false,\n     }\n }\n@@ -212,17 +216,20 @@ impl<'a> Resolver<'a> {\n         binding: &'a NameBinding<'a>,\n         import: &'a Import<'a>,\n     ) -> &'a NameBinding<'a> {\n-        let vis = if binding.vis.is_at_least(import.vis.get(), self)\n+        let import_vis = import.expect_vis();\n+        let vis = if binding.vis.is_at_least(import_vis, self)\n             || pub_use_of_private_extern_crate_hack(import, binding)\n         {\n-            import.vis.get()\n+            import_vis\n         } else {\n             binding.vis\n         };\n \n         if let ImportKind::Glob { ref max_vis, .. } = import.kind {\n-            if vis == import.vis.get() || vis.is_at_least(max_vis.get(), self) {\n-                max_vis.set(vis)\n+            if vis == import_vis\n+                || max_vis.get().map_or(true, |max_vis| vis.is_at_least(max_vis, self))\n+            {\n+                max_vis.set(Some(vis))\n             }\n         }\n \n@@ -536,7 +543,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         } else {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n-            let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n+            let orig_vis = import.vis.take();\n             let path_res =\n                 self.r.maybe_resolve_path(&import.module_path, None, &import.parent_scope);\n             import.vis.set(orig_vis);\n@@ -571,7 +578,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 if let Err(Undetermined) = source_bindings[ns].get() {\n                     // For better failure detection, pretend that the import will\n                     // not define any names while resolving its module path.\n-                    let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n+                    let orig_vis = import.vis.take();\n                     let binding = this.resolve_ident_in_module(\n                         module,\n                         source,\n@@ -620,7 +627,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// Optionally returns an unresolved import error. This error is buffered and used to\n     /// consolidate multiple unresolved import errors into a single diagnostic.\n     fn finalize_import(&mut self, import: &'b Import<'b>) -> Option<UnresolvedImportError> {\n-        let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n+        let orig_vis = import.vis.take();\n         let ignore_binding = match &import.kind {\n             ImportKind::Single { target_bindings, .. } => target_bindings[TypeNS].get(),\n             _ => None,\n@@ -727,9 +734,9 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         });\n                     }\n                 }\n-                if !is_prelude &&\n-                   max_vis.get() != ty::Visibility::Invisible && // Allow empty globs.\n-                   !max_vis.get().is_at_least(import.vis.get(), &*self.r)\n+                if !is_prelude\n+                    && let Some(max_vis) = max_vis.get()\n+                    && !max_vis.is_at_least(import.expect_vis(), &*self.r)\n                 {\n                     let msg = \"glob import doesn't reexport anything because no candidate is public enough\";\n                     self.r.lint_buffer.buffer_lint(UNUSED_IMPORTS, import.id, import.span, msg);\n@@ -742,7 +749,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut all_ns_err = true;\n         self.r.per_ns(|this, ns| {\n             if !type_ns_only || ns == TypeNS {\n-                let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n+                let orig_vis = import.vis.take();\n                 let binding = this.resolve_ident_in_module(\n                     module,\n                     ident,\n@@ -906,8 +913,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         let mut crate_private_reexport = false;\n         self.r.per_ns(|this, ns| {\n             if let Ok(binding) = source_bindings[ns].get() {\n-                let vis = import.vis.get();\n-                if !binding.vis.is_at_least(vis, &*this) {\n+                if !binding.vis.is_at_least(import.expect_vis(), &*this) {\n                     reexport_error = Some((ns, binding));\n                     if let ty::Visibility::Restricted(binding_def_id) = binding.vis {\n                         if binding_def_id.is_top_level_module() {"}, {"sha": "8bb8c7ac51559c6ae164c2c5c6ad3c622bfb4c80", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1299,7 +1299,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // local binding\n                     if let hir::def::Res::Local(hir_id) = path.res {\n                         let span = tcx.hir().span(hir_id);\n-                        let snippet = tcx.sess.source_map().span_to_snippet(span);\n                         let filename = tcx.sess.source_map().span_to_filename(span);\n \n                         let parent_node =\n@@ -1309,22 +1308,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             concrete_type,\n                         );\n \n-                        match (filename, parent_node, snippet) {\n+                        match (filename, parent_node) {\n                             (\n                                 FileName::Real(_),\n                                 Node::Local(hir::Local {\n                                     source: hir::LocalSource::Normal,\n                                     ty,\n                                     ..\n                                 }),\n-                                Ok(ref snippet),\n                             ) => {\n+                                let type_span = ty.map(|ty| ty.span.with_lo(span.hi())).unwrap_or(span.shrink_to_hi());\n                                 err.span_suggestion(\n                                     // account for `let x: _ = 42;`\n-                                    //                  ^^^^\n-                                    span.to(ty.as_ref().map(|ty| ty.span).unwrap_or(span)),\n+                                    //                   ^^^\n+                                    type_span,\n                                     &msg,\n-                                    format!(\"{}: {}\", snippet, concrete_type),\n+                                    format!(\": {concrete_type}\"),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }"}, {"sha": "6aa1c915542e24bccfbbbdf69771827eddef9854", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -762,16 +762,13 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         // If there is a single unbound associated type and a single excess generic param\n         // suggest replacing the generic param with the associated type bound\n         if provided_args_matches_unbound_traits && !unbound_types.is_empty() {\n-            let mut suggestions = vec![];\n             let unused_generics = &self.gen_args.args[self.num_expected_type_or_const_args()..];\n-            for (potential, name) in iter::zip(unused_generics, &unbound_types) {\n-                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(potential.span()) {\n-                    suggestions.push((potential.span(), format!(\"{} = {}\", name, snippet)));\n-                }\n-            }\n+            let suggestions = iter::zip(unused_generics, &unbound_types)\n+                .map(|(potential, name)| (potential.span().shrink_to_lo(), format!(\"{name} = \")))\n+                .collect::<Vec<_>>();\n \n             if !suggestions.is_empty() {\n-                err.multipart_suggestion(\n+                err.multipart_suggestion_verbose(\n                     &format!(\n                         \"replace the generic bound{s} with the associated type{s}\",\n                         s = pluralize!(unbound_types.len())"}, {"sha": "65e323c9e00c3b1f5e2b5c452aea83c976e4da9b", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1485,7 +1485,7 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// Converts a `&[T]` into a `Box<[T]>`\n     ///\n     /// This conversion allocates on the heap\n-    /// and performs a copy of `slice`.\n+    /// and performs a copy of `slice` and its contents.\n     ///\n     /// # Examples\n     /// ```rust"}, {"sha": "4a8efe15e596ba8ffd0a32b8d3b29c4ea8f010ce", "filename": "library/core/src/error.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fcore%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fcore%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ferror.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,17 +1,6 @@\n #![doc = include_str!(\"error.md\")]\n #![unstable(feature = \"error_in_core\", issue = \"none\")]\n \n-// A note about crates and the facade:\n-//\n-// Originally, the `Error` trait was defined in libcore, and the impls\n-// were scattered about. However, coherence objected to this\n-// arrangement, because to create the blanket impls for `Box` required\n-// knowing that `&str: !Error`, and we have no means to deal with that\n-// sort of conflict just now. Therefore, for the time being, we have\n-// moved the `Error` trait into libstd. As we evolve a sol'n to the\n-// coherence challenge (e.g., specialization, neg impls, etc) we can\n-// reconsider what crate these items belong in.\n-\n #[cfg(test)]\n mod tests;\n \n@@ -30,12 +19,12 @@ use crate::fmt::{Debug, Display};\n /// assert_eq!(err.to_string(), \"invalid digit found in string\");\n /// ```\n ///\n-/// Errors may provide cause chain information. [`Error::source()`] is generally\n+/// Errors may provide cause information. [`Error::source()`] is generally\n /// used when errors cross \"abstraction boundaries\". If one module must report\n /// an error that is caused by an error from a lower-level module, it can allow\n /// accessing that error via [`Error::source()`]. This makes it possible for the\n /// high-level module to provide its own errors while also revealing some of the\n-/// implementation for debugging via `source` chains.\n+/// implementation for debugging.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[rustc_has_incoherent_inherent_impls]\n@@ -182,8 +171,8 @@ pub trait Error: Debug + Display {\n     /// }\n     ///\n     /// impl std::error::Error for Error {\n-    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-    ///         req\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand\n     ///             .provide_ref::<MyBacktrace>(&self.backtrace)\n     ///             .provide_ref::<dyn std::error::Error + 'static>(&self.source);\n     ///     }\n@@ -201,16 +190,16 @@ pub trait Error: Debug + Display {\n     /// ```\n     #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n     #[allow(unused_variables)]\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {}\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {}\n }\n \n #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n impl<E> Provider for E\n where\n     E: Error + ?Sized,\n {\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-        self.provide(req)\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        self.provide(demand)\n     }\n }\n \n@@ -397,7 +386,7 @@ impl dyn Error {\n     /// // let err : Box<Error> = b.into(); // or\n     /// let err = &b as &(dyn Error);\n     ///\n-    /// let mut iter = err.chain();\n+    /// let mut iter = err.sources();\n     ///\n     /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n     /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n@@ -406,8 +395,19 @@ impl dyn Error {\n     /// ```\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n-    pub fn chain(&self) -> Chain<'_> {\n-        Chain { current: Some(self) }\n+    pub fn sources(&self) -> Source<'_> {\n+        // You may think this method would be better in the Error trait, and you'd be right.\n+        // Unfortunately that doesn't work, not because of the object safety rules but because we\n+        // save a reference to self in Sources below as a trait object. If this method was\n+        // declared in Error, then self would have the type &T where T is some concrete type which\n+        // implements Error. We would need to coerce self to have type &dyn Error, but that requires\n+        // that Self has a known size (i.e., Self: Sized). We can't put that bound on Error\n+        // since that would forbid Error trait objects, and we can't put that bound on the method\n+        // because that means the method can't be called on trait objects (we'd also need the\n+        // 'static bound, but that isn't allowed because methods with bounds on Self other than\n+        // Sized are not object-safe). Requiring an Unsize bound is not backwards compatible.\n+\n+        Source { current: Some(self) }\n     }\n }\n \n@@ -417,12 +417,12 @@ impl dyn Error {\n /// its sources, use `skip(1)`.\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n-pub struct Chain<'a> {\n+pub struct Source<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n-impl<'a> Iterator for Chain<'a> {\n+impl<'a> Iterator for Source<'a> {\n     type Item = &'a (dyn Error + 'static);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -448,8 +448,8 @@ impl<'a, T: Error + ?Sized> Error for &'a T {\n         Error::source(&**self)\n     }\n \n-    fn provide<'b>(&'b self, req: &mut Demand<'b>) {\n-        Error::provide(&**self, req);\n+    fn provide<'b>(&'b self, demand: &mut Demand<'b>) {\n+        Error::provide(&**self, demand);\n     }\n }\n "}, {"sha": "e45059595362f00c7fc348a2e87b50f691ee3d76", "filename": "library/std/src/error.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,17 +1,6 @@\n #![doc = include_str!(\"../../core/src/error.md\")]\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-// A note about crates and the facade:\n-//\n-// Originally, the `Error` trait was defined in libcore, and the impls\n-// were scattered about. However, coherence objected to this\n-// arrangement, because to create the blanket impls for `Box` required\n-// knowing that `&str: !Error`, and we have no means to deal with that\n-// sort of conflict just now. Therefore, for the time being, we have\n-// moved the `Error` trait into libstd. As we evolve a sol'n to the\n-// coherence challenge (e.g., specialization, neg impls, etc) we can\n-// reconsider what crate these items belong in.\n-\n #[cfg(test)]\n mod tests;\n \n@@ -69,12 +58,12 @@ pub use core::error::Error;\n /// assert_eq!(err.to_string(), \"invalid digit found in string\");\n /// ```\n ///\n-/// Errors may provide cause chain information. [`Error::source()`] is generally\n+/// Errors may provide cause information. [`Error::source()`] is generally\n /// used when errors cross \"abstraction boundaries\". If one module must report\n /// an error that is caused by an error from a lower-level module, it can allow\n /// accessing that error via [`Error::source()`]. This makes it possible for the\n /// high-level module to provide its own errors while also revealing some of the\n-/// implementation for debugging via `source` chains.\n+/// implementation for debugging.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"Error\")]\n #[cfg(bootstrap)]\n@@ -221,8 +210,8 @@ pub trait Error: Debug + Display {\n     /// }\n     ///\n     /// impl std::error::Error for Error {\n-    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-    ///         req\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand\n     ///             .provide_ref::<MyBacktrace>(&self.backtrace)\n     ///             .provide_ref::<dyn std::error::Error + 'static>(&self.source);\n     ///     }\n@@ -240,14 +229,14 @@ pub trait Error: Debug + Display {\n     /// ```\n     #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n     #[allow(unused_variables)]\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {}\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {}\n }\n \n #[cfg(bootstrap)]\n #[unstable(feature = \"error_generic_member_access\", issue = \"99301\")]\n impl<'b> Provider for dyn Error + 'b {\n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-        self.provide(req)\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        self.provide(demand)\n     }\n }\n \n@@ -659,8 +648,8 @@ impl<'a, T: Error + ?Sized> Error for &'a T {\n         Error::source(&**self)\n     }\n \n-    fn provide<'b>(&'b self, req: &mut Demand<'b>) {\n-        Error::provide(&**self, req);\n+    fn provide<'b>(&'b self, demand: &mut Demand<'b>) {\n+        Error::provide(&**self, demand);\n     }\n }\n \n@@ -681,8 +670,8 @@ impl<T: Error + ?Sized> Error for Arc<T> {\n         Error::source(&**self)\n     }\n \n-    fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-        Error::provide(&**self, req);\n+    fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+        Error::provide(&**self, demand);\n     }\n }\n \n@@ -976,7 +965,7 @@ impl dyn Error {\n     /// // let err : Box<Error> = b.into(); // or\n     /// let err = &b as &(dyn Error);\n     ///\n-    /// let mut iter = err.chain();\n+    /// let mut iter = err.sources();\n     ///\n     /// assert_eq!(\"B\".to_string(), iter.next().unwrap().to_string());\n     /// assert_eq!(\"A\".to_string(), iter.next().unwrap().to_string());\n@@ -985,8 +974,19 @@ impl dyn Error {\n     /// ```\n     #[unstable(feature = \"error_iter\", issue = \"58520\")]\n     #[inline]\n-    pub fn chain(&self) -> Chain<'_> {\n-        Chain { current: Some(self) }\n+    pub fn sources(&self) -> Sources<'_> {\n+        // You may think this method would be better in the Error trait, and you'd be right.\n+        // Unfortunately that doesn't work, not because of the object safety rules but because we\n+        // save a reference to self in Sources below as a trait object. If this method was\n+        // declared in Error, then self would have the type &T where T is some concrete type which\n+        // implements Error. We would need to coerce self to have type &dyn Error, but that requires\n+        // that Self has a known size (i.e., Self: Sized). We can't put that bound on Error\n+        // since that would forbid Error trait objects, and we can't put that bound on the method\n+        // because that means the method can't be called on trait objects (we'd also need the\n+        // 'static bound, but that isn't allowed because methods with bounds on Self other than\n+        // Sized are not object-safe). Requiring an Unsize bound is not backwards compatible.\n+\n+        Sources { current: Some(self) }\n     }\n }\n \n@@ -997,13 +997,13 @@ impl dyn Error {\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n #[derive(Clone, Debug)]\n #[cfg(bootstrap)]\n-pub struct Chain<'a> {\n+pub struct Sources<'a> {\n     current: Option<&'a (dyn Error + 'static)>,\n }\n \n #[cfg(bootstrap)]\n #[unstable(feature = \"error_iter\", issue = \"58520\")]\n-impl<'a> Iterator for Chain<'a> {\n+impl<'a> Iterator for Sources<'a> {\n     type Item = &'a (dyn Error + 'static);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -1043,8 +1043,8 @@ impl dyn Error + Send + Sync {\n \n /// An error reporter that prints an error and its sources.\n ///\n-/// Report also exposes configuration options for formatting the error chain, either entirely on a\n-/// single line, or in multi-line format with each cause in the error chain on a new line.\n+/// Report also exposes configuration options for formatting the error sources, either entirely on a\n+/// single line, or in multi-line format with each source on a new line.\n ///\n /// `Report` only requires that the wrapped error implement `Error`. It doesn't require that the\n /// wrapped error be `Send`, `Sync`, or `'static`.\n@@ -1389,7 +1389,7 @@ impl<E> Report<E> {\n     ///\n     /// **Note**: Report will search for the first `Backtrace` it can find starting from the\n     /// outermost error. In this example it will display the backtrace from the second error in the\n-    /// chain, `SuperErrorSideKick`.\n+    /// sources, `SuperErrorSideKick`.\n     ///\n     /// ```rust\n     /// #![feature(error_reporter)]\n@@ -1427,9 +1427,8 @@ impl<E> Report<E> {\n     /// }\n     ///\n     /// impl Error for SuperErrorSideKick {\n-    ///     fn provide<'a>(&'a self, req: &mut Demand<'a>) {\n-    ///         req\n-    ///             .provide_ref::<Backtrace>(&self.backtrace);\n+    ///     fn provide<'a>(&'a self, demand: &mut Demand<'a>) {\n+    ///         demand.provide_ref::<Backtrace>(&self.backtrace);\n     ///     }\n     /// }\n     ///\n@@ -1486,7 +1485,7 @@ where\n         let backtrace = backtrace.or_else(|| {\n             self.error\n                 .source()\n-                .map(|source| source.chain().find_map(|source| source.request_ref()))\n+                .map(|source| source.sources().find_map(|source| source.request_ref()))\n                 .flatten()\n         });\n         backtrace\n@@ -1497,7 +1496,7 @@ where\n     fn fmt_singleline(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{}\", self.error)?;\n \n-        let sources = self.error.source().into_iter().flat_map(<dyn Error>::chain);\n+        let sources = self.error.source().into_iter().flat_map(<dyn Error>::sources);\n \n         for cause in sources {\n             write!(f, \": {cause}\")?;\n@@ -1518,7 +1517,7 @@ where\n \n             let multiple = cause.source().is_some();\n \n-            for (ind, error) in cause.chain().enumerate() {\n+            for (ind, error) in cause.sources().enumerate() {\n                 writeln!(f)?;\n                 let mut indented = Indented { inner: f };\n                 if multiple {"}, {"sha": "e1ab06b0d0f69fc8eb77fc65e838970ce7c191a7", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -13,7 +13,7 @@ mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n use crate::sys::fs as fs_imp;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n@@ -703,8 +703,8 @@ impl Read for File {\n         self.inner.read_vectored(bufs)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.inner.read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(cursor)\n     }\n \n     #[inline]\n@@ -755,8 +755,8 @@ impl Read for &File {\n         self.inner.read(buf)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.inner.read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.inner.read_buf(cursor)\n     }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {"}, {"sha": "88ad92d8a985971134ba3171a952547fa6003e9e", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,7 +2,7 @@ mod buffer;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n+    self, BorrowedCursor, BufRead, IoSliceMut, Read, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n };\n use buffer::Buffer;\n \n@@ -266,21 +266,21 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.pos() == self.buf.filled() && buf.remaining() >= self.capacity() {\n+        if self.buf.pos() == self.buf.filled() && cursor.capacity() >= self.capacity() {\n             self.discard_buffer();\n-            return self.inner.read_buf(buf);\n+            return self.inner.read_buf(cursor);\n         }\n \n-        let prev = buf.filled_len();\n+        let prev = cursor.written();\n \n         let mut rem = self.fill_buf()?;\n-        rem.read_buf(buf)?;\n+        rem.read_buf(cursor.reborrow())?;\n \n-        self.consume(buf.filled_len() - prev); //slice impl of read_buf known to never unfill buf\n+        self.consume(cursor.written() - prev); //slice impl of read_buf known to never unfill buf\n \n         Ok(())\n     }"}, {"sha": "867c22c6041e73b560f2298c48cf51821e9d7947", "filename": "library/std/src/io/buffered/bufreader/buffer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader%2Fbuffer.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -9,7 +9,7 @@\n /// that user code which wants to do reads from a `BufReader` via `buffer` + `consume` can do so\n /// without encountering any runtime bounds checks.\n use crate::cmp;\n-use crate::io::{self, Read, ReadBuf};\n+use crate::io::{self, BorrowedBuf, Read};\n use crate::mem::MaybeUninit;\n \n pub struct Buffer {\n@@ -93,11 +93,15 @@ impl Buffer {\n         if self.pos >= self.filled {\n             debug_assert!(self.pos == self.filled);\n \n-            let mut readbuf = ReadBuf::uninit(&mut self.buf);\n+            let mut buf = BorrowedBuf::from(&mut *self.buf);\n+            // SAFETY: `self.filled` bytes will always have been initialized.\n+            unsafe {\n+                buf.set_init(self.filled);\n+            }\n \n-            reader.read_buf(&mut readbuf)?;\n+            reader.read_buf(buf.unfilled())?;\n \n-            self.filled = readbuf.filled_len();\n+            self.filled = buf.len();\n             self.pos = 0;\n         }\n         Ok(self.buffer())"}, {"sha": "bd6d95242ad94e4b04bfda9951c624da84a2ef23", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,5 +1,7 @@\n use crate::io::prelude::*;\n-use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, ReadBuf, SeekFrom};\n+use crate::io::{\n+    self, BorrowedBuf, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom,\n+};\n use crate::mem::MaybeUninit;\n use crate::panic;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n@@ -61,48 +63,48 @@ fn test_buffered_reader_read_buf() {\n     let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n     let mut reader = BufReader::with_capacity(2, inner);\n \n-    let mut buf = [MaybeUninit::uninit(); 3];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 3];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [5, 6, 7]);\n     assert_eq!(reader.buffer(), []);\n \n-    let mut buf = [MaybeUninit::uninit(); 2];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 2];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [0, 1]);\n     assert_eq!(reader.buffer(), []);\n \n-    let mut buf = [MaybeUninit::uninit(); 1];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [2]);\n     assert_eq!(reader.buffer(), [3]);\n \n-    let mut buf = [MaybeUninit::uninit(); 3];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 3];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [3]);\n     assert_eq!(reader.buffer(), []);\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [3, 4]);\n     assert_eq!(reader.buffer(), []);\n \n     buf.clear();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n-    assert_eq!(buf.filled_len(), 0);\n+    assert!(buf.filled().is_empty());\n }\n \n #[test]"}, {"sha": "38b98afffa16887c40adc1d3d279ab767aec8a9c", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,4 +1,4 @@\n-use super::{BufWriter, ErrorKind, Read, ReadBuf, Result, Write, DEFAULT_BUF_SIZE};\n+use super::{BorrowedBuf, BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -97,37 +97,39 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n \n         loop {\n             let buf = writer.buffer_mut();\n-            let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+            let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n \n-            // SAFETY: init is either 0 or the initialized_len of the previous iteration\n             unsafe {\n-                read_buf.assume_init(init);\n+                // SAFETY: init is either 0 or the init_len from the previous iteration.\n+                read_buf.set_init(init);\n             }\n \n             if read_buf.capacity() >= DEFAULT_BUF_SIZE {\n-                match reader.read_buf(&mut read_buf) {\n+                let mut cursor = read_buf.unfilled();\n+                match reader.read_buf(cursor.reborrow()) {\n                     Ok(()) => {\n-                        let bytes_read = read_buf.filled_len();\n+                        let bytes_read = cursor.written();\n \n                         if bytes_read == 0 {\n                             return Ok(len);\n                         }\n \n-                        init = read_buf.initialized_len() - bytes_read;\n+                        init = read_buf.init_len() - bytes_read;\n+                        len += bytes_read as u64;\n \n-                        // SAFETY: ReadBuf guarantees all of its filled bytes are init\n+                        // SAFETY: BorrowedBuf guarantees all of its filled bytes are init\n                         unsafe { buf.set_len(buf.len() + bytes_read) };\n-                        len += bytes_read as u64;\n+\n                         // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                         // This will occur if the reader returns short reads\n-                        continue;\n                     }\n-                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                     Err(e) => return Err(e),\n                 }\n+            } else {\n+                writer.flush_buf()?;\n+                init = 0;\n             }\n-\n-            writer.flush_buf()?;\n         }\n     }\n }\n@@ -136,13 +138,13 @@ fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n     reader: &mut R,\n     writer: &mut W,\n ) -> Result<u64> {\n-    let mut buf = [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n     let mut len = 0;\n \n     loop {\n-        match reader.read_buf(&mut buf) {\n+        match reader.read_buf(buf.unfilled()) {\n             Ok(()) => {}\n             Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),"}, {"sha": "d98ab021cadb156b58d35276b475ed9109fb6d71", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -5,7 +5,7 @@ use crate::io::prelude::*;\n \n use crate::alloc::Allocator;\n use crate::cmp;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n \n /// A `Cursor` wraps an in-memory buffer and provides it with a\n /// [`Seek`] implementation.\n@@ -323,12 +323,12 @@ where\n         Ok(n)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let prev_filled = buf.filled_len();\n+    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        let prev_written = cursor.written();\n \n-        Read::read_buf(&mut self.fill_buf()?, buf)?;\n+        Read::read_buf(&mut self.fill_buf()?, cursor.reborrow())?;\n \n-        self.pos += (buf.filled_len() - prev_filled) as u64;\n+        self.pos += (cursor.written() - prev_written) as u64;\n \n         Ok(())\n     }"}, {"sha": "29b09fcc5274e1f994f1a5033abf46b5493af397", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -573,6 +573,8 @@ impl Error {\n     /// println!(\"last OS error: {os_error:?}\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[doc(alias = \"GetLastError\")]\n+    #[doc(alias = \"errno\")]\n     #[must_use]\n     #[inline]\n     pub fn last_os_error() -> Error {"}, {"sha": "e5048dcc8acd91ec86e424bdcef3bedec0ad6de7", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -6,7 +6,7 @@ use crate::cmp;\n use crate::collections::VecDeque;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n+    self, BorrowedCursor, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n };\n use crate::mem;\n \n@@ -21,8 +21,8 @@ impl<R: Read + ?Sized> Read for &mut R {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        (**self).read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n     }\n \n     #[inline]\n@@ -125,8 +125,8 @@ impl<R: Read + ?Sized> Read for Box<R> {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        (**self).read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n     }\n \n     #[inline]\n@@ -249,11 +249,11 @@ impl Read for &[u8] {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let amt = cmp::min(buf.remaining(), self.len());\n+    fn read_buf(&mut self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        let amt = cmp::min(cursor.capacity(), self.len());\n         let (a, b) = self.split_at(amt);\n \n-        buf.append(a);\n+        cursor.append(a);\n \n         *self = b;\n         Ok(())\n@@ -427,10 +427,10 @@ impl<A: Allocator> Read for VecDeque<u8, A> {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         let (ref mut front, _) = self.as_slices();\n-        let n = cmp::min(buf.remaining(), front.len());\n-        Read::read_buf(front, buf)?;\n+        let n = cmp::min(cursor.capacity(), front.len());\n+        Read::read_buf(front, cursor)?;\n         self.drain(..n);\n         Ok(())\n     }"}, {"sha": "a9fa7b0a6aca0699a551c04743cd9bc02dc3c380", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 48, "deletions": 41, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -278,7 +278,7 @@ pub use self::{\n };\n \n #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-pub use self::readbuf::ReadBuf;\n+pub use self::readbuf::{BorrowedBuf, BorrowedCursor};\n pub(crate) use error::const_io_error;\n \n mod buffered;\n@@ -362,29 +362,30 @@ pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>\n             buf.reserve(32); // buf is full, need more space\n         }\n \n-        let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+        let mut read_buf: BorrowedBuf<'_> = buf.spare_capacity_mut().into();\n \n         // SAFETY: These bytes were initialized but not filled in the previous loop\n         unsafe {\n-            read_buf.assume_init(initialized);\n+            read_buf.set_init(initialized);\n         }\n \n-        match r.read_buf(&mut read_buf) {\n+        let mut cursor = read_buf.unfilled();\n+        match r.read_buf(cursor.reborrow()) {\n             Ok(()) => {}\n             Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         }\n \n-        if read_buf.filled_len() == 0 {\n+        if cursor.written() == 0 {\n             return Ok(buf.len() - start_len);\n         }\n \n         // store how much was initialized but not filled\n-        initialized = read_buf.initialized_len() - read_buf.filled_len();\n-        let new_len = read_buf.filled_len() + buf.len();\n+        initialized = cursor.init_ref().len();\n \n-        // SAFETY: ReadBuf's invariants mean this much memory is init\n+        // SAFETY: BorrowedBuf's invariants mean this much memory is initialized.\n         unsafe {\n+            let new_len = read_buf.filled().len() + buf.len();\n             buf.set_len(new_len);\n         }\n \n@@ -461,12 +462,15 @@ pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [\n     }\n }\n \n-pub(crate) fn default_read_buf<F>(read: F, buf: &mut ReadBuf<'_>) -> Result<()>\n+pub(crate) fn default_read_buf<F>(read: F, mut cursor: BorrowedCursor<'_>) -> Result<()>\n where\n     F: FnOnce(&mut [u8]) -> Result<usize>,\n {\n-    let n = read(buf.initialize_unfilled())?;\n-    buf.add_filled(n);\n+    let n = read(cursor.ensure_init().init_mut())?;\n+    unsafe {\n+        // SAFETY: we initialised using `ensure_init` so there is no uninit data to advance to.\n+        cursor.advance(n);\n+    }\n     Ok(())\n }\n \n@@ -803,30 +807,30 @@ pub trait Read {\n \n     /// Pull some bytes from this source into the specified buffer.\n     ///\n-    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to allow use\n+    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to allow use\n     /// with uninitialized buffers. The new data will be appended to any existing contents of `buf`.\n     ///\n     /// The default implementation delegates to `read`.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+    fn read_buf(&mut self, buf: BorrowedCursor<'_>) -> Result<()> {\n         default_read_buf(|b| self.read(b), buf)\n     }\n \n-    /// Read the exact number of bytes required to fill `buf`.\n+    /// Read the exact number of bytes required to fill `cursor`.\n     ///\n-    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to\n+    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`BorrowedCursor`] rather than `[u8]` to\n     /// allow use with uninitialized buffers.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-    fn read_buf_exact(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n-        while buf.remaining() > 0 {\n-            let prev_filled = buf.filled().len();\n-            match self.read_buf(buf) {\n+    fn read_buf_exact(&mut self, mut cursor: BorrowedCursor<'_>) -> Result<()> {\n+        while cursor.capacity() > 0 {\n+            let prev_written = cursor.written();\n+            match self.read_buf(cursor.reborrow()) {\n                 Ok(()) => {}\n                 Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n                 Err(e) => return Err(e),\n             }\n \n-            if buf.filled().len() == prev_filled {\n+            if cursor.written() == prev_written {\n                 return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill buffer\"));\n             }\n         }\n@@ -883,6 +887,10 @@ pub trait Read {\n     /// The yielded item is [`Ok`] if a byte was successfully read and [`Err`]\n     /// otherwise. EOF is mapped to returning [`None`] from this iterator.\n     ///\n+    /// The default implementation calls `read` for each byte,\n+    /// which can be very inefficient for data that's not in memory,\n+    /// such as [`File`]. Consider using a [`BufReader`] in such cases.\n+    ///\n     /// # Examples\n     ///\n     /// [`File`]s implement `Read`:\n@@ -895,10 +903,11 @@ pub trait Read {\n     /// ```no_run\n     /// use std::io;\n     /// use std::io::prelude::*;\n+    /// use std::io::BufReader;\n     /// use std::fs::File;\n     ///\n     /// fn main() -> io::Result<()> {\n-    ///     let f = File::open(\"foo.txt\")?;\n+    ///     let f = BufReader::new(File::open(\"foo.txt\")?);\n     ///\n     ///     for byte in f.bytes() {\n     ///         println!(\"{}\", byte.unwrap());\n@@ -2582,50 +2591,48 @@ impl<T: Read> Read for Take<T> {\n         Ok(n)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+    fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> Result<()> {\n         // Don't call into inner reader at all at EOF because it may still block\n         if self.limit == 0 {\n             return Ok(());\n         }\n \n-        let prev_filled = buf.filled_len();\n-\n-        if self.limit <= buf.remaining() as u64 {\n+        if self.limit <= buf.capacity() as u64 {\n             // if we just use an as cast to convert, limit may wrap around on a 32 bit target\n             let limit = cmp::min(self.limit, usize::MAX as u64) as usize;\n \n-            let extra_init = cmp::min(limit as usize, buf.initialized_len() - buf.filled_len());\n+            let extra_init = cmp::min(limit as usize, buf.init_ref().len());\n \n             // SAFETY: no uninit data is written to ibuf\n-            let ibuf = unsafe { &mut buf.unfilled_mut()[..limit] };\n+            let ibuf = unsafe { &mut buf.as_mut()[..limit] };\n \n-            let mut sliced_buf = ReadBuf::uninit(ibuf);\n+            let mut sliced_buf: BorrowedBuf<'_> = ibuf.into();\n \n             // SAFETY: extra_init bytes of ibuf are known to be initialized\n             unsafe {\n-                sliced_buf.assume_init(extra_init);\n+                sliced_buf.set_init(extra_init);\n             }\n \n-            self.inner.read_buf(&mut sliced_buf)?;\n+            let mut cursor = sliced_buf.unfilled();\n+            self.inner.read_buf(cursor.reborrow())?;\n \n-            let new_init = sliced_buf.initialized_len();\n-            let filled = sliced_buf.filled_len();\n+            let new_init = cursor.init_ref().len();\n+            let filled = sliced_buf.len();\n \n-            // sliced_buf / ibuf must drop here\n+            // cursor / sliced_buf / ibuf must drop here\n \n-            // SAFETY: new_init bytes of buf's unfilled buffer have been initialized\n             unsafe {\n-                buf.assume_init(new_init);\n+                // SAFETY: filled bytes have been filled and therefore initialized\n+                buf.advance(filled);\n+                // SAFETY: new_init bytes of buf's unfilled buffer have been initialized\n+                buf.set_init(new_init);\n             }\n \n-            buf.add_filled(filled);\n-\n             self.limit -= filled as u64;\n         } else {\n-            self.inner.read_buf(buf)?;\n-\n-            //inner may unfill\n-            self.limit -= buf.filled_len().saturating_sub(prev_filled) as u64;\n+            let written = buf.written();\n+            self.inner.read_buf(buf.reborrow())?;\n+            self.limit -= (buf.written() - written) as u64;\n         }\n \n         Ok(())"}, {"sha": "b1a84095f13fa7e9b1823935998794fa3713f481", "filename": "library/std/src/io/readbuf.rs", "status": "modified", "additions": 182, "deletions": 125, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -5,9 +5,10 @@ mod tests;\n \n use crate::cmp;\n use crate::fmt::{self, Debug, Formatter};\n-use crate::mem::MaybeUninit;\n+use crate::io::{Result, Write};\n+use crate::mem::{self, MaybeUninit};\n \n-/// A wrapper around a byte buffer that is incrementally filled and initialized.\n+/// A borrowed byte buffer which is incrementally filled and initialized.\n ///\n /// This type is a sort of \"double cursor\". It tracks three regions in the buffer: a region at the beginning of the\n /// buffer that has been logically filled with data, a region that has been initialized at some point but not yet\n@@ -20,230 +21,286 @@ use crate::mem::MaybeUninit;\n /// [ filled |         unfilled         ]\n /// [    initialized    | uninitialized ]\n /// ```\n-pub struct ReadBuf<'a> {\n-    buf: &'a mut [MaybeUninit<u8>],\n+///\n+/// A `BorrowedBuf` is created around some existing data (or capacity for data) via a unique reference\n+/// (`&mut`). The `BorrowedBuf` can be configured (e.g., using `clear` or `set_init`), but cannot be\n+/// directly written. To write into the buffer, use `unfilled` to create a `BorrowedCursor`. The cursor\n+/// has write-only access to the unfilled portion of the buffer (you can think of it as a\n+/// write-only iterator).\n+///\n+/// The lifetime `'data` is a bound on the lifetime of the underlying data.\n+pub struct BorrowedBuf<'data> {\n+    /// The buffer's underlying data.\n+    buf: &'data mut [MaybeUninit<u8>],\n+    /// The length of `self.buf` which is known to be filled.\n     filled: usize,\n-    initialized: usize,\n+    /// The length of `self.buf` which is known to be initialized.\n+    init: usize,\n }\n \n-impl Debug for ReadBuf<'_> {\n+impl Debug for BorrowedBuf<'_> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"ReadBuf\")\n-            .field(\"init\", &self.initialized())\n+        f.debug_struct(\"BorrowedBuf\")\n+            .field(\"init\", &self.init)\n             .field(\"filled\", &self.filled)\n             .field(\"capacity\", &self.capacity())\n             .finish()\n     }\n }\n \n-impl<'a> ReadBuf<'a> {\n-    /// Creates a new `ReadBuf` from a fully initialized buffer.\n+/// Create a new `BorrowedBuf` from a fully initialized slice.\n+impl<'data> From<&'data mut [u8]> for BorrowedBuf<'data> {\n     #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> ReadBuf<'a> {\n-        let len = buf.len();\n+    fn from(slice: &'data mut [u8]) -> BorrowedBuf<'data> {\n+        let len = slice.len();\n \n-        ReadBuf {\n-            //SAFETY: initialized data never becoming uninitialized is an invariant of ReadBuf\n-            buf: unsafe { (buf as *mut [u8]).as_uninit_slice_mut().unwrap() },\n+        BorrowedBuf {\n+            // SAFETY: initialized data never becoming uninitialized is an invariant of BorrowedBuf\n+            buf: unsafe { (slice as *mut [u8]).as_uninit_slice_mut().unwrap() },\n             filled: 0,\n-            initialized: len,\n+            init: len,\n         }\n     }\n+}\n \n-    /// Creates a new `ReadBuf` from a fully uninitialized buffer.\n-    ///\n-    /// Use `assume_init` if part of the buffer is known to be already initialized.\n+/// Create a new `BorrowedBuf` from an uninitialized buffer.\n+///\n+/// Use `set_init` if part of the buffer is known to be already initialized.\n+impl<'data> From<&'data mut [MaybeUninit<u8>]> for BorrowedBuf<'data> {\n     #[inline]\n-    pub fn uninit(buf: &'a mut [MaybeUninit<u8>]) -> ReadBuf<'a> {\n-        ReadBuf { buf, filled: 0, initialized: 0 }\n+    fn from(buf: &'data mut [MaybeUninit<u8>]) -> BorrowedBuf<'data> {\n+        BorrowedBuf { buf, filled: 0, init: 0 }\n     }\n+}\n \n+impl<'data> BorrowedBuf<'data> {\n     /// Returns the total capacity of the buffer.\n     #[inline]\n     pub fn capacity(&self) -> usize {\n         self.buf.len()\n     }\n \n+    /// Returns the length of the filled part of the buffer.\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.filled\n+    }\n+\n+    /// Returns the length of the initialized part of the buffer.\n+    #[inline]\n+    pub fn init_len(&self) -> usize {\n+        self.init\n+    }\n+\n     /// Returns a shared reference to the filled portion of the buffer.\n     #[inline]\n     pub fn filled(&self) -> &[u8] {\n-        //SAFETY: We only slice the filled part of the buffer, which is always valid\n+        // SAFETY: We only slice the filled part of the buffer, which is always valid\n         unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.filled]) }\n     }\n \n-    /// Returns a mutable reference to the filled portion of the buffer.\n+    /// Returns a cursor over the unfilled part of the buffer.\n     #[inline]\n-    pub fn filled_mut(&mut self) -> &mut [u8] {\n-        //SAFETY: We only slice the filled part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.filled]) }\n+    pub fn unfilled<'this>(&'this mut self) -> BorrowedCursor<'this> {\n+        BorrowedCursor {\n+            start: self.filled,\n+            // SAFETY: we never assign into `BorrowedCursor::buf`, so treating its\n+            // lifetime covariantly is safe.\n+            buf: unsafe {\n+                mem::transmute::<&'this mut BorrowedBuf<'data>, &'this mut BorrowedBuf<'this>>(self)\n+            },\n+        }\n     }\n \n-    /// Returns a shared reference to the initialized portion of the buffer.\n+    /// Clears the buffer, resetting the filled region to empty.\n     ///\n-    /// This includes the filled portion.\n+    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n     #[inline]\n-    pub fn initialized(&self) -> &[u8] {\n-        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.initialized]) }\n+    pub fn clear(&mut self) -> &mut Self {\n+        self.filled = 0;\n+        self\n     }\n \n-    /// Returns a mutable reference to the initialized portion of the buffer.\n+    /// Asserts that the first `n` bytes of the buffer are initialized.\n     ///\n-    /// This includes the filled portion.\n-    #[inline]\n-    pub fn initialized_mut(&mut self) -> &mut [u8] {\n-        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.initialized]) }\n-    }\n-\n-    /// Returns a mutable reference to the unfilled part of the buffer without ensuring that it has been fully\n-    /// initialized.\n+    /// `BorrowedBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n+    /// bytes than are already known to be initialized.\n     ///\n     /// # Safety\n     ///\n-    /// The caller must not de-initialize portions of the buffer that have already been initialized.\n+    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n     #[inline]\n-    pub unsafe fn unfilled_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n-        &mut self.buf[self.filled..]\n+    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {\n+        self.init = cmp::max(self.init, n);\n+        self\n     }\n+}\n \n-    /// Returns a mutable reference to the uninitialized part of the buffer.\n+/// A writeable view of the unfilled portion of a [`BorrowedBuf`](BorrowedBuf).\n+///\n+/// Provides access to the initialized and uninitialized parts of the underlying `BorrowedBuf`.\n+/// Data can be written directly to the cursor by using [`append`](BorrowedCursor::append) or\n+/// indirectly by getting a slice of part or all of the cursor and writing into the slice. In the\n+/// indirect case, the caller must call [`advance`](BorrowedCursor::advance) after writing to inform\n+/// the cursor how many bytes have been written.\n+///\n+/// Once data is written to the cursor, it becomes part of the filled portion of the underlying\n+/// `BorrowedBuf` and can no longer be accessed or re-written by the cursor. I.e., the cursor tracks\n+/// the unfilled part of the underlying `BorrowedBuf`.\n+///\n+/// The lifetime `'a` is a bound on the lifetime of the underlying buffer (which means it is a bound\n+/// on the data in that buffer by transitivity).\n+#[derive(Debug)]\n+pub struct BorrowedCursor<'a> {\n+    /// The underlying buffer.\n+    // Safety invariant: we treat the type of buf as covariant in the lifetime of `BorrowedBuf` when\n+    // we create a `BorrowedCursor`. This is only safe if we never replace `buf` by assigning into\n+    // it, so don't do that!\n+    buf: &'a mut BorrowedBuf<'a>,\n+    /// The length of the filled portion of the underlying buffer at the time of the cursor's\n+    /// creation.\n+    start: usize,\n+}\n+\n+impl<'a> BorrowedCursor<'a> {\n+    /// Reborrow this cursor by cloning it with a smaller lifetime.\n     ///\n-    /// It is safe to uninitialize any of these bytes.\n+    /// Since a cursor maintains unique access to its underlying buffer, the borrowed cursor is\n+    /// not accessible while the new cursor exists.\n     #[inline]\n-    pub fn uninitialized_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n-        &mut self.buf[self.initialized..]\n+    pub fn reborrow<'this>(&'this mut self) -> BorrowedCursor<'this> {\n+        BorrowedCursor {\n+            // SAFETY: we never assign into `BorrowedCursor::buf`, so treating its\n+            // lifetime covariantly is safe.\n+            buf: unsafe {\n+                mem::transmute::<&'this mut BorrowedBuf<'a>, &'this mut BorrowedBuf<'this>>(\n+                    self.buf,\n+                )\n+            },\n+            start: self.start,\n+        }\n     }\n \n-    /// Returns a mutable reference to the unfilled part of the buffer, ensuring it is fully initialized.\n-    ///\n-    /// Since `ReadBuf` tracks the region of the buffer that has been initialized, this is effectively \"free\" after\n-    /// the first use.\n+    /// Returns the available space in the cursor.\n     #[inline]\n-    pub fn initialize_unfilled(&mut self) -> &mut [u8] {\n-        // should optimize out the assertion\n-        self.initialize_unfilled_to(self.remaining())\n+    pub fn capacity(&self) -> usize {\n+        self.buf.capacity() - self.buf.filled\n     }\n \n-    /// Returns a mutable reference to the first `n` bytes of the unfilled part of the buffer, ensuring it is\n-    /// fully initialized.\n-    ///\n-    /// # Panics\n+    /// Returns the number of bytes written to this cursor since it was created from a `BorrowedBuf`.\n     ///\n-    /// Panics if `self.remaining()` is less than `n`.\n+    /// Note that if this cursor is a reborrowed clone of another, then the count returned is the\n+    /// count written via either cursor, not the count since the cursor was reborrowed.\n     #[inline]\n-    pub fn initialize_unfilled_to(&mut self, n: usize) -> &mut [u8] {\n-        assert!(self.remaining() >= n);\n-\n-        let extra_init = self.initialized - self.filled;\n-        // If we don't have enough initialized, do zeroing\n-        if n > extra_init {\n-            let uninit = n - extra_init;\n-            let unfilled = &mut self.uninitialized_mut()[0..uninit];\n-\n-            for byte in unfilled.iter_mut() {\n-                byte.write(0);\n-            }\n-\n-            // SAFETY: we just initialized uninit bytes, and the previous bytes were already init\n-            unsafe {\n-                self.assume_init(n);\n-            }\n-        }\n-\n-        let filled = self.filled;\n+    pub fn written(&self) -> usize {\n+        self.buf.filled - self.start\n+    }\n \n-        &mut self.initialized_mut()[filled..filled + n]\n+    /// Returns a shared reference to the initialized portion of the cursor.\n+    #[inline]\n+    pub fn init_ref(&self) -> &[u8] {\n+        // SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf.buf[self.buf.filled..self.buf.init]) }\n     }\n \n-    /// Returns the number of bytes at the end of the slice that have not yet been filled.\n+    /// Returns a mutable reference to the initialized portion of the cursor.\n     #[inline]\n-    pub fn remaining(&self) -> usize {\n-        self.capacity() - self.filled\n+    pub fn init_mut(&mut self) -> &mut [u8] {\n+        // SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe {\n+            MaybeUninit::slice_assume_init_mut(&mut self.buf.buf[self.buf.filled..self.buf.init])\n+        }\n     }\n \n-    /// Clears the buffer, resetting the filled region to empty.\n+    /// Returns a mutable reference to the uninitialized part of the cursor.\n     ///\n-    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n+    /// It is safe to uninitialize any of these bytes.\n     #[inline]\n-    pub fn clear(&mut self) -> &mut Self {\n-        self.set_filled(0) // The assertion in `set_filled` is optimized out\n+    pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf.buf[self.buf.init..]\n     }\n \n-    /// Increases the size of the filled region of the buffer.\n-    ///\n-    /// The number of initialized bytes is not changed.\n+    /// Returns a mutable reference to the whole cursor.\n     ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    /// The caller must not uninitialize any bytes in the initialized portion of the cursor.\n     #[inline]\n-    pub fn add_filled(&mut self, n: usize) -> &mut Self {\n-        self.set_filled(self.filled + n)\n+    pub unsafe fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf.buf[self.buf.filled..]\n     }\n \n-    /// Sets the size of the filled region of the buffer.\n+    /// Advance the cursor by asserting that `n` bytes have been filled.\n     ///\n-    /// The number of initialized bytes is not changed.\n+    /// After advancing, the `n` bytes are no longer accessible via the cursor and can only be\n+    /// accessed via the underlying buffer. I.e., the buffer's filled portion grows by `n` elements\n+    /// and its unfilled portion (and the capacity of this cursor) shrinks by `n` elements.\n     ///\n-    /// Note that this can be used to *shrink* the filled region of the buffer in addition to growing it (for\n-    /// example, by a `Read` implementation that compresses data in-place).\n-    ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    /// The caller must ensure that the first `n` bytes of the cursor have been properly\n+    /// initialised.\n+    #[inline]\n+    pub unsafe fn advance(&mut self, n: usize) -> &mut Self {\n+        self.buf.filled += n;\n+        self.buf.init = cmp::max(self.buf.init, self.buf.filled);\n+        self\n+    }\n+\n+    /// Initializes all bytes in the cursor.\n     #[inline]\n-    pub fn set_filled(&mut self, n: usize) -> &mut Self {\n-        assert!(n <= self.initialized);\n+    pub fn ensure_init(&mut self) -> &mut Self {\n+        for byte in self.uninit_mut() {\n+            byte.write(0);\n+        }\n+        self.buf.init = self.buf.capacity();\n \n-        self.filled = n;\n         self\n     }\n \n-    /// Asserts that the first `n` unfilled bytes of the buffer are initialized.\n+    /// Asserts that the first `n` unfilled bytes of the cursor are initialized.\n     ///\n-    /// `ReadBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n-    /// bytes than are already known to be initialized.\n+    /// `BorrowedBuf` assumes that bytes are never de-initialized, so this method does nothing when\n+    /// called with fewer bytes than are already known to be initialized.\n     ///\n     /// # Safety\n     ///\n-    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n+    /// The caller must ensure that the first `n` bytes of the buffer have already been initialized.\n     #[inline]\n-    pub unsafe fn assume_init(&mut self, n: usize) -> &mut Self {\n-        self.initialized = cmp::max(self.initialized, self.filled + n);\n+    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {\n+        self.buf.init = cmp::max(self.buf.init, self.buf.filled + n);\n         self\n     }\n \n-    /// Appends data to the buffer, advancing the written position and possibly also the initialized position.\n+    /// Appends data to the cursor, advancing position within its buffer.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `self.remaining()` is less than `buf.len()`.\n+    /// Panics if `self.capacity()` is less than `buf.len()`.\n     #[inline]\n     pub fn append(&mut self, buf: &[u8]) {\n-        assert!(self.remaining() >= buf.len());\n+        assert!(self.capacity() >= buf.len());\n \n         // SAFETY: we do not de-initialize any of the elements of the slice\n         unsafe {\n-            MaybeUninit::write_slice(&mut self.unfilled_mut()[..buf.len()], buf);\n+            MaybeUninit::write_slice(&mut self.as_mut()[..buf.len()], buf);\n         }\n \n         // SAFETY: We just added the entire contents of buf to the filled section.\n         unsafe {\n-            self.assume_init(buf.len());\n+            self.set_init(buf.len());\n         }\n-        self.add_filled(buf.len());\n+        self.buf.filled += buf.len();\n     }\n+}\n \n-    /// Returns the amount of bytes that have been filled.\n-    #[inline]\n-    pub fn filled_len(&self) -> usize {\n-        self.filled\n+impl<'a> Write for BorrowedCursor<'a> {\n+    fn write(&mut self, buf: &[u8]) -> Result<usize> {\n+        self.append(buf);\n+        Ok(buf.len())\n     }\n \n-    /// Returns the amount of bytes that have been initialized.\n-    #[inline]\n-    pub fn initialized_len(&self) -> usize {\n-        self.initialized\n+    fn flush(&mut self) -> Result<()> {\n+        Ok(())\n     }\n }"}, {"sha": "cc1b423f2dd0d32fecbf4d7d150af926d6dba2d0", "filename": "library/std/src/io/readbuf/tests.rs", "status": "modified", "additions": 107, "deletions": 113, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,181 +1,175 @@\n-use super::ReadBuf;\n+use super::BorrowedBuf;\n use crate::mem::MaybeUninit;\n \n-/// Test that ReadBuf has the correct numbers when created with new\n+/// Test that BorrowedBuf has the correct numbers when created with new\n #[test]\n fn new() {\n-    let mut buf = [0; 16];\n-    let rbuf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [0; 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.init_len(), 16);\n     assert_eq!(rbuf.capacity(), 16);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n }\n \n-/// Test that ReadBuf has the correct numbers when created with uninit\n+/// Test that BorrowedBuf has the correct numbers when created with uninit\n #[test]\n fn uninit() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.initialized_len(), 0);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.init_len(), 0);\n     assert_eq!(rbuf.capacity(), 16);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n }\n \n #[test]\n fn initialize_unfilled() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.initialize_unfilled();\n+    rbuf.unfilled().ensure_init();\n \n-    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.init_len(), 16);\n }\n \n #[test]\n-fn initialize_unfilled_to() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+fn addvance_filled() {\n+    let buf: &mut [_] = &mut [0; 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.initialize_unfilled_to(8);\n-\n-    assert_eq!(rbuf.initialized_len(), 8);\n-\n-    rbuf.initialize_unfilled_to(4);\n-\n-    assert_eq!(rbuf.initialized_len(), 8);\n-\n-    rbuf.set_filled(8);\n-\n-    rbuf.initialize_unfilled_to(6);\n-\n-    assert_eq!(rbuf.initialized_len(), 14);\n-\n-    rbuf.initialize_unfilled_to(8);\n-\n-    assert_eq!(rbuf.initialized_len(), 16);\n-}\n-\n-#[test]\n-fn add_filled() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.add_filled(1);\n-\n-    assert_eq!(rbuf.filled_len(), 1);\n-    assert_eq!(rbuf.remaining(), 15);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn add_filled_panic() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n-\n-    rbuf.add_filled(1);\n-}\n-\n-#[test]\n-fn set_filled() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.set_filled(16);\n-\n-    assert_eq!(rbuf.filled_len(), 16);\n-    assert_eq!(rbuf.remaining(), 0);\n-\n-    rbuf.set_filled(6);\n-\n-    assert_eq!(rbuf.filled_len(), 6);\n-    assert_eq!(rbuf.remaining(), 10);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn set_filled_panic() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    unsafe {\n+        rbuf.unfilled().advance(1);\n+    }\n \n-    rbuf.set_filled(16);\n+    assert_eq!(rbuf.filled().len(), 1);\n+    assert_eq!(rbuf.unfilled().capacity(), 15);\n }\n \n #[test]\n fn clear() {\n-    let mut buf = [255; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [255; 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.set_filled(16);\n+    unsafe {\n+        rbuf.unfilled().advance(16);\n+    }\n \n-    assert_eq!(rbuf.filled_len(), 16);\n-    assert_eq!(rbuf.remaining(), 0);\n+    assert_eq!(rbuf.filled().len(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 0);\n \n     rbuf.clear();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n \n-    assert_eq!(rbuf.initialized(), [255; 16]);\n+    assert_eq!(rbuf.unfilled().init_ref(), [255; 16]);\n }\n \n #[test]\n-fn assume_init() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+fn set_init() {\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n     unsafe {\n-        rbuf.assume_init(8);\n+        rbuf.set_init(8);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n \n-    rbuf.add_filled(4);\n+    unsafe {\n+        rbuf.unfilled().advance(4);\n+    }\n \n     unsafe {\n-        rbuf.assume_init(2);\n+        rbuf.set_init(2);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n \n     unsafe {\n-        rbuf.assume_init(8);\n+        rbuf.set_init(8);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 12);\n+    assert_eq!(rbuf.init_len(), 8);\n }\n \n #[test]\n fn append() {\n-    let mut buf = [MaybeUninit::new(255); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::new(255); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n \n-    rbuf.append(&[0; 8]);\n+    rbuf.unfilled().append(&[0; 8]);\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n-    assert_eq!(rbuf.filled_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n+    assert_eq!(rbuf.filled().len(), 8);\n     assert_eq!(rbuf.filled(), [0; 8]);\n \n     rbuf.clear();\n \n-    rbuf.append(&[1; 16]);\n+    rbuf.unfilled().append(&[1; 16]);\n \n-    assert_eq!(rbuf.initialized_len(), 16);\n-    assert_eq!(rbuf.filled_len(), 16);\n+    assert_eq!(rbuf.init_len(), 16);\n+    assert_eq!(rbuf.filled().len(), 16);\n     assert_eq!(rbuf.filled(), [1; 16]);\n }\n \n #[test]\n-fn filled_mut() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n+fn reborrow_written() {\n+    let buf: &mut [_] = &mut [MaybeUninit::new(0); 32];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+\n+    let mut cursor = buf.unfilled();\n+    cursor.append(&[1; 16]);\n+\n+    let mut cursor2 = cursor.reborrow();\n+    cursor2.append(&[2; 16]);\n+\n+    assert_eq!(cursor2.written(), 32);\n+    assert_eq!(cursor.written(), 32);\n+\n+    assert_eq!(buf.unfilled().written(), 0);\n+    assert_eq!(buf.init_len(), 32);\n+    assert_eq!(buf.filled().len(), 32);\n+    let filled = buf.filled();\n+    assert_eq!(&filled[..16], [1; 16]);\n+    assert_eq!(&filled[16..], [2; 16]);\n+}\n+\n+#[test]\n+fn cursor_set_init() {\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowedBuf<'_> = buf.into();\n+\n+    unsafe {\n+        rbuf.unfilled().set_init(8);\n+    }\n \n-    rbuf.add_filled(8);\n+    assert_eq!(rbuf.init_len(), 8);\n+    assert_eq!(rbuf.unfilled().init_ref().len(), 8);\n+    assert_eq!(rbuf.unfilled().init_mut().len(), 8);\n+    assert_eq!(rbuf.unfilled().uninit_mut().len(), 8);\n+    assert_eq!(unsafe { rbuf.unfilled().as_mut() }.len(), 16);\n+\n+    unsafe {\n+        rbuf.unfilled().advance(4);\n+    }\n \n-    let filled = rbuf.filled().to_vec();\n+    unsafe {\n+        rbuf.unfilled().set_init(2);\n+    }\n+\n+    assert_eq!(rbuf.init_len(), 8);\n+\n+    unsafe {\n+        rbuf.unfilled().set_init(8);\n+    }\n \n-    assert_eq!(&*filled, &*rbuf.filled_mut());\n+    assert_eq!(rbuf.init_len(), 12);\n+    assert_eq!(rbuf.unfilled().init_ref().len(), 8);\n+    assert_eq!(rbuf.unfilled().init_mut().len(), 8);\n+    assert_eq!(rbuf.unfilled().uninit_mut().len(), 4);\n+    assert_eq!(unsafe { rbuf.unfilled().as_mut() }.len(), 12);\n }"}, {"sha": "f4a886d889a99a1b655b444bfbfacde2ae904733", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,4 +1,4 @@\n-use super::{repeat, Cursor, ReadBuf, SeekFrom};\n+use super::{repeat, BorrowedBuf, Cursor, SeekFrom};\n use crate::cmp::{self, min};\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::io::{BufRead, BufReader, Read, Seek, Write};\n@@ -159,24 +159,24 @@ fn read_exact_slice() {\n \n #[test]\n fn read_buf_exact() {\n-    let mut buf = [0; 4];\n-    let mut buf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [0; 4];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n \n     let mut c = Cursor::new(&b\"\"[..]);\n-    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    assert_eq!(c.read_buf_exact(buf.unfilled()).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n     let mut c = Cursor::new(&b\"123456789\"[..]);\n-    c.read_buf_exact(&mut buf).unwrap();\n+    c.read_buf_exact(buf.unfilled()).unwrap();\n     assert_eq!(buf.filled(), b\"1234\");\n \n     buf.clear();\n \n-    c.read_buf_exact(&mut buf).unwrap();\n+    c.read_buf_exact(buf.unfilled()).unwrap();\n     assert_eq!(buf.filled(), b\"5678\");\n \n     buf.clear();\n \n-    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    assert_eq!(c.read_buf_exact(buf.unfilled()).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n }\n \n #[test]\n@@ -615,10 +615,10 @@ fn bench_take_read(b: &mut test::Bencher) {\n #[bench]\n fn bench_take_read_buf(b: &mut test::Bencher) {\n     b.iter(|| {\n-        let mut buf = [MaybeUninit::uninit(); 64];\n+        let buf: &mut [_] = &mut [MaybeUninit::uninit(); 64];\n \n-        let mut rbuf = ReadBuf::uninit(&mut buf);\n+        let mut buf: BorrowedBuf<'_> = buf.into();\n \n-        [255; 128].take(64).read_buf(&mut rbuf).unwrap();\n+        [255; 128].take(64).read_buf(buf.unfilled()).unwrap();\n     });\n }"}, {"sha": "f076ee0923c80ff0d675e0a5df9e3d5573940e58", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -5,7 +5,7 @@ mod tests;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, Write,\n+    self, BorrowedCursor, BufRead, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n };\n \n /// A reader which is always at EOF.\n@@ -47,7 +47,7 @@ impl Read for Empty {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, _buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -130,21 +130,19 @@ impl Read for Repeat {\n         Ok(buf.len())\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, mut buf: BorrowedCursor<'_>) -> io::Result<()> {\n         // SAFETY: No uninit bytes are being written\n-        for slot in unsafe { buf.unfilled_mut() } {\n+        for slot in unsafe { buf.as_mut() } {\n             slot.write(self.byte);\n         }\n \n-        let remaining = buf.remaining();\n+        let remaining = buf.capacity();\n \n         // SAFETY: the entire unfilled portion of buf has been initialized\n         unsafe {\n-            buf.assume_init(remaining);\n+            buf.advance(remaining);\n         }\n \n-        buf.add_filled(remaining);\n-\n         Ok(())\n     }\n "}, {"sha": "ce5e2c9da1dbf15694197e6fc161152a52a92f16", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp::{max, min};\n use crate::io::prelude::*;\n use crate::io::{\n-    copy, empty, repeat, sink, BufWriter, Empty, ReadBuf, Repeat, Result, SeekFrom, Sink,\n+    copy, empty, repeat, sink, BorrowedBuf, BufWriter, Empty, Repeat, Result, SeekFrom, Sink,\n     DEFAULT_BUF_SIZE,\n };\n \n@@ -79,29 +79,29 @@ fn empty_reads() {\n     assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n     assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n \n-    let mut buf = [];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit()];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit(); 1024];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit(); 1024];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.by_ref().read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n+    let buf: &mut [MaybeUninit<_>] = &mut [];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit()];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1024];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1024];\n+    let mut buf: BorrowedBuf<'_> = buf.into();\n+    e.by_ref().read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n }\n \n #[test]"}, {"sha": "39a42f4e17fecfde7d5290e8664c442648416fb8", "filename": "library/std/src/os/fortanix_sgx/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -30,7 +30,9 @@ pub mod usercalls {\n \n         // fortanix-sgx-abi re-exports\n         pub use crate::sys::abi::usercalls::raw::Error;\n-        pub use crate::sys::abi::usercalls::raw::{ByteBuffer, FifoDescriptor, Return, Usercall};\n+        pub use crate::sys::abi::usercalls::raw::{\n+            ByteBuffer, Cancel, FifoDescriptor, Return, Usercall,\n+        };\n         pub use crate::sys::abi::usercalls::raw::{Fd, Result, Tcs};\n         pub use crate::sys::abi::usercalls::raw::{\n             EV_RETURNQ_NOT_EMPTY, EV_UNPARK, EV_USERCALLQ_NOT_FULL, FD_STDERR, FD_STDIN, FD_STDOUT,"}, {"sha": "1c5efa94bd36ac50fed582ff2fee5da2a7cd23c0", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,7 +2,7 @@ use crate::ffi::{CStr, CString, OsString};\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n use crate::io::{self, Error, ErrorKind};\n-use crate::io::{IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::os::unix::ffi::OsStrExt;\n use crate::path::{Path, PathBuf};\n use crate::sys::cvt;\n@@ -312,8 +312,8 @@ impl File {\n         false\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        crate::io::default_read_buf(|buf| self.read(buf), buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        crate::io::default_read_buf(|buf| self.read(buf), cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "9692222534eaa2a43bbd2ec5870e804949b68064", "filename": "library/std/src/sys/solid/fs.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,7 +2,7 @@ use super::{abi, error};\n use crate::{\n     ffi::{CStr, CString, OsStr, OsString},\n     fmt,\n-    io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom},\n+    io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom},\n     mem::MaybeUninit,\n     os::raw::{c_int, c_short},\n     os::solid::ffi::OsStrExt,\n@@ -366,13 +366,13 @@ impl File {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         unsafe {\n-            let len = buf.remaining();\n+            let len = cursor.capacity();\n             let mut out_num_bytes = MaybeUninit::uninit();\n             error::SolidError::err_if_negative(abi::SOLID_FS_Read(\n                 self.fd.raw(),\n-                buf.unfilled_mut().as_mut_ptr() as *mut u8,\n+                cursor.as_mut().as_mut_ptr() as *mut u8,\n                 len,\n                 out_num_bytes.as_mut_ptr(),\n             ))\n@@ -384,9 +384,7 @@ impl File {\n \n             // Safety: `num_bytes_read` bytes were written to the unfilled\n             // portion of the buffer\n-            buf.assume_init(num_bytes_read);\n-\n-            buf.add_filled(num_bytes_read);\n+            cursor.advance(num_bytes_read);\n \n             Ok(())\n         }"}, {"sha": "dbaa3c33e2e577f13afb6c98181648bef6e7cf54", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -4,7 +4,7 @@\n mod tests;\n \n use crate::cmp;\n-use crate::io::{self, IoSlice, IoSliceMut, Read, ReadBuf};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, Read};\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -131,20 +131,19 @@ impl FileDesc {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         let ret = cvt(unsafe {\n             libc::read(\n                 self.as_raw_fd(),\n-                buf.unfilled_mut().as_mut_ptr() as *mut libc::c_void,\n-                cmp::min(buf.remaining(), READ_LIMIT),\n+                cursor.as_mut().as_mut_ptr() as *mut libc::c_void,\n+                cmp::min(cursor.capacity(), READ_LIMIT),\n             )\n         })?;\n \n         // Safety: `ret` bytes were written to the initialized portion of the buffer\n         unsafe {\n-            buf.assume_init(ret as usize);\n+            cursor.advance(ret as usize);\n         }\n-        buf.add_filled(ret as usize);\n         Ok(())\n     }\n "}, {"sha": "cc347e3586ae337fdcd6d45592f39f1e261e17c8", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,7 +2,7 @@ use crate::os::unix::prelude::*;\n \n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n@@ -1037,8 +1037,8 @@ impl File {\n         self.0.read_at(buf, offset)\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.0.read_buf(buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.0.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "6ac1b5d2bcfcaf6e6db9e7e678db2e476deb7a0c", "filename": "library/std/src/sys/unsupported/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,7 +1,7 @@\n use crate::ffi::OsString;\n use crate::fmt;\n use crate::hash::{Hash, Hasher};\n-use crate::io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::path::{Path, PathBuf};\n use crate::sys::time::SystemTime;\n use crate::sys::unsupported;\n@@ -214,7 +214,7 @@ impl File {\n         self.0\n     }\n \n-    pub fn read_buf(&self, _buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, _cursor: BorrowedCursor<'_>) -> io::Result<()> {\n         self.0\n     }\n "}, {"sha": "510cf36b1bf48efca38f05d122e59ecf2bc8d456", "filename": "library/std/src/sys/wasi/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -3,7 +3,7 @@\n use super::fd::WasiFd;\n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, IoSlice, IoSliceMut, SeekFrom};\n use crate::iter;\n use crate::mem::{self, ManuallyDrop};\n use crate::os::raw::c_int;\n@@ -439,8 +439,8 @@ impl File {\n         true\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        crate::io::default_read_buf(|buf| self.read(buf), buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        crate::io::default_read_buf(|buf| self.read(buf), cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "9653b1abfc3d88a4bb43ab37385ec5fd7e4da3ee", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,7 +2,7 @@ use crate::os::windows::prelude::*;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, Error, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowedCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::os::windows::io::{AsHandle, BorrowedHandle};\n use crate::path::{Path, PathBuf};\n@@ -415,8 +415,8 @@ impl File {\n         self.handle.read_at(buf, offset)\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.handle.read_buf(buf)\n+    pub fn read_buf(&self, cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        self.handle.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "ae33d48c612eeb9460144cccd6f13b5fb56035c9", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -4,7 +4,7 @@\n mod tests;\n \n use crate::cmp;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf};\n+use crate::io::{self, BorrowedCursor, ErrorKind, IoSlice, IoSliceMut, Read};\n use crate::mem;\n use crate::os::windows::io::{\n     AsHandle, AsRawHandle, BorrowedHandle, FromRawHandle, IntoRawHandle, OwnedHandle, RawHandle,\n@@ -112,18 +112,16 @@ impl Handle {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let res = unsafe {\n-            self.synchronous_read(buf.unfilled_mut().as_mut_ptr(), buf.remaining(), None)\n-        };\n+    pub fn read_buf(&self, mut cursor: BorrowedCursor<'_>) -> io::Result<()> {\n+        let res =\n+            unsafe { self.synchronous_read(cursor.as_mut().as_mut_ptr(), cursor.capacity(), None) };\n \n         match res {\n             Ok(read) => {\n                 // Safety: `read` bytes were written to the initialized portion of the buffer\n                 unsafe {\n-                    buf.assume_init(read as usize);\n+                    cursor.advance(read as usize);\n                 }\n-                buf.add_filled(read as usize);\n                 Ok(())\n             }\n "}, {"sha": "8171cb4e9a68aa0c27a7bd25a53c87f07e672eff", "filename": "src/etc/gdb_lookup.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Fgdb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Fgdb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_lookup.py?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -89,4 +89,7 @@ def lookup(valobj):\n     if rust_type == RustType.STD_REF_CELL:\n         return StdRefCellProvider(valobj)\n \n+    if rust_type == RustType.STD_NONZERO_NUMBER:\n+        return StdNonZeroNumberProvider(valobj)\n+\n     return None"}, {"sha": "c351c3450f582d630e7d4708728ce71a336c3431", "filename": "src/etc/gdb_providers.py", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Fgdb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Fgdb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_providers.py?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -231,6 +231,17 @@ def children(self):\n         yield \"borrow\", self.borrow\n \n \n+class StdNonZeroNumberProvider:\n+    def __init__(self, valobj):\n+        fields = valobj.type.fields()\n+        assert len(fields) == 1\n+        field = list(fields)[0]\n+        self.value = str(valobj[field.name])\n+\n+    def to_string(self):\n+        return self.value\n+\n+\n # Yields children (in a provider's sense of the word) for a BTreeMap.\n def children_of_btree_map(map):\n     # Yields each key/value pair in the node and in any child nodes."}, {"sha": "ed66ecf30729e471299d8167f5bf3bb1aeb5a37b", "filename": "src/etc/lldb_commands", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Flldb_commands", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Flldb_commands", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_commands?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -15,4 +15,5 @@ type summary add -F lldb_lookup.summary_lookup  -e -x -h \"^(core::([a-z_]+::)+)C\n type summary add -F lldb_lookup.summary_lookup  -e -x -h \"^(core::([a-z_]+::)+)Ref<.+>$\" --category Rust\n type summary add -F lldb_lookup.summary_lookup  -e -x -h \"^(core::([a-z_]+::)+)RefMut<.+>$\" --category Rust\n type summary add -F lldb_lookup.summary_lookup  -e -x -h \"^(core::([a-z_]+::)+)RefCell<.+>$\" --category Rust\n+type summary add -F lldb_lookup.summary_lookup  -e -x -h \"^core::num::([a-z_]+::)*NonZero.+$\" --category Rust\n type category enable Rust"}, {"sha": "bca9c2ae192a715fc0572e0ab43af716764035fb", "filename": "src/etc/lldb_lookup.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Flldb_lookup.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Flldb_lookup.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_lookup.py?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -55,6 +55,9 @@ def summary_lookup(valobj, dict):\n     if rust_type == RustType.STD_REF_CELL:\n         return StdRefSummaryProvider(valobj, dict)\n \n+    if rust_type == RustType.STD_NONZERO_NUMBER:\n+        return StdNonZeroNumberSummaryProvider(valobj, dict)\n+\n     return \"\"\n \n "}, {"sha": "8a9927e7d96d7d26b134bd32160ce106b9b37940", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -739,3 +739,11 @@ def update(self):\n     def has_children(self):\n         # type: () -> bool\n         return True\n+\n+\n+def StdNonZeroNumberSummaryProvider(valobj, _dict):\n+    # type: (SBValue, dict) -> str\n+    objtype = valobj.GetType()\n+    field = objtype.GetFieldAtIndex(0)\n+    element = valobj.GetChildMemberWithName(field.name)\n+    return element.GetValue()"}, {"sha": "bf512bc99b8f282ad27181d5135fb3dabadf6e1d", "filename": "src/etc/rust_types.py", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Frust_types.py", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Fetc%2Frust_types.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust_types.py?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -31,6 +31,7 @@ class RustType(object):\n     STD_REF = \"StdRef\"\n     STD_REF_MUT = \"StdRefMut\"\n     STD_REF_CELL = \"StdRefCell\"\n+    STD_NONZERO_NUMBER = \"StdNonZeroNumber\"\n \n \n STD_STRING_REGEX = re.compile(r\"^(alloc::(\\w+::)+)String$\")\n@@ -49,6 +50,7 @@ class RustType(object):\n STD_REF_REGEX = re.compile(r\"^(core::(\\w+::)+)Ref<.+>$\")\n STD_REF_MUT_REGEX = re.compile(r\"^(core::(\\w+::)+)RefMut<.+>$\")\n STD_REF_CELL_REGEX = re.compile(r\"^(core::(\\w+::)+)RefCell<.+>$\")\n+STD_NONZERO_NUMBER_REGEX = re.compile(r\"^core::num::([a-z_]+::)*NonZero.+$\")\n \n TUPLE_ITEM_REGEX = re.compile(r\"__\\d+$\")\n \n@@ -72,6 +74,7 @@ class RustType(object):\n     RustType.STD_REF_MUT: STD_REF_MUT_REGEX,\n     RustType.STD_REF_CELL: STD_REF_CELL_REGEX,\n     RustType.STD_CELL: STD_CELL_REGEX,\n+    RustType.STD_NONZERO_NUMBER: STD_NONZERO_NUMBER_REGEX,\n }\n \n def is_tuple_fields(fields):"}, {"sha": "420159b5a6751cb3eebce2e70fa85e878b5bf4cf", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1776,11 +1776,6 @@ fn is_field_vis_inherited(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n pub(crate) fn clean_visibility(vis: ty::Visibility) -> Visibility {\n     match vis {\n         ty::Visibility::Public => Visibility::Public,\n-        // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n-        // while rustdoc really does mean inherited. That means that for enum variants, such as\n-        // `pub enum E { V }`, `V` will be marked as `Public` by `ty`, but as `Inherited` by rustdoc.\n-        // Various parts of clean override `tcx.visibility` explicitly to make sure this distinction is captured.\n-        ty::Visibility::Invisible => Visibility::Inherited,\n         ty::Visibility::Restricted(module) => Visibility::Restricted(module),\n     }\n }"}, {"sha": "2b12d118bca0e3968e0598e68a2a7a008fcb2599", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -41,8 +41,9 @@ impl<'a, 'tcx> DocFolder for CfgPropagator<'a, 'tcx> {\n             if self.parent != Some(expected_parent) {\n                 let mut attrs = Vec::new();\n                 for (parent_hir_id, _) in hir.parent_iter(hir_id) {\n-                    let def_id = hir.local_def_id(parent_hir_id).to_def_id();\n-                    attrs.extend_from_slice(load_attrs(self.cx, def_id));\n+                    if let Some(def_id) = hir.opt_local_def_id(parent_hir_id) {\n+                        attrs.extend_from_slice(load_attrs(self.cx, def_id.to_def_id()));\n+                    }\n                 }\n                 let (_, cfg) =\n                     merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));"}, {"sha": "c41c9ee21df892c2bde379b70a5c8386f3209a81", "filename": "src/test/debuginfo/numeric-types.rs", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fdebuginfo%2Fnumeric-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fdebuginfo%2Fnumeric-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fnumeric-types.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,6 +1,7 @@\n-// only-cdb\n // compile-flags:-g\n \n+// min-gdb-version: 8.1\n+\n // Tests the visualizations for `NonZero{I,U}{8,16,32,64,128,size}`, `Wrapping<T>` and\n // `Atomic{Bool,I8,I16,I32,I64,Isize,U8,U16,U32,U64,Usize}` located in `libcore.natvis`.\n \n@@ -153,6 +154,90 @@\n // cdb-check:a_usize          : 0x400 [Type: core::sync::atomic::AtomicUsize]\n // cdb-check:    [<Raw View>]     [Type: core::sync::atomic::AtomicUsize]\n \n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+\n+// gdb-command:print/d nz_i8\n+// gdb-check:[...]$1 = 11\n+\n+// gdb-command:print nz_i16\n+// gdb-check:[...]$2 = 22\n+\n+// gdb-command:print nz_i32\n+// gdb-check:[...]$3 = 33\n+\n+// gdb-command:print nz_i64\n+// gdb-check:[...]$4 = 44\n+\n+// gdb-command:print nz_i128\n+// gdb-check:[...]$5 = 55\n+\n+// gdb-command:print nz_isize\n+// gdb-check:[...]$6 = 66\n+\n+// gdb-command:print/d nz_u8\n+// gdb-check:[...]$7 = 77\n+\n+// gdb-command:print nz_u16\n+// gdb-check:[...]$8 = 88\n+\n+// gdb-command:print nz_u32\n+// gdb-check:[...]$9 = 99\n+\n+// gdb-command:print nz_u64\n+// gdb-check:[...]$10 = 100\n+\n+// gdb-command:print nz_u128\n+// gdb-check:[...]$11 = 111\n+\n+// gdb-command:print nz_usize\n+// gdb-check:[...]$12 = 122\n+\n+\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:run\n+\n+// lldb-command:print/d nz_i8\n+// lldb-check:[...]$0 = 11 { __0 = 11 }\n+\n+// lldb-command:print nz_i16\n+// lldb-check:[...]$1 = 22 { __0 = 22 }\n+\n+// lldb-command:print nz_i32\n+// lldb-check:[...]$2 = 33 { __0 = 33 }\n+\n+// lldb-command:print nz_i64\n+// lldb-check:[...]$3 = 44 { __0 = 44 }\n+\n+// lldb-command:print nz_i128\n+// lldb-check:[...]$4 = 55 { __0 = 55 }\n+\n+// lldb-command:print nz_isize\n+// lldb-check:[...]$5 = 66 { __0 = 66 }\n+\n+// lldb-command:print/d nz_u8\n+// lldb-check:[...]$6 = 77 { __0 = 77 }\n+\n+// lldb-command:print nz_u16\n+// lldb-check:[...]$7 = 88 { __0 = 88 }\n+\n+// lldb-command:print nz_u32\n+// lldb-check:[...]$8 = 99 { __0 = 99 }\n+\n+// lldb-command:print nz_u64\n+// lldb-check:[...]$9 = 100 { __0 = 100 }\n+\n+// lldb-command:print nz_u128\n+// lldb-check:[...]$10 = 111 { __0 = 111 }\n+\n+// lldb-command:print nz_usize\n+// lldb-check:[...]$11 = 122 { __0 = 122 }\n+\n+\n use std::num::*;\n use std::sync::atomic::*;\n "}, {"sha": "648f9902908af8607dbca9bbee167b6114f4b5fe", "filename": "src/test/rustdoc-ui/issue-101076.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Frustdoc-ui%2Fissue-101076.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Frustdoc-ui%2Fissue-101076.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fissue-101076.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+const _: () = {\n+    #[macro_export]\n+    macro_rules! first_macro {\n+        () => {}\n+    }\n+    mod foo {\n+        #[macro_export]\n+        macro_rules! second_macro {\n+            () => {}\n+        }\n+    }\n+};"}, {"sha": "35266e113a6de437ce055995c60e10f603519a94", "filename": "src/test/ui/borrowck/index-mut-help.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,10 +1,9 @@\n // When mutably indexing a type that implements `Index` but not `IndexMut`, a\n // special 'help' message is added to the output.\n+use std::collections::HashMap;\n \n \n fn main() {\n-    use std::collections::HashMap;\n-\n     let mut map = HashMap::new();\n     map.insert(\"peter\", \"23\".to_string());\n "}, {"sha": "f42d7e0155433fbcb61bf3cb8efeacf32d7bd2ea", "filename": "src/test/ui/borrowck/index-mut-help.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Findex-mut-help.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1,23 +1,33 @@\n error[E0596]: cannot borrow data in an index of `HashMap<&str, String>` as mutable\n-  --> $DIR/index-mut-help.rs:11:5\n+  --> $DIR/index-mut-help.rs:10:5\n    |\n LL |     map[\"peter\"].clear();\n    |     ^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n    |\n    = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `HashMap<&str, String>`\n-   = help: to modify a `HashMap<&str, String>`, use `.get_mut()`, `.insert()` or the entry API\n+help: to modify a `HashMap<&str, String>` use `.get_mut()`\n+   |\n+LL |     map.get_mut(\"peter\").map(|val| val.clear());\n+   |        ~~~~~~~~~       ~~~~~~~~~~~~~~~        +\n \n error[E0594]: cannot assign to data in an index of `HashMap<&str, String>`\n-  --> $DIR/index-mut-help.rs:12:5\n+  --> $DIR/index-mut-help.rs:11:5\n    |\n LL |     map[\"peter\"] = \"0\".to_string();\n    |     ^^^^^^^^^^^^ cannot assign\n    |\n    = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `HashMap<&str, String>`\n-   = help: to modify a `HashMap<&str, String>`, use `.get_mut()`, `.insert()` or the entry API\n+help: to modify a `HashMap<&str, String>`, use `.get_mut()`, `.insert()` or the entry API\n+   |\n+LL |     map.insert(\"peter\", \"0\".to_string());\n+   |        ~~~~~~~~       ~                +\n+LL |     map.get_mut(\"peter\").map(|val| { *val = \"0\".to_string(); });\n+   |        ~~~~~~~~~       ~~~~~~~~~~~~~~~~~~                  ++++\n+LL |     let val = map.entry(\"peter\").or_insert(\"0\".to_string());\n+   |     +++++++++    ~~~~~~~       ~~~~~~~~~~~~               +\n \n error[E0596]: cannot borrow data in an index of `HashMap<&str, String>` as mutable\n-  --> $DIR/index-mut-help.rs:13:13\n+  --> $DIR/index-mut-help.rs:12:13\n    |\n LL |     let _ = &mut map[\"peter\"];\n    |             ^^^^^^^^^^^^^^^^^ cannot borrow as mutable"}, {"sha": "26f2a4c4b29145faff8ea86e67b42e2d36636bb6", "filename": "src/test/ui/btreemap/btreemap-index-mut.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap-index-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap-index-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbtreemap%2Fbtreemap-index-mut.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -5,7 +5,14 @@ LL |     map[&0] = 1;\n    |     ^^^^^^^^^^^ cannot assign\n    |\n    = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `BTreeMap<u32, u32>`\n-   = help: to modify a `BTreeMap<u32, u32>`, use `.get_mut()`, `.insert()` or the entry API\n+help: to modify a `BTreeMap<u32, u32>`, use `.get_mut()`, `.insert()` or the entry API\n+   |\n+LL |     map.insert(&0, 1);\n+   |        ~~~~~~~~  ~  +\n+LL |     map.get_mut(&0).map(|val| { *val = 1; });\n+   |        ~~~~~~~~~  ~~~~~~~~~~~~~~~~~~    ++++\n+LL |     let val = map.entry(&0).or_insert(1);\n+   |     +++++++++    ~~~~~~~  ~~~~~~~~~~~~ +\n \n error: aborting due to previous error\n "}, {"sha": "d4bd673b84e1b70083273e08d5ccae0a4a4b36b8", "filename": "src/test/ui/conditional-compilation/cfg-attr-syntax-validation.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -50,7 +50,9 @@ error[E0565]: literal in `cfg` predicate value must be a string\n   --> $DIR/cfg-attr-syntax-validation.rs:25:11\n    |\n LL | #[cfg(a = b\"hi\")]\n-   |           ^^^^^ help: consider removing the prefix: `\"hi\"`\n+   |           -^^^^\n+   |           |\n+   |           help: consider removing the prefix\n \n error: expected unsuffixed literal or identifier, found `concat!(\"nonexistent\")`\n   --> $DIR/cfg-attr-syntax-validation.rs:30:25"}, {"sha": "653afae2191159f3dfcf50e8d82e622de7c90660", "filename": "src/test/ui/const-generics/issues/issue-87493.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-87493.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-87493.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-87493.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -13,15 +13,17 @@ error[E0107]: this trait takes 0 generic arguments but 1 generic argument was su\n   --> $DIR/issue-87493.rs:8:8\n    |\n LL |     T: MyTrait<Assoc == S::Assoc>,\n-   |        ^^^^^^^ ----------------- help: replace the generic bound with the associated type: `Assoc = Assoc == S::Assoc`\n-   |        |\n-   |        expected 0 generic arguments\n+   |        ^^^^^^^ expected 0 generic arguments\n    |\n note: trait defined here, with 0 generic parameters\n   --> $DIR/issue-87493.rs:1:11\n    |\n LL | pub trait MyTrait {\n    |           ^^^^^^^\n+help: replace the generic bound with the associated type\n+   |\n+LL |     T: MyTrait<Assoc = Assoc == S::Assoc>,\n+   |                +++++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e0de705c488460b22da6d7462ff839ea2b6055be", "filename": "src/test/ui/consts/extra-const-ub/issue-101034.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fissue-101034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fissue-101034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fextra-const-ub%2Fissue-101034.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -0,0 +1,17 @@\n+// check-pass\n+// compile-flags: -Zextra-const-ub-checks\n+\n+#[repr(packed)]\n+pub struct Foo {\n+    bar: u8,\n+    baa: [u32; 1],\n+}\n+\n+const FOOMP: Foo = Foo {\n+    bar: 0,\n+    baa: [69; 1],\n+};\n+\n+fn main() {\n+    let _val = FOOMP;\n+}"}, {"sha": "8b2b480d19586e40e090d90f1e1716e559c939b4", "filename": "src/test/ui/deprecation/deprecation-sanity.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-sanity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-sanity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdeprecation%2Fdeprecation-sanity.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -44,7 +44,9 @@ error[E0565]: literal in `deprecated` value must be a string\n   --> $DIR/deprecation-sanity.rs:19:25\n    |\n LL |     #[deprecated(note = b\"test\")]\n-   |                         ^^^^^^^ help: consider removing the prefix: `\"test\"`\n+   |                         -^^^^^^\n+   |                         |\n+   |                         help: consider removing the prefix\n \n error[E0565]: item in `deprecated` must be a key/value pair\n   --> $DIR/deprecation-sanity.rs:22:18"}, {"sha": "03430f8fa3a0bcd7da9197ebd7bdb9b4c5c82223", "filename": "src/test/ui/error-codes/E0107.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0107.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -142,7 +142,7 @@ LL | pub trait T {\n help: replace the generic bounds with the associated types\n    |\n LL | fn trait_bound_generic<I: T<A = u8, B = u16>>(_i: I) {\n-   |                             ~~~~~~  ~~~~~~~\n+   |                             +++     +++\n \n error: aborting due to 10 previous errors\n "}, {"sha": "097871bd31906cb28c7014233419cfc8fe5b6e62", "filename": "src/test/ui/error-codes/E0565-2.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Ferror-codes%2FE0565-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Ferror-codes%2FE0565-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0565-2.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,7 +2,9 @@ error[E0565]: literal in `deprecated` value must be a string\n   --> $DIR/E0565-2.rs:2:22\n    |\n LL | #[deprecated(since = b\"1.29\", note = \"hi\")]\n-   |                      ^^^^^^^ help: consider removing the prefix: `\"1.29\"`\n+   |                      -^^^^^^\n+   |                      |\n+   |                      help: consider removing the prefix\n \n error: aborting due to previous error\n "}, {"sha": "c1948ab627149dad14a0b162c6f516903881ee3d", "filename": "src/test/ui/hashmap/hashmap-index-mut.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-index-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-index-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhashmap%2Fhashmap-index-mut.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -5,7 +5,14 @@ LL |     map[&0] = 1;\n    |     ^^^^^^^^^^^ cannot assign\n    |\n    = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `HashMap<u32, u32>`\n-   = help: to modify a `HashMap<u32, u32>`, use `.get_mut()`, `.insert()` or the entry API\n+help: to modify a `HashMap<u32, u32>`, use `.get_mut()`, `.insert()` or the entry API\n+   |\n+LL |     map.insert(&0, 1);\n+   |        ~~~~~~~~  ~  +\n+LL |     map.get_mut(&0).map(|val| { *val = 1; });\n+   |        ~~~~~~~~~  ~~~~~~~~~~~~~~~~~~    ++++\n+LL |     let val = map.entry(&0).or_insert(1);\n+   |     +++++++++    ~~~~~~~  ~~~~~~~~~~~~ +\n \n error: aborting due to previous error\n "}, {"sha": "b05c1fb14efc6d23778c5e78659936320efe51c4", "filename": "src/test/ui/issues/issue-41726.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fissues%2Fissue-41726.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fissues%2Fissue-41726.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-41726.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -5,7 +5,10 @@ LL |         things[src.as_str()].sort();\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n    |\n    = help: trait `IndexMut` is required to modify indexed content, but it is not implemented for `HashMap<String, Vec<String>>`\n-   = help: to modify a `HashMap<String, Vec<String>>`, use `.get_mut()`, `.insert()` or the entry API\n+help: to modify a `HashMap<String, Vec<String>>` use `.get_mut()`\n+   |\n+LL |         things.get_mut(src.as_str()).map(|val| val.sort());\n+   |               ~~~~~~~~~            ~~~~~~~~~~~~~~~       +\n \n error: aborting due to previous error\n "}, {"sha": "91733411637d032f1f46d771273579b3920eb7b1", "filename": "src/test/ui/methods/method-on-ambiguous-numeric-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fmethods%2Fmethod-on-ambiguous-numeric-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fmethods%2Fmethod-on-ambiguous-numeric-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-on-ambiguous-numeric-type.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -18,7 +18,7 @@ LL |     let x = y.neg();\n help: you must specify a type for this binding, like `f32`\n    |\n LL |     let y: f32 = 2.0;\n-   |         ~~~~~~\n+   |          +++++\n \n error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:19:26\n@@ -37,7 +37,7 @@ LL |     local_bar.pow(2);\n help: you must specify a type for this binding, like `i32`\n    |\n LL |     ($ident:ident) => { let $ident: i32 = 42; }\n-   |                             ~~~~~~~~~~~\n+   |                                   +++++\n \n error[E0689]: can't call method `pow` on ambiguous numeric type `{integer}`\n   --> $DIR/method-on-ambiguous-numeric-type.rs:30:9\n@@ -46,10 +46,10 @@ LL |     bar.pow(2);\n    |         ^^^\n    |\n help: you must specify a type for this binding, like `i32`\n-  --> $DIR/auxiliary/macro-in-other-crate.rs:3:29\n+  --> $DIR/auxiliary/macro-in-other-crate.rs:3:35\n    |\n LL |     ($ident:ident) => { let $ident: i32 = 42; }\n-   |                             ~~~~~~~~~~~\n+   |                                   +++++\n \n error: aborting due to 5 previous errors\n "}, {"sha": "75b919232847832440a2cd0da3cc12bddd06f291", "filename": "src/test/ui/suggestions/use-type-argument-instead-of-assoc-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fuse-type-argument-instead-of-assoc-type.stderr?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -12,7 +12,7 @@ LL | pub trait T<X, Y> {\n help: replace the generic bounds with the associated types\n    |\n LL |     i: Box<dyn T<usize, usize, A = usize, C = usize, B=usize>>,\n-   |                                ~~~~~~~~~  ~~~~~~~~~\n+   |                                +++        +++\n \n error[E0191]: the value of the associated types `A` (from trait `T`), `C` (from trait `T`) must be specified\n   --> $DIR/use-type-argument-instead-of-assoc-type.rs:7:16"}, {"sha": "e168a81890c948660b03ff263700d0de4ce8ae36", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -1103,6 +1103,7 @@ impl<'test> TestCx<'test> {\n             \"^(core::([a-z_]+::)+)Ref<.+>$\",\n             \"^(core::([a-z_]+::)+)RefMut<.+>$\",\n             \"^(core::([a-z_]+::)+)RefCell<.+>$\",\n+            \"^core::num::([a-z_]+::)*NonZero.+$\",\n         ];\n \n         script_str"}, {"sha": "a9830a3840d1acc9e749a25a6321bc422d21a361", "filename": "src/tools/unstable-book-gen/src/main.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funstable-book-gen%2Fsrc%2Fmain.rs?ref=3fdd578d72a24d4efc2fe2ad18eec3b6ba72271e", "patch": "@@ -2,37 +2,23 @@\n \n use std::collections::BTreeSet;\n use std::env;\n-use std::fs::{self, File};\n-use std::io::Write;\n+use std::fs::{self, write};\n use std::path::Path;\n use tidy::features::{collect_lang_features, collect_lib_features, Features};\n+use tidy::t;\n use tidy::unstable_book::{\n     collect_unstable_book_section_file_names, collect_unstable_feature_names, LANG_FEATURES_DIR,\n     LIB_FEATURES_DIR, PATH_STR,\n };\n \n-/// A helper macro to `unwrap` a result except also print out details like:\n-///\n-/// * The file/line of the panic\n-/// * The expression that failed\n-/// * The error itself\n-macro_rules! t {\n-    ($e:expr) => {\n-        match $e {\n-            Ok(e) => e,\n-            Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n-        }\n-    };\n-}\n-\n fn generate_stub_issue(path: &Path, name: &str, issue: u32) {\n-    let mut file = t!(File::create(path));\n-    t!(write!(file, include_str!(\"stub-issue.md\"), name = name, issue = issue));\n+    let content = format!(include_str!(\"stub-issue.md\"), name = name, issue = issue);\n+    t!(write(path, content), path);\n }\n \n fn generate_stub_no_issue(path: &Path, name: &str) {\n-    let mut file = t!(File::create(path));\n-    t!(write!(file, include_str!(\"stub-no-issue.md\"), name = name));\n+    let content = format!(include_str!(\"stub-no-issue.md\"), name = name);\n+    t!(write(path, content), path);\n }\n \n fn set_to_summary_str(set: &BTreeSet<String>, dir: &str) -> String {\n@@ -52,13 +38,14 @@ fn generate_summary(path: &Path, lang_features: &Features, lib_features: &Featur\n     let lang_features_str = set_to_summary_str(&unstable_lang_features, \"language-features\");\n     let lib_features_str = set_to_summary_str(&unstable_lib_features, \"library-features\");\n \n-    let mut file = t!(File::create(&path.join(\"src/SUMMARY.md\")));\n-    t!(file.write_fmt(format_args!(\n+    let summary_path = path.join(\"src/SUMMARY.md\");\n+    let content = format!(\n         include_str!(\"SUMMARY.md\"),\n         compiler_flags = compiler_flags_str,\n         language_features = lang_features_str,\n         library_features = lib_features_str\n-    )));\n+    );\n+    t!(write(&summary_path, content), summary_path);\n }\n \n fn generate_unstable_book_files(src: &Path, out: &Path, features: &Features) {"}]}