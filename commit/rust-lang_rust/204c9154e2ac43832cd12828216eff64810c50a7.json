{"sha": "204c9154e2ac43832cd12828216eff64810c50a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwNGM5MTU0ZTJhYzQzODMyY2QxMjgyODIxNmVmZjY0ODEwYzUwYTc=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-02-25T16:09:01Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T09:24:36Z"}, "message": "refactor: Extract the undo log to its own modules", "tree": {"sha": "a502e24f00e20a1a01c5e6fc01e43c585dadfe3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a502e24f00e20a1a01c5e6fc01e43c585dadfe3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/204c9154e2ac43832cd12828216eff64810c50a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/204c9154e2ac43832cd12828216eff64810c50a7", "html_url": "https://github.com/rust-lang/rust/commit/204c9154e2ac43832cd12828216eff64810c50a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/204c9154e2ac43832cd12828216eff64810c50a7/comments", "author": null, "committer": null, "parents": [{"sha": "bc7f7b2d4d2ae25e6ce234ac4b03715b6979548b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7f7b2d4d2ae25e6ce234ac4b03715b6979548b", "html_url": "https://github.com/rust-lang/rust/commit/bc7f7b2d4d2ae25e6ce234ac4b03715b6979548b"}], "stats": {"total": 502, "additions": 272, "deletions": 230}, "files": [{"sha": "7bf13c90bf7362df71842138e6254cae2b9bca2c", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 225, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=204c9154e2ac43832cd12828216eff64810c50a7", "patch": "@@ -6,13 +6,14 @@ pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n \n+pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};\n+\n use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n \n use rustc_ast::ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::undo_log::{Rollback, Snapshots, UndoLogs};\n+use rustc_data_structures::undo_log::{Rollback, Snapshots};\n use rustc_data_structures::unify as ut;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n@@ -69,6 +70,7 @@ pub mod region_constraints;\n pub mod resolve;\n mod sub;\n pub mod type_variable;\n+mod undo_log;\n \n use crate::infer::canonical::OriginalQueryValues;\n pub use rustc_middle::infer::unify_key;\n@@ -85,6 +87,10 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n+pub(crate) type UnificationTable<'a, 'tcx, T> = ut::UnificationTable<\n+    ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'tcx>>,\n+>;\n+\n /// How we should handle region solving.\n ///\n /// This is used so that the region values inferred by HIR region solving are\n@@ -270,228 +276,6 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n }\n \n-pub struct Snapshot<'tcx> {\n-    undo_len: usize,\n-    _marker: PhantomData<&'tcx ()>,\n-}\n-\n-pub(crate) enum UndoLog<'tcx> {\n-    TypeVariables(type_variable::UndoLog<'tcx>),\n-    ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n-    IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n-    FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n-    RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n-    RegionUnificationTable(sv::UndoLog<ut::Delegate<ty::RegionVid>>),\n-    ProjectionCache(traits::UndoLog<'tcx>),\n-    PushRegionObligation,\n-}\n-\n-impl<'tcx> From<region_constraints::UndoLog<'tcx>> for UndoLog<'tcx> {\n-    fn from(l: region_constraints::UndoLog<'tcx>) -> Self {\n-        UndoLog::RegionConstraintCollector(l)\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>) -> Self {\n-        UndoLog::TypeVariables(type_variable::UndoLog::EqRelation(l))\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::TyVid>>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<ut::Delegate<ty::TyVid>>) -> Self {\n-        UndoLog::TypeVariables(type_variable::UndoLog::SubRelation(l))\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<type_variable::Delegate>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<type_variable::Delegate>) -> Self {\n-        UndoLog::TypeVariables(type_variable::UndoLog::Values(l))\n-    }\n-}\n-\n-impl<'tcx> From<type_variable::Instantiate> for UndoLog<'tcx> {\n-    fn from(l: type_variable::Instantiate) -> Self {\n-        UndoLog::TypeVariables(type_variable::UndoLog::from(l))\n-    }\n-}\n-\n-impl From<type_variable::UndoLog<'tcx>> for UndoLog<'tcx> {\n-    fn from(t: type_variable::UndoLog<'tcx>) -> Self {\n-        Self::TypeVariables(t)\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>) -> Self {\n-        Self::ConstUnificationTable(l)\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::IntVid>>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<ut::Delegate<ty::IntVid>>) -> Self {\n-        Self::IntUnificationTable(l)\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::FloatVid>>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<ut::Delegate<ty::FloatVid>>) -> Self {\n-        Self::FloatUnificationTable(l)\n-    }\n-}\n-\n-impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::RegionVid>>> for UndoLog<'tcx> {\n-    fn from(l: sv::UndoLog<ut::Delegate<ty::RegionVid>>) -> Self {\n-        Self::RegionUnificationTable(l)\n-    }\n-}\n-\n-impl<'tcx> From<traits::UndoLog<'tcx>> for UndoLog<'tcx> {\n-    fn from(l: traits::UndoLog<'tcx>) -> Self {\n-        Self::ProjectionCache(l)\n-    }\n-}\n-\n-pub(crate) type UnificationTable<'a, 'tcx, T> = ut::UnificationTable<\n-    ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut InferCtxtUndoLogs<'tcx>>,\n->;\n-\n-struct RollbackView<'tcx, 'a> {\n-    type_variables: &'a mut type_variable::TypeVariableStorage<'tcx>,\n-    const_unification_table: &'a mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n-    int_unification_table: &'a mut ut::UnificationStorage<ty::IntVid>,\n-    float_unification_table: &'a mut ut::UnificationStorage<ty::FloatVid>,\n-    region_constraints: &'a mut RegionConstraintStorage<'tcx>,\n-    projection_cache: &'a mut traits::ProjectionCacheStorage<'tcx>,\n-    region_obligations: &'a mut Vec<(hir::HirId, RegionObligation<'tcx>)>,\n-}\n-\n-impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n-    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n-        match undo {\n-            UndoLog::TypeVariables(undo) => self.type_variables.reverse(undo),\n-            UndoLog::ConstUnificationTable(undo) => self.const_unification_table.reverse(undo),\n-            UndoLog::IntUnificationTable(undo) => self.int_unification_table.reverse(undo),\n-            UndoLog::FloatUnificationTable(undo) => self.float_unification_table.reverse(undo),\n-            UndoLog::RegionConstraintCollector(undo) => self.region_constraints.reverse(undo),\n-            UndoLog::RegionUnificationTable(undo) => {\n-                self.region_constraints.unification_table.reverse(undo)\n-            }\n-            UndoLog::ProjectionCache(undo) => self.projection_cache.reverse(undo),\n-            UndoLog::PushRegionObligation => {\n-                self.region_obligations.pop();\n-            }\n-        }\n-    }\n-}\n-\n-pub(crate) struct InferCtxtUndoLogs<'tcx> {\n-    logs: Vec<UndoLog<'tcx>>,\n-    num_open_snapshots: usize,\n-}\n-\n-impl Default for InferCtxtUndoLogs<'_> {\n-    fn default() -> Self {\n-        Self { logs: Default::default(), num_open_snapshots: Default::default() }\n-    }\n-}\n-\n-impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>\n-where\n-    UndoLog<'tcx>: From<T>,\n-{\n-    fn num_open_snapshots(&self) -> usize {\n-        self.num_open_snapshots\n-    }\n-    fn push(&mut self, undo: T) {\n-        if self.in_snapshot() {\n-            self.logs.push(undo.into())\n-        }\n-    }\n-    fn clear(&mut self) {\n-        self.logs.clear();\n-        self.num_open_snapshots = 0;\n-    }\n-    fn extend<J>(&mut self, undos: J)\n-    where\n-        Self: Sized,\n-        J: IntoIterator<Item = T>,\n-    {\n-        if self.in_snapshot() {\n-            self.logs.extend(undos.into_iter().map(UndoLog::from))\n-        }\n-    }\n-}\n-\n-impl<'tcx> Snapshots<UndoLog<'tcx>> for InferCtxtUndoLogs<'tcx> {\n-    type Snapshot = Snapshot<'tcx>;\n-    fn actions_since_snapshot(&self, snapshot: &Self::Snapshot) -> &[UndoLog<'tcx>] {\n-        &self.logs[snapshot.undo_len..]\n-    }\n-\n-    fn start_snapshot(&mut self) -> Self::Snapshot {\n-        self.num_open_snapshots += 1;\n-        Snapshot { undo_len: self.logs.len(), _marker: PhantomData }\n-    }\n-\n-    fn rollback_to<R>(&mut self, values: impl FnOnce() -> R, snapshot: Self::Snapshot)\n-    where\n-        R: Rollback<UndoLog<'tcx>>,\n-    {\n-        debug!(\"rollback_to({})\", snapshot.undo_len);\n-        self.assert_open_snapshot(&snapshot);\n-\n-        if self.logs.len() > snapshot.undo_len {\n-            let mut values = values();\n-            while self.logs.len() > snapshot.undo_len {\n-                values.reverse(self.logs.pop().unwrap());\n-            }\n-        }\n-\n-        if self.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n-            assert!(snapshot.undo_len == 0);\n-            self.logs.clear();\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-    }\n-\n-    fn commit(&mut self, snapshot: Self::Snapshot) {\n-        debug!(\"commit({})\", snapshot.undo_len);\n-\n-        if self.num_open_snapshots == 1 {\n-            // The root snapshot. It's safe to clear the undo log because\n-            // there's no snapshot further out that we might need to roll back\n-            // to.\n-            assert!(snapshot.undo_len == 0);\n-            self.logs.clear();\n-        }\n-\n-        self.num_open_snapshots -= 1;\n-    }\n-}\n-\n-impl<'tcx> InferCtxtUndoLogs<'tcx> {\n-    pub(crate) fn region_constraints(\n-        &self,\n-        after: usize,\n-    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n-        self.logs[after..].iter().filter_map(|log| match log {\n-            UndoLog::RegionConstraintCollector(log) => Some(log),\n-            _ => None,\n-        })\n-    }\n-\n-    fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n-        // Failures here may indicate a failure to follow a stack discipline.\n-        assert!(self.logs.len() >= snapshot.undo_len);\n-        assert!(self.num_open_snapshots > 0);\n-    }\n-}\n-\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n@@ -1097,7 +881,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ..\n         } = &mut *self.inner.borrow_mut();\n         undo_log.rollback_to(\n-            || RollbackView {\n+            || undo_log::RollbackView {\n                 type_variables,\n                 const_unification_table,\n                 int_unification_table,"}, {"sha": "480a5cb4dccee141ca3bcb1dfc49e4f98a623688", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=204c9154e2ac43832cd12828216eff64810c50a7", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> RegionConstraintCollector<'tcx, '_> {\n             let mut taint_set = TaintSet::new(TaintDirections::both(), placeholder_region);\n             taint_set.fixed_point(\n                 tcx,\n-                self.undo_log.region_constraints(0),\n+                self.undo_log.region_constraints(),\n                 &self.storage.data.verifys,\n             );\n             let tainted_regions = taint_set.into_set();"}, {"sha": "ead2494756ce29d23baae6cbd9970c8f47afaf8e", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=204c9154e2ac43832cd12828216eff64810c50a7", "patch": "@@ -500,7 +500,6 @@ impl<'tcx> RegionConstraintCollector<'tcx, '_> {\n \n         let constraints_to_kill: Vec<usize> = self\n             .undo_log\n-            .logs\n             .iter()\n             .enumerate()\n             .rev()\n@@ -514,7 +513,7 @@ impl<'tcx> RegionConstraintCollector<'tcx, '_> {\n             .collect();\n \n         for index in constraints_to_kill {\n-            let undo_entry = match &mut self.undo_log.logs[index] {\n+            let undo_entry = match &mut self.undo_log[index] {\n                 super::UndoLog::RegionConstraintCollector(undo_entry) => {\n                     mem::replace(undo_entry, Purged)\n                 }\n@@ -790,9 +789,9 @@ impl<'tcx> RegionConstraintCollector<'tcx, '_> {\n     }\n \n     /// See [`RegionInference::region_constraints_added_in_snapshot`].\n-    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'_>) -> Option<bool> {\n+    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> Option<bool> {\n         self.undo_log\n-            .region_constraints(mark.undo_len)\n+            .region_constraints_in_snapshot(mark)\n             .map(|&elt| match elt {\n                 AddConstraint(constraint) => Some(constraint.involves_placeholders()),\n                 _ => None,"}, {"sha": "beb71e9e2e865793f21d7824ae608f6a75413e47", "filename": "src/librustc_infer/infer/undo_log.rs", "status": "added", "additions": 259, "deletions": 0, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/204c9154e2ac43832cd12828216eff64810c50a7/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fundo_log.rs?ref=204c9154e2ac43832cd12828216eff64810c50a7", "patch": "@@ -0,0 +1,259 @@\n+use std::marker::PhantomData;\n+\n+use rustc::ty;\n+use rustc_data_structures::snapshot_vec as sv;\n+use rustc_data_structures::undo_log::{Rollback, Snapshots, UndoLogs};\n+use rustc_data_structures::unify as ut;\n+use rustc_hir as hir;\n+\n+use crate::{\n+    infer::{\n+        region_constraints::{self, RegionConstraintStorage},\n+        type_variable, RegionObligation,\n+    },\n+    traits,\n+};\n+\n+pub struct Snapshot<'tcx> {\n+    pub(crate) undo_len: usize,\n+    _marker: PhantomData<&'tcx ()>,\n+}\n+\n+pub(crate) enum UndoLog<'tcx> {\n+    TypeVariables(type_variable::UndoLog<'tcx>),\n+    ConstUnificationTable(sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>),\n+    IntUnificationTable(sv::UndoLog<ut::Delegate<ty::IntVid>>),\n+    FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n+    RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n+    RegionUnificationTable(sv::UndoLog<ut::Delegate<ty::RegionVid>>),\n+    ProjectionCache(traits::UndoLog<'tcx>),\n+    PushRegionObligation,\n+}\n+\n+impl<'tcx> From<region_constraints::UndoLog<'tcx>> for UndoLog<'tcx> {\n+    fn from(l: region_constraints::UndoLog<'tcx>) -> Self {\n+        UndoLog::RegionConstraintCollector(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<type_variable::TyVidEqKey<'tcx>>>) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::EqRelation(l))\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::TyVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::TyVid>>) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::SubRelation(l))\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<type_variable::Delegate>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<type_variable::Delegate>) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::Values(l))\n+    }\n+}\n+\n+impl<'tcx> From<type_variable::Instantiate> for UndoLog<'tcx> {\n+    fn from(l: type_variable::Instantiate) -> Self {\n+        UndoLog::TypeVariables(type_variable::UndoLog::from(l))\n+    }\n+}\n+\n+impl From<type_variable::UndoLog<'tcx>> for UndoLog<'tcx> {\n+    fn from(t: type_variable::UndoLog<'tcx>) -> Self {\n+        Self::TypeVariables(t)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::ConstVid<'tcx>>>) -> Self {\n+        Self::ConstUnificationTable(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::IntVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::IntVid>>) -> Self {\n+        Self::IntUnificationTable(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::FloatVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::FloatVid>>) -> Self {\n+        Self::FloatUnificationTable(l)\n+    }\n+}\n+\n+impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::RegionVid>>> for UndoLog<'tcx> {\n+    fn from(l: sv::UndoLog<ut::Delegate<ty::RegionVid>>) -> Self {\n+        Self::RegionUnificationTable(l)\n+    }\n+}\n+\n+impl<'tcx> From<traits::UndoLog<'tcx>> for UndoLog<'tcx> {\n+    fn from(l: traits::UndoLog<'tcx>) -> Self {\n+        Self::ProjectionCache(l)\n+    }\n+}\n+\n+pub(super) struct RollbackView<'tcx, 'a> {\n+    pub(super) type_variables: &'a mut type_variable::TypeVariableStorage<'tcx>,\n+    pub(super) const_unification_table: &'a mut ut::UnificationStorage<ty::ConstVid<'tcx>>,\n+    pub(super) int_unification_table: &'a mut ut::UnificationStorage<ty::IntVid>,\n+    pub(super) float_unification_table: &'a mut ut::UnificationStorage<ty::FloatVid>,\n+    pub(super) region_constraints: &'a mut RegionConstraintStorage<'tcx>,\n+    pub(super) projection_cache: &'a mut traits::ProjectionCacheStorage<'tcx>,\n+    pub(super) region_obligations: &'a mut Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+}\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        match undo {\n+            UndoLog::TypeVariables(undo) => self.type_variables.reverse(undo),\n+            UndoLog::ConstUnificationTable(undo) => self.const_unification_table.reverse(undo),\n+            UndoLog::IntUnificationTable(undo) => self.int_unification_table.reverse(undo),\n+            UndoLog::FloatUnificationTable(undo) => self.float_unification_table.reverse(undo),\n+            UndoLog::RegionConstraintCollector(undo) => self.region_constraints.reverse(undo),\n+            UndoLog::RegionUnificationTable(undo) => {\n+                self.region_constraints.unification_table.reverse(undo)\n+            }\n+            UndoLog::ProjectionCache(undo) => self.projection_cache.reverse(undo),\n+            UndoLog::PushRegionObligation => {\n+                self.region_obligations.pop();\n+            }\n+        }\n+    }\n+}\n+\n+pub(crate) struct InferCtxtUndoLogs<'tcx> {\n+    logs: Vec<UndoLog<'tcx>>,\n+    num_open_snapshots: usize,\n+}\n+\n+impl Default for InferCtxtUndoLogs<'_> {\n+    fn default() -> Self {\n+        Self { logs: Default::default(), num_open_snapshots: Default::default() }\n+    }\n+}\n+\n+impl<'tcx, T> UndoLogs<T> for InferCtxtUndoLogs<'tcx>\n+where\n+    UndoLog<'tcx>: From<T>,\n+{\n+    fn num_open_snapshots(&self) -> usize {\n+        self.num_open_snapshots\n+    }\n+    fn push(&mut self, undo: T) {\n+        if self.in_snapshot() {\n+            self.logs.push(undo.into())\n+        }\n+    }\n+    fn clear(&mut self) {\n+        self.logs.clear();\n+        self.num_open_snapshots = 0;\n+    }\n+    fn extend<J>(&mut self, undos: J)\n+    where\n+        Self: Sized,\n+        J: IntoIterator<Item = T>,\n+    {\n+        if self.in_snapshot() {\n+            self.logs.extend(undos.into_iter().map(UndoLog::from))\n+        }\n+    }\n+}\n+\n+impl<'tcx> Snapshots<UndoLog<'tcx>> for InferCtxtUndoLogs<'tcx> {\n+    type Snapshot = Snapshot<'tcx>;\n+    fn actions_since_snapshot(&self, snapshot: &Self::Snapshot) -> &[UndoLog<'tcx>] {\n+        &self.logs[snapshot.undo_len..]\n+    }\n+\n+    fn start_snapshot(&mut self) -> Self::Snapshot {\n+        self.num_open_snapshots += 1;\n+        Snapshot { undo_len: self.logs.len(), _marker: PhantomData }\n+    }\n+\n+    fn rollback_to<R>(&mut self, values: impl FnOnce() -> R, snapshot: Self::Snapshot)\n+    where\n+        R: Rollback<UndoLog<'tcx>>,\n+    {\n+        debug!(\"rollback_to({})\", snapshot.undo_len);\n+        self.assert_open_snapshot(&snapshot);\n+\n+        if self.logs.len() > snapshot.undo_len {\n+            let mut values = values();\n+            while self.logs.len() > snapshot.undo_len {\n+                values.reverse(self.logs.pop().unwrap());\n+            }\n+        }\n+\n+        if self.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.undo_len == 0);\n+            self.logs.clear();\n+        }\n+\n+        self.num_open_snapshots -= 1;\n+    }\n+\n+    fn commit(&mut self, snapshot: Self::Snapshot) {\n+        debug!(\"commit({})\", snapshot.undo_len);\n+\n+        if self.num_open_snapshots == 1 {\n+            // The root snapshot. It's safe to clear the undo log because\n+            // there's no snapshot further out that we might need to roll back\n+            // to.\n+            assert!(snapshot.undo_len == 0);\n+            self.logs.clear();\n+        }\n+\n+        self.num_open_snapshots -= 1;\n+    }\n+}\n+\n+impl<'tcx> InferCtxtUndoLogs<'tcx> {\n+    pub(crate) fn region_constraints_in_snapshot(\n+        &self,\n+        s: &Snapshot<'tcx>,\n+    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n+        self.logs[s.undo_len..].iter().filter_map(|log| match log {\n+            UndoLog::RegionConstraintCollector(log) => Some(log),\n+            _ => None,\n+        })\n+    }\n+\n+    pub(crate) fn region_constraints(\n+        &self,\n+    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n+        self.logs.iter().filter_map(|log| match log {\n+            UndoLog::RegionConstraintCollector(log) => Some(log),\n+            _ => None,\n+        })\n+    }\n+\n+    fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n+        // Failures here may indicate a failure to follow a stack discipline.\n+        assert!(self.logs.len() >= snapshot.undo_len);\n+        assert!(self.num_open_snapshots > 0);\n+    }\n+\n+    pub(crate) fn iter(&self) -> std::slice::Iter<'_, UndoLog<'tcx>> {\n+        self.logs.iter()\n+    }\n+}\n+\n+impl<'tcx> std::ops::Index<usize> for InferCtxtUndoLogs<'tcx> {\n+    type Output = UndoLog<'tcx>;\n+    fn index(&self, key: usize) -> &Self::Output {\n+        &self.logs[key]\n+    }\n+}\n+\n+impl<'tcx> std::ops::IndexMut<usize> for InferCtxtUndoLogs<'tcx> {\n+    fn index_mut(&mut self, key: usize) -> &mut Self::Output {\n+        &mut self.logs[key]\n+    }\n+}"}]}