{"sha": "609bb27514fe71f08040aef1eb8a7acd098e9185", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwOWJiMjc1MTRmZTcxZjA4MDQwYWVmMWViOGE3YWNkMDk4ZTkxODU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-04T15:19:43Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-01T14:27:15Z"}, "message": "categorize `Locations` as interesting or boring", "tree": {"sha": "7c2f022055cf5dc4b9c6335d094970e2bfde9a97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c2f022055cf5dc4b9c6335d094970e2bfde9a97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/609bb27514fe71f08040aef1eb8a7acd098e9185", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAls45MMACgkQAXYLT59T\n8VSRaQ//WMAm20gQ7KiGSr/gCAv53gYWaWavFU/Y+Y632Kxy36X9/xJBPrrMeSIu\nH4U/8938UpIPsI2VsLtBkJt6Cn3XlOXMzQdbtabXpl4wQqTcRQ9yRZnxBgW+wuXQ\ns5uWsWuZEUChm9Wmb1BnieF6/ZSFytl3Pb0tm5AIAmfrzvS4hCczOSEYgEmxsCXT\nvlXvbjjltOtmYJ/qQR4BK554+2vNN5XSDcHTk7hQBTJEDCctPSlMOaEY44oUhDQD\n+6tLwD4IN8gzRPVVjtP5UueeVylr8MxmfaZm1RTZYuF3RUS/XBwmJlrOXOQDyVqL\nL7jx7cskt56/D8NsFJKrbnSa/bl2SYRzYNz1aQHZLvqqPJbEbb8qC38YzRh/k4HK\nzEWMxZLMOWzYyVBRJ/QE8P/Cgd92ywINzUhS010Xx7/Wd7GZQ0Y+lPkcH/Y6O5AD\nYare9UNAoxtyXwe5mRSt/OuwzCT4oVG3w5pGvX84dFJZ2IlUIEQODzhES+u0EauO\nSay8/NQjUF2k00ywPJDZSndkbE+85yoLWNt/W6UjIIIJHK887ciKwYeYzOR9xlY3\n8E+xJ97++Ip4AoeF6G0HI+qBD7vQA/RAXiiv2Dl7WX7qKTDKBul2LOw/dBIBbgOo\n1swBXLqStdRyqqB40J9DQ64sXrREHi3aQh3u07qX5D/uA+gQv7o=\n=ry3C\n-----END PGP SIGNATURE-----", "payload": "tree 7c2f022055cf5dc4b9c6335d094970e2bfde9a97\nparent dbeda5ee29ddfd9195f540860020afd1a628bde2\nauthor Niko Matsakis <niko@alum.mit.edu> 1528125583 -0400\ncommitter David Wood <david@davidtw.co> 1530455235 +0100\n\ncategorize `Locations` as interesting or boring\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/609bb27514fe71f08040aef1eb8a7acd098e9185", "html_url": "https://github.com/rust-lang/rust/commit/609bb27514fe71f08040aef1eb8a7acd098e9185", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/609bb27514fe71f08040aef1eb8a7acd098e9185/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbeda5ee29ddfd9195f540860020afd1a628bde2", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbeda5ee29ddfd9195f540860020afd1a628bde2", "html_url": "https://github.com/rust-lang/rust/commit/dbeda5ee29ddfd9195f540860020afd1a628bde2"}], "stats": {"total": 92, "additions": 48, "deletions": 44}, "files": [{"sha": "d84dcc5678279a918a545e914832c2c989e59454", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/609bb27514fe71f08040aef1eb8a7acd098e9185/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609bb27514fe71f08040aef1eb8a7acd098e9185/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=609bb27514fe71f08040aef1eb8a7acd098e9185", "patch": "@@ -199,7 +199,7 @@ impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flo\n         });\n \n         if let Some(data) = &drop_data.region_constraint_data {\n-            self.cx.push_region_constraints(location.at_self(), data);\n+            self.cx.push_region_constraints(location.boring(), data);\n         }\n \n         drop_data.dropck_result.report_overflows("}, {"sha": "404e04ef4ccefe70604c312dbc16547d20b9624c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/609bb27514fe71f08040aef1eb8a7acd098e9185/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/609bb27514fe71f08040aef1eb8a7acd098e9185/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=609bb27514fe71f08040aef1eb8a7acd098e9185", "patch": "@@ -288,7 +288,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                         tcx.predicates_of(def_id).instantiate(tcx, substs);\n                     type_checker.normalize_and_prove_instantiated_predicates(\n                         instantiated_predicates,\n-                        location,\n+                        location.boring(),\n                     );\n                 }\n \n@@ -313,10 +313,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n \n         debug!(\"sanitize_constant: expected_ty={:?}\", expected_ty);\n \n-        if let Err(terr) = self\n-            .cx\n-            .eq_types(expected_ty, constant.ty, location.at_self())\n-        {\n+        if let Err(terr) = self.cx.eq_types(expected_ty, constant.ty, location.boring()) {\n             span_mirbug!(\n                 self,\n                 constant,\n@@ -346,7 +343,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n-                if let Err(terr) = self.cx.eq_types(ty, sty, location.at_self()) {\n+                if let Err(terr) = self.cx.eq_types(ty, sty, location.boring()) {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -390,7 +387,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             // (e.g., #29149). Note that we decide to use Copy before knowing whether the bounds\n             // fully apply: in effect, the rule is that if a value of some type could implement\n             // Copy, then it must.\n-            self.cx.prove_trait_ref(trait_ref, location);\n+            self.cx.prove_trait_ref(trait_ref, location.interesting());\n         }\n         place_ty\n     }\n@@ -489,7 +486,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n                 match self.field_ty(place, base, field, location) {\n-                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.at_self()) {\n+                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.boring()) {\n                         span_mirbug!(\n                             self,\n                             place,\n@@ -787,7 +784,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             StatementKind::Assign(ref place, ref rv) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = rv.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(rv_ty, place_ty, location.at_self()) {\n+                if let Err(terr) = self.sub_types(rv_ty, place_ty, location.interesting()) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n@@ -802,7 +799,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     def_id: tcx.lang_items().sized_trait().unwrap(),\n                     substs: tcx.mk_substs_trait(place_ty, &[]),\n                 };\n-                self.prove_trait_ref(trait_ref, location);\n+                self.prove_trait_ref(trait_ref, location.interesting());\n             }\n             StatementKind::SetDiscriminant {\n                 ref place,\n@@ -909,7 +906,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 ..\n             } => {\n                 let discr_ty = discr.ty(mir, tcx);\n-                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.at_self()) {\n+                if let Err(terr) = self.sub_types(discr_ty, switch_ty, term_location.boring()) {\n                     span_mirbug!(\n                         self,\n                         term,\n@@ -949,7 +946,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                 self.prove_predicates(\n                     sig.inputs().iter().map(|ty| ty::Predicate::WellFormed(ty)),\n-                    term_location,\n+                    term_location.boring(),\n                 );\n \n                 // The ordinary liveness rules will ensure that all\n@@ -991,7 +988,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.at_self()) {\n+                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.interesting()) {\n                             span_mirbug!(\n                                 self,\n                                 term,\n@@ -1056,7 +1053,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n         for (n, (fn_arg, op_arg)) in sig.inputs().iter().zip(args).enumerate() {\n             let op_arg_ty = op_arg.ty(mir, self.tcx());\n-            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.at_self()) {\n+            if let Err(terr) = self.sub_types(op_arg_ty, fn_arg, term_location.interesting()) {\n                 span_mirbug!(\n                     self,\n                     term,\n@@ -1284,7 +1281,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(operand_ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location);\n+                self.prove_trait_ref(trait_ref, location.interesting());\n             },\n \n             Rvalue::NullaryOp(_, ty) => {\n@@ -1293,7 +1290,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     substs: tcx.mk_substs_trait(ty, &[]),\n                 };\n \n-                self.prove_trait_ref(trait_ref, location);\n+                self.prove_trait_ref(trait_ref, location.interesting());\n             }\n \n             Rvalue::Cast(cast_kind, op, ty) => match cast_kind {\n@@ -1309,7 +1306,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                     let ty_fn_ptr_from = tcx.mk_fn_ptr(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n                         span_mirbug!(\n                             self,\n                             rvalue,\n@@ -1330,7 +1327,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     };\n                     let ty_fn_ptr_from = tcx.coerce_closure_fn_ty(sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n                         span_mirbug!(\n                             self,\n                             rvalue,\n@@ -1354,7 +1351,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n                     let ty_fn_ptr_from = tcx.safe_to_unsafe_fn_ty(fn_sig);\n \n-                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.at_self()) {\n+                    if let Err(terr) = self.eq_types(ty_fn_ptr_from, ty, location.interesting()) {\n                         span_mirbug!(\n                             self,\n                             rvalue,\n@@ -1373,7 +1370,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         substs: tcx.mk_substs_trait(op.ty(mir, tcx), &[ty.into()]),\n                     };\n \n-                    self.prove_trait_ref(trait_ref, location);\n+                    self.prove_trait_ref(trait_ref, location.interesting());\n                 }\n \n                 CastKind::Misc => {}\n@@ -1422,7 +1419,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n             };\n             let operand_ty = operand.ty(mir, tcx);\n-            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.at_self()) {\n+\n+            if let Err(terr) = self.sub_types(operand_ty, field_ty, location.boring()) {\n                 span_mirbug!(\n                     self,\n                     rvalue,\n@@ -1483,8 +1481,9 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                         *substs,\n                     );\n \n+                    // Hmm, are these constraints *really* boring?\n                     self.push_region_constraints(\n-                        location.at_self(),\n+                        location.boring(),\n                         &closure_constraints,\n                     );\n                 }\n@@ -1499,53 +1498,53 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n         };\n \n-        self.normalize_and_prove_instantiated_predicates(instantiated_predicates, location);\n+        self.normalize_and_prove_instantiated_predicates(instantiated_predicates, location.boring());\n     }\n \n-    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, location: Location) {\n+    fn prove_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>, locations: Locations) {\n         self.prove_predicates(\n             Some(ty::Predicate::Trait(\n                 trait_ref.to_poly_trait_ref().to_poly_trait_predicate(),\n             )),\n-            location,\n+            locations,\n         );\n     }\n \n     fn normalize_and_prove_instantiated_predicates(\n         &mut self,\n         instantiated_predicates: ty::InstantiatedPredicates<'tcx>,\n-        location: Location,\n+        locations: Locations,\n     ) {\n         for predicate in instantiated_predicates.predicates {\n-            let predicate = self.normalize(predicate, location);\n-            self.prove_predicate(predicate, location);\n+            let predicate = self.normalize(predicate, locations);\n+            self.prove_predicate(predicate, locations);\n         }\n     }\n \n     fn prove_predicates(\n         &mut self,\n         predicates: impl IntoIterator<Item = ty::Predicate<'tcx>>,\n-        location: Location,\n+        locations: Locations,\n     ) {\n         for predicate in predicates {\n             debug!(\n-                \"prove_predicates(predicate={:?}, location={:?})\",\n-                predicate, location,\n+                \"prove_predicates(predicate={:?}, locations={:?})\",\n+                predicate, locations,\n             );\n \n-            self.prove_predicate(predicate, location);\n+            self.prove_predicate(predicate, locations);\n         }\n     }\n \n-    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, location: Location) {\n+    fn prove_predicate(&mut self, predicate: ty::Predicate<'tcx>, locations: Locations) {\n         debug!(\n             \"prove_predicate(predicate={:?}, location={:?})\",\n-            predicate, location,\n+            predicate, locations,\n         );\n \n         let param_env = self.param_env;\n         self.fully_perform_op(\n-            location.at_self(),\n+            locations,\n             param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n         ).unwrap_or_else(|NoSolution| {\n             span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n@@ -1632,20 +1631,25 @@ impl MirPass for TypeckMir {\n }\n \n trait AtLocation {\n-    /// Creates a `Locations` where `self` is both the from-location\n-    /// and the at-location. This means that any required region\n-    /// relationships must hold upon entering the statement/terminator\n-    /// indicated by `self`. This is typically used when processing\n-    /// \"inputs\" to the given location.\n-    fn at_self(self) -> Locations;\n+    /// Indicates a \"boring\" constraint that the user probably\n+    /// woudln't want to see highlights.\n+    fn boring(self) -> Locations;\n+\n+    /// Indicates an \"interesting\" edge, which is of significance only\n+    /// for diagnostics.\n+    fn interesting(self) -> Locations;\n }\n \n impl AtLocation for Location {\n-    fn at_self(self) -> Locations {\n+    fn boring(self) -> Locations {\n         Locations::Pair {\n             from_location: self,\n         }\n     }\n+\n+    fn interesting(self) -> Locations {\n+        self.boring()\n+    }\n }\n \n trait NormalizeLocation: fmt::Debug + Copy {\n@@ -1660,6 +1664,6 @@ impl NormalizeLocation for Locations {\n \n impl NormalizeLocation for Location {\n     fn to_locations(self) -> Locations {\n-        self.at_self()\n+        self.boring()\n     }\n }"}]}