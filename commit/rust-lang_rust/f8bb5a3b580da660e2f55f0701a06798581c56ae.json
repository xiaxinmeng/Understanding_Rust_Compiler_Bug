{"sha": "f8bb5a3b580da660e2f55f0701a06798581c56ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4YmI1YTNiNTgwZGE2NjBlMmY1NWYwNzAxYTA2Nzk4NTgxYzU2YWU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-21T22:32:31Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-07-22T00:39:06Z"}, "message": "Make ty::ctxt be boxed.\n\nArguably we should leave ty_ctxt as a bare rec and just always work with\nboxes of it. This winds up being simpler and prettier, though.", "tree": {"sha": "4decb936647c1209366878bb25870f8a79ad8131", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4decb936647c1209366878bb25870f8a79ad8131"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8bb5a3b580da660e2f55f0701a06798581c56ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8bb5a3b580da660e2f55f0701a06798581c56ae", "html_url": "https://github.com/rust-lang/rust/commit/f8bb5a3b580da660e2f55f0701a06798581c56ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8bb5a3b580da660e2f55f0701a06798581c56ae/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9a1392b2c1fece9447a2b834896b4316c5dbfff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9a1392b2c1fece9447a2b834896b4316c5dbfff", "html_url": "https://github.com/rust-lang/rust/commit/a9a1392b2c1fece9447a2b834896b4316c5dbfff"}], "stats": {"total": 95, "additions": 45, "deletions": 50}, "files": [{"sha": "01ae803c9e20c7b49190ffb68ce8f2e40433f3af", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f8bb5a3b580da660e2f55f0701a06798581c56ae/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8bb5a3b580da660e2f55f0701a06798581c56ae/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=f8bb5a3b580da660e2f55f0701a06798581c56ae", "patch": "@@ -143,7 +143,7 @@ fn compile_input(session::session sess, ast::crate_cfg cfg, str input,\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n     time(time_passes, \"alias checking\",\n-         bind middle::alias::check_crate(@ty_cx, crate));\n+         bind middle::alias::check_crate(ty_cx, crate));\n     auto llmod =\n         time[llvm::llvm::ModuleRef](time_passes, \"translation\",\n                                     bind trans::trans_crate"}, {"sha": "fd03e264d497296a320adda91aab49e1afb2e539", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f8bb5a3b580da660e2f55f0701a06798581c56ae/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8bb5a3b580da660e2f55f0701a06798581c56ae/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=f8bb5a3b580da660e2f55f0701a06798581c56ae", "patch": "@@ -36,10 +36,10 @@ type scope = @restrict[];\n \n tag local_info { arg(ast::mode); objfield(ast::mutability); }\n \n-type ctx = rec(@ty::ctxt tcx,\n+type ctx = rec(ty::ctxt tcx,\n                std::map::hashmap[node_id, local_info] local_map);\n \n-fn check_crate(@ty::ctxt tcx, &@ast::crate crate) {\n+fn check_crate(ty::ctxt tcx, &@ast::crate crate) {\n     auto cx = @rec(tcx=tcx,\n                    // Stores information about object fields and function\n                    // arguments that's otherwise not easily available.\n@@ -149,7 +149,7 @@ fn visit_decl(&@ctx cx, &@ast::decl d, &scope sc, &vt[scope] v) {\n \n fn check_call(&ctx cx, &@ast::expr f, &(@ast::expr)[] args, &scope sc) ->\n    rec(node_id[] root_vars, ty::t[] unsafe_ts) {\n-    auto fty = ty::expr_ty(*cx.tcx, f);\n+    auto fty = ty::expr_ty(cx.tcx, f);\n     auto arg_ts = fty_args(cx, fty);\n     let node_id[] roots = ~[];\n     let tup(uint, node_id)[] mut_roots = ~[];\n@@ -248,7 +248,7 @@ fn check_tail_call(&ctx cx, &@ast::expr call) {\n             case (ast::expr_call(?f, ?args_)) { args = args_; f }\n         };\n     auto i = 0u;\n-    for (ty::arg arg_t in fty_args(cx, ty::expr_ty(*cx.tcx, f))) {\n+    for (ty::arg arg_t in fty_args(cx, ty::expr_ty(cx.tcx, f))) {\n         if (arg_t.mode != ty::mo_val) {\n             auto mut_a = arg_t.mode == ty::mo_alias(true);\n             auto ok = true;\n@@ -354,15 +354,15 @@ fn check_for(&ctx cx, &@ast::local local, &@ast::expr seq, &ast::block block,\n     auto unsafe = alt (inner_mut(root.ds)) { some(?t) { ~[t] } _ { ~[] } };\n \n     // If this is a mutable vector, don't allow it to be touched.\n-    auto seq_t = ty::expr_ty(*cx.tcx, seq);\n-    alt (ty::struct(*cx.tcx, seq_t)) {\n+    auto seq_t = ty::expr_ty(cx.tcx, seq);\n+    alt (ty::struct(cx.tcx, seq_t)) {\n         ty::ty_vec(?mt) | ty::ty_ivec(?mt) {\n             if (mt.mut != ast::imm) { unsafe = ~[seq_t]; }\n         }\n         ty::ty_str | ty::ty_istr { /* no-op */ }\n         _ {\n             cx.tcx.sess.span_unimpl(seq.span, \"unknown seq type \" +\n-                                    util::ppaux::ty_to_str(*cx.tcx, seq_t));\n+                                    util::ppaux::ty_to_str(cx.tcx, seq_t));\n         }\n     }\n     auto new_sc =\n@@ -380,7 +380,7 @@ fn check_var(&ctx cx, &@ast::expr ex, &ast::path p, ast::node_id id,\n     auto def = cx.tcx.def_map.get(id);\n     if (!def_is_local(def, true)) { ret; }\n     auto my_defnum = ast::def_id_of_def(def)._1;\n-    auto var_t = ty::expr_ty(*cx.tcx, ex);\n+    auto var_t = ty::expr_ty(cx.tcx, ex);\n     for (restrict r in *sc) {\n         // excludes variables introduced since the alias was made\n         if (my_defnum < r.block_defnum) {\n@@ -523,7 +523,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n    rec(@ast::expr ex, @deref[] ds) {\n     fn maybe_auto_unbox(&ctx cx, &ty::t t) ->\n        rec(ty::t t, option::t[deref] d) {\n-        alt (ty::struct(*cx.tcx, t)) {\n+        alt (ty::struct(cx.tcx, t)) {\n             case (ty::ty_box(?mt)) {\n                 ret rec(t=mt.ty,\n                         d=some(@rec(mut=mt.mut != ast::imm,\n@@ -541,9 +541,9 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n         alt ({ ex.node }) {\n             case (ast::expr_field(?base, ?ident)) {\n                 auto auto_unbox =\n-                    maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n+                    maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n                 auto mut = false;\n-                alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n+                alt (ty::struct(cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_tup(?fields)) {\n                         auto fnm = ty::field_num(cx.tcx.sess, ex.span, ident);\n                         mut = fields.(fnm).mut != ast::imm;\n@@ -564,8 +564,8 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n             }\n             case (ast::expr_index(?base, _)) {\n                 auto auto_unbox =\n-                    maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, base));\n-                alt (ty::struct(*cx.tcx, auto_unbox.t)) {\n+                    maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, base));\n+                alt (ty::struct(cx.tcx, auto_unbox.t)) {\n                     case (ty::ty_vec(?mt)) {\n                         ds += ~[@rec(mut=mt.mut != ast::imm,\n                                     kind=index,\n@@ -582,9 +582,9 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n             }\n             case (ast::expr_unary(?op, ?base)) {\n                 if (op == ast::deref) {\n-                    auto base_t = ty::expr_ty(*cx.tcx, base);\n+                    auto base_t = ty::expr_ty(cx.tcx, base);\n                     auto mut = false;\n-                    alt (ty::struct(*cx.tcx, base_t)) {\n+                    alt (ty::struct(cx.tcx, base_t)) {\n                         case (ty::ty_box(?mt)) { mut = mt.mut != ast::imm; }\n                         case (ty::ty_res(_, _, _)) {}\n                         case (ty::ty_tag(_, _)) {}\n@@ -598,7 +598,7 @@ fn expr_root(&ctx cx, @ast::expr ex, bool autoderef) ->\n         }\n     }\n     if (autoderef) {\n-        auto auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(*cx.tcx, ex));\n+        auto auto_unbox = maybe_auto_unbox(cx, ty::expr_ty(cx.tcx, ex));\n         maybe_push_auto_unbox(auto_unbox.d, ds);\n     }\n     ret rec(ex=ex, ds=@ds);\n@@ -669,7 +669,7 @@ fn ty_can_unsafely_include(&ctx cx, ty::t needle, ty::t haystack, bool mut) ->\n             _ { ret false; }\n         }\n     }\n-    ret helper(*cx.tcx, needle, haystack, mut);\n+    ret helper(cx.tcx, needle, haystack, mut);\n }\n \n fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n@@ -681,7 +681,7 @@ fn def_is_local(&ast::def d, bool objfields_count) -> bool {\n }\n \n fn fty_args(&ctx cx, ty::t fty) -> ty::arg[] {\n-    ret alt (ty::struct(*cx.tcx, ty::type_autoderef(*cx.tcx, fty))) {\n+    ret alt (ty::struct(cx.tcx, ty::type_autoderef(cx.tcx, fty))) {\n         ty::ty_fn(_, ?args, _, _, _) | ty::ty_native_fn(_, ?args, _) { args }\n     };\n }"}, {"sha": "61e61579e67d5da18a15a12196db3952709c66dc", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f8bb5a3b580da660e2f55f0701a06798581c56ae/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8bb5a3b580da660e2f55f0701a06798581c56ae/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=f8bb5a3b580da660e2f55f0701a06798581c56ae", "patch": "@@ -207,20 +207,20 @@ type mt = rec(t ty, ast::mutability mut);\n type creader_cache = hashmap[tup(int, uint, uint), ty::t];\n \n type ctxt =\n-    rec(@type_store ts,\n-        session::session sess,\n-        resolve::def_map def_map,\n-        node_type_table node_types,\n-        ast_map::map items,\n-        freevars::freevar_map freevars,\n-\n-        //        constr_table fn_constrs,\n-        type_cache tcache,\n-        creader_cache rcache,\n-        hashmap[t, str] short_names_cache,\n-        hashmap[t, bool] has_pointer_cache,\n-        hashmap[t, bool] owns_heap_mem_cache,\n-        hashmap[@ast::ty, option::t[t]] ast_ty_to_ty_cache);\n+    @rec(@type_store ts,\n+         session::session sess,\n+         resolve::def_map def_map,\n+         node_type_table node_types,\n+         ast_map::map items,\n+         freevars::freevar_map freevars,\n+\n+         //        constr_table fn_constrs,\n+         type_cache tcache,\n+         creader_cache rcache,\n+         hashmap[t, str] short_names_cache,\n+         hashmap[t, bool] has_pointer_cache,\n+         hashmap[t, bool] owns_heap_mem_cache,\n+         hashmap[@ast::ty, option::t[t]] ast_ty_to_ty_cache);\n \n type ty_ctxt = ctxt;\n \n@@ -405,23 +405,18 @@ fn mk_ctxt(session::session s, resolve::def_map dm,\n     auto tcache = new_def_hash[ty::ty_param_count_and_ty]();\n     auto ts = @interner::mk[@raw_t](hash_raw_ty, eq_raw_ty);\n     auto cx =\n-        rec(ts=ts,\n-            sess=s,\n-            def_map=dm,\n-            node_types=ntt,\n-            items=amap,\n-            freevars=freevars,\n-            tcache=tcache,\n-            rcache=mk_rcache(),\n-            short_names_cache=map::mk_hashmap[ty::t,\n-                                              str](ty::hash_ty, ty::eq_ty),\n-            has_pointer_cache=map::mk_hashmap[ty::t,\n-                                              bool](ty::hash_ty, ty::eq_ty),\n-            owns_heap_mem_cache=map::mk_hashmap[ty::t,\n-                                                bool](ty::hash_ty, ty::eq_ty),\n-            ast_ty_to_ty_cache=map::mk_hashmap[@ast::ty,\n-                                               option::t[t]](ast::hash_ty,\n-                                                             ast::eq_ty));\n+        @rec(ts=ts,\n+             sess=s,\n+             def_map=dm,\n+             node_types=ntt,\n+             items=amap,\n+             freevars=freevars,\n+             tcache=tcache,\n+             rcache=mk_rcache(),\n+             short_names_cache=map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+             has_pointer_cache=map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+             owns_heap_mem_cache=map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n+             ast_ty_to_ty_cache=map::mk_hashmap(ast::hash_ty, ast::eq_ty));\n     populate_type_store(cx);\n     ret cx;\n }"}]}