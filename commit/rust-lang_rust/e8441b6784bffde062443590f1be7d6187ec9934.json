{"sha": "e8441b6784bffde062443590f1be7d6187ec9934", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NDQxYjY3ODRiZmZkZTA2MjQ0MzU5MGYxYmU3ZDYxODdlYzk5MzQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-03-24T15:40:49Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-04-15T14:05:53Z"}, "message": "Add initial version of codegen unit partitioning for incremental compilation.", "tree": {"sha": "956bb85e07ef2d40d326f4f176932f50e64d0235", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/956bb85e07ef2d40d326f4f176932f50e64d0235"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8441b6784bffde062443590f1be7d6187ec9934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8441b6784bffde062443590f1be7d6187ec9934", "html_url": "https://github.com/rust-lang/rust/commit/e8441b6784bffde062443590f1be7d6187ec9934", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8441b6784bffde062443590f1be7d6187ec9934/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2217ddb58feb55c5792626696608b91acb661b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2217ddb58feb55c5792626696608b91acb661b5", "html_url": "https://github.com/rust-lang/rust/commit/a2217ddb58feb55c5792626696608b91acb661b5"}], "stats": {"total": 1395, "additions": 1326, "deletions": 69}, "files": [{"sha": "af482f781ab6e0689acd081c698f04e55e872770", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 130, "deletions": 17, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -1911,6 +1911,7 @@ fn run_rustdoc_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n }\n \n fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {\n+\n     assert!(props.revisions.is_empty(), \"revisions not relevant here\");\n \n     let proc_res = compile_test(config, props, testpaths);\n@@ -1921,36 +1922,148 @@ fn run_codegen_units_test(config: &Config, props: &TestProps, testpaths: &TestPa\n \n     check_no_compiler_crash(None, &proc_res);\n \n-    let prefix = \"TRANS_ITEM \";\n+    const PREFIX: &'static str = \"TRANS_ITEM \";\n+    const CGU_MARKER: &'static str = \"@@\";\n \n-    let actual: HashSet<String> = proc_res\n+    let actual: Vec<TransItem> = proc_res\n         .stdout\n         .lines()\n-        .filter(|line| line.starts_with(prefix))\n-        .map(|s| (&s[prefix.len()..]).to_string())\n+        .filter(|line| line.starts_with(PREFIX))\n+        .map(str_to_trans_item)\n         .collect();\n \n-    let expected: HashSet<String> = errors::load_errors(&testpaths.file, None)\n+    let expected: Vec<TransItem> = errors::load_errors(&testpaths.file, None)\n         .iter()\n-        .map(|e| e.msg.trim().to_string())\n+        .map(|e| str_to_trans_item(&e.msg[..]))\n         .collect();\n \n-    if actual != expected {\n-        let mut missing: Vec<_> = expected.difference(&actual).collect();\n+    let mut missing = Vec::new();\n+    let mut wrong_cgus = Vec::new();\n+\n+    for expected_item in &expected {\n+        let actual_item_with_same_name = actual.iter()\n+                                               .find(|ti| ti.name == expected_item.name);\n+\n+        if let Some(actual_item) = actual_item_with_same_name {\n+            if !expected_item.codegen_units.is_empty() {\n+                // Also check for codegen units\n+                if expected_item.codegen_units != actual_item.codegen_units {\n+                    wrong_cgus.push((expected_item.clone(), actual_item.clone()));\n+                }\n+            }\n+        } else {\n+            missing.push(expected_item.string.clone());\n+        }\n+    }\n+\n+    let unexpected: Vec<_> =\n+        actual.iter()\n+              .filter(|acgu| !expected.iter().any(|ecgu| acgu.name == ecgu.name))\n+              .map(|acgu| acgu.string.clone())\n+              .collect();\n+\n+    if !missing.is_empty() {\n         missing.sort();\n \n-        let mut too_much: Vec<_> = actual.difference(&expected).collect();\n-        too_much.sort();\n+        println!(\"\\nThese items should have been contained but were not:\\n\");\n+\n+        for item in &missing {\n+            println!(\"{}\", item);\n+        }\n \n-        println!(\"Expected and actual sets of codegen-items differ.\\n\\\n-                  These items should have been contained but were not:\\n\\n\\\n-                  {}\\n\\n\\\n-                  These items were contained but should not have been:\\n\\n\\\n-                  {}\\n\\n\",\n-            missing.iter().fold(\"\".to_string(), |s1, s2| s1 + \"\\n\" + s2),\n-            too_much.iter().fold(\"\".to_string(), |s1, s2| s1 + \"\\n\" + s2));\n+        println!(\"\\n\");\n+    }\n+\n+    if !unexpected.is_empty() {\n+        let sorted = {\n+            let mut sorted = unexpected.clone();\n+            sorted.sort();\n+            sorted\n+        };\n+\n+        println!(\"\\nThese items were contained but should not have been:\\n\");\n+\n+        for item in sorted {\n+            println!(\"{}\", item);\n+        }\n+\n+        println!(\"\\n\");\n+    }\n+\n+    if !wrong_cgus.is_empty() {\n+        wrong_cgus.sort_by_key(|pair| pair.0.name.clone());\n+        println!(\"\\nThe following items were assigned to wrong codegen units:\\n\");\n+\n+        for &(ref expected_item, ref actual_item) in &wrong_cgus {\n+            println!(\"{}\", expected_item.name);\n+            println!(\"  expected: {}\", codegen_units_to_str(&expected_item.codegen_units));\n+            println!(\"  actual:   {}\", codegen_units_to_str(&actual_item.codegen_units));\n+            println!(\"\");\n+        }\n+    }\n+\n+    if !(missing.is_empty() && unexpected.is_empty() && wrong_cgus.is_empty())\n+    {\n         panic!();\n     }\n+\n+    #[derive(Clone, Eq, PartialEq)]\n+    struct TransItem {\n+        name: String,\n+        codegen_units: HashSet<String>,\n+        string: String,\n+    }\n+\n+    // [TRANS_ITEM] name [@@ (cgu)+]\n+    fn str_to_trans_item(s: &str) -> TransItem {\n+        let s = if s.starts_with(PREFIX) {\n+            (&s[PREFIX.len()..]).trim()\n+        } else {\n+            s.trim()\n+        };\n+\n+        let full_string = format!(\"{}{}\", PREFIX, s.trim().to_owned());\n+\n+        let parts: Vec<&str> = s.split(CGU_MARKER)\n+                                .map(str::trim)\n+                                .filter(|s| !s.is_empty())\n+                                .collect();\n+\n+        let name = parts[0].trim();\n+\n+        let cgus = if parts.len() > 1 {\n+            let cgus_str = parts[1];\n+\n+            cgus_str.split(\" \")\n+                    .map(str::trim)\n+                    .filter(|s| !s.is_empty())\n+                    .map(str::to_owned)\n+                    .collect()\n+        }\n+        else {\n+            HashSet::new()\n+        };\n+\n+        TransItem {\n+            name: name.to_owned(),\n+            codegen_units: cgus,\n+            string: full_string,\n+        }\n+    }\n+\n+    fn codegen_units_to_str(cgus: &HashSet<String>) -> String\n+    {\n+        let mut cgus: Vec<_> = cgus.iter().collect();\n+        cgus.sort();\n+\n+        let mut string = String::new();\n+        for cgu in cgus {\n+            string.push_str(&cgu[..]);\n+            string.push_str(\" \");\n+        }\n+\n+        string\n+    }\n }\n \n fn run_incremental_test(config: &Config, props: &TestProps, testpaths: &TestPaths) {"}, {"sha": "95f9e8eaac2e82eeef427816a36efd56b2b99e4c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -136,9 +136,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n             ItemDefaultImpl(..) | ItemImpl(..) =>\n                 DefPathData::Impl,\n             ItemEnum(..) | ItemStruct(..) | ItemTrait(..) |\n-            ItemExternCrate(..) | ItemMod(..) | ItemForeignMod(..) |\n-            ItemTy(..) =>\n+            ItemExternCrate(..) | ItemForeignMod(..) | ItemTy(..) =>\n                 DefPathData::TypeNs(i.name),\n+            ItemMod(..) =>\n+                DefPathData::Module(i.name),\n             ItemStatic(..) | ItemConst(..) | ItemFn(..) =>\n                 DefPathData::ValueNs(i.name),\n             ItemUse(..) =>"}, {"sha": "a2f0f30b62c74fd560cd9f00657182b9bde19a1b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -147,6 +147,7 @@ pub enum DefPathData {\n     Impl,\n     TypeNs(ast::Name), // something in the type NS\n     ValueNs(ast::Name), // something in the value NS\n+    Module(ast::Name),\n     MacroDef(ast::Name),\n     ClosureExpr,\n \n@@ -288,6 +289,7 @@ impl DefPathData {\n         match *self {\n             TypeNs(name) |\n             ValueNs(name) |\n+            Module(name) |\n             MacroDef(name) |\n             TypeParam(name) |\n             LifetimeDef(name) |"}, {"sha": "e390456a87c4b066ebdbbcc5fb42c0cf839d897a", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -147,6 +147,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             data @ DefPathData::Misc |\n             data @ DefPathData::TypeNs(..) |\n             data @ DefPathData::ValueNs(..) |\n+            data @ DefPathData::Module(..) |\n             data @ DefPathData::TypeParam(..) |\n             data @ DefPathData::LifetimeDef(..) |\n             data @ DefPathData::EnumVariant(..) |\n@@ -189,7 +190,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n         let self_ty = self.lookup_item_type(impl_def_id).ty;\n-        let in_self_mod = match self.characteristic_def_id_of_type(self_ty) {\n+        let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.parent_def_id(ty_def_id) == Some(parent_def_id),\n         };\n@@ -268,38 +269,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         buffer.push(&format!(\"<impl at {}>\", span_str));\n     }\n \n-    /// As a heuristic, when we see an impl, if we see that the\n-    /// 'self-type' is a type defined in the same module as the impl,\n-    /// we can omit including the path to the impl itself. This\n-    /// function tries to find a \"characteristic def-id\" for a\n-    /// type. It's just a heuristic so it makes some questionable\n-    /// decisions and we may want to adjust it later.\n-    fn characteristic_def_id_of_type(&self, ty: Ty<'tcx>) -> Option<DefId> {\n-        match ty.sty {\n-            ty::TyStruct(adt_def, _) |\n-            ty::TyEnum(adt_def, _) =>\n-                Some(adt_def.did),\n-\n-            ty::TyTrait(ref data) =>\n-                Some(data.principal_def_id()),\n-\n-            ty::TyBox(subty) =>\n-                self.characteristic_def_id_of_type(subty),\n-\n-            ty::TyRawPtr(mt) |\n-            ty::TyRef(_, mt) =>\n-                self.characteristic_def_id_of_type(mt.ty),\n-\n-            ty::TyTuple(ref tys) =>\n-                tys.iter()\n-                   .filter_map(|ty| self.characteristic_def_id_of_type(ty))\n-                   .next(),\n-\n-            _ =>\n-                None\n-        }\n-    }\n-\n     /// Returns the def-id of `def_id`'s parent in the def tree. If\n     /// this returns `None`, then `def_id` represents a crate root or\n     /// inlined root.\n@@ -309,6 +278,47 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n }\n \n+/// As a heuristic, when we see an impl, if we see that the\n+/// 'self-type' is a type defined in the same module as the impl,\n+/// we can omit including the path to the impl itself. This\n+/// function tries to find a \"characteristic def-id\" for a\n+/// type. It's just a heuristic so it makes some questionable\n+/// decisions and we may want to adjust it later.\n+pub fn characteristic_def_id_of_type<'tcx>(ty: Ty<'tcx>) -> Option<DefId> {\n+    match ty.sty {\n+        ty::TyStruct(adt_def, _) |\n+        ty::TyEnum(adt_def, _) => Some(adt_def.did),\n+\n+        ty::TyTrait(ref data) => Some(data.principal_def_id()),\n+\n+        ty::TyArray(subty, _) |\n+        ty::TySlice(subty) |\n+        ty::TyBox(subty) => characteristic_def_id_of_type(subty),\n+\n+        ty::TyRawPtr(mt) |\n+        ty::TyRef(_, mt) => characteristic_def_id_of_type(mt.ty),\n+\n+        ty::TyTuple(ref tys) => tys.iter()\n+                                   .filter_map(|ty| characteristic_def_id_of_type(ty))\n+                                   .next(),\n+\n+        ty::TyFnDef(def_id, _, _) |\n+        ty::TyClosure(def_id, _) => Some(def_id),\n+\n+        ty::TyBool |\n+        ty::TyChar |\n+        ty::TyInt(_) |\n+        ty::TyUint(_) |\n+        ty::TyStr |\n+        ty::TyFnPtr(_) |\n+        ty::TyProjection(_) |\n+        ty::TyParam(_) |\n+        ty::TyInfer(_) |\n+        ty::TyError |\n+        ty::TyFloat(_) => None,\n+    }\n+}\n+\n /// Unifying Trait for different kinds of item paths we might\n /// construct. The basic interface is that components get pushed: the\n /// instance can also customize how we handle the root of a crate."}, {"sha": "a026e546e9c68a3ac60530477b52b0b2ea0f37cd", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -97,7 +97,7 @@ pub enum Visibility {\n // DLLExportLinkage, GhostLinkage and LinkOnceODRAutoHideLinkage.\n // LinkerPrivateLinkage and LinkerPrivateWeakLinkage are not included either;\n // they've been removed in upstream LLVM commit r203866.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Linkage {\n     ExternalLinkage = 0,\n     AvailableExternallyLinkage = 1,"}, {"sha": "05ad333ed3adcf9513e9340cfcc4820920325a7b", "filename": "src/librustc_metadata/def_key.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -31,6 +31,7 @@ pub enum DefPathData {\n     Impl,\n     TypeNs,\n     ValueNs,\n+    Module,\n     MacroDef,\n     ClosureExpr,\n     TypeParam,\n@@ -61,6 +62,7 @@ fn simplify_def_path_data(data: hir_map::DefPathData) -> DefPathData {\n         hir_map::DefPathData::Impl => DefPathData::Impl,\n         hir_map::DefPathData::TypeNs(_) => DefPathData::TypeNs,\n         hir_map::DefPathData::ValueNs(_) => DefPathData::ValueNs,\n+        hir_map::DefPathData::Module(_) => DefPathData::Module,\n         hir_map::DefPathData::MacroDef(_) => DefPathData::MacroDef,\n         hir_map::DefPathData::ClosureExpr => DefPathData::ClosureExpr,\n         hir_map::DefPathData::TypeParam(_) => DefPathData::TypeParam,\n@@ -91,6 +93,7 @@ fn recover_def_path_data(data: DefPathData, name: Option<Name>) -> hir_map::DefP\n         DefPathData::Impl => hir_map::DefPathData::Impl,\n         DefPathData::TypeNs => hir_map::DefPathData::TypeNs(name.unwrap()),\n         DefPathData::ValueNs => hir_map::DefPathData::ValueNs(name.unwrap()),\n+        DefPathData::Module => hir_map::DefPathData::Module(name.unwrap()),\n         DefPathData::MacroDef => hir_map::DefPathData::MacroDef(name.unwrap()),\n         DefPathData::ClosureExpr => hir_map::DefPathData::ClosureExpr,\n         DefPathData::TypeParam => hir_map::DefPathData::TypeParam(name.unwrap()),"}, {"sha": "f084d30e0c08769017ade4f79549a9eb4ad4378c", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -58,6 +58,7 @@ use attributes;\n use build::*;\n use builder::{Builder, noname};\n use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n+use partitioning;\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n@@ -2958,14 +2959,60 @@ fn collect_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>) {\n         None => TransItemCollectionMode::Lazy\n     };\n \n-    let items = time(time_passes, \"translation item collection\", || {\n+    let (items, inlining_map) = time(time_passes, \"translation item collection\", || {\n         collector::collect_crate_translation_items(&ccx, collection_mode)\n     });\n \n+    let codegen_units = time(time_passes, \"codegen unit partitioning\", || {\n+        partitioning::partition(ccx.tcx(), items.iter().cloned(), &inlining_map)\n+    });\n+\n     if ccx.sess().opts.debugging_opts.print_trans_items.is_some() {\n-        let mut item_keys: Vec<_> = items.iter()\n-                                         .map(|i| i.to_string(ccx))\n-                                         .collect();\n+        let mut item_to_cgus = HashMap::new();\n+\n+        for cgu in codegen_units {\n+            for (trans_item, linkage) in cgu.items {\n+                item_to_cgus.entry(trans_item)\n+                            .or_insert(Vec::new())\n+                            .push((cgu.name.clone(), linkage));\n+            }\n+        }\n+\n+        let mut item_keys: Vec<_> = items\n+            .iter()\n+            .map(|i| {\n+                let mut output = i.to_string(ccx);\n+                output.push_str(\" @@\");\n+                let mut empty = Vec::new();\n+                let mut cgus = item_to_cgus.get_mut(i).unwrap_or(&mut empty);\n+                cgus.as_mut_slice().sort_by_key(|&(ref name, _)| name.clone());\n+                cgus.dedup();\n+                for &(ref cgu_name, linkage) in cgus.iter() {\n+                    output.push_str(\" \");\n+                    output.push_str(&cgu_name[..]);\n+\n+                    let linkage_abbrev = match linkage {\n+                        llvm::ExternalLinkage => \"External\",\n+                        llvm::AvailableExternallyLinkage => \"Available\",\n+                        llvm::LinkOnceAnyLinkage => \"OnceAny\",\n+                        llvm::LinkOnceODRLinkage => \"OnceODR\",\n+                        llvm::WeakAnyLinkage => \"WeakAny\",\n+                        llvm::WeakODRLinkage => \"WeakODR\",\n+                        llvm::AppendingLinkage => \"Appending\",\n+                        llvm::InternalLinkage => \"Internal\",\n+                        llvm::PrivateLinkage => \"Private\",\n+                        llvm::ExternalWeakLinkage => \"ExternalWeak\",\n+                        llvm::CommonLinkage => \"Common\",\n+                    };\n+\n+                    output.push_str(\"[\");\n+                    output.push_str(linkage_abbrev);\n+                    output.push_str(\"]\");\n+                }\n+                output\n+            })\n+            .collect();\n+\n         item_keys.sort();\n \n         for item in item_keys {"}, {"sha": "e8437393625dbe37fb4bf9638bcd40c294ef3a8f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -196,22 +196,23 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::{self, Substs, Subst};\n-use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n use syntax::ast::{self, NodeId};\n use syntax::codemap::DUMMY_SP;\n-use syntax::errors;\n+use syntax::{attr, errors};\n use syntax::parse::token;\n \n-use base::custom_coerce_unsize_info;\n+use base::{custom_coerce_unsize_info, llvm_linkage_by_name};\n use context::CrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates,\n                     type_is_sized};\n use glue;\n+use llvm;\n use meth;\n use monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n@@ -251,9 +252,12 @@ impl<'tcx> Hash for TransItem<'tcx> {\n     }\n }\n \n+pub type InliningMap<'tcx> = FnvHashMap<TransItem<'tcx>, FnvHashSet<TransItem<'tcx>>>;\n+\n pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                  mode: TransItemCollectionMode)\n-                                                 -> FnvHashSet<TransItem<'tcx>> {\n+                                                 -> (FnvHashSet<TransItem<'tcx>>,\n+                                                     InliningMap<'tcx>) {\n     // We are not tracking dependencies of this pass as it has to be re-executed\n     // every time no matter what.\n     ccx.tcx().dep_graph.with_ignore(|| {\n@@ -262,12 +266,17 @@ pub fn collect_crate_translation_items<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"Building translation item graph, beginning at roots\");\n         let mut visited = FnvHashSet();\n         let mut recursion_depths = DefIdMap();\n+        let mut inlining_map = FnvHashMap();\n \n         for root in roots {\n-            collect_items_rec(ccx, root, &mut visited, &mut recursion_depths);\n+            collect_items_rec(ccx,\n+                              root,\n+                              &mut visited,\n+                              &mut recursion_depths,\n+                              &mut inlining_map);\n         }\n \n-        visited\n+        (visited, inlining_map)\n     })\n }\n \n@@ -297,7 +306,8 @@ fn collect_roots<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                    starting_point: TransItem<'tcx>,\n                                    visited: &mut FnvHashSet<TransItem<'tcx>>,\n-                                   recursion_depths: &mut DefIdMap<usize>) {\n+                                   recursion_depths: &mut DefIdMap<usize>,\n+                                   inlining_map: &mut InliningMap<'tcx>) {\n     if !visited.insert(starting_point.clone()) {\n         // We've been here already, no need to search again.\n         return;\n@@ -312,7 +322,11 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n             find_drop_glue_neighbors(ccx, t, &mut neighbors);\n             recursion_depth_reset = None;\n         }\n-        TransItem::Static(_) => {\n+        TransItem::Static(node_id) => {\n+            let def_id = ccx.tcx().map.local_def_id(node_id);\n+            let ty = ccx.tcx().lookup_item_type(def_id).ty;\n+            let ty = glue::get_drop_glue_type(ccx, ty);\n+            neighbors.push(TransItem::DropGlue(ty));\n             recursion_depth_reset = None;\n         }\n         TransItem::Fn(instance) => {\n@@ -338,7 +352,8 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     }\n \n     for neighbour in neighbors {\n-        collect_items_rec(ccx, neighbour, visited, recursion_depths);\n+        record_inlined_use(ccx, starting_point, neighbour, inlining_map);\n+        collect_items_rec(ccx, neighbour, visited, recursion_depths, inlining_map);\n     }\n \n     if let Some((def_id, depth)) = recursion_depth_reset {\n@@ -348,6 +363,18 @@ fn collect_items_rec<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n     debug!(\"END collect_items_rec({})\", starting_point.to_string(ccx));\n }\n \n+fn record_inlined_use<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                caller: TransItem<'tcx>,\n+                                callee: TransItem<'tcx>,\n+                                inlining_map: &mut InliningMap<'tcx>) {\n+    if callee.is_from_extern_crate() ||\n+       callee.requests_inline(ccx.tcx()) {\n+        inlining_map.entry(caller)\n+                    .or_insert_with(|| FnvHashSet())\n+                    .insert(callee);\n+    }\n+}\n+\n fn check_recursion_limit<'a, 'tcx: 'a>(ccx: &CrateContext<'a, 'tcx>,\n                                        instance: Instance<'tcx>,\n                                        recursion_depths: &mut DefIdMap<usize>)\n@@ -1315,7 +1342,7 @@ fn push_instance_as_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     push_type_params(ccx, &instance.substs.types, &[], output);\n }\n \n-fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n+pub fn def_id_to_string(ccx: &CrateContext, def_id: DefId) -> String {\n     let mut output = String::new();\n     push_item_name(ccx, def_id, &mut output);\n     output\n@@ -1331,6 +1358,57 @@ fn type_to_string<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n impl<'tcx> TransItem<'tcx> {\n \n+    pub fn requests_inline(&self, tcx: &TyCtxt<'tcx>) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                let attributes = tcx.get_attrs(instance.def);\n+                attr::requests_inline(&attributes[..])\n+            }\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_from_extern_crate(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_lazily_instantiated(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn explicit_linkage(&self, tcx: &TyCtxt<'tcx>) -> Option<llvm::Linkage> {\n+        let def_id = match *self {\n+            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::DropGlue(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = llvm_linkage_by_name(&name) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.map.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n         let hir_map = &ccx.tcx().map;\n "}, {"sha": "f48409ec755738babe08e3bdf2b1b1aafe7bb21b", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -103,6 +103,7 @@ mod cabi_x86_win64;\n mod callee;\n mod cleanup;\n mod closure;\n+mod collector;\n mod common;\n mod consts;\n mod context;\n@@ -120,7 +121,7 @@ mod _match;\n mod meth;\n mod mir;\n mod monomorphize;\n-mod collector;\n+mod partitioning;\n mod symbol_names_test;\n mod tvec;\n mod type_;"}, {"sha": "f2198c0e490f618f2a090a24f9c2298a5e861f97", "filename": "src/librustc_trans/partitioning.rs", "status": "added", "additions": 363, "deletions": 0, "changes": 363, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,363 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Partitioning Codegen Units for Incremental Compilation\n+//! ======================================================\n+//!\n+//! The task of this module is to take the complete set of translation items of\n+//! a crate and produce a set of codegen units from it, where a codegen unit\n+//! is a named set of (translation-item, linkage) pairs. That is, this module\n+//! decides which translation item appears in which codegen units with which\n+//! linkage. The following paragraphs describe some of the background on the\n+//! partitioning scheme.\n+//!\n+//! The most important opportunity for saving on compilation time with\n+//! incremental compilation is to avoid re-translating and re-optimizing code.\n+//! Since the unit of translation and optimization for LLVM is \"modules\" or, how\n+//! we call them \"codegen units\", the particulars of how much time can be saved\n+//! by incremental compilation are tightly linked to how the output program is\n+//! partitioned into these codegen units prior to passing it to LLVM --\n+//! especially because we have to treat codegen units as opaque entities once\n+//! they are created: There is no way for us to incrementally update an existing\n+//! LLVM module and so we have to build any such module from scratch if it was\n+//! affected by some change in the source code.\n+//!\n+//! From that point of view it would make sense to maximize the number of\n+//! codegen units by, for example, putting each function into its own module.\n+//! That way only those modules would have to be re-compiled that were actually\n+//! affected by some change, minimizing the number of functions that could have\n+//! been re-used but just happened to be located in a module that is\n+//! re-compiled.\n+//!\n+//! However, since LLVM optimization does not work across module boundaries,\n+//! using such a highly granular partitioning would lead to very slow runtime\n+//! code since it would effectively prohibit inlining and other inter-procedure\n+//! optimizations. We want to avoid that as much as possible.\n+//!\n+//! Thus we end up with a trade-off: The bigger the codegen units, the better\n+//! LLVM's optimizer can do its work, but also the smaller the compilation time\n+//! reduction we get from incremental compilation.\n+//!\n+//! Ideally, we would create a partitioning such that there are few big codegen\n+//! units with few interdependencies between them. For now though, we use the\n+//! following heuristic to determine the partitioning:\n+//!\n+//! - There are two codegen units for every source-level module:\n+//! - One for \"stable\", that is non-generic, code\n+//! - One for more \"volatile\" code, i.e. monomorphized instances of functions\n+//!   defined in that module\n+//! - Code for monomorphized instances of functions from external crates gets\n+//!   placed into every codegen unit that uses that instance.\n+//!\n+//! In order to see why this heuristic makes sense, let's take a look at when a\n+//! codegen unit can get invalidated:\n+//!\n+//! 1. The most straightforward case is when the BODY of a function or global\n+//! changes. Then any codegen unit containing the code for that item has to be\n+//! re-compiled. Note that this includes all codegen units where the function\n+//! has been inlined.\n+//!\n+//! 2. The next case is when the SIGNATURE of a function or global changes. In\n+//! this case, all codegen units containing a REFERENCE to that item have to be\n+//! re-compiled. This is a superset of case 1.\n+//!\n+//! 3. The final and most subtle case is when a REFERENCE to a generic function\n+//! is added or removed somewhere. Even though the definition of the function\n+//! might be unchanged, a new REFERENCE might introduce a new monomorphized\n+//! instance of this function which has to be placed and compiled somewhere.\n+//! Conversely, when removing a REFERENCE, it might have been the last one with\n+//! that particular set of generic arguments and thus we have to remove it.\n+//!\n+//! From the above we see that just using one codegen unit per source-level\n+//! module is not such a good idea, since just adding a REFERENCE to some\n+//! generic item somewhere else would invalidate everything within the module\n+//! containing the generic item. The heuristic above reduces this detrimental\n+//! side-effect of references a little by at least not touching the non-generic\n+//! code of the module.\n+//!\n+//! As another optimization, monomorphized functions from external crates get\n+//! some special handling. Since we assume that the definition of such a\n+//! function changes rather infrequently compared to local items, we can just\n+//! instantiate external functions in every codegen unit where it is referenced\n+//! -- without having to fear that doing this will cause a lot of unnecessary\n+//! re-compilations. If such a reference is added or removed, the codegen unit\n+//! has to be re-translated anyway.\n+//! (Note that this only makes sense if external crates actually don't change\n+//! frequently. For certain multi-crate projects this might not be a valid\n+//! assumption).\n+//!\n+//! A Note on Inlining\n+//! ------------------\n+//! As briefly mentioned above, in order for LLVM to be able to inline a\n+//! function call, the body of the function has to be available in the LLVM\n+//! module where the call is made. This has a few consequences for partitioning:\n+//!\n+//! - The partitioning algorithm has to take care of placing functions into all\n+//!   codegen units where they should be available for inlining. It also has to\n+//!   decide on the correct linkage for these functions.\n+//!\n+//! - The partitioning algorithm has to know which functions are likely to get\n+//!   inlined, so it can distribute function instantiations accordingly. Since\n+//!   there is no way of knowing for sure which functions LLVM will decide to\n+//!   inline in the end, we apply a heuristic here: Only functions marked with\n+//!   #[inline] and (as stated above) functions from external crates are\n+//!   considered for inlining by the partitioner. The current implementation\n+//!   will not try to determine if a function is likely to be inlined by looking\n+//!   at the functions definition.\n+//!\n+//! Note though that as a side-effect of creating a codegen units per\n+//! source-level module, functions from the same module will be available for\n+//! inlining, even when they are not marked #[inline].\n+\n+use collector::{InliningMap, TransItem};\n+use context::CrateContext;\n+use monomorphize;\n+use rustc::hir::def_id::DefId;\n+use rustc::hir::map::DefPathData;\n+use rustc::ty::TyCtxt;\n+use rustc::ty::item_path::characteristic_def_id_of_type;\n+use llvm;\n+use syntax::parse::token::{self, InternedString};\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n+\n+pub struct CodegenUnit<'tcx> {\n+    pub name: InternedString,\n+    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+}\n+\n+// Anything we can't find a proper codegen unit for goes into this.\n+const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n+\n+pub fn partition<'tcx, I>(tcx: &TyCtxt<'tcx>,\n+                          trans_items: I,\n+                          inlining_map: &InliningMap<'tcx>)\n+                          -> Vec<CodegenUnit<'tcx>>\n+    where I: Iterator<Item = TransItem<'tcx>>\n+{\n+    // In the first step, we place all regular translation items into their\n+    // respective 'home' codegen unit. Regular translation items are all\n+    // functions and statics defined in the local crate.\n+    let initial_partitioning = place_root_translation_items(tcx, trans_items);\n+\n+    // In the next step, we use the inlining map to determine which addtional\n+    // translation items have to go into each codegen unit. These additional\n+    // translation items can be drop-glue, functions from external crates, and\n+    // local functions the definition of which is marked with #[inline].\n+    place_inlined_translation_items(initial_partitioning, inlining_map)\n+}\n+\n+struct InitialPartitioning<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    roots: FnvHashSet<TransItem<'tcx>>,\n+}\n+\n+fn place_root_translation_items<'tcx, I>(tcx: &TyCtxt<'tcx>,\n+                                         trans_items: I)\n+                                         -> InitialPartitioning<'tcx>\n+    where I: Iterator<Item = TransItem<'tcx>>\n+{\n+    let mut roots = FnvHashSet();\n+    let mut codegen_units = FnvHashMap();\n+\n+    for trans_item in trans_items {\n+        let is_root = match trans_item {\n+            TransItem::Static(..) => true,\n+            TransItem::DropGlue(..) => false,\n+            TransItem::Fn(_) => !trans_item.is_from_extern_crate(),\n+        };\n+\n+        if is_root {\n+            let characteristic_def_id = characteristic_def_id_of_trans_item(tcx, trans_item);\n+            let is_volatile = trans_item.is_lazily_instantiated();\n+\n+            let codegen_unit_name = match characteristic_def_id {\n+                Some(def_id) => compute_codegen_unit_name(tcx, def_id, is_volatile),\n+                None => InternedString::new(FALLBACK_CODEGEN_UNIT),\n+            };\n+\n+            let make_codegen_unit = || {\n+                CodegenUnit {\n+                    name: codegen_unit_name.clone(),\n+                    items: FnvHashMap(),\n+                }\n+            };\n+\n+            let mut codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n+                                                .or_insert_with(make_codegen_unit);\n+\n+            let linkage = match trans_item.explicit_linkage(tcx) {\n+                Some(explicit_linkage) => explicit_linkage,\n+                None => {\n+                    match trans_item {\n+                        TransItem::Static(..) => llvm::ExternalLinkage,\n+                        TransItem::DropGlue(..) => unreachable!(),\n+                        // Is there any benefit to using ExternalLinkage?:\n+                        TransItem::Fn(..) => llvm::WeakODRLinkage,\n+                    }\n+                }\n+            };\n+\n+            codegen_unit.items.insert(trans_item, linkage);\n+            roots.insert(trans_item);\n+        }\n+    }\n+\n+    InitialPartitioning {\n+        codegen_units: codegen_units.into_iter()\n+                                    .map(|(_, codegen_unit)| codegen_unit)\n+                                    .collect(),\n+        roots: roots,\n+    }\n+}\n+\n+fn place_inlined_translation_items<'tcx>(initial_partitioning: InitialPartitioning<'tcx>,\n+                                         inlining_map: &InliningMap<'tcx>)\n+                                         -> Vec<CodegenUnit<'tcx>> {\n+    let mut final_partitioning = Vec::new();\n+\n+    for codegen_unit in &initial_partitioning.codegen_units[..] {\n+        // Collect all items that need to be available in this codegen unit\n+        let mut reachable = FnvHashSet();\n+        for root in codegen_unit.items.keys() {\n+            follow_inlining(*root, inlining_map, &mut reachable);\n+        }\n+\n+        let mut final_codegen_unit = CodegenUnit {\n+            name: codegen_unit.name.clone(),\n+            items: FnvHashMap(),\n+        };\n+\n+        // Add all translation items that are not already there\n+        for trans_item in reachable {\n+            if let Some(linkage) = codegen_unit.items.get(&trans_item) {\n+                // This is a root, just copy it over\n+                final_codegen_unit.items.insert(trans_item, *linkage);\n+            } else {\n+                if initial_partitioning.roots.contains(&trans_item) {\n+                    // This item will be instantiated in some other codegen unit,\n+                    // so we just add it here with AvailableExternallyLinkage\n+                    final_codegen_unit.items.insert(trans_item, llvm::AvailableExternallyLinkage);\n+                } else {\n+                    // We can't be sure if this will also be instantiated\n+                    // somewhere else, so we add an instance here with\n+                    // LinkOnceODRLinkage. That way the item can be discarded if\n+                    // it's not needed (inlined) after all.\n+                    final_codegen_unit.items.insert(trans_item, llvm::LinkOnceODRLinkage);\n+                }\n+            }\n+        }\n+\n+        final_partitioning.push(final_codegen_unit);\n+    }\n+\n+    return final_partitioning;\n+\n+    fn follow_inlining<'tcx>(trans_item: TransItem<'tcx>,\n+                             inlining_map: &InliningMap<'tcx>,\n+                             visited: &mut FnvHashSet<TransItem<'tcx>>) {\n+        if !visited.insert(trans_item) {\n+            return;\n+        }\n+\n+        if let Some(inlined_items) = inlining_map.get(&trans_item) {\n+            for &inlined_item in inlined_items {\n+                follow_inlining(inlined_item, inlining_map, visited);\n+            }\n+        }\n+    }\n+}\n+\n+fn characteristic_def_id_of_trans_item<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                             trans_item: TransItem<'tcx>)\n+                                             -> Option<DefId> {\n+    match trans_item {\n+        TransItem::Fn(instance) => {\n+            // If this is a method, we want to put it into the same module as\n+            // its self-type. If the self-type does not provide a characteristic\n+            // DefId, we use the location of the impl after all.\n+\n+            if let Some(self_ty) = instance.substs.self_ty() {\n+                // This is an implementation of a trait method.\n+                return characteristic_def_id_of_type(self_ty).or(Some(instance.def));\n+            }\n+\n+            if let Some(impl_def_id) = tcx.impl_of_method(instance.def) {\n+                // This is a method within an inherent impl, find out what the\n+                // self-type is:\n+                let impl_self_ty = tcx.lookup_item_type(impl_def_id).ty;\n+                let impl_self_ty = tcx.erase_regions(&impl_self_ty);\n+                let impl_self_ty = monomorphize::apply_param_substs(tcx,\n+                                                                    instance.substs,\n+                                                                    &impl_self_ty);\n+\n+                if let Some(def_id) = characteristic_def_id_of_type(impl_self_ty) {\n+                    return Some(def_id);\n+                }\n+            }\n+\n+            Some(instance.def)\n+        }\n+        TransItem::DropGlue(t) => characteristic_def_id_of_type(t),\n+        TransItem::Static(node_id) => Some(tcx.map.local_def_id(node_id)),\n+    }\n+}\n+\n+fn compute_codegen_unit_name<'tcx>(tcx: &TyCtxt<'tcx>,\n+                                   def_id: DefId,\n+                                   volatile: bool)\n+                                   -> InternedString {\n+    // Unfortunately we cannot just use the `ty::item_path` infrastructure here\n+    // because we need paths to modules and the DefIds of those are not\n+    // available anymore for external items.\n+    let mut mod_path = String::with_capacity(64);\n+\n+    let def_path = tcx.def_path(def_id);\n+    mod_path.push_str(&tcx.crate_name(def_path.krate));\n+\n+    for part in tcx.def_path(def_id)\n+                   .data\n+                   .iter()\n+                   .take_while(|part| {\n+                        match part.data {\n+                            DefPathData::Module(..) => true,\n+                            _ => false,\n+                        }\n+                    }) {\n+        mod_path.push_str(\"-\");\n+        mod_path.push_str(&part.data.as_interned_str());\n+    }\n+\n+    if volatile {\n+        mod_path.push_str(\".volatile\");\n+    }\n+\n+    return token::intern_and_get_ident(&mod_path[..]);\n+}\n+\n+impl<'tcx> CodegenUnit<'tcx> {\n+    pub fn _dump<'a>(&self, ccx: &CrateContext<'a, 'tcx>) {\n+        println!(\"CodegenUnit {} (\", self.name);\n+\n+        let mut items: Vec<_> = self.items\n+                                    .iter()\n+                                    .map(|(trans_item, inst)| {\n+                                        format!(\"{} -- ({:?})\", trans_item.to_string(ccx), inst)\n+                                    })\n+                                    .collect();\n+\n+        items.as_mut_slice().sort();\n+\n+        for s in items {\n+            println!(\"  {}\", s);\n+        }\n+\n+        println!(\")\");\n+    }\n+}"}, {"sha": "e4ba9fae41246cb0e19b79c591a28d03825abb0b", "filename": "src/test/auxiliary/cgu_explicit_inlining.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fauxiliary%2Fcgu_explicit_inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fauxiliary%2Fcgu_explicit_inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcgu_explicit_inlining.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+#[inline]\n+pub fn inlined() {}\n+\n+#[inline(always)]\n+pub fn always_inlined() {}\n+\n+#[inline(never)]\n+pub fn never_inlined() {}"}, {"sha": "049bdb46579eea767ae139473ee7372c469bff00", "filename": "src/test/auxiliary/cgu_extern_drop_glue.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fauxiliary%2Fcgu_extern_drop_glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fauxiliary%2Fcgu_extern_drop_glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcgu_extern_drop_glue.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+\n+pub struct Struct(pub u32);\n+\n+impl Drop for Struct {\n+    fn drop(&mut self) {}\n+}"}, {"sha": "04c68748eca0e2029f0fcdeb7cf57ba33acefbe1", "filename": "src/test/auxiliary/cgu_generic_function.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fauxiliary%2Fcgu_generic_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fauxiliary%2Fcgu_generic_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcgu_generic_function.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -12,12 +12,13 @@\n \n struct Struct(u32);\n \n+#[inline(never)]\n pub fn foo<T>(x: T) -> (T, u32, i8) {\n     let (x, Struct(y)) = bar(x);\n     (x, y, 2)\n }\n \n-\n+#[inline(never)]\n fn bar<T>(x: T) -> (T, Struct) {\n     let _ = not_exported_and_not_generic(0);\n     (x, Struct(1))"}, {"sha": "ddf5f461aef0943bf20c7ccb452f0041fa0311cf", "filename": "src/test/codegen-units/partitioning/extern-drop-glue.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-drop-glue.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+// aux-build:cgu_extern_drop_glue.rs\n+extern crate cgu_extern_drop_glue;\n+\n+//~ TRANS_ITEM drop-glue cgu_extern_drop_glue::Struct[0] @@ extern_drop_glue[OnceODR] extern_drop_glue-mod1[OnceODR]\n+\n+struct LocalStruct(cgu_extern_drop_glue::Struct);\n+\n+//~ TRANS_ITEM fn extern_drop_glue::user[0] @@ extern_drop_glue[WeakODR]\n+fn user()\n+{\n+    //~ TRANS_ITEM drop-glue extern_drop_glue::LocalStruct[0] @@ extern_drop_glue[OnceODR]\n+    let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n+}\n+\n+mod mod1 {\n+    use cgu_extern_drop_glue;\n+\n+    struct LocalStruct(cgu_extern_drop_glue::Struct);\n+\n+    //~ TRANS_ITEM fn extern_drop_glue::mod1[0]::user[0] @@ extern_drop_glue-mod1[WeakODR]\n+    fn user()\n+    {\n+        //~ TRANS_ITEM drop-glue extern_drop_glue::mod1[0]::LocalStruct[0] @@ extern_drop_glue-mod1[OnceODR]\n+        let _ = LocalStruct(cgu_extern_drop_glue::Struct(0));\n+    }\n+}\n+"}, {"sha": "71af676b0a9707a34ba88d70faf1646ff6c69cc4", "filename": "src/test/codegen-units/partitioning/extern-generic.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fextern-generic.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+// aux-build:cgu_generic_function.rs\n+extern crate cgu_generic_function;\n+\n+//~ TRANS_ITEM fn extern_generic::user[0] @@ extern_generic[WeakODR]\n+fn user() {\n+    let _ = cgu_generic_function::foo(\"abc\");\n+}\n+\n+mod mod1 {\n+    use cgu_generic_function;\n+\n+    //~ TRANS_ITEM fn extern_generic::mod1[0]::user[0] @@ extern_generic-mod1[WeakODR]\n+    fn user() {\n+        let _ = cgu_generic_function::foo(\"abc\");\n+    }\n+\n+    mod mod1 {\n+        use cgu_generic_function;\n+\n+        //~ TRANS_ITEM fn extern_generic::mod1[0]::mod1[0]::user[0] @@ extern_generic-mod1-mod1[WeakODR]\n+        fn user() {\n+            let _ = cgu_generic_function::foo(\"abc\");\n+        }\n+    }\n+}\n+\n+mod mod2 {\n+    use cgu_generic_function;\n+\n+    //~ TRANS_ITEM fn extern_generic::mod2[0]::user[0] @@ extern_generic-mod2[WeakODR]\n+    fn user() {\n+        let _ = cgu_generic_function::foo(\"abc\");\n+    }\n+}\n+\n+mod mod3 {\n+    //~ TRANS_ITEM fn extern_generic::mod3[0]::non_user[0] @@ extern_generic-mod3[WeakODR]\n+    fn non_user() {}\n+}\n+\n+// Make sure the two generic functions from the extern crate get instantiated\n+// privately in every module they are use in.\n+//~ TRANS_ITEM fn cgu_generic_function::foo[0]<&str> @@ extern_generic[OnceODR] extern_generic-mod1[OnceODR] extern_generic-mod2[OnceODR] extern_generic-mod1-mod1[OnceODR]\n+//~ TRANS_ITEM fn cgu_generic_function::bar[0]<&str> @@ extern_generic[OnceODR] extern_generic-mod1[OnceODR] extern_generic-mod2[OnceODR] extern_generic-mod1-mod1[OnceODR]\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "f4732a7bcf8fb5634b92a2a02d6d27cf97a17420", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![crate_type=\"lib\"]\n+\n+// aux-build:cgu_explicit_inlining.rs\n+extern crate cgu_explicit_inlining;\n+\n+// This test makes sure that items inlined from external crates are privately\n+// instantiated in every codegen unit they are used in.\n+\n+//~ TRANS_ITEM fn cgu_explicit_inlining::inlined[0] @@ inlining_from_extern_crate[OnceODR] inlining_from_extern_crate-mod1[OnceODR]\n+//~ TRANS_ITEM fn cgu_explicit_inlining::always_inlined[0] @@ inlining_from_extern_crate[OnceODR] inlining_from_extern_crate-mod2[OnceODR]\n+\n+//~ TRANS_ITEM fn inlining_from_extern_crate::user[0] @@ inlining_from_extern_crate[WeakODR]\n+pub fn user()\n+{\n+    cgu_explicit_inlining::inlined();\n+    cgu_explicit_inlining::always_inlined();\n+\n+    // does not generate a translation item in this crate\n+    cgu_explicit_inlining::never_inlined();\n+}\n+\n+mod mod1 {\n+    use cgu_explicit_inlining;\n+\n+    //~ TRANS_ITEM fn inlining_from_extern_crate::mod1[0]::user[0] @@ inlining_from_extern_crate-mod1[WeakODR]\n+    pub fn user()\n+    {\n+        cgu_explicit_inlining::inlined();\n+\n+        // does not generate a translation item in this crate\n+        cgu_explicit_inlining::never_inlined();\n+    }\n+}\n+\n+mod mod2 {\n+    use cgu_explicit_inlining;\n+\n+    //~ TRANS_ITEM fn inlining_from_extern_crate::mod2[0]::user[0] @@ inlining_from_extern_crate-mod2[WeakODR]\n+    pub fn user()\n+    {\n+        cgu_explicit_inlining::always_inlined();\n+\n+        // does not generate a translation item in this crate\n+        cgu_explicit_inlining::never_inlined();\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "0c500bb64f8db928878bc99e48d3005438aa4a69", "filename": "src/test/codegen-units/partitioning/local-drop-glue.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-drop-glue.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+//~ TRANS_ITEM drop-glue local_drop_glue::Struct[0] @@ local_drop_glue[OnceODR] local_drop_glue-mod1[OnceODR]\n+struct Struct {\n+    _a: u32\n+}\n+\n+impl Drop for Struct {\n+    //~ TRANS_ITEM fn local_drop_glue::{{impl}}[0]::drop[0] @@ local_drop_glue[WeakODR]\n+    fn drop(&mut self) {}\n+}\n+\n+//~ TRANS_ITEM drop-glue local_drop_glue::Outer[0] @@ local_drop_glue[OnceODR]\n+struct Outer {\n+    _a: Struct\n+}\n+\n+//~ TRANS_ITEM fn local_drop_glue::user[0] @@ local_drop_glue[WeakODR]\n+fn user()\n+{\n+    let _ = Outer {\n+        _a: Struct {\n+            _a: 0\n+        }\n+    };\n+}\n+\n+mod mod1\n+{\n+    use super::Struct;\n+\n+    //~ TRANS_ITEM drop-glue local_drop_glue::mod1[0]::Struct2[0] @@ local_drop_glue-mod1[OnceODR]\n+    struct Struct2 {\n+        _a: Struct,\n+        //~ TRANS_ITEM drop-glue (u32, local_drop_glue::Struct[0]) @@ local_drop_glue-mod1[OnceODR]\n+        _b: (u32, Struct),\n+    }\n+\n+    //~ TRANS_ITEM fn local_drop_glue::mod1[0]::user[0] @@ local_drop_glue-mod1[WeakODR]\n+    fn user()\n+    {\n+        let _ = Struct2 {\n+            _a: Struct { _a: 0 },\n+            _b: (0, Struct { _a: 0 }),\n+        };\n+    }\n+}"}, {"sha": "08c8ff0cb2f9186ddba4defb2657a3ab37e19f28", "filename": "src/test/codegen-units/partitioning/local-generic.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-generic.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+// Used in different modules/codegen units but always instantiated in the same\n+// codegen unit.\n+\n+//~ TRANS_ITEM fn local_generic::generic[0]<u32> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<u64> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<char> @@ local_generic.volatile[WeakODR]\n+//~ TRANS_ITEM fn local_generic::generic[0]<&str> @@ local_generic.volatile[WeakODR]\n+pub fn generic<T>(x: T) -> T { x }\n+\n+//~ TRANS_ITEM fn local_generic::user[0] @@ local_generic[WeakODR]\n+fn user() {\n+    let _ = generic(0u32);\n+}\n+\n+mod mod1 {\n+    pub use super::generic;\n+\n+    //~ TRANS_ITEM fn local_generic::mod1[0]::user[0] @@ local_generic-mod1[WeakODR]\n+    fn user() {\n+        let _ = generic(0u64);\n+    }\n+\n+    mod mod1 {\n+        use super::generic;\n+\n+        //~ TRANS_ITEM fn local_generic::mod1[0]::mod1[0]::user[0] @@ local_generic-mod1-mod1[WeakODR]\n+        fn user() {\n+            let _ = generic('c');\n+        }\n+    }\n+}\n+\n+mod mod2 {\n+    use super::generic;\n+\n+    //~ TRANS_ITEM fn local_generic::mod2[0]::user[0] @@ local_generic-mod2[WeakODR]\n+    fn user() {\n+        let _ = generic(\"abc\");\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "dfd8f725b61dddab55efdd878cca6cfc1879d7e0", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+mod inline {\n+\n+    // Important: This function should show up in all codegen units where it is inlined\n+    //~ TRANS_ITEM fn local_inlining::inline[0]::inlined_function[0] @@ local_inlining-inline[WeakODR] local_inlining-user1[Available] local_inlining-user2[Available]\n+    #[inline(always)]\n+    pub fn inlined_function()\n+    {\n+\n+    }\n+}\n+\n+mod user1 {\n+    use super::inline;\n+\n+    //~ TRANS_ITEM fn local_inlining::user1[0]::foo[0] @@ local_inlining-user1[WeakODR]\n+    fn foo() {\n+        inline::inlined_function();\n+    }\n+}\n+\n+mod user2 {\n+    use super::inline;\n+\n+    //~ TRANS_ITEM fn local_inlining::user2[0]::bar[0] @@ local_inlining-user2[WeakODR]\n+    fn bar() {\n+        inline::inlined_function();\n+    }\n+}\n+\n+mod non_user {\n+\n+    //~ TRANS_ITEM fn local_inlining::non_user[0]::baz[0] @@ local_inlining-non_user[WeakODR]\n+    fn baz() {\n+\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "ea3a1cd34be32bf42a455a3a03aa3a3a66e97b62", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+mod inline {\n+\n+    //~ TRANS_ITEM fn local_transitive_inlining::inline[0]::inlined_function[0] @@ local_transitive_inlining-inline[WeakODR] local_transitive_inlining-direct_user[Available] local_transitive_inlining-indirect_user[Available]\n+    #[inline(always)]\n+    pub fn inlined_function()\n+    {\n+\n+    }\n+}\n+\n+mod direct_user {\n+    use super::inline;\n+\n+    //~ TRANS_ITEM fn local_transitive_inlining::direct_user[0]::foo[0] @@ local_transitive_inlining-direct_user[WeakODR] local_transitive_inlining-indirect_user[Available]\n+    #[inline(always)]\n+    pub fn foo() {\n+        inline::inlined_function();\n+    }\n+}\n+\n+mod indirect_user {\n+    use super::direct_user;\n+\n+    //~ TRANS_ITEM fn local_transitive_inlining::indirect_user[0]::bar[0] @@ local_transitive_inlining-indirect_user[WeakODR]\n+    fn bar() {\n+        direct_user::foo();\n+    }\n+}\n+\n+mod non_user {\n+\n+    //~ TRANS_ITEM fn local_transitive_inlining::non_user[0]::baz[0] @@ local_transitive_inlining-non_user[WeakODR]\n+    fn baz() {\n+\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "51d2d53f24a80eff72e68c16cb35ac81896159aa", "filename": "src/test/codegen-units/partitioning/methods-are-with-self-type.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fmethods-are-with-self-type.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![allow(dead_code)]\n+\n+struct SomeType;\n+\n+struct SomeGenericType<T1, T2>(T1, T2);\n+\n+mod mod1 {\n+    use super::{SomeType, SomeGenericType};\n+\n+    // Even though the impl is in `mod1`, the methods should end up in the\n+    // parent module, since that is where their self-type is.\n+    impl SomeType {\n+        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::method[0] @@ methods_are_with_self_type[WeakODR]\n+        fn method(&self) {}\n+\n+        //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[0]::associated_fn[0] @@ methods_are_with_self_type[WeakODR]\n+        fn associated_fn() {}\n+    }\n+\n+    impl<T1, T2> SomeGenericType<T1, T2> {\n+        pub fn method(&self) {}\n+        pub fn associated_fn(_: T1, _: T2) {}\n+    }\n+}\n+\n+trait Trait {\n+    fn foo(&self);\n+    fn default(&self) {}\n+}\n+\n+// We provide an implementation of `Trait` for all types. The corresponding\n+// monomorphizations should end up in whichever module the concrete `T` is.\n+impl<T> Trait for T\n+{\n+    fn foo(&self) {}\n+}\n+\n+mod type1 {\n+    pub struct Struct;\n+}\n+\n+mod type2 {\n+    pub struct Struct;\n+}\n+\n+//~ TRANS_ITEM fn methods_are_with_self_type::main[0]\n+fn main()\n+{\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::method[0]<u32, u64> @@ methods_are_with_self_type.volatile[WeakODR]\n+    SomeGenericType(0u32, 0u64).method();\n+    //~ TRANS_ITEM fn methods_are_with_self_type::mod1[0]::{{impl}}[1]::associated_fn[0]<char, &str> @@ methods_are_with_self_type.volatile[WeakODR]\n+    SomeGenericType::associated_fn('c', \"&str\");\n+\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    type1::Struct.foo();\n+    //~ TRANS_ITEM fn methods_are_with_self_type::{{impl}}[0]::foo[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    type2::Struct.foo();\n+\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type1[0]::Struct[0]> @@ methods_are_with_self_type-type1.volatile[WeakODR]\n+    type1::Struct.default();\n+    //~ TRANS_ITEM fn methods_are_with_self_type::Trait[0]::default[0]<methods_are_with_self_type::type2[0]::Struct[0]> @@ methods_are_with_self_type-type2.volatile[WeakODR]\n+    type2::Struct.default();\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "a761cab2e44e48581d4de7fc078475471b9ecac3", "filename": "src/test/codegen-units/partitioning/regular-modules.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fregular-modules.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,82 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=eager\n+\n+#![allow(dead_code)]\n+#![crate_type=\"lib\"]\n+\n+//~ TRANS_ITEM fn regular_modules::foo[0] @@ regular_modules[WeakODR]\n+fn foo() {}\n+\n+//~ TRANS_ITEM fn regular_modules::bar[0] @@ regular_modules[WeakODR]\n+fn bar() {}\n+\n+//~ TRANS_ITEM static regular_modules::BAZ[0] @@ regular_modules[External]\n+static BAZ: u64 = 0;\n+\n+mod mod1 {\n+\n+    //~ TRANS_ITEM fn regular_modules::mod1[0]::foo[0] @@ regular_modules-mod1[WeakODR]\n+    fn foo() {}\n+    //~ TRANS_ITEM fn regular_modules::mod1[0]::bar[0] @@ regular_modules-mod1[WeakODR]\n+    fn bar() {}\n+    //~ TRANS_ITEM static regular_modules::mod1[0]::BAZ[0] @@ regular_modules-mod1[External]\n+    static BAZ: u64 = 0;\n+\n+    mod mod1 {\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::foo[0] @@ regular_modules-mod1-mod1[WeakODR]\n+        fn foo() {}\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod1[0]::bar[0] @@ regular_modules-mod1-mod1[WeakODR]\n+        fn bar() {}\n+        //~ TRANS_ITEM static regular_modules::mod1[0]::mod1[0]::BAZ[0] @@ regular_modules-mod1-mod1[External]\n+        static BAZ: u64 = 0;\n+    }\n+\n+    mod mod2 {\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::foo[0] @@ regular_modules-mod1-mod2[WeakODR]\n+        fn foo() {}\n+        //~ TRANS_ITEM fn regular_modules::mod1[0]::mod2[0]::bar[0] @@ regular_modules-mod1-mod2[WeakODR]\n+        fn bar() {}\n+        //~ TRANS_ITEM static regular_modules::mod1[0]::mod2[0]::BAZ[0] @@ regular_modules-mod1-mod2[External]\n+        static BAZ: u64 = 0;\n+    }\n+}\n+\n+mod mod2 {\n+\n+    //~ TRANS_ITEM fn regular_modules::mod2[0]::foo[0] @@ regular_modules-mod2[WeakODR]\n+    fn foo() {}\n+    //~ TRANS_ITEM fn regular_modules::mod2[0]::bar[0] @@ regular_modules-mod2[WeakODR]\n+    fn bar() {}\n+    //~ TRANS_ITEM static regular_modules::mod2[0]::BAZ[0] @@ regular_modules-mod2[External]\n+    static BAZ: u64 = 0;\n+\n+    mod mod1 {\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::foo[0] @@ regular_modules-mod2-mod1[WeakODR]\n+        fn foo() {}\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod1[0]::bar[0] @@ regular_modules-mod2-mod1[WeakODR]\n+        fn bar() {}\n+        //~ TRANS_ITEM static regular_modules::mod2[0]::mod1[0]::BAZ[0] @@ regular_modules-mod2-mod1[External]\n+        static BAZ: u64 = 0;\n+    }\n+\n+    mod mod2 {\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::foo[0] @@ regular_modules-mod2-mod2[WeakODR]\n+        fn foo() {}\n+        //~ TRANS_ITEM fn regular_modules::mod2[0]::mod2[0]::bar[0] @@ regular_modules-mod2-mod2[WeakODR]\n+        fn bar() {}\n+        //~ TRANS_ITEM static regular_modules::mod2[0]::mod2[0]::BAZ[0] @@ regular_modules-mod2-mod2[External]\n+        static BAZ: u64 = 0;\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}, {"sha": "ac6a0c55d4f6db3e2ab24fe75f3c0486f245cba2", "filename": "src/test/codegen-units/partitioning/statics.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8441b6784bffde062443590f1be7d6187ec9934/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Fstatics.rs?ref=e8441b6784bffde062443590f1be7d6187ec9934", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags:-Zprint-trans-items=lazy\n+\n+#![crate_type=\"lib\"]\n+\n+//~ TRANS_ITEM static statics::FOO[0] @@ statics[External]\n+static FOO: u32 = 0;\n+\n+//~ TRANS_ITEM static statics::BAR[0] @@ statics[External]\n+static BAR: u32 = 0;\n+\n+//~ TRANS_ITEM fn statics::function[0] @@ statics[WeakODR]\n+fn function() {\n+    //~ TRANS_ITEM static statics::function[0]::FOO[0] @@ statics[External]\n+    static FOO: u32 = 0;\n+\n+    //~ TRANS_ITEM static statics::function[0]::BAR[0] @@ statics[External]\n+    static BAR: u32 = 0;\n+}\n+\n+mod mod1 {\n+    //~ TRANS_ITEM static statics::mod1[0]::FOO[0] @@ statics-mod1[External]\n+    static FOO: u32 = 0;\n+\n+    //~ TRANS_ITEM static statics::mod1[0]::BAR[0] @@ statics-mod1[External]\n+    static BAR: u32 = 0;\n+\n+    //~ TRANS_ITEM fn statics::mod1[0]::function[0] @@ statics-mod1[WeakODR]\n+    fn function() {\n+        //~ TRANS_ITEM static statics::mod1[0]::function[0]::FOO[0] @@ statics-mod1[External]\n+        static FOO: u32 = 0;\n+\n+        //~ TRANS_ITEM static statics::mod1[0]::function[0]::BAR[0] @@ statics-mod1[External]\n+        static BAR: u32 = 0;\n+    }\n+}\n+\n+//~ TRANS_ITEM drop-glue i8"}]}