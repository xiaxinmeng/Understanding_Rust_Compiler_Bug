{"sha": "c76a024121d8d92af8c5c44651bc72a177565281", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3NmEwMjQxMjFkOGQ5MmFmOGM1YzQ0NjUxYmM3MmExNzc1NjUyODE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-26T22:27:58Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-08-28T06:27:58Z"}, "message": "rustc: treat impl associated consts like const items for constness.", "tree": {"sha": "1263d0c6296cc7eab84cbd8a67f487733d84cf78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1263d0c6296cc7eab84cbd8a67f487733d84cf78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c76a024121d8d92af8c5c44651bc72a177565281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c76a024121d8d92af8c5c44651bc72a177565281", "html_url": "https://github.com/rust-lang/rust/commit/c76a024121d8d92af8c5c44651bc72a177565281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c76a024121d8d92af8c5c44651bc72a177565281/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b61771ea80b476eb92bda6388fcf6f0f88e8567", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b61771ea80b476eb92bda6388fcf6f0f88e8567", "html_url": "https://github.com/rust-lang/rust/commit/9b61771ea80b476eb92bda6388fcf6f0f88e8567"}], "stats": {"total": 66, "additions": 44, "deletions": 22}, "files": [{"sha": "da59ebb9b9cd2051aba6fa12751f4cb1a21a8567", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c76a024121d8d92af8c5c44651bc72a177565281/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76a024121d8d92af8c5c44651bc72a177565281/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c76a024121d8d92af8c5c44651bc72a177565281", "patch": "@@ -591,15 +591,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Operand::Constant(ref constant) => {\n-                if let Literal::Item { def_id, substs } = constant.literal {\n-                    // Don't peek inside generic (associated) constants.\n-                    if substs.types().next().is_some() {\n+                if let Literal::Item { def_id, substs: _ } = constant.literal {\n+                    // Don't peek inside trait associated constants.\n+                    if self.tcx.trait_of_item(def_id).is_some() {\n                         self.add_type(constant.ty);\n                     } else {\n                         let bits = self.tcx.at(constant.span).mir_const_qualif(def_id);\n \n                         let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n                         self.add(qualif);\n+\n+                        // Just in case the type is more specific than\n+                        // the definition, e.g. impl associated const\n+                        // with type parameters, take it into account.\n+                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n                     }\n \n                     // Let `const fn` transitively have destructors,"}, {"sha": "8ba8d4fce0dbfe556a13d46fa4693cc742ca3c74", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c76a024121d8d92af8c5c44651bc72a177565281/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76a024121d8d92af8c5c44651bc72a177565281/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=c76a024121d8d92af8c5c44651bc72a177565281", "patch": "@@ -87,19 +87,14 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         }\n     }\n \n-    // Adds the worst effect out of all the values of one type.\n-    fn add_type(&mut self, ty: Ty<'gcx>) {\n-        if !ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) {\n-            self.promotable = false;\n-        }\n-\n-        if ty.needs_drop(self.tcx, self.param_env) {\n-            self.promotable = false;\n-        }\n+    // Returns true iff all the values of the type are promotable.\n+    fn type_has_only_promotable_values(&mut self, ty: Ty<'gcx>) -> bool {\n+        ty.is_freeze(self.tcx, self.param_env, DUMMY_SP) &&\n+        !ty.needs_drop(self.tcx, self.param_env)\n     }\n \n     fn handle_const_fn_call(&mut self, def_id: DefId, ret_ty: Ty<'gcx>) {\n-        self.add_type(ret_ty);\n+        self.promotable &= self.type_has_only_promotable_values(ret_ty);\n \n         self.promotable &= if let Some(fn_id) = self.tcx.hir.as_local_node_id(def_id) {\n             FnLikeNode::from_node(self.tcx.hir.get(fn_id)).map_or(false, |fn_like| {\n@@ -333,20 +328,30 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n-                Def::AssociatedConst(_) => v.add_type(node_ty),\n-                Def::Const(did) => {\n-                    v.promotable &= if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n-                        match v.tcx.hir.expect_item(node_id).node {\n-                            hir::ItemConst(_, body) => {\n+\n+                Def::Const(did) |\n+                Def::AssociatedConst(did) => {\n+                    let promotable = if v.tcx.trait_of_item(did).is_some() {\n+                        // Don't peek inside trait associated constants.\n+                        false\n+                    } else if let Some(node_id) = v.tcx.hir.as_local_node_id(did) {\n+                        match v.tcx.hir.maybe_body_owned_by(node_id) {\n+                            Some(body) => {\n                                 v.visit_nested_body(body);\n                                 v.tcx.rvalue_promotable_to_static.borrow()[&body.node_id]\n                             }\n-                            _ => false\n+                            None => false\n                         }\n                     } else {\n                         v.tcx.const_is_rvalue_promotable_to_static(did)\n                     };\n+\n+                    // Just in case the type is more specific than the definition,\n+                    // e.g. impl associated const with type parameters, check it.\n+                    // Also, trait associated consts are relaxed by this.\n+                    v.promotable &= promotable || v.type_has_only_promotable_values(node_ty);\n                 }\n+\n                 _ => {\n                     v.promotable = false;\n                 }"}, {"sha": "acf96b566df840165a7023244ae8f9c21dd17d29", "filename": "src/test/run-pass/rvalue-static-promotion.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c76a024121d8d92af8c5c44651bc72a177565281/src%2Ftest%2Frun-pass%2Frvalue-static-promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c76a024121d8d92af8c5c44651bc72a177565281/src%2Ftest%2Frun-pass%2Frvalue-static-promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frvalue-static-promotion.rs?ref=c76a024121d8d92af8c5c44651bc72a177565281", "patch": "@@ -8,8 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[allow(unused_variables)]\n+use std::cell::Cell;\n+\n+const NONE_CELL_STRING: Option<Cell<String>> = None;\n+\n+struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    const FOO: Option<Box<T>> = None;\n+}\n+\n fn main() {\n-    let x: &'static u32 = &42;\n-    let y: &'static Option<u32> = &None;\n+    let _: &'static u32 = &42;\n+    let _: &'static Option<u32> = &None;\n+\n+    // We should be able to peek at consts and see they're None.\n+    let _: &'static Option<Cell<String>> = &NONE_CELL_STRING;\n+    let _: &'static Option<Box<()>> = &Foo::FOO;\n }"}]}