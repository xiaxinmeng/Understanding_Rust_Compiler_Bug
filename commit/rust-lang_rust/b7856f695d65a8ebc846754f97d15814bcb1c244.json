{"sha": "b7856f695d65a8ebc846754f97d15814bcb1c244", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ODU2ZjY5NWQ2NWE4ZWJjODQ2NzU0Zjk3ZDE1ODE0YmNiMWMyNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-02T08:35:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-02T08:35:53Z"}, "message": "Auto merge of #73950 - Manishearth:rollup-0dtxnit, r=Manishearth\n\nRollup of 16 pull requests\n\nSuccessful merges:\n\n - #72569 (Remove legacy InnoSetup GUI installer)\n - #73306 (Don't implement Fn* traits for #[target_feature] functions)\n - #73345 (expand: Stop using nonterminals for passing tokens to attribute and derive macros)\n - #73449 (Provide more information on duplicate lang item error.)\n - #73569 (Handle `macro_rules!` tokens consistently across crates)\n - #73803 (Recover extra trailing angle brackets in struct definition)\n - #73839 (Split and expand nonstandard-style lints unicode unit test.)\n - #73841 (Remove defunct `-Z print-region-graph`)\n - #73848 (Fix markdown rendering in librustc_lexer docs)\n - #73865 (Fix Zulip topic format)\n - #73892 (Clean up E0712 explanation)\n - #73898 (remove duplicate test for #61935)\n - #73906 (Add missing backtick in `ty_error_with_message`)\n - #73909 (`#[deny(unsafe_op_in_unsafe_fn)]` in libstd/fs.rs)\n - #73910 (Rewrite a few manual index loops with while-let)\n - #73929 (Fix comment typo)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "a30df4257643452b93662f454a9efa4b20e182b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a30df4257643452b93662f454a9efa4b20e182b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7856f695d65a8ebc846754f97d15814bcb1c244", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7856f695d65a8ebc846754f97d15814bcb1c244", "html_url": "https://github.com/rust-lang/rust/commit/b7856f695d65a8ebc846754f97d15814bcb1c244", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7856f695d65a8ebc846754f97d15814bcb1c244/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "html_url": "https://github.com/rust-lang/rust/commit/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c"}, {"sha": "d7be1e4e3353c9f2bc9d697341905e93f57253b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7be1e4e3353c9f2bc9d697341905e93f57253b1", "html_url": "https://github.com/rust-lang/rust/commit/d7be1e4e3353c9f2bc9d697341905e93f57253b1"}], "stats": {"total": 1725, "additions": 1012, "deletions": 713}, "files": [{"sha": "15c6d4011e19f9c30d1ea1dacb3146c302d511ba", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -90,9 +90,6 @@ jobs:\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n         if: success() && !env.SKIP_JOB\n@@ -193,9 +190,6 @@ jobs:\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n         if: success() && !env.SKIP_JOB\n@@ -537,9 +531,6 @@ jobs:\n       - name: install WIX\n         run: src/ci/scripts/install-wix.sh\n         if: success() && !env.SKIP_JOB\n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        if: success() && !env.SKIP_JOB\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n         if: success() && !env.SKIP_JOB"}, {"sha": "f9403260f7752cc74746fab43d34f47f735c3154", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -973,7 +973,7 @@ impl<'a> Builder<'a> {\n         // we're gated on RUSTC_RPATH here.\n         //\n         // Ok, so the astute might be wondering \"why isn't `-C rpath` used\n-        // here?\" and that is indeed a good question to task. This codegen\n+        // here?\" and that is indeed a good question to ask. This codegen\n         // option is the compiler's current interface to generating an rpath.\n         // Unfortunately it doesn't quite suffice for us. The flag currently\n         // takes no value as an argument, so the compiler calculates what it"}, {"sha": "28430b56ee56fc1c11d4825299b77c8bc5993975", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1875,28 +1875,7 @@ impl Step for Extended {\n                 prepare(\"rust-mingw\");\n             }\n \n-            builder.install(&xform(&etc.join(\"exe/rust.iss\")), &exe, 0o644);\n-            builder.install(&etc.join(\"exe/modpath.iss\"), &exe, 0o644);\n-            builder.install(&etc.join(\"exe/upgrade.iss\"), &exe, 0o644);\n             builder.install(&etc.join(\"gfx/rust-logo.ico\"), &exe, 0o644);\n-            builder.create(&exe.join(\"LICENSE.txt\"), &license);\n-\n-            // Generate exe installer\n-            builder.info(\"building `exe` installer with `iscc`\");\n-            let mut cmd = Command::new(\"iscc\");\n-            cmd.arg(\"rust.iss\").arg(\"/Q\").current_dir(&exe);\n-            if target.contains(\"windows-gnu\") {\n-                cmd.arg(\"/dMINGW\");\n-            }\n-            add_env(builder, &mut cmd, target);\n-            let time = timeit(builder);\n-            builder.run(&mut cmd);\n-            drop(time);\n-            builder.install(\n-                &exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n-                &distdir(builder),\n-                0o755,\n-            );\n \n             // Generate msi installer\n             let wix = PathBuf::from(env::var_os(\"WIX\").unwrap());"}, {"sha": "34fc4d76fa207d7cc572ef02c24ffcda40001993", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -66,10 +66,6 @@ steps:\n   displayName: Install wix\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n \n-- bash: src/ci/scripts/install-innosetup.sh\n-  displayName: Install InnoSetup\n-  condition: and(succeeded(), not(variables.SKIP_JOB))\n-\n - bash: src/ci/scripts/symlink-build-dir.sh\n   displayName: Ensure the build happens on a partition with enough space\n   condition: and(succeeded(), not(variables.SKIP_JOB))"}, {"sha": "00170226e63c70c2d2e4334af06740a46a38c4be", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -131,10 +131,6 @@ x--expand-yaml-anchors--remove:\n         run: src/ci/scripts/install-wix.sh\n         <<: *step\n \n-      - name: install InnoSetup\n-        run: src/ci/scripts/install-innosetup.sh\n-        <<: *step\n-\n       - name: ensure the build happens on a partition with enough space\n         run: src/ci/scripts/symlink-build-dir.sh\n         <<: *step"}, {"sha": "04ca249777a11a55228c5dbb6a94c59254afab20", "filename": "src/ci/scripts/install-innosetup.sh", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fci%2Fscripts%2Finstall-innosetup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fci%2Fscripts%2Finstall-innosetup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Finstall-innosetup.sh?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,18 +0,0 @@\n-#!/bin/bash\n-# We use InnoSetup and its `iscc` program to also create combined installers.\n-# Honestly at this point WIX above and `iscc` are just holdovers from\n-# oh-so-long-ago and are required for creating installers on Windows. I think\n-# one is MSI installers and one is EXE, but they're not used so frequently at\n-# this point anyway so perhaps it's a wash!\n-\n-set -euo pipefail\n-IFS=$'\\n\\t'\n-\n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n-\n-if isWindows; then\n-    curl.exe -o is-install.exe \"${MIRRORS_BASE}/2017-08-22-is.exe\"\n-    cmd.exe //c \"is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\"\n-\n-    ciCommandAddPath \"C:\\\\Program Files (x86)\\\\Inno Setup 5\"\n-fi"}, {"sha": "2cfc8698c4b67f7e9c8c9cb569aaa54758645542", "filename": "src/etc/installer/exe/modpath.iss", "status": "removed", "additions": 0, "deletions": 219, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Fmodpath.iss?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,219 +0,0 @@\n-// ----------------------------------------------------------------------------\n-//\n-// Inno Setup Ver:\t5.4.2\n-// Script Version:\t1.4.1\n-// Author:\t\t\tJared Breland <jbreland@legroom.net>\n-// Homepage:\t\thttp://www.legroom.net/software\n-// License:\t\t\tGNU Lesser General Public License (LGPL), version 3\n-//\t\t\t\t\t\thttp://www.gnu.org/licenses/lgpl.html\n-//\n-// Script Function:\n-//\tAllow modification of environmental path directly from Inno Setup installers\n-//\n-// Instructions:\n-//\tCopy modpath.iss to the same directory as your setup script\n-//\n-//\tAdd this statement to your [Setup] section\n-//\t\tChangesEnvironment=true\n-//\n-//\tAdd this statement to your [Tasks] section\n-//\tYou can change the Description or Flags\n-//\tYou can change the Name, but it must match the ModPathName setting below\n-//\t\tName: modifypath; Description: &Add application directory to your environmental path; Flags: unchecked\n-//\n-//\tAdd the following to the end of your [Code] section\n-//\tModPathName defines the name of the task defined above\n-//\tModPathType defines whether the 'user' or 'system' path will be modified;\n-//\t\tthis will default to user if anything other than system is set\n-//\tsetArrayLength must specify the total number of dirs to be added\n-//\tResult[0] contains first directory, Result[1] contains second, etc.\n-//\t\tconst\n-//\t\t\tModPathName = 'modifypath';\n-//\t\t\tModPathType = 'user';\n-//\n-//\t\tfunction ModPathDir(): TArrayOfString;\n-//\t\tbegin\n-//\t\t\tsetArrayLength(Result, 1);\n-//\t\t\tResult[0] := ExpandConstant('{app}');\n-//\t\tend;\n-//\t\t#include \"modpath.iss\"\n-// ----------------------------------------------------------------------------\n-\n-procedure ModPath();\n-var\n-\toldpath:\tString;\n-\tnewpath:\tString;\n-\tupdatepath:\tBoolean;\n-\tpathArr:\tTArrayOfString;\n-\taExecFile:\tString;\n-\taExecArr:\tTArrayOfString;\n-\ti, d:\t\tInteger;\n-\tpathdir:\tTArrayOfString;\n-\tregroot:\tInteger;\n-\tregpath:\tString;\n-\n-begin\n-\t// Get constants from main script and adjust behavior accordingly\n-\t// ModPathType MUST be 'system' or 'user'; force 'user' if invalid\n-\tif ModPathType = 'system' then begin\n-\t\tregroot := HKEY_LOCAL_MACHINE;\n-\t\tregpath := 'SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment';\n-\tend else begin\n-\t\tregroot := HKEY_CURRENT_USER;\n-\t\tregpath := 'Environment';\n-\tend;\n-\n-\t// Get array of new directories and act on each individually\n-\tpathdir := ModPathDir();\n-\tfor d := 0 to GetArrayLength(pathdir)-1 do begin\n-\t\tupdatepath := true;\n-\n-\t\t// Modify WinNT path\n-\t\tif UsingWinNT() = true then begin\n-\n-\t\t\t// Get current path, split into an array\n-\t\t\tRegQueryStringValue(regroot, regpath, 'Path', oldpath);\n-\t\t\toldpath := oldpath + ';';\n-\t\t\ti := 0;\n-\n-\t\t\twhile (Pos(';', oldpath) > 0) do begin\n-\t\t\t\tSetArrayLength(pathArr, i+1);\n-\t\t\t\tpathArr[i] := Copy(oldpath, 0, Pos(';', oldpath)-1);\n-\t\t\t\toldpath := Copy(oldpath, Pos(';', oldpath)+1, Length(oldpath));\n-\t\t\t\ti := i + 1;\n-\n-\t\t\t\t// Check if current directory matches app dir\n-\t\t\t\tif pathdir[d] = pathArr[i-1] then begin\n-\t\t\t\t\t// if uninstalling, remove dir from path\n-\t\t\t\t\tif IsUninstaller() = true then begin\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t// if installing, flag that dir already exists in path\n-\t\t\t\t\tend else begin\n-\t\t\t\t\t\tupdatepath := false;\n-\t\t\t\t\tend;\n-\t\t\t\tend;\n-\n-\t\t\t\t// Add current directory to new path\n-\t\t\t\tif i = 1 then begin\n-\t\t\t\t\tnewpath := pathArr[i-1];\n-\t\t\t\tend else begin\n-\t\t\t\t\tnewpath := newpath + ';' + pathArr[i-1];\n-\t\t\t\tend;\n-\t\t\tend;\n-\n-\t\t\t// Append app dir to path if not already included\n-\t\t\tif (IsUninstaller() = false) AND (updatepath = true) then\n-\t\t\t\tnewpath := newpath + ';' + pathdir[d];\n-\n-\t\t\t// Write new path\n-\t\t\tRegWriteStringValue(regroot, regpath, 'Path', newpath);\n-\n-\t\t// Modify Win9x path\n-\t\tend else begin\n-\n-\t\t\t// Convert to shortened dirname\n-\t\t\tpathdir[d] := GetShortName(pathdir[d]);\n-\n-\t\t\t// If autoexec.bat exists, check if app dir already exists in path\n-\t\t\taExecFile := 'C:\\AUTOEXEC.BAT';\n-\t\t\tif FileExists(aExecFile) then begin\n-\t\t\t\tLoadStringsFromFile(aExecFile, aExecArr);\n-\t\t\t\tfor i := 0 to GetArrayLength(aExecArr)-1 do begin\n-\t\t\t\t\tif IsUninstaller() = false then begin\n-\t\t\t\t\t\t// If app dir already exists while installing, skip add\n-\t\t\t\t\t\tif (Pos(pathdir[d], aExecArr[i]) > 0) then\n-\t\t\t\t\t\t\tupdatepath := false;\n-\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\tend else begin\n-\t\t\t\t\t\t// If app dir exists and = what we originally set, then delete at uninstall\n-\t\t\t\t\t\tif aExecArr[i] = 'SET PATH=%PATH%;' + pathdir[d] then\n-\t\t\t\t\t\t\taExecArr[i] := '';\n-\t\t\t\t\tend;\n-\t\t\t\tend;\n-\t\t\tend;\n-\n-\t\t\t// If app dir not found, or autoexec.bat didn't exist, then (create and) append to current path\n-\t\t\tif (IsUninstaller() = false) AND (updatepath = true) then begin\n-\t\t\t\tSaveStringToFile(aExecFile, #13#10 + 'SET PATH=%PATH%;' + pathdir[d], True);\n-\n-\t\t\t// If uninstalling, write the full autoexec out\n-\t\t\tend else begin\n-\t\t\t\tSaveStringsToFile(aExecFile, aExecArr, False);\n-\t\t\tend;\n-\t\tend;\n-\tend;\n-end;\n-\n-// Split a string into an array using passed delimiter\n-procedure Explode(var Dest: TArrayOfString; Text: String; Separator: String);\n-var\n-\ti: Integer;\n-begin\n-\ti := 0;\n-\trepeat\n-\t\tSetArrayLength(Dest, i+1);\n-\t\tif Pos(Separator,Text) > 0 then\tbegin\n-\t\t\tDest[i] := Copy(Text, 1, Pos(Separator, Text)-1);\n-\t\t\tText := Copy(Text, Pos(Separator,Text) + Length(Separator), Length(Text));\n-\t\t\ti := i + 1;\n-\t\tend else begin\n-\t\t\t Dest[i] := Text;\n-\t\t\t Text := '';\n-\t\tend;\n-\tuntil Length(Text)=0;\n-end;\n-\n-\n-procedure ModPathCurStepChanged(CurStep: TSetupStep);\n-var\n-\ttaskname:\tString;\n-begin\n-\ttaskname := ModPathName;\n-\tif CurStep = ssPostInstall then\n-\t\tif IsTaskSelected(taskname) then\n-\t\t\tModPath();\n-end;\n-\n-procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep);\n-var\n-\taSelectedTasks:\tTArrayOfString;\n-\ti:\t\t\t\tInteger;\n-\ttaskname:\t\tString;\n-\tregpath:\t\tString;\n-\tregstring:\t\tString;\n-\tappid:\t\t\tString;\n-begin\n-\t// only run during actual uninstall\n-\tif CurUninstallStep = usUninstall then begin\n-\t\t// get list of selected tasks saved in registry at install time\n-\t\tappid := '{#emit SetupSetting(\"AppId\")}';\n-\t\tif appid = '' then appid := '{#emit SetupSetting(\"AppName\")}';\n-\t\tregpath := ExpandConstant('Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\'+appid+'_is1');\n-\t\tRegQueryStringValue(HKLM, regpath, 'Inno Setup: Selected Tasks', regstring);\n-\t\tif regstring = '' then RegQueryStringValue(HKCU, regpath, 'Inno Setup: Selected Tasks', regstring);\n-\n-\t\t// check each task; if matches modpath taskname, trigger patch removal\n-\t\tif regstring <> '' then begin\n-\t\t\ttaskname := ModPathName;\n-\t\t\tExplode(aSelectedTasks, regstring, ',');\n-\t\t\tif GetArrayLength(aSelectedTasks) > 0 then begin\n-\t\t\t\tfor i := 0 to GetArrayLength(aSelectedTasks)-1 do begin\n-\t\t\t\t\tif comparetext(aSelectedTasks[i], taskname) = 0 then\n-\t\t\t\t\t\tModPath();\n-\t\t\t\tend;\n-\t\t\tend;\n-\t\tend;\n-\tend;\n-end;\n-\n-function NeedRestart(): Boolean;\n-var\n-\ttaskname:\tString;\n-begin\n-\ttaskname := ModPathName;\n-\tif IsTaskSelected(taskname) and not UsingWinNT() then begin\n-\t\tResult := True;\n-\tend else begin\n-\t\tResult := False;\n-\tend;\n-end;"}, {"sha": "70648beac38b03565f77547f23542998dcce10b0", "filename": "src/etc/installer/exe/rust.iss", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Frust.iss?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,87 +0,0 @@\n-#define CFG_RELEASE_NUM GetEnv(\"CFG_RELEASE_NUM\")\n-#define CFG_RELEASE GetEnv(\"CFG_RELEASE\")\n-#define CFG_PACKAGE_NAME GetEnv(\"CFG_PACKAGE_NAME\")\n-#define CFG_BUILD GetEnv(\"CFG_BUILD\")\n-\n-[Setup]\n-\n-SetupIconFile=rust-logo.ico\n-AppName=Rust\n-AppVersion={#CFG_RELEASE}\n-AppCopyright=Copyright (C) 2006-2014 Mozilla Foundation, MIT license\n-AppPublisher=Mozilla Foundation\n-AppPublisherURL=http://www.rust-lang.org\n-VersionInfoVersion={#CFG_RELEASE_NUM}\n-LicenseFile=LICENSE.txt\n-\n-PrivilegesRequired=lowest\n-DisableWelcomePage=true\n-DisableProgramGroupPage=true\n-DisableReadyPage=true\n-DisableStartupPrompt=true\n-\n-OutputDir=.\\\n-SourceDir=.\\\n-OutputBaseFilename={#CFG_PACKAGE_NAME}-{#CFG_BUILD}\n-DefaultDirName={sd}\\Rust\n-\n-Compression=lzma2/normal\n-InternalCompressLevel=normal\n-SolidCompression=no\n-\n-ChangesEnvironment=true\n-ChangesAssociations=no\n-AllowUNCPath=false\n-AllowNoIcons=true\n-Uninstallable=yes\n-\n-[Tasks]\n-Name: modifypath; Description: &Add {app}\\bin to your PATH (recommended)\n-\n-[Components]\n-Name: rust; Description: \"Rust compiler and standard crates\"; Types: full compact custom; Flags: fixed\n-#ifdef MINGW\n-Name: gcc; Description: \"Linker and platform libraries\"; Types: full\n-#endif\n-Name: docs; Description: \"HTML documentation\"; Types: full\n-Name: cargo; Description: \"Cargo, the Rust package manager\"; Types: full\n-Name: std; Description: \"The Rust Standard Library\"; Types: full\n-// tool-rls-start\n-Name: rls; Description: \"RLS, the Rust Language Server\"\n-// tool-rls-end\n-\n-[Files]\n-Source: \"rustc/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rust\n-#ifdef MINGW\n-Source: \"rust-mingw/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: gcc\n-#endif\n-Source: \"rust-docs/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: docs\n-Source: \"cargo/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: cargo\n-Source: \"rust-std/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: std\n-// tool-rls-start\n-Source: \"rls/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n-Source: \"rust-analysis/*.*\"; DestDir: \"{app}\"; Flags: ignoreversion recursesubdirs; Components: rls\n-// tool-rls-end\n-\n-[Code]\n-const\n-\tModPathName = 'modifypath';\n-\tModPathType = 'user';\n-\n-function ModPathDir(): TArrayOfString;\n-begin\n-\tsetArrayLength(Result, 1)\n-\tResult[0] := ExpandConstant('{app}\\bin');\n-end;\n-\n-#include \"modpath.iss\"\n-#include \"upgrade.iss\"\n-\n-// Both modpath.iss and upgrade.iss want to overload CurStepChanged.\n-// This version does the overload then delegates to each.\n-\n-procedure CurStepChanged(CurStep: TSetupStep);\n-begin\n-  UpgradeCurStepChanged(CurStep);\n-  ModPathCurStepChanged(CurStep);\n-end;"}, {"sha": "29da7c333bb72b3c1cc1d6d463b8acc792c16363", "filename": "src/etc/installer/exe/upgrade.iss", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fetc%2Finstaller%2Fexe%2Fupgrade.iss", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Fetc%2Finstaller%2Fexe%2Fupgrade.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Fupgrade.iss?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,61 +0,0 @@\n-// The following code taken from https://stackoverflow.com/questions/2000296/innosetup-how-to-automatically-uninstall-previous-installed-version\n-// It performs upgrades by running the uninstaller before the install\n-\n-/////////////////////////////////////////////////////////////////////\n-function GetUninstallString(): String;\n-var\n-  sUnInstPath: String;\n-  sUnInstallString: String;\n-begin\n-  sUnInstPath := ExpandConstant('Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Rust_is1');\n-  sUnInstallString := '';\n-  if not RegQueryStringValue(HKLM, sUnInstPath, 'UninstallString', sUnInstallString) then\n-    RegQueryStringValue(HKCU, sUnInstPath, 'UninstallString', sUnInstallString);\n-  Result := sUnInstallString;\n-end;\n-\n-\n-/////////////////////////////////////////////////////////////////////\n-function IsUpgrade(): Boolean;\n-begin\n-  Result := (GetUninstallString() <> '');\n-end;\n-\n-\n-/////////////////////////////////////////////////////////////////////\n-function UnInstallOldVersion(): Integer;\n-var\n-  sUnInstallString: String;\n-  iResultCode: Integer;\n-begin\n-// Return Values:\n-// 1 - uninstall string is empty\n-// 2 - error executing the UnInstallString\n-// 3 - successfully executed the UnInstallString\n-\n-  // default return value\n-  Result := 0;\n-\n-  // get the uninstall string of the old app\n-  sUnInstallString := GetUninstallString();\n-  if sUnInstallString <> '' then begin\n-    sUnInstallString := RemoveQuotes(sUnInstallString);\n-    if Exec(sUnInstallString, '/SILENT /NORESTART /SUPPRESSMSGBOXES','', SW_HIDE, ewWaitUntilTerminated, iResultCode) then\n-      Result := 3\n-    else\n-      Result := 2;\n-  end else\n-    Result := 1;\n-end;\n-\n-/////////////////////////////////////////////////////////////////////\n-procedure UpgradeCurStepChanged(CurStep: TSetupStep);\n-begin\n-  if (CurStep=ssInstall) then\n-  begin\n-    if (IsUpgrade()) then\n-    begin\n-      UnInstallOldVersion();\n-    end;\n-  end;\n-end;"}, {"sha": "76139209c9151da807c35e77c73bd2ce401f8cad", "filename": "src/librustc_ast/attr/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fattr%2Fmod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -475,7 +475,7 @@ impl MetaItem {\n                 let span = span.with_hi(segments.last().unwrap().ident.span.hi());\n                 Path { span, segments }\n             }\n-            Some(TokenTree::Token(Token { kind: token::Interpolated(nt, _), .. })) => match *nt {\n+            Some(TokenTree::Token(Token { kind: token::Interpolated(nt), .. })) => match *nt {\n                 token::Nonterminal::NtMeta(ref item) => return item.meta(item.path.span),\n                 token::Nonterminal::NtPath(ref path) => path.clone(),\n                 _ => return None,\n@@ -560,6 +560,9 @@ impl MetaItemKind {\n         tokens: &mut impl Iterator<Item = TokenTree>,\n     ) -> Option<MetaItemKind> {\n         match tokens.next() {\n+            Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n+                MetaItemKind::name_value_from_tokens(&mut inner_tokens.trees())\n+            }\n             Some(TokenTree::Token(token)) => {\n                 Lit::from_token(&token).ok().map(MetaItemKind::NameValue)\n             }\n@@ -619,13 +622,20 @@ impl NestedMetaItem {\n     where\n         I: Iterator<Item = TokenTree>,\n     {\n-        if let Some(TokenTree::Token(token)) = tokens.peek() {\n-            if let Ok(lit) = Lit::from_token(token) {\n+        match tokens.peek() {\n+            Some(TokenTree::Token(token)) => {\n+                if let Ok(lit) = Lit::from_token(token) {\n+                    tokens.next();\n+                    return Some(NestedMetaItem::Literal(lit));\n+                }\n+            }\n+            Some(TokenTree::Delimited(_, token::NoDelim, inner_tokens)) => {\n+                let inner_tokens = inner_tokens.clone();\n                 tokens.next();\n-                return Some(NestedMetaItem::Literal(lit));\n+                return NestedMetaItem::from_tokens(&mut inner_tokens.into_trees().peekable());\n             }\n+            _ => {}\n         }\n-\n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }"}, {"sha": "54f81ef106fe14e39424e5f26fcb4c74212aa43b", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -656,7 +656,7 @@ pub fn noop_visit_token<T: MutVisitor>(t: &mut Token, vis: &mut T) {\n             *span = ident.span;\n             return; // Avoid visiting the span for the second time.\n         }\n-        token::Interpolated(nt, _) => {\n+        token::Interpolated(nt) => {\n             let mut nt = Lrc::make_mut(nt);\n             vis.visit_interpolated(&mut nt);\n         }"}, {"sha": "173ea5e48d682d54ca613282a8c2e4192c8969f0", "filename": "src/librustc_ast/token.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Ftoken.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -11,7 +11,7 @@ use crate::tokenstream::TokenTree;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_macros::HashStable_Generic;\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{self, Span, DUMMY_SP};\n use std::borrow::Cow;\n@@ -182,15 +182,6 @@ fn ident_can_begin_type(name: Symbol, span: Span, is_raw: bool) -> bool {\n             .contains(&name)\n }\n \n-/// A hack used to pass AST fragments to attribute and derive macros\n-/// as a single nonterminal token instead of a token stream.\n-/// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n-pub enum FlattenGroup {\n-    Yes,\n-    No,\n-}\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum TokenKind {\n     /* Expression-operator symbols. */\n@@ -245,7 +236,7 @@ pub enum TokenKind {\n     /// treat regular and interpolated lifetime identifiers in the same way.\n     Lifetime(Symbol),\n \n-    Interpolated(Lrc<Nonterminal>, FlattenGroup),\n+    Interpolated(Lrc<Nonterminal>),\n \n     // Can be expanded into several tokens.\n     /// A doc comment.\n@@ -352,7 +343,7 @@ impl Token {\n     /// if they keep spans or perform edition checks.\n     pub fn uninterpolated_span(&self) -> Span {\n         match &self.kind {\n-            Interpolated(nt, _) => nt.span(),\n+            Interpolated(nt) => nt.span(),\n             _ => self.span,\n         }\n     }\n@@ -391,7 +382,7 @@ impl Token {\n             ModSep                            | // global path\n             Lifetime(..)                      | // labeled loop\n             Pound                             => true, // expression attributes\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) |\n                 NtExpr(..)    |\n                 NtBlock(..)   |\n@@ -417,7 +408,7 @@ impl Token {\n             Lifetime(..)                | // lifetime bound in trait object\n             Lt | BinOp(Shl)             | // associated path\n             ModSep                      => true, // global path\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtTy(..) | NtPath(..) => true,\n                 _ => false,\n             },\n@@ -429,7 +420,7 @@ impl Token {\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self.kind {\n             OpenDelim(Brace) => true,\n-            Interpolated(ref nt, _) => match **nt {\n+            Interpolated(ref nt) => match **nt {\n                 NtExpr(..) | NtBlock(..) | NtLiteral(..) => true,\n                 _ => false,\n             },\n@@ -464,7 +455,7 @@ impl Token {\n         match self.uninterpolate().kind {\n             Literal(..) | BinOp(Minus) => true,\n             Ident(name, false) if name.is_bool_lit() => true,\n-            Interpolated(ref nt, _) => match &**nt {\n+            Interpolated(ref nt) => match &**nt {\n                 NtLiteral(_) => true,\n                 NtExpr(e) => match &e.kind {\n                     ast::ExprKind::Lit(_) => true,\n@@ -485,7 +476,7 @@ impl Token {\n     // otherwise returns the original token.\n     pub fn uninterpolate(&self) -> Cow<'_, Token> {\n         match &self.kind {\n-            Interpolated(nt, _) => match **nt {\n+            Interpolated(nt) => match **nt {\n                 NtIdent(ident, is_raw) => {\n                     Cow::Owned(Token::new(Ident(ident.name, is_raw), ident.span))\n                 }\n@@ -532,7 +523,7 @@ impl Token {\n \n     /// Returns `true` if the token is an interpolated path.\n     fn is_path(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtPath(..) = **nt {\n                 return true;\n             }\n@@ -544,7 +535,7 @@ impl Token {\n     /// That is, is this a pre-parsed expression dropped into the token stream\n     /// (which happens while parsing the result of macro expansion)?\n     pub fn is_whole_expr(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtExpr(_) | NtLiteral(_) | NtPath(_) | NtIdent(..) | NtBlock(_) = **nt {\n                 return true;\n             }\n@@ -555,7 +546,7 @@ impl Token {\n \n     // Is the token an interpolated block (`$b:block`)?\n     pub fn is_whole_block(&self) -> bool {\n-        if let Interpolated(ref nt, _) = self.kind {\n+        if let Interpolated(ref nt) = self.kind {\n             if let NtBlock(..) = **nt {\n                 return true;\n             }\n@@ -785,6 +776,26 @@ impl Nonterminal {\n             NtTT(tt) => tt.span(),\n         }\n     }\n+\n+    /// This nonterminal looks like some specific enums from\n+    /// `proc-macro-hack` and `procedural-masquerade` crates.\n+    /// We need to maintain some special pretty-printing behavior for them due to incorrect\n+    /// asserts in old versions of those crates and their wide use in the ecosystem.\n+    /// See issue #73345 for more details.\n+    /// FIXME(#73933): Remove this eventually.\n+    pub fn pretty_printing_compatibility_hack(&self) -> bool {\n+        if let NtItem(item) = self {\n+            let name = item.ident.name;\n+            if name == sym::ProceduralMasqueradeDummyType || name == sym::ProcMacroHack {\n+                if let ast::ItemKind::Enum(enum_def, _) = &item.kind {\n+                    if let [variant] = &*enum_def.variants {\n+                        return variant.ident.name == sym::Input;\n+                    }\n+                }\n+            }\n+        }\n+        false\n+    }\n }\n \n impl PartialEq for Nonterminal {"}, {"sha": "4428d09902b92d6b8a3360e130737b33eb66b32d", "filename": "src/librustc_ast/util/literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Futil%2Fliteral.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -205,7 +205,7 @@ impl Lit {\n                 token::Lit::new(token::Bool, name, None)\n             }\n             token::Literal(lit) => lit,\n-            token::Interpolated(ref nt, _) => {\n+            token::Interpolated(ref nt) => {\n                 if let token::NtExpr(expr) | token::NtLiteral(expr) = &**nt {\n                     if let ast::ExprKind::Lit(lit) = &expr.kind {\n                         return Ok(lit.clone());"}, {"sha": "b5d3beb4f8a9b70331639b0d3e9ec8aa7ce2645f", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -39,8 +39,8 @@ use rustc_ast::ast;\n use rustc_ast::ast::*;\n use rustc_ast::attr;\n use rustc_ast::node_id::NodeMap;\n-use rustc_ast::token::{self, Nonterminal, Token};\n-use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::token::{self, DelimToken, Nonterminal, Token};\n+use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree};\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::walk_list;\n use rustc_ast_pretty::pprust;\n@@ -1027,9 +1027,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_token(&mut self, token: Token) -> TokenStream {\n         match token.kind {\n-            token::Interpolated(nt, _) => {\n+            token::Interpolated(nt) => {\n                 let tts = (self.nt_to_tokenstream)(&nt, &self.sess.parse_sess, token.span);\n-                self.lower_token_stream(tts)\n+                TokenTree::Delimited(\n+                    DelimSpan::from_single(token.span),\n+                    DelimToken::NoDelim,\n+                    self.lower_token_stream(tts),\n+                )\n+                .into()\n             }\n             _ => TokenTree::Token(token).into(),\n         }"}, {"sha": "5a6e10f49f9e6959666d73c7ac37d14e7beae1f1", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -148,9 +148,14 @@ pub fn to_string(f: impl FnOnce(&mut State<'_>)) -> String {\n     printer.s.eof()\n }\n \n-// This makes comma-separated lists look slightly nicer,\n-// and also addresses a specific regression described in issue #63896.\n+// This makes printed token streams look slightly nicer,\n+// and also addresses some specific regressions described in #63896 and #73345.\n fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n+    if let TokenTree::Token(token) = prev {\n+        if let token::DocComment(s) = token.kind {\n+            return !s.as_str().starts_with(\"//\");\n+        }\n+    }\n     match tt {\n         TokenTree::Token(token) => match token.kind {\n             token::Comma => false,\n@@ -163,7 +168,14 @@ fn tt_prepend_space(tt: &TokenTree, prev: &TokenTree) -> bool {\n             },\n             _ => true,\n         },\n-        _ => true,\n+        TokenTree::Delimited(_, DelimToken::Bracket, _) => match prev {\n+            TokenTree::Token(token) => match token.kind {\n+                token::Pound => false,\n+                _ => true,\n+            },\n+            _ => true,\n+        },\n+        TokenTree::Delimited(..) => true,\n     }\n }\n \n@@ -245,7 +257,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::CloseDelim(token::Bracket) => \"]\".to_string(),\n         token::OpenDelim(token::Brace) => \"{\".to_string(),\n         token::CloseDelim(token::Brace) => \"}\".to_string(),\n-        token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \" \".to_string(),\n+        token::OpenDelim(token::NoDelim) | token::CloseDelim(token::NoDelim) => \"\".to_string(),\n         token::Pound => \"#\".to_string(),\n         token::Dollar => \"$\".to_string(),\n         token::Question => \"?\".to_string(),\n@@ -266,7 +278,7 @@ fn token_kind_to_string_ext(tok: &TokenKind, convert_dollar_crate: Option<Span>)\n         token::Shebang(s) => format!(\"/* shebang: {}*/\", s),\n         token::Unknown(s) => s.to_string(),\n \n-        token::Interpolated(ref nt, _) => nonterminal_to_string(nt),\n+        token::Interpolated(ref nt) => nonterminal_to_string(nt),\n     }\n }\n "}, {"sha": "7cf5202d919f8269ee500813568cb12e77627d9b", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -412,9 +412,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // be computed with the initial length, and we would miss the appended\n         // nodes. Therefore we use a `while` loop.\n         let mut index = 0;\n-        while index < self.nodes.len() {\n-            let node = &mut self.nodes[index];\n-\n+        while let Some(node) = self.nodes.get_mut(index) {\n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n             // `self.active_cache`. This means that `self.active_cache` can get\n@@ -666,16 +664,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         for node in &mut self.nodes {\n             let mut i = 0;\n-            while i < node.dependents.len() {\n-                let new_index = node_rewrites[node.dependents[i]];\n+            while let Some(dependent) = node.dependents.get_mut(i) {\n+                let new_index = node_rewrites[*dependent];\n                 if new_index >= orig_nodes_len {\n                     node.dependents.swap_remove(i);\n                     if i == 0 && node.has_parent {\n                         // We just removed the parent.\n                         node.has_parent = false;\n                     }\n                 } else {\n-                    node.dependents[i] = new_index;\n+                    *dependent = new_index;\n                     i += 1;\n                 }\n             }"}, {"sha": "189da3395ad1b32999e43db90bd67b6e1ebc33f9", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -391,14 +391,12 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n /// - Input: `[a, x, b, y]`. Output: `[a, x]`.\n fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix<usize, usize>) {\n     let mut i = 0;\n-    while i < candidates.len() {\n-        let candidate_i = candidates[i];\n+    while let Some(&candidate_i) = candidates.get(i) {\n         i += 1;\n \n         let mut j = i;\n         let mut dead = 0;\n-        while j < candidates.len() {\n-            let candidate_j = candidates[j];\n+        while let Some(&candidate_j) = candidates.get(j) {\n             if closure.contains(candidate_i, candidate_j) {\n                 // If `i` can reach `j`, then we can remove `j`. So just\n                 // mark it as dead and move on; subsequent indices will be"}, {"sha": "7e09210e7874cfad8ea9577ef12b2f1a8d1d6042", "filename": "src/librustc_error_codes/error_codes/E0712.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_error_codes%2Ferror_codes%2FE0712.md", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_error_codes%2Ferror_codes%2FE0712.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0712.md?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,5 +1,5 @@\n-This error occurs because a borrow of a thread-local variable was made inside a\n-function which outlived the lifetime of the function.\n+A borrow of a thread-local variable was made inside a function which outlived\n+the lifetime of the function.\n \n Erroneous code example:\n "}, {"sha": "db9293bddeb7d446f6ba50e06d544fd6662ecbe4", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -4,14 +4,14 @@ use crate::module::DirectoryOwnership;\n use rustc_ast::ast::{self, Attribute, NodeId, PatKind};\n use rustc_ast::mut_visit::{self, MutVisitor};\n use rustc_ast::ptr::P;\n-use rustc_ast::token::{self, FlattenGroup};\n-use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::{self, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n-use rustc_parse::{self, parser, MACRO_ARGUMENTS};\n+use rustc_parse::{self, nt_to_tokenstream, parser, MACRO_ARGUMENTS};\n use rustc_session::{parse::ParseSess, Limit};\n use rustc_span::def_id::DefId;\n use rustc_span::edition::Edition;\n@@ -120,10 +120,7 @@ impl Annotatable {\n         }\n     }\n \n-    crate fn into_tokens(self) -> TokenStream {\n-        // `Annotatable` can be converted into tokens directly, but we\n-        // are packing it into a nonterminal as a piece of AST to make\n-        // the produced token stream look nicer in pretty-printed form.\n+    crate fn into_tokens(self, sess: &ParseSess) -> TokenStream {\n         let nt = match self {\n             Annotatable::Item(item) => token::NtItem(item),\n             Annotatable::TraitItem(item) | Annotatable::ImplItem(item) => {\n@@ -142,7 +139,7 @@ impl Annotatable {\n             | Annotatable::StructField(..)\n             | Annotatable::Variant(..) => panic!(\"unexpected annotatable\"),\n         };\n-        TokenTree::token(token::Interpolated(Lrc::new(nt), FlattenGroup::Yes), DUMMY_SP).into()\n+        nt_to_tokenstream(&nt, sess, DUMMY_SP)\n     }\n \n     pub fn expect_item(self) -> P<ast::Item> {\n@@ -374,7 +371,7 @@ where\n         impl MutVisitor for AvoidInterpolatedIdents {\n             fn visit_tt(&mut self, tt: &mut tokenstream::TokenTree) {\n                 if let tokenstream::TokenTree::Token(token) = tt {\n-                    if let token::Interpolated(nt, _) = &token.kind {\n+                    if let token::Interpolated(nt) = &token.kind {\n                         if let token::NtIdent(ident, is_raw) = **nt {\n                             *tt = tokenstream::TokenTree::token(\n                                 token::Ident(ident.name, is_raw),"}, {"sha": "bd7a094c5e355737280dade8ea08d0a9748c6f39", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -705,7 +705,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 SyntaxExtensionKind::Attr(expander) => {\n                     self.gate_proc_macro_input(&item);\n                     self.gate_proc_macro_attr_item(span, &item);\n-                    let tokens = item.into_tokens();\n+                    let tokens = item.into_tokens(self.cx.parse_sess);\n                     let attr_item = attr.unwrap_normal_item();\n                     if let MacArgs::Eq(..) = attr_item.args {\n                         self.cx.span_err(span, \"key-value macro attributes are not supported\");"}, {"sha": "3c15a81c67f6748af6fa10849c90916984e09d72", "filename": "src/librustc_expand/mbe/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_parser.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -790,7 +790,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::block => match token.kind {\n             token::OpenDelim(token::Brace) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n                 | token::NtPat(_)\n                 | token::NtTy(_)\n@@ -804,7 +804,7 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n         },\n         sym::path | sym::meta => match token.kind {\n             token::ModSep | token::Ident(..) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n@@ -823,12 +823,12 @@ fn may_begin_with(token: &Token, name: Symbol) -> bool {\n             token::ModSep |                     // path\n             token::Lt |                         // path (UFCS constant)\n             token::BinOp(token::Shl) => true,   // path (double UFCS)\n-            token::Interpolated(ref nt, _) => may_be_ident(nt),\n+            token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n         sym::lifetime => match token.kind {\n             token::Lifetime(_) => true,\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n                 _ => false,\n             },"}, {"sha": "7101525b3097721272e0de0cb09a09c871c3a511", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -387,6 +387,7 @@ pub fn compile_declarative_macro(\n     def: &ast::Item,\n     edition: Edition,\n ) -> SyntaxExtension {\n+    debug!(\"compile_declarative_macro: {:?}\", def);\n     let mk_syn_ext = |expander| {\n         SyntaxExtension::new(\n             sess,"}, {"sha": "09306f26ee0adb76436b0781ca37b6551e6cc9c7", "filename": "src/librustc_expand/mbe/quoted.rs", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fquoted.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -90,72 +90,88 @@ pub(super) fn parse(\n /// # Parameters\n ///\n /// - `tree`: the tree we wish to convert.\n-/// - `trees`: an iterator over trees. We may need to read more tokens from it in order to finish\n+/// - `outer_trees`: an iterator over trees. We may need to read more tokens from it in order to finish\n ///   converting `tree`\n /// - `expect_matchers`: same as for `parse` (see above).\n /// - `sess`: the parsing session. Any errors will be emitted to this session.\n /// - `features`, `attrs`: language feature flags and attributes so that we know whether to use\n ///   unstable features or not.\n fn parse_tree(\n     tree: tokenstream::TokenTree,\n-    trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n+    outer_trees: &mut impl Iterator<Item = tokenstream::TokenTree>,\n     expect_matchers: bool,\n     sess: &ParseSess,\n     node_id: NodeId,\n ) -> TokenTree {\n     // Depending on what `tree` is, we could be parsing different parts of a macro\n     match tree {\n         // `tree` is a `$` token. Look at the next token in `trees`\n-        tokenstream::TokenTree::Token(Token { kind: token::Dollar, span }) => match trees.next() {\n-            // `tree` is followed by a delimited set of token trees. This indicates the beginning\n-            // of a repetition sequence in the macro (e.g. `$(pat)*`).\n-            Some(tokenstream::TokenTree::Delimited(span, delim, tts)) => {\n-                // Must have `(` not `{` or `[`\n-                if delim != token::Paren {\n-                    let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n-                    let msg = format!(\"expected `(`, found `{}`\", tok);\n-                    sess.span_diagnostic.span_err(span.entire(), &msg);\n-                }\n-                // Parse the contents of the sequence itself\n-                let sequence = parse(tts, expect_matchers, sess, node_id);\n-                // Get the Kleene operator and optional separator\n-                let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n-                // Count the number of captured \"names\" (i.e., named metavars)\n-                let name_captures = macro_parser::count_names(&sequence);\n-                TokenTree::Sequence(\n-                    span,\n-                    Lrc::new(SequenceRepetition {\n-                        tts: sequence,\n-                        separator,\n-                        kleene,\n-                        num_captures: name_captures,\n-                    }),\n-                )\n+        tokenstream::TokenTree::Token(Token { kind: token::Dollar, span }) => {\n+            // FIXME: Handle `None`-delimited groups in a more systematic way\n+            // during parsing.\n+            let mut next = outer_trees.next();\n+            let mut trees: Box<dyn Iterator<Item = tokenstream::TokenTree>>;\n+            if let Some(tokenstream::TokenTree::Delimited(_, token::NoDelim, tts)) = next {\n+                trees = Box::new(tts.into_trees());\n+                next = trees.next();\n+            } else {\n+                trees = Box::new(outer_trees);\n             }\n \n-            // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n-            // metavariable that names the crate of the invocation.\n-            Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n-                let (ident, is_raw) = token.ident().unwrap();\n-                let span = ident.span.with_lo(span.lo());\n-                if ident.name == kw::Crate && !is_raw {\n-                    TokenTree::token(token::Ident(kw::DollarCrate, is_raw), span)\n-                } else {\n-                    TokenTree::MetaVar(span, ident)\n+            match next {\n+                // `tree` is followed by a delimited set of token trees. This indicates the beginning\n+                // of a repetition sequence in the macro (e.g. `$(pat)*`).\n+                Some(tokenstream::TokenTree::Delimited(span, delim, tts)) => {\n+                    // Must have `(` not `{` or `[`\n+                    if delim != token::Paren {\n+                        let tok = pprust::token_kind_to_string(&token::OpenDelim(delim));\n+                        let msg = format!(\"expected `(`, found `{}`\", tok);\n+                        sess.span_diagnostic.span_err(span.entire(), &msg);\n+                    }\n+                    // Parse the contents of the sequence itself\n+                    let sequence = parse(tts, expect_matchers, sess, node_id);\n+                    // Get the Kleene operator and optional separator\n+                    let (separator, kleene) =\n+                        parse_sep_and_kleene_op(&mut trees, span.entire(), sess);\n+                    // Count the number of captured \"names\" (i.e., named metavars)\n+                    let name_captures = macro_parser::count_names(&sequence);\n+                    TokenTree::Sequence(\n+                        span,\n+                        Lrc::new(SequenceRepetition {\n+                            tts: sequence,\n+                            separator,\n+                            kleene,\n+                            num_captures: name_captures,\n+                        }),\n+                    )\n                 }\n-            }\n \n-            // `tree` is followed by a random token. This is an error.\n-            Some(tokenstream::TokenTree::Token(token)) => {\n-                let msg =\n-                    format!(\"expected identifier, found `{}`\", pprust::token_to_string(&token),);\n-                sess.span_diagnostic.span_err(token.span, &msg);\n-                TokenTree::MetaVar(token.span, Ident::invalid())\n-            }\n+                // `tree` is followed by an `ident`. This could be `$meta_var` or the `$crate` special\n+                // metavariable that names the crate of the invocation.\n+                Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n+                    let (ident, is_raw) = token.ident().unwrap();\n+                    let span = ident.span.with_lo(span.lo());\n+                    if ident.name == kw::Crate && !is_raw {\n+                        TokenTree::token(token::Ident(kw::DollarCrate, is_raw), span)\n+                    } else {\n+                        TokenTree::MetaVar(span, ident)\n+                    }\n+                }\n \n-            // There are no more tokens. Just return the `$` we already have.\n-            None => TokenTree::token(token::Dollar, span),\n-        },\n+                // `tree` is followed by a random token. This is an error.\n+                Some(tokenstream::TokenTree::Token(token)) => {\n+                    let msg = format!(\n+                        \"expected identifier, found `{}`\",\n+                        pprust::token_to_string(&token),\n+                    );\n+                    sess.span_diagnostic.span_err(token.span, &msg);\n+                    TokenTree::MetaVar(token.span, Ident::invalid())\n+                }\n+\n+                // There are no more tokens. Just return the `$` we already have.\n+                None => TokenTree::token(token::Dollar, span),\n+            }\n+        }\n \n         // `tree` is an arbitrary token. Keep it.\n         tokenstream::TokenTree::Token(token) => TokenTree::Token(token),"}, {"sha": "e2d3d5c4d644e04076ac1fbb31ac672bdfa7f29e", "filename": "src/librustc_expand/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Ftranscribe.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -4,7 +4,7 @@ use crate::mbe::macro_parser::{MatchedNonterminal, MatchedSeq, NamedMatch};\n \n use rustc_ast::ast::MacCall;\n use rustc_ast::mut_visit::{self, MutVisitor};\n-use rustc_ast::token::{self, FlattenGroup, NtTT, Token};\n+use rustc_ast::token::{self, NtTT, Token};\n use rustc_ast::tokenstream::{DelimSpan, TokenStream, TokenTree, TreeAndJoint};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -240,10 +240,7 @@ pub(super) fn transcribe<'a>(\n                             result.push(tt.clone().into());\n                         } else {\n                             marker.visit_span(&mut sp);\n-                            let token = TokenTree::token(\n-                                token::Interpolated(nt.clone(), FlattenGroup::No),\n-                                sp,\n-                            );\n+                            let token = TokenTree::token(token::Interpolated(nt.clone()), sp);\n                             result.push(token.into());\n                         }\n                     } else {"}, {"sha": "54012d62a72a7a54c68dade7752ae5c9724ea079", "filename": "src/librustc_expand/proc_macro.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -2,10 +2,11 @@ use crate::base::{self, *};\n use crate::proc_macro_server;\n \n use rustc_ast::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n-use rustc_ast::token::{self, FlattenGroup};\n-use rustc_ast::tokenstream::{self, TokenStream};\n+use rustc_ast::token;\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, ErrorReported};\n+use rustc_parse::nt_to_tokenstream;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -102,8 +103,12 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        let token = token::Interpolated(Lrc::new(token::NtItem(item)), FlattenGroup::Yes);\n-        let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n+        let item = token::NtItem(item);\n+        let input = if item.pretty_printing_compatibility_hack() {\n+            TokenTree::token(token::Interpolated(Lrc::new(item)), DUMMY_SP).into()\n+        } else {\n+            nt_to_tokenstream(&item, ecx.parse_sess, DUMMY_SP)\n+        };\n \n         let server = proc_macro_server::Rustc::new(ecx);\n         let stream = match self.client.run(&EXEC_STRATEGY, server, input) {"}, {"sha": "663bc508143d6748fa8fc9b3b288045976193d93", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,7 +1,7 @@\n use crate::base::ExtCtxt;\n \n use rustc_ast::ast;\n-use rustc_ast::token::{self, FlattenGroup};\n+use rustc_ast::token;\n use rustc_ast::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n use rustc_ast::util::comments;\n use rustc_ast_pretty::pprust;\n@@ -60,12 +60,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n         let Token { kind, span } = match tree {\n             tokenstream::TokenTree::Delimited(span, delim, tts) => {\n                 let delimiter = Delimiter::from_internal(delim);\n-                return TokenTree::Group(Group {\n-                    delimiter,\n-                    stream: tts,\n-                    span,\n-                    flatten: FlattenGroup::No,\n-                });\n+                return TokenTree::Group(Group { delimiter, stream: tts, span, flatten: false });\n             }\n             tokenstream::TokenTree::Token(token) => token,\n         };\n@@ -172,21 +167,21 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     delimiter: Delimiter::Bracket,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten: FlattenGroup::No,\n+                    flatten: false,\n                 }));\n                 if style == ast::AttrStyle::Inner {\n                     stack.push(tt!(Punct::new('!', false)));\n                 }\n                 tt!(Punct::new('#', false))\n             }\n \n-            Interpolated(nt, flatten) => {\n+            Interpolated(nt) => {\n                 let stream = nt_to_tokenstream(&nt, sess, span);\n                 TokenTree::Group(Group {\n                     delimiter: Delimiter::None,\n                     stream,\n                     span: DelimSpan::from_single(span),\n-                    flatten,\n+                    flatten: nt.pretty_printing_compatibility_hack(),\n                 })\n             }\n \n@@ -293,7 +288,7 @@ pub struct Group {\n     /// A hack used to pass AST fragments to attribute and derive macros\n     /// as a single nonterminal token instead of a token stream.\n     /// FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n-    flatten: FlattenGroup,\n+    flatten: bool,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -453,7 +448,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n             // Such token needs to be \"unwrapped\" and not represented as a delimited group.\n             // FIXME: It needs to be removed, but there are some compatibility issues (see #73345).\n             if let TokenTree::Group(ref group) = tree {\n-                if matches!(group.flatten, FlattenGroup::Yes) {\n+                if group.flatten {\n                     iter.cursor.append(group.stream.clone());\n                     continue;\n                 }\n@@ -469,7 +464,7 @@ impl server::Group for Rustc<'_> {\n             delimiter,\n             stream,\n             span: DelimSpan::from_single(server::Span::call_site(self)),\n-            flatten: FlattenGroup::No,\n+            flatten: false,\n         }\n     }\n     fn delimiter(&mut self, group: &Self::Group) -> Delimiter {"}, {"sha": "e35dbbc0c2f24bb3fc81472a38e3a97c6cdfd9da", "filename": "src/librustc_interface/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_interface%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_interface%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Ftests.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -500,7 +500,6 @@ fn test_debugging_options_tracking_hash() {\n     untracked!(print_link_args, true);\n     untracked!(print_llvm_passes, true);\n     untracked!(print_mono_items, Some(String::from(\"abc\")));\n-    untracked!(print_region_graph, true);\n     untracked!(print_type_sizes, true);\n     untracked!(query_dep_graph, true);\n     untracked!(query_stats, true);"}, {"sha": "2f4b1bbd3ba0f139842191b17162469ebd69c2e5", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -51,8 +51,9 @@ pub enum TokenKind {\n     // Multi-char tokens:\n     /// \"// comment\"\n     LineComment,\n-    /// \"/* block comment */\"\n-    /// Block comments can be recursive, so the sequence like \"/* /* */\"\n+    /// `/* block comment */`\n+    ///\n+    /// Block comments can be recursive, so the sequence like `/* /* */`\n     /// will not be considered terminated and will result in a parsing error.\n     BlockComment { terminated: bool },\n     /// Any whitespace characters sequence."}, {"sha": "abbe45fe02e25f3c2162a185ce75e9eb5e3eec61", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -239,6 +239,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n         syms\n     }\n+\n+    crate_extern_paths => { cdata.source().paths().cloned().collect() }\n }\n \n pub fn provide(providers: &mut Providers<'_>) {"}, {"sha": "e7f9ad9d1cfd75443011b9d340e553c8dbce7a98", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1042,6 +1042,10 @@ rustc_queries! {\n             eval_always\n             desc { \"looking up the extra filename for a crate\" }\n         }\n+        query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n+            eval_always\n+            desc { \"looking up the paths for extern crates\" }\n+        }\n     }\n \n     TypeChecking {"}, {"sha": "cee4efaa4651832856a7d6eed36c6e419ab5aab5", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1049,6 +1049,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 Some(attr) => attr,\n                 None => return Bound::Unbounded,\n             };\n+            debug!(\"layout_scalar_valid_range: attr={:?}\", attr);\n             for meta in attr.meta_item_list().expect(\"rustc_layout_scalar_valid_range takes args\") {\n                 match meta.literal().expect(\"attribute takes lit\").kind {\n                     ast::LitKind::Int(a, _) => return Bound::Included(a),\n@@ -1169,7 +1170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ty_error_with_message(DUMMY_SP, \"TyKind::Error constructed but no error reported\")\n     }\n \n-    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n     /// ensure it gets used.\n     #[track_caller]\n     pub fn ty_error_with_message<S: Into<MultiSpan>>(self, span: S, msg: &str) -> Ty<'tcx> {"}, {"sha": "2ad49b1acce435c9ad1cac9f11bda2cdf60e0730", "filename": "src/librustc_middle/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fmod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -57,6 +57,7 @@ use rustc_span::{Span, DUMMY_SP};\n use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n+use std::path::PathBuf;\n use std::sync::Arc;\n \n #[macro_use]"}, {"sha": "803f14a2a228a6789915694fe27ee9ec38541dbb", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -155,7 +155,7 @@ impl<'a> Parser<'a> {\n     /// The delimiters or `=` are still put into the resulting token stream.\n     pub fn parse_attr_item(&mut self) -> PResult<'a, ast::AttrItem> {\n         let item = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n                 _ => None,\n             },\n@@ -254,7 +254,7 @@ impl<'a> Parser<'a> {\n     ///     meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n         let nt_meta = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtMeta(ref e) => Some(e.clone()),\n                 _ => None,\n             },"}, {"sha": "16a118cb48c913eb1901a75a64f9cd44cbe1fd58", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -376,7 +376,14 @@ impl<'a> Parser<'a> {\n     /// let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>>>();\n     ///                                                        ^^ help: remove extra angle brackets\n     /// ```\n-    pub(super) fn check_trailing_angle_brackets(&mut self, segment: &PathSegment, end: TokenKind) {\n+    ///\n+    /// If `true` is returned, then trailing brackets were recovered, tokens were consumed\n+    /// up until one of the tokens in 'end' was encountered, and an error was emitted.\n+    pub(super) fn check_trailing_angle_brackets(\n+        &mut self,\n+        segment: &PathSegment,\n+        end: &[&TokenKind],\n+    ) -> bool {\n         // This function is intended to be invoked after parsing a path segment where there are two\n         // cases:\n         //\n@@ -409,7 +416,7 @@ impl<'a> Parser<'a> {\n             parsed_angle_bracket_args,\n         );\n         if !parsed_angle_bracket_args {\n-            return;\n+            return false;\n         }\n \n         // Keep the span at the start so we can highlight the sequence of `>` characters to be\n@@ -447,18 +454,18 @@ impl<'a> Parser<'a> {\n             number_of_gt, number_of_shr,\n         );\n         if number_of_gt < 1 && number_of_shr < 1 {\n-            return;\n+            return false;\n         }\n \n         // Finally, double check that we have our end token as otherwise this is the\n         // second case.\n         if self.look_ahead(position, |t| {\n             trace!(\"check_trailing_angle_brackets: t={:?}\", t);\n-            *t == end\n+            end.contains(&&t.kind)\n         }) {\n             // Eat from where we started until the end token so that parsing can continue\n             // as if we didn't have those extra angle brackets.\n-            self.eat_to_tokens(&[&end]);\n+            self.eat_to_tokens(end);\n             let span = lo.until(self.token.span);\n \n             let total_num_of_gt = number_of_gt + number_of_shr * 2;\n@@ -473,7 +480,9 @@ impl<'a> Parser<'a> {\n                 Applicability::MachineApplicable,\n             )\n             .emit();\n+            return true;\n         }\n+        false\n     }\n \n     /// Check to see if a pair of chained operators looks like an attempt at chained comparison,"}, {"sha": "abb444933536ff0e7d845b3b39170da2f8c6ef4b", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -26,7 +26,7 @@ use std::mem;\n /// `token::Interpolated` tokens.\n macro_rules! maybe_whole_expr {\n     ($p:expr) => {\n-        if let token::Interpolated(nt, _) = &$p.token.kind {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n             match &**nt {\n                 token::NtExpr(e) | token::NtLiteral(e) => {\n                     let e = e.clone();\n@@ -867,7 +867,7 @@ impl<'a> Parser<'a> {\n \n         let fn_span_lo = self.token.span;\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n-        self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n+        self.check_trailing_angle_brackets(&segment, &[&token::OpenDelim(token::Paren)]);\n \n         if self.check(&token::OpenDelim(token::Paren)) {\n             // Method call `expr.f()`"}, {"sha": "5923a185dcf939c167bc4b7c8b2875c073a068ab", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::ast::{AssocItem, AssocItemKind, ForeignItemKind, Item, ItemKind,\n use rustc_ast::ast::{Async, Const, Defaultness, IsAuto, Mutability, Unsafe, UseTree, UseTreeKind};\n use rustc_ast::ast::{BindingMode, Block, FnDecl, FnSig, Param, SelfKind};\n use rustc_ast::ast::{EnumDef, Generics, StructField, TraitRef, Ty, TyKind, Variant, VariantData};\n-use rustc_ast::ast::{FnHeader, ForeignItem, PathSegment, Visibility, VisibilityKind};\n+use rustc_ast::ast::{FnHeader, ForeignItem, Path, PathSegment, Visibility, VisibilityKind};\n use rustc_ast::ast::{MacArgs, MacCall, MacDelimiter};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n@@ -1262,6 +1262,25 @@ impl<'a> Parser<'a> {\n                     sp,\n                     &format!(\"expected `,`, or `}}`, found {}\", super::token_descr(&self.token)),\n                 );\n+\n+                // Try to recover extra trailing angle brackets\n+                let mut recovered = false;\n+                if let TyKind::Path(_, Path { segments, .. }) = &a_var.ty.kind {\n+                    if let Some(last_segment) = segments.last() {\n+                        recovered = self.check_trailing_angle_brackets(\n+                            last_segment,\n+                            &[&token::Comma, &token::CloseDelim(token::Brace)],\n+                        );\n+                        if recovered {\n+                            // Handle a case like `Vec<u8>>,` where we can continue parsing fields\n+                            // after the comma\n+                            self.eat(&token::Comma);\n+                            // `check_trailing_angle_brackets` already emitted a nicer error\n+                            err.cancel();\n+                        }\n+                    }\n+                }\n+\n                 if self.token.is_ident() {\n                     // This is likely another field; emit the diagnostic and keep going\n                     err.span_suggestion(\n@@ -1271,6 +1290,14 @@ impl<'a> Parser<'a> {\n                         Applicability::MachineApplicable,\n                     );\n                     err.emit();\n+                    recovered = true;\n+                }\n+\n+                if recovered {\n+                    // Make sure an error was emitted (either by recovering an angle bracket,\n+                    // or by finding an identifier as the next token), since we're\n+                    // going to continue parsing\n+                    assert!(self.sess.span_diagnostic.has_errors());\n                 } else {\n                     return Err(err);\n                 }\n@@ -1780,7 +1807,7 @@ impl<'a> Parser<'a> {\n \n     fn is_named_param(&self) -> bool {\n         let offset = match self.token.kind {\n-            token::Interpolated(ref nt, _) => match **nt {\n+            token::Interpolated(ref nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             },"}, {"sha": "7811d5fb741b27d946b6ce57c6856d8d2b4977d5", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -54,7 +54,7 @@ enum BlockMode {\n #[macro_export]\n macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident, |$x:ident| $e:expr) => {\n-        if let token::Interpolated(nt, _) = &$p.token.kind {\n+        if let token::Interpolated(nt) = &$p.token.kind {\n             if let token::$constructor(x) = &**nt {\n                 let $x = x.clone();\n                 $p.bump();\n@@ -69,7 +69,7 @@ macro_rules! maybe_whole {\n macro_rules! maybe_recover_from_interpolated_ty_qpath {\n     ($self: expr, $allow_qpath_recovery: expr) => {\n         if $allow_qpath_recovery && $self.look_ahead(1, |t| t == &token::ModSep) {\n-            if let token::Interpolated(nt, _) = &$self.token.kind {\n+            if let token::Interpolated(nt) = &$self.token.kind {\n                 if let token::NtTy(ty) = &**nt {\n                     let ty = ty.clone();\n                     $self.bump();\n@@ -922,7 +922,7 @@ impl<'a> Parser<'a> {\n                 if self.eat(&token::Eq) {\n                     let eq_span = self.prev_token.span;\n                     let mut is_interpolated_expr = false;\n-                    if let token::Interpolated(nt, _) = &self.token.kind {\n+                    if let token::Interpolated(nt) = &self.token.kind {\n                         if let token::NtExpr(..) = **nt {\n                             is_interpolated_expr = true;\n                         }"}, {"sha": "6603d0afc0248d6cf52ad3d147c3cf8a05d95d7d", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -515,7 +515,7 @@ impl<'a> Parser<'a> {\n         self.recover_additional_muts();\n \n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n-        if let token::Interpolated(ref nt, _) = self.token.kind {\n+        if let token::Interpolated(ref nt) = self.token.kind {\n             if let token::NtPat(_) = **nt {\n                 self.expected_ident_found().emit();\n             }"}, {"sha": "67e9b3af4a8cfad21ddb0ba0a9712a73db25f30f", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -169,7 +169,7 @@ impl<'a> Parser<'a> {\n                 // `PathStyle::Expr` is only provided at the root invocation and never in\n                 // `parse_path_segment` to recurse and therefore can be checked to maintain\n                 // this invariant.\n-                self.check_trailing_angle_brackets(&segment, token::ModSep);\n+                self.check_trailing_angle_brackets(&segment, &[&token::ModSep]);\n             }\n             segments.push(segment);\n "}, {"sha": "0326591a931f5e3984d6859c585750b43c230ec6", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -146,6 +146,28 @@ impl LanguageItemCollector<'tcx> {\n                             ));\n                         }\n                     }\n+                    let mut note_def = |which, def_id: DefId| {\n+                        let crate_name = self.tcx.crate_name(def_id.krate);\n+                        let note = if def_id.is_local() {\n+                            format!(\"{} definition in the local crate (`{}`)\", which, crate_name)\n+                        } else {\n+                            let paths: Vec<_> = self\n+                                .tcx\n+                                .crate_extern_paths(def_id.krate)\n+                                .iter()\n+                                .map(|p| p.display().to_string())\n+                                .collect();\n+                            format!(\n+                                \"{} definition in `{}` loaded from {}\",\n+                                which,\n+                                crate_name,\n+                                paths.join(\", \")\n+                            )\n+                        };\n+                        err.note(&note);\n+                    };\n+                    note_def(\"first\", original_def_id);\n+                    note_def(\"second\", item_def_id);\n                 }\n                 err.emit();\n             }"}, {"sha": "bca65c63e91986c476325156d3efa231869746e8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1325,7 +1325,7 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt, _) = t.kind {\n+        if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ast::ExprKind::MacCall(..) = expr.kind {\n                     self.visit_invoc(expr.id);"}, {"sha": "32af920020ce6438ea15b5761d08627042d9d6bb", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -256,7 +256,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n     }\n \n     fn visit_token(&mut self, t: Token) {\n-        if let token::Interpolated(nt, _) = t.kind {\n+        if let token::Interpolated(nt) = t.kind {\n             if let token::NtExpr(ref expr) = *nt {\n                 if let ExprKind::MacCall(..) = expr.kind {\n                     self.visit_macro_invoc(expr.id);"}, {"sha": "ed5fd6dc7028b29b677916718de71aa87c06cb47", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -958,9 +958,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print the LLVM optimization passes being run (default: no)\"),\n     print_mono_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"print the result of the monomorphization collection pass\"),\n-    print_region_graph: bool = (false, parse_bool, [UNTRACKED],\n-        \"prints region inference graph. \\\n-        Use with RUST_REGION_GRAPH=help for more info (default: no)\"),\n     print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n         \"print layout information for each type encountered (default: no)\"),\n     profile: bool = (false, parse_bool, [TRACKED],"}, {"sha": "33f14e50edbf34282fa85aef1a11b854b879624f", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -401,6 +401,7 @@ symbols! {\n         infer_outlives_requirements,\n         infer_static_outlives_requirements,\n         inline,\n+        Input,\n         intel,\n         into_iter,\n         IntoIterator,\n@@ -589,6 +590,8 @@ symbols! {\n         proc_macro_mod,\n         proc_macro_non_items,\n         proc_macro_path_invoc,\n+        ProceduralMasqueradeDummyType,\n+        ProcMacroHack,\n         profiler_builtins,\n         profiler_runtime,\n         ptr_guaranteed_eq,"}, {"sha": "ad6e81ed3e8893610295f83885fcb680308f4312", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -429,6 +429,24 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             );\n                         }\n \n+                        let is_fn_trait = [\n+                            self.tcx.lang_items().fn_trait(),\n+                            self.tcx.lang_items().fn_mut_trait(),\n+                            self.tcx.lang_items().fn_once_trait(),\n+                        ]\n+                        .contains(&Some(trait_ref.def_id()));\n+                        let is_target_feature_fn =\n+                            if let ty::FnDef(def_id, _) = trait_ref.skip_binder().self_ty().kind {\n+                                !self.tcx.codegen_fn_attrs(def_id).target_features.is_empty()\n+                            } else {\n+                                false\n+                            };\n+                        if is_fn_trait && is_target_feature_fn {\n+                            err.note(\n+                                \"`#[target_feature]` functions do not implement the `Fn` traits\",\n+                            );\n+                        }\n+\n                         // Try to report a help message\n                         if !trait_ref.has_infer_types_or_consts()\n                             && self.predicate_can_apply(obligation.param_env, trait_ref)"}, {"sha": "597a7a58022cd7762297a449dddfb446d4abfccd", "filename": "src/librustc_trait_selection/traits/select/candidate_assembly.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -306,7 +306,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 candidates.ambiguous = true; // Could wind up being a fn() type.\n             }\n             // Provide an impl, but only for suitable `fn` pointers.\n-            ty::FnDef(..) | ty::FnPtr(_) => {\n+            ty::FnPtr(_) => {\n                 if let ty::FnSig {\n                     unsafety: hir::Unsafety::Normal,\n                     abi: Abi::Rust,\n@@ -317,6 +317,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     candidates.vec.push(FnPointerCandidate);\n                 }\n             }\n+            // Provide an impl for suitable functions, rejecting `#[target_feature]` functions (RFC 2396).\n+            ty::FnDef(def_id, _) => {\n+                if let ty::FnSig {\n+                    unsafety: hir::Unsafety::Normal,\n+                    abi: Abi::Rust,\n+                    c_variadic: false,\n+                    ..\n+                } = self_ty.fn_sig(self.tcx()).skip_binder()\n+                {\n+                    if self.tcx().codegen_fn_attrs(def_id).target_features.is_empty() {\n+                        candidates.vec.push(FnPointerCandidate);\n+                    }\n+                }\n+            }\n             _ => {}\n         }\n "}, {"sha": "4d031cb7a52e4c69253e4239cda3a78e9232e1cc", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -8,6 +8,7 @@\n //! extension traits of `std::os::$platform`.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![deny(unsafe_op_in_unsafe_fn)]\n \n use crate::ffi::OsString;\n use crate::fmt;\n@@ -666,7 +667,8 @@ impl Read for File {\n \n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n+        // SAFETY: Read is guaranteed to work on uninitialized memory\n+        unsafe { Initializer::nop() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -711,7 +713,8 @@ impl Read for &File {\n \n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n+        // SAFETY: Read is guaranteed to work on uninitialized memory\n+        unsafe { Initializer::nop() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "bd585d39c242fb226b21af7cfd37ea397d4c51cb", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -319,6 +319,7 @@\n #![cfg_attr(bootstrap, feature(track_caller))]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n+#![feature(unsafe_block_in_unsafe_fn)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_into_raw_parts)]"}, {"sha": "66db1a21736659d15fd909df19c8a9e4b22f23b0", "filename": "src/test/run-make/rustc-macro-dep-files/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Frun-make%2Frustc-macro-dep-files%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Frun-make%2Frustc-macro-dep-files%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustc-macro-dep-files%2Ffoo.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -7,6 +7,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(A)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"struct A ;\"));\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "395d9e21b3848a1b953baf4ef1a5429f1a003242", "filename": "src/test/ui/async-await/issues/issue-60674.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-60674.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,3 +1,3 @@\n-async fn f(mut x: u8) { }\n-async fn g((mut x, y, mut z): (u8, u8, u8)) { }\n-async fn g(mut x: u8, (a, mut b, c): (u8, u8, u8), y: u8) { }\n+async fn f(mut x : u8) { }\n+async fn g((mut x, y, mut z) : (u8, u8, u8)) { }\n+async fn g(mut x : u8, (a, mut b, c) : (u8, u8, u8), y : u8) { }"}, {"sha": "0d392ddcaedcc4f4a109d0b035e34830e605ed5e", "filename": "src/test/ui/const-generics/lazy-normalization/issue-71922.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.rs?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,19 +0,0 @@\n-#![feature(const_generics)]\n-//~^ WARN the feature `const_generics` is incomplete\n-trait Foo {}\n-\n-impl<const N: usize> Foo for [(); N] where Self: FooImpl<{ N == 0 }> {}\n-//~^ ERROR constant expression depends on a generic parameter\n-\n-trait FooImpl<const IS_ZERO: bool> {}\n-\n-impl FooImpl<{ 0u8 == 0u8 }> for [(); 0] {}\n-\n-impl<const N: usize> FooImpl<{ 0u8 != 0u8 }> for [(); N] {}\n-\n-fn foo<T: Foo>(_: T) {}\n-\n-fn main() {\n-    foo([]);\n-    foo([()]);\n-}"}, {"sha": "00917571e716d8bf1bc21c84da6ab89c21f9e37c", "filename": "src/test/ui/const-generics/lazy-normalization/issue-71922.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Flazy-normalization%2Fissue-71922.stderr?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,19 +0,0 @@\n-warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/issue-71922.rs:1:12\n-   |\n-LL | #![feature(const_generics)]\n-   |            ^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(incomplete_features)]` on by default\n-   = note: see issue #44580 <https://github.com/rust-lang/rust/issues/44580> for more information\n-\n-error: constant expression depends on a generic parameter\n-  --> $DIR/issue-71922.rs:5:50\n-   |\n-LL | impl<const N: usize> Foo for [(); N] where Self: FooImpl<{ N == 0 }> {}\n-   |                                                  ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: this may fail depending on what value the parameter takes\n-\n-error: aborting due to previous error; 1 warning emitted\n-"}, {"sha": "776ecedea7e7eef68cceec287d9d0365aa0c767e", "filename": "src/test/ui/duplicate_entry_error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fduplicate_entry_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fduplicate_entry_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fduplicate_entry_error.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,3 +1,4 @@\n+// normalize-stderr-test \"loaded from .*libstd-.*.rlib\" -> \"loaded from SYSROOT/libstd-*.rlib\"\n // note-pattern: first defined in crate `std`.\n \n // Test for issue #31788 and E0152"}, {"sha": "61cccf40ed8a5133526ea9658019b050c7f4c6a2", "filename": "src/test/ui/duplicate_entry_error.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fduplicate_entry_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fduplicate_entry_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fduplicate_entry_error.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,5 +1,5 @@\n error[E0152]: found duplicate lang item `panic_impl`\n-  --> $DIR/duplicate_entry_error.rs:10:1\n+  --> $DIR/duplicate_entry_error.rs:11:1\n    |\n LL | / fn panic_impl(info: &PanicInfo) -> ! {\n LL | |\n@@ -8,6 +8,8 @@ LL | | }\n    | |_^\n    |\n    = note: the lang item is first defined in crate `std` (which `duplicate_entry_error` depends on)\n+   = note: first definition in `std` loaded from SYSROOT/libstd-*.rlib\n+   = note: second definition in the local crate (`duplicate_entry_error`)\n \n error: aborting due to previous error\n "}, {"sha": "d716ca1a14fdf3cbfafb57a116ab03198fa576b9", "filename": "src/test/ui/error-codes/E0152.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0152.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,3 +1,4 @@\n+// normalize-stderr-test \"loaded from .*liballoc-.*.rlib\" -> \"loaded from SYSROOT/liballoc-*.rlib\"\n #![feature(lang_items)]\n \n #[lang = \"owned_box\"]"}, {"sha": "7445c2880af1c0a98e8b858439fa518a6cad7eb8", "filename": "src/test/ui/error-codes/E0152.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0152.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,10 +1,12 @@\n error[E0152]: found duplicate lang item `owned_box`\n-  --> $DIR/E0152.rs:4:1\n+  --> $DIR/E0152.rs:5:1\n    |\n LL | struct Foo;\n    | ^^^^^^^^^^^\n    |\n    = note: the lang item is first defined in crate `alloc` (which `std` depends on)\n+   = note: first definition in `alloc` loaded from SYSROOT/liballoc-*.rlib\n+   = note: second definition in the local crate (`E0152`)\n \n error: aborting due to previous error\n "}, {"sha": "4f90bd98c63e59ac39d064536c5b7e3ceab4b976", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-1.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,50 @@\n+#![allow(dead_code)]\n+\n+#![forbid(non_camel_case_types)]\n+#![feature(non_ascii_idents)]\n+\n+// Some scripts (e.g., hiragana) don't have a concept of\n+// upper/lowercase\n+\n+// 1. non_camel_case_types\n+\n+// Can start with non-lowercase letter\n+struct \u0398\u03c7;\n+struct \u30d2a;\n+\n+struct \u03c7a;\n+//~^ ERROR type `\u03c7a` should have an upper camel case name\n+\n+// If there's already leading or trailing underscores, they get trimmed before checking.\n+// This is fine:\n+struct _\u30d2b;\n+\n+// This is not:\n+struct __\u03c7a;\n+//~^ ERROR type `__\u03c7a` should have an upper camel case name\n+\n+// Besides this, we cannot have two continous underscores in the middle.\n+\n+struct \u5bf9__\u5426;\n+//~^ ERROR type `\u5bf9__\u5426` should have an upper camel case name\n+\n+struct \u30d2__\u03c7;\n+//~^ ERROR type `\u30d2__\u03c7` should have an upper camel case name\n+\n+// also cannot have lowercase letter next to a underscore.\n+// so this triggers the lint:\n+\n+struct Hello_\u4f60\u597d;\n+//~^ ERROR type `Hello_\u4f60\u597d` should have an upper camel case name\n+\n+struct Hello_World;\n+//~^ ERROR type `Hello_World` should have an upper camel case name\n+\n+struct \u4f60_\u04df;\n+//~^ ERROR type `\u4f60_\u04df` should have an upper camel case name\n+\n+// and this is ok:\n+\n+struct \u4f60_\u597d;\n+\n+fn main() {}"}, {"sha": "371002656591c133a642f5678d7df7c20c3cbbc1", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-1.stderr", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-1.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,50 @@\n+error: type `\u03c7a` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:15:8\n+   |\n+LL | struct \u03c7a;\n+   |        ^^ help: convert the identifier to upper camel case: `\u03a7a`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:3:11\n+   |\n+LL | #![forbid(non_camel_case_types)]\n+   |           ^^^^^^^^^^^^^^^^^^^^\n+\n+error: type `__\u03c7a` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:23:8\n+   |\n+LL | struct __\u03c7a;\n+   |        ^^^^ help: convert the identifier to upper camel case: `\u03a7a`\n+\n+error: type `\u5bf9__\u5426` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:28:8\n+   |\n+LL | struct \u5bf9__\u5426;\n+   |        ^^^^^^ help: convert the identifier to upper camel case: `\u5bf9_\u5426`\n+\n+error: type `\u30d2__\u03c7` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:31:8\n+   |\n+LL | struct \u30d2__\u03c7;\n+   |        ^^^^^ help: convert the identifier to upper camel case: `\u30d2\u03a7`\n+\n+error: type `Hello_\u4f60\u597d` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:37:8\n+   |\n+LL | struct Hello_\u4f60\u597d;\n+   |        ^^^^^^^^^^ help: convert the identifier to upper camel case: `Hello\u4f60\u597d`\n+\n+error: type `Hello_World` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:40:8\n+   |\n+LL | struct Hello_World;\n+   |        ^^^^^^^^^^^ help: convert the identifier to upper camel case: `HelloWorld`\n+\n+error: type `\u4f60_\u04df` should have an upper camel case name\n+  --> $DIR/lint-nonstandard-style-unicode-1.rs:43:8\n+   |\n+LL | struct \u4f60_\u04df;\n+   |        ^^^^ help: convert the identifier to upper camel case: `\u4f60\u04de`\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "813e0ea5c5708b76c7578aabeb084005bc03aa40", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,30 @@\n+#![allow(dead_code)]\n+\n+#![forbid(non_snake_case)]\n+#![feature(non_ascii_idents)]\n+\n+// Some scripts (e.g., hiragana) don't have a concept of\n+// upper/lowercase\n+\n+// 2. non_snake_case\n+\n+// Can only use non-uppercase letters.\n+// So this works:\n+\n+fn \u7f16\u7a0b() {}\n+\n+// but this doesn't:\n+\n+fn \u0426() {}\n+//~^ ERROR function `\u0426` should have a snake case name\n+\n+// besides this, you cannot use continous underscores in the middle\n+\n+fn \u5206__\u9694() {}\n+//~^ ERROR function `\u5206__\u9694` should have a snake case name\n+\n+// but you can use them both at the beginning and at the end.\n+\n+fn _______\u4e0d_\u8fde_\u7eed_\u7684_\u5b58_\u5728_______() {}\n+\n+fn main() {}"}, {"sha": "0b309e315a4117dca42714e5fe5f8fa3b1d42f23", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-2.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,20 @@\n+error: function `\u0426` should have a snake case name\n+  --> $DIR/lint-nonstandard-style-unicode-2.rs:18:4\n+   |\n+LL | fn \u0426() {}\n+   |    ^ help: convert the identifier to snake case: `\u0446`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-nonstandard-style-unicode-2.rs:3:11\n+   |\n+LL | #![forbid(non_snake_case)]\n+   |           ^^^^^^^^^^^^^^\n+\n+error: function `\u5206__\u9694` should have a snake case name\n+  --> $DIR/lint-nonstandard-style-unicode-2.rs:23:4\n+   |\n+LL | fn \u5206__\u9694() {}\n+   |    ^^^^^^ help: convert the identifier to snake case: `\u5206_\u9694`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "b17c2de39a0c0e7b1963d50e6580a4a8b4f9e8f5", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-3.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,25 @@\n+#![allow(dead_code)]\n+\n+#![forbid(non_upper_case_globals)]\n+#![feature(non_ascii_idents)]\n+\n+// Some scripts (e.g., hiragana) don't have a concept of\n+// upper/lowercase\n+\n+// 3. non_upper_case_globals\n+\n+// Can only use non-lowercase letters.\n+// So this works:\n+\n+static \u30e9: usize = 0;\n+\n+// but this doesn't:\n+\n+static \u03c4\u03b5\u03c7: f32 = 3.14159265;\n+//~^ ERROR static variable `\u03c4\u03b5\u03c7` should have an upper case name\n+\n+// This has no limit at all on underscore usages.\n+\n+static __\u5bc6__\u5c01__\u7ebf__\u5185__\u7981__\u6b62__\u7b54__\u9898__: bool = true;\n+\n+fn main() {}"}, {"sha": "44bd5ad55ff5c8c702802d39a4a98bb69354eb89", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode-3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode-3.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,14 @@\n+error: static variable `\u03c4\u03b5\u03c7` should have an upper case name\n+  --> $DIR/lint-nonstandard-style-unicode-3.rs:18:8\n+   |\n+LL | static \u03c4\u03b5\u03c7: f32 = 3.14159265;\n+   |        ^^^ help: convert the identifier to upper case: `\u03a4\u0395\u03a7`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-nonstandard-style-unicode-3.rs:3:11\n+   |\n+LL | #![forbid(non_upper_case_globals)]\n+   |           ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9f16cb20fb32cf029024a160814a53e7fd0ecd6e", "filename": "src/test/ui/lint/lint-nonstandard-style-unicode.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-nonstandard-style-unicode.rs?ref=9491f18c5de3ff1c4bf9c3fdacf52d9859e26f7c", "patch": "@@ -1,16 +0,0 @@\n-// check-pass\n-\n-#![allow(dead_code)]\n-\n-#![forbid(non_camel_case_types)]\n-#![forbid(non_upper_case_globals)]\n-#![feature(non_ascii_idents)]\n-\n-// Some scripts (e.g., hiragana) don't have a concept of\n-// upper/lowercase\n-\n-struct \u30d2;\n-\n-static \u30e9: usize = 0;\n-\n-pub fn main() {}"}, {"sha": "9de39e9b56c986da89bc8365f0ffa788bc68588e", "filename": "src/test/ui/macros/doc-comment.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fmacros%2Fdoc-comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fmacros%2Fdoc-comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fdoc-comment.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,25 @@\n+// check-pass\n+// Tests that we properly handle a nested macro expansion\n+// involving a `#[doc]` attribute\n+#![deny(missing_docs)]\n+//! Crate docs\n+\n+macro_rules! doc_comment {\n+    ($x:expr, $($tt:tt)*) => {\n+        #[doc = $x]\n+        $($tt)*\n+    }\n+}\n+\n+macro_rules! make_comment {\n+    () => {\n+        doc_comment!(\"Function docs\",\n+            pub fn bar() {}\n+        );\n+    }\n+}\n+\n+\n+make_comment!();\n+\n+fn main() {}"}, {"sha": "6183c886cfac7194272c611349d46e9a15242061", "filename": "src/test/ui/panic-handler/panic-handler-std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fpanic-handler%2Fpanic-handler-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fpanic-handler%2Fpanic-handler-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-handler%2Fpanic-handler-std.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,3 +1,4 @@\n+// normalize-stderr-test \"loaded from .*libstd-.*.rlib\" -> \"loaded from SYSROOT/libstd-*.rlib\"\n // error-pattern: found duplicate lang item `panic_impl`\n \n "}, {"sha": "bb656089bcaffb0e20f3754722c2fd285dcda829", "filename": "src/test/ui/panic-handler/panic-handler-std.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fpanic-handler%2Fpanic-handler-std.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fpanic-handler%2Fpanic-handler-std.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanic-handler%2Fpanic-handler-std.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,15 +1,17 @@\n error[E0152]: found duplicate lang item `panic_impl`\n-  --> $DIR/panic-handler-std.rs:7:1\n+  --> $DIR/panic-handler-std.rs:8:1\n    |\n LL | / fn panic(info: PanicInfo) -> ! {\n LL | |     loop {}\n LL | | }\n    | |_^\n    |\n    = note: the lang item is first defined in crate `std` (which `panic_handler_std` depends on)\n+   = note: first definition in `std` loaded from SYSROOT/libstd-*.rlib\n+   = note: second definition in the local crate (`panic_handler_std`)\n \n error: argument should be `&PanicInfo`\n-  --> $DIR/panic-handler-std.rs:7:16\n+  --> $DIR/panic-handler-std.rs:8:16\n    |\n LL | fn panic(info: PanicInfo) -> ! {\n    |                ^^^^^^^^^"}, {"sha": "5e0e00bcb5e8d3eed1c34a9cd6c73d38e4a9eb2f", "filename": "src/test/ui/parser/recover-field-extra-angle-brackets.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fparser%2Frecover-field-extra-angle-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fparser%2Frecover-field-extra-angle-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-field-extra-angle-brackets.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,14 @@\n+// Tests that we recover from extra trailing angle brackets\n+// in a struct field\n+\n+struct BadStruct {\n+    first: Vec<u8>>, //~ ERROR unmatched angle bracket\n+    second: bool\n+}\n+\n+fn bar(val: BadStruct) {\n+    val.first;\n+    val.second;\n+}\n+\n+fn main() {}"}, {"sha": "318e55f6e99ac993f06b32aeb00e457ca16a4569", "filename": "src/test/ui/parser/recover-field-extra-angle-brackets.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fparser%2Frecover-field-extra-angle-brackets.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fparser%2Frecover-field-extra-angle-brackets.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-field-extra-angle-brackets.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,8 @@\n+error: unmatched angle bracket\n+  --> $DIR/recover-field-extra-angle-brackets.rs:5:19\n+   |\n+LL |     first: Vec<u8>>,\n+   |                   ^ help: remove extra angle bracket\n+\n+error: aborting due to previous error\n+"}, {"sha": "2f0054cc14aa6454005f2889292acc42824b2c9f", "filename": "src/test/ui/proc-macro/auxiliary/attr-cfg.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-cfg.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -11,11 +11,9 @@ use proc_macro::TokenStream;\n pub fn attr_cfg(args: TokenStream, input: TokenStream) -> TokenStream {\n     let input_str = input.to_string();\n \n-    assert_eq!(input_str, \"fn outer() -> u8 {\n-    #[cfg(foo)]\n-    fn inner() -> u8 { 1 }\n-    #[cfg(bar)]\n-    fn inner() -> u8 { 2 }\n+    assert_eq!(input_str, \"fn outer() -> u8\n+{\n+    #[cfg(foo)] fn inner() -> u8 { 1 } #[cfg(bar)] fn inner() -> u8 { 2 }\n     inner()\n }\");\n "}, {"sha": "e056bd32d2d0e9c0045e0dcb8e0fc81460963175", "filename": "src/test/ui/proc-macro/auxiliary/attr-stmt-expr-rpass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr-rpass.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,14 +10,14 @@ use proc_macro::TokenStream;\n #[proc_macro_attribute]\n pub fn expect_let(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\";\");\n+    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\" ;\");\n     item\n }\n \n #[proc_macro_attribute]\n pub fn expect_print_stmt(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string);\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string) ;\");\n     item\n }\n \n@@ -31,7 +31,7 @@ pub fn expect_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n #[proc_macro_attribute]\n pub fn expect_print_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string)\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string)\");\n     item\n }\n "}, {"sha": "213f999e9d0eaa080783f80d99fec8f9258ddcda", "filename": "src/test/ui/proc-macro/auxiliary/attr-stmt-expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fattr-stmt-expr.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,14 +10,14 @@ use proc_macro::TokenStream;\n #[proc_macro_attribute]\n pub fn expect_let(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\";\");\n+    assert_eq!(item.to_string(), \"let string = \\\"Hello, world!\\\" ;\");\n     item\n }\n \n #[proc_macro_attribute]\n pub fn expect_print_stmt(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string);\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string) ;\");\n     item\n }\n \n@@ -31,7 +31,7 @@ pub fn expect_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n #[proc_macro_attribute]\n pub fn expect_print_expr(attr: TokenStream, item: TokenStream) -> TokenStream {\n     assert!(attr.to_string().is_empty());\n-    assert_eq!(item.to_string(), \"println!(\\\"{}\\\", string)\");\n+    assert_eq!(item.to_string(), \"println ! (\\\"{}\\\", string)\");\n     item\n }\n "}, {"sha": "79a3864bf991d8f31144a71b6fae5ca299853e99", "filename": "src/test/ui/proc-macro/auxiliary/derive-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-a.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,6 +10,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(A)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"struct A ;\"));\n     \"\".parse().unwrap()\n }"}, {"sha": "207b7fd3203601eb7fee5be0deb814aaf24fe870", "filename": "src/test/ui/proc-macro/auxiliary/derive-atob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-atob.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,6 +10,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"struct A;\");\n+    assert_eq!(input, \"struct A ;\");\n     \"struct B;\".parse().unwrap()\n }"}, {"sha": "641a95f78c112a92d66c81388ca45ce88f4e1e5b", "filename": "src/test/ui/proc-macro/auxiliary/derive-b-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-b-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-b-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-b-rpass.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,7 +10,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(B, attributes(B, C))]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"#[B[arbitrary tokens]]\"));\n+    assert!(input.contains(\"#[B [arbitrary tokens]]\"));\n     assert!(input.contains(\"struct B {\"));\n     assert!(input.contains(\"#[C]\"));\n     \"\".parse().unwrap()"}, {"sha": "2efe5a9134054de27130795bb380866ad91e49d6", "filename": "src/test/ui/proc-macro/auxiliary/derive-ctod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-ctod.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,6 +10,6 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(CToD)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert_eq!(input, \"struct C;\");\n+    assert_eq!(input, \"struct C ;\");\n     \"struct D;\".parse().unwrap()\n }"}, {"sha": "7598d632cb6d57f396db1019b5e8784ed73b2b98", "filename": "src/test/ui/proc-macro/auxiliary/derive-same-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-same-struct.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -10,12 +10,12 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(AToB)]\n pub fn derive1(input: TokenStream) -> TokenStream {\n     println!(\"input1: {:?}\", input.to_string());\n-    assert_eq!(input.to_string(), \"struct A;\");\n+    assert_eq!(input.to_string(), \"struct A ;\");\n     \"#[derive(BToC)] struct B;\".parse().unwrap()\n }\n \n #[proc_macro_derive(BToC)]\n pub fn derive2(input: TokenStream) -> TokenStream {\n-    assert_eq!(input.to_string(), \"struct B;\");\n+    assert_eq!(input.to_string(), \"struct B ;\");\n     \"struct C;\".parse().unwrap()\n }"}, {"sha": "05883170c6c48006c771e8e4b327272a9c90f1ba", "filename": "src/test/ui/proc-macro/auxiliary/derive-union.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fderive-union.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -12,7 +12,7 @@ pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n     assert!(input.contains(\"#[repr(C)]\"));\n     assert!(input.contains(\"union Test {\"));\n-    assert!(input.contains(\"a: u8,\"));\n+    assert!(input.contains(\"a : u8,\"));\n     assert!(input.contains(\"}\"));\n     \"\".parse().unwrap()\n }"}, {"sha": "99eb4e3754672e05e01b48f86eade2eb5aaf8e59", "filename": "src/test/ui/proc-macro/auxiliary/double.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdouble.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdouble.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fdouble.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,15 +1,16 @@\n // force-host\n // no-prefer-dynamic\n \n+#![feature(proc_macro_quote)]\n+\n #![crate_type = \"proc-macro\"]\n \n extern crate proc_macro;\n-\n-use proc_macro::TokenStream;\n+use proc_macro::*;\n \n // Outputs another copy of the struct.  Useful for testing the tokens\n // seen by the proc_macro.\n #[proc_macro_derive(Double)]\n pub fn derive(input: TokenStream) -> TokenStream {\n-    format!(\"mod foo {{ {} }}\", input.to_string()).parse().unwrap()\n+    quote!(mod foo { $input })\n }"}, {"sha": "d779d57af14c7a12ccde94871c96176a69cad71e", "filename": "src/test/ui/proc-macro/auxiliary/expand-with-a-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fexpand-with-a-macro.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -11,7 +11,7 @@ use proc_macro::TokenStream;\n #[proc_macro_derive(A)]\n pub fn derive(input: TokenStream) -> TokenStream {\n     let input = input.to_string();\n-    assert!(input.contains(\"struct A;\"));\n+    assert!(input.contains(\"struct A ;\"));\n     r#\"\n         impl A {\n             fn a(&self) {"}, {"sha": "54e3d7857267b9efdf23520444b8c6bfe31fa068", "filename": "src/test/ui/proc-macro/auxiliary/meta-delim.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fmeta-delim.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,12 @@\n+macro_rules! produce_it {\n+    ($dollar_one:tt $foo:ident $my_name:ident) => {\n+        #[macro_export]\n+        macro_rules! meta_delim {\n+            ($dollar_one ($dollar_one $my_name:ident)*) => {\n+                stringify!($dollar_one ($dollar_one $my_name)*)\n+            }\n+        }\n+    }\n+}\n+\n+produce_it!($my_name name);"}, {"sha": "52ebe8e7fb2ef1d8906f00d0c2389853cd8f53ed", "filename": "src/test/ui/proc-macro/auxiliary/nested-macro-rules.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Fnested-macro-rules.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,15 @@\n+pub struct FirstStruct;\n+\n+#[macro_export]\n+macro_rules! outer_macro {\n+    ($name:ident) => {\n+        #[macro_export]\n+        macro_rules! inner_macro {\n+            ($wrapper:ident) => {\n+                $wrapper!($name)\n+            }\n+        }\n+    }\n+}\n+\n+outer_macro!(FirstStruct);"}, {"sha": "8682ebdd109f02f8d7c2b405abcb7a258225d320", "filename": "src/test/ui/proc-macro/auxiliary/test-macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fauxiliary%2Ftest-macros.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -101,6 +101,12 @@ pub fn print_bang(input: TokenStream) -> TokenStream {\n     print_helper(input, \"BANG\")\n }\n \n+#[proc_macro]\n+pub fn print_bang_consume(input: TokenStream) -> TokenStream {\n+    print_helper(input, \"BANG\");\n+    TokenStream::new()\n+}\n+\n #[proc_macro_attribute]\n pub fn print_attr(_: TokenStream, input: TokenStream) -> TokenStream {\n     print_helper(input, \"ATTR\")"}, {"sha": "7478d9741409bb8e6f52896bfa41a2831e8df69c", "filename": "src/test/ui/proc-macro/derive-same-struct.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fderive-same-struct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fderive-same-struct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-same-struct.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1 +1 @@\n-input1: \"struct A;\"\n+input1: \"struct A ;\""}, {"sha": "5d93144b445530ddf79b355c2ca14a278179ebd2", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -38,8 +38,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A($crate :: S) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "e4212377626ca7fdccc575b5388a59ac039dee1c", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,5 +1,4 @@\n-PRINT-ATTR INPUT (DISPLAY): struct A(identity!(crate :: S));\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A(identity ! ($crate :: S)) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A(identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -54,8 +53,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct B(identity ! ($crate :: S)) ;\n+PRINT-ATTR INPUT (DISPLAY): struct B(identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "8a7406b1a3d134350ed110566dc505911311d0dc", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -38,8 +38,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A($crate :: S) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -79,8 +78,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #3 bytes(LO..HI),\n     },\n ]\n-PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D($crate :: S) ;\n+PRINT-DERIVE INPUT (DISPLAY): struct D($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -160,8 +158,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #13 bytes(LO..HI),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n-PRINT-ATTR RE-COLLECTED (DISPLAY): struct A($crate :: S) ;\n+PRINT-ATTR INPUT (DISPLAY): struct A($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n@@ -201,8 +198,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #13 bytes(LO..HI),\n     },\n ]\n-PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D($crate :: S) ;\n+PRINT-DERIVE INPUT (DISPLAY): struct D($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "ee988d48b461d30d1e76bd50d72e1bd35f0f7877", "filename": "src/test/ui/proc-macro/input-interpolated.stdout", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Finput-interpolated.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Finput-interpolated.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Finput-interpolated.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -1,5 +1,4 @@\n PRINT-BANG INPUT (DISPLAY): A\n-PRINT-BANG RE-COLLECTED (DISPLAY):  A \n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Group {\n         delimiter: None,\n@@ -12,8 +11,7 @@ PRINT-BANG INPUT (DEBUG): TokenStream [\n         span: #3 bytes(269..271),\n     },\n ]\n-PRINT-ATTR INPUT (DISPLAY): const A: u8 = 0;\n-PRINT-ATTR RE-COLLECTED (DISPLAY): const A : u8 = 0 ;\n+PRINT-ATTR INPUT (DISPLAY): const A : u8 = 0 ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"const\",\n@@ -49,9 +47,7 @@ PRINT-ATTR INPUT (DEBUG): TokenStream [\n         span: #0 bytes(0..0),\n     },\n ]\n-PRINT-DERIVE INPUT (DISPLAY): struct A {\n-}\n-PRINT-DERIVE RE-COLLECTED (DISPLAY): struct A { }\n+PRINT-DERIVE INPUT (DISPLAY): struct A { }\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\","}, {"sha": "964291bc6784c822c095502aa87ad0e916ef2563", "filename": "src/test/ui/proc-macro/meta-delim.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmeta-delim.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,12 @@\n+// aux-build:meta-delim.rs\n+// edition:2018\n+// run-pass\n+\n+// Tests that we can properly deserialize a macro with strange delimiters\n+// See https://github.com/rust-lang/rust/pull/73569#issuecomment-650860457\n+\n+extern crate meta_delim;\n+\n+fn main() {\n+    assert_eq!(\"a bunch of idents\", meta_delim::meta_delim!(a bunch of idents));\n+}"}, {"sha": "2f8ef20232782d663d91dc669e93d0e13580855e", "filename": "src/test/ui/proc-macro/nested-macro-rules.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+// aux-build:nested-macro-rules.rs\n+// aux-build:test-macros.rs\n+// compile-flags: -Z span-debug\n+// edition:2018\n+\n+extern crate nested_macro_rules;\n+extern crate test_macros;\n+\n+use test_macros::print_bang;\n+\n+use nested_macro_rules::FirstStruct;\n+struct SecondStruct;\n+\n+fn main() {\n+    nested_macro_rules::inner_macro!(print_bang);\n+\n+    nested_macro_rules::outer_macro!(SecondStruct);\n+    inner_macro!(print_bang);\n+}"}, {"sha": "e4cfe020324b8b9090f1856e8c3ebad95b2766af", "filename": "src/test/ui/proc-macro/nested-macro-rules.stdout", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnested-macro-rules.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,26 @@\n+PRINT-BANG INPUT (DISPLAY): FirstStruct\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"FirstStruct\",\n+                span: $DIR/auxiliary/nested-macro-rules.rs:15:14: 15:25 (#3),\n+            },\n+        ],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:9:27: 9:32 (#3),\n+    },\n+]\n+PRINT-BANG INPUT (DISPLAY): SecondStruct\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Ident {\n+                ident: \"SecondStruct\",\n+                span: $DIR/nested-macro-rules.rs:18:38: 18:50 (#9),\n+            },\n+        ],\n+        span: $DIR/auxiliary/nested-macro-rules.rs:9:27: 9:32 (#8),\n+    },\n+]"}, {"sha": "cfcd4c0d2a658071b66780086b6a00c50a449d98", "filename": "src/test/ui/proc-macro/nodelim-groups.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+// aux-build:test-macros.rs\n+// compile-flags: -Z span-debug\n+// edition:2018\n+//\n+// Tests the pretty-printing behavior of inserting `NoDelim` groups\n+\n+extern crate test_macros;\n+use test_macros::print_bang_consume;\n+\n+macro_rules! expand_it {\n+    (($val1:expr) ($val2:expr)) => { expand_it!($val1 + $val2) };\n+    ($val:expr) => { print_bang_consume!(\"hi\" $val (1 + 1)) };\n+}\n+\n+fn main() {\n+    expand_it!(1 + (25) + 1);\n+    expand_it!((\"hello\".len()) (\"world\".len()));\n+}"}, {"sha": "75a189a9fcdeab28073086e5282a7de052ef1cae", "filename": "src/test/ui/proc-macro/nodelim-groups.stdout", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnodelim-groups.stdout?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,156 @@\n+PRINT-BANG INPUT (DISPLAY): \"hi\" 1 + (25) + 1 (1 + 1)\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Literal {\n+        kind: Str,\n+        symbol: \"hi\",\n+        suffix: None,\n+        span: $DIR/nodelim-groups.rs:13:42: 13:46 (#3),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:17:16: 17:17 (#0),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:17:18: 17:19 (#0),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [\n+                    Literal {\n+                        kind: Integer,\n+                        symbol: \"25\",\n+                        suffix: None,\n+                        span: $DIR/nodelim-groups.rs:17:21: 17:23 (#0),\n+                    },\n+                ],\n+                span: $DIR/nodelim-groups.rs:17:20: 17:24 (#0),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:17:25: 17:26 (#0),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:17:27: 17:28 (#0),\n+            },\n+        ],\n+        span: $DIR/nodelim-groups.rs:13:47: 13:51 (#3),\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:13:53: 13:54 (#3),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:13:55: 13:56 (#3),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:13:57: 13:58 (#3),\n+            },\n+        ],\n+        span: $DIR/nodelim-groups.rs:13:52: 13:59 (#3),\n+    },\n+]\n+PRINT-BANG INPUT (DISPLAY): \"hi\" \"hello\".len() + \"world\".len() (1 + 1)\n+PRINT-BANG RE-COLLECTED (DISPLAY): \"hi\" \"hello\" . len() + \"world\" . len() (1 + 1)\n+PRINT-BANG INPUT (DEBUG): TokenStream [\n+    Literal {\n+        kind: Str,\n+        symbol: \"hi\",\n+        suffix: None,\n+        span: $DIR/nodelim-groups.rs:13:42: 13:46 (#8),\n+    },\n+    Group {\n+        delimiter: None,\n+        stream: TokenStream [\n+            Literal {\n+                kind: Str,\n+                symbol: \"hello\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Punct {\n+                ch: '.',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Ident {\n+                ident: \"len\",\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [],\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Literal {\n+                kind: Str,\n+                symbol: \"world\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Punct {\n+                ch: '.',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Ident {\n+                ident: \"len\",\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+            Group {\n+                delimiter: Parenthesis,\n+                stream: TokenStream [],\n+                span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+            },\n+        ],\n+        span: $DIR/nodelim-groups.rs:13:47: 13:51 (#8),\n+    },\n+    Group {\n+        delimiter: Parenthesis,\n+        stream: TokenStream [\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:13:53: 13:54 (#8),\n+            },\n+            Punct {\n+                ch: '+',\n+                spacing: Alone,\n+                span: $DIR/nodelim-groups.rs:13:55: 13:56 (#8),\n+            },\n+            Literal {\n+                kind: Integer,\n+                symbol: \"1\",\n+                suffix: None,\n+                span: $DIR/nodelim-groups.rs:13:57: 13:58 (#8),\n+            },\n+        ],\n+        span: $DIR/nodelim-groups.rs:13:52: 13:59 (#8),\n+    },\n+]"}, {"sha": "2a172c8458d71462493c1cb4a7b26d03c3e231b2", "filename": "src/test/ui/rfc-2565-param-attrs/auxiliary/param-attrs.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2565-param-attrs%2Fauxiliary%2Fparam-attrs.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -17,28 +17,27 @@ macro_rules! checker {\n     }\n }\n \n-checker!(attr_extern, r#\"extern \"C\" {\n-    fn ffi(#[a1] arg1: i32, #[a2] ...);\n-}\"#);\n-checker!(attr_extern_cvar, r#\"unsafe extern \"C\" fn cvar(arg1: i32, #[a1] mut args: ...) { }\"#);\n-checker!(attr_alias, \"type Alias = fn(#[a1] u8, #[a2] ...);\");\n-checker!(attr_free, \"fn free(#[a1] arg1: u8) { let lam = |#[a2] W(x), #[a3] y| (); }\");\n-checker!(attr_inherent_1, \"fn inherent1(#[a1] self, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_2, \"fn inherent2(#[a1] &self, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_3, \"fn inherent3<'a>(#[a1] &'a mut self, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_4, \"fn inherent4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8) { }\");\n-checker!(attr_inherent_issue_64682, \"fn inherent5(#[a1] #[a2] arg1: u8, #[a3] arg2: u8) { }\");\n-checker!(attr_trait_1, \"fn trait1(#[a1] self, #[a2] arg1: u8);\");\n-checker!(attr_trait_2, \"fn trait2(#[a1] &self, #[a2] arg1: u8);\");\n-checker!(attr_trait_3, \"fn trait3<'a>(#[a1] &'a mut self, #[a2] arg1: u8);\");\n-checker!(attr_trait_4, \"fn trait4<'a>(#[a1] self: Box<Self>, #[a2] arg1: u8, #[a3] Vec<u8>);\");\n-checker!(attr_trait_issue_64682, \"fn trait5(#[a1] #[a2] arg1: u8, #[a3] arg2: u8);\");\n-checker!(rename_params, r#\"impl Foo {\n-    fn hello(#[angery(true)] a: i32, #[a2] b: i32, #[what = \"how\"] c: u32) { }\n-    fn hello2(#[a1] #[a2] a: i32, #[what = \"how\"] b: i32,\n-              #[angery(true)] c: u32) {\n-    }\n-    fn hello_self(#[a1] #[a2] &self, #[a1] #[a2] a: i32,\n-                  #[what = \"how\"] b: i32, #[angery(true)] c: u32) {\n-    }\n+checker!(attr_extern, r#\"extern \"C\" { fn ffi(#[a1] arg1 : i32, #[a2] ...) ; }\"#);\n+checker!(attr_extern_cvar, r#\"unsafe extern \"C\" fn cvar(arg1 : i32, #[a1] mut args : ...) { }\"#);\n+checker!(attr_alias, \"type Alias = fn(#[a1] u8, #[a2] ...) ;\");\n+checker!(attr_free, \"fn free(#[a1] arg1 : u8) { let lam = | #[a2] W(x), #[a3] y | () ; }\");\n+checker!(attr_inherent_1, \"fn inherent1(#[a1] self, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_2, \"fn inherent2(#[a1] & self, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_3, \"fn inherent3 < 'a > (#[a1] & 'a mut self, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_4, \"fn inherent4 < 'a > (#[a1] self : Box < Self >, #[a2] arg1 : u8) { }\");\n+checker!(attr_inherent_issue_64682, \"fn inherent5(#[a1] #[a2] arg1 : u8, #[a3] arg2 : u8) { }\");\n+checker!(attr_trait_1, \"fn trait1(#[a1] self, #[a2] arg1 : u8) ;\");\n+checker!(attr_trait_2, \"fn trait2(#[a1] & self, #[a2] arg1 : u8) ;\");\n+checker!(attr_trait_3, \"fn trait3 < 'a > (#[a1] & 'a mut self, #[a2] arg1 : u8) ;\");\n+checker!(attr_trait_4, r#\"fn trait4 < 'a >\n+(#[a1] self : Box < Self >, #[a2] arg1 : u8, #[a3] Vec < u8 >) ;\"#);\n+checker!(attr_trait_issue_64682, \"fn trait5(#[a1] #[a2] arg1 : u8, #[a3] arg2 : u8) ;\");\n+checker!(rename_params, r#\"impl Foo\n+{\n+    fn hello(#[angery(true)] a : i32, #[a2] b : i32, #[what = \"how\"] c : u32)\n+    { } fn\n+    hello2(#[a1] #[a2] a : i32, #[what = \"how\"] b : i32, #[angery(true)] c :\n+           u32) { } fn\n+    hello_self(#[a1] #[a2] & self, #[a1] #[a2] a : i32, #[what = \"how\"] b :\n+               i32, #[angery(true)] c : u32) { }\n }\"#);"}, {"sha": "5c838fd719cd9492eabdce4e54c6e93897eae0d7", "filename": "src/test/ui/rfcs/rfc-2396-target_feature-11/fn-traits.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,34 @@\n+// only-x86_64\n+\n+#![feature(target_feature_11)]\n+\n+#[target_feature(enable = \"avx\")]\n+fn foo() {}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn foo_unsafe() {}\n+\n+fn call(f: impl Fn()) {\n+    f()\n+}\n+\n+fn call_mut(f: impl FnMut()) {\n+    f()\n+}\n+\n+fn call_once(f: impl FnOnce()) {\n+    f()\n+}\n+\n+fn main() {\n+    call(foo); //~ ERROR expected a `std::ops::Fn<()>` closure, found `fn() {foo}`\n+    call_mut(foo); //~ ERROR expected a `std::ops::FnMut<()>` closure, found `fn() {foo}`\n+    call_once(foo); //~ ERROR expected a `std::ops::FnOnce<()>` closure, found `fn() {foo}`\n+\n+    call(foo_unsafe);\n+    //~^ ERROR expected a `std::ops::Fn<()>` closure, found `unsafe fn() {foo_unsafe}`\n+    call_mut(foo_unsafe);\n+    //~^ ERROR expected a `std::ops::FnMut<()>` closure, found `unsafe fn() {foo_unsafe}`\n+    call_once(foo_unsafe);\n+    //~^ ERROR expected a `std::ops::FnOnce<()>` closure, found `unsafe fn() {foo_unsafe}`\n+}"}, {"sha": "448077b439e80bb3416fe4fdf62361755fb9fffc", "filename": "src/test/ui/rfcs/rfc-2396-target_feature-11/fn-traits.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-traits.stderr?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,81 @@\n+error[E0277]: expected a `std::ops::Fn<()>` closure, found `fn() {foo}`\n+  --> $DIR/fn-traits.rs:24:10\n+   |\n+LL | fn call(f: impl Fn()) {\n+   |                 ---- required by this bound in `call`\n+...\n+LL |     call(foo);\n+   |          ^^^ expected an `Fn<()>` closure, found `fn() {foo}`\n+   |\n+   = help: the trait `std::ops::Fn<()>` is not implemented for `fn() {foo}`\n+   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }\n+   = note: `#[target_feature]` functions do not implement the `Fn` traits\n+\n+error[E0277]: expected a `std::ops::FnMut<()>` closure, found `fn() {foo}`\n+  --> $DIR/fn-traits.rs:25:14\n+   |\n+LL | fn call_mut(f: impl FnMut()) {\n+   |                     ------- required by this bound in `call_mut`\n+...\n+LL |     call_mut(foo);\n+   |              ^^^ expected an `FnMut<()>` closure, found `fn() {foo}`\n+   |\n+   = help: the trait `std::ops::FnMut<()>` is not implemented for `fn() {foo}`\n+   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }\n+   = note: `#[target_feature]` functions do not implement the `Fn` traits\n+\n+error[E0277]: expected a `std::ops::FnOnce<()>` closure, found `fn() {foo}`\n+  --> $DIR/fn-traits.rs:26:15\n+   |\n+LL | fn call_once(f: impl FnOnce()) {\n+   |                      -------- required by this bound in `call_once`\n+...\n+LL |     call_once(foo);\n+   |               ^^^ expected an `FnOnce<()>` closure, found `fn() {foo}`\n+   |\n+   = help: the trait `std::ops::FnOnce<()>` is not implemented for `fn() {foo}`\n+   = note: wrap the `fn() {foo}` in a closure with no arguments: `|| { /* code */ }\n+   = note: `#[target_feature]` functions do not implement the `Fn` traits\n+\n+error[E0277]: expected a `std::ops::Fn<()>` closure, found `unsafe fn() {foo_unsafe}`\n+  --> $DIR/fn-traits.rs:28:10\n+   |\n+LL | fn call(f: impl Fn()) {\n+   |                 ---- required by this bound in `call`\n+...\n+LL |     call(foo_unsafe);\n+   |          ^^^^^^^^^^ expected an `Fn<()>` closure, found `unsafe fn() {foo_unsafe}`\n+   |\n+   = help: the trait `std::ops::Fn<()>` is not implemented for `unsafe fn() {foo_unsafe}`\n+   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }\n+   = note: `#[target_feature]` functions do not implement the `Fn` traits\n+\n+error[E0277]: expected a `std::ops::FnMut<()>` closure, found `unsafe fn() {foo_unsafe}`\n+  --> $DIR/fn-traits.rs:30:14\n+   |\n+LL | fn call_mut(f: impl FnMut()) {\n+   |                     ------- required by this bound in `call_mut`\n+...\n+LL |     call_mut(foo_unsafe);\n+   |              ^^^^^^^^^^ expected an `FnMut<()>` closure, found `unsafe fn() {foo_unsafe}`\n+   |\n+   = help: the trait `std::ops::FnMut<()>` is not implemented for `unsafe fn() {foo_unsafe}`\n+   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }\n+   = note: `#[target_feature]` functions do not implement the `Fn` traits\n+\n+error[E0277]: expected a `std::ops::FnOnce<()>` closure, found `unsafe fn() {foo_unsafe}`\n+  --> $DIR/fn-traits.rs:32:15\n+   |\n+LL | fn call_once(f: impl FnOnce()) {\n+   |                      -------- required by this bound in `call_once`\n+...\n+LL |     call_once(foo_unsafe);\n+   |               ^^^^^^^^^^ expected an `FnOnce<()>` closure, found `unsafe fn() {foo_unsafe}`\n+   |\n+   = help: the trait `std::ops::FnOnce<()>` is not implemented for `unsafe fn() {foo_unsafe}`\n+   = note: wrap the `unsafe fn() {foo_unsafe}` in a closure with no arguments: `|| { /* code */ }\n+   = note: `#[target_feature]` functions do not implement the `Fn` traits\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "9192ecfe196cb9d3f2b09eb2e87bd0889c337e7c", "filename": "src/test/ui/unsafe/ranged_ints_macro.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Funsafe%2Franged_ints_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/src%2Ftest%2Fui%2Funsafe%2Franged_ints_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints_macro.rs?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -0,0 +1,16 @@\n+// build-pass\n+#![feature(rustc_attrs)]\n+\n+macro_rules! apply {\n+    ($val:expr) => {\n+        #[rustc_layout_scalar_valid_range_start($val)]\n+        #[repr(transparent)]\n+        pub(crate) struct NonZero<T>(pub(crate) T);\n+    }\n+}\n+\n+apply!(1);\n+\n+fn main() {\n+    let _x = unsafe { NonZero(1) };\n+}"}, {"sha": "51a29553fdb3dc1f5de8a071bd16326f64a3b7f9", "filename": "triagebot.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7856f695d65a8ebc846754f97d15814bcb1c244/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b7856f695d65a8ebc846754f97d15814bcb1c244/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=b7856f695d65a8ebc846754f97d15814bcb1c244", "patch": "@@ -92,7 +92,7 @@ message_on_remove = \"Issue #{number}'s prioritization request has been removed.\"\n [notify-zulip.\"I-nominated\"]\n required_labels = [\"T-compiler\"]\n zulip_stream = 245100 # #t-compiler/wg-prioritization/alerts\n-topic = \"I-prioritize #{number} {title}\"\n+topic = \"I-nominated #{number} {title}\"\n message_on_add = \"\"\"\\\n @*WG-prioritization/alerts* #{number} has been nominated for discussion in `T-compiler` meeting.\n "}]}