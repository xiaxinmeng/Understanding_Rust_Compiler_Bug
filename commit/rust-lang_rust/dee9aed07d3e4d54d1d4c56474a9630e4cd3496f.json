{"sha": "dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "node_id": "C_kwDOAAsO6NoAKGRlZTlhZWQwN2QzZTRkNTRkMWQ0YzU2NDc0YTk2MzBlNGNkMzQ5NmY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-06-29T04:58:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-29T04:58:19Z"}, "message": "Rollup merge of #97542 - compiler-errors:arg-mismatch, r=jackh726\n\nUse typed indices in argument mismatch algorithm\n\nI kinda went overboard with the renames, but in general, \"arg\" is renamed to \"expected\", and \"input\" is renamed to \"provided\", and we use new typed indices to make sure we're indexing into the right sized array.\n\nOther drive-by changes:\n1. Factor this logic into a new function, so we don't need to `break 'label` to escape it.\n1. Factored out dependence on `final_arg_types`, which is never populated for arguments greater than the number of expected args. Instead, we just grab the final coerced expression type from `in_progress_typeck_results`.\n1. Adjust the criteria we use to print (provided) type names, before we didn't suggest anything that had infer vars, but now we suggest thing that have infer vars but aren't `_`.\n\n~Also, sorry in advance, I kinda want to backport this but I know I have folded in a lot of unnecessary drive-by changes that might discourage that. I would be open to brainstorming how to get some of these changes on beta at least.~ edit: Minimized the ICE-fixing changes to #97557\n\ncc `@jackh726` as author of #92364, and `@estebank` as reviewer of the PR.\nfixes #97484", "tree": {"sha": "d77cf95af955c9c46e46372ca70050f88b528b3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d77cf95af955c9c46e46372ca70050f88b528b3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiu9vrCRBK7hj4Ov3rIwAASjUIAE8kpNkOSVTi/BFtp3ZzRaLX\nevrfLSMTa5IqAa+OX7grWAxWh4ERqV2PlhEfBBA4jauRikabG/iskUYYK9/s+mp3\nHX0MNE4tK3JnT7BJvcJI7ughipBxL/wsNnWvMm4sV5RD8pNpA08ZnhPxD74IALWf\nstbv17KXCwzK2KuyJ2ZIcidiM/xzcwhIhwsnr5RPHo6qnpP9UGfLe+5Dyo6c+Wqk\nGdcjp97x+C57FjGiZhH36aJrsoljp0hLKudmU9h+cwgPuAj+iu41LUx/iMBRKrEA\nxainfqifFsBVxt8e+4cq2Vinlxe/uxeTgT86lcqBecp4bFU07VspXKVEUCkDd7c=\n=gLn8\n-----END PGP SIGNATURE-----\n", "payload": "tree d77cf95af955c9c46e46372ca70050f88b528b3e\nparent 45740acd3451a574f4b67329f70e610145cd99cd\nparent f2277e03eeb112730e3f07fab0d6b91d195fe55c\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1656478699 +0530\ncommitter GitHub <noreply@github.com> 1656478699 +0530\n\nRollup merge of #97542 - compiler-errors:arg-mismatch, r=jackh726\n\nUse typed indices in argument mismatch algorithm\n\nI kinda went overboard with the renames, but in general, \"arg\" is renamed to \"expected\", and \"input\" is renamed to \"provided\", and we use new typed indices to make sure we're indexing into the right sized array.\n\nOther drive-by changes:\n1. Factor this logic into a new function, so we don't need to `break 'label` to escape it.\n1. Factored out dependence on `final_arg_types`, which is never populated for arguments greater than the number of expected args. Instead, we just grab the final coerced expression type from `in_progress_typeck_results`.\n1. Adjust the criteria we use to print (provided) type names, before we didn't suggest anything that had infer vars, but now we suggest thing that have infer vars but aren't `_`.\n\n~Also, sorry in advance, I kinda want to backport this but I know I have folded in a lot of unnecessary drive-by changes that might discourage that. I would be open to brainstorming how to get some of these changes on beta at least.~ edit: Minimized the ICE-fixing changes to #97557\n\ncc `@jackh726` as author of #92364, and `@estebank` as reviewer of the PR.\nfixes #97484\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "html_url": "https://github.com/rust-lang/rust/commit/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45740acd3451a574f4b67329f70e610145cd99cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/45740acd3451a574f4b67329f70e610145cd99cd", "html_url": "https://github.com/rust-lang/rust/commit/45740acd3451a574f4b67329f70e610145cd99cd"}, {"sha": "f2277e03eeb112730e3f07fab0d6b91d195fe55c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2277e03eeb112730e3f07fab0d6b91d195fe55c", "html_url": "https://github.com/rust-lang/rust/commit/f2277e03eeb112730e3f07fab0d6b91d195fe55c"}], "stats": {"total": 1441, "additions": 759, "deletions": 682}, "files": [{"sha": "7602f2550e85baa18b943bd8ad53df0faf0fb340", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/arg_matrix.rs", "status": "modified", "additions": 77, "deletions": 52, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Farg_matrix.rs?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -1,7 +1,26 @@\n use std::cmp;\n \n+use rustc_index::vec::IndexVec;\n use rustc_middle::ty::error::TypeError;\n \n+rustc_index::newtype_index! {\n+    pub(crate) struct ExpectedIdx {\n+        DEBUG_FORMAT = \"ExpectedIdx({})\",\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub(crate) struct ProvidedIdx {\n+        DEBUG_FORMAT = \"ProvidedIdx({})\",\n+    }\n+}\n+\n+impl ExpectedIdx {\n+    pub fn to_provided_idx(self) -> ProvidedIdx {\n+        ProvidedIdx::from_usize(self.as_usize())\n+    }\n+}\n+\n // An issue that might be found in the compatibility matrix\n #[derive(Debug)]\n enum Issue {\n@@ -27,87 +46,89 @@ pub(crate) enum Compatibility<'tcx> {\n #[derive(Debug)]\n pub(crate) enum Error<'tcx> {\n     /// The provided argument is the invalid type for the expected input\n-    Invalid(usize, usize, Compatibility<'tcx>), // provided, expected\n+    Invalid(ProvidedIdx, ExpectedIdx, Compatibility<'tcx>),\n     /// There is a missing input\n-    Missing(usize),\n+    Missing(ExpectedIdx),\n     /// There's a superfluous argument\n-    Extra(usize),\n+    Extra(ProvidedIdx),\n     /// Two arguments should be swapped\n-    Swap(usize, usize, usize, usize),\n+    Swap(ProvidedIdx, ProvidedIdx, ExpectedIdx, ExpectedIdx),\n     /// Several arguments should be reordered\n-    Permutation(Vec<(usize, usize)>), // dest_arg, dest_input\n+    Permutation(Vec<(ExpectedIdx, ProvidedIdx)>),\n }\n \n pub(crate) struct ArgMatrix<'tcx> {\n     /// Maps the indices in the `compatibility_matrix` rows to the indices of\n     /// the *user provided* inputs\n-    input_indexes: Vec<usize>,\n+    provided_indices: Vec<ProvidedIdx>,\n     /// Maps the indices in the `compatibility_matrix` columns to the indices\n     /// of the *expected* args\n-    arg_indexes: Vec<usize>,\n+    expected_indices: Vec<ExpectedIdx>,\n     /// The first dimension (rows) are the remaining user provided inputs to\n     /// match and the second dimension (cols) are the remaining expected args\n     /// to match\n     compatibility_matrix: Vec<Vec<Compatibility<'tcx>>>,\n }\n \n impl<'tcx> ArgMatrix<'tcx> {\n-    pub(crate) fn new<F: FnMut(usize, usize) -> Compatibility<'tcx>>(\n-        minimum_input_count: usize,\n-        provided_arg_count: usize,\n+    pub(crate) fn new<F: FnMut(ProvidedIdx, ExpectedIdx) -> Compatibility<'tcx>>(\n+        provided_count: usize,\n+        expected_input_count: usize,\n         mut is_compatible: F,\n     ) -> Self {\n-        let compatibility_matrix = (0..provided_arg_count)\n-            .map(|i| (0..minimum_input_count).map(|j| is_compatible(i, j)).collect())\n+        let compatibility_matrix = (0..provided_count)\n+            .map(|i| {\n+                (0..expected_input_count)\n+                    .map(|j| is_compatible(ProvidedIdx::from_usize(i), ExpectedIdx::from_usize(j)))\n+                    .collect()\n+            })\n             .collect();\n         ArgMatrix {\n-            input_indexes: (0..provided_arg_count).collect(),\n-            arg_indexes: (0..minimum_input_count).collect(),\n+            provided_indices: (0..provided_count).map(ProvidedIdx::from_usize).collect(),\n+            expected_indices: (0..expected_input_count).map(ExpectedIdx::from_usize).collect(),\n             compatibility_matrix,\n         }\n     }\n \n     /// Remove a given input from consideration\n-    fn eliminate_input(&mut self, idx: usize) {\n-        self.input_indexes.remove(idx);\n+    fn eliminate_provided(&mut self, idx: usize) {\n+        self.provided_indices.remove(idx);\n         self.compatibility_matrix.remove(idx);\n     }\n \n     /// Remove a given argument from consideration\n-    fn eliminate_arg(&mut self, idx: usize) {\n-        self.arg_indexes.remove(idx);\n+    fn eliminate_expected(&mut self, idx: usize) {\n+        self.expected_indices.remove(idx);\n         for row in &mut self.compatibility_matrix {\n             row.remove(idx);\n         }\n     }\n \n     /// \"satisfy\" an input with a given arg, removing both from consideration\n-    fn satisfy_input(&mut self, input_idx: usize, arg_idx: usize) {\n-        self.eliminate_input(input_idx);\n-        self.eliminate_arg(arg_idx);\n+    fn satisfy_input(&mut self, provided_idx: usize, expected_idx: usize) {\n+        self.eliminate_provided(provided_idx);\n+        self.eliminate_expected(expected_idx);\n     }\n \n     // Returns a `Vec` of (user input, expected arg) of matched arguments. These\n     // are inputs on the remaining diagonal that match.\n-    fn eliminate_satisfied(&mut self) -> Vec<(usize, usize)> {\n-        let mut i = cmp::min(self.input_indexes.len(), self.arg_indexes.len());\n+    fn eliminate_satisfied(&mut self) -> Vec<(ProvidedIdx, ExpectedIdx)> {\n+        let num_args = cmp::min(self.provided_indices.len(), self.expected_indices.len());\n         let mut eliminated = vec![];\n-        while i > 0 {\n-            let idx = i - 1;\n-            if matches!(self.compatibility_matrix[idx][idx], Compatibility::Compatible) {\n-                eliminated.push((self.input_indexes[idx], self.arg_indexes[idx]));\n-                self.satisfy_input(idx, idx);\n+        for i in (0..num_args).rev() {\n+            if matches!(self.compatibility_matrix[i][i], Compatibility::Compatible) {\n+                eliminated.push((self.provided_indices[i], self.expected_indices[i]));\n+                self.satisfy_input(i, i);\n             }\n-            i -= 1;\n         }\n-        return eliminated;\n+        eliminated\n     }\n \n     // Find some issue in the compatibility matrix\n     fn find_issue(&self) -> Option<Issue> {\n         let mat = &self.compatibility_matrix;\n-        let ai = &self.arg_indexes;\n-        let ii = &self.input_indexes;\n+        let ai = &self.expected_indices;\n+        let ii = &self.provided_indices;\n \n         for i in 0..cmp::max(ai.len(), ii.len()) {\n             // If we eliminate the last row, any left-over inputs are considered missing\n@@ -264,12 +285,15 @@ impl<'tcx> ArgMatrix<'tcx> {\n     //\n     // We'll want to know which arguments and inputs these rows and columns correspond to\n     // even after we delete them.\n-    pub(crate) fn find_errors(mut self) -> (Vec<Error<'tcx>>, Vec<Option<usize>>) {\n-        let provided_arg_count = self.input_indexes.len();\n+    pub(crate) fn find_errors(\n+        mut self,\n+    ) -> (Vec<Error<'tcx>>, IndexVec<ExpectedIdx, Option<ProvidedIdx>>) {\n+        let provided_arg_count = self.provided_indices.len();\n \n         let mut errors: Vec<Error<'tcx>> = vec![];\n         // For each expected argument, the matched *actual* input\n-        let mut matched_inputs: Vec<Option<usize>> = vec![None; self.arg_indexes.len()];\n+        let mut matched_inputs: IndexVec<ExpectedIdx, Option<ProvidedIdx>> =\n+            IndexVec::from_elem_n(None, self.expected_indices.len());\n \n         // Before we start looking for issues, eliminate any arguments that are already satisfied,\n         // so that an argument which is already spoken for by the input it's in doesn't\n@@ -280,34 +304,34 @@ impl<'tcx> ArgMatrix<'tcx> {\n         // Without this elimination, the first argument causes the second argument\n         // to show up as both a missing input and extra argument, rather than\n         // just an invalid type.\n-        for (inp, arg) in self.eliminate_satisfied() {\n-            matched_inputs[arg] = Some(inp);\n+        for (provided, expected) in self.eliminate_satisfied() {\n+            matched_inputs[expected] = Some(provided);\n         }\n \n-        while self.input_indexes.len() > 0 || self.arg_indexes.len() > 0 {\n+        while !self.provided_indices.is_empty() || !self.expected_indices.is_empty() {\n             match self.find_issue() {\n                 Some(Issue::Invalid(idx)) => {\n                     let compatibility = self.compatibility_matrix[idx][idx].clone();\n-                    let input_idx = self.input_indexes[idx];\n-                    let arg_idx = self.arg_indexes[idx];\n+                    let input_idx = self.provided_indices[idx];\n+                    let arg_idx = self.expected_indices[idx];\n                     self.satisfy_input(idx, idx);\n                     errors.push(Error::Invalid(input_idx, arg_idx, compatibility));\n                 }\n                 Some(Issue::Extra(idx)) => {\n-                    let input_idx = self.input_indexes[idx];\n-                    self.eliminate_input(idx);\n+                    let input_idx = self.provided_indices[idx];\n+                    self.eliminate_provided(idx);\n                     errors.push(Error::Extra(input_idx));\n                 }\n                 Some(Issue::Missing(idx)) => {\n-                    let arg_idx = self.arg_indexes[idx];\n-                    self.eliminate_arg(idx);\n+                    let arg_idx = self.expected_indices[idx];\n+                    self.eliminate_expected(idx);\n                     errors.push(Error::Missing(arg_idx));\n                 }\n                 Some(Issue::Swap(idx, other)) => {\n-                    let input_idx = self.input_indexes[idx];\n-                    let other_input_idx = self.input_indexes[other];\n-                    let arg_idx = self.arg_indexes[idx];\n-                    let other_arg_idx = self.arg_indexes[other];\n+                    let input_idx = self.provided_indices[idx];\n+                    let other_input_idx = self.provided_indices[other];\n+                    let arg_idx = self.expected_indices[idx];\n+                    let other_arg_idx = self.expected_indices[other];\n                     let (min, max) = (cmp::min(idx, other), cmp::max(idx, other));\n                     self.satisfy_input(min, max);\n                     // Subtract 1 because we already removed the \"min\" row\n@@ -319,13 +343,14 @@ impl<'tcx> ArgMatrix<'tcx> {\n                 Some(Issue::Permutation(args)) => {\n                     let mut idxs: Vec<usize> = args.iter().filter_map(|&a| a).collect();\n \n-                    let mut real_idxs = vec![None; provided_arg_count];\n+                    let mut real_idxs: IndexVec<ProvidedIdx, Option<(ExpectedIdx, ProvidedIdx)>> =\n+                        IndexVec::from_elem_n(None, provided_arg_count);\n                     for (src, dst) in\n                         args.iter().enumerate().filter_map(|(src, dst)| dst.map(|dst| (src, dst)))\n                     {\n-                        let src_input_idx = self.input_indexes[src];\n-                        let dst_input_idx = self.input_indexes[dst];\n-                        let dest_arg_idx = self.arg_indexes[dst];\n+                        let src_input_idx = self.provided_indices[src];\n+                        let dst_input_idx = self.provided_indices[dst];\n+                        let dest_arg_idx = self.expected_indices[dst];\n                         real_idxs[src_input_idx] = Some((dest_arg_idx, dst_input_idx));\n                         matched_inputs[dest_arg_idx] = Some(src_input_idx);\n                     }"}, {"sha": "08df01c0c1a1a9ab1923ddc328d26f03201297cb", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 635, "deletions": 582, "changes": 1217, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -1,6 +1,8 @@\n use crate::astconv::AstConv;\n use crate::check::coercion::CoerceMany;\n-use crate::check::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error};\n+use crate::check::fn_ctxt::arg_matrix::{\n+    ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx,\n+};\n use crate::check::gather_locals::Declaration;\n use crate::check::method::MethodCallee;\n use crate::check::Expectation::*;\n@@ -17,13 +19,14 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_index::vec::IndexVec;\n use rustc_infer::infer::error_reporting::{FailureCode, ObligationCauseExt};\n use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::fold::TypeFoldable;\n-use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{self, IsSuggestable, Ty, TyCtxt};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n@@ -214,6 +217,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let provided_arg_count = provided_args.len();\n \n         // We'll also want to keep track of the fully coerced argument types, for an awkward hack near the end\n+        // FIXME(compiler-errors): Get rid of this, actually.\n         let mut final_arg_types: Vec<Option<(Ty<'_>, Ty<'_>)>> = vec![None; provided_arg_count];\n \n         // We introduce a helper function to demand that a given argument satisfy a given input\n@@ -287,54 +291,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n \n-        // A \"softer\" version of the helper above, which checks types without persisting them,\n-        // and treats error types differently\n-        // This will allow us to \"probe\" for other argument orders that would likely have been correct\n-        let check_compatible = |input_idx, arg_idx| {\n-            let formal_input_ty: Ty<'tcx> = formal_input_tys[arg_idx];\n-            let expected_input_ty: Ty<'tcx> = expected_input_tys[arg_idx];\n-\n-            // If either is an error type, we defy the usual convention and consider them to *not* be\n-            // coercible.  This prevents our error message heuristic from trying to pass errors into\n-            // every argument.\n-            if formal_input_ty.references_error() || expected_input_ty.references_error() {\n-                return Compatibility::Incompatible(None);\n-            }\n-\n-            let provided_arg: &hir::Expr<'tcx> = &provided_args[input_idx];\n-            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n-            // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n-            //\n-            //   I had another method of \"soft\" type checking before,\n-            //   but it was failing to find the type of some expressions (like \"\")\n-            //   so I prodded this method and made it pub(super) so I could call it, and it seems to work well.\n-            let checked_ty = self.check_expr_kind(provided_arg, expectation);\n-\n-            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n-            let can_coerce = self.can_coerce(checked_ty, coerced_ty);\n-\n-            if !can_coerce {\n-                return Compatibility::Incompatible(None);\n-            }\n-\n-            let subtyping_result = self\n-                .at(&self.misc(provided_arg.span), self.param_env)\n-                .sup(formal_input_ty, coerced_ty);\n-\n-            // Same as above: if either the coerce type or the checked type is an error type,\n-            // consider them *not* compatible.\n-            let coercible =\n-                !coerced_ty.references_error() && !checked_ty.references_error() && can_coerce;\n-\n-            match (coercible, &subtyping_result) {\n-                (true, Ok(_)) => Compatibility::Compatible,\n-                _ => Compatibility::Incompatible(subtyping_result.err()),\n-            }\n-        };\n-\n         // To start, we only care \"along the diagonal\", where we expect every\n         // provided arg to be in the right spot\n-        let mut compatibility = vec![Compatibility::Incompatible(None); provided_args.len()];\n+        let mut compatibility_diagonal =\n+            vec![Compatibility::Incompatible(None); provided_args.len()];\n \n         // Keep track of whether we *could possibly* be satisfied, i.e. whether we're on the happy path\n         // if the wrong number of arguments were supplied, we CAN'T be satisfied,\n@@ -394,78 +354,62 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let compatible = demand_compatible(idx, &mut final_arg_types);\n                 let is_compatible = matches!(compatible, Compatibility::Compatible);\n-                compatibility[idx] = compatible;\n+                compatibility_diagonal[idx] = compatible;\n \n                 if !is_compatible {\n                     call_appears_satisfied = false;\n                 }\n             }\n         }\n \n-        // Logic here is a bit hairy\n-        'errors: {\n-            // If something above didn't typecheck, we've fallen off the happy path\n-            // and we should make some effort to provide better error messages\n-            if call_appears_satisfied {\n-                break 'errors;\n-            }\n-\n-            self.set_tainted_by_errors();\n+        if c_variadic && provided_arg_count < minimum_input_count {\n+            err_code = \"E0060\";\n+        }\n \n-            // The algorithm here is inspired by levenshtein distance and longest common subsequence.\n-            // We'll try to detect 4 different types of mistakes:\n-            // - An extra parameter has been provided that doesn't satisfy *any* of the other inputs\n-            // - An input is missing, which isn't satisfied by *any* of the other arguments\n-            // - Some number of arguments have been provided in the wrong order\n-            // - A type is straight up invalid\n+        for arg in provided_args.iter().skip(minimum_input_count) {\n+            // Make sure we've checked this expr at least once.\n+            let arg_ty = self.check_expr(&arg);\n \n-            // First, let's find the errors\n-            let mut compatibility: Vec<_> = compatibility.into_iter().map(Some).collect();\n-            let (mut errors, matched_inputs) =\n-                ArgMatrix::new(minimum_input_count, provided_arg_count, |i, j| {\n-                    if i == j { compatibility[i].take().unwrap() } else { check_compatible(i, j) }\n-                })\n-                .find_errors();\n+            // If the function is c-style variadic, we skipped a bunch of arguments\n+            // so we need to check those, and write out the types\n+            // Ideally this would be folded into the above, for uniform style\n+            // but c-variadic is already a corner case\n+            if c_variadic {\n+                fn variadic_error<'tcx>(\n+                    sess: &'tcx Session,\n+                    span: Span,\n+                    ty: Ty<'tcx>,\n+                    cast_ty: &str,\n+                ) {\n+                    use crate::structured_errors::MissingCastForVariadicArg;\n \n-            // Okay, so here's where it gets complicated in regards to what errors\n-            // we emit and how.\n-            // There are 3 different \"types\" of errors we might encounter.\n-            //   1) Missing/extra/swapped arguments\n-            //   2) Valid but incorrect arguments\n-            //   3) Invalid arguments\n-            //      - Currently I think this only comes up with `CyclicTy`\n-            //\n-            // We first need to go through, remove those from (3) and emit those\n-            // as their own error, particularly since they're error code and\n-            // message is special. From what I can tell, we *must* emit these\n-            // here (vs somewhere prior to this function) since the arguments\n-            // become invalid *because* of how they get used in the function.\n-            // It is what it is.\n-\n-            let found_errors = !errors.is_empty();\n-\n-            errors.drain_filter(|error| {\n-                let Error::Invalid(input_idx, arg_idx, Compatibility::Incompatible(Some(e))) = error else { return false };\n-                let expected_ty = expected_input_tys[*arg_idx];\n-                let provided_ty = final_arg_types[*input_idx].map(|ty| ty.0).unwrap_or_else(|| tcx.ty_error());\n-                let cause = &self.misc(provided_args[*input_idx].span);\n-                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                if !matches!(trace.cause.as_failure_code(e), FailureCode::Error0308(_)) {\n-                    self.report_and_explain_type_error(trace, e).emit();\n-                    return true;\n+                    MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n                 }\n-                false\n-            });\n \n-            // We're done if we found errors, but we already emitted them.\n-            // I don't think we *should* be able to enter this bit of code\n-            // (`!call_appears_satisfied`) without *also* finding errors, but we\n-            // don't want to accidentally not emit an error if there is some\n-            // logic bug in the `ArgMatrix` code.\n-            if found_errors && errors.is_empty() {\n-                break 'errors;\n+                // There are a few types which get autopromoted when passed via varargs\n+                // in C but we just error out instead and require explicit casts.\n+                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n+                match arg_ty.kind() {\n+                    ty::Float(ty::FloatTy::F32) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n+                    }\n+                    ty::Int(ty::IntTy::I8 | ty::IntTy::I16) | ty::Bool => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n+                    }\n+                    ty::Uint(ty::UintTy::U8 | ty::UintTy::U16) => {\n+                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n+                    }\n+                    ty::FnDef(..) => {\n+                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n+                        let ptr_ty = self.resolve_vars_if_possible(ptr_ty);\n+                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n+                    }\n+                    _ => {}\n+                }\n             }\n+        }\n \n+        if !call_appears_satisfied {\n             // Next, let's construct the error\n             let (error_span, full_call_span, ctor_of) = match &call_expr.kind {\n                 hir::ExprKind::Call(\n@@ -500,524 +444,633 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 Some(CtorOf::Variant) => \"enum variant\",\n                 None => \"function\",\n             };\n-            if c_variadic && provided_arg_count < minimum_input_count {\n-                err_code = \"E0060\";\n-            }\n \n-            // Next special case: The case where we expect a single tuple and\n-            // wrapping all the args in parentheses (or adding a comma to\n-            // already existing parentheses) will result in a tuple that\n-            // satisfies the call.\n-            // This isn't super ideal code, because we copy code from elsewhere\n-            // and somewhat duplicate this. We also delegate to the general type\n-            // mismatch suggestions for the single arg case.\n-            let sugg_tuple_wrap_args =\n-                self.suggested_tuple_wrap(&expected_input_tys, provided_args);\n-            match sugg_tuple_wrap_args {\n-                TupleMatchFound::None => {}\n-                TupleMatchFound::Single => {\n-                    let expected_ty = expected_input_tys[0];\n-                    let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n-                    let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                    let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                    let cause = &self.misc(provided_args[0].span);\n-                    let compatibility = demand_compatible(0, &mut final_arg_types);\n-                    let type_error = match compatibility {\n-                        Compatibility::Incompatible(Some(error)) => error,\n-                        _ => TypeError::Mismatch,\n-                    };\n-                    let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                    let mut err = self.report_and_explain_type_error(trace, &type_error);\n-                    self.emit_coerce_suggestions(\n-                        &mut err,\n-                        &provided_args[0],\n-                        final_arg_types[0].map(|ty| ty.0).unwrap(),\n-                        final_arg_types[0].map(|ty| ty.1).unwrap(),\n-                        None,\n-                        None,\n-                    );\n-                    err.span_label(\n-                        full_call_span,\n-                        format!(\"arguments to this {} are incorrect\", call_name),\n-                    );\n-                    // Call out where the function is defined\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n-                    err.emit();\n-                    break 'errors;\n-                }\n-                TupleMatchFound::Multiple(start, end) => {\n-                    let mut err = tcx.sess.struct_span_err_with_code(\n-                        full_call_span,\n-                        &format!(\n-                            \"this {} takes {}{} but {} {} supplied\",\n-                            call_name,\n-                            if c_variadic { \"at least \" } else { \"\" },\n-                            potentially_plural_count(minimum_input_count, \"argument\"),\n-                            potentially_plural_count(provided_arg_count, \"argument\"),\n-                            if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                        ),\n-                        DiagnosticId::Error(err_code.to_owned()),\n-                    );\n-                    // Call out where the function is defined\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n-                    err.multipart_suggestion(\n-                        \"use parentheses to construct a tuple\",\n-                        vec![(start, '('.to_string()), (end, ')'.to_string())],\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                    break 'errors;\n+            let try_tuple_wrap_args = || {\n+                // The case where we expect a single tuple and wrapping all the args\n+                // in parentheses (or adding a comma to already existing parentheses)\n+                // will result in a tuple that satisfies the call.\n+                // This isn't super ideal code, because we copy code from elsewhere\n+                // and somewhat duplicate this. We also delegate to the general type\n+                // mismatch suggestions for the single arg case.\n+                match self.suggested_tuple_wrap(&expected_input_tys, provided_args) {\n+                    TupleMatchFound::Single => {\n+                        let expected_ty = expected_input_tys[0];\n+                        let provided_ty = final_arg_types[0].map(|ty| ty.0).unwrap();\n+                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n+                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n+                        let cause = &self.misc(provided_args[0].span);\n+                        let compatibility = demand_compatible(0, &mut final_arg_types);\n+                        let type_error = match compatibility {\n+                            Compatibility::Incompatible(Some(error)) => error,\n+                            _ => TypeError::Mismatch,\n+                        };\n+                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                        let mut err = self.report_and_explain_type_error(trace, &type_error);\n+                        self.emit_coerce_suggestions(\n+                            &mut err,\n+                            &provided_args[0],\n+                            final_arg_types[0].map(|ty| ty.0).unwrap(),\n+                            final_arg_types[0].map(|ty| ty.1).unwrap(),\n+                            None,\n+                            None,\n+                        );\n+                        err.span_label(\n+                            full_call_span,\n+                            format!(\"arguments to this {} are incorrect\", call_name),\n+                        );\n+                        // Call out where the function is defined\n+                        label_fn_like(tcx, &mut err, fn_def_id);\n+                        err.emit();\n+                        return true;\n+                    }\n+                    TupleMatchFound::Multiple(start, end) => {\n+                        let mut err = tcx.sess.struct_span_err_with_code(\n+                            full_call_span,\n+                            &format!(\n+                                \"this {} takes {}{} but {} {} supplied\",\n+                                call_name,\n+                                if c_variadic { \"at least \" } else { \"\" },\n+                                potentially_plural_count(minimum_input_count, \"argument\"),\n+                                potentially_plural_count(provided_arg_count, \"argument\"),\n+                                if provided_arg_count == 1 { \"was\" } else { \"were\" }\n+                            ),\n+                            DiagnosticId::Error(err_code.to_owned()),\n+                        );\n+                        // Call out where the function is defined\n+                        label_fn_like(tcx, &mut err, fn_def_id);\n+                        err.multipart_suggestion(\n+                            \"use parentheses to construct a tuple\",\n+                            vec![(start, '('.to_string()), (end, ')'.to_string())],\n+                            Applicability::MachineApplicable,\n+                        );\n+                        err.emit();\n+                        return true;\n+                    }\n+                    TupleMatchFound::None => {}\n                 }\n+                false\n+            };\n+\n+            let compatibility_diagonal = IndexVec::from_raw(compatibility_diagonal);\n+            let provided_args = IndexVec::from_iter(provided_args.iter().take(if c_variadic {\n+                minimum_input_count\n+            } else {\n+                provided_arg_count\n+            }));\n+            debug_assert_eq!(\n+                formal_input_tys.len(),\n+                expected_input_tys.len(),\n+                \"expected formal_input_tys to be the same size as expected_input_tys\"\n+            );\n+            let formal_and_expected_inputs = IndexVec::from_iter(\n+                formal_input_tys\n+                    .iter()\n+                    .copied()\n+                    .zip(expected_input_tys.iter().copied())\n+                    .map(|vars| self.resolve_vars_if_possible(vars)),\n+            );\n+\n+            self.report_arg_errors(\n+                compatibility_diagonal,\n+                formal_and_expected_inputs,\n+                provided_args,\n+                full_call_span,\n+                error_span,\n+                args_span,\n+                call_name,\n+                c_variadic,\n+                err_code,\n+                fn_def_id,\n+                try_tuple_wrap_args,\n+            );\n+        }\n+    }\n+\n+    fn report_arg_errors(\n+        &self,\n+        compatibility_diagonal: IndexVec<ProvidedIdx, Compatibility<'tcx>>,\n+        formal_and_expected_inputs: IndexVec<ExpectedIdx, (Ty<'tcx>, Ty<'tcx>)>,\n+        provided_args: IndexVec<ProvidedIdx, &'tcx hir::Expr<'tcx>>,\n+        full_call_span: Span,\n+        error_span: Span,\n+        args_span: Span,\n+        call_name: &str,\n+        c_variadic: bool,\n+        err_code: &str,\n+        fn_def_id: Option<DefId>,\n+        try_tuple_wrap_args: impl FnOnce() -> bool,\n+    ) {\n+        // Don't print if it has error types or is just plain `_`\n+        fn has_error_or_infer<'tcx>(tys: impl IntoIterator<Item = Ty<'tcx>>) -> bool {\n+            tys.into_iter().any(|ty| ty.references_error() || ty.is_ty_var())\n+        }\n+\n+        self.set_tainted_by_errors();\n+        let tcx = self.tcx;\n+\n+        // A \"softer\" version of the `demand_compatible`, which checks types without persisting them,\n+        // and treats error types differently\n+        // This will allow us to \"probe\" for other argument orders that would likely have been correct\n+        let check_compatible = |provided_idx: ProvidedIdx, expected_idx: ExpectedIdx| {\n+            if provided_idx.as_usize() == expected_idx.as_usize() {\n+                return compatibility_diagonal[provided_idx].clone();\n+            }\n+\n+            let (formal_input_ty, expected_input_ty) = formal_and_expected_inputs[expected_idx];\n+            // If either is an error type, we defy the usual convention and consider them to *not* be\n+            // coercible.  This prevents our error message heuristic from trying to pass errors into\n+            // every argument.\n+            if (formal_input_ty, expected_input_ty).references_error() {\n+                return Compatibility::Incompatible(None);\n+            }\n+\n+            let provided_arg: &hir::Expr<'tcx> = &provided_args[provided_idx];\n+            let expectation = Expectation::rvalue_hint(self, expected_input_ty);\n+            // FIXME: check that this is safe; I don't believe this commits any of the obligations, but I can't be sure.\n+            //\n+            //   I had another method of \"soft\" type checking before,\n+            //   but it was failing to find the type of some expressions (like \"\")\n+            //   so I prodded this method and made it pub(super) so I could call it, and it seems to work well.\n+            let checked_ty = self.check_expr_kind(provided_arg, expectation);\n+\n+            let coerced_ty = expectation.only_has_type(self).unwrap_or(formal_input_ty);\n+            let can_coerce = self.can_coerce(checked_ty, coerced_ty);\n+            if !can_coerce {\n+                return Compatibility::Incompatible(None);\n+            }\n+\n+            let subtyping_result = self\n+                .at(&self.misc(provided_arg.span), self.param_env)\n+                .sup(formal_input_ty, coerced_ty);\n+\n+            // Same as above: if either the coerce type or the checked type is an error type,\n+            // consider them *not* compatible.\n+            let references_error = (coerced_ty, checked_ty).references_error();\n+            match (references_error, &subtyping_result) {\n+                (false, Ok(_)) => Compatibility::Compatible,\n+                _ => Compatibility::Incompatible(subtyping_result.err()),\n             }\n+        };\n+\n+        // The algorithm here is inspired by levenshtein distance and longest common subsequence.\n+        // We'll try to detect 4 different types of mistakes:\n+        // - An extra parameter has been provided that doesn't satisfy *any* of the other inputs\n+        // - An input is missing, which isn't satisfied by *any* of the other arguments\n+        // - Some number of arguments have been provided in the wrong order\n+        // - A type is straight up invalid\n+\n+        // First, let's find the errors\n+        let (mut errors, matched_inputs) =\n+            ArgMatrix::new(provided_args.len(), formal_and_expected_inputs.len(), check_compatible)\n+                .find_errors();\n+\n+        // Precompute the provided types and spans, since that's all we typically need for below\n+        let provided_arg_tys: IndexVec<ProvidedIdx, (Ty<'tcx>, Span)> = provided_args\n+            .iter()\n+            .map(|expr| {\n+                let ty = self\n+                    .in_progress_typeck_results\n+                    .as_ref()\n+                    .unwrap()\n+                    .borrow()\n+                    .expr_ty_adjusted_opt(*expr)\n+                    .unwrap_or_else(|| tcx.ty_error());\n+                (self.resolve_vars_if_possible(ty), expr.span)\n+            })\n+            .collect();\n+\n+        // Okay, so here's where it gets complicated in regards to what errors\n+        // we emit and how.\n+        // There are 3 different \"types\" of errors we might encounter.\n+        //   1) Missing/extra/swapped arguments\n+        //   2) Valid but incorrect arguments\n+        //   3) Invalid arguments\n+        //      - Currently I think this only comes up with `CyclicTy`\n+        //\n+        // We first need to go through, remove those from (3) and emit those\n+        // as their own error, particularly since they're error code and\n+        // message is special. From what I can tell, we *must* emit these\n+        // here (vs somewhere prior to this function) since the arguments\n+        // become invalid *because* of how they get used in the function.\n+        // It is what it is.\n+\n+        if errors.is_empty() {\n+            if cfg!(debug_assertions) {\n+                span_bug!(error_span, \"expected errors from argument matrix\");\n+            } else {\n+                tcx.sess\n+                    .struct_span_err(\n+                        error_span,\n+                        \"argument type mismatch was detected, \\\n+                        but rustc had trouble determining where\",\n+                    )\n+                    .note(\n+                        \"we would appreciate a bug report: \\\n+                        https://github.com/rust-lang/rust-clippy/issues/new\",\n+                    )\n+                    .emit();\n+            }\n+            return;\n+        }\n+\n+        errors.drain_filter(|error| {\n+                let Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(error)) = error else { return false };\n+                let (provided_ty, provided_span) = provided_arg_tys[*provided_idx];\n+                let (expected_ty, _) = formal_and_expected_inputs[*expected_idx];\n+                let cause = &self.misc(provided_span);\n+                let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                if let Some(e) = error {\n+                    if !matches!(trace.cause.as_failure_code(e), FailureCode::Error0308(_)) {\n+                        self.report_and_explain_type_error(trace, e).emit();\n+                        return true;\n+                    }\n+                }\n+                false\n+            });\n+\n+        // We're done if we found errors, but we already emitted them.\n+        if errors.is_empty() {\n+            return;\n+        }\n+\n+        // Okay, now that we've emitted the special errors separately, we\n+        // are only left missing/extra/swapped and mismatched arguments, both\n+        // can be collated pretty easily if needed.\n+\n+        // Next special case: if there is only one \"Incompatible\" error, just emit that\n+        if let [\n+            Error::Invalid(provided_idx, expected_idx, Compatibility::Incompatible(Some(err))),\n+        ] = &errors[..]\n+        {\n+            let (formal_ty, expected_ty) = formal_and_expected_inputs[*expected_idx];\n+            let (provided_ty, provided_arg_span) = provided_arg_tys[*provided_idx];\n+            let cause = &self.misc(provided_arg_span);\n+            let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+            let mut err = self.report_and_explain_type_error(trace, err);\n+            self.emit_coerce_suggestions(\n+                &mut err,\n+                &provided_args[*provided_idx],\n+                provided_ty,\n+                Expectation::rvalue_hint(self, expected_ty)\n+                    .only_has_type(self)\n+                    .unwrap_or(formal_ty),\n+                None,\n+                None,\n+            );\n+            err.span_label(\n+                full_call_span,\n+                format!(\"arguments to this {} are incorrect\", call_name),\n+            );\n+            // Call out where the function is defined\n+            label_fn_like(tcx, &mut err, fn_def_id);\n+            err.emit();\n+            return;\n+        }\n+\n+        // Second, let's try tuple wrapping the args.\n+        // FIXME(compiler-errors): This is currently in its own closure because\n+        // I didn't want to factor it out.\n+        if try_tuple_wrap_args() {\n+            return;\n+        }\n+\n+        let mut err = if formal_and_expected_inputs.len() == provided_args.len() {\n+            struct_span_err!(\n+                tcx.sess,\n+                full_call_span,\n+                E0308,\n+                \"arguments to this {} are incorrect\",\n+                call_name,\n+            )\n+        } else {\n+            tcx.sess.struct_span_err_with_code(\n+                full_call_span,\n+                &format!(\n+                    \"this {} takes {}{} but {} {} supplied\",\n+                    call_name,\n+                    if c_variadic { \"at least \" } else { \"\" },\n+                    potentially_plural_count(formal_and_expected_inputs.len(), \"argument\"),\n+                    potentially_plural_count(provided_args.len(), \"argument\"),\n+                    if provided_args.len() == 1 { \"was\" } else { \"were\" }\n+                ),\n+                DiagnosticId::Error(err_code.to_owned()),\n+            )\n+        };\n+\n+        // As we encounter issues, keep track of what we want to provide for the suggestion\n+        let mut labels = vec![];\n+        // If there is a single error, we give a specific suggestion; otherwise, we change to\n+        // \"did you mean\" with the suggested function call\n+        enum SuggestionText {\n+            None,\n+            Provide(bool),\n+            Remove(bool),\n+            Swap,\n+            Reorder,\n+            DidYouMean,\n+        }\n+        let mut suggestion_text = SuggestionText::None;\n+\n+        let mut errors = errors.into_iter().peekable();\n+        while let Some(error) = errors.next() {\n+            match error {\n+                Error::Invalid(provided_idx, expected_idx, compatibility) => {\n+                    let (formal_ty, expected_ty) = formal_and_expected_inputs[expected_idx];\n+                    let (provided_ty, provided_span) = provided_arg_tys[provided_idx];\n+                    if let Compatibility::Incompatible(error) = &compatibility {\n+                        let cause = &self.misc(provided_span);\n+                        let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n+                        if let Some(e) = error {\n+                            self.note_type_err(\n+                                &mut err,\n+                                &trace.cause,\n+                                None,\n+                                Some(trace.values),\n+                                e,\n+                                false,\n+                                true,\n+                            );\n+                        }\n+                    }\n \n-            // Okay, now that we've emitted the special errors separately, we\n-            // are only left missing/extra/swapped and mismatched arguments, both\n-            // can be collated pretty easily if needed.\n-\n-            // Next special case: if there is only one \"Incompatible\" error, just emit that\n-            if errors.len() == 1 {\n-                if let Some(Error::Invalid(\n-                    input_idx,\n-                    arg_idx,\n-                    Compatibility::Incompatible(Some(error)),\n-                )) = errors.iter().next()\n-                {\n-                    let expected_ty = expected_input_tys[*arg_idx];\n-                    let provided_ty = final_arg_types[*input_idx]\n-                        .map(|ty| ty.0)\n-                        .unwrap_or_else(|| tcx.ty_error());\n-                    let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                    let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                    let cause = &self.misc(provided_args[*input_idx].span);\n-                    let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                    let mut err = self.report_and_explain_type_error(trace, error);\n                     self.emit_coerce_suggestions(\n                         &mut err,\n-                        &provided_args[*input_idx],\n+                        &provided_args[provided_idx],\n                         provided_ty,\n-                        final_arg_types[*input_idx]\n-                            .map(|ty| ty.1)\n-                            .unwrap_or_else(|| tcx.ty_error()),\n+                        Expectation::rvalue_hint(self, expected_ty)\n+                            .only_has_type(self)\n+                            .unwrap_or(formal_ty),\n                         None,\n                         None,\n                     );\n-                    err.span_label(\n-                        full_call_span,\n-                        format!(\"arguments to this {} are incorrect\", call_name),\n-                    );\n-                    // Call out where the function is defined\n-                    label_fn_like(tcx, &mut err, fn_def_id);\n-                    err.emit();\n-                    break 'errors;\n                 }\n-            }\n-\n-            let mut err = if minimum_input_count == provided_arg_count {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    full_call_span,\n-                    E0308,\n-                    \"arguments to this {} are incorrect\",\n-                    call_name,\n-                )\n-            } else {\n-                tcx.sess.struct_span_err_with_code(\n-                    full_call_span,\n-                    &format!(\n-                        \"this {} takes {}{} but {} {} supplied\",\n-                        call_name,\n-                        if c_variadic { \"at least \" } else { \"\" },\n-                        potentially_plural_count(minimum_input_count, \"argument\"),\n-                        potentially_plural_count(provided_arg_count, \"argument\"),\n-                        if provided_arg_count == 1 { \"was\" } else { \"were\" }\n-                    ),\n-                    DiagnosticId::Error(err_code.to_owned()),\n-                )\n-            };\n-\n-            // As we encounter issues, keep track of what we want to provide for the suggestion\n-            let mut labels = vec![];\n-            // If there is a single error, we give a specific suggestion; otherwise, we change to\n-            // \"did you mean\" with the suggested function call\n-            enum SuggestionText {\n-                None,\n-                Provide(bool),\n-                Remove(bool),\n-                Swap,\n-                Reorder,\n-                DidYouMean,\n-            }\n-            let mut suggestion_text = SuggestionText::None;\n-\n-            let mut errors = errors.into_iter().peekable();\n-            while let Some(error) = errors.next() {\n-                match error {\n-                    Error::Invalid(input_idx, arg_idx, compatibility) => {\n-                        let expected_ty = expected_input_tys[arg_idx];\n-                        let provided_ty = final_arg_types[input_idx]\n-                            .map(|ty| ty.0)\n-                            .unwrap_or_else(|| tcx.ty_error());\n-                        let expected_ty = self.resolve_vars_if_possible(expected_ty);\n-                        let provided_ty = self.resolve_vars_if_possible(provided_ty);\n-                        if let Compatibility::Incompatible(error) = &compatibility {\n-                            let cause = &self.misc(provided_args[input_idx].span);\n-                            let trace = TypeTrace::types(cause, true, expected_ty, provided_ty);\n-                            if let Some(e) = error {\n-                                self.note_type_err(\n-                                    &mut err,\n-                                    &trace.cause,\n-                                    None,\n-                                    Some(trace.values),\n-                                    e,\n-                                    false,\n-                                    true,\n-                                );\n-                            }\n+                Error::Extra(arg_idx) => {\n+                    let (provided_ty, provided_span) = provided_arg_tys[arg_idx];\n+                    let provided_ty_name = if !has_error_or_infer([provided_ty]) {\n+                        // FIXME: not suggestable, use something else\n+                        format!(\" of type `{}`\", provided_ty)\n+                    } else {\n+                        \"\".to_string()\n+                    };\n+                    labels\n+                        .push((provided_span, format!(\"argument{} unexpected\", provided_ty_name)));\n+                    suggestion_text = match suggestion_text {\n+                        SuggestionText::None => SuggestionText::Remove(false),\n+                        SuggestionText::Remove(_) => SuggestionText::Remove(true),\n+                        _ => SuggestionText::DidYouMean,\n+                    };\n+                }\n+                Error::Missing(expected_idx) => {\n+                    // If there are multiple missing arguments adjacent to each other,\n+                    // then we can provide a single error.\n+\n+                    let mut missing_idxs = vec![expected_idx];\n+                    while let Some(e) = errors.next_if(|e| {\n+                        matches!(e, Error::Missing(next_expected_idx)\n+                            if *next_expected_idx == *missing_idxs.last().unwrap() + 1)\n+                    }) {\n+                        match e {\n+                            Error::Missing(expected_idx) => missing_idxs.push(expected_idx),\n+                            _ => unreachable!(),\n                         }\n-\n-                        self.emit_coerce_suggestions(\n-                            &mut err,\n-                            &provided_args[input_idx],\n-                            provided_ty,\n-                            // FIXME(compiler-errors): expected_ty?\n-                            final_arg_types[input_idx]\n-                                .map(|ty| ty.1)\n-                                .unwrap_or_else(|| tcx.ty_error()),\n-                            None,\n-                            None,\n-                        );\n                     }\n-                    Error::Extra(arg_idx) => {\n-                        let arg_type = if let Some((_, ty)) = final_arg_types[arg_idx] {\n-                            if ty.references_error() || ty.has_infer_types() {\n-                                \"\".into()\n+\n+                    // NOTE: Because we might be re-arranging arguments, might have extra\n+                    // arguments, etc. it's hard to *really* know where we should provide\n+                    // this error label, so as a heuristic, we point to the provided arg, or\n+                    // to the call if the missing inputs pass the provided args.\n+                    match &missing_idxs[..] {\n+                        &[expected_idx] => {\n+                            let (_, input_ty) = formal_and_expected_inputs[expected_idx];\n+                            let span = if let Some((_, arg_span)) =\n+                                provided_arg_tys.get(expected_idx.to_provided_idx())\n+                            {\n+                                *arg_span\n                             } else {\n-                                format!(\" of type `{}`\", ty)\n-                            }\n-                        } else {\n-                            \"\".into()\n-                        };\n-                        labels.push((\n-                            provided_args[arg_idx].span,\n-                            format!(\"argument{} unexpected\", arg_type),\n-                        ));\n-                        suggestion_text = match suggestion_text {\n-                            SuggestionText::None => SuggestionText::Remove(false),\n-                            SuggestionText::Remove(_) => SuggestionText::Remove(true),\n-                            _ => SuggestionText::DidYouMean,\n-                        };\n-                    }\n-                    Error::Missing(input_idx) => {\n-                        // If there are multiple missing arguments adjacent to each other,\n-                        // then we can provide a single error.\n-\n-                        let mut missing_idxs = vec![input_idx];\n-                        while let Some(e) = errors.next_if(|e| matches!(e, Error::Missing(input_idx) if *input_idx == (missing_idxs.last().unwrap() + 1))) {\n-                            match e {\n-                                Error::Missing(input_idx) => missing_idxs.push(input_idx),\n-                                _ => unreachable!(),\n-                            }\n+                                args_span\n+                            };\n+                            let rendered = if !has_error_or_infer([input_ty]) {\n+                                format!(\" of type `{}`\", input_ty)\n+                            } else {\n+                                \"\".to_string()\n+                            };\n+                            labels.push((span, format!(\"an argument{} is missing\", rendered)));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None => SuggestionText::Provide(false),\n+                                SuggestionText::Provide(_) => SuggestionText::Provide(true),\n+                                _ => SuggestionText::DidYouMean,\n+                            };\n                         }\n-\n-                        // NOTE: Because we might be re-arranging arguments, might have extra\n-                        // arguments, etc. it's hard to *really* know where we should provide\n-                        // this error label, so as a heuristic, we point to the provided arg, or\n-                        // to the call if the missing inputs pass the provided args.\n-                        match &missing_idxs[..] {\n-                            &[input_idx] => {\n-                                let expected_ty = expected_input_tys[input_idx];\n-                                let input_ty = self.resolve_vars_if_possible(expected_ty);\n-                                let span = if input_idx < provided_arg_count {\n-                                    let arg_span = provided_args[input_idx].span;\n-                                    Span::new(arg_span.lo(), arg_span.hi(), arg_span.ctxt(), None)\n-                                } else {\n-                                    args_span\n-                                };\n-                                let arg_type =\n-                                    if input_ty.references_error() || input_ty.has_infer_types() {\n-                                        \"\".into()\n-                                    } else {\n-                                        format!(\" of type `{}`\", input_ty)\n-                                    };\n-                                labels.push((span, format!(\"an argument{} is missing\", arg_type)));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None => SuggestionText::Provide(false),\n-                                    SuggestionText::Provide(_) => SuggestionText::Provide(true),\n-                                    _ => SuggestionText::DidYouMean,\n-                                };\n-                            }\n-                            &[first_idx, second_idx] => {\n-                                let first_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[first_idx]);\n-                                let second_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[second_idx]);\n-\n-                                let span = if second_idx < provided_arg_count {\n-                                    let first_arg_span = provided_args[first_idx].span;\n-                                    let second_arg_span = provided_args[second_idx].span;\n-                                    Span::new(\n-                                        first_arg_span.lo(),\n-                                        second_arg_span.hi(),\n-                                        first_arg_span.ctxt(),\n-                                        None,\n-                                    )\n-                                } else {\n-                                    args_span\n-                                };\n-                                let any_unnameable = false\n-                                    || first_input_ty.references_error()\n-                                    || first_input_ty.has_infer_types()\n-                                    || second_input_ty.references_error()\n-                                    || second_input_ty.has_infer_types();\n-                                let arg_type = if any_unnameable {\n-                                    \"\".into()\n-                                } else {\n+                        &[first_idx, second_idx] => {\n+                            let (_, first_expected_ty) = formal_and_expected_inputs[first_idx];\n+                            let (_, second_expected_ty) = formal_and_expected_inputs[second_idx];\n+                            let span = if let (Some((_, first_span)), Some((_, second_span))) = (\n+                                provided_arg_tys.get(first_idx.to_provided_idx()),\n+                                provided_arg_tys.get(second_idx.to_provided_idx()),\n+                            ) {\n+                                first_span.to(*second_span)\n+                            } else {\n+                                args_span\n+                            };\n+                            let rendered =\n+                                if !has_error_or_infer([first_expected_ty, second_expected_ty]) {\n                                     format!(\n                                         \" of type `{}` and `{}`\",\n-                                        first_input_ty, second_input_ty\n-                                    )\n-                                };\n-                                labels\n-                                    .push((span, format!(\"two arguments{} are missing\", arg_type)));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None | SuggestionText::Provide(_) => {\n-                                        SuggestionText::Provide(true)\n-                                    }\n-                                    _ => SuggestionText::DidYouMean,\n-                                };\n-                            }\n-                            &[first_idx, second_idx, third_idx] => {\n-                                let first_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[first_idx]);\n-                                let second_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[second_idx]);\n-                                let third_input_ty =\n-                                    self.resolve_vars_if_possible(expected_input_tys[third_idx]);\n-                                let span = if third_idx < provided_arg_count {\n-                                    let first_arg_span = provided_args[first_idx].span;\n-                                    let third_arg_span = provided_args[third_idx].span;\n-                                    Span::new(\n-                                        first_arg_span.lo(),\n-                                        third_arg_span.hi(),\n-                                        first_arg_span.ctxt(),\n-                                        None,\n-                                    )\n-                                } else {\n-                                    args_span\n-                                };\n-                                let any_unnameable = false\n-                                    || first_input_ty.references_error()\n-                                    || first_input_ty.has_infer_types()\n-                                    || second_input_ty.references_error()\n-                                    || second_input_ty.has_infer_types()\n-                                    || third_input_ty.references_error()\n-                                    || third_input_ty.has_infer_types();\n-                                let arg_type = if any_unnameable {\n-                                    \"\".into()\n-                                } else {\n-                                    format!(\n-                                        \" of type `{}`, `{}`, and `{}`\",\n-                                        first_input_ty, second_input_ty, third_input_ty\n-                                    )\n-                                };\n-                                labels.push((\n-                                    span,\n-                                    format!(\"three arguments{} are missing\", arg_type),\n-                                ));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None | SuggestionText::Provide(_) => {\n-                                        SuggestionText::Provide(true)\n-                                    }\n-                                    _ => SuggestionText::DidYouMean,\n-                                };\n-                            }\n-                            missing_idxs => {\n-                                let first_idx = *missing_idxs.first().unwrap();\n-                                let last_idx = *missing_idxs.last().unwrap();\n-                                // NOTE: Because we might be re-arranging arguments, might have extra arguments, etc.\n-                                // It's hard to *really* know where we should provide this error label, so this is a\n-                                // decent heuristic\n-                                let span = if last_idx < provided_arg_count {\n-                                    let first_arg_span = provided_args[first_idx].span;\n-                                    let last_arg_span = provided_args[last_idx].span;\n-                                    Span::new(\n-                                        first_arg_span.lo(),\n-                                        last_arg_span.hi(),\n-                                        first_arg_span.ctxt(),\n-                                        None,\n+                                        first_expected_ty, second_expected_ty\n                                     )\n                                 } else {\n-                                    // Otherwise just label the whole function\n-                                    args_span\n-                                };\n-                                labels.push((span, format!(\"multiple arguments are missing\")));\n-                                suggestion_text = match suggestion_text {\n-                                    SuggestionText::None | SuggestionText::Provide(_) => {\n-                                        SuggestionText::Provide(true)\n-                                    }\n-                                    _ => SuggestionText::DidYouMean,\n+                                    \"\".to_string()\n                                 };\n-                            }\n+                            labels.push((span, format!(\"two arguments{} are missing\", rendered)));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None | SuggestionText::Provide(_) => {\n+                                    SuggestionText::Provide(true)\n+                                }\n+                                _ => SuggestionText::DidYouMean,\n+                            };\n                         }\n-                    }\n-                    Error::Swap(input_idx, other_input_idx, arg_idx, other_arg_idx) => {\n-                        let first_span = provided_args[input_idx].span;\n-                        let second_span = provided_args[other_input_idx].span;\n-\n-                        let first_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[arg_idx]);\n-                        let first_provided_ty = if let Some((ty, _)) = final_arg_types[input_idx] {\n-                            format!(\", found `{}`\", ty)\n-                        } else {\n-                            String::new()\n-                        };\n-                        labels.push((\n-                            first_span,\n-                            format!(\"expected `{}`{}\", first_expected_ty, first_provided_ty),\n-                        ));\n-                        let other_expected_ty =\n-                            self.resolve_vars_if_possible(expected_input_tys[other_arg_idx]);\n-                        let other_provided_ty =\n-                            if let Some((ty, _)) = final_arg_types[other_input_idx] {\n-                                format!(\", found `{}`\", ty)\n+                        &[first_idx, second_idx, third_idx] => {\n+                            let (_, first_expected_ty) = formal_and_expected_inputs[first_idx];\n+                            let (_, second_expected_ty) = formal_and_expected_inputs[second_idx];\n+                            let (_, third_expected_ty) = formal_and_expected_inputs[third_idx];\n+                            let span = if let (Some((_, first_span)), Some((_, third_span))) = (\n+                                provided_arg_tys.get(first_idx.to_provided_idx()),\n+                                provided_arg_tys.get(third_idx.to_provided_idx()),\n+                            ) {\n+                                first_span.to(*third_span)\n                             } else {\n-                                String::new()\n+                                args_span\n                             };\n-                        labels.push((\n-                            second_span,\n-                            format!(\"expected `{}`{}\", other_expected_ty, other_provided_ty),\n-                        ));\n-                        suggestion_text = match suggestion_text {\n-                            SuggestionText::None => SuggestionText::Swap,\n-                            _ => SuggestionText::DidYouMean,\n-                        };\n-                    }\n-                    Error::Permutation(args) => {\n-                        for (dst_arg, dest_input) in args {\n-                            let expected_ty =\n-                                self.resolve_vars_if_possible(expected_input_tys[dst_arg]);\n-                            let provided_ty = if let Some((ty, _)) = final_arg_types[dest_input] {\n-                                format!(\", found `{}`\", ty)\n+                            let rendered = if !has_error_or_infer([\n+                                first_expected_ty,\n+                                second_expected_ty,\n+                                third_expected_ty,\n+                            ]) {\n+                                format!(\n+                                    \" of type `{}`, `{}`, and `{}`\",\n+                                    first_expected_ty, second_expected_ty, third_expected_ty\n+                                )\n                             } else {\n-                                String::new()\n+                                \"\".to_string()\n+                            };\n+                            labels.push((span, format!(\"three arguments{} are missing\", rendered)));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None | SuggestionText::Provide(_) => {\n+                                    SuggestionText::Provide(true)\n+                                }\n+                                _ => SuggestionText::DidYouMean,\n+                            };\n+                        }\n+                        missing_idxs => {\n+                            let first_idx = *missing_idxs.first().unwrap();\n+                            let last_idx = *missing_idxs.last().unwrap();\n+                            // NOTE: Because we might be re-arranging arguments, might have extra arguments, etc.\n+                            // It's hard to *really* know where we should provide this error label, so this is a\n+                            // decent heuristic\n+                            let span = if let (Some((_, first_span)), Some((_, last_span))) = (\n+                                provided_arg_tys.get(first_idx.to_provided_idx()),\n+                                provided_arg_tys.get(last_idx.to_provided_idx()),\n+                            ) {\n+                                first_span.to(*last_span)\n+                            } else {\n+                                args_span\n+                            };\n+                            labels.push((span, format!(\"multiple arguments are missing\")));\n+                            suggestion_text = match suggestion_text {\n+                                SuggestionText::None | SuggestionText::Provide(_) => {\n+                                    SuggestionText::Provide(true)\n+                                }\n+                                _ => SuggestionText::DidYouMean,\n                             };\n-                            labels.push((\n-                                provided_args[dest_input].span,\n-                                format!(\"expected `{}`{}\", expected_ty, provided_ty),\n-                            ));\n                         }\n-\n-                        suggestion_text = match suggestion_text {\n-                            SuggestionText::None => SuggestionText::Reorder,\n-                            _ => SuggestionText::DidYouMean,\n-                        };\n                     }\n                 }\n-            }\n-\n-            // If we have less than 5 things to say, it would be useful to call out exactly what's wrong\n-            if labels.len() <= 5 {\n-                for (span, label) in labels {\n-                    err.span_label(span, label);\n-                }\n-            }\n-\n-            // Call out where the function is defined\n-            label_fn_like(tcx, &mut err, fn_def_id);\n-\n-            // And add a suggestion block for all of the parameters\n-            let suggestion_text = match suggestion_text {\n-                SuggestionText::None => None,\n-                SuggestionText::Provide(plural) => {\n-                    Some(format!(\"provide the argument{}\", if plural { \"s\" } else { \"\" }))\n-                }\n-                SuggestionText::Remove(plural) => {\n-                    Some(format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }))\n-                }\n-                SuggestionText::Swap => Some(\"swap these arguments\".to_string()),\n-                SuggestionText::Reorder => Some(\"reorder these arguments\".to_string()),\n-                SuggestionText::DidYouMean => Some(\"did you mean\".to_string()),\n-            };\n-            if let Some(suggestion_text) = suggestion_text {\n-                let source_map = self.sess().source_map();\n-                let mut suggestion = format!(\n-                    \"{}(\",\n-                    source_map.span_to_snippet(full_call_span).unwrap_or_else(|_| String::new())\n-                );\n-                for (arg_index, input_idx) in matched_inputs.iter().enumerate() {\n-                    let suggestion_text = if let Some(input_idx) = input_idx {\n-                        let arg_span = provided_args[*input_idx].span.source_callsite();\n-                        let arg_text = source_map.span_to_snippet(arg_span).unwrap();\n-                        arg_text\n+                Error::Swap(\n+                    first_provided_idx,\n+                    second_provided_idx,\n+                    first_expected_idx,\n+                    second_expected_idx,\n+                ) => {\n+                    let (first_provided_ty, first_span) = provided_arg_tys[first_provided_idx];\n+                    let (_, first_expected_ty) = formal_and_expected_inputs[first_expected_idx];\n+                    let first_provided_ty_name = if !has_error_or_infer([first_provided_ty]) {\n+                        format!(\", found `{}`\", first_provided_ty)\n                     } else {\n-                        // Propose a placeholder of the correct type\n-                        let expected_ty = expected_input_tys[arg_index];\n-                        let input_ty = self.resolve_vars_if_possible(expected_ty);\n-                        if input_ty.is_unit() {\n-                            \"()\".to_string()\n-                        } else if !input_ty.is_ty_var() {\n-                            format!(\"/* {} */\", input_ty)\n+                        String::new()\n+                    };\n+                    labels.push((\n+                        first_span,\n+                        format!(\"expected `{}`{}\", first_expected_ty, first_provided_ty_name),\n+                    ));\n+\n+                    let (second_provided_ty, second_span) = provided_arg_tys[second_provided_idx];\n+                    let (_, second_expected_ty) = formal_and_expected_inputs[second_expected_idx];\n+                    let second_provided_ty_name = if !has_error_or_infer([second_provided_ty]) {\n+                        format!(\", found `{}`\", second_provided_ty)\n+                    } else {\n+                        String::new()\n+                    };\n+                    labels.push((\n+                        second_span,\n+                        format!(\"expected `{}`{}\", second_expected_ty, second_provided_ty_name),\n+                    ));\n+\n+                    suggestion_text = match suggestion_text {\n+                        SuggestionText::None => SuggestionText::Swap,\n+                        _ => SuggestionText::DidYouMean,\n+                    };\n+                }\n+                Error::Permutation(args) => {\n+                    for (dst_arg, dest_input) in args {\n+                        let (_, expected_ty) = formal_and_expected_inputs[dst_arg];\n+                        let (provided_ty, provided_span) = provided_arg_tys[dest_input];\n+                        let provided_ty_name = if !has_error_or_infer([provided_ty]) {\n+                            format!(\", found `{}`\", provided_ty)\n                         } else {\n-                            \"/* value */\".to_string()\n+                            String::new()\n+                        };\n+                        // FIXME(compiler-errors): Why do we get permutations with the same type?\n+                        if expected_ty != provided_ty {\n+                            labels.push((\n+                                provided_span,\n+                                format!(\"expected `{}`{}\", expected_ty, provided_ty_name),\n+                            ));\n                         }\n-                    };\n-                    suggestion += &suggestion_text;\n-                    if arg_index < minimum_input_count - 1 {\n-                        suggestion += \", \";\n                     }\n+\n+                    suggestion_text = match suggestion_text {\n+                        SuggestionText::None => SuggestionText::Reorder,\n+                        _ => SuggestionText::DidYouMean,\n+                    };\n                 }\n-                suggestion += \")\";\n-                err.span_suggestion_verbose(\n-                    error_span,\n-                    &suggestion_text,\n-                    suggestion,\n-                    Applicability::HasPlaceholders,\n-                );\n             }\n-            err.emit();\n         }\n \n-        for arg in provided_args.iter().skip(minimum_input_count) {\n-            let arg_ty = self.check_expr(&arg);\n+        // If we have less than 5 things to say, it would be useful to call out exactly what's wrong\n+        if labels.len() <= 5 {\n+            for (span, label) in labels {\n+                err.span_label(span, label);\n+            }\n+        }\n \n-            // If the function is c-style variadic, we skipped a bunch of arguments\n-            // so we need to check those, and write out the types\n-            // Ideally this would be folded into the above, for uniform style\n-            // but c-variadic is already a corner case\n-            if c_variadic {\n-                fn variadic_error<'tcx>(\n-                    sess: &'tcx Session,\n-                    span: Span,\n-                    ty: Ty<'tcx>,\n-                    cast_ty: &str,\n-                ) {\n-                    use crate::structured_errors::MissingCastForVariadicArg;\n+        // Call out where the function is defined\n+        label_fn_like(tcx, &mut err, fn_def_id);\n \n-                    MissingCastForVariadicArg { sess, span, ty, cast_ty }.diagnostic().emit();\n+        // And add a suggestion block for all of the parameters\n+        let suggestion_text = match suggestion_text {\n+            SuggestionText::None => None,\n+            SuggestionText::Provide(plural) => {\n+                Some(format!(\"provide the argument{}\", if plural { \"s\" } else { \"\" }))\n+            }\n+            SuggestionText::Remove(plural) => {\n+                Some(format!(\"remove the extra argument{}\", if plural { \"s\" } else { \"\" }))\n+            }\n+            SuggestionText::Swap => Some(\"swap these arguments\".to_string()),\n+            SuggestionText::Reorder => Some(\"reorder these arguments\".to_string()),\n+            SuggestionText::DidYouMean => Some(\"did you mean\".to_string()),\n+        };\n+        if let Some(suggestion_text) = suggestion_text {\n+            let source_map = self.sess().source_map();\n+            let mut suggestion = format!(\n+                \"{}(\",\n+                source_map.span_to_snippet(full_call_span).unwrap_or_else(|_| fn_def_id\n+                    .map_or(\"\".to_string(), |fn_def_id| tcx.item_name(fn_def_id).to_string()))\n+            );\n+            let mut needs_comma = false;\n+            for (expected_idx, provided_idx) in matched_inputs.iter_enumerated() {\n+                if needs_comma {\n+                    suggestion += \", \";\n+                } else {\n+                    needs_comma = true;\n                 }\n-\n-                // There are a few types which get autopromoted when passed via varargs\n-                // in C but we just error out instead and require explicit casts.\n-                let arg_ty = self.structurally_resolved_type(arg.span, arg_ty);\n-                match arg_ty.kind() {\n-                    ty::Float(ty::FloatTy::F32) => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_double\");\n-                    }\n-                    ty::Int(ty::IntTy::I8 | ty::IntTy::I16) | ty::Bool => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_int\");\n-                    }\n-                    ty::Uint(ty::UintTy::U8 | ty::UintTy::U16) => {\n-                        variadic_error(tcx.sess, arg.span, arg_ty, \"c_uint\");\n-                    }\n-                    ty::FnDef(..) => {\n-                        let ptr_ty = self.tcx.mk_fn_ptr(arg_ty.fn_sig(self.tcx));\n-                        let ptr_ty = self.resolve_vars_if_possible(ptr_ty);\n-                        variadic_error(tcx.sess, arg.span, arg_ty, &ptr_ty.to_string());\n+                let suggestion_text =\n+                    if let Some(provided_idx) = provided_idx\n+                    && let (_, provided_span) = provided_arg_tys[*provided_idx]\n+                    && let Ok(arg_text) = source_map.span_to_snippet(provided_span.source_callsite()) {\n+                    arg_text\n+                } else {\n+                    // Propose a placeholder of the correct type\n+                    let (_, expected_ty) = formal_and_expected_inputs[expected_idx];\n+                    if expected_ty.is_unit() {\n+                        \"()\".to_string()\n+                    } else if expected_ty.is_suggestable(tcx) {\n+                        format!(\"/* {} */\", expected_ty)\n+                    } else {\n+                        \"/* value */\".to_string()\n                     }\n-                    _ => {}\n-                }\n+                };\n+                suggestion += &suggestion_text;\n             }\n+            suggestion += \")\";\n+            err.span_suggestion_verbose(\n+                error_span,\n+                &suggestion_text,\n+                suggestion,\n+                Applicability::HasPlaceholders,\n+            );\n         }\n+\n+        err.emit();\n     }\n \n     fn suggested_tuple_wrap("}, {"sha": "c495ad6b842f8bb8056b819e23b3e0869e0ff7c1", "filename": "src/test/ui/argument-suggestions/basic.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fbasic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fbasic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fbasic.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -16,7 +16,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/basic.rs:21:5\n    |\n LL |     extra(\"\");\n-   |     ^^^^^ -- argument unexpected\n+   |     ^^^^^ -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/basic.rs:14:4"}, {"sha": "32b1e15737ab9370bc007fd78b5fe2ffa9e61efd", "filename": "src/test/ui/argument-suggestions/extra_arguments.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fextra_arguments.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/extra_arguments.rs:7:3\n    |\n LL |   empty(\"\");\n-   |   ^^^^^ -- argument unexpected\n+   |   ^^^^^ -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:1:4\n@@ -18,7 +18,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/extra_arguments.rs:9:3\n    |\n LL |   one_arg(1, 1);\n-   |   ^^^^^^^    - argument unexpected\n+   |   ^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:2:4\n@@ -34,7 +34,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/extra_arguments.rs:10:3\n    |\n LL |   one_arg(1, \"\");\n-   |   ^^^^^^^    -- argument unexpected\n+   |   ^^^^^^^    -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:2:4\n@@ -50,9 +50,9 @@ error[E0061]: this function takes 1 argument but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:11:3\n    |\n LL |   one_arg(1, \"\", 1.0);\n-   |   ^^^^^^^    --  --- argument unexpected\n+   |   ^^^^^^^    --  --- argument of type `{float}` unexpected\n    |              |\n-   |              argument unexpected\n+   |              argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:2:4\n@@ -68,7 +68,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:13:3\n    |\n LL |   two_arg_same(1, 1, 1);\n-   |   ^^^^^^^^^^^^       - argument unexpected\n+   |   ^^^^^^^^^^^^       - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -84,7 +84,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:14:3\n    |\n LL |   two_arg_same(1, 1, 1.0);\n-   |   ^^^^^^^^^^^^       --- argument unexpected\n+   |   ^^^^^^^^^^^^       --- argument of type `{float}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -100,7 +100,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:16:3\n    |\n LL |   two_arg_diff(1, 1, \"\");\n-   |   ^^^^^^^^^^^^    - argument of type `&str` unexpected\n+   |   ^^^^^^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -116,7 +116,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:17:3\n    |\n LL |   two_arg_diff(1, \"\", \"\");\n-   |   ^^^^^^^^^^^^        -- argument unexpected\n+   |   ^^^^^^^^^^^^        -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -132,9 +132,9 @@ error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n   --> $DIR/extra_arguments.rs:18:3\n    |\n LL |   two_arg_diff(1, 1, \"\", \"\");\n-   |   ^^^^^^^^^^^^    -      -- argument unexpected\n+   |   ^^^^^^^^^^^^    -      -- argument of type `&'static str` unexpected\n    |                   |\n-   |                   argument of type `&str` unexpected\n+   |                   argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -150,9 +150,9 @@ error[E0061]: this function takes 2 arguments but 4 arguments were supplied\n   --> $DIR/extra_arguments.rs:19:3\n    |\n LL |   two_arg_diff(1, \"\", 1, \"\");\n-   |   ^^^^^^^^^^^^        -  -- argument unexpected\n+   |   ^^^^^^^^^^^^        -  -- argument of type `&'static str` unexpected\n    |                       |\n-   |                       argument unexpected\n+   |                       argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -168,7 +168,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:22:3\n    |\n LL |   two_arg_same(1, 1,     \"\");\n-   |   ^^^^^^^^^^^^           -- argument unexpected\n+   |   ^^^^^^^^^^^^           -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -184,7 +184,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/extra_arguments.rs:23:3\n    |\n LL |   two_arg_diff(1, 1,     \"\");\n-   |   ^^^^^^^^^^^^    - argument of type `&str` unexpected\n+   |   ^^^^^^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4\n@@ -203,7 +203,7 @@ LL |   two_arg_same(\n    |   ^^^^^^^^^^^^\n ...\n LL |     \"\"\n-   |     -- argument unexpected\n+   |     -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:3:4\n@@ -222,7 +222,7 @@ LL |   two_arg_diff(\n    |   ^^^^^^^^^^^^\n LL |     1,\n LL |     1,\n-   |     - argument of type `&str` unexpected\n+   |     - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/extra_arguments.rs:4:4"}, {"sha": "9589e919c0a1f15f0ad9359949eb8f75f92d35bd", "filename": "src/test/ui/argument-suggestions/issue-97484.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-97484.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-97484.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-97484.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,21 +2,20 @@ error[E0061]: this function takes 4 arguments but 7 arguments were supplied\n   --> $DIR/issue-97484.rs:12:5\n    |\n LL |     foo(&&A, B, C, D, E, F, G);\n-   |     ^^^      -  -        - argument unexpected\n+   |     ^^^      -  -        - argument of type `F` unexpected\n    |              |  |\n-   |              |  argument of type `&E` unexpected\n-   |              argument of type `D` unexpected\n+   |              |  argument of type `C` unexpected\n+   |              argument of type `B` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-97484.rs:9:4\n    |\n LL | fn foo(a: &A, d: D, e: &E, g: G) {}\n    |    ^^^ -----  ----  -----  ----\n-help: consider removing the ``\n-   |\n-LL -     foo(&&A, B, C, D, E, F, G);\n-LL +     foo(&&A, B, C, D, E, F, G);\n+help: consider borrowing here\n    |\n+LL |     foo(&&A, B, C, D, &E, F, G);\n+   |                       ~~\n help: remove the extra arguments\n    |\n LL |     foo(&&A, D, /* &E */, G);"}, {"sha": "a52a30d7884f899f2ea3c8be9aa17444fd9962ab", "filename": "src/test/ui/argument-suggestions/mixed_cases.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fmixed_cases.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fargument-suggestions%2Fmixed_cases.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fmixed_cases.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/mixed_cases.rs:10:3\n    |\n LL |   two_args(1, \"\", X {});\n-   |   ^^^^^^^^    --  ---- argument unexpected\n+   |   ^^^^^^^^    --  ---- argument of type `X` unexpected\n    |               |\n    |               expected `f32`, found `&str`\n    |\n@@ -20,9 +20,9 @@ error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n   --> $DIR/mixed_cases.rs:11:3\n    |\n LL |   three_args(1, \"\", X {}, \"\");\n-   |   ^^^^^^^^^^    --  ----  -- argument unexpected\n+   |   ^^^^^^^^^^    --  ----  -- argument of type `&'static str` unexpected\n    |                 |   |\n-   |                 |   argument of type `&str` unexpected\n+   |                 |   argument of type `X` unexpected\n    |                 an argument of type `f32` is missing\n    |\n note: function defined here\n@@ -58,7 +58,7 @@ error[E0308]: arguments to this function are incorrect\n   --> $DIR/mixed_cases.rs:17:3\n    |\n LL |   three_args(1, \"\", X {});\n-   |   ^^^^^^^^^^    --  ---- argument of type `&str` unexpected\n+   |   ^^^^^^^^^^    --  ---- argument of type `X` unexpected\n    |                 |\n    |                 an argument of type `f32` is missing\n    |"}, {"sha": "2307f52c93bceb8aa8f0fffab4c8806998ed0092", "filename": "src/test/ui/error-codes/E0057.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ferror-codes%2FE0057.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ferror-codes%2FE0057.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0057.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -18,7 +18,7 @@ error[E0057]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/E0057.rs:5:13\n    |\n LL |     let c = f(2, 3);\n-   |             ^    - argument unexpected\n+   |             ^    - argument of type `{integer}` unexpected\n    |\n note: closure defined here\n   --> $DIR/E0057.rs:2:13"}, {"sha": "df8c2f739108db485ed7b8a1ed782e532fd4a545", "filename": "src/test/ui/issues/issue-26094.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fissues%2Fissue-26094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fissues%2Fissue-26094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26094.rs?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -1,6 +1,6 @@\n macro_rules! some_macro {\n     ($other: expr) => ({\n-        $other(None) //~ NOTE argument unexpected\n+        $other(None) //~ NOTE argument of type `Option<_>` unexpected\n     })\n }\n "}, {"sha": "881a6e538ee44621b9d6b7e23f9d671498a264e2", "filename": "src/test/ui/issues/issue-26094.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26094.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/issue-26094.rs:10:17\n    |\n LL |         $other(None)\n-   |                ---- argument unexpected\n+   |                ---- argument of type `Option<_>` unexpected\n ...\n LL |     some_macro!(some_function);\n    |                 ^^^^^^^^^^^^^"}, {"sha": "aab19a699ace08770c7e3b89e40cf6fa2d1a80a0", "filename": "src/test/ui/issues/issue-4935.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-4935.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/issue-4935.rs:5:13\n    |\n LL | fn main() { foo(5, 6) }\n-   |             ^^^    - argument unexpected\n+   |             ^^^    - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-4935.rs:3:4"}, {"sha": "57662e1e265aec21e69880ffe6211b59168b8c6e", "filename": "src/test/ui/methods/method-call-err-msg.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-err-msg.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 0 arguments but 1 argument was supplied\n   --> $DIR/method-call-err-msg.rs:13:7\n    |\n LL |     x.zero(0)\n-   |       ^^^^ - argument unexpected\n+   |       ^^^^ - argument of type `{integer}` unexpected\n    |\n note: associated function defined here\n   --> $DIR/method-call-err-msg.rs:5:8"}, {"sha": "cb93a7ad9008d871314e3364cd02d3ce9fd3ef37", "filename": "src/test/ui/mismatched_types/overloaded-calls-bad.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Foverloaded-calls-bad.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -32,7 +32,7 @@ error[E0057]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/overloaded-calls-bad.rs:31:15\n    |\n LL |     let ans = s(\"burma\", \"shave\");\n-   |               ^ -------  ------- argument unexpected\n+   |               ^ -------  ------- argument of type `&'static str` unexpected\n    |                 |\n    |                 expected `isize`, found `&str`\n    |"}, {"sha": "e676d7372e89133121c2128a816623b963703b49", "filename": "src/test/ui/span/issue-34264.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-34264.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -54,7 +54,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/issue-34264.rs:7:5\n    |\n LL |     foo(Some(42), 2, \"\");\n-   |     ^^^              -- argument unexpected\n+   |     ^^^              -- argument of type `&'static str` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-34264.rs:1:4\n@@ -84,7 +84,7 @@ error[E0061]: this function takes 2 arguments but 3 arguments were supplied\n   --> $DIR/issue-34264.rs:10:5\n    |\n LL |     bar(1, 2, 3);\n-   |     ^^^       - argument unexpected\n+   |     ^^^       - argument of type `{integer}` unexpected\n    |\n note: function defined here\n   --> $DIR/issue-34264.rs:3:4"}, {"sha": "805c75f464cd558200b0ec23d388fddd8cbd890a", "filename": "src/test/ui/suggestions/args-instead-of-tuple-errors.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fargs-instead-of-tuple-errors.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this enum variant takes 1 argument but 2 arguments were supplied\n   --> $DIR/args-instead-of-tuple-errors.rs:6:34\n    |\n LL |     let _: Option<(i32, bool)> = Some(1, 2);\n-   |                                  ^^^^ -  - argument unexpected\n+   |                                  ^^^^ -  - argument of type `{integer}` unexpected\n    |                                       |\n    |                                       expected tuple, found integer\n    |\n@@ -22,7 +22,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/args-instead-of-tuple-errors.rs:8:5\n    |\n LL |     int_bool(1, 2);\n-   |     ^^^^^^^^ -  - argument unexpected\n+   |     ^^^^^^^^ -  - argument of type `{integer}` unexpected\n    |              |\n    |              expected tuple, found integer\n    |"}, {"sha": "2733fb3149b55d1f8fcf87d9ca62091987fb4c6f", "filename": "src/test/ui/tuple/wrong_argument_ice-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-3.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/wrong_argument_ice-3.rs:9:16\n    |\n LL |         groups.push(new_group, vec![process]);\n-   |                ^^^^ ---------  ------------- argument unexpected\n+   |                ^^^^ ---------  ------------- argument of type `Vec<&Process>` unexpected\n    |                     |\n    |                     expected tuple, found struct `Vec`\n    |"}, {"sha": "3645d11842f7d4dc605dd34f067cb0ea01837975", "filename": "src/test/ui/tuple/wrong_argument_ice-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftuple%2Fwrong_argument_ice-4.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -6,7 +6,7 @@ LL |       (|| {})(|| {\n LL | |\n LL | |         let b = 1;\n LL | |     });\n-   | |_____- argument unexpected\n+   | |_____- argument of type `[closure@$DIR/wrong_argument_ice-4.rs:2:13: 5:6]` unexpected\n    |\n note: closure defined here\n   --> $DIR/wrong_argument_ice-4.rs:2:6"}, {"sha": "fcac6c495c4b2705eeb71a01775c56bcc789eca3", "filename": "src/test/ui/type/type-ascription-instead-of-initializer.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-initializer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-initializer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-ascription-instead-of-initializer.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -11,7 +11,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/type-ascription-instead-of-initializer.rs:2:12\n    |\n LL |     let x: Vec::with_capacity(10, 20);\n-   |            ^^^^^^^^^^^^^^^^^^     -- argument unexpected\n+   |            ^^^^^^^^^^^^^^^^^^     -- argument of type `{integer}` unexpected\n    |\n note: associated function defined here\n   --> $SRC_DIR/alloc/src/vec/mod.rs:LL:COL"}, {"sha": "703032a83223154ff916a6292876b5497bae7819", "filename": "src/test/ui/typeck/remove-extra-argument.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftypeck%2Fremove-extra-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftypeck%2Fremove-extra-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fremove-extra-argument.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this function takes 1 argument but 2 arguments were supplied\n   --> $DIR/remove-extra-argument.rs:6:5\n    |\n LL |     l(vec![], vec![])\n-   |     ^         ------ argument unexpected\n+   |     ^         ------ argument of type `Vec<_>` unexpected\n    |\n note: function defined here\n   --> $DIR/remove-extra-argument.rs:3:4"}, {"sha": "f72082d53016729e3b45b3f68205382ac45b016e", "filename": "src/test/ui/typeck/struct-enum-wrong-args.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftypeck%2Fstruct-enum-wrong-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dee9aed07d3e4d54d1d4c56474a9630e4cd3496f/src%2Ftest%2Fui%2Ftypeck%2Fstruct-enum-wrong-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fstruct-enum-wrong-args.stderr?ref=dee9aed07d3e4d54d1d4c56474a9630e4cd3496f", "patch": "@@ -2,7 +2,7 @@ error[E0061]: this enum variant takes 1 argument but 2 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:6:13\n    |\n LL |     let _ = Some(3, 2);\n-   |             ^^^^    - argument unexpected\n+   |             ^^^^    - argument of type `{integer}` unexpected\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n@@ -18,9 +18,9 @@ error[E0061]: this enum variant takes 1 argument but 3 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:7:13\n    |\n LL |     let _ = Ok(3, 6, 2);\n-   |             ^^    -  - argument unexpected\n+   |             ^^    -  - argument of type `{integer}` unexpected\n    |                   |\n-   |                   argument unexpected\n+   |                   argument of type `{integer}` unexpected\n    |\n note: tuple variant defined here\n   --> $SRC_DIR/core/src/result.rs:LL:COL\n@@ -68,7 +68,7 @@ error[E0061]: this struct takes 1 argument but 2 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:10:13\n    |\n LL |     let _ = Wrapper(5, 2);\n-   |             ^^^^^^^    - argument unexpected\n+   |             ^^^^^^^    - argument of type `{integer}` unexpected\n    |\n note: tuple struct defined here\n   --> $DIR/struct-enum-wrong-args.rs:2:8\n@@ -116,7 +116,7 @@ error[E0061]: this struct takes 2 arguments but 3 arguments were supplied\n   --> $DIR/struct-enum-wrong-args.rs:13:13\n    |\n LL |     let _ = DoubleWrapper(5, 2, 7);\n-   |             ^^^^^^^^^^^^^       - argument unexpected\n+   |             ^^^^^^^^^^^^^       - argument of type `{integer}` unexpected\n    |\n note: tuple struct defined here\n   --> $DIR/struct-enum-wrong-args.rs:3:8"}]}