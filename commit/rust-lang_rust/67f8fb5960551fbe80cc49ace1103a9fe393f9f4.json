{"sha": "67f8fb5960551fbe80cc49ace1103a9fe393f9f4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZjhmYjU5NjA1NTFmYmU4MGNjNDlhY2UxMTAzYTlmZTM5M2Y5ZjQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-12-11T22:01:39Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-12-12T09:36:00Z"}, "message": "Use `Lrc<Vec<TokenStream>>` instead of `RcVec<TokenStream>`.\n\nThis shrinks:\n- ThinTokenStream: 16 to 8 bytes\n- TokenTree: 32 to 24 bytes\n- TokenStream: 40 to 32 bytes\n\nThe only downside is that in a couple of places this requires using\n`to_vec()` (which allocates) instead of `sub_slice()`. But those places\nare rarely executed, so it doesn't hurt perf.\n\nOverall, this reduces instruction counts on numerous benchmarks by up to\n3%.", "tree": {"sha": "5e0c1adf5a0f6aaa75554ceb862e16682eb1dc51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0c1adf5a0f6aaa75554ceb862e16682eb1dc51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67f8fb5960551fbe80cc49ace1103a9fe393f9f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67f8fb5960551fbe80cc49ace1103a9fe393f9f4", "html_url": "https://github.com/rust-lang/rust/commit/67f8fb5960551fbe80cc49ace1103a9fe393f9f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67f8fb5960551fbe80cc49ace1103a9fe393f9f4/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08857c1c5743133ac309820640ef0755c82fedb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/08857c1c5743133ac309820640ef0755c82fedb7", "html_url": "https://github.com/rust-lang/rust/commit/08857c1c5743133ac309820640ef0755c82fedb7"}], "stats": {"total": 34, "additions": 17, "deletions": 17}, "files": [{"sha": "da7f5029d9db64f23de3ac8d1960fb9b03ddd29c", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/67f8fb5960551fbe80cc49ace1103a9fe393f9f4/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67f8fb5960551fbe80cc49ace1103a9fe393f9f4/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=67f8fb5960551fbe80cc49ace1103a9fe393f9f4", "patch": "@@ -28,8 +28,8 @@ use ext::tt::{macro_parser, quoted};\n use parse::Directory;\n use parse::token::{self, DelimToken, Token};\n use print::pprust;\n+use rustc_data_structures::sync::Lrc;\n use serialize::{Decoder, Decodable, Encoder, Encodable};\n-use util::RcVec;\n \n use std::borrow::Cow;\n use std::{fmt, iter, mem};\n@@ -160,7 +160,7 @@ pub struct TokenStream {\n \n // `TokenStream` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 40);\n+static_assert!(MEM_SIZE_OF_TOKEN_STREAM: mem::size_of::<TokenStream>() == 32);\n \n impl TokenStream {\n     /// Given a `TokenStream` with a `Stream` of only two arguments, return a new `TokenStream`\n@@ -194,7 +194,7 @@ impl TokenStream {\n                 new_slice.extend_from_slice(parts.0);\n                 new_slice.push(comma);\n                 new_slice.extend_from_slice(parts.1);\n-                let slice = RcVec::new(new_slice);\n+                let slice = Lrc::new(new_slice);\n                 return Some((TokenStream { kind: TokenStreamKind::Stream(slice) }, sp));\n             }\n         }\n@@ -207,7 +207,7 @@ enum TokenStreamKind {\n     Empty,\n     Tree(TokenTree),\n     JointTree(TokenTree),\n-    Stream(RcVec<TokenStream>),\n+    Stream(Lrc<Vec<TokenStream>>),\n }\n \n impl From<TokenTree> for TokenStream {\n@@ -246,7 +246,7 @@ impl Extend<TokenStream> for TokenStream {\n                 vec.push(TokenStream { kind });\n                 vec\n             }\n-            TokenStreamKind::Stream(rc_vec) => match RcVec::try_unwrap(rc_vec) {\n+            TokenStreamKind::Stream(rc_vec) => match Lrc::try_unwrap(rc_vec) {\n                 Ok(mut vec) => {\n                     // Extend in place using the existing capacity if possible.\n                     // This is the fast path for libraries like `quote` that\n@@ -277,7 +277,7 @@ impl Extend<TokenStream> for TokenStream {\n         *self = match tts.len() {\n             0 => TokenStream::empty(),\n             1 => tts.pop().unwrap(),\n-            _ => TokenStream::concat_rc_vec(RcVec::new_preserving_capacity(tts)),\n+            _ => TokenStream::concat_rc_vec(Lrc::new(tts)),\n         };\n     }\n }\n@@ -314,11 +314,11 @@ impl TokenStream {\n         match streams.len() {\n             0 => TokenStream::empty(),\n             1 => streams.pop().unwrap(),\n-            _ => TokenStream::concat_rc_vec(RcVec::new(streams)),\n+            _ => TokenStream::concat_rc_vec(Lrc::new(streams)),\n         }\n     }\n \n-    fn concat_rc_vec(streams: RcVec<TokenStream>) -> TokenStream {\n+    fn concat_rc_vec(streams: Lrc<Vec<TokenStream>>) -> TokenStream {\n         TokenStream { kind: TokenStreamKind::Stream(streams) }\n     }\n \n@@ -483,7 +483,7 @@ impl TokenStreamBuilder {\n             match len {\n                 1 => {}\n                 2 => self.0.push(streams[0].clone().into()),\n-                _ => self.0.push(TokenStream::concat_rc_vec(streams.sub_slice(0 .. len - 1))),\n+                _ => self.0.push(TokenStream::concat_rc_vec( Lrc::new(streams[0 .. len - 1].to_vec()))),\n             }\n             self.push_all_but_last_tree(&streams[len - 1])\n         }\n@@ -495,7 +495,7 @@ impl TokenStreamBuilder {\n             match len {\n                 1 => {}\n                 2 => self.0.push(streams[1].clone().into()),\n-                _ => self.0.push(TokenStream::concat_rc_vec(streams.sub_slice(1 .. len))),\n+                _ => self.0.push(TokenStream::concat_rc_vec(Lrc::new(streams[1 .. len].to_vec()))),\n             }\n             self.push_all_but_first_tree(&streams[0])\n         }\n@@ -515,13 +515,13 @@ enum CursorKind {\n \n #[derive(Clone)]\n struct StreamCursor {\n-    stream: RcVec<TokenStream>,\n+    stream: Lrc<Vec<TokenStream>>,\n     index: usize,\n-    stack: Vec<(RcVec<TokenStream>, usize)>,\n+    stack: Vec<(Lrc<Vec<TokenStream>>, usize)>,\n }\n \n impl StreamCursor {\n-    fn new(stream: RcVec<TokenStream>) -> Self {\n+    fn new(stream: Lrc<Vec<TokenStream>>) -> Self {\n         StreamCursor { stream: stream, index: 0, stack: Vec::new() }\n     }\n \n@@ -544,7 +544,7 @@ impl StreamCursor {\n         }\n     }\n \n-    fn insert(&mut self, stream: RcVec<TokenStream>) {\n+    fn insert(&mut self, stream: Lrc<Vec<TokenStream>>) {\n         self.stack.push((mem::replace(&mut self.stream, stream),\n                          mem::replace(&mut self.index, 0)));\n     }\n@@ -656,7 +656,7 @@ impl Cursor {\n /// `ThinTokenStream` is smaller, but needs to allocate to represent a single `TokenTree`.\n /// We must use `ThinTokenStream` in `TokenTree::Delimited` to avoid infinite size due to recursion.\n #[derive(Debug, Clone)]\n-pub struct ThinTokenStream(Option<RcVec<TokenStream>>);\n+pub struct ThinTokenStream(Option<Lrc<Vec<TokenStream>>>);\n \n impl ThinTokenStream {\n     pub fn stream(&self) -> TokenStream {\n@@ -668,8 +668,8 @@ impl From<TokenStream> for ThinTokenStream {\n     fn from(stream: TokenStream) -> ThinTokenStream {\n         ThinTokenStream(match stream.kind {\n             TokenStreamKind::Empty => None,\n-            TokenStreamKind::Tree(tree) => Some(RcVec::new(vec![tree.into()])),\n-            TokenStreamKind::JointTree(tree) => Some(RcVec::new(vec![tree.joint()])),\n+            TokenStreamKind::Tree(tree) => Some(Lrc::new(vec![tree.into()])),\n+            TokenStreamKind::JointTree(tree) => Some(Lrc::new(vec![tree.joint()])),\n             TokenStreamKind::Stream(stream) => Some(stream),\n         })\n     }"}]}