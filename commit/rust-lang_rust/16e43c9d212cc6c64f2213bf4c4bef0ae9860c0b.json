{"sha": "16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2ZTQzYzlkMjEyY2M2YzY0ZjIyMTNiZjRjNGJlZjBhZTk4NjBjMGI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-29T14:33:34Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-29T14:36:17Z"}, "message": "Fix unsize coercions and the size_of_val and min_align_of_val intrinsics for custom dst's", "tree": {"sha": "9b01b5ac80c1a1cca792f290ec4749744339da65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b01b5ac80c1a1cca792f290ec4749744339da65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "html_url": "https://github.com/rust-lang/rust/commit/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f2ca706c21fef0cdc22f218e95164a9266aa0f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2ca706c21fef0cdc22f218e95164a9266aa0f9", "html_url": "https://github.com/rust-lang/rust/commit/8f2ca706c21fef0cdc22f218e95164a9266aa0f9"}], "stats": {"total": 330, "additions": 244, "deletions": 86}, "files": [{"sha": "a3ab76232873729ef6e783fb3d8e3db285017587", "filename": "example/mini_core.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/example%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/example%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -12,6 +12,7 @@ pub trait Unsize<T: ?Sized> {}\n pub trait CoerceUnsized<T> {}\n \n impl<'a, 'b: 'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n "}, {"sha": "c4140ceaf1ec61b0e424a5250a4943026c814f04", "filename": "example/mini_core_hello_world.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/example%2Fmini_core_hello_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/example%2Fmini_core_hello_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fmini_core_hello_world.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -151,6 +151,10 @@ fn main() {\n             pointer: 0 as *const &str,\n             _marker: PhantomData,\n         } as Unique<dyn SomeTrait>;\n+\n+        struct MyDst<T: ?Sized>(T);\n+\n+        intrinsics::size_of_val(&MyDst([0u8; 4]) as &MyDst<[u8]>);\n     }\n \n     let _ = NoisyDrop {"}, {"sha": "433334aa41754aab942914043b01d855e6bdef52", "filename": "src/common.rs", "status": "modified", "additions": 1, "deletions": 63, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcommon.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -221,69 +221,7 @@ impl<'tcx> CValue<'tcx> {\n     }\n \n     pub fn unsize_value<'a>(self, fx: &mut FunctionCx<'a, 'tcx, impl Backend>, dest: CPlace<'tcx>) {\n-        if self.layout().ty == dest.layout().ty {\n-            dest.write_cvalue(fx, self); // FIXME this shouldn't happen (rust-lang/rust#53602)\n-            return;\n-        }\n-        match &self.layout().ty.sty {\n-            ty::Ref(_, ty, _) | ty::RawPtr(TypeAndMut { ty, mutbl: _ }) => {\n-                let (ptr, extra) = match dest.layout().ty.builtin_deref(true).unwrap().ty.sty {\n-                    ty::Slice(slice_elem_ty) => match ty.sty {\n-                        ty::Array(array_elem_ty, size) => {\n-                            assert_eq!(slice_elem_ty, array_elem_ty);\n-                            let ptr = self.load_value(fx);\n-                            let extra = fx\n-                                .bcx\n-                                .ins()\n-                                .iconst(fx.pointer_type, size.unwrap_usize(fx.tcx) as i64);\n-                            (ptr, extra)\n-                        }\n-                        _ => bug!(\"unsize non array {:?} to slice\", ty),\n-                    },\n-                    ty::Dynamic(data, _) => match ty.sty {\n-                        ty::Dynamic(_, _) => self.load_value_pair(fx),\n-                        _ => {\n-                            let ptr = self.load_value(fx);\n-                            let vtable = crate::vtable::get_vtable(fx, ty, data.principal());\n-                            (ptr, vtable)\n-                        }\n-                    },\n-                    _ => bug!(\n-                        \"unsize of type {:?} to {:?}\",\n-                        self.layout().ty,\n-                        dest.layout().ty\n-                    ),\n-                };\n-                dest.write_cvalue(fx, CValue::ByValPair(ptr, extra, dest.layout()));\n-            }\n-            _ => {\n-                assert!(!self.layout().ty.is_enum(), \"Tried to unsize enum\");\n-                let field_count = self.layout().fields.count();\n-                let mut found_unsize_field = false;\n-                for idx in 0..field_count {\n-                    let field_dest = dest.place_field(fx, mir::Field::new(idx));\n-                    let field_src = self.value_field(fx, mir::Field::new(idx));\n-                    if field_src.layout().ty.is_phantom_data() {\n-                        // Ignore PhantomData so for example `Unique<()>` can coerce to `Unique<Debug>`\n-                        //\n-                        // ```rust\n-                        // struct Unique<T: ?Sized> {\n-                        //     pointer: NonZero<*const T>,\n-                        //     _marker: PhantomData<T>,\n-                        // }\n-                        // ```\n-                        continue;\n-                    }\n-                    if field_src.layout().ty != field_dest.layout().ty {\n-                        assert!(!found_unsize_field);\n-                        found_unsize_field = true;\n-                        field_src.unsize_value(fx, field_dest);\n-                    } else {\n-                        field_dest.write_cvalue(fx, field_src);\n-                    }\n-                }\n-            }\n-        }\n+        crate::unsize::coerce_unsized_into(fx, self, dest);\n     }\n \n     pub fn const_val<'a>("}, {"sha": "62800132dff5bde1ff424257e44d77bff5402cbd", "filename": "src/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -153,18 +153,15 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         size_of_val, <T> (c ptr) {\n             let layout = fx.layout_of(T);\n-            let size = match &layout.ty.sty {\n-                _ if !layout.is_unsized() => fx\n+            let size = if layout.is_unsized() {\n+                let (_ptr, info) = ptr.load_value_pair(fx);\n+                let (size, _align) = crate::unsize::size_and_align_of_dst(fx, layout.ty, info);\n+                size\n+            } else {\n+                fx\n                     .bcx\n                     .ins()\n-                    .iconst(fx.pointer_type, layout.size.bytes() as i64),\n-                ty::Slice(elem) => {\n-                    let len = ptr.load_value_pair(fx).1;\n-                    let elem_size = fx.layout_of(elem).size.bytes();\n-                    fx.bcx.ins().imul_imm(len, elem_size as i64)\n-                }\n-                ty::Dynamic(..) => crate::vtable::size_of_obj(fx, ptr),\n-                ty => bug!(\"size_of_val for unknown unsized type {:?}\", ty),\n+                    .iconst(fx.pointer_type, layout.size.bytes() as i64)\n             };\n             ret.write_cvalue(fx, CValue::ByVal(size, usize_layout));\n         };\n@@ -175,17 +172,15 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         };\n         min_align_of_val, <T> (c ptr) {\n             let layout = fx.layout_of(T);\n-            let align = match &layout.ty.sty {\n-                _ if !layout.is_unsized() => fx\n+            let align = if layout.is_unsized() {\n+                let (_ptr, info) = ptr.load_value_pair(fx);\n+                let (_size, align) = crate::unsize::size_and_align_of_dst(fx, layout.ty, info);\n+                align\n+            } else {\n+                fx\n                     .bcx\n                     .ins()\n-                    .iconst(fx.pointer_type, layout.align.abi.bytes() as i64),\n-                ty::Slice(elem) => {\n-                    let align = fx.layout_of(elem).align.abi.bytes() as i64;\n-                    fx.bcx.ins().iconst(fx.pointer_type, align)\n-                }\n-                ty::Dynamic(..) => crate::vtable::min_align_of_obj(fx, ptr),\n-                ty => unimplemented!(\"min_align_of_val for {:?}\", ty),\n+                    .iconst(fx.pointer_type, layout.align.abi.bytes() as i64)\n             };\n             ret.write_cvalue(fx, CValue::ByVal(align, usize_layout));\n         };"}, {"sha": "a9a6895d46b946a63614fb055d6714ea50c68d86", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -51,6 +51,7 @@ mod metadata;\n mod pretty_clif;\n mod trap;\n mod unimpl;\n+mod unsize;\n mod vtable;\n \n mod prelude {"}, {"sha": "f8f918fa8aa26255ac9dfdf6706ad0582a1afef6", "filename": "src/unsize.rs", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funsize.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -0,0 +1,221 @@\n+use crate::prelude::*;\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/base.rs#L159-L307\n+\n+/// Retrieve the information we are losing (making dynamic) in an unsizing\n+/// adjustment.\n+///\n+/// The `old_info` argument is a bit funny. It is intended for use\n+/// in an upcast, where the new vtable for an object will be derived\n+/// from the old one.\n+pub fn unsized_info<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    source: Ty<'tcx>,\n+    target: Ty<'tcx>,\n+    old_info: Option<Value>,\n+) -> Value {\n+    let (source, target) = fx.tcx.struct_lockstep_tails(source, target);\n+    match (&source.sty, &target.sty) {\n+        (&ty::Array(_, len), &ty::Slice(_)) => {\n+            fx.bcx.ins().iconst(fx.pointer_type, len.unwrap_usize(fx.tcx) as i64)\n+        }\n+        (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n+            // For now, upcasts are limited to changes in marker\n+            // traits, and hence never actually require an actual\n+            // change to the vtable.\n+            old_info.expect(\"unsized_info: missing old info for trait upcast\")\n+        }\n+        (_, &ty::Dynamic(ref data, ..)) => {\n+            crate::vtable::get_vtable(fx, source, data.principal())\n+        }\n+        _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\",\n+                  source,\n+                  target),\n+    }\n+}\n+\n+/// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n+pub fn unsize_thin_ptr<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    src: Value,\n+    src_ty: Ty<'tcx>,\n+    dst_ty: Ty<'tcx>\n+) -> (Value, Value) {\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::Ref(_, a, _),\n+         &ty::Ref(_, b, _)) |\n+        (&ty::Ref(_, a, _),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) |\n+        (&ty::RawPtr(ty::TypeAndMut { ty: a, .. }),\n+         &ty::RawPtr(ty::TypeAndMut { ty: b, .. })) => {\n+            assert!(!fx.layout_of(a).is_unsized());\n+            (src, unsized_info(fx, a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) if def_a.is_box() && def_b.is_box() => {\n+            let (a, b) = (src_ty.boxed_ty(), dst_ty.boxed_ty());\n+            assert!(!fx.layout_of(a).is_unsized());\n+            (src, unsized_info(fx, a, b, None))\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            let src_layout = fx.layout_of(src_ty);\n+            let dst_layout = fx.layout_of(dst_ty);\n+            let mut result = None;\n+            for i in 0..src_layout.fields.count() {\n+                let src_f = src_layout.field(fx, i);\n+                assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n+                assert_eq!(dst_layout.fields.offset(i).bytes(), 0);\n+                if src_f.is_zst() {\n+                    continue;\n+                }\n+                assert_eq!(src_layout.size, src_f.size);\n+\n+                let dst_f = dst_layout.field(fx, i);\n+                assert_ne!(src_f.ty, dst_f.ty);\n+                assert_eq!(result, None);\n+                result = Some(unsize_thin_ptr(fx, src, src_f.ty, dst_f.ty));\n+            }\n+            result.unwrap()\n+        }\n+        _ => bug!(\"unsize_thin_ptr: called on bad types\"),\n+    }\n+}\n+\n+/// Coerce `src`, which is a reference to a value of type `src_ty`,\n+/// to a value of type `dst_ty` and store the result in `dst`\n+pub fn coerce_unsized_into<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    src: CValue<'tcx>,\n+    dst: CPlace<'tcx>,\n+)  {\n+    let src_ty = src.layout().ty;\n+    let dst_ty = dst.layout().ty;\n+    let mut coerce_ptr = || {\n+        let (base, info) = if fx.layout_of(src.layout().ty.builtin_deref(true).unwrap().ty).is_unsized() {\n+            // fat-ptr to fat-ptr unsize preserves the vtable\n+            // i.e., &'a fmt::Debug+Send => &'a fmt::Debug\n+            src.load_value_pair(fx)\n+        } else {\n+            let base = src.load_value(fx);\n+            unsize_thin_ptr(fx, base, src_ty, dst_ty)\n+        };\n+        dst.write_cvalue(fx, CValue::ByValPair(base, info, dst.layout()));\n+    };\n+    match (&src_ty.sty, &dst_ty.sty) {\n+        (&ty::Ref(..), &ty::Ref(..)) |\n+        (&ty::Ref(..), &ty::RawPtr(..)) |\n+        (&ty::RawPtr(..), &ty::RawPtr(..)) => {\n+            coerce_ptr()\n+        }\n+        (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => {\n+            assert_eq!(def_a, def_b);\n+\n+            for i in 0..def_a.variants[VariantIdx::new(0)].fields.len() {\n+                let src_f = src.value_field(fx, mir::Field::new(i));\n+                let dst_f = dst.place_field(fx, mir::Field::new(i));\n+\n+                if dst_f.layout().is_zst() {\n+                    continue;\n+                }\n+\n+                if src_f.layout().ty == dst_f.layout().ty {\n+                    dst_f.write_cvalue(fx, src_f);\n+                } else {\n+                    coerce_unsized_into(fx, src_f, dst_f);\n+                }\n+            }\n+        }\n+        _ => bug!(\"coerce_unsized_into: invalid coercion {:?} -> {:?}\",\n+                  src_ty,\n+                  dst_ty),\n+    }\n+}\n+\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/2a663555ddf36f6b041445894a8c175cd1bc718c/src/librustc_codegen_ssa/glue.rs\n+\n+pub fn size_and_align_of_dst<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    ty: Ty<'tcx>,\n+    info: Value,\n+) -> (Value, Value) {\n+    let layout = fx.layout_of(ty);\n+    if !layout.is_unsized() {\n+        let size = fx.bcx.ins().iconst(fx.pointer_type, layout.size.bytes() as i64);\n+        let align = fx.bcx.ins().iconst(fx.pointer_type, layout.align.abi.bytes() as i64);\n+        return (size, align);\n+    }\n+    match ty.sty {\n+        ty::Dynamic(..) => {\n+            // load size/align from vtable\n+            (\n+                crate::vtable::size_of_obj(fx, info),\n+                crate::vtable::min_align_of_obj(fx, info),\n+            )\n+        }\n+        ty::Slice(_) | ty::Str => {\n+            let unit = layout.field(fx, 0);\n+            // The info in this case is the length of the str, so the size is that\n+            // times the unit size.\n+            (fx.bcx.ins().imul_imm(info, unit.size.bytes() as i64),\n+             fx.bcx.ins().iconst(fx.pointer_type, unit.align.abi.bytes() as i64))\n+        }\n+        _ => {\n+            // First get the size of all statically known fields.\n+            // Don't use size_of because it also rounds up to alignment, which we\n+            // want to avoid, as the unsized field's alignment could be smaller.\n+            assert!(!ty.is_simd());\n+\n+            let i = layout.fields.count() - 1;\n+            let sized_size = layout.fields.offset(i).bytes();\n+            let sized_align = layout.align.abi.bytes();\n+            let sized_align = fx.bcx.ins().iconst(fx.pointer_type, sized_align as i64);\n+\n+            // Recurse to get the size of the dynamically sized field (must be\n+            // the last field).\n+            let field_ty = layout.field(fx, i).ty;\n+            let (unsized_size, mut unsized_align) = size_and_align_of_dst(fx, field_ty, info);\n+\n+            // FIXME (#26403, #27023): We should be adding padding\n+            // to `sized_size` (to accommodate the `unsized_align`\n+            // required of the unsized field that follows) before\n+            // summing it with `sized_size`. (Note that since #26403\n+            // is unfixed, we do not yet add the necessary padding\n+            // here. But this is where the add would go.)\n+\n+            // Return the sum of sizes and max of aligns.\n+            let size = fx.bcx.ins().iadd_imm(unsized_size, sized_size as i64);\n+\n+            // Packed types ignore the alignment of their fields.\n+            if let ty::Adt(def, _) = ty.sty {\n+                if def.repr.packed() {\n+                    unsized_align = sized_align;\n+                }\n+            }\n+\n+            // Choose max of two known alignments (combined value must\n+            // be aligned according to more restrictive of the two).\n+            let cmp = fx.bcx.ins().icmp(IntCC::UnsignedGreaterThan, sized_align, unsized_align);\n+            let align = fx.bcx.ins().select(cmp, sized_align, unsized_align);\n+\n+            // Issue #27023: must add any necessary padding to `size`\n+            // (to make it a multiple of `align`) before returning it.\n+            //\n+            // Namely, the returned size should be, in C notation:\n+            //\n+            //   `size + ((size & (align-1)) ? align : 0)`\n+            //\n+            // emulated via the semi-standard fast bit trick:\n+            //\n+            //   `(size + (align-1)) & -align`\n+            let addend = fx.bcx.ins().iadd_imm(align, -1);\n+            let add = fx.bcx.ins().iadd(size, addend);\n+            let zero = fx.bcx.ins().iconst(fx.pointer_type, 0);\n+            let neg =  fx.bcx.ins().isub(zero, align);\n+            let size = fx.bcx.ins().band(add, neg);\n+\n+            (size, align)\n+        }\n+    }\n+}"}, {"sha": "bdf0c9e2f54482b0226bd5b216ee108e9f054ba6", "filename": "src/vtable.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=16e43c9d212cc6c64f2213bf4c4bef0ae9860c0b", "patch": "@@ -8,9 +8,8 @@ const ALIGN_INDEX: usize = 2;\n \n pub fn size_of_obj<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    val: CValue<'tcx>,\n+    vtable: Value,\n ) -> Value {\n-    let (_ptr, vtable) = val.load_value_pair(fx);\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),\n@@ -22,9 +21,8 @@ pub fn size_of_obj<'a, 'tcx: 'a>(\n \n pub fn min_align_of_obj<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n-    val: CValue<'tcx>,\n+    vtable: Value,\n ) -> Value {\n-    let (_ptr, vtable) = val.load_value_pair(fx);\n     let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n     fx.bcx.ins().load(\n         pointer_ty(fx.tcx),"}]}