{"sha": "a58b980bd88651bc3bb85ef465848e0c08253444", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1OGI5ODBiZDg4NjUxYmMzYmI4NWVmNDY1ODQ4ZTBjMDgyNTM0NDQ=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:49Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-11-13T06:27:49Z"}, "message": "literal representation restructure 8\n\nStore the digit parts directly in DigitInfo since we need them anyway.", "tree": {"sha": "ac4e4abf49f0eaa43715f4baf5051bbe0cca243e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac4e4abf49f0eaa43715f4baf5051bbe0cca243e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a58b980bd88651bc3bb85ef465848e0c08253444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a58b980bd88651bc3bb85ef465848e0c08253444", "html_url": "https://github.com/rust-lang/rust/commit/a58b980bd88651bc3bb85ef465848e0c08253444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a58b980bd88651bc3bb85ef465848e0c08253444/comments", "author": null, "committer": null, "parents": [{"sha": "b62543f756bb6219dcc1025e21f5e209349b6ed6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b62543f756bb6219dcc1025e21f5e209349b6ed6", "html_url": "https://github.com/rust-lang/rust/commit/b62543f756bb6219dcc1025e21f5e209349b6ed6"}], "stats": {"total": 66, "additions": 37, "deletions": 29}, "files": [{"sha": "2fe993624f44ee5525e4821b12b4f8df52918099", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 37, "deletions": 29, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a58b980bd88651bc3bb85ef465848e0c08253444/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a58b980bd88651bc3bb85ef465848e0c08253444/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=a58b980bd88651bc3bb85ef465848e0c08253444", "patch": "@@ -124,12 +124,18 @@ impl Radix {\n \n #[derive(Debug)]\n pub(super) struct DigitInfo<'a> {\n-    /// Characters of a literal between the radix prefix and type suffix.\n-    crate digits: &'a str,\n     /// Which radix the literal was represented in.\n     crate radix: Radix,\n     /// The radix prefix, if present.\n     crate prefix: Option<&'a str>,\n+\n+    /// The integer part of the number.\n+    integer: &'a str,\n+    /// The fraction part of the number.\n+    fraction: Option<&'a str>,\n+    /// The character used as exponent seperator (b'e' or b'E') and the exponent part.\n+    exponent: Option<(char, &'a str)>,\n+\n     /// The type suffix, including preceding underscore if present.\n     crate suffix: Option<&'a str>,\n     /// True for floating-point literals.\n@@ -158,6 +164,9 @@ impl<'a> DigitInfo<'a> {\n             (Some(p), s)\n         };\n \n+        let mut digits = sans_prefix;\n+        let mut suffix = None;\n+\n         let len = sans_prefix.len();\n         let mut last_d = '\\0';\n         for (d_idx, d) in sans_prefix.char_indices() {\n@@ -168,36 +177,33 @@ impl<'a> DigitInfo<'a> {\n                     || ((d == 'E' || d == 'e') && !has_possible_float_suffix(&sans_prefix)))\n                 || !float && (d == 'i' || d == 'u' || is_possible_suffix_index(&sans_prefix, suffix_start, len))\n             {\n-                let (digits, suffix) = sans_prefix.split_at(suffix_start);\n-                return Self {\n-                    digits,\n-                    radix,\n-                    prefix,\n-                    suffix: Some(suffix),\n-                    float,\n-                };\n+                let (d, s) = sans_prefix.split_at(suffix_start);\n+                digits = d;\n+                suffix = Some(s);\n+                break;\n             }\n             last_d = d\n         }\n \n-        // No suffix found\n+        let (integer, fraction, exponent) = Self::split_digit_parts(digits, float);\n+\n         Self {\n-            digits: sans_prefix,\n             radix,\n             prefix,\n-            suffix: None,\n+            integer,\n+            fraction,\n+            exponent,\n+            suffix,\n             float,\n         }\n     }\n \n-    fn split_digit_parts(&self) -> (&str, Option<&str>, Option<(char, &str)>) {\n-        let digits = self.digits;\n-\n+    fn split_digit_parts(digits: &str, float: bool) -> (&str, Option<&str>, Option<(char, &str)>) {\n         let mut integer = digits;\n         let mut fraction = None;\n         let mut exponent = None;\n \n-        if self.float {\n+        if float {\n             for (i, c) in digits.char_indices() {\n                 match c {\n                     '.' => {\n@@ -231,17 +237,21 @@ impl<'a> DigitInfo<'a> {\n \n         let group_size = self.radix.suggest_grouping();\n \n-        let (integer, fraction, exponent) = &self.split_digit_parts();\n+        Self::group_digits(\n+            &mut output,\n+            self.integer,\n+            group_size,\n+            true,\n+            self.radix == Radix::Hexadecimal,\n+        );\n \n-        Self::group_digits(&mut output, integer, group_size, true, self.radix == Radix::Hexadecimal);\n-\n-        if let Some(fraction) = fraction {\n+        if let Some(fraction) = self.fraction {\n             output.push('.');\n             Self::group_digits(&mut output, fraction, group_size, false, false);\n         }\n \n-        if let Some((separator, exponent)) = exponent {\n-            output.push(*separator);\n+        if let Some((separator, exponent)) = self.exponent {\n+            output.push(separator);\n             Self::group_digits(&mut output, exponent, group_size, true, false);\n         }\n \n@@ -395,15 +405,13 @@ impl LiteralDigitGrouping {\n                         }\n                     }\n \n-                    let (integer, fraction, _) = digit_info.split_digit_parts();\n-\n-                    let integral_group_size = Self::get_group_size(integer.split('_'), in_macro)?;\n-                    if let Some(fraction) = fraction {\n+                    let integral_group_size = Self::get_group_size(digit_info.integer.split('_'), in_macro)?;\n+                    if let Some(fraction) = digit_info.fraction {\n                         let fractional_group_size = Self::get_group_size(fraction.rsplit('_'), in_macro)?;\n \n                         let consistent = Self::parts_consistent(integral_group_size,\n                                                                 fractional_group_size,\n-                                                                integer.len(),\n+                                                                digit_info.integer.len(),\n                                                                 fraction.len());\n                         if !consistent {\n                             return Err(WarningType::InconsistentDigitGrouping);\n@@ -503,7 +511,7 @@ impl DecimalLiteralRepresentation {\n             then {\n                 let hex = format!(\"{:#X}\", val);\n                 let digit_info = DigitInfo::new(&hex, false);\n-                let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n+                let _ = Self::do_lint(digit_info.integer).map_err(|warning_type| {\n                     warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n                 });\n             }"}]}