{"sha": "f23b63cbbf8d92deac6b3c39746d3b85d3e838af", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyM2I2M2NiYmY4ZDkyZGVhYzZiM2MzOTc0NmQzYjg1ZDNlODM4YWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T10:20:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-24T10:20:12Z"}, "message": "Auto merge of #57066 - Zoxc:graph-race, r=michaelwoerister\n\nFix race condition when emitting stored diagnostics\n\nr? @michaelwoerister", "tree": {"sha": "4ed7829ac15fa67f3bc81ebb01f5c74849d3e56e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ed7829ac15fa67f3bc81ebb01f5c74849d3e56e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f23b63cbbf8d92deac6b3c39746d3b85d3e838af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f23b63cbbf8d92deac6b3c39746d3b85d3e838af", "html_url": "https://github.com/rust-lang/rust/commit/f23b63cbbf8d92deac6b3c39746d3b85d3e838af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f23b63cbbf8d92deac6b3c39746d3b85d3e838af/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9", "html_url": "https://github.com/rust-lang/rust/commit/cd3d580d59e8af62fb8fc25b996900dd5ccd5ad9"}, {"sha": "b2dfd9680d9d59ce5dcc16118da1f3384ceb19ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2dfd9680d9d59ce5dcc16118da1f3384ceb19ab", "html_url": "https://github.com/rust-lang/rust/commit/b2dfd9680d9d59ce5dcc16118da1f3384ceb19ab"}], "stats": {"total": 84, "additions": 63, "deletions": 21}, "files": [{"sha": "63857d6c9189af63fc1306cf31f701d05d31c220", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 63, "deletions": 21, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f23b63cbbf8d92deac6b3c39746d3b85d3e838af/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f23b63cbbf8d92deac6b3c39746d3b85d3e838af/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=f23b63cbbf8d92deac6b3c39746d3b85d3e838af", "patch": "@@ -1,4 +1,4 @@\n-use errors::DiagnosticBuilder;\n+use errors::{Diagnostic, DiagnosticBuilder};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -9,6 +9,7 @@ use std::hash::Hash;\n use std::collections::hash_map::Entry;\n use ty::{self, TyCtxt};\n use util::common::{ProfileQueriesMsg, profq_msg};\n+use parking_lot::{Mutex, Condvar};\n \n use ich::{StableHashingContext, StableHashingContextProvider, Fingerprint};\n \n@@ -60,6 +61,12 @@ struct DepGraphData {\n \n     colors: DepNodeColorMap,\n \n+    /// A set of loaded diagnostics which has been emitted.\n+    emitted_diagnostics: Mutex<FxHashSet<DepNodeIndex>>,\n+\n+    /// Used to wait for diagnostics to be emitted.\n+    emitted_diagnostics_cond_var: Condvar,\n+\n     /// When we load, there may be `.o` files, cached mir, or other such\n     /// things available to us. If we find that they are not dirty, we\n     /// load the path to the file storing those work-products here into\n@@ -83,6 +90,8 @@ impl DepGraph {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n                 current: Lock::new(CurrentDepGraph::new(prev_graph_node_count)),\n+                emitted_diagnostics: Default::default(),\n+                emitted_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n                 colors: DepNodeColorMap::new(prev_graph_node_count),\n                 loaded_from_cache: Default::default(),\n@@ -718,28 +727,18 @@ impl DepGraph {\n         };\n \n         // ... emitting any stored diagnostic ...\n-        if did_allocation {\n-            // Only the thread which did the allocation emits the error messages\n-\n-            // FIXME: Ensure that these are printed before returning for all threads.\n-            // Currently threads where did_allocation = false can continue on\n-            // and emit other diagnostics before these diagnostics are emitted.\n-            // Such diagnostics should be emitted after these.\n-            // See https://github.com/rust-lang/rust/issues/48685\n-            let diagnostics = tcx.queries.on_disk_cache\n-                                 .load_diagnostics(tcx, prev_dep_node_index);\n \n-            if diagnostics.len() > 0 {\n-                let handle = tcx.sess.diagnostic();\n+        let diagnostics = tcx.queries.on_disk_cache\n+                                .load_diagnostics(tcx, prev_dep_node_index);\n \n-                // Promote the previous diagnostics to the current session.\n-                tcx.queries.on_disk_cache\n-                   .store_diagnostics(dep_node_index, diagnostics.clone().into());\n-\n-                for diagnostic in diagnostics {\n-                    DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n-                }\n-            }\n+        if unlikely!(diagnostics.len() > 0) {\n+            self.emit_diagnostics(\n+                tcx,\n+                data,\n+                dep_node_index,\n+                did_allocation,\n+                diagnostics\n+            );\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n@@ -755,6 +754,49 @@ impl DepGraph {\n         Some(dep_node_index)\n     }\n \n+    /// Atomically emits some loaded diagnotics assuming that this only gets called with\n+    /// did_allocation set to true on one thread\n+    #[cold]\n+    #[inline(never)]\n+    fn emit_diagnostics<'tcx>(\n+        &self,\n+        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        data: &DepGraphData,\n+        dep_node_index: DepNodeIndex,\n+        did_allocation: bool,\n+        diagnostics: Vec<Diagnostic>,\n+    ) {\n+        if did_allocation || !cfg!(parallel_queries) {\n+            // Only the thread which did the allocation emits the error messages\n+            let handle = tcx.sess.diagnostic();\n+\n+            // Promote the previous diagnostics to the current session.\n+            tcx.queries.on_disk_cache\n+                .store_diagnostics(dep_node_index, diagnostics.clone().into());\n+\n+            for diagnostic in diagnostics {\n+                DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n+            }\n+\n+            #[cfg(parallel_queries)]\n+            {\n+                // Mark the diagnostics and emitted and wake up waiters\n+                data.emitted_diagnostics.lock().insert(dep_node_index);\n+                data.emitted_diagnostics_cond_var.notify_all();\n+            }\n+        } else {\n+            // The other threads will wait for the diagnostics to be emitted\n+\n+            let mut emitted_diagnostics = data.emitted_diagnostics.lock();\n+            loop {\n+                if emitted_diagnostics.contains(&dep_node_index) {\n+                    break;\n+                }\n+                data.emitted_diagnostics_cond_var.wait(&mut emitted_diagnostics);\n+            }\n+        }\n+    }\n+\n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode) -> bool {"}]}