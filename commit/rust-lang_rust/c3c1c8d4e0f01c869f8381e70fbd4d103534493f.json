{"sha": "c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYzFjOGQ0ZTBmMDFjODY5ZjgzODFlNzBmYmQ0ZDEwMzUzNDQ5M2Y=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-13T08:18:37Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-04T23:36:23Z"}, "message": "Allow linking to a proc macro on the target in metadata and still use a host proc macro to execute them", "tree": {"sha": "8cc535c809f249b602f9372ca4dca0b6d9b56e02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cc535c809f249b602f9372ca4dca0b6d9b56e02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "html_url": "https://github.com/rust-lang/rust/commit/c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97431a40908a32db31fbc1f10af365e653309a90", "url": "https://api.github.com/repos/rust-lang/rust/commits/97431a40908a32db31fbc1f10af365e653309a90", "html_url": "https://github.com/rust-lang/rust/commit/97431a40908a32db31fbc1f10af365e653309a90"}], "stats": {"total": 178, "additions": 122, "deletions": 56}, "files": [{"sha": "a4c587b5ca76195d762e40935e06cced35bd5851", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "patch": "@@ -1232,6 +1232,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n          Use with RUST_REGION_GRAPH=help for more info\"),\n     parse_only: bool = (false, parse_bool, [UNTRACKED],\n         \"parse only; do not compile, assemble, or link\"),\n+    dual_proc_macros: bool = (false, parse_bool, [TRACKED],\n+        \"load proc macros for both target and host, but only link to the target\"),\n     no_codegen: bool = (false, parse_bool, [TRACKED],\n         \"run all passes except codegen; no output\"),\n     treat_err_as_bug: bool = (false, parse_bool, [TRACKED],"}, {"sha": "cf09d45ca38fc3556ac6d3760496ff8160848798", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "patch": "@@ -18,6 +18,7 @@ pub enum FileMatch {\n \n // A module for searching for libraries\n \n+#[derive(Clone)]\n pub struct FileSearch<'a> {\n     sysroot: &'a Path,\n     triple: &'a str,"}, {"sha": "600ec8d65b63cb85e0aabcd3dff5970693889a89", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 106, "deletions": 53, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "patch": "@@ -188,13 +188,15 @@ impl<'a> CrateLoader<'a> {\n         });\n     }\n \n-    fn register_crate(&mut self,\n-                      root: &Option<CratePaths>,\n-                      ident: Symbol,\n-                      span: Span,\n-                      lib: Library,\n-                      dep_kind: DepKind)\n-                      -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+    fn register_crate(\n+        &mut self,\n+        host_lib: Option<Library>,\n+        root: &Option<CratePaths>,\n+        ident: Symbol,\n+        span: Span,\n+        lib: Library,\n+        dep_kind: DepKind\n+    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n         let crate_root = lib.metadata.get_root();\n         info!(\"register crate `extern crate {} as {}`\", crate_root.name, ident);\n         self.verify_no_symbol_conflicts(span, &crate_root);\n@@ -222,7 +224,16 @@ impl<'a> CrateLoader<'a> {\n         let dependencies: Vec<CrateNum> = cnum_map.iter().cloned().collect();\n \n         let proc_macros = crate_root.proc_macro_decls_static.map(|_| {\n-            self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+            if self.sess.opts.debugging_opts.dual_proc_macros {\n+                let host_lib = host_lib.unwrap();\n+                self.load_derive_macros(\n+                    &host_lib.metadata.get_root(),\n+                    host_lib.dylib.clone().map(|p| p.0),\n+                    span\n+                )\n+            } else {\n+                self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n+            }\n         });\n \n         let def_path_table = record_time(&self.sess.perf_stats.decode_def_path_tables_time, || {\n@@ -269,6 +280,61 @@ impl<'a> CrateLoader<'a> {\n         (cnum, cmeta)\n     }\n \n+    fn load_proc_macro<'b> (\n+        &mut self,\n+        locate_ctxt: &mut locator::Context<'b>,\n+        path_kind: PathKind,\n+    ) -> Option<(LoadResult, Option<Library>)>\n+    where\n+        'a: 'b\n+    {\n+        // Use a new locator Context so trying to load a proc macro doesn't affect the error\n+        // message we emit\n+        let mut proc_macro_locator = locate_ctxt.clone();\n+\n+        // Try to load a proc macro\n+        proc_macro_locator.is_proc_macro = Some(true);\n+\n+        // Load the proc macro crate for the target\n+        let (locator, target_result) = if self.sess.opts.debugging_opts.dual_proc_macros {\n+            proc_macro_locator.reset();\n+            let result = match self.load(&mut proc_macro_locator)? {\n+                LoadResult::Previous(cnum) => return Some((LoadResult::Previous(cnum), None)),\n+                LoadResult::Loaded(library) => Some(LoadResult::Loaded(library))\n+            };\n+            // Don't look for a matching hash when looking for the host crate.\n+            // It won't be the same as the target crate hash\n+            locate_ctxt.hash = None;\n+            // Use the locate_ctxt when looking for the host proc macro crate, as that is required\n+            // so we want it to affect the error message\n+            (locate_ctxt, result)\n+        } else {\n+            (&mut proc_macro_locator, None)\n+        };\n+\n+        // Load the proc macro crate for the host\n+\n+        locator.reset();\n+        locator.is_proc_macro = Some(true);\n+        locator.target = &self.sess.host;\n+        locator.triple = TargetTriple::from_triple(config::host_triple());\n+        locator.filesearch = self.sess.host_filesearch(path_kind);\n+\n+        let host_result = self.load(locator)?;\n+\n+        Some(if self.sess.opts.debugging_opts.dual_proc_macros {\n+            let host_result = match host_result {\n+                LoadResult::Previous(..) => {\n+                    panic!(\"host and target proc macros must be loaded in lock-step\")\n+                }\n+                LoadResult::Loaded(library) => library\n+            };\n+            (target_result.unwrap(), Some(host_result))\n+        } else {\n+            (host_result, None)\n+        })\n+    }\n+\n     fn resolve_crate<'b>(\n         &'b mut self,\n         root: &'b Option<CratePaths>,\n@@ -281,53 +347,39 @@ impl<'a> CrateLoader<'a> {\n         mut dep_kind: DepKind,\n     ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n         info!(\"resolving crate `extern crate {} as {}`\", name, ident);\n+        let mut locate_ctxt = locator::Context {\n+            sess: self.sess,\n+            span,\n+            ident,\n+            crate_name: name,\n+            hash: hash.map(|a| &*a),\n+            extra_filename: extra_filename,\n+            filesearch: self.sess.target_filesearch(path_kind),\n+            target: &self.sess.target.target,\n+            triple: self.sess.opts.target_triple.clone(),\n+            root,\n+            rejected_via_hash: vec![],\n+            rejected_via_triple: vec![],\n+            rejected_via_kind: vec![],\n+            rejected_via_version: vec![],\n+            rejected_via_filename: vec![],\n+            should_match_name: true,\n+            is_proc_macro: Some(false),\n+            metadata_loader: &*self.cstore.metadata_loader,\n+        };\n+\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n-            LoadResult::Previous(cnum)\n+            (LoadResult::Previous(cnum), None)\n         } else {\n             info!(\"falling back to a load\");\n-            let mut locate_ctxt = locator::Context {\n-                sess: self.sess,\n-                span,\n-                ident,\n-                crate_name: name,\n-                hash: hash.map(|a| &*a),\n-                extra_filename: extra_filename,\n-                filesearch: self.sess.target_filesearch(path_kind),\n-                target: &self.sess.target.target,\n-                triple: &self.sess.opts.target_triple,\n-                root,\n-                rejected_via_hash: vec![],\n-                rejected_via_triple: vec![],\n-                rejected_via_kind: vec![],\n-                rejected_via_version: vec![],\n-                rejected_via_filename: vec![],\n-                should_match_name: true,\n-                is_proc_macro: Some(false),\n-                metadata_loader: &*self.cstore.metadata_loader,\n-            };\n-\n-            self.load(&mut locate_ctxt).or_else(|| {\n+            self.load(&mut locate_ctxt).map(|r| (r, None)).or_else(|| {\n                 dep_kind = DepKind::UnexportedMacrosOnly;\n-\n-                let mut proc_macro_locator = locator::Context {\n-                    target: &self.sess.host,\n-                    triple: &TargetTriple::from_triple(config::host_triple()),\n-                    filesearch: self.sess.host_filesearch(path_kind),\n-                    rejected_via_hash: vec![],\n-                    rejected_via_triple: vec![],\n-                    rejected_via_kind: vec![],\n-                    rejected_via_version: vec![],\n-                    rejected_via_filename: vec![],\n-                    is_proc_macro: Some(true),\n-                    ..locate_ctxt\n-                };\n-\n-                self.load(&mut proc_macro_locator)\n+                self.load_proc_macro(&mut locate_ctxt, path_kind)\n             }).ok_or_else(move || LoadError::LocatorError(locate_ctxt))?\n         };\n \n         match result {\n-            LoadResult::Previous(cnum) => {\n+            (LoadResult::Previous(cnum), None) => {\n                 let data = self.cstore.get_crate_data(cnum);\n                 if data.root.proc_macro_decls_static.is_some() {\n                     dep_kind = DepKind::UnexportedMacrosOnly;\n@@ -337,9 +389,10 @@ impl<'a> CrateLoader<'a> {\n                 });\n                 Ok((cnum, data))\n             }\n-            LoadResult::Loaded(library) => {\n-                Ok(self.register_crate(root, ident, span, library, dep_kind))\n+            (LoadResult::Loaded(library), host_library) => {\n+                Ok(self.register_crate(host_library, root, ident, span, library, dep_kind))\n             }\n+            _ => panic!()\n         }\n     }\n \n@@ -355,7 +408,7 @@ impl<'a> CrateLoader<'a> {\n         // don't want to match a host crate against an equivalent target one\n         // already loaded.\n         let root = library.metadata.get_root();\n-        if locate_ctxt.triple == &self.sess.opts.target_triple {\n+        if locate_ctxt.triple == self.sess.opts.target_triple {\n             let mut result = LoadResult::Loaded(library);\n             self.cstore.iter_crate_data(|cnum, data| {\n                 if data.root.name == root.name && root.hash == data.root.hash {\n@@ -451,9 +504,9 @@ impl<'a> CrateLoader<'a> {\n     fn read_extension_crate(&mut self, span: Span, orig_name: Symbol, rename: Symbol)\n                             -> ExtensionCrate {\n         info!(\"read extension crate `extern crate {} as {}`\", orig_name, rename);\n-        let target_triple = &self.sess.opts.target_triple;\n+        let target_triple = self.sess.opts.target_triple.clone();\n         let host_triple = TargetTriple::from_triple(config::host_triple());\n-        let is_cross = target_triple != &host_triple;\n+        let is_cross = target_triple != host_triple;\n         let mut target_only = false;\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n@@ -464,7 +517,7 @@ impl<'a> CrateLoader<'a> {\n             extra_filename: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n-            triple: &host_triple,\n+            triple: host_triple,\n             root: &None,\n             rejected_via_hash: vec![],\n             rejected_via_triple: vec![],"}, {"sha": "81878c4f687b6df0797527264ad082f2c71e679c", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3c1c8d4e0f01c869f8381e70fbd4d103534493f/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=c3c1c8d4e0f01c869f8381e70fbd4d103534493f", "patch": "@@ -244,11 +244,13 @@ use rustc_data_structures::owning_ref::OwningRef;\n \n use log::{debug, info, warn};\n \n+#[derive(Clone)]\n pub struct CrateMismatch {\n     path: PathBuf,\n     got: String,\n }\n \n+#[derive(Clone)]\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n@@ -258,7 +260,7 @@ pub struct Context<'a> {\n     pub extra_filename: Option<&'a str>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n-    pub triple: &'a TargetTriple,\n+    pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n     pub root: &'a Option<CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n@@ -302,6 +304,14 @@ impl CratePaths {\n }\n \n impl<'a> Context<'a> {\n+    pub fn reset(&mut self) {\n+        self.rejected_via_hash.clear();\n+        self.rejected_via_triple.clear();\n+        self.rejected_via_kind.clear();\n+        self.rejected_via_version.clear();\n+        self.rejected_via_filename.clear();\n+    }\n+\n     pub fn maybe_load_library_crate(&mut self) -> Option<Library> {\n         let mut seen_paths = FxHashSet::default();\n         match self.extra_filename {\n@@ -399,7 +409,7 @@ impl<'a> Context<'a> {\n                                            add);\n \n             if (self.ident == \"std\" || self.ident == \"core\")\n-                && self.triple != &TargetTriple::from_triple(config::host_triple()) {\n+                && self.triple != TargetTriple::from_triple(config::host_triple()) {\n                 err.note(&format!(\"the `{}` target may not be installed\", self.triple));\n             }\n             err.span_label(self.span, \"can't find crate\");\n@@ -718,7 +728,7 @@ impl<'a> Context<'a> {\n             }\n         }\n \n-        if &root.triple != self.triple {\n+        if root.triple != self.triple {\n             info!(\"Rejecting via crate triple: expected {} got {}\",\n                   self.triple,\n                   root.triple);"}]}