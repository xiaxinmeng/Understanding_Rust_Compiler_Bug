{"sha": "1c27243f953cadb1e09960a96123694bc2c83317", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjMjcyNDNmOTUzY2FkYjFlMDk5NjBhOTYxMjM2OTRiYzJjODMzMTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-08-22T15:37:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-08-22T15:37:06Z"}, "message": "Merge #9988\n\n9988: fix: Refactor & improve handling of overloaded binary operators r=flodiebold a=flodiebold\n\nFixes #9971. Also records them as method resolutions, which we could use later.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "8c2903da79274676a538289483c7ee1408fc0cc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c2903da79274676a538289483c7ee1408fc0cc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c27243f953cadb1e09960a96123694bc2c83317", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIm8iCRBK7hj4Ov3rIwAAeZcIACKs67cOqJc1/lV22NFjJt04\ngdIFx9Wqfnq3wNoY2cWkPbY3yuBfe5E6aWkEMxTYO3xWAfzuFLV7R30CxBAyuGQz\nmj1XBwnAKXmv8gLPFz47kG6/YhwuJa4hoaGWQ04ZlEHuh/1v4ifwgwr13aLScGmR\nfjysEN2IrncvKVOk9J0m7pMT587aTdttD1xuB57Rk9H1Bzh23acml7S0oDWMorZN\nG776dGyUhrSFo2kmTyz5odz4W4Uc6ECxpjLu7RiDG8HF2Hsxrn3crDh9Rb8DQ85x\n7x75gjqKhmk6STXCA8eqoYoWoH6OoDSsgkBlprE6xo9Ti1k1kVtydBp8aq/DGaE=\n=JV6L\n-----END PGP SIGNATURE-----\n", "payload": "tree 8c2903da79274676a538289483c7ee1408fc0cc1\nparent c8fd4fd410a3e097567420cf11d05f134b95063f\nparent 424dda8113301fa72e9604ae8e4914ec0243c764\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1629646626 +0000\ncommitter GitHub <noreply@github.com> 1629646626 +0000\n\nMerge #9988\n\n9988: fix: Refactor & improve handling of overloaded binary operators r=flodiebold a=flodiebold\n\nFixes #9971. Also records them as method resolutions, which we could use later.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c27243f953cadb1e09960a96123694bc2c83317", "html_url": "https://github.com/rust-lang/rust/commit/1c27243f953cadb1e09960a96123694bc2c83317", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c27243f953cadb1e09960a96123694bc2c83317/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8fd4fd410a3e097567420cf11d05f134b95063f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8fd4fd410a3e097567420cf11d05f134b95063f", "html_url": "https://github.com/rust-lang/rust/commit/c8fd4fd410a3e097567420cf11d05f134b95063f"}, {"sha": "424dda8113301fa72e9604ae8e4914ec0243c764", "url": "https://api.github.com/repos/rust-lang/rust/commits/424dda8113301fa72e9604ae8e4914ec0243c764", "html_url": "https://github.com/rust-lang/rust/commit/424dda8113301fa72e9604ae8e4914ec0243c764"}], "stats": {"total": 578, "additions": 317, "deletions": 261}, "files": [{"sha": "c63e9311abf6f98df6b5faede4475101a9e3a241", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -199,6 +199,13 @@ impl TraitData {\n             _ => None,\n         })\n     }\n+\n+    pub fn method_by_name(&self, name: &Name) -> Option<FunctionId> {\n+        self.items.iter().find_map(|(item_name, item)| match item {\n+            AssocItemId::FunctionId(t) if item_name == name => Some(*t),\n+            _ => None,\n+        })\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "4750d65d196e5bbd837327b3b31f5080ec54cb5f", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -285,6 +285,33 @@ pub mod known {\n         wrapping_add,\n         wrapping_mul,\n         wrapping_sub,\n+        // known methods of lang items\n+        add,\n+        mul,\n+        sub,\n+        div,\n+        rem,\n+        shl,\n+        shr,\n+        bitxor,\n+        bitor,\n+        bitand,\n+        add_assign,\n+        mul_assign,\n+        sub_assign,\n+        div_assign,\n+        rem_assign,\n+        shl_assign,\n+        shr_assign,\n+        bitxor_assign,\n+        bitor_assign,\n+        bitand_assign,\n+        eq,\n+        ne,\n+        ge,\n+        gt,\n+        le,\n+        lt,\n     );\n \n     // self/Self cannot be used as an identifier"}, {"sha": "d07a93958396fc620fc1d9f80ae6f49a57e8802b", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -16,11 +16,11 @@\n use std::ops::Index;\n use std::sync::Arc;\n \n-use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety};\n+use chalk_ir::{cast::Cast, DebruijnIndex, Mutability, Safety, Scalar};\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n-    expr::{ArithOp, BinaryOp, BindingAnnotation, ExprId, PatId},\n+    expr::{BindingAnnotation, ExprId, PatId},\n     lang_item::LangItemTarget,\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n@@ -134,11 +134,17 @@ pub struct TypeMismatch {\n #[derive(Clone, PartialEq, Eq, Debug)]\n struct InternedStandardTypes {\n     unknown: Ty,\n+    bool_: Ty,\n+    unit: Ty,\n }\n \n impl Default for InternedStandardTypes {\n     fn default() -> Self {\n-        InternedStandardTypes { unknown: TyKind::Error.intern(&Interner) }\n+        InternedStandardTypes {\n+            unknown: TyKind::Error.intern(&Interner),\n+            bool_: TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+            unit: TyKind::Tuple(0, Substitution::empty(&Interner)).intern(&Interner),\n+        }\n     }\n }\n /// Represents coercing a value to a different type of value.\n@@ -751,28 +757,6 @@ impl<'a> InferenceContext<'a> {\n         self.db.trait_data(trait_).associated_type_by_name(&name![Output])\n     }\n \n-    fn resolve_binary_op_output(&self, bop: &BinaryOp) -> Option<TypeAliasId> {\n-        let lang_item = match bop {\n-            BinaryOp::ArithOp(aop) => match aop {\n-                ArithOp::Add => \"add\",\n-                ArithOp::Sub => \"sub\",\n-                ArithOp::Mul => \"mul\",\n-                ArithOp::Div => \"div\",\n-                ArithOp::Shl => \"shl\",\n-                ArithOp::Shr => \"shr\",\n-                ArithOp::Rem => \"rem\",\n-                ArithOp::BitXor => \"bitxor\",\n-                ArithOp::BitOr => \"bitor\",\n-                ArithOp::BitAnd => \"bitand\",\n-            },\n-            _ => return None,\n-        };\n-\n-        let trait_ = self.resolve_lang_item(lang_item)?.as_trait();\n-\n-        self.db.trait_data(trait_?).associated_type_by_name(&name![Output])\n-    }\n-\n     fn resolve_boxed_box(&self) -> Option<AdtId> {\n         let struct_ = self.resolve_lang_item(\"owned_box\")?.as_struct()?;\n         Some(struct_.into())\n@@ -846,6 +830,10 @@ impl Expectation {\n         }\n     }\n \n+    fn from_option(ty: Option<Ty>) -> Self {\n+        ty.map_or(Expectation::None, Expectation::HasType)\n+    }\n+\n     /// The following explanation is copied straight from rustc:\n     /// Provides an expectation for an rvalue expression given an *optional*\n     /// hint, which is not required for type safety (the resulting type might"}, {"sha": "ceb5eeeccb3d2fdc17f93bde1e0b0f382d6ce0d0", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 213, "deletions": 30, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -8,10 +8,13 @@ use std::{\n \n use chalk_ir::{cast::Cast, fold::Shift, Mutability, TyVariableKind};\n use hir_def::{\n-    expr::{Array, BinaryOp, Expr, ExprId, Literal, MatchGuard, Statement, UnaryOp},\n+    expr::{\n+        ArithOp, Array, BinaryOp, CmpOp, Expr, ExprId, Literal, MatchGuard, Ordering, Statement,\n+        UnaryOp,\n+    },\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n-    AssocContainerId, FieldId, Lookup,\n+    AssocContainerId, FieldId, FunctionId, Lookup,\n };\n use hir_expand::name::{name, Name};\n use stdx::always;\n@@ -23,7 +26,7 @@ use crate::{\n     infer::coerce::CoerceMany,\n     lower::lower_to_chalk_mutability,\n     mapping::from_chalk,\n-    method_resolution, op,\n+    method_resolution,\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     traits::FnTrait,\n@@ -669,34 +672,21 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n-                Some(op) => {\n-                    let lhs_expectation = match op {\n-                        BinaryOp::LogicOp(..) => {\n-                            Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner))\n-                        }\n-                        _ => Expectation::none(),\n-                    };\n-                    let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n-                    let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n-                    let rhs_expectation = op::binary_op_rhs_expectation(*op, lhs_ty.clone());\n-                    let rhs_ty =\n-                        self.infer_expr_coerce(*rhs, &Expectation::has_type(rhs_expectation));\n-                    let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n-\n-                    let ret = op::binary_op_return_ty(*op, lhs_ty.clone(), rhs_ty.clone());\n-\n-                    if ret.is_unknown() {\n-                        cov_mark::hit!(infer_expr_inner_binary_operator_overload);\n-\n-                        self.resolve_associated_type_with_params(\n-                            lhs_ty,\n-                            self.resolve_binary_op_output(op),\n-                            &[rhs_ty],\n-                        )\n-                    } else {\n-                        ret\n-                    }\n+                Some(BinaryOp::Assignment { op: None }) => {\n+                    let lhs_ty = self.infer_expr(*lhs, &Expectation::none());\n+                    self.infer_expr_coerce(*rhs, &Expectation::has_type(lhs_ty));\n+                    self.result.standard_types.unit.clone()\n+                }\n+                Some(BinaryOp::LogicOp(_)) => {\n+                    let bool_ty = self.result.standard_types.bool_.clone();\n+                    self.infer_expr_coerce(*lhs, &Expectation::HasType(bool_ty.clone()));\n+                    let lhs_diverges = self.diverges;\n+                    self.infer_expr_coerce(*rhs, &Expectation::HasType(bool_ty.clone()));\n+                    // Depending on the LHS' value, the RHS can never execute.\n+                    self.diverges = lhs_diverges;\n+                    bool_ty\n                 }\n+                Some(op) => self.infer_overloadable_binop(*lhs, *op, *rhs, tgt_expr),\n                 _ => self.err_ty(),\n             },\n             Expr::Range { lhs, rhs, range_type } => {\n@@ -862,6 +852,62 @@ impl<'a> InferenceContext<'a> {\n         ty\n     }\n \n+    fn infer_overloadable_binop(\n+        &mut self,\n+        lhs: ExprId,\n+        op: BinaryOp,\n+        rhs: ExprId,\n+        tgt_expr: ExprId,\n+    ) -> Ty {\n+        let lhs_expectation = Expectation::none();\n+        let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n+        let rhs_ty = self.table.new_type_var();\n+\n+        let func = self.resolve_binop_method(op);\n+        let func = match func {\n+            Some(func) => func,\n+            None => {\n+                let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n+                let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n+                return self\n+                    .builtin_binary_op_return_ty(op, lhs_ty, rhs_ty)\n+                    .unwrap_or_else(|| self.err_ty());\n+            }\n+        };\n+\n+        let subst = TyBuilder::subst_for_def(self.db, func)\n+            .push(lhs_ty.clone())\n+            .push(rhs_ty.clone())\n+            .build();\n+        self.write_method_resolution(tgt_expr, func, subst.clone());\n+\n+        let method_ty = self.db.value_ty(func.into()).substitute(&Interner, &subst);\n+        self.register_obligations_for_call(&method_ty);\n+\n+        self.infer_expr_coerce(rhs, &Expectation::has_type(rhs_ty.clone()));\n+\n+        let ret_ty = match method_ty.callable_sig(self.db) {\n+            Some(sig) => sig.ret().clone(),\n+            None => self.err_ty(),\n+        };\n+\n+        let ret_ty = self.normalize_associated_types_in(ret_ty);\n+\n+        // FIXME: record autoref adjustments\n+\n+        // use knowledge of built-in binary ops, which can sometimes help inference\n+        if let Some(builtin_rhs) = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone()) {\n+            self.unify(&builtin_rhs, &rhs_ty);\n+        }\n+        if let Some(builtin_ret) =\n+            self.builtin_binary_op_return_ty(op, lhs_ty.clone(), rhs_ty.clone())\n+        {\n+            self.unify(&builtin_ret, &ret_ty);\n+        }\n+\n+        ret_ty\n+    }\n+\n     fn infer_block(\n         &mut self,\n         expr: ExprId,\n@@ -1136,4 +1182,141 @@ impl<'a> InferenceContext<'a> {\n             }\n         }\n     }\n+\n+    fn builtin_binary_op_return_ty(&mut self, op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Option<Ty> {\n+        let lhs_ty = self.resolve_ty_shallow(&lhs_ty);\n+        let rhs_ty = self.resolve_ty_shallow(&rhs_ty);\n+        match op {\n+            BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => {\n+                Some(TyKind::Scalar(Scalar::Bool).intern(&Interner))\n+            }\n+            BinaryOp::Assignment { .. } => Some(TyBuilder::unit()),\n+            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n+                // all integer combinations are valid here\n+                if matches!(\n+                    lhs_ty.kind(&Interner),\n+                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n+                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n+                ) && matches!(\n+                    rhs_ty.kind(&Interner),\n+                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n+                        | TyKind::InferenceVar(_, TyVariableKind::Integer)\n+                ) {\n+                    Some(lhs_ty)\n+                } else {\n+                    None\n+                }\n+            }\n+            BinaryOp::ArithOp(_) => match (lhs_ty.kind(&Interner), rhs_ty.kind(&Interner)) {\n+                // (int, int) | (uint, uint) | (float, float)\n+                (TyKind::Scalar(Scalar::Int(_)), TyKind::Scalar(Scalar::Int(_)))\n+                | (TyKind::Scalar(Scalar::Uint(_)), TyKind::Scalar(Scalar::Uint(_)))\n+                | (TyKind::Scalar(Scalar::Float(_)), TyKind::Scalar(Scalar::Float(_))) => {\n+                    Some(rhs_ty)\n+                }\n+                // ({int}, int) | ({int}, uint)\n+                (\n+                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n+                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n+                ) => Some(rhs_ty),\n+                // (int, {int}) | (uint, {int})\n+                (\n+                    TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n+                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n+                ) => Some(lhs_ty),\n+                // ({float} | float)\n+                (\n+                    TyKind::InferenceVar(_, TyVariableKind::Float),\n+                    TyKind::Scalar(Scalar::Float(_)),\n+                ) => Some(rhs_ty),\n+                // (float, {float})\n+                (\n+                    TyKind::Scalar(Scalar::Float(_)),\n+                    TyKind::InferenceVar(_, TyVariableKind::Float),\n+                ) => Some(lhs_ty),\n+                // ({int}, {int}) | ({float}, {float})\n+                (\n+                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n+                    TyKind::InferenceVar(_, TyVariableKind::Integer),\n+                )\n+                | (\n+                    TyKind::InferenceVar(_, TyVariableKind::Float),\n+                    TyKind::InferenceVar(_, TyVariableKind::Float),\n+                ) => Some(rhs_ty),\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    fn builtin_binary_op_rhs_expectation(&mut self, op: BinaryOp, lhs_ty: Ty) -> Option<Ty> {\n+        Some(match op {\n+            BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+            BinaryOp::Assignment { op: None } => lhs_ty,\n+            BinaryOp::CmpOp(CmpOp::Eq { .. }) => match self\n+                .resolve_ty_shallow(&lhs_ty)\n+                .kind(&Interner)\n+            {\n+                TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n+                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n+                _ => return None,\n+            },\n+            BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => return None,\n+            BinaryOp::CmpOp(CmpOp::Ord { .. })\n+            | BinaryOp::Assignment { op: Some(_) }\n+            | BinaryOp::ArithOp(_) => match self.resolve_ty_shallow(&lhs_ty).kind(&Interner) {\n+                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_)) => lhs_ty,\n+                TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n+                _ => return None,\n+            },\n+        })\n+    }\n+\n+    fn resolve_binop_method(&self, op: BinaryOp) -> Option<FunctionId> {\n+        let (name, lang_item) = match op {\n+            BinaryOp::LogicOp(_) => return None,\n+            BinaryOp::ArithOp(aop) => match aop {\n+                ArithOp::Add => (name!(add), \"add\"),\n+                ArithOp::Mul => (name!(mul), \"mul\"),\n+                ArithOp::Sub => (name!(sub), \"sub\"),\n+                ArithOp::Div => (name!(div), \"div\"),\n+                ArithOp::Rem => (name!(rem), \"rem\"),\n+                ArithOp::Shl => (name!(shl), \"shl\"),\n+                ArithOp::Shr => (name!(shr), \"shr\"),\n+                ArithOp::BitXor => (name!(bitxor), \"bitxor\"),\n+                ArithOp::BitOr => (name!(bitor), \"bitor\"),\n+                ArithOp::BitAnd => (name!(bitand), \"bitand\"),\n+            },\n+            BinaryOp::Assignment { op: Some(aop) } => match aop {\n+                ArithOp::Add => (name!(add_assign), \"add_assign\"),\n+                ArithOp::Mul => (name!(mul_assign), \"mul_assign\"),\n+                ArithOp::Sub => (name!(sub_assign), \"sub_assign\"),\n+                ArithOp::Div => (name!(div_assign), \"div_assign\"),\n+                ArithOp::Rem => (name!(rem_assign), \"rem_assign\"),\n+                ArithOp::Shl => (name!(shl_assign), \"shl_assign\"),\n+                ArithOp::Shr => (name!(shr_assign), \"shr_assign\"),\n+                ArithOp::BitXor => (name!(bitxor_assign), \"bitxor_assign\"),\n+                ArithOp::BitOr => (name!(bitor_assign), \"bitor_assign\"),\n+                ArithOp::BitAnd => (name!(bitand_assign), \"bitand_assign\"),\n+            },\n+            BinaryOp::CmpOp(cop) => match cop {\n+                CmpOp::Eq { negated: false } => (name!(eq), \"eq\"),\n+                CmpOp::Eq { negated: true } => (name!(ne), \"eq\"),\n+                CmpOp::Ord { ordering: Ordering::Less, strict: false } => {\n+                    (name!(le), \"partial_ord\")\n+                }\n+                CmpOp::Ord { ordering: Ordering::Less, strict: true } => (name!(lt), \"partial_ord\"),\n+                CmpOp::Ord { ordering: Ordering::Greater, strict: false } => {\n+                    (name!(ge), \"partial_ord\")\n+                }\n+                CmpOp::Ord { ordering: Ordering::Greater, strict: true } => {\n+                    (name!(gt), \"partial_ord\")\n+                }\n+            },\n+            BinaryOp::Assignment { op: None } => return None,\n+        };\n+\n+        let trait_ = self.resolve_lang_item(lang_item)?.as_trait()?;\n+\n+        self.db.trait_data(trait_).method_by_name(&name)\n+    }\n }"}, {"sha": "f59e109c85f47ae8bd0aacf9f8bf4d70b6e5872a", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -15,7 +15,6 @@ mod infer;\n mod interner;\n mod lower;\n mod mapping;\n-mod op;\n mod tls;\n mod utils;\n mod walk;"}, {"sha": "5ef6342d57bd2bf02d3e7fe6736d6b6b65d9b48d", "filename": "crates/hir_ty/src/op.rs", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c8fd4fd410a3e097567420cf11d05f134b95063f/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8fd4fd410a3e097567420cf11d05f134b95063f/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=c8fd4fd410a3e097567420cf11d05f134b95063f", "patch": "@@ -1,82 +0,0 @@\n-//! Helper functions for binary operator type inference.\n-use chalk_ir::TyVariableKind;\n-use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n-\n-use crate::{Interner, Scalar, Ty, TyBuilder, TyKind};\n-\n-pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n-    match op {\n-        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-        BinaryOp::Assignment { .. } => TyBuilder::unit(),\n-        BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => {\n-            // all integer combinations are valid here\n-            if matches!(\n-                lhs_ty.kind(&Interner),\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                    | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-            ) && matches!(\n-                rhs_ty.kind(&Interner),\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_))\n-                    | TyKind::InferenceVar(_, TyVariableKind::Integer)\n-            ) {\n-                lhs_ty\n-            } else {\n-                TyKind::Error.intern(&Interner)\n-            }\n-        }\n-        BinaryOp::ArithOp(_) => match (lhs_ty.kind(&Interner), rhs_ty.kind(&Interner)) {\n-            // (int, int) | (uint, uint) | (float, float)\n-            (TyKind::Scalar(Scalar::Int(_)), TyKind::Scalar(Scalar::Int(_)))\n-            | (TyKind::Scalar(Scalar::Uint(_)), TyKind::Scalar(Scalar::Uint(_)))\n-            | (TyKind::Scalar(Scalar::Float(_)), TyKind::Scalar(Scalar::Float(_))) => rhs_ty,\n-            // ({int}, int) | ({int}, uint)\n-            (\n-                TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-            ) => rhs_ty,\n-            // (int, {int}) | (uint, {int})\n-            (\n-                TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_)),\n-                TyKind::InferenceVar(_, TyVariableKind::Integer),\n-            ) => lhs_ty,\n-            // ({float} | float)\n-            (TyKind::InferenceVar(_, TyVariableKind::Float), TyKind::Scalar(Scalar::Float(_))) => {\n-                rhs_ty\n-            }\n-            // (float, {float})\n-            (TyKind::Scalar(Scalar::Float(_)), TyKind::InferenceVar(_, TyVariableKind::Float)) => {\n-                lhs_ty\n-            }\n-            // ({int}, {int}) | ({float}, {float})\n-            (\n-                TyKind::InferenceVar(_, TyVariableKind::Integer),\n-                TyKind::InferenceVar(_, TyVariableKind::Integer),\n-            )\n-            | (\n-                TyKind::InferenceVar(_, TyVariableKind::Float),\n-                TyKind::InferenceVar(_, TyVariableKind::Float),\n-            ) => rhs_ty,\n-            _ => TyKind::Error.intern(&Interner),\n-        },\n-    }\n-}\n-\n-pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n-    match op {\n-        BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n-        BinaryOp::Assignment { op: None } => lhs_ty,\n-        BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty.kind(&Interner) {\n-            TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n-            TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-            _ => TyKind::Error.intern(&Interner),\n-        },\n-        BinaryOp::ArithOp(ArithOp::Shl | ArithOp::Shr) => TyKind::Error.intern(&Interner),\n-        BinaryOp::CmpOp(CmpOp::Ord { .. })\n-        | BinaryOp::Assignment { op: Some(_) }\n-        | BinaryOp::ArithOp(_) => match lhs_ty.kind(&Interner) {\n-            TyKind::Scalar(Scalar::Int(_) | Scalar::Uint(_) | Scalar::Float(_)) => lhs_ty,\n-            TyKind::InferenceVar(_, TyVariableKind::Integer | TyVariableKind::Float) => lhs_ty,\n-            _ => TyKind::Error.intern(&Interner),\n-        },\n-    }\n-}"}, {"sha": "dd3b86f05033ad8d25216bebb22b44eebc4fdb0c", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -630,3 +630,27 @@ fn test() {\n \"#,\n     )\n }\n+\n+#[test]\n+fn coerce_overloaded_binary_op_rhs() {\n+    check_types(\n+        r#\"\n+//- minicore: deref, add\n+\n+struct String {}\n+impl core::ops::Deref for String { type Target = str; }\n+\n+impl core::ops::Add<&str> for String {\n+    type Output = String;\n+}\n+\n+fn test() {\n+    let s1 = String {};\n+    let s2 = String {};\n+    s1 + &s2;\n+  //^^^^^^^^ String\n+}\n+\n+        \"#,\n+    );\n+}"}, {"sha": "a409c453b0edfe39f425e66a534e12d4c87e9270", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "modified", "additions": 12, "deletions": 77, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -2311,89 +2311,24 @@ fn generic_default_depending_on_other_type_arg_forward() {\n \n #[test]\n fn infer_operator_overload() {\n-    cov_mark::check!(infer_expr_inner_binary_operator_overload);\n-\n-    check_infer(\n+    check_types(\n         r#\"\n-        struct V2([f32; 2]);\n-\n-        #[lang = \"add\"]\n-        pub trait Add<Rhs = Self> {\n-            /// The resulting type after applying the `+` operator.\n-            type Output;\n+//- minicore: add\n+struct V2([f32; 2]);\n \n-            /// Performs the `+` operation.\n-            #[must_use]\n-            fn add(self, rhs: Rhs) -> Self::Output;\n-        }\n-\n-        impl Add<V2> for V2 {\n-            type Output = V2;\n-\n-            fn add(self, rhs: V2) -> V2 {\n-                let x = self.0[0] + rhs.0[0];\n-                let y = self.0[1] + rhs.0[1];\n-                V2([x, y])\n-            }\n-        }\n+impl core::ops::Add<V2> for V2 {\n+    type Output = V2;\n+}\n \n-        fn test() {\n-            let va = V2([0.0, 1.0]);\n-            let vb = V2([0.0, 1.0]);\n+fn test() {\n+    let va = V2([0.0, 1.0]);\n+    let vb = V2([0.0, 1.0]);\n \n-            let r = va + vb;\n-        }\n+    let r = va + vb;\n+    //      ^^^^^^^ V2\n+}\n \n         \"#,\n-        expect![[r#\"\n-            207..211 'self': Self\n-            213..216 'rhs': Rhs\n-            299..303 'self': V2\n-            305..308 'rhs': V2\n-            320..422 '{     ...     }': V2\n-            334..335 'x': f32\n-            338..342 'self': V2\n-            338..344 'self.0': [f32; 2]\n-            338..347 'self.0[0]': {unknown}\n-            338..358 'self.0...s.0[0]': f32\n-            345..346 '0': i32\n-            350..353 'rhs': V2\n-            350..355 'rhs.0': [f32; 2]\n-            350..358 'rhs.0[0]': {unknown}\n-            356..357 '0': i32\n-            372..373 'y': f32\n-            376..380 'self': V2\n-            376..382 'self.0': [f32; 2]\n-            376..385 'self.0[1]': {unknown}\n-            376..396 'self.0...s.0[1]': f32\n-            383..384 '1': i32\n-            388..391 'rhs': V2\n-            388..393 'rhs.0': [f32; 2]\n-            388..396 'rhs.0[1]': {unknown}\n-            394..395 '1': i32\n-            406..408 'V2': V2([f32; 2]) -> V2\n-            406..416 'V2([x, y])': V2\n-            409..415 '[x, y]': [f32; 2]\n-            410..411 'x': f32\n-            413..414 'y': f32\n-            436..519 '{     ... vb; }': ()\n-            446..448 'va': V2\n-            451..453 'V2': V2([f32; 2]) -> V2\n-            451..465 'V2([0.0, 1.0])': V2\n-            454..464 '[0.0, 1.0]': [f32; 2]\n-            455..458 '0.0': f32\n-            460..463 '1.0': f32\n-            475..477 'vb': V2\n-            480..482 'V2': V2([f32; 2]) -> V2\n-            480..494 'V2([0.0, 1.0])': V2\n-            483..493 '[0.0, 1.0]': [f32; 2]\n-            484..487 '0.0': f32\n-            489..492 '1.0': f32\n-            505..506 'r': V2\n-            509..511 'va': V2\n-            509..516 'va + vb': V2\n-            514..516 'vb': V2\n-        \"#]],\n     );\n }\n "}, {"sha": "2e074410cd44c871b0a43ebd3a09aa3b1c03a023", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -1798,66 +1798,32 @@ fn test() {\n \n #[test]\n fn closure_2() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r#\"\n-#[lang = \"add\"]\n-pub trait Add<Rhs = Self> {\n-    type Output;\n-    fn add(self, rhs: Rhs) -> Self::Output;\n-}\n+//- minicore: add, fn\n \n-trait FnOnce<Args> {\n-    type Output;\n-}\n-\n-impl Add for u64 {\n+impl core::ops::Add for u64 {\n     type Output = Self;\n     fn add(self, rhs: u64) -> Self::Output {0}\n }\n \n-impl Add for u128 {\n+impl core::ops::Add for u128 {\n     type Output = Self;\n     fn add(self, rhs: u128) -> Self::Output {0}\n }\n \n fn test<F: FnOnce(u32) -> u64>(f: F) {\n     f(1);\n+  //  ^ u32\n+  //^^^^ u64\n     let g = |v| v + 1;\n+              //^^^^^ u64\n+          //^^^^^^^^^ |u64| -> u64\n     g(1u64);\n+  //^^^^^^^ u64\n     let h = |v| 1u128 + v;\n+          //^^^^^^^^^^^^^ |u128| -> u128\n }\"#,\n-        expect![[r#\"\n-            72..76 'self': Self\n-            78..81 'rhs': Rhs\n-            203..207 'self': u64\n-            209..212 'rhs': u64\n-            235..238 '{0}': u64\n-            236..237 '0': u64\n-            297..301 'self': u128\n-            303..306 'rhs': u128\n-            330..333 '{0}': u128\n-            331..332 '0': u128\n-            368..369 'f': F\n-            374..450 '{     ...+ v; }': ()\n-            380..381 'f': F\n-            380..384 'f(1)': {unknown}\n-            382..383 '1': i32\n-            394..395 'g': |u64| -> u64\n-            398..407 '|v| v + 1': |u64| -> u64\n-            399..400 'v': u64\n-            402..403 'v': u64\n-            402..407 'v + 1': u64\n-            406..407 '1': u64\n-            413..414 'g': |u64| -> u64\n-            413..420 'g(1u64)': u64\n-            415..419 '1u64': u64\n-            430..431 'h': |u128| -> u128\n-            434..447 '|v| 1u128 + v': |u128| -> u128\n-            435..436 'v': u128\n-            438..443 '1u128': u128\n-            438..447 '1u128 + v': u128\n-            446..447 'v': u128\n-        \"#]],\n     );\n }\n "}, {"sha": "99e1f6e06faf59236b0c2baa354c9d0d959ee405", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -2773,8 +2773,8 @@ fn foo() {\n                                     file_id: FileId(\n                                         1,\n                                     ),\n-                                    full_range: 253..435,\n-                                    focus_range: 292..298,\n+                                    full_range: 254..436,\n+                                    focus_range: 293..299,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "5e17047a407e124e1d920b64e40379ca215e3c07", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c27243f953cadb1e09960a96123694bc2c83317/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=1c27243f953cadb1e09960a96123694bc2c83317", "patch": "@@ -34,6 +34,7 @@\n //!     derive:\n //!     fmt: result\n //!     bool_impl: option, fn\n+//!     add:\n \n pub mod marker {\n     // region:sized\n@@ -302,6 +303,14 @@ pub mod ops {\n     }\n     pub use self::try_::{ControlFlow, FromResidual, Try};\n     // endregion:try\n+\n+    // region:add\n+    #[lang = \"add\"]\n+    pub trait Add<Rhs = Self> {\n+        type Output;\n+        fn add(self, rhs: Rhs) -> Self::Output;\n+    }\n+    // endregion:add\n }\n \n // region:eq"}]}