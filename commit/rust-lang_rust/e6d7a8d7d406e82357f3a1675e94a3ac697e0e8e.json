{"sha": "e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "node_id": "C_kwDOAAsO6NoAKGU2ZDdhOGQ3ZDQwNmU4MjM1N2YzYTE2NzVlOTRhM2FjNjk3ZTBlOGU", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-18T14:10:56Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2022-02-20T12:38:15Z"}, "message": "Remove build_sibling_block", "tree": {"sha": "2b84b325970520ca1e133abe9c27a364e86d9c88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b84b325970520ca1e133abe9c27a364e86d9c88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "html_url": "https://github.com/rust-lang/rust/commit/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d7aa4763fe7f737d6add4261b9e050b36701089", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d7aa4763fe7f737d6add4261b9e050b36701089", "html_url": "https://github.com/rust-lang/rust/commit/6d7aa4763fe7f737d6add4261b9e050b36701089"}], "stats": {"total": 128, "additions": 68, "deletions": 60}, "files": [{"sha": "a576291cd51f0a4e4e7d7de4d5c44328558a449c", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "patch": "@@ -390,11 +390,6 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         bx\n     }\n \n-    fn build_sibling_block(&mut self, name: &str) -> Self {\n-        let block = self.append_sibling_block(name);\n-        Self::build(self.cx, block)\n-    }\n-\n     fn llbb(&self) -> Block<'gcc> {\n         self.block.expect(\"block\")\n     }\n@@ -880,28 +875,30 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         let start = dest.project_index(&mut self, zero).llval;\n         let end = dest.project_index(&mut self, count).llval;\n \n-        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n-        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n-        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+        let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n+        let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n+        let next_bb = self.append_sibling_block(\"repeat_loop_next\");\n \n         let ptr_type = start.get_type();\n         let current = self.llbb().get_function().new_local(None, ptr_type, \"loop_var\");\n         let current_val = current.to_rvalue();\n         self.assign(current, start);\n \n-        self.br(header_bx.llbb());\n+        self.br(header_bb);\n \n+        let mut header_bx = Builder::build(self.cx, header_bb);\n         let keep_going = header_bx.icmp(IntPredicate::IntNE, current_val, end);\n-        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+        header_bx.cond_br(keep_going, body_bb, next_bb);\n \n+        let mut body_bx = Builder::build(self.cx, body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n         cg_elem.val.store(&mut body_bx, PlaceRef::new_sized_aligned(current_val, cg_elem.layout, align));\n \n         let next = body_bx.inbounds_gep(self.backend_type(cg_elem.layout), current.to_rvalue(), &[self.const_usize(1)]);\n         body_bx.llbb().add_assignment(None, current, next);\n-        body_bx.br(header_bx.llbb());\n+        body_bx.br(header_bb);\n \n-        next_bx\n+        Builder::build(self.cx, next_bb)\n     }\n \n     fn range_metadata(&mut self, _load: RValue<'gcc>, _range: WrappingRange) {"}, {"sha": "478cc3c06f60161353d5bb1711749786334951eb", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "patch": "@@ -166,11 +166,6 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         Self::append_block(self.cx, self.llfn(), name)\n     }\n \n-    fn build_sibling_block(&mut self, name: &str) -> Self {\n-        let llbb = self.append_sibling_block(name);\n-        Self::build(self.cx, llbb)\n-    }\n-\n     fn ret_void(&mut self) {\n         unsafe {\n             llvm::LLVMBuildRetVoid(self.llbuilder);\n@@ -544,16 +539,19 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let start = dest.project_index(&mut self, zero).llval;\n         let end = dest.project_index(&mut self, count).llval;\n \n-        let mut header_bx = self.build_sibling_block(\"repeat_loop_header\");\n-        let mut body_bx = self.build_sibling_block(\"repeat_loop_body\");\n-        let next_bx = self.build_sibling_block(\"repeat_loop_next\");\n+        let header_bb = self.append_sibling_block(\"repeat_loop_header\");\n+        let body_bb = self.append_sibling_block(\"repeat_loop_body\");\n+        let next_bb = self.append_sibling_block(\"repeat_loop_next\");\n+\n+        self.br(header_bb);\n \n-        self.br(header_bx.llbb());\n+        let mut header_bx = Self::build(self.cx, header_bb);\n         let current = header_bx.phi(self.val_ty(start), &[start], &[self.llbb()]);\n \n         let keep_going = header_bx.icmp(IntPredicate::IntNE, current, end);\n-        header_bx.cond_br(keep_going, body_bx.llbb(), next_bx.llbb());\n+        header_bx.cond_br(keep_going, body_bb, next_bb);\n \n+        let mut body_bx = Self::build(self.cx, body_bb);\n         let align = dest.align.restrict_for_offset(dest.layout.field(self.cx(), 0).size);\n         cg_elem\n             .val\n@@ -564,10 +562,10 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n             current,\n             &[self.const_usize(1)],\n         );\n-        body_bx.br(header_bx.llbb());\n-        header_bx.add_incoming_to_phi(current, next, body_bx.llbb());\n+        body_bx.br(header_bb);\n+        header_bx.add_incoming_to_phi(current, next, body_bb);\n \n-        next_bx\n+        Self::build(self.cx, next_bb)\n     }\n \n     fn range_metadata(&mut self, load: &'ll Value, range: WrappingRange) {"}, {"sha": "b5c5148d51a2c765445a3edd5d5d468267798573", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "patch": "@@ -452,11 +452,11 @@ fn codegen_msvc_try<'ll>(\n     let (llty, llfn) = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n \n-        let mut normal = bx.build_sibling_block(\"normal\");\n-        let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n-        let mut catchpad_rust = bx.build_sibling_block(\"catchpad_rust\");\n-        let mut catchpad_foreign = bx.build_sibling_block(\"catchpad_foreign\");\n-        let mut caught = bx.build_sibling_block(\"caught\");\n+        let normal = bx.append_sibling_block(\"normal\");\n+        let catchswitch = bx.append_sibling_block(\"catchswitch\");\n+        let catchpad_rust = bx.append_sibling_block(\"catchpad_rust\");\n+        let catchpad_foreign = bx.append_sibling_block(\"catchpad_foreign\");\n+        let caught = bx.append_sibling_block(\"caught\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n@@ -520,12 +520,13 @@ fn codegen_msvc_try<'ll>(\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], normal.llbb(), catchswitch.llbb(), None);\n+        bx.invoke(try_func_ty, try_func, &[data], normal, catchswitch, None);\n \n+        let mut normal = Builder::build(bx.cx, normal);\n         normal.ret(bx.const_i32(0));\n \n-        let cs =\n-            catchswitch.catch_switch(None, None, &[catchpad_rust.llbb(), catchpad_foreign.llbb()]);\n+        let mut catchswitch = Builder::build(bx.cx, catchswitch);\n+        let cs = catchswitch.catch_switch(None, None, &[catchpad_rust, catchpad_foreign]);\n \n         // We can't use the TypeDescriptor defined in libpanic_unwind because it\n         // might be in another DLL and the SEH encoding only supports specifying\n@@ -558,20 +559,23 @@ fn codegen_msvc_try<'ll>(\n         // since our exception object effectively contains a Box.\n         //\n         // Source: MicrosoftCXXABI::getAddrOfCXXCatchHandlerType in clang\n+        let mut catchpad_rust = Builder::build(bx.cx, catchpad_rust);\n         let flags = bx.const_i32(8);\n         let funclet = catchpad_rust.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = catchpad_rust.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n         catchpad_rust.call(catch_ty, catch_func, &[data, ptr], Some(&funclet));\n-        catchpad_rust.catch_ret(&funclet, caught.llbb());\n+        catchpad_rust.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n+        let mut catchpad_foreign = Builder::build(bx.cx, catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = catchpad_foreign.catch_pad(cs, &[null, flags, null]);\n         catchpad_foreign.call(catch_ty, catch_func, &[data, null], Some(&funclet));\n-        catchpad_foreign.catch_ret(&funclet, caught.llbb());\n+        catchpad_foreign.catch_ret(&funclet, caught);\n \n+        let mut caught = Builder::build(bx.cx, caught);\n         caught.ret(bx.const_i32(1));\n     });\n \n@@ -613,14 +617,16 @@ fn codegen_gnu_try<'ll>(\n         //      (%ptr, _) = landingpad\n         //      call %catch_func(%data, %ptr)\n         //      ret 1\n-        let mut then = bx.build_sibling_block(\"then\");\n-        let mut catch = bx.build_sibling_block(\"catch\");\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n+        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+\n+        let mut then = Builder::build(bx.cx, then);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n@@ -629,6 +635,7 @@ fn codegen_gnu_try<'ll>(\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n+        let mut catch = Builder::build(bx.cx, catch);\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 1);\n         let tydesc = bx.const_null(bx.type_i8p());\n@@ -674,21 +681,24 @@ fn codegen_emcc_try<'ll>(\n         //      %catch_data[1] = %is_rust_panic\n         //      call %catch_func(%data, %catch_data)\n         //      ret 1\n-        let mut then = bx.build_sibling_block(\"then\");\n-        let mut catch = bx.build_sibling_block(\"catch\");\n+        let then = bx.append_sibling_block(\"then\");\n+        let catch = bx.append_sibling_block(\"catch\");\n \n         let try_func = llvm::get_param(bx.llfn(), 0);\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, try_func, &[data], then.llbb(), catch.llbb(), None);\n+        bx.invoke(try_func_ty, try_func, &[data], then, catch, None);\n+\n+        let mut then = Builder::build(bx.cx, then);\n         then.ret(bx.const_i32(0));\n \n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n         // being thrown.  The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n+        let mut catch = Builder::build(bx.cx, catch);\n         let tydesc = bx.eh_catch_typeinfo();\n         let lpad_ty = bx.type_struct(&[bx.type_i8p(), bx.type_i32()], false);\n         let vals = catch.landing_pad(lpad_ty, bx.eh_personality(), 2);"}, {"sha": "13d9a47b1068460ed8a89ff361803ec5479695e3", "filename": "compiler/rustc_codegen_llvm/src/va_arg.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fva_arg.rs?ref=e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "patch": "@@ -102,10 +102,10 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     let va_list_ty = va_list_layout.llvm_type(bx);\n     let layout = bx.cx.layout_of(target_ty);\n \n-    let mut maybe_reg = bx.build_sibling_block(\"va_arg.maybe_reg\");\n-    let mut in_reg = bx.build_sibling_block(\"va_arg.in_reg\");\n-    let mut on_stack = bx.build_sibling_block(\"va_arg.on_stack\");\n-    let mut end = bx.build_sibling_block(\"va_arg.end\");\n+    let maybe_reg = bx.append_sibling_block(\"va_arg.maybe_reg\");\n+    let in_reg = bx.append_sibling_block(\"va_arg.in_reg\");\n+    let on_stack = bx.append_sibling_block(\"va_arg.on_stack\");\n+    let end = bx.append_sibling_block(\"va_arg.end\");\n     let zero = bx.const_i32(0);\n     let offset_align = Align::from_bytes(4).unwrap();\n \n@@ -125,12 +125,13 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     // if the offset >= 0 then the value will be on the stack\n     let mut reg_off_v = bx.load(bx.type_i32(), reg_off, offset_align);\n     let use_stack = bx.icmp(IntPredicate::IntSGE, reg_off_v, zero);\n-    bx.cond_br(use_stack, on_stack.llbb(), maybe_reg.llbb());\n+    bx.cond_br(use_stack, on_stack, maybe_reg);\n \n     // The value at this point might be in a register, but there is a chance that\n     // it could be on the stack so we have to update the offset and then check\n     // the offset again.\n \n+    let mut maybe_reg = Builder::build(bx.cx, maybe_reg);\n     if gr_type && layout.align.abi.bytes() > 8 {\n         reg_off_v = maybe_reg.add(reg_off_v, bx.const_i32(15));\n         reg_off_v = maybe_reg.and(reg_off_v, bx.const_i32(-16));\n@@ -142,8 +143,9 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     // Check to see if we have overflowed the registers as a result of this.\n     // If we have then we need to use the stack for this value\n     let use_stack = maybe_reg.icmp(IntPredicate::IntSGT, new_reg_off_v, zero);\n-    maybe_reg.cond_br(use_stack, on_stack.llbb(), in_reg.llbb());\n+    maybe_reg.cond_br(use_stack, on_stack, in_reg);\n \n+    let mut in_reg = Builder::build(bx.cx, in_reg);\n     let top_type = bx.type_i8p();\n     let top = in_reg.struct_gep(va_list_ty, va_list_addr, reg_top_index);\n     let top = in_reg.load(top_type, top, bx.tcx().data_layout.pointer_align.abi);\n@@ -158,13 +160,15 @@ fn emit_aapcs_va_arg<'ll, 'tcx>(\n     let reg_type = layout.llvm_type(bx);\n     let reg_addr = in_reg.bitcast(reg_addr, bx.cx.type_ptr_to(reg_type));\n     let reg_value = in_reg.load(reg_type, reg_addr, layout.align.abi);\n-    in_reg.br(end.llbb());\n+    in_reg.br(end);\n \n     // On Stack block\n+    let mut on_stack = Builder::build(bx.cx, on_stack);\n     let stack_value =\n         emit_ptr_va_arg(&mut on_stack, list, target_ty, false, Align::from_bytes(8).unwrap(), true);\n-    on_stack.br(end.llbb());\n+    on_stack.br(end);\n \n+    let mut end = Builder::build(bx.cx, end);\n     let val = end.phi(\n         layout.immediate_llvm_type(bx),\n         &[reg_value, stack_value],"}, {"sha": "1979bbdb85970f8d3d5c377bcb646fc90e8e3376", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "patch": "@@ -452,15 +452,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Create the failure block and the conditional branch to it.\n         let lltarget = helper.llblock(self, target);\n-        let panic_block = bx.build_sibling_block(\"panic\");\n+        let panic_block = bx.append_sibling_block(\"panic\");\n         if expected {\n-            bx.cond_br(cond, lltarget, panic_block.llbb());\n+            bx.cond_br(cond, lltarget, panic_block);\n         } else {\n-            bx.cond_br(cond, panic_block.llbb(), lltarget);\n+            bx.cond_br(cond, panic_block, lltarget);\n         }\n \n         // After this point, bx is the block for the call to panic.\n-        bx = panic_block;\n+        bx = Bx::build(self.cx, panic_block);\n         self.set_debug_loc(&mut bx, terminator.source_info);\n \n         // Get the location information.\n@@ -908,10 +908,11 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             // Test whether the function pointer is associated with the type identifier.\n             let cond = bx.type_test(fn_ptr, typeid_metadata);\n-            let mut bx_pass = bx.build_sibling_block(\"type_test.pass\");\n-            let mut bx_fail = bx.build_sibling_block(\"type_test.fail\");\n-            bx.cond_br(cond, bx_pass.llbb(), bx_fail.llbb());\n+            let bb_pass = bx.append_sibling_block(\"type_test.pass\");\n+            let bb_fail = bx.append_sibling_block(\"type_test.fail\");\n+            bx.cond_br(cond, bb_pass, bb_fail);\n \n+            let mut bx_pass = Bx::build(self.cx, bb_pass);\n             helper.do_call(\n                 self,\n                 &mut bx_pass,\n@@ -922,6 +923,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 cleanup,\n             );\n \n+            let mut bx_fail = Bx::build(self.cx, bb_fail);\n             bx_fail.abort();\n             bx_fail.unreachable();\n \n@@ -1441,7 +1443,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         })\n     }\n \n-    // FIXME(eddyb) replace with `build_sibling_block`/`append_sibling_block`\n+    // FIXME(eddyb) replace with `append_sibling_block`\n     // (which requires having a `Bx` already, and not all callers do).\n     fn new_block(&self, name: &str) -> Bx {\n         let llbb = Bx::append_block(self.cx, self.llfn, name);"}, {"sha": "6c7162c68d45e134c0e31c1804f3cf184cd996a8", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=e6d7a8d7d406e82357f3a1675e94a3ac697e0e8e", "patch": "@@ -53,9 +53,6 @@ pub trait BuilderMethods<'a, 'tcx>:\n \n     fn append_sibling_block(&mut self, name: &str) -> Self::BasicBlock;\n \n-    // FIXME(eddyb) replace with callers using `append_sibling_block`.\n-    fn build_sibling_block(&mut self, name: &str) -> Self;\n-\n     fn ret_void(&mut self);\n     fn ret(&mut self, v: Self::Value);\n     fn br(&mut self, dest: Self::BasicBlock);"}]}