{"sha": "1be170b01addf84534b51d68e2d5ac76a1a42ac6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZTE3MGIwMWFkZGY4NDUzNGI1MWQ2OGUyZDVhYzc2YTFhNDJhYzY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-31T23:00:24Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:33:31Z"}, "message": "Replace BlockAndBuilder with Builder.", "tree": {"sha": "70ba37fde7786c1bda8ce4b84b7c9db92f965163", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70ba37fde7786c1bda8ce4b84b7c9db92f965163"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be170b01addf84534b51d68e2d5ac76a1a42ac6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be170b01addf84534b51d68e2d5ac76a1a42ac6", "html_url": "https://github.com/rust-lang/rust/commit/1be170b01addf84534b51d68e2d5ac76a1a42ac6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be170b01addf84534b51d68e2d5ac76a1a42ac6/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d40d01bd0e7d9d20bb3454a3d0870f00b805a01c", "url": "https://api.github.com/repos/rust-lang/rust/commits/d40d01bd0e7d9d20bb3454a3d0870f00b805a01c", "html_url": "https://github.com/rust-lang/rust/commit/d40d01bd0e7d9d20bb3454a3d0870f00b805a01c"}], "stats": {"total": 701, "additions": 344, "deletions": 357}, "files": [{"sha": "18f433eb16249689b36c1a037b1b76d783b04e8f", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -10,7 +10,8 @@\n \n use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n use base;\n-use common::{type_is_fat_ptr, BlockAndBuilder, C_uint};\n+use builder::Builder;\n+use common::{type_is_fat_ptr, C_uint};\n use context::CrateContext;\n use cabi_x86;\n use cabi_x86_64;\n@@ -236,7 +237,7 @@ impl ArgType {\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &BlockAndBuilder, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder, mut val: ValueRef, dst: ValueRef) {\n         if self.is_ignore() {\n             return;\n         }\n@@ -269,7 +270,7 @@ impl ArgType {\n                 //   bitcasting to the struct type yields invalid cast errors.\n \n                 // We instead thus allocate some scratch space...\n-                let llscratch = bcx.fcx().alloca(ty, \"abi_cast\");\n+                let llscratch = bcx.alloca(ty, \"abi_cast\");\n                 base::Lifetime::Start.call(bcx, llscratch);\n \n                 // ...where we first store the value...\n@@ -293,14 +294,16 @@ impl ArgType {\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &BlockAndBuilder, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(\n+        &self, bcx: &Builder, idx: &mut usize, dst: ValueRef\n+    ) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n         if self.is_ignore() {\n             return;\n         }\n-        let val = llvm::get_param(bcx.fcx().llfn, *idx as c_uint);\n+        let val = llvm::get_param(bcx.llfn(), *idx as c_uint);\n         *idx += 1;\n         self.store(bcx, val, dst);\n     }"}, {"sha": "29a41acd0e557221017620d301206b595a633830", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -49,6 +49,7 @@ use llvm::{ValueRef, True, IntEQ, IntNE};\n use rustc::ty::layout;\n use rustc::ty::{self, Ty, AdtKind};\n use common::*;\n+use builder::Builder;\n use glue;\n use base;\n use machine;\n@@ -303,7 +304,7 @@ fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>\n /// Obtain a representation of the discriminant sufficient to translate\n /// destructuring; this may or may not involve the actual discriminant.\n pub fn trans_switch<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     t: Ty<'tcx>,\n     scrutinee: ValueRef,\n     range_assert: bool\n@@ -331,7 +332,7 @@ pub fn is_discr_signed<'tcx>(l: &layout::Layout) -> bool {\n \n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     t: Ty<'tcx>,\n     scrutinee: ValueRef,\n     cast_to: Option<Type>,\n@@ -374,7 +375,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n }\n \n fn struct_wrapped_nullable_bitdiscr(\n-    bcx: &BlockAndBuilder,\n+    bcx: &Builder,\n     nndiscr: u64,\n     discrfield: &layout::FieldPath,\n     scrutinee: ValueRef\n@@ -387,7 +388,7 @@ fn struct_wrapped_nullable_bitdiscr(\n }\n \n /// Helper for cases where the discriminant is simply loaded.\n-fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n+fn load_discr(bcx: &Builder, ity: layout::Integer, ptr: ValueRef, min: u64, max: u64,\n               range_assert: bool)\n     -> ValueRef {\n     let llty = Type::from_integer(bcx.ccx, ity);\n@@ -415,7 +416,7 @@ fn load_discr(bcx: &BlockAndBuilder, ity: layout::Integer, ptr: ValueRef, min: u\n /// discriminant-like value returned by `trans_switch`.\n ///\n /// This should ideally be less tightly tied to `_match`.\n-pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n+pub fn trans_case<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, value: Disr) -> ValueRef {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n         layout::CEnum { discr, .. }\n@@ -436,7 +437,7 @@ pub fn trans_case<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, value:\n /// Set the discriminant for a new value of the given case of the given\n /// representation.\n pub fn trans_set_discr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n+    bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: ValueRef, to: Disr\n ) {\n     let l = bcx.ccx.layout_of(t);\n     match *l {\n@@ -484,8 +485,8 @@ pub fn trans_set_discr<'a, 'tcx>(\n     }\n }\n \n-fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>) -> bool {\n-    bcx.sess().target.target.arch == \"arm\" || bcx.sess().target.target.arch == \"aarch64\"\n+fn target_sets_discr_via_memset<'a, 'tcx>(bcx: &Builder<'a, 'tcx>) -> bool {\n+    bcx.ccx.sess().target.target.arch == \"arm\" || bcx.ccx.sess().target.target.arch == \"aarch64\"\n }\n \n fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n@@ -498,7 +499,7 @@ fn assert_discr_in_range(min: Disr, max: Disr, discr: Disr) {\n \n /// Access a field, at a point when the value's case is known.\n pub fn trans_field_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     t: Ty<'tcx>,\n     val: MaybeSizedValue,\n     discr: Disr,\n@@ -560,7 +561,7 @@ pub fn trans_field_ptr<'a, 'tcx>(\n }\n \n fn struct_field_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     st: &layout::Struct,\n     fields: &Vec<Ty<'tcx>>,\n     val: MaybeSizedValue,"}, {"sha": "0912e54bf537e3f318f255df523f7e86501332d7", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -15,6 +15,7 @@ use base;\n use common::*;\n use type_of;\n use type_::Type;\n+use builder::Builder;\n \n use rustc::hir;\n use rustc::ty::Ty;\n@@ -25,7 +26,7 @@ use libc::{c_uint, c_char};\n \n // Take an inline assembly expression and splat it out via LLVM\n pub fn trans_inline_asm<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     ia: &hir::InlineAsm,\n     outputs: Vec<(ValueRef, Ty<'tcx>)>,\n     mut inputs: Vec<ValueRef>\n@@ -61,7 +62,7 @@ pub fn trans_inline_asm<'a, 'tcx>(\n \n     // Default per-arch clobbers\n     // Basically what clang does\n-    let arch_clobbers = match &bcx.sess().target.target.arch[..] {\n+    let arch_clobbers = match &bcx.ccx.sess().target.target.arch[..] {\n         \"x86\" | \"x86_64\" => vec![\"~{dirflag}\", \"~{fpsr}\", \"~{flags}\"],\n         _                => Vec::new()\n     };"}, {"sha": "cb45f9c05126471e6a16f0daeaa4a79844c35c93", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -38,7 +38,7 @@ use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use middle::lang_items::StartFnLangItem;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n@@ -51,7 +51,7 @@ use adt;\n use attributes;\n use builder::Builder;\n use callee::{Callee};\n-use common::{BlockAndBuilder, C_bool, C_bytes_in_context, C_i32, C_uint};\n+use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n use common::{CrateContext, FunctionContext};\n@@ -161,7 +161,7 @@ pub fn bin_op_to_fcmp_predicate(op: hir::BinOp_) -> llvm::RealPredicate {\n }\n \n pub fn compare_simd_types<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef,\n     t: Ty<'tcx>,\n@@ -218,7 +218,7 @@ pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n \n /// Coerce `src` to `dst_ty`. `src_ty` must be a thin pointer.\n pub fn unsize_thin_ptr<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     src: ValueRef,\n     src_ty: Ty<'tcx>,\n     dst_ty: Ty<'tcx>\n@@ -242,7 +242,7 @@ pub fn unsize_thin_ptr<'a, 'tcx>(\n \n /// Coerce `src`, which is a reference to a value of type `src_ty`,\n /// to a value of type `dst_ty` and store the result in `dst`\n-pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn coerce_unsized_into<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                      src: ValueRef,\n                                      src_ty: Ty<'tcx>,\n                                      dst: ValueRef,\n@@ -272,10 +272,10 @@ pub fn coerce_unsized_into<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             assert_eq!(def_a, def_b);\n \n             let src_fields = def_a.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.tcx(), substs_a, f)\n+                monomorphize::field_ty(bcx.ccx.tcx(), substs_a, f)\n             });\n             let dst_fields = def_b.variants[0].fields.iter().map(|f| {\n-                monomorphize::field_ty(bcx.tcx(), substs_b, f)\n+                monomorphize::field_ty(bcx.ccx.tcx(), substs_b, f)\n             });\n \n             let src = adt::MaybeSizedValue::sized(src);\n@@ -322,7 +322,7 @@ pub fn custom_coerce_unsize_info<'scx, 'tcx>(scx: &SharedCrateContext<'scx, 'tcx\n }\n \n pub fn cast_shift_expr_rhs(\n-    cx: &BlockAndBuilder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n+    cx: &Builder, op: hir::BinOp_, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     cast_shift_rhs(op, lhs, rhs, |a, b| cx.trunc(a, b), |a, b| cx.zext(a, b))\n }\n@@ -421,7 +421,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n-pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n+pub fn store_ty<'a, 'tcx>(cx: &Builder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n     if common::type_is_fat_ptr(cx.ccx, t) {\n@@ -433,7 +433,7 @@ pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: Valu\n     }\n }\n \n-pub fn store_fat_ptr<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn store_fat_ptr<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n                                data: ValueRef,\n                                extra: ValueRef,\n                                dst: ValueRef,\n@@ -459,15 +459,15 @@ pub fn load_fat_ptr<'a, 'tcx>(\n     (ptr, meta)\n }\n \n-pub fn from_immediate(bcx: &BlockAndBuilder, val: ValueRef) -> ValueRef {\n+pub fn from_immediate(bcx: &Builder, val: ValueRef) -> ValueRef {\n     if val_ty(val) == Type::i1(bcx.ccx) {\n         bcx.zext(val, Type::i8(bcx.ccx))\n     } else {\n         val\n     }\n }\n \n-pub fn to_immediate(bcx: &BlockAndBuilder, val: ValueRef, ty: Ty) -> ValueRef {\n+pub fn to_immediate(bcx: &Builder, val: ValueRef, ty: Ty) -> ValueRef {\n     if ty.is_bool() {\n         bcx.trunc(val, Type::i1(bcx.ccx))\n     } else {\n@@ -523,11 +523,13 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n }\n \n-pub fn memcpy_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                           dst: ValueRef,\n-                           src: ValueRef,\n-                           t: Ty<'tcx>,\n-                           align: Option<u32>) {\n+pub fn memcpy_ty<'a, 'tcx>(\n+    bcx: &Builder<'a, 'tcx>,\n+    dst: ValueRef,\n+    src: ValueRef,\n+    t: Ty<'tcx>,\n+    align: Option<u32>,\n+) {\n     let ccx = bcx.ccx;\n \n     if type_is_zero_size(ccx, t) {\n@@ -553,11 +555,6 @@ pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     b.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None)\n }\n \n-pub fn alloc_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, ty: Ty<'tcx>, name: &str) -> ValueRef {\n-    assert!(!ty.has_param_types());\n-    bcx.fcx().alloca(type_of::type_of(bcx.ccx, ty), name)\n-}\n-\n pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance<'tcx>) {\n     let _s = if ccx.sess().trans_stats() {\n         let mut instance_name = String::new();\n@@ -623,7 +620,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             // We create an alloca to hold a pointer of type `ret.original_ty`\n             // which will hold the pointer to the right alloca which has the\n             // final ret value\n-            fcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n+            bcx.alloca(fn_ty.ret.memory_ty(ccx), \"sret_slot\")\n         };\n         let dest_val = adt::MaybeSizedValue::sized(dest); // Can return unsized value\n         let mut llarg_idx = fn_ty.ret.is_indirect() as usize;\n@@ -756,12 +753,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n         // `main` should respect same config for frame pointer elimination as rest of code\n         attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-        let llbb = unsafe {\n-            let name = CString::new(\"top\").unwrap();\n-            llvm::LLVMAppendBasicBlockInContext(ccx.llcx(), llfn, name.as_ptr())\n-        };\n-        let bld = Builder::with_ccx(ccx);\n-        bld.position_at_end(llbb);\n+        let bld = Builder::new_block(ccx, llfn, \"top\");\n \n         debuginfo::gdb::insert_reference_to_gdb_debug_scripts_section_global(ccx, &bld);\n "}, {"sha": "6ea048d7ed3bf479cba8beccd2b760c9cb11b1a6", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -19,12 +19,16 @@ use machine::llalign_of_pref;\n use type_::Type;\n use value::Value;\n use libc::{c_uint, c_char};\n+use rustc::ty::{Ty, TypeFoldable};\n+use type_of;\n \n use std::borrow::Cow;\n use std::ffi::CString;\n use std::ptr;\n use syntax_pos::Span;\n \n+// All Builders must have an llfn associated with them\n+#[must_use]\n pub struct Builder<'a, 'tcx: 'a> {\n     pub llbuilder: BuilderRef,\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n@@ -46,6 +50,20 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn new_block<'b>(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n+        let builder = Builder::with_ccx(ccx);\n+        let llbb = unsafe {\n+            let name = CString::new(name).unwrap();\n+            llvm::LLVMAppendBasicBlockInContext(\n+                ccx.llcx(),\n+                llfn,\n+                name.as_ptr()\n+            )\n+        };\n+        builder.position_at_end(llbb);\n+        builder\n+    }\n+\n     pub fn with_ccx(ccx: &'a CrateContext<'a, 'tcx>) -> Self {\n         // Create a fresh builder from the crate context.\n         let llbuilder = unsafe {\n@@ -57,6 +75,32 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn build_new_block<'b>(&self, name: &'b str) -> Builder<'a, 'tcx> {\n+        let builder = Builder::with_ccx(self.ccx);\n+        let llbb = unsafe {\n+            let name = CString::new(name).unwrap();\n+            llvm::LLVMAppendBasicBlockInContext(\n+                self.ccx.llcx(),\n+                self.llfn(),\n+                name.as_ptr()\n+            )\n+        };\n+        builder.position_at_end(llbb);\n+        builder\n+    }\n+\n+    pub fn llfn(&self) -> ValueRef {\n+        unsafe {\n+            llvm::LLVMGetBasicBlockParent(self.llbb())\n+        }\n+    }\n+\n+    pub fn llbb(&self) -> BasicBlockRef {\n+        unsafe {\n+            llvm::LLVMGetInsertBlock(self.llbuilder)\n+        }\n+    }\n+\n     fn count_insn(&self, category: &str) {\n         if self.ccx.sess().trans_stats() {\n             self.ccx.stats().n_llvm_insns.set(self.ccx.stats().n_llvm_insns.get() + 1);\n@@ -435,6 +479,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n+        let builder = Builder::with_ccx(self.ccx);\n+        builder.position_at_start(unsafe {\n+            llvm::LLVMGetFirstBasicBlock(self.llfn())\n+        });\n+        builder.dynamic_alloca(ty, name)\n+    }\n+\n+    pub fn alloca_ty(&self, ty: Ty<'tcx>, name: &str) -> ValueRef {\n+        assert!(!ty.has_param_types());\n+        self.alloca(type_of::type_of(self.ccx, ty), name)\n+    }\n+\n     pub fn dynamic_alloca(&self, ty: Type, name: &str) -> ValueRef {\n         self.count_insn(\"alloca\");\n         unsafe {"}, {"sha": "aabd3083ff53cfbaf54480a140ec52b074f27e90", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -23,7 +23,6 @@ use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n use base;\n-use base::*;\n use common::{\n     self, CrateContext, FunctionContext, SharedCrateContext\n };\n@@ -348,7 +347,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     let llenv = if env_arg.is_indirect() {\n         llargs[self_idx]\n     } else {\n-        let scratch = alloc_ty(&bcx, closure_ty, \"self\");\n+        let scratch = bcx.alloca_ty(closure_ty, \"self\");\n         let mut llarg_idx = self_idx;\n         env_arg.store_fn_arg(&bcx, &mut llarg_idx, scratch);\n         scratch\n@@ -365,12 +364,12 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.schedule_drop_mem(MaybeSizedValue::sized(llenv), closure_ty);\n+    let self_scope = fcx.schedule_drop_mem(&bcx, MaybeSizedValue::sized(llenv), closure_ty);\n \n     let llfn = callee.reify(bcx.ccx);\n     let llret;\n     if let Some(landing_pad) = self_scope.landing_pad {\n-        let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+        let normal_bcx = bcx.build_new_block(\"normal-return\");\n         llret = bcx.invoke(llfn, &llargs[..], normal_bcx.llbb(), landing_pad, None);\n         bcx = normal_bcx;\n     } else {"}, {"sha": "bb8faefffecd49c8ba2905aed841b60fd5c2ee10", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -21,7 +21,8 @@\n use llvm::BasicBlockRef;\n use base;\n use adt::MaybeSizedValue;\n-use common::{BlockAndBuilder, FunctionContext, Funclet};\n+use builder::Builder;\n+use common::{FunctionContext, Funclet};\n use glue;\n use type_::Type;\n use rustc::ty::Ty;\n@@ -42,7 +43,7 @@ pub struct DropValue<'tcx> {\n }\n \n impl<'tcx> DropValue<'tcx> {\n-    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &BlockAndBuilder<'a, 'tcx>) {\n+    fn trans<'a>(&self, funclet: Option<&'a Funclet>, bcx: &Builder<'a, 'tcx>) {\n         glue::call_drop_glue(bcx, self.val, self.ty, self.skip_dtor, funclet)\n     }\n \n@@ -52,13 +53,13 @@ impl<'tcx> DropValue<'tcx> {\n     ///     landing_pad -> ... cleanups ... -> [resume]\n     ///\n     /// This should only be called once per function, as it creates an alloca for the landingpad.\n-    fn get_landing_pad<'a>(&self, fcx: &FunctionContext<'a, 'tcx>) -> BasicBlockRef {\n+    fn get_landing_pad<'a>(&self, bcx: &Builder<'a, 'tcx>) -> BasicBlockRef {\n         debug!(\"get_landing_pad\");\n-        let bcx = fcx.build_new_block(\"cleanup_unwind\");\n+        let bcx = bcx.build_new_block(\"cleanup_unwind\");\n         let llpersonality = bcx.ccx.eh_personality();\n         bcx.set_personality_fn(llpersonality);\n \n-        if base::wants_msvc_seh(fcx.ccx.sess()) {\n+        if base::wants_msvc_seh(bcx.ccx.sess()) {\n             let pad = bcx.cleanup_pad(None, &[]);\n             let funclet = Some(Funclet::new(pad));\n             self.trans(funclet.as_ref(), &bcx);\n@@ -68,18 +69,18 @@ impl<'tcx> DropValue<'tcx> {\n             // The landing pad return type (the type being propagated). Not sure\n             // what this represents but it's determined by the personality\n             // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n+            let llretty = Type::struct_(bcx.ccx, &[Type::i8p(bcx.ccx), Type::i32(bcx.ccx)], false);\n \n             // The only landing pad clause will be 'cleanup'\n-            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.fcx().llfn);\n+            let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.llfn());\n \n             // The landing pad block is a cleanup\n             bcx.set_cleanup(llretval);\n \n             // Insert cleanup instructions into the cleanup block\n             self.trans(None, &bcx);\n \n-            if !bcx.sess().target.target.options.custom_unwind_resume {\n+            if !bcx.ccx.sess().target.target.options.custom_unwind_resume {\n                 bcx.resume(llretval);\n             } else {\n                 let exc_ptr = bcx.extract_value(llretval, 0);\n@@ -94,24 +95,27 @@ impl<'tcx> DropValue<'tcx> {\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n-    pub fn schedule_drop_mem(&self, val: MaybeSizedValue, ty: Ty<'tcx>) -> CleanupScope<'tcx> {\n+    pub fn schedule_drop_mem(\n+        &self, bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n+    ) -> CleanupScope<'tcx> {\n         if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n         let drop = DropValue {\n             val: val,\n             ty: ty,\n             skip_dtor: false,\n         };\n \n-        CleanupScope::new(self, drop)\n+        CleanupScope::new(bcx, drop)\n     }\n \n     /// Issue #23611: Schedules a (deep) drop of the contents of\n     /// `val`, which is a pointer to an instance of struct/enum type\n     /// `ty`. The scheduled code handles extracting the discriminant\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n-    pub fn schedule_drop_adt_contents(&self, val: MaybeSizedValue, ty: Ty<'tcx>)\n-        -> CleanupScope<'tcx> {\n+    pub fn schedule_drop_adt_contents(\n+        &self, bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n+    ) -> CleanupScope<'tcx> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n         if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n@@ -122,16 +126,16 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             skip_dtor: true,\n         };\n \n-        CleanupScope::new(self, drop)\n+        CleanupScope::new(bcx, drop)\n     }\n }\n \n impl<'tcx> CleanupScope<'tcx> {\n-    fn new<'a>(fcx: &FunctionContext<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n+    fn new<'a>(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n             cleanup: Some(drop_val),\n-            landing_pad: if !fcx.ccx.sess().no_landing_pads() {\n-                Some(drop_val.get_landing_pad(fcx))\n+            landing_pad: if !bcx.ccx.sess().no_landing_pads() {\n+                Some(drop_val.get_landing_pad(bcx))\n             } else {\n                 None\n             },\n@@ -145,7 +149,7 @@ impl<'tcx> CleanupScope<'tcx> {\n         }\n     }\n \n-    pub fn trans<'a>(self, bcx: &'a BlockAndBuilder<'a, 'tcx>) {\n+    pub fn trans<'a>(self, bcx: &'a Builder<'a, 'tcx>) {\n         if let Some(cleanup) = self.cleanup {\n             cleanup.trans(None, &bcx);\n         }"}, {"sha": "09be09a2b0aeca88ff36c1f3c0d3ff13dd68f004", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 14, "deletions": 87, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -12,7 +12,6 @@\n \n //! Code that is useful in various trans modules.\n \n-use session::Session;\n use llvm;\n use llvm::{ValueRef, BasicBlockRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n@@ -37,7 +36,6 @@ use rustc::hir;\n use libc::{c_uint, c_char};\n use std::borrow::Cow;\n use std::iter;\n-use std::ops::Deref;\n use std::ffi::CString;\n \n use syntax::ast;\n@@ -235,8 +233,6 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // This function's enclosing crate context.\n     pub ccx: &'a CrateContext<'a, 'tcx>,\n-\n-    alloca_builder: Builder<'a, 'tcx>,\n }\n \n impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n@@ -247,30 +243,18 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n             llfn: llfndecl,\n             alloca_insert_pt: None,\n             ccx: ccx,\n-            alloca_builder: Builder::with_ccx(ccx),\n-        };\n-\n-        let val = {\n-            let entry_bcx = fcx.build_new_block(\"entry-block\");\n-            let val = entry_bcx.load(C_null(Type::i8p(ccx)));\n-            fcx.alloca_builder.position_at_start(entry_bcx.llbb());\n-            val\n         };\n \n+        let entry_bcx = Builder::new_block(fcx.ccx, fcx.llfn, \"entry-block\");\n+        entry_bcx.position_at_start(entry_bcx.llbb());\n         // Use a dummy instruction as the insertion point for all allocas.\n         // This is later removed in the drop of FunctionContext.\n-        fcx.alloca_insert_pt = Some(val);\n+        fcx.alloca_insert_pt = Some(entry_bcx.load(C_null(Type::i8p(ccx))));\n \n         fcx\n     }\n \n-    pub fn get_entry_block(&'a self) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(unsafe {\n-            llvm::LLVMGetFirstBasicBlock(self.llfn)\n-        }, self)\n-    }\n-\n-    pub fn new_block(&'a self, name: &str) -> BasicBlockRef {\n+    pub fn new_block(&self, name: &str) -> BasicBlockRef {\n         unsafe {\n             let name = CString::new(name).unwrap();\n             llvm::LLVMAppendBasicBlockInContext(\n@@ -281,12 +265,14 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n     }\n \n-    pub fn build_new_block(&'a self, name: &str) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(self.new_block(name), self)\n+    pub fn build_new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n+        Builder::new_block(self.ccx, self.llfn, name)\n     }\n \n-    pub fn alloca(&self, ty: Type, name: &str) -> ValueRef {\n-        self.alloca_builder.dynamic_alloca(ty, name)\n+    pub fn get_entry_block(&'a self) -> Builder<'a, 'tcx> {\n+        let builder = Builder::with_ccx(self.ccx);\n+        builder.position_at_end(unsafe { llvm::LLVMGetFirstBasicBlock(self.llfn) });\n+        builder\n     }\n }\n \n@@ -298,65 +284,6 @@ impl<'a, 'tcx> Drop for FunctionContext<'a, 'tcx> {\n     }\n }\n \n-#[must_use]\n-pub struct BlockAndBuilder<'a, 'tcx: 'a> {\n-    // The BasicBlockRef returned from a call to\n-    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n-    // block to the function pointed to by llfn.  We insert\n-    // instructions into that block by way of this block context.\n-    // The block pointing to this one in the function's digraph.\n-    llbb: BasicBlockRef,\n-\n-    // The function context for the function to which this block is\n-    // attached.\n-    fcx: &'a FunctionContext<'a, 'tcx>,\n-\n-    builder: Builder<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n-    pub fn new(llbb: BasicBlockRef, fcx: &'a FunctionContext<'a, 'tcx>) -> Self {\n-        let builder = Builder::with_ccx(fcx.ccx);\n-        // Set the builder's position to this block's end.\n-        builder.position_at_end(llbb);\n-        BlockAndBuilder {\n-            llbb: llbb,\n-            fcx: fcx,\n-            builder: builder,\n-        }\n-    }\n-\n-    pub fn at_start<F, R>(&self, f: F) -> R\n-        where F: FnOnce(&BlockAndBuilder<'a, 'tcx>) -> R\n-    {\n-        self.position_at_start(self.llbb);\n-        let r = f(self);\n-        self.position_at_end(self.llbb);\n-        r\n-    }\n-\n-    pub fn fcx(&self) -> &'a FunctionContext<'a, 'tcx> {\n-        self.fcx\n-    }\n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.ccx.tcx()\n-    }\n-    pub fn sess(&self) -> &'a Session {\n-        self.ccx.sess()\n-    }\n-\n-    pub fn llbb(&self) -> BasicBlockRef {\n-        self.llbb\n-    }\n-}\n-\n-impl<'a, 'tcx> Deref for BlockAndBuilder<'a, 'tcx> {\n-    type Target = Builder<'a, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.builder\n-    }\n-}\n-\n /// A structure representing an active landing pad for the duration of a basic\n /// block.\n ///\n@@ -725,7 +652,7 @@ pub fn langcall(tcx: TyCtxt,\n // of Java. (See related discussion on #1877 and #10183.)\n \n pub fn build_unchecked_lshift<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     lhs: ValueRef,\n     rhs: ValueRef\n ) -> ValueRef {\n@@ -736,7 +663,7 @@ pub fn build_unchecked_lshift<'a, 'tcx>(\n }\n \n pub fn build_unchecked_rshift<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n+    bcx: &Builder<'a, 'tcx>, lhs_t: Ty<'tcx>, lhs: ValueRef, rhs: ValueRef\n ) -> ValueRef {\n     let rhs = base::cast_shift_expr_rhs(bcx, hir::BinOp_::BiShr, lhs, rhs);\n     // #1877, #10183: Ensure that input is always valid\n@@ -749,13 +676,13 @@ pub fn build_unchecked_rshift<'a, 'tcx>(\n     }\n }\n \n-fn shift_mask_rhs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n+fn shift_mask_rhs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, rhs: ValueRef) -> ValueRef {\n     let rhs_llty = val_ty(rhs);\n     bcx.and(rhs, shift_mask_val(bcx, rhs_llty, rhs_llty, false))\n }\n \n pub fn shift_mask_val<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     llty: Type,\n     mask_llty: Type,\n     invert: bool"}, {"sha": "9117f49cf3ea5b8aaa3ec3fc0a343df1e0113a81", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -27,7 +27,8 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n \n use abi::Abi;\n-use common::{CrateContext, BlockAndBuilder};\n+use common::CrateContext;\n+use builder::Builder;\n use monomorphize::{self, Instance};\n use rustc::ty::{self, Ty};\n use rustc::mir;\n@@ -423,7 +424,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-pub fn declare_local<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                dbg_context: &FunctionDebugContext,\n                                variable_name: ast::Name,\n                                variable_type: Ty<'tcx>,"}, {"sha": "c27576f9016aef2c3745f5715a43dc5671659622", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -35,16 +35,17 @@ use type_::Type;\n use value::Value;\n use Disr;\n use cleanup::CleanupScope;\n+use builder::Builder;\n \n use syntax_pos::DUMMY_SP;\n \n pub fn trans_exchange_free_ty<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     ptr: MaybeSizedValue,\n     content_ty: Ty<'tcx>\n ) {\n-    let def_id = langcall(bcx.tcx(), None, \"\", BoxFreeFnLangItem);\n-    let substs = bcx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n+    let def_id = langcall(bcx.ccx.tcx(), None, \"\", BoxFreeFnLangItem);\n+    let substs = bcx.ccx.tcx().mk_substs(iter::once(Kind::from(content_ty)));\n     let callee = Callee::def(bcx.ccx, def_id, substs);\n \n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n@@ -93,12 +94,12 @@ pub fn get_drop_glue_type<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'t\n     }\n }\n \n-fn drop_ty<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n+fn drop_ty<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, args: MaybeSizedValue, t: Ty<'tcx>) {\n     call_drop_glue(bcx, args, t, false, None)\n }\n \n pub fn call_drop_glue<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     mut args: MaybeSizedValue,\n     t: Ty<'tcx>,\n     skip_dtor: bool,\n@@ -232,7 +233,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n         }\n         ty::TyAdt(def, ..) if def.dtor_kind().is_present() && !skip_dtor => {\n             let shallow_drop = def.is_union();\n-            let tcx = bcx.tcx();\n+            let tcx = bcx.ccx.tcx();\n \n             let def = t.ty_adt_def().unwrap();\n \n@@ -245,7 +246,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // Issue #23611: schedule cleanup of contents, re-inspecting the\n             // discriminant (if any) in case of variant swap in drop code.\n             let contents_scope = if !shallow_drop {\n-                bcx.fcx().schedule_drop_adt_contents(ptr, t)\n+                fcx.schedule_drop_adt_contents(&bcx, ptr, t)\n             } else {\n                 CleanupScope::noop()\n             };\n@@ -264,7 +265,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             let llret;\n             let args = &[ptr.value, ptr.meta][..1 + ptr.has_meta() as usize];\n             if let Some(landing_pad) = contents_scope.landing_pad {\n-                let normal_bcx = bcx.fcx().build_new_block(\"normal-return\");\n+                let normal_bcx = bcx.build_new_block(\"normal-return\");\n                 llret = bcx.invoke(callee.reify(ccx), args, normal_bcx.llbb(), landing_pad, None);\n                 bcx = normal_bcx;\n             } else {\n@@ -288,8 +289,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     bcx.ret_void();\n }\n \n-pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                                       t: Ty<'tcx>, info: ValueRef)\n+pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, info: ValueRef)\n                                        -> (ValueRef, ValueRef) {\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n@@ -331,7 +331,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // Recurse to get the size of the dynamically sized field (must be\n             // the last field).\n             let last_field = def.struct_variant().fields.last().unwrap();\n-            let field_ty = monomorphize::field_ty(bcx.tcx(), substs, last_field);\n+            let field_ty = monomorphize::field_ty(bcx.ccx.tcx(), substs, last_field);\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // FIXME (#26403, #27023): We should be adding padding\n@@ -383,7 +383,7 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             (bcx.load(size_ptr), bcx.load(align_ptr))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(bcx.tcx());\n+            let unit_ty = t.sequence_element_type(bcx.ccx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n             let llunit_ty = sizing_type_of(bcx.ccx, unit_ty);\n@@ -397,16 +397,16 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n }\n \n // Iterates through the elements of a structural type, dropping them.\n-fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n+fn drop_structural_ty<'a, 'tcx>(cx: Builder<'a, 'tcx>,\n                                 ptr: MaybeSizedValue,\n                                 t: Ty<'tcx>)\n-                                -> BlockAndBuilder<'a, 'tcx> {\n-    fn iter_variant<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>,\n+                                -> Builder<'a, 'tcx> {\n+    fn iter_variant<'a, 'tcx>(cx: &Builder<'a, 'tcx>,\n                               t: Ty<'tcx>,\n                               av: adt::MaybeSizedValue,\n                               variant: &'tcx ty::VariantDef,\n                               substs: &Substs<'tcx>) {\n-        let tcx = cx.tcx();\n+        let tcx = cx.ccx.tcx();\n         for (i, field) in variant.fields.iter().enumerate() {\n             let arg = monomorphize::field_ty(tcx, substs, field);\n             let field_ptr = adt::trans_field_ptr(&cx, t, av, Disr::from(variant.disr_val), i);\n@@ -417,20 +417,20 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n     let mut cx = cx;\n     match t.sty {\n         ty::TyClosure(def_id, substs) => {\n-            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.tcx()).enumerate() {\n+            for (i, upvar_ty) in substs.upvar_tys(def_id, cx.ccx.tcx()).enumerate() {\n                 let llupvar = adt::trans_field_ptr(&cx, t, ptr, Disr(0), i);\n                 drop_ty(&cx, MaybeSizedValue::sized(llupvar), upvar_ty);\n             }\n         }\n         ty::TyArray(_, n) => {\n             let base = get_dataptr(&cx, ptr.value);\n             let len = C_uint(cx.ccx, n);\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n+            let unit_ty = t.sequence_element_type(cx.ccx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len,\n                 |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(cx.tcx());\n+            let unit_ty = t.sequence_element_type(cx.ccx.tcx());\n             cx = tvec::slice_for_each(&cx, ptr.value, unit_ty, ptr.meta,\n                 |bb, vv| drop_ty(bb, MaybeSizedValue::sized(vv), unit_ty));\n         }\n@@ -442,7 +442,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n         }\n         ty::TyAdt(adt, substs) => match adt.adt_kind() {\n             AdtKind::Struct => {\n-                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.tcx(), t, None);\n+                let VariantInfo { fields, discr } = VariantInfo::from_ty(cx.ccx.tcx(), t, None);\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n                     let llfld_a = adt::trans_field_ptr(&cx, t, ptr, Disr::from(discr), i);\n                     let ptr = if cx.ccx.shared().type_is_sized(field_ty) {\n@@ -470,7 +470,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                         }\n                     }\n                     (adt::BranchKind::Switch, Some(lldiscrim_a)) => {\n-                        let tcx = cx.tcx();\n+                        let tcx = cx.ccx.tcx();\n                         drop_ty(&cx, MaybeSizedValue::sized(lldiscrim_a), tcx.types.isize);\n \n                         // Create a fall-through basic block for the \"else\" case of\n@@ -486,15 +486,15 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                         // from the outer function, and any other use case will only\n                         // call this for an already-valid enum in which case the `ret\n                         // void` will never be hit.\n-                        let ret_void_cx = cx.fcx().build_new_block(\"enum-iter-ret-void\");\n+                        let ret_void_cx = cx.build_new_block(\"enum-iter-ret-void\");\n                         ret_void_cx.ret_void();\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = cx.fcx().build_new_block(\"enum-iter-next\");\n+                        let next_cx = cx.build_new_block(\"enum-iter-next\");\n \n                         for variant in &adt.variants {\n                             let variant_cx_name = format!(\"enum-iter-variant-{}\",\n                                 &variant.disr_val.to_string());\n-                            let variant_cx = cx.fcx().build_new_block(&variant_cx_name);\n+                            let variant_cx = cx.build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n                             iter_variant(&variant_cx, t, ptr, variant, substs);\n@@ -508,7 +508,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n         },\n \n         _ => {\n-            cx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n+            cx.ccx.sess().unimpl(&format!(\"type in drop_structural_ty: {}\", t))\n         }\n     }\n     return cx;"}, {"sha": "af3050fef0d68c8f31cd654c1e4718550d4d20ca", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 38, "deletions": 33, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -28,6 +28,7 @@ use Disr;\n use rustc::hir;\n use syntax::ast;\n use syntax::symbol::Symbol;\n+use builder::Builder;\n \n use rustc::session::Session;\n use syntax_pos::Span;\n@@ -87,14 +88,15 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// Remember to add all intrinsics here, in librustc_typeck/check/mod.rs,\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n-pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                                      fcx: &FunctionContext,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType,\n                                       llargs: &[ValueRef],\n                                       llresult: ValueRef,\n                                       span: Span) {\n     let ccx = bcx.ccx;\n-    let tcx = bcx.tcx();\n+    let tcx = ccx.tcx();\n \n     let (def_id, substs, fty) = match callee_ty.sty {\n         ty::TyFnDef(def_id, substs, ref fty) => (def_id, substs, fty),\n@@ -125,7 +127,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, llargs[0], llargs[1], llargs[2], llresult);\n+            try_intrinsic(bcx, fcx, llargs[0], llargs[1], llargs[2], llresult);\n             C_nil(ccx)\n         }\n         \"breakpoint\" => {\n@@ -533,7 +535,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             // qux` to be converted into `foo, bar, baz, qux`, integer\n             // arguments to be truncated as needed and pointers to be\n             // cast.\n-            fn modify_as_needed<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+            fn modify_as_needed<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                           t: &intrinsics::Type,\n                                           arg_type: Ty<'tcx>,\n                                           llarg: ValueRef)\n@@ -634,7 +636,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n     }\n }\n \n-fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             allow_overlap: bool,\n                             volatile: bool,\n                             tp_ty: Ty<'tcx>,\n@@ -670,7 +672,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n }\n \n fn memset_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     volatile: bool,\n     ty: Ty<'tcx>,\n     dst: ValueRef,\n@@ -686,19 +688,20 @@ fn memset_intrinsic<'a, 'tcx>(\n }\n \n fn try_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n+    fcx: &FunctionContext,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n     dest: ValueRef,\n ) {\n-    if bcx.sess().no_landing_pads() {\n+    if bcx.ccx.sess().no_landing_pads() {\n         bcx.call(func, &[data], None);\n         bcx.store(C_null(Type::i8p(&bcx.ccx)), dest, None);\n     } else if wants_msvc_seh(bcx.sess()) {\n-        trans_msvc_try(bcx, func, data, local_ptr, dest);\n+        trans_msvc_try(bcx, fcx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bcx, func, data, local_ptr, dest);\n+        trans_gnu_try(bcx, fcx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -709,24 +712,25 @@ fn try_intrinsic<'a, 'tcx>(\n // instructions are meant to work for all targets, as of the time of this\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n-fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                            fcx: &FunctionContext,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n-    let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n+    let llfn = get_rust_try_fn(fcx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         bcx.set_personality_fn(bcx.ccx.eh_personality());\n \n-        let normal = bcx.fcx().build_new_block(\"normal\");\n-        let catchswitch = bcx.fcx().build_new_block(\"catchswitch\");\n-        let catchpad = bcx.fcx().build_new_block(\"catchpad\");\n-        let caught = bcx.fcx().build_new_block(\"caught\");\n+        let normal = bcx.build_new_block(\"normal\");\n+        let catchswitch = bcx.build_new_block(\"catchswitch\");\n+        let catchpad = bcx.build_new_block(\"catchpad\");\n+        let caught = bcx.build_new_block(\"caught\");\n \n-        let func = llvm::get_param(bcx.fcx().llfn, 0);\n-        let data = llvm::get_param(bcx.fcx().llfn, 1);\n-        let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n+        let func = llvm::get_param(bcx.llfn(), 0);\n+        let data = llvm::get_param(bcx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n \n         // We're generating an IR snippet that looks like:\n         //\n@@ -768,7 +772,7 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         //\n         // More information can be found in libstd's seh.rs implementation.\n         let i64p = Type::i64(ccx).ptr_to();\n-        let slot = bcx.fcx().alloca(i64p, \"slot\");\n+        let slot = bcx.alloca(i64p, \"slot\");\n         bcx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(),\n             None);\n \n@@ -812,12 +816,13 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n // function calling it, and that function may already have other personality\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n-fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n+                           fcx: &FunctionContext,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n-    let llfn = get_rust_try_fn(bcx.fcx(), &mut |bcx| {\n+    let llfn = get_rust_try_fn(fcx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         // Translates the shims described above:\n@@ -837,12 +842,12 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         // expected to be `*mut *mut u8` for this to actually work, but that's\n         // managed by the standard library.\n \n-        let then = bcx.fcx().build_new_block(\"then\");\n-        let catch = bcx.fcx().build_new_block(\"catch\");\n+        let then = bcx.build_new_block(\"then\");\n+        let catch = bcx.build_new_block(\"catch\");\n \n-        let func = llvm::get_param(bcx.fcx().llfn, 0);\n-        let data = llvm::get_param(bcx.fcx().llfn, 1);\n-        let local_ptr = llvm::get_param(bcx.fcx().llfn, 2);\n+        let func = llvm::get_param(bcx.llfn(), 0);\n+        let data = llvm::get_param(bcx.llfn(), 1);\n+        let local_ptr = llvm::get_param(bcx.llfn(), 2);\n         bcx.invoke(func, &[data], then.llbb(), catch.llbb(), None);\n         then.ret(C_i32(ccx, 0));\n \n@@ -854,7 +859,7 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n         // rust_try ignores the selector.\n         let lpad_ty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)],\n                                     false);\n-        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.fcx().llfn);\n+        let vals = catch.landing_pad(lpad_ty, bcx.ccx.eh_personality(), 1, catch.llfn());\n         catch.add_clause(vals, C_null(Type::i8p(ccx)));\n         let ptr = catch.extract_value(vals, 0);\n         catch.store(ptr, catch.bitcast(local_ptr, Type::i8p(ccx).ptr_to()), None);\n@@ -873,7 +878,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n-                    trans: &mut for<'b> FnMut(BlockAndBuilder<'b, 'tcx>))\n+                    trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n     let ccx = fcx.ccx;\n     let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n@@ -894,7 +899,7 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n //\n // This function is only generated once and is then cached.\n fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n-                             trans: &mut for<'b> FnMut(BlockAndBuilder<'b, 'tcx>))\n+                             trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n     let ccx = fcx.ccx;\n     if let Some(llfn) = ccx.rust_try_fn().get() {\n@@ -920,7 +925,7 @@ fn span_invalid_monomorphization_error(a: &Session, b: Span, c: &str) {\n }\n \n fn generic_simd_intrinsic<'a, 'tcx>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     name: &str,\n     callee_ty: Ty<'tcx>,\n     llargs: &[ValueRef],\n@@ -935,7 +940,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n         };\n         ($msg: tt, $($fmt: tt)*) => {\n             span_invalid_monomorphization_error(\n-                bcx.sess(), span,\n+                bcx.ccx.sess(), span,\n                 &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \",\n                                  $msg),\n                          name, $($fmt)*));\n@@ -957,7 +962,7 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n \n \n-    let tcx = bcx.tcx();\n+    let tcx = bcx.ccx.tcx();\n     let sig = tcx.erase_late_bound_regions_and_normalize(callee_ty.fn_sig());\n     let arg_tys = sig.inputs();\n "}, {"sha": "1765d6e73b32cffee3427b64cca5b948e3168706", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -13,6 +13,7 @@ use llvm::{ValueRef, get_params};\n use rustc::traits;\n use callee::{Callee, CalleeData};\n use common::*;\n+use builder::Builder;\n use consts;\n use declare;\n use glue;\n@@ -27,7 +28,7 @@ use rustc::ty;\n const VTABLE_OFFSET: usize = 3;\n \n /// Extracts a method from a trait object's vtable, at the specified index.\n-pub fn get_virtual_method<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+pub fn get_virtual_method<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                                     llvtable: ValueRef,\n                                     vtable_index: usize)\n                                     -> ValueRef {"}, {"sha": "a818694267b90dc1cd0ac243db86eeef04bc5305", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 52, "deletions": 49, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -17,7 +17,8 @@ use abi::{Abi, FnType, ArgType};\n use adt::{self, MaybeSizedValue};\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, BlockAndBuilder, Funclet};\n+use builder::Builder;\n+use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n use Disr;\n@@ -57,7 +58,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let cleanup_pad = funclet.map(|lp| lp.cleanuppad());\n         let cleanup_bundle = funclet.map(|l| l.bundle());\n \n-        let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n+        let funclet_br = |this: &Self, bcx: Builder, bb: mir::BasicBlock| {\n             let lltarget = this.blocks[bb];\n             if let Some(cp) = cleanup_pad {\n                 match this.cleanup_kinds[bb] {\n@@ -74,7 +75,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n         };\n \n-        let llblock = |this: &mut Self, target: mir::BasicBlock| {\n+        let llblock = |this: &mut Self, bcx: &Builder, target: mir::BasicBlock| {\n             let lltarget = this.blocks[target];\n \n             if let Some(cp) = cleanup_pad {\n@@ -84,7 +85,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n                         let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n-                        let trampoline = this.fcx.build_new_block(name);\n+                        let trampoline = bcx.build_new_block(name);\n                         trampoline.cleanup_ret(cp, Some(lltarget));\n                         trampoline.llbb()\n                     }\n@@ -121,7 +122,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let ps = self.get_personality_slot(&bcx);\n                     let lp = bcx.load(ps);\n                     Lifetime::End.call(&bcx, ps);\n-                    if !bcx.sess().target.target.options.custom_unwind_resume {\n+                    if !bcx.ccx.sess().target.target.options.custom_unwind_resume {\n                         bcx.resume(lp);\n                     } else {\n                         let exc_ptr = bcx.extract_value(lp, 0);\n@@ -138,14 +139,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(&bcx, cond);\n \n-                let lltrue = llblock(self, true_bb);\n-                let llfalse = llblock(self, false_bb);\n+                let lltrue = llblock(self, &bcx, true_bb);\n+                let llfalse = llblock(self, &bcx, false_bb);\n                 bcx.cond_br(cond.immediate(), lltrue, llfalse);\n             }\n \n             mir::TerminatorKind::Switch { ref discr, ref adt_def, ref targets } => {\n                 let discr_lvalue = self.trans_lvalue(&bcx, discr);\n-                let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n+                let ty = discr_lvalue.ty.to_ty(bcx.ccx.tcx());\n                 let discr = adt::trans_get_discr(&bcx, ty, discr_lvalue.llval, None, true);\n \n                 let mut bb_hist = FxHashMap();\n@@ -158,7 +159,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     // code. This is especially helpful in cases like an if-let on a huge enum.\n                     // Note: This optimization is only valid for exhaustive matches.\n                     Some((&&bb, &c)) if c > targets.len() / 2 => {\n-                        (Some(bb), llblock(self, bb))\n+                        (Some(bb), llblock(self, &bcx, bb))\n                     }\n                     // We're generating an exhaustive switch, so the else branch\n                     // can't be hit.  Branching to an unreachable instruction\n@@ -169,7 +170,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n                     if default_bb != Some(target) {\n-                        let llbb = llblock(self, target);\n+                        let llbb = llblock(self, &bcx, target);\n                         let llval = adt::trans_case(&bcx, ty, Disr::from(adt_variant.disr_val));\n                         bcx.add_case(switch, llval, llbb)\n                     }\n@@ -180,10 +181,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n                 let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n                 let discr = base::to_immediate(&bcx, discr, switch_ty);\n-                let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n+                let switch = bcx.switch(discr, llblock(self, &bcx, *otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n                     let val = Const::from_constval(bcx.ccx, value.clone(), switch_ty);\n-                    let llbb = llblock(self, *target);\n+                    let llbb = llblock(self, &bcx, *target);\n                     bcx.add_case(switch, val.llval, llbb)\n                 }\n             }\n@@ -202,7 +203,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         LocalRef::Lvalue(tr_lvalue) => {\n                             OperandRef {\n                                 val: Ref(tr_lvalue.llval),\n-                                ty: tr_lvalue.ty.to_ty(bcx.tcx())\n+                                ty: tr_lvalue.ty.to_ty(bcx.ccx.tcx())\n                             }\n                         }\n                     };\n@@ -232,7 +233,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::TerminatorKind::Drop { ref location, target, unwind } => {\n-                let ty = location.ty(&self.mir, bcx.tcx()).to_ty(bcx.tcx());\n+                let ty = location.ty(&self.mir, bcx.ccx.tcx()).to_ty(bcx.ccx.tcx());\n                 let ty = self.monomorphize(&ty);\n \n                 // Double check for necessity to drop\n@@ -260,7 +261,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         drop_fn,\n                         args,\n                         self.blocks[target],\n-                        llblock(self, unwind),\n+                        llblock(self, &bcx, unwind),\n                         cleanup_bundle\n                     );\n                 } else {\n@@ -300,7 +301,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let cond = bcx.call(expect, &[cond, C_bool(bcx.ccx, expected)], None);\n \n                 // Create the failure block and the conditional branch to it.\n-                let lltarget = llblock(self, target);\n+                let lltarget = llblock(self, &bcx, target);\n                 let panic_block = self.fcx.build_new_block(\"panic\");\n                 if expected {\n                     bcx.cond_br(cond, lltarget, panic_block.llbb());\n@@ -313,7 +314,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 self.set_debug_loc(&bcx, terminator.source_info);\n \n                 // Get the location information.\n-                let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n+                let loc = bcx.ccx.sess().codemap().lookup_char_pos(span.lo);\n                 let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n@@ -363,15 +364,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 if const_cond == Some(!expected) {\n                     if let Some(err) = const_err {\n                         let err = ConstEvalErr{ span: span, kind: err };\n-                        let mut diag = bcx.tcx().sess.struct_span_warn(\n+                        let mut diag = bcx.ccx.tcx().sess.struct_span_warn(\n                             span, \"this expression will panic at run-time\");\n-                        note_const_eval_err(bcx.tcx(), &err, span, \"expression\", &mut diag);\n+                        note_const_eval_err(bcx.ccx.tcx(), &err, span, \"expression\", &mut diag);\n                         diag.emit();\n                     }\n                 }\n \n                 // Obtain the panic entry point.\n-                let def_id = common::langcall(bcx.tcx(), Some(span), \"\", lang_item);\n+                let def_id = common::langcall(bcx.ccx.tcx(), Some(span), \"\", lang_item);\n                 let callee = Callee::def(bcx.ccx, def_id,\n                     bcx.ccx.empty_substs_for_def_id(def_id));\n                 let llfn = callee.reify(bcx.ccx);\n@@ -381,7 +382,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     bcx.invoke(llfn,\n                                &args,\n                                self.unreachable_block(),\n-                               llblock(self, unwind),\n+                               llblock(self, &bcx, unwind),\n                                cleanup_bundle);\n                 } else {\n                     bcx.call(llfn, &args, cleanup_bundle);\n@@ -410,12 +411,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     _ => bug!(\"{} is not callable\", callee.ty)\n                 };\n \n-                let sig = bcx.tcx().erase_late_bound_regions_and_normalize(sig);\n+                let sig = bcx.ccx.tcx().erase_late_bound_regions_and_normalize(sig);\n \n                 // Handle intrinsics old trans wants Expr's for, ourselves.\n                 let intrinsic = match (&callee.ty.sty, &callee.data) {\n                     (&ty::TyFnDef(def_id, ..), &Intrinsic) => {\n-                        Some(bcx.tcx().item_name(def_id).as_str())\n+                        Some(bcx.ccx.tcx().item_name(def_id).as_str())\n                     }\n                     _ => None\n                 };\n@@ -443,7 +444,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 let extra_args = &args[sig.inputs().len()..];\n                 let extra_args = extra_args.iter().map(|op_arg| {\n-                    let op_ty = op_arg.ty(&self.mir, bcx.tcx());\n+                    let op_ty = op_arg.ty(&self.mir, bcx.ccx.tcx());\n                     self.monomorphize(&op_ty)\n                 }).collect::<Vec<_>>();\n                 let fn_ty = callee.direct_fn_type(bcx.ccx, &extra_args);\n@@ -545,7 +546,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bug!(\"Cannot use direct operand with an intrinsic call\")\n                         };\n \n-                        trans_intrinsic_call(&bcx, callee.ty, &fn_ty, &llargs, dest,\n+                        trans_intrinsic_call(&bcx, self.fcx, callee.ty, &fn_ty, &llargs, dest,\n                             terminator.source_info.span);\n \n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -579,20 +580,20 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     let invokeret = bcx.invoke(fn_ptr,\n                                                &llargs,\n                                                ret_bcx,\n-                                               llblock(self, cleanup),\n+                                               llblock(self, &bcx, cleanup),\n                                                cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n                     if let Some((_, target)) = *destination {\n                         let ret_bcx = self.build_block(target);\n-                        ret_bcx.at_start(|ret_bcx| {\n-                            self.set_debug_loc(&ret_bcx, terminator.source_info);\n-                            let op = OperandRef {\n-                                val: Immediate(invokeret),\n-                                ty: sig.output(),\n-                            };\n-                            self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n-                        });\n+                        ret_bcx.position_at_start(ret_bcx.llbb());\n+                        self.set_debug_loc(&ret_bcx, terminator.source_info);\n+                        let op = OperandRef {\n+                            val: Immediate(invokeret),\n+                            ty: sig.output(),\n+                        };\n+                        self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n+                        ret_bcx.position_at_end(ret_bcx.llbb());\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -613,7 +614,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_argument(&mut self,\n-                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                      bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n                       fn_ty: &FnType,\n@@ -634,7 +635,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let imm_op = |x| OperandRef {\n                     val: Immediate(x),\n                     // We won't be checking the type again.\n-                    ty: bcx.tcx().types.err\n+                    ty: bcx.ccx.tcx().types.err\n                 };\n                 self.trans_argument(bcx, imm_op(ptr), llargs, fn_ty, next_idx, callee);\n                 self.trans_argument(bcx, imm_op(meta), llargs, fn_ty, next_idx, callee);\n@@ -689,7 +690,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_arguments_untupled(&mut self,\n-                                bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n                                 fn_ty: &FnType,\n@@ -765,13 +766,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     }\n \n-    fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>) -> ValueRef {\n+    fn get_personality_slot(&mut self, bcx: &Builder<'a, 'tcx>) -> ValueRef {\n         let ccx = bcx.ccx;\n         if let Some(slot) = self.llpersonalityslot {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.fcx().alloca(llretty, \"personalityslot\");\n+            let slot = bcx.alloca(llretty, \"personalityslot\");\n             self.llpersonalityslot = Some(slot);\n             Lifetime::Start.call(bcx, slot);\n             slot\n@@ -815,11 +816,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         })\n     }\n \n-    pub fn build_block(&self, bb: mir::BasicBlock) -> BlockAndBuilder<'a, 'tcx> {\n-        BlockAndBuilder::new(self.blocks[bb], self.fcx)\n+    pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n+        let builder = Builder::with_ccx(self.fcx.ccx);\n+        builder.position_at_end(self.blocks[bb]);\n+        builder\n     }\n \n-    fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    fn make_return_dest(&mut self, bcx: &Builder<'a, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {\n         // If the return is ignored, we can just return a do-nothing ReturnDest\n@@ -836,14 +839,14 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     return if fn_ret_ty.is_indirect() {\n                         // Odd, but possible, case, we have an operand temporary,\n                         // but the calling convention has an indirect return.\n-                        let tmp = base::alloc_ty(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n                         llargs.push(tmp);\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else if is_intrinsic {\n                         // Currently, intrinsics always need a location to store\n                         // the result. so we create a temporary alloca for the\n                         // result\n-                        let tmp = base::alloc_ty(bcx, ret_ty, \"tmp_ret\");\n+                        let tmp = bcx.alloca_ty(ret_ty, \"tmp_ret\");\n                         ReturnDest::IndirectOperand(tmp, index)\n                     } else {\n                         ReturnDest::DirectOperand(index)\n@@ -864,17 +867,17 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         }\n     }\n \n-    fn trans_transmute(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    fn trans_transmute(&mut self, bcx: &Builder<'a, 'tcx>,\n                        src: &mir::Operand<'tcx>, dst: LvalueRef<'tcx>) {\n         let mut val = self.trans_operand(bcx, src);\n         if let ty::TyFnDef(def_id, substs, _) = val.ty.sty {\n-            let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.tcx()));\n+            let llouttype = type_of::type_of(bcx.ccx, dst.ty.to_ty(bcx.ccx.tcx()));\n             let out_type_size = llbitsize_of_real(bcx.ccx, llouttype);\n             if out_type_size != 0 {\n                 // FIXME #19925 Remove this hack after a release cycle.\n                 let f = Callee::def(bcx.ccx, def_id, substs);\n                 let ty = match f.ty.sty {\n-                    ty::TyFnDef(.., f) => bcx.tcx().mk_fn_ptr(f),\n+                    ty::TyFnDef(.., f) => bcx.ccx.tcx().mk_fn_ptr(f),\n                     _ => f.ty\n                 };\n                 val = OperandRef {\n@@ -895,7 +898,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     // Stores the return value of a function call into it's final location.\n     fn store_return(&mut self,\n-                    bcx: &BlockAndBuilder<'a, 'tcx>,\n+                    bcx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest,\n                     ret_ty: ArgType,\n                     op: OperandRef<'tcx>) {\n@@ -911,7 +914,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             DirectOperand(index) => {\n                 // If there is a cast, we have to store and reload.\n                 let op = if ret_ty.cast.is_some() {\n-                    let tmp = base::alloc_ty(bcx, op.ty, \"tmp_ret\");\n+                    let tmp = bcx.alloca_ty(op.ty, \"tmp_ret\");\n                     ret_ty.store(bcx, op.immediate(), tmp);\n                     self.trans_load(bcx, tmp, op.ty)\n                 } else {"}, {"sha": "e15c25df911392d00bc5b93fe1dec35db8c3a34e", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -24,10 +24,11 @@ use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n-use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n+use builder::Builder;\n+use common::{self, CrateContext, const_get_elt, val_ty};\n use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use common::{const_to_opt_u128};\n+use common::const_to_opt_u128;\n use consts;\n use monomorphize::{self, Instance};\n use type_of;\n@@ -900,7 +901,7 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n-                          bcx: &BlockAndBuilder<'a, 'tcx>,\n+                          bcx: &Builder<'a, 'tcx>,\n                           constant: &mir::Constant<'tcx>)\n                           -> Const<'tcx>\n     {"}, {"sha": "b09ce7340038316c1f6d9f8a58707af4d4cfed33", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 13, "deletions": 28, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -14,8 +14,8 @@ use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n use adt;\n-use base;\n-use common::{self, BlockAndBuilder, CrateContext, C_uint, C_undef};\n+use builder::Builder;\n+use common::{self, CrateContext, C_uint, C_undef};\n use consts;\n use machine;\n use type_of::type_of;\n@@ -44,16 +44,6 @@ impl<'tcx> LvalueRef<'tcx> {\n         LvalueRef { llval: llval, llextra: ptr::null_mut(), ty: lvalue_ty }\n     }\n \n-    pub fn alloca<'a>(bcx: &BlockAndBuilder<'a, 'tcx>,\n-                        ty: Ty<'tcx>,\n-                        name: &str)\n-                        -> LvalueRef<'tcx>\n-    {\n-        assert!(!ty.has_erasable_regions());\n-        let lltemp = base::alloc_ty(bcx, ty, name);\n-        LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty))\n-    }\n-\n     pub fn len<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> ValueRef {\n         let ty = self.ty.to_ty(ccx.tcx());\n         match ty.sty {\n@@ -69,13 +59,13 @@ impl<'tcx> LvalueRef<'tcx> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_lvalue(&mut self,\n-                        bcx: &BlockAndBuilder<'a, 'tcx>,\n+                        bcx: &Builder<'a, 'tcx>,\n                         lvalue: &mir::Lvalue<'tcx>)\n                         -> LvalueRef<'tcx> {\n         debug!(\"trans_lvalue(lvalue={:?})\", lvalue);\n \n         let ccx = bcx.ccx;\n-        let tcx = bcx.tcx();\n+        let tcx = ccx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n             match self.locals[index] {\n@@ -177,7 +167,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let llindex = C_uint(bcx.ccx, from);\n                         let llbase = project_index(llindex);\n \n-                        let base_ty = tr_base.ty.to_ty(bcx.tcx());\n+                        let base_ty = tr_base.ty.to_ty(bcx.ccx.tcx());\n                         match base_ty.sty {\n                             ty::TyArray(..) => {\n                                 // must cast the lvalue pointer type to the new\n@@ -214,7 +204,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     // Perform an action using the given Lvalue.\n     // If the Lvalue is an empty LocalRef::Operand, then a temporary stack slot\n     // is created first, then used as an operand to update the Lvalue.\n-    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &BlockAndBuilder<'a, 'tcx>,\n+    pub fn with_lvalue_ref<F, U>(&mut self, bcx: &Builder<'a, 'tcx>,\n                                  lvalue: &mir::Lvalue<'tcx>, f: F) -> U\n     where F: FnOnce(&mut Self, LvalueRef<'tcx>) -> U\n     {\n@@ -223,9 +213,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 LocalRef::Lvalue(lvalue) => f(self, lvalue),\n                 LocalRef::Operand(None) => {\n                     let lvalue_ty = self.monomorphized_lvalue_ty(lvalue);\n-                    let lvalue = LvalueRef::alloca(bcx,\n-                                                   lvalue_ty,\n-                                                   \"lvalue_temp\");\n+                    assert!(!lvalue_ty.has_erasable_regions());\n+                    let lltemp = bcx.alloca_ty(lvalue_ty, \"lvalue_temp\");\n+                    let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(lvalue_ty));\n                     let ret = f(self, lvalue);\n                     let op = self.trans_load(bcx, lvalue.llval, lvalue_ty);\n                     self.locals[index] = LocalRef::Operand(Some(op));\n@@ -254,18 +244,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     /// than we are.\n     ///\n     /// nmatsakis: is this still necessary? Not sure.\n-    fn prepare_index(&mut self,\n-                     bcx: &BlockAndBuilder<'a, 'tcx>,\n-                     llindex: ValueRef)\n-                     -> ValueRef\n-    {\n-        let ccx = bcx.ccx;\n+    fn prepare_index(&mut self, bcx: &Builder<'a, 'tcx>, llindex: ValueRef) -> ValueRef {\n         let index_size = machine::llbitsize_of_real(bcx.ccx, common::val_ty(llindex));\n-        let int_size = machine::llbitsize_of_real(bcx.ccx, ccx.int_type());\n+        let int_size = machine::llbitsize_of_real(bcx.ccx, bcx.ccx.int_type());\n         if index_size < int_size {\n-            bcx.zext(llindex, ccx.int_type())\n+            bcx.zext(llindex, bcx.ccx.int_type())\n         } else if index_size > int_size {\n-            bcx.trunc(llindex, ccx.int_type())\n+            bcx.trunc(llindex, bcx.ccx.int_type())\n         } else {\n             llindex\n         }"}, {"sha": "94427ee9aefa60a1b16a006a0b1b58415c8beae5", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -19,7 +19,8 @@ use rustc::infer::TransNormalize;\n use rustc::ty::TypeFoldable;\n use session::config::FullDebugInfo;\n use base;\n-use common::{self, BlockAndBuilder, CrateContext, FunctionContext, C_null, Funclet};\n+use builder::Builder;\n+use common::{self, CrateContext, FunctionContext, C_null, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::{self, Instance};\n use abi::FnType;\n@@ -106,7 +107,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n     }\n \n-    pub fn set_debug_loc(&mut self, bcx: &BlockAndBuilder, source_info: mir::SourceInfo) {\n+    pub fn set_debug_loc(&mut self, bcx: &Builder, source_info: mir::SourceInfo) {\n         let (scope, span) = self.debug_loc(source_info);\n         debuginfo::set_source_location(&self.debug_context, bcx, scope, span);\n     }\n@@ -258,15 +259,17 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 // User variable\n                 let source_info = decl.source_info.unwrap();\n                 let debug_scope = mircx.scopes[source_info.scope];\n-                let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n+                let dbg = debug_scope.is_valid() && bcx.ccx.sess().opts.debuginfo == FullDebugInfo;\n \n                 if !lvalue_locals.contains(local.index()) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n                     return LocalRef::new_operand(bcx.ccx, ty);\n                 }\n \n                 debug!(\"alloc: {:?} ({}) -> lvalue\", local, name);\n-                let lvalue = LvalueRef::alloca(&bcx, ty, &name.as_str());\n+                assert!(!ty.has_erasable_regions());\n+                let lltemp = bcx.alloca_ty(ty, &name.as_str());\n+                let lvalue = LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty));\n                 if dbg {\n                     let (scope, span) = mircx.debug_loc(source_info);\n                     declare_local(&bcx, &mircx.debug_context, name, ty, scope,\n@@ -282,7 +285,9 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                     LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n-                    LocalRef::Lvalue(LvalueRef::alloca(&bcx, ty, &format!(\"{:?}\", local)))\n+                    assert!(!ty.has_erasable_regions());\n+                    let lltemp = bcx.alloca_ty(ty, &format!(\"{:?}\", local));\n+                    LocalRef::Lvalue(LvalueRef::new_sized(lltemp, LvalueTy::from_ty(ty)))\n                 } else {\n                     // If this is an immediate local, we do not create an\n                     // alloca in advance. Instead we wait until we see the\n@@ -347,20 +352,20 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n /// Produce, for each argument, a `ValueRef` pointing at the\n /// argument's value. As arguments are lvalues, these are always\n /// indirect.\n-fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n+fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             mircx: &MirContext<'a, 'tcx>,\n                             scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                             lvalue_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = mircx.mir;\n-    let fcx = bcx.fcx();\n-    let tcx = bcx.tcx();\n+    let fcx = mircx.fcx;\n+    let tcx = bcx.ccx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n-    let arg_scope = if arg_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+    let arg_scope = if arg_scope.is_valid() && bcx.ccx.sess().opts.debuginfo == FullDebugInfo {\n         Some(arg_scope.scope_metadata)\n     } else {\n         None\n@@ -381,7 +386,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n                 _ => bug!(\"spread argument isn't a tuple?!\")\n             };\n \n-            let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n             for (i, &tupled_arg_ty) in tupled_arg_tys.iter().enumerate() {\n                 let dst = bcx.struct_gep(lltemp, i);\n                 let arg = &mircx.fn_ty.args[idx];\n@@ -420,7 +425,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n         let arg = &mircx.fn_ty.args[idx];\n         idx += 1;\n-        let llval = if arg.is_indirect() && bcx.sess().opts.debuginfo != FullDebugInfo {\n+        let llval = if arg.is_indirect() && bcx.ccx.sess().opts.debuginfo != FullDebugInfo {\n             // Don't copy an indirect argument to an alloca, the caller\n             // already put it in a temporary alloca and gave it up, unless\n             // we emit extra-debug-info, which requires local allocas :(.\n@@ -462,7 +467,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n             };\n             return LocalRef::Operand(Some(operand.unpack_if_pair(bcx)));\n         } else {\n-            let lltemp = base::alloc_ty(&bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+            let lltemp = bcx.alloca_ty(arg_ty, &format!(\"arg{}\", arg_index));\n             if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 // we pass fat pointers as two words, but we want to\n                 // represent them internally as a pointer to two words,"}, {"sha": "c6eedc0d2efda9da3a41774711a99b9498328964", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -14,7 +14,8 @@ use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common::{self, BlockAndBuilder};\n+use common;\n+use builder::Builder;\n use value::Value;\n use type_of;\n use type_::Type;\n@@ -85,8 +86,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a Pair, we return an\n     /// Immediate aggregate with the two values.\n-    pub fn pack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n-                        -> OperandRef<'tcx> {\n+    pub fn pack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Pair(a, b) = self.val {\n             // Reconstruct the immediate aggregate.\n             let llty = type_of::type_of(bcx.ccx, self.ty);\n@@ -107,8 +107,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n     /// If this operand is a pair in an Immediate,\n     /// we return a Pair with the two halves.\n-    pub fn unpack_if_pair(mut self, bcx: &BlockAndBuilder<'a, 'tcx>)\n-                          -> OperandRef<'tcx> {\n+    pub fn unpack_if_pair(mut self, bcx: &Builder<'a, 'tcx>) -> OperandRef<'tcx> {\n         if let OperandValue::Immediate(llval) = self.val {\n             // Deconstruct the immediate aggregate.\n             if common::type_is_imm_pair(bcx.ccx, self.ty) {\n@@ -136,7 +135,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_load(&mut self,\n-                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                      bcx: &Builder<'a, 'tcx>,\n                       llval: ValueRef,\n                       ty: Ty<'tcx>)\n                       -> OperandRef<'tcx>\n@@ -165,7 +164,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_consume(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          lvalue: &mir::Lvalue<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -212,12 +211,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // for most lvalues, to consume them we just load them\n         // out from their home\n         let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n-        let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n+        let ty = tr_lvalue.ty.to_ty(bcx.ccx.tcx());\n         self.trans_load(bcx, tr_lvalue.llval, ty)\n     }\n \n     pub fn trans_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n                          -> OperandRef<'tcx>\n     {\n@@ -242,7 +241,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn store_operand(&mut self,\n-                         bcx: &BlockAndBuilder<'a, 'tcx>,\n+                         bcx: &Builder<'a, 'tcx>,\n                          lldest: ValueRef,\n                          operand: OperandRef<'tcx>,\n                          align: Option<u32>) {"}, {"sha": "00dd49d84e31c2a239af1bb739fddc5845e9a595", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -17,8 +17,9 @@ use middle::lang_items::ExchangeMallocFnLangItem;\n \n use asm;\n use base;\n+use builder::Builder;\n use callee::Callee;\n-use common::{self, val_ty, C_bool, C_null, C_uint, BlockAndBuilder};\n+use common::{self, val_ty, C_bool, C_null, C_uint};\n use common::{C_integral};\n use adt;\n use machine;\n@@ -35,10 +36,10 @@ use super::lvalue::{LvalueRef};\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_rvalue(&mut self,\n-                        bcx: BlockAndBuilder<'a, 'tcx>,\n+                        bcx: Builder<'a, 'tcx>,\n                         dest: LvalueRef<'tcx>,\n                         rvalue: &mir::Rvalue<'tcx>)\n-                        -> BlockAndBuilder<'a, 'tcx>\n+                        -> Builder<'a, 'tcx>\n     {\n         debug!(\"trans_rvalue(dest.llval={:?}, rvalue={:?})\",\n                Value(dest.llval), rvalue);\n@@ -79,7 +80,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         // index into the struct, and this case isn't\n                         // important enough for it.\n                         debug!(\"trans_rvalue: creating ugly alloca\");\n-                        let lltemp = base::alloc_ty(&bcx, operand.ty, \"__unsize_temp\");\n+                        let lltemp = bcx.alloca_ty(operand.ty, \"__unsize_temp\");\n                         base::store_ty(&bcx, llval, lltemp, operand.ty);\n                         lltemp\n                     }\n@@ -91,7 +92,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n                 let tr_elem = self.trans_operand(&bcx, elem);\n-                let size = count.value.as_u64(bcx.tcx().sess.target.uint_type);\n+                let size = count.value.as_u64(bcx.ccx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot| {\n@@ -103,7 +104,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 match *kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n                         let disr = Disr::from(adt_def.variants[variant_index].disr_val);\n-                        let dest_ty = dest.ty.to_ty(bcx.tcx());\n+                        let dest_ty = dest.ty.to_ty(bcx.ccx.tcx());\n                         adt::trans_set_discr(&bcx, dest_ty, dest.llval, Disr::from(disr));\n                         for (i, operand) in operands.iter().enumerate() {\n                             let op = self.trans_operand(&bcx, operand);\n@@ -119,7 +120,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     },\n                     _ => {\n                         // If this is a tuple or closure, we need to translate GEP indices.\n-                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.tcx()));\n+                        let layout = bcx.ccx.layout_of(dest.ty.to_ty(bcx.ccx.tcx()));\n                         let translation = if let Layout::Univariant { ref variant, .. } = *layout {\n                             Some(&variant.memory_index)\n                         } else {\n@@ -149,7 +150,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 let outputs = outputs.iter().map(|output| {\n                     let lvalue = self.trans_lvalue(&bcx, output);\n-                    (lvalue.llval, lvalue.ty.to_ty(bcx.tcx()))\n+                    (lvalue.llval, lvalue.ty.to_ty(bcx.ccx.tcx()))\n                 }).collect();\n \n                 let input_vals = inputs.iter().map(|input| {\n@@ -170,9 +171,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_rvalue_operand(&mut self,\n-                                bcx: BlockAndBuilder<'a, 'tcx>,\n+                                bcx: Builder<'a, 'tcx>,\n                                 rvalue: &mir::Rvalue<'tcx>)\n-                                -> (BlockAndBuilder<'a, 'tcx>, OperandRef<'tcx>)\n+                                -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n         assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n@@ -344,9 +345,9 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             mir::Rvalue::Ref(_, bk, ref lvalue) => {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n \n-                let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                let ref_ty = bcx.tcx().mk_ref(\n-                    bcx.tcx().mk_region(ty::ReErased),\n+                let ty = tr_lvalue.ty.to_ty(bcx.ccx.tcx());\n+                let ref_ty = bcx.ccx.tcx().mk_ref(\n+                    bcx.ccx.tcx().mk_region(ty::ReErased),\n                     ty::TypeAndMut { ty: ty, mutbl: bk.to_mutbl_lossy() }\n                 );\n \n@@ -371,7 +372,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let tr_lvalue = self.trans_lvalue(&bcx, lvalue);\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(tr_lvalue.len(bcx.ccx)),\n-                    ty: bcx.tcx().types.usize,\n+                    ty: bcx.ccx.tcx().types.usize,\n                 };\n                 (bcx, operand)\n             }\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 };\n                 let operand = OperandRef {\n                     val: OperandValue::Immediate(llresult),\n-                    ty: op.ty(bcx.tcx(), lhs.ty, rhs.ty),\n+                    ty: op.ty(bcx.ccx.tcx(), lhs.ty, rhs.ty),\n                 };\n                 (bcx, operand)\n             }\n@@ -408,8 +409,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let result = self.trans_scalar_checked_binop(&bcx, op,\n                                                              lhs.immediate(), rhs.immediate(),\n                                                              lhs.ty);\n-                let val_ty = op.ty(bcx.tcx(), lhs.ty, rhs.ty);\n-                let operand_ty = bcx.tcx().intern_tup(&[val_ty, bcx.tcx().types.bool]);\n+                let val_ty = op.ty(bcx.ccx.tcx(), lhs.ty, rhs.ty);\n+                let operand_ty = bcx.ccx.tcx().intern_tup(&[val_ty, bcx.ccx.tcx().types.bool]);\n                 let operand = OperandRef {\n                     val: result,\n                     ty: operand_ty\n@@ -443,16 +444,16 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let align = type_of::align_of(bcx.ccx, content_ty);\n                 let llalign = C_uint(bcx.ccx, align);\n                 let llty_ptr = llty.ptr_to();\n-                let box_ty = bcx.tcx().mk_box(content_ty);\n+                let box_ty = bcx.ccx.tcx().mk_box(content_ty);\n \n                 // Allocate space:\n-                let def_id = match bcx.tcx().lang_items.require(ExchangeMallocFnLangItem) {\n+                let def_id = match bcx.ccx.tcx().lang_items.require(ExchangeMallocFnLangItem) {\n                     Ok(id) => id,\n                     Err(s) => {\n-                        bcx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n+                        bcx.ccx.sess().fatal(&format!(\"allocation of `{}` {}\", box_ty, s));\n                     }\n                 };\n-                let r = Callee::def(bcx.ccx, def_id, bcx.tcx().intern_substs(&[]))\n+                let r = Callee::def(bcx.ccx, def_id, bcx.ccx.tcx().intern_substs(&[]))\n                     .reify(bcx.ccx);\n                 let val = bcx.pointercast(bcx.call(r, &[llsize, llalign], None), llty_ptr);\n \n@@ -477,7 +478,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_binop(&mut self,\n-                              bcx: &BlockAndBuilder<'a, 'tcx>,\n+                              bcx: &Builder<'a, 'tcx>,\n                               op: mir::BinOp,\n                               lhs: ValueRef,\n                               rhs: ValueRef,\n@@ -552,7 +553,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_fat_ptr_binop(&mut self,\n-                               bcx: &BlockAndBuilder<'a, 'tcx>,\n+                               bcx: &Builder<'a, 'tcx>,\n                                op: mir::BinOp,\n                                lhs_addr: ValueRef,\n                                lhs_extra: ValueRef,\n@@ -599,7 +600,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn trans_scalar_checked_binop(&mut self,\n-                                      bcx: &BlockAndBuilder<'a, 'tcx>,\n+                                      bcx: &Builder<'a, 'tcx>,\n                                       op: mir::BinOp,\n                                       lhs: ValueRef,\n                                       rhs: ValueRef,\n@@ -617,7 +618,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // will only succeed if both operands are constant.\n         // This is necessary to determine when an overflow Assert\n         // will always panic at runtime, and produce a warning.\n-        if let Some((val, of)) = const_scalar_checked_binop(bcx.tcx(), op, lhs, rhs, input_ty) {\n+        if let Some((val, of)) = const_scalar_checked_binop(bcx.ccx.tcx(), op, lhs, rhs, input_ty) {\n             return OperandValue::Pair(val, C_bool(bcx.ccx, of));\n         }\n \n@@ -681,12 +682,12 @@ enum OverflowOp {\n     Add, Sub, Mul\n }\n \n-fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> ValueRef {\n+fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n     use syntax::ast::IntTy::*;\n     use syntax::ast::UintTy::*;\n     use rustc::ty::{TyInt, TyUint};\n \n-    let tcx = bcx.tcx();\n+    let tcx = bcx.ccx.tcx();\n \n     let new_sty = match ty.sty {\n         TyInt(Is) => match &tcx.sess.target.target.target_pointer_width[..] {"}, {"sha": "48fc9720e4b8317eb374fc1811499c0b048d8c62", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -11,7 +11,8 @@\n use rustc::mir;\n \n use base;\n-use common::{self, BlockAndBuilder};\n+use common;\n+use builder::Builder;\n \n use super::MirContext;\n use super::LocalRef;\n@@ -20,9 +21,9 @@ use super::super::disr::Disr;\n \n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_statement(&mut self,\n-                           bcx: BlockAndBuilder<'a, 'tcx>,\n+                           bcx: Builder<'a, 'tcx>,\n                            statement: &mir::Statement<'tcx>)\n-                           -> BlockAndBuilder<'a, 'tcx> {\n+                           -> Builder<'a, 'tcx> {\n         debug!(\"trans_statement(statement={:?})\", statement);\n \n         self.set_debug_loc(&bcx, statement.source_info);\n@@ -77,10 +78,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     fn trans_storage_liveness(&self,\n-                              bcx: BlockAndBuilder<'a, 'tcx>,\n+                              bcx: Builder<'a, 'tcx>,\n                               lvalue: &mir::Lvalue<'tcx>,\n                               intrinsic: base::Lifetime)\n-                              -> BlockAndBuilder<'a, 'tcx> {\n+                              -> Builder<'a, 'tcx> {\n         if let mir::Lvalue::Local(index) = *lvalue {\n             if let LocalRef::Lvalue(tr_lval) = self.locals[index] {\n                 intrinsic.call(&bcx, tr_lval.llval);"}, {"sha": "f6fc4637e1c06d3ca4010e24bbfbb763c3b19ab7", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -9,28 +9,29 @@\n // except according to those terms.\n \n use llvm;\n+use builder::Builder;\n use llvm::ValueRef;\n use common::*;\n use rustc::ty::Ty;\n \n pub fn slice_for_each<'a, 'tcx, F>(\n-    bcx: &BlockAndBuilder<'a, 'tcx>,\n+    bcx: &Builder<'a, 'tcx>,\n     data_ptr: ValueRef,\n     unit_ty: Ty<'tcx>,\n     len: ValueRef,\n     f: F\n-) -> BlockAndBuilder<'a, 'tcx> where F: FnOnce(&BlockAndBuilder<'a, 'tcx>, ValueRef) {\n+) -> Builder<'a, 'tcx> where F: FnOnce(&Builder<'a, 'tcx>, ValueRef) {\n     // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n     let zst = type_is_zero_size(bcx.ccx, unit_ty);\n-    let add = |bcx: &BlockAndBuilder, a, b| if zst {\n+    let add = |bcx: &Builder, a, b| if zst {\n         bcx.add(a, b)\n     } else {\n         bcx.inbounds_gep(a, &[b])\n     };\n \n-    let body_bcx = bcx.fcx().build_new_block(\"slice_loop_body\");\n-    let next_bcx = bcx.fcx().build_new_block(\"slice_loop_next\");\n-    let header_bcx = bcx.fcx().build_new_block(\"slice_loop_header\");\n+    let body_bcx = bcx.build_new_block(\"slice_loop_body\");\n+    let next_bcx = bcx.build_new_block(\"slice_loop_next\");\n+    let header_bcx = bcx.build_new_block(\"slice_loop_header\");\n \n     let start = if zst {\n         C_uint(bcx.ccx, 0usize)"}, {"sha": "6135f49eb711be0c9a2e8c22bd6e84cb6b9fc444", "filename": "src/test/codegen/stores.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Ftest%2Fcodegen%2Fstores.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be170b01addf84534b51d68e2d5ac76a1a42ac6/src%2Ftest%2Fcodegen%2Fstores.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fstores.rs?ref=1be170b01addf84534b51d68e2d5ac76a1a42ac6", "patch": "@@ -24,8 +24,8 @@ pub struct Bytes {\n // dependent alignment\n #[no_mangle]\n pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n-// CHECK: %arg1 = alloca [4 x i8]\n // CHECK: [[TMP:%.+]] = alloca i32\n+// CHECK: %arg1 = alloca [4 x i8]\n // CHECK: store i32 %1, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast [4 x i8]* %arg1 to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*\n@@ -38,8 +38,8 @@ pub fn small_array_alignment(x: &mut [i8; 4], y: [i8; 4]) {\n // dependent alignment\n #[no_mangle]\n pub fn small_struct_alignment(x: &mut Bytes, y: Bytes) {\n-// CHECK: %arg1 = alloca %Bytes\n // CHECK: [[TMP:%.+]] = alloca i32\n+// CHECK: %arg1 = alloca %Bytes\n // CHECK: store i32 %1, i32* [[TMP]]\n // CHECK: [[Y8:%[0-9]+]] = bitcast %Bytes* %arg1 to i8*\n // CHECK: [[TMP8:%[0-9]+]] = bitcast i32* [[TMP]] to i8*"}]}