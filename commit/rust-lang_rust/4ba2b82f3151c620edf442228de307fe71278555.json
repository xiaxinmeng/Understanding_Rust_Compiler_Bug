{"sha": "4ba2b82f3151c620edf442228de307fe71278555", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiYTJiODJmMzE1MWM2MjBlZGY0NDIyMjhkZTMwN2ZlNzEyNzg1NTU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-08T11:06:14Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-08-08T15:09:25Z"}, "message": "Split the alloc id address space into functions and normal allocs\n\ninstead of interleaving them as before.\nThe next step is to also separate out static memory into its own\naddress space.", "tree": {"sha": "6b7b3925cf11ebaf597223d9be88cb5b7d108b97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b7b3925cf11ebaf597223d9be88cb5b7d108b97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ba2b82f3151c620edf442228de307fe71278555", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlmJ1CUACgkQpp+NIls6\n19nhhA/+IbWo+7VTKF7+/RE3VSlxitWqbaIFLnuL48/Ym/bFOQC58c8jQ/RE2TAA\nWldQluriFKlyTS8NW6HsMPEFb+/JzA11ifde+v8+fXjuf0Wmr4sHXlz5aM3pL4k/\neIyOUSPhXkmmg1RU24fDAlvYQaQhNo1mURfDQnzqXc+1vP1LU+zu6VDqovetIHwS\nPg4w2510AZuAlvGnwW0SrLRn+9ZdrGeGIRgY41fG5k7ePeFpbFenSFnvGjIoYUGb\nt3WgWiLwDyG7OIWFLOtz10M+B84Kf75Mp+rJLlqyHvD/vTPzbfyqktfaosHZmGRh\nCtqvDjKnbO0Ac3RNPAPOdHBp1WV9EVRaB3khuzASqoUJJjvJw3sVJsSuZEjwIv5b\nQ6Zw5PSIUO8J72lBe94iW+DN7zvxZdMYNEqIcSXczYVuKhbw4qtZu2ReyQKV08vb\n22svEuOOx4g9WOnJf0fo0Oy36732ogA8ojYC5J2LCAx5XMQKf+t0AmFZXXReFqdj\n6psPHX562Ep5v0xkbo0XKbxMxDdfq28KNL/+1NJZaai1XGpouIEVgxKs5vPferR5\nEyoyN+M/Hk5GzcaM9e2zcTXUakh5r0mslWeCbZau+Vbm/kva309KDQCsGzMNgBMJ\nmgftJdkkYydx7bfYhMAFI80fisfUb4gfxTs6WMAjBUHoA+fnEQA=\n=8Og8\n-----END PGP SIGNATURE-----", "payload": "tree 6b7b3925cf11ebaf597223d9be88cb5b7d108b97\nparent 14e8f500af85da93e342dced154a0581ee9237ed\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502190374 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1502204965 +0200\n\nSplit the alloc id address space into functions and normal allocs\n\ninstead of interleaving them as before.\nThe next step is to also separate out static memory into its own\naddress space.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ba2b82f3151c620edf442228de307fe71278555", "html_url": "https://github.com/rust-lang/rust/commit/4ba2b82f3151c620edf442228de307fe71278555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ba2b82f3151c620edf442228de307fe71278555/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14e8f500af85da93e342dced154a0581ee9237ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/14e8f500af85da93e342dced154a0581ee9237ed", "html_url": "https://github.com/rust-lang/rust/commit/14e8f500af85da93e342dced154a0581ee9237ed"}], "stats": {"total": 148, "additions": 99, "deletions": 49}, "files": [{"sha": "96911c10cca80c687bfd0eed3ed25db3ff30ffbb", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ba2b82f3151c620edf442228de307fe71278555/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba2b82f3151c620edf442228de307fe71278555/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=4ba2b82f3151c620edf442228de307fe71278555", "patch": "@@ -139,7 +139,7 @@ impl<'tcx> Error for EvalError<'tcx> {\n             DoubleFree =>\n                 \"tried to deallocate dangling pointer\",\n             InvalidFunctionPointer =>\n-                \"tried to use an integer pointer or a dangling pointer as a function pointer\",\n+                \"tried to use a function pointer after offsetting it\",\n             InvalidBool =>\n                 \"invalid boolean value read\",\n             InvalidDiscriminant =>"}, {"sha": "c476046d3854ad2dbc090bd14ac53d4680b91f3f", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 97, "deletions": 47, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/4ba2b82f3151c620edf442228de307fe71278555/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba2b82f3151c620edf442228de307fe71278555/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4ba2b82f3151c620edf442228de307fe71278555", "patch": "@@ -82,12 +82,55 @@ impl LockInfo {\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n-pub struct AllocId(pub u64);\n+#[derive(Copy, Clone, Eq, Hash, Ord, PartialEq, PartialOrd)]\n+pub struct AllocId(u64);\n+\n+#[derive(Debug)]\n+enum AllocIdKind {\n+    /// We can't ever have more than `usize::max_value` functions at the same time\n+    /// since we never \"deallocate\" functions\n+    Function(usize),\n+    /// Locals and heap allocations (also statics for now, but those will get their\n+    /// own variant soonish).\n+    Runtime(u64),\n+}\n+\n+impl AllocIdKind {\n+    fn into_alloc_id(self) -> AllocId {\n+        match self {\n+            AllocIdKind::Function(n) => AllocId(n as u64),\n+            AllocIdKind::Runtime(n) => AllocId((1 << 63) | n),\n+        }\n+    }\n+}\n+\n+impl AllocId {\n+    /// Currently yields the top bit to discriminate the `AllocIdKind`s\n+    fn discriminant(self) -> u64 {\n+        self.0 >> 63\n+    }\n+    /// Yields everything but the discriminant bits\n+    fn index(self) -> u64 {\n+        self.0 & ((1 << 63) - 1)\n+    }\n+    fn destructure(self) -> AllocIdKind {\n+        match self.discriminant() {\n+            0 => AllocIdKind::Function(self.index() as usize),\n+            1 => AllocIdKind::Runtime(self.index()),\n+            n => bug!(\"got discriminant {} for AllocId\", n),\n+        }\n+    }\n+}\n \n impl fmt::Display for AllocId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.0)\n+        write!(f, \"{:?}\", self.destructure())\n+    }\n+}\n+\n+impl fmt::Debug for AllocId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{:?}\", self.destructure())\n     }\n }\n \n@@ -186,10 +229,10 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<AllocId, Allocation<M::MemoryKinds>>,\n+    alloc_map: HashMap<u64, Allocation<M::MemoryKinds>>,\n \n-    /// The AllocId to assign to the next new allocation. Always incremented, never gets smaller.\n-    next_id: AllocId,\n+    /// The AllocId to assign to the next new regular allocation. Always incremented, never gets smaller.\n+    next_alloc_id: u64,\n \n     /// Set of statics, constants, promoteds, vtables, ... to prevent `mark_static_initalized` from\n     /// stepping out of its own allocations. This set only contains statics backed by an\n@@ -205,7 +248,7 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n \n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, ty::Instance<'tcx>>,\n+    functions: Vec<ty::Instance<'tcx>>,\n \n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n     function_alloc_cache: HashMap<ty::Instance<'tcx>, AllocId>,\n@@ -231,9 +274,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         Memory {\n             data,\n             alloc_map: HashMap::new(),\n-            functions: HashMap::new(),\n+            functions: Vec::new(),\n             function_alloc_cache: HashMap::new(),\n-            next_id: AllocId(0),\n+            next_alloc_id: 0,\n             layout,\n             memory_size: max_memory,\n             memory_usage: 0,\n@@ -245,20 +288,20 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn allocations(&self) -> ::std::collections::hash_map::Iter<AllocId, Allocation<M::MemoryKinds>> {\n-        self.alloc_map.iter()\n+    pub fn allocations<'x>(&'x self) -> impl Iterator<Item = (AllocId, &'x Allocation<M::MemoryKinds>)> {\n+        self.alloc_map.iter().map(|(&id, alloc)| (AllocIdKind::Runtime(id).into_alloc_id(), alloc))\n     }\n \n     pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n             return MemoryPointer::new(alloc_id, 0);\n         }\n-        let id = self.next_id;\n+        let id = self.functions.len();\n         debug!(\"creating fn ptr: {}\", id);\n-        self.next_id.0 += 1;\n-        self.functions.insert(id, instance);\n-        self.function_alloc_cache.insert(instance, id);\n-        MemoryPointer::new(id, 0)\n+        self.functions.push(instance);\n+        let alloc_id = AllocIdKind::Function(id).into_alloc_id();\n+        self.function_alloc_cache.insert(instance, alloc_id);\n+        MemoryPointer::new(alloc_id, 0)\n     }\n \n     pub fn allocate_cached(&mut self, bytes: &[u8]) -> EvalResult<'tcx, MemoryPointer> {\n@@ -300,10 +343,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             mutable: Mutability::Mutable,\n             locks: RangeMap::new(),\n         };\n-        let id = self.next_id;\n-        self.next_id.0 += 1;\n+        let id = self.next_alloc_id;\n+        self.next_alloc_id += 1;\n         self.alloc_map.insert(id, alloc);\n-        Ok(MemoryPointer::new(id, 0))\n+        Ok(MemoryPointer::new(AllocIdKind::Runtime(id).into_alloc_id(), 0))\n     }\n \n     pub fn reallocate(\n@@ -344,7 +387,13 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return err!(DeallocateNonBasePtr);\n         }\n \n-        let alloc = match self.alloc_map.remove(&ptr.alloc_id) {\n+        let alloc_id = match ptr.alloc_id.destructure() {\n+            AllocIdKind::Function(_) =>\n+                return err!(DeallocatedWrongMemoryKind(\"function\".to_string(), format!(\"{:?}\", kind))),\n+            AllocIdKind::Runtime(id) => id,\n+        };\n+\n+        let alloc = match self.alloc_map.remove(&alloc_id) {\n             Some(alloc) => alloc,\n             None => return err!(DoubleFree),\n         };\n@@ -624,22 +673,22 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n /// Allocation accessors\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation<M::MemoryKinds>> {\n-        match self.alloc_map.get(&id) {\n-            Some(alloc) => Ok(alloc),\n-            None => match self.functions.get(&id) {\n-                Some(_) => err!(DerefFunctionPointer),\n+        match id.destructure() {\n+            AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n+            AllocIdKind::Runtime(id) => match self.alloc_map.get(&id) {\n+                Some(alloc) => Ok(alloc),\n                 None => err!(DanglingPointerDeref),\n-            }\n+            },\n         }\n     }\n     \n     fn get_mut_unchecked(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n-        match self.alloc_map.get_mut(&id) {\n-            Some(alloc) => Ok(alloc),\n-            None => match self.functions.get(&id) {\n-                Some(_) => err!(DerefFunctionPointer),\n+        match id.destructure() {\n+            AllocIdKind::Function(_) => err!(DerefFunctionPointer),\n+            AllocIdKind::Runtime(id) => match self.alloc_map.get_mut(&id) {\n+                Some(alloc) => Ok(alloc),\n                 None => err!(DanglingPointerDeref),\n-            }\n+            },\n         }\n     }\n \n@@ -657,12 +706,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             return err!(InvalidFunctionPointer);\n         }\n         debug!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        match self.functions.get(&ptr.alloc_id) {\n-            Some(&fndef) => Ok(fndef),\n-            None => match self.alloc_map.get(&ptr.alloc_id) {\n-                Some(_) => err!(ExecuteMemory),\n-                None => err!(InvalidFunctionPointer),\n-            }\n+        match ptr.alloc_id.destructure() {\n+            AllocIdKind::Function(id) => Ok(self.functions[id]),\n+            AllocIdKind::Runtime(_) => err!(ExecuteMemory),\n         }\n     }\n \n@@ -684,17 +730,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             let prefix_len = msg.len();\n             let mut relocations = vec![];\n \n-            let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n-                (Some(a), None) => a,\n-                (None, Some(instance)) => {\n-                    trace!(\"{} {}\", msg, instance);\n+            let alloc = match id.destructure() {\n+                AllocIdKind::Function(id) => {\n+                    trace!(\"{} {}\", msg, self.functions[id]);\n                     continue;\n                 },\n-                (None, None) => {\n-                    trace!(\"{} (deallocated)\", msg);\n-                    continue;\n+                AllocIdKind::Runtime(id) => match self.alloc_map.get(&id) {\n+                    Some(a) => a,\n+                    None => {\n+                        trace!(\"{} (deallocated)\", msg);\n+                        continue;\n+                    }\n                 },\n-                (Some(_), Some(_)) => bug!(\"miri invariant broken: an allocation id exists that points to both a function and a memory location\"),\n             };\n \n             for i in 0..(alloc.bytes.len() as u64) {\n@@ -745,7 +792,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n             .iter()\n             .filter_map(|(&key, val)| {\n                 if val.kind != Kind::Static {\n-                    Some(key)\n+                    Some(AllocIdKind::Runtime(key).into_alloc_id())\n                 } else {\n                     None\n                 }\n@@ -834,6 +881,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         trace!(\"mark_static_initalized {:?}, mutability: {:?}\", alloc_id, mutability);\n         // do not use `self.get_mut(alloc_id)` here, because we might have already marked a\n         // sub-element or have circular pointers (e.g. `Rc`-cycles)\n+        let alloc_id = match alloc_id.destructure() {\n+            AllocIdKind::Function(_) => return Ok(()),\n+            AllocIdKind::Runtime(id) => id,\n+        };\n         let relocations = match self.alloc_map.get_mut(&alloc_id) {\n             Some(&mut Allocation { ref mut relocations, ref mut kind, ref mut mutable, .. }) => {\n                 match *kind {\n@@ -854,8 +905,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n                 // mark recursively\n                 mem::replace(relocations, Default::default())\n             },\n-            None if !self.functions.contains_key(&alloc_id) => return err!(DanglingPointerDeref),\n-            _ => return Ok(()),\n+            None => return err!(DanglingPointerDeref),\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {"}, {"sha": "45e32142a8c44a2b723db5410bba8005a6b491a5", "filename": "tests/compile-fail/fn_ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ba2b82f3151c620edf442228de307fe71278555/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ba2b82f3151c620edf442228de307fe71278555/tests%2Fcompile-fail%2Ffn_ptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffn_ptr_offset.rs?ref=4ba2b82f3151c620edf442228de307fe71278555", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let y : *mut u8 = unsafe { mem::transmute(x) };\n     let y = y.wrapping_offset(1);\n     let x : fn() = unsafe { mem::transmute(y) };\n-    x(); //~ ERROR: tried to use an integer pointer or a dangling pointer as a function pointer\n+    x(); //~ ERROR: tried to use a function pointer after offsetting it\n }"}]}