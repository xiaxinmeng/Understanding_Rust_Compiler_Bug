{"sha": "9067d5277d10f0f32a49ec9c125a33828e26a32b", "node_id": "C_kwDOAAsO6NoAKDkwNjdkNTI3N2QxMGYwZjMyYTQ5ZWM5YzEyNWEzMzgyOGUyNmEzMmI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T19:12:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-28T19:12:21Z"}, "message": "Auto merge of #99863 - Dylan-DPC:rollup-lq9w047, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #99628 (add more docs regarding ideographic numbers)\n - #99689 (Revert `write!` and `writeln!` to late drop temporaries)\n - #99807 (Fix PermissionDenied UI tests on WSL)\n - #99817 (rustdoc: remove Clean trait impls for more items)\n - #99851 (Fix small typo in Cargo.toml comment)\n - #99856 (fix: remove fake no_dead_strip for osx)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "20a468451b7c7a0fd07ad5ff352b6d04fff44c70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20a468451b7c7a0fd07ad5ff352b6d04fff44c70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9067d5277d10f0f32a49ec9c125a33828e26a32b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9067d5277d10f0f32a49ec9c125a33828e26a32b", "html_url": "https://github.com/rust-lang/rust/commit/9067d5277d10f0f32a49ec9c125a33828e26a32b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9067d5277d10f0f32a49ec9c125a33828e26a32b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36f4f4aa38563d0c02bbdbbc03fb20145edef567", "url": "https://api.github.com/repos/rust-lang/rust/commits/36f4f4aa38563d0c02bbdbbc03fb20145edef567", "html_url": "https://github.com/rust-lang/rust/commit/36f4f4aa38563d0c02bbdbbc03fb20145edef567"}, {"sha": "55f041e1f6383fc7cafd6b4f9aa9b5d3c23b5c48", "url": "https://api.github.com/repos/rust-lang/rust/commits/55f041e1f6383fc7cafd6b4f9aa9b5d3c23b5c48", "html_url": "https://github.com/rust-lang/rust/commit/55f041e1f6383fc7cafd6b4f9aa9b5d3c23b5c48"}], "stats": {"total": 310, "additions": 215, "deletions": 95}, "files": [{"sha": "ffc886d47f3991536d16396654ac59c16902571c", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -60,7 +60,7 @@ exclude = [\n # verify that this is the case. This requires, however, that the crate is built\n # without overflow checks and debug assertions. Forcefully disable debug\n # assertions and overflow checks here which should ensure that even if these\n-# assertions are enabled for libstd we won't enable then for compiler_builtins\n+# assertions are enabled for libstd we won't enable them for compiler_builtins\n # which should ensure we still link everything correctly.\n debug-assertions = false\n overflow-checks = false"}, {"sha": "a4bbdefbb87f8d41aa68b3e54a27b376b09b5ee4", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -566,9 +566,7 @@ impl<'a> Linker for GccLinker<'a> {\n     }\n \n     fn no_gc_sections(&mut self) {\n-        if self.sess.target.is_like_osx {\n-            self.linker_arg(\"-no_dead_strip\");\n-        } else if self.sess.target.linker_is_gnu || self.sess.target.is_like_wasm {\n+        if self.sess.target.linker_is_gnu || self.sess.target.is_like_wasm {\n             self.linker_arg(\"--no-gc-sections\");\n         }\n     }"}, {"sha": "eae567cad00e62b7ddf7d5cdfe0e80fa91c020f7", "filename": "library/core/src/char/methods.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fchar%2Fmethods.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -892,7 +892,16 @@ impl char {\n     ///\n     /// The general categories for numbers (`Nd` for decimal digits, `Nl` for letter-like numeric\n     /// characters, and `No` for other numeric characters) are specified in the [Unicode Character\n-    /// Database][ucd] [`UnicodeData.txt`].\n+    /// Database][ucd] [`UnicodeData.txt`]. Note that this means ideographic numbers like '\u4e09'\n+    /// are considered alphabetic, not numeric. Please consider to use `is_ascii_digit` or `is_digit`.\n+    ///\n+    /// This method doesn't cover everything that could be considered a number, e.g. ideographic numbers like '\u4e09'.\n+    /// If you want everything including characters with overlapping purposes then you might want to use\n+    /// a unicode or language-processing library that exposes the appropriate character properties instead\n+    /// of looking at the unicode categories.\n+    ///\n+    /// If you want to parse ASCII decimal digits (0-9) or ASCII base-N, use\n+    /// `is_ascii_digit` or `is_digit` instead.\n     ///\n     /// [Unicode Standard]: https://www.unicode.org/versions/latest/\n     /// [ucd]: https://www.unicode.org/reports/tr44/\n@@ -911,6 +920,7 @@ impl char {\n     /// assert!(!'K'.is_numeric());\n     /// assert!(!'\u0648'.is_numeric());\n     /// assert!(!'\u85cf'.is_numeric());\n+    /// assert!(!'\u4e09'.is_numeric());\n     /// ```\n     #[must_use]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "3a115a8b8b6c614e343a0ae1f807d3cc4e03f255", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -496,10 +496,9 @@ macro_rules! r#try {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(test), rustc_diagnostic_item = \"write_macro\")]\n macro_rules! write {\n-    ($dst:expr, $($arg:tt)*) => {{\n-        let result = $dst.write_fmt($crate::format_args!($($arg)*));\n-        result\n-    }};\n+    ($dst:expr, $($arg:tt)*) => {\n+        $dst.write_fmt($crate::format_args!($($arg)*))\n+    };\n }\n \n /// Write formatted data into a buffer, with a newline appended.\n@@ -554,10 +553,9 @@ macro_rules! writeln {\n     ($dst:expr $(,)?) => {\n         $crate::write!($dst, \"\\n\")\n     };\n-    ($dst:expr, $($arg:tt)*) => {{\n-        let result = $dst.write_fmt($crate::format_args_nl!($($arg)*));\n-        result\n-    }};\n+    ($dst:expr, $($arg:tt)*) => {\n+        $dst.write_fmt($crate::format_args_nl!($($arg)*))\n+    };\n }\n \n /// Indicates unreachable code."}, {"sha": "2f2fbc9d4ba8da1903f1aab6f7fc648b63b95531", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -398,23 +398,19 @@ fn clean_type_outlives_predicate<'tcx>(\n     })\n }\n \n-impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n-        match self {\n-            ty::Term::Ty(ty) => Term::Type(clean_middle_ty(*ty, cx, None)),\n-            ty::Term::Const(c) => Term::Constant(clean_middle_const(*c, cx)),\n-        }\n+fn clean_middle_term<'tcx>(term: ty::Term<'tcx>, cx: &mut DocContext<'tcx>) -> Term {\n+    match term {\n+        ty::Term::Ty(ty) => Term::Type(clean_middle_ty(ty, cx, None)),\n+        ty::Term::Const(c) => Term::Constant(clean_middle_const(c, cx)),\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Term> for hir::Term<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n-        match self {\n-            hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n-            hir::Term::Const(c) => {\n-                let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n-                Term::Constant(clean_middle_const(ty::Const::from_anon_const(cx.tcx, def_id), cx))\n-            }\n+fn clean_hir_term<'tcx>(term: &hir::Term<'tcx>, cx: &mut DocContext<'tcx>) -> Term {\n+    match term {\n+        hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n+        hir::Term::Const(c) => {\n+            let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n+            Term::Constant(clean_middle_const(ty::Const::from_anon_const(cx.tcx, def_id), cx))\n         }\n     }\n }\n@@ -426,7 +422,7 @@ fn clean_projection_predicate<'tcx>(\n     let ty::ProjectionPredicate { projection_ty, term } = pred;\n     WherePredicate::EqPredicate {\n         lhs: clean_projection(projection_ty, cx, None),\n-        rhs: term.clean(cx),\n+        rhs: clean_middle_term(term, cx),\n     }\n }\n \n@@ -474,47 +470,44 @@ fn projection_to_path_segment<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n-        let (name, kind) = match self.kind {\n-            ty::GenericParamDefKind::Lifetime => {\n-                (self.name, GenericParamDefKind::Lifetime { outlives: vec![] })\n-            }\n-            ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n-                let default = if has_default {\n-                    Some(clean_middle_ty(cx.tcx.type_of(self.def_id), cx, Some(self.def_id)))\n-                } else {\n-                    None\n-                };\n-                (\n-                    self.name,\n-                    GenericParamDefKind::Type {\n-                        did: self.def_id,\n-                        bounds: vec![], // These are filled in from the where-clauses.\n-                        default: default.map(Box::new),\n-                        synthetic,\n-                    },\n-                )\n-            }\n-            ty::GenericParamDefKind::Const { has_default } => (\n-                self.name,\n-                GenericParamDefKind::Const {\n-                    did: self.def_id,\n-                    ty: Box::new(clean_middle_ty(\n-                        cx.tcx.type_of(self.def_id),\n-                        cx,\n-                        Some(self.def_id),\n-                    )),\n-                    default: match has_default {\n-                        true => Some(Box::new(cx.tcx.const_param_default(self.def_id).to_string())),\n-                        false => None,\n-                    },\n+fn clean_generic_param_def<'tcx>(\n+    def: &ty::GenericParamDef,\n+    cx: &mut DocContext<'tcx>,\n+) -> GenericParamDef {\n+    let (name, kind) = match def.kind {\n+        ty::GenericParamDefKind::Lifetime => {\n+            (def.name, GenericParamDefKind::Lifetime { outlives: vec![] })\n+        }\n+        ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n+            let default = if has_default {\n+                Some(clean_middle_ty(cx.tcx.type_of(def.def_id), cx, Some(def.def_id)))\n+            } else {\n+                None\n+            };\n+            (\n+                def.name,\n+                GenericParamDefKind::Type {\n+                    did: def.def_id,\n+                    bounds: vec![], // These are filled in from the where-clauses.\n+                    default: default.map(Box::new),\n+                    synthetic,\n                 },\n-            ),\n-        };\n+            )\n+        }\n+        ty::GenericParamDefKind::Const { has_default } => (\n+            def.name,\n+            GenericParamDefKind::Const {\n+                did: def.def_id,\n+                ty: Box::new(clean_middle_ty(cx.tcx.type_of(def.def_id), cx, Some(def.def_id))),\n+                default: match has_default {\n+                    true => Some(Box::new(cx.tcx.const_param_default(def.def_id).to_string())),\n+                    false => None,\n+                },\n+            },\n+        ),\n+    };\n \n-        GenericParamDef { name, kind }\n-    }\n+    GenericParamDef { name, kind }\n }\n \n fn clean_generic_param<'tcx>(\n@@ -672,7 +665,7 @@ fn clean_ty_generics<'tcx>(\n         .iter()\n         .filter_map(|param| match param.kind {\n             ty::GenericParamDefKind::Lifetime if param.name == kw::UnderscoreLifetime => None,\n-            ty::GenericParamDefKind::Lifetime => Some(param.clean(cx)),\n+            ty::GenericParamDefKind::Lifetime => Some(clean_generic_param_def(param, cx)),\n             ty::GenericParamDefKind::Type { synthetic, .. } => {\n                 if param.name == kw::SelfUpper {\n                     assert_eq!(param.index, 0);\n@@ -682,9 +675,9 @@ fn clean_ty_generics<'tcx>(\n                     impl_trait.insert(param.index.into(), vec![]);\n                     return None;\n                 }\n-                Some(param.clean(cx))\n+                Some(clean_generic_param_def(param, cx))\n             }\n-            ty::GenericParamDefKind::Const { .. } => Some(param.clean(cx)),\n+            ty::GenericParamDefKind::Const { .. } => Some(clean_generic_param_def(param, cx)),\n         })\n         .collect::<Vec<GenericParamDef>>();\n \n@@ -1682,7 +1675,9 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                             .projection_ty,\n                         cx,\n                     ),\n-                    kind: TypeBindingKind::Equality { term: pb.skip_binder().term.clean(cx) },\n+                    kind: TypeBindingKind::Equality {\n+                        term: clean_middle_term(pb.skip_binder().term, cx),\n+                    },\n                 });\n             }\n \n@@ -1746,7 +1741,7 @@ pub(crate) fn clean_middle_ty<'tcx>(\n                                     Some(TypeBinding {\n                                         assoc: projection_to_path_segment(proj.projection_ty, cx),\n                                         kind: TypeBindingKind::Equality {\n-                                            term: proj.term.clean(cx),\n+                                            term: clean_middle_term(proj.term, cx),\n                                         },\n                                     })\n                                 } else {\n@@ -2283,7 +2278,7 @@ impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref term } => {\n-                TypeBindingKind::Equality { term: term.clean(cx) }\n+                TypeBindingKind::Equality { term: clean_hir_term(term, cx) }\n             }\n             hir::TypeBindingKind::Constraint { bounds } => TypeBindingKind::Constraint {\n                 bounds: bounds.iter().filter_map(|b| b.clean(cx)).collect(),"}, {"sha": "afd2dc46ca3cb8dec4741dc087cbdaa800087dcb", "filename": "src/test/ui/linkage-attr/issue-10755.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Flinkage-attr%2Fissue-10755.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Flinkage-attr%2Fissue-10755.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flinkage-attr%2Fissue-10755.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -1,7 +1,10 @@\n // build-fail\n // dont-check-compiler-stderr\n // compile-flags: -C linker=llllll -C linker-flavor=ld\n-// error-pattern: linker `llllll` not found\n+// error-pattern: `llllll`\n+\n+// Before, the error-pattern checked for \"not found\". On WSL with appendWindowsPath=true, running\n+// in invalid command returns a PermissionDenied instead.\n \n fn main() {\n }"}, {"sha": "d959329b9fce29fc84e0b3b1028323ab4711d1c8", "filename": "src/test/ui/macros/format-args-temporaries-async.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-async.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -0,0 +1,37 @@\n+// check-pass\n+// edition:2021\n+\n+use std::fmt::{self, Display};\n+use std::future::Future;\n+use std::io;\n+use std::pin::Pin;\n+use std::task::{Context, Poll};\n+\n+struct AsyncStdout;\n+\n+impl AsyncStdout {\n+    fn write_fmt<'a>(&'a mut self, _args: fmt::Arguments) -> WriteFmtFuture<'a, Self>\n+    where\n+        Self: Unpin,\n+    {\n+        WriteFmtFuture(self)\n+    }\n+}\n+\n+struct WriteFmtFuture<'a, T>(&'a mut T);\n+\n+impl<'a, T> Future for WriteFmtFuture<'a, T> {\n+    type Output = io::Result<()>;\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {\n+        unimplemented!()\n+    }\n+}\n+\n+async fn async_main() {\n+    let _write = write!(&mut AsyncStdout, \"...\").await;\n+    let _writeln = writeln!(&mut AsyncStdout, \"...\").await;\n+}\n+\n+fn main() {\n+    let _ = async_main;\n+}"}, {"sha": "339ccbc33ac98161f18ad0c0e85d1a340b18a29d", "filename": "src/test/ui/macros/format-args-temporaries-in-write.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -0,0 +1,50 @@\n+// check-fail\n+\n+use std::fmt::{self, Display};\n+\n+struct Mutex;\n+\n+impl Mutex {\n+    fn lock(&self) -> MutexGuard {\n+        MutexGuard(self)\n+    }\n+}\n+\n+struct MutexGuard<'a>(&'a Mutex);\n+\n+impl<'a> Drop for MutexGuard<'a> {\n+    fn drop(&mut self) {\n+        // Empty but this is a necessary part of the repro. Otherwise borrow\n+        // checker is fine with 'a dangling at the time that MutexGuard goes out\n+        // of scope.\n+    }\n+}\n+\n+struct Out;\n+\n+impl Out {\n+    fn write_fmt(&self, _args: fmt::Arguments) {}\n+}\n+\n+impl<'a> Display for MutexGuard<'a> {\n+    fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n+        Ok(())\n+    }\n+}\n+\n+fn main() {\n+    // FIXME(dtolnay): We actually want both of these to work. I think it's\n+    // sadly unimplementable today though.\n+\n+    let _write = {\n+        let mutex = Mutex;\n+        write!(Out, \"{}\", mutex.lock()) /* no semicolon */\n+        //~^ ERROR `mutex` does not live long enough\n+    };\n+\n+    let _writeln = {\n+        let mutex = Mutex;\n+        writeln!(Out, \"{}\", mutex.lock()) /* no semicolon */\n+        //~^ ERROR `mutex` does not live long enough\n+    };\n+}"}, {"sha": "03ecc4b4418c61aa25f065301dfd25f89ad619e2", "filename": "src/test/ui/macros/format-args-temporaries-in-write.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries-in-write.stderr?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -0,0 +1,43 @@\n+error[E0597]: `mutex` does not live long enough\n+  --> $DIR/format-args-temporaries-in-write.rs:41:27\n+   |\n+LL |         write!(Out, \"{}\", mutex.lock()) /* no semicolon */\n+   |                           ^^^^^^^^^^^^\n+   |                           |\n+   |                           borrowed value does not live long enough\n+   |                           a temporary with access to the borrow is created here ...\n+LL |\n+LL |     };\n+   |     -- ... and the borrow might be used here, when that temporary is dropped and runs the `Drop` code for type `MutexGuard`\n+   |     |\n+   |     `mutex` dropped here while still borrowed\n+   |\n+help: consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+   |\n+LL |         $dst.write_fmt($crate::format_args!($($arg)*));\n+   |                                                       +\n+\n+error[E0597]: `mutex` does not live long enough\n+  --> $DIR/format-args-temporaries-in-write.rs:47:29\n+   |\n+LL |         writeln!(Out, \"{}\", mutex.lock()) /* no semicolon */\n+   |                             ^^^^^^^^^^^^\n+   |                             |\n+   |                             borrowed value does not live long enough\n+   |                             a temporary with access to the borrow is created here ...\n+LL |\n+LL |     };\n+   |     -- ... and the borrow might be used here, when that temporary is dropped and runs the `Drop` code for type `MutexGuard`\n+   |     |\n+   |     `mutex` dropped here while still borrowed\n+   |\n+help: consider adding semicolon after the expression so its temporaries are dropped sooner, before the local variables declared by the block are dropped\n+  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n+   |\n+LL |         $dst.write_fmt($crate::format_args_nl!($($arg)*));\n+   |                                                          +\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "59323828bc37f0d9de2aaaf685104f0beb2f2d65", "filename": "src/test/ui/macros/format-args-temporaries.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-args-temporaries.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -20,29 +20,13 @@ impl<'a> Drop for MutexGuard<'a> {\n     }\n }\n \n-impl<'a> MutexGuard<'a> {\n-    fn write_fmt(&self, _args: fmt::Arguments) {}\n-}\n-\n impl<'a> Display for MutexGuard<'a> {\n     fn fmt(&self, _formatter: &mut fmt::Formatter) -> fmt::Result {\n         Ok(())\n     }\n }\n \n fn main() {\n-    let _write = {\n-        let out = Mutex;\n-        let mutex = Mutex;\n-        write!(out.lock(), \"{}\", mutex.lock()) /* no semicolon */\n-    };\n-\n-    let _writeln = {\n-        let out = Mutex;\n-        let mutex = Mutex;\n-        writeln!(out.lock(), \"{}\", mutex.lock()) /* no semicolon */\n-    };\n-\n     let _print = {\n         let mutex = Mutex;\n         print!(\"{}\", mutex.lock()) /* no semicolon */"}, {"sha": "a513722639adb13123f191b728ebc563291da5f6", "filename": "src/test/ui/process/process-spawn-nonexistent.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fprocess%2Fprocess-spawn-nonexistent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9067d5277d10f0f32a49ec9c125a33828e26a32b/src%2Ftest%2Fui%2Fprocess%2Fprocess-spawn-nonexistent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-spawn-nonexistent.rs?ref=9067d5277d10f0f32a49ec9c125a33828e26a32b", "patch": "@@ -6,9 +6,11 @@ use std::io::ErrorKind;\n use std::process::Command;\n \n fn main() {\n-    assert_eq!(Command::new(\"nonexistent\")\n-                   .spawn()\n-                   .unwrap_err()\n-                   .kind(),\n-               ErrorKind::NotFound);\n+    let result = Command::new(\"nonexistent\").spawn().unwrap_err().kind();\n+\n+    assert!(matches!(\n+        result,\n+        // Under WSL with appendWindowsPath=true, this fails with PermissionDenied\n+        ErrorKind::NotFound | ErrorKind::PermissionDenied\n+    ));\n }"}]}