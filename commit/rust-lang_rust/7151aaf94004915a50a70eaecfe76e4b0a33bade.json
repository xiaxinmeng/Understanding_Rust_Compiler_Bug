{"sha": "7151aaf94004915a50a70eaecfe76e4b0a33bade", "node_id": "C_kwDOAAsO6NoAKDcxNTFhYWY5NDAwNDkxNWE1MGE3MGVhZWNmZTc2ZTRiMGEzM2JhZGU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-07-11T20:39:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-07-11T20:39:06Z"}, "message": "Rollup merge of #99124 - compiler-errors:issue-99122, r=oli-obk\n\nFix sized check ICE in asm check\n\nFixes (beta nominated, so doesn't close) #99122\n\n1. Moves a check for unresolved inference variables to _before_ other checks that could possibly ICE. We're not changing behavior here, just doing the same thing earlier in the function.\n2. Erases region variables in sized check (which are not resolved at this point) because rustc will also ICE when region vars are passed to a query which does not canonicalize them.", "tree": {"sha": "e03371255ecc947ec2f11be455eae95e49ac3f33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e03371255ecc947ec2f11be455eae95e49ac3f33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7151aaf94004915a50a70eaecfe76e4b0a33bade", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJizIprCRBK7hj4Ov3rIwAAE3cIAJC94zVk/8WNvpeI0Bs8Zhp9\nsjIr3tuU+35EeR1eFyltGHF5AKWRhklCtETRoAq9EOtqDLgLg4wGPpiZ1wQpYdDR\noTakFLOo96WK/AM3xZ8g88vg6Qr/Dmmc7jZE5zUKj7TfJX9+PwYAmqHUNjNq9OAp\npM97BiQ7WtdnJTWv8Dnkbu2Us9fRYwiPWUYuX2kiH25/Wt8KpVuRNywmWxhx2cax\ndUAix/n9JYlQE7sZRjhsqdFwAvjGTZNqNMdAZth5crOoAxCe+hYLKD/+04J3aO6T\na3xCtvK8mKEhss2Riuh/cPu3WHyCKApQ5vlW2a25x3dxPgmytv8xm2InbEIWW3o=\n=+y7w\n-----END PGP SIGNATURE-----\n", "payload": "tree e03371255ecc947ec2f11be455eae95e49ac3f33\nparent d89c18355455ec1542b1ee78f684cd4baed663e7\nparent 5c6560f2d5c9a286ac389a9c81e5a6be94e01aa4\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1657571946 +0200\ncommitter GitHub <noreply@github.com> 1657571946 +0200\n\nRollup merge of #99124 - compiler-errors:issue-99122, r=oli-obk\n\nFix sized check ICE in asm check\n\nFixes (beta nominated, so doesn't close) #99122\n\n1. Moves a check for unresolved inference variables to _before_ other checks that could possibly ICE. We're not changing behavior here, just doing the same thing earlier in the function.\n2. Erases region variables in sized check (which are not resolved at this point) because rustc will also ICE when region vars are passed to a query which does not canonicalize them.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7151aaf94004915a50a70eaecfe76e4b0a33bade", "html_url": "https://github.com/rust-lang/rust/commit/7151aaf94004915a50a70eaecfe76e4b0a33bade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7151aaf94004915a50a70eaecfe76e4b0a33bade/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d89c18355455ec1542b1ee78f684cd4baed663e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d89c18355455ec1542b1ee78f684cd4baed663e7", "html_url": "https://github.com/rust-lang/rust/commit/d89c18355455ec1542b1ee78f684cd4baed663e7"}, {"sha": "5c6560f2d5c9a286ac389a9c81e5a6be94e01aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c6560f2d5c9a286ac389a9c81e5a6be94e01aa4", "html_url": "https://github.com/rust-lang/rust/commit/5c6560f2d5c9a286ac389a9c81e5a6be94e01aa4"}], "stats": {"total": 79, "additions": 58, "deletions": 21}, "files": [{"sha": "a5add1e9a8acb629a73dca107039b07197cd77fe", "filename": "compiler/rustc_typeck/src/check/intrinsicck.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7151aaf94004915a50a70eaecfe76e4b0a33bade/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7151aaf94004915a50a70eaecfe76e4b0a33bade/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=7151aaf94004915a50a70eaecfe76e4b0a33bade", "patch": "@@ -4,7 +4,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_index::vec::Idx;\n use rustc_middle::ty::layout::{LayoutError, SizeSkeleton};\n-use rustc_middle::ty::{self, Article, FloatTy, InferTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n+use rustc_middle::ty::{self, Article, FloatTy, IntTy, Ty, TyCtxt, TypeVisitable, UintTy};\n use rustc_session::lint;\n use rustc_span::{Span, Symbol, DUMMY_SP};\n use rustc_target::abi::{Pointer, VariantIdx};\n@@ -99,8 +99,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n+    // FIXME(compiler-errors): This could use `<$ty as Pointee>::Metadata == ()`\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        // Type still may have region variables, but `Sized` does not depend\n+        // on those, so just erase them before querying.\n+        if self.tcx.erase_regions(ty).is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n@@ -128,30 +131,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             64 => InlineAsmType::I64,\n             _ => unreachable!(),\n         };\n+\n+        // Expect types to be fully resolved, no const or type variables.\n+        if ty.has_infer_types_or_consts() {\n+            assert!(self.is_tainted_by_errors());\n+            return None;\n+        }\n+\n         let asm_ty = match *ty.kind() {\n             // `!` is allowed for input but not for output (issue #87802)\n             ty::Never if is_input => return None,\n             ty::Error(_) => return None,\n             ty::Int(IntTy::I8) | ty::Uint(UintTy::U8) => Some(InlineAsmType::I8),\n             ty::Int(IntTy::I16) | ty::Uint(UintTy::U16) => Some(InlineAsmType::I16),\n-            // Somewhat of a hack: fallback in the presence of errors does not actually\n-            // fall back to i32, but to ty::Error. For integer inference variables this\n-            // means that they don't get any fallback and stay as `{integer}`.\n-            // Since compilation can't succeed anyway, it's fine to use this to avoid printing\n-            // \"cannot use value of type `{integer}`\", even though that would absolutely\n-            // work due due i32 fallback if the current function had no other errors.\n-            ty::Infer(InferTy::IntVar(_)) => {\n-                assert!(self.is_tainted_by_errors());\n-                Some(InlineAsmType::I32)\n-            }\n             ty::Int(IntTy::I32) | ty::Uint(UintTy::U32) => Some(InlineAsmType::I32),\n             ty::Int(IntTy::I64) | ty::Uint(UintTy::U64) => Some(InlineAsmType::I64),\n             ty::Int(IntTy::I128) | ty::Uint(UintTy::U128) => Some(InlineAsmType::I128),\n             ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => Some(asm_ty_isize),\n-            ty::Infer(InferTy::FloatVar(_)) => {\n-                assert!(self.is_tainted_by_errors());\n-                Some(InlineAsmType::F32)\n-            }\n             ty::Float(FloatTy::F32) => Some(InlineAsmType::F32),\n             ty::Float(FloatTy::F64) => Some(InlineAsmType::F64),\n             ty::FnPtr(_) => Some(asm_ty_isize),\n@@ -191,6 +187,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     _ => None,\n                 }\n             }\n+            ty::Infer(_) => unreachable!(),\n             _ => None,\n         };\n         let Some(asm_ty) = asm_ty else {\n@@ -204,11 +201,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return None;\n         };\n \n-        if ty.has_infer_types_or_consts() {\n-            assert!(self.is_tainted_by_errors());\n-            return None;\n-        }\n-\n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n         if !self.infcx.type_is_copy_modulo_regions(self.param_env, ty, DUMMY_SP) {"}, {"sha": "cfb9fd90a55b7c56075ec484311cb5647c729018", "filename": "src/test/ui/asm/issue-99122-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7151aaf94004915a50a70eaecfe76e4b0a33bade/src%2Ftest%2Fui%2Fasm%2Fissue-99122-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7151aaf94004915a50a70eaecfe76e4b0a33bade/src%2Ftest%2Fui%2Fasm%2Fissue-99122-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-99122-2.rs?ref=7151aaf94004915a50a70eaecfe76e4b0a33bade", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+// needs-asm-support\n+// only-x86_64\n+\n+// This demonstrates why we need to erase regions before sized check in intrinsicck\n+\n+struct NoCopy;\n+\n+struct Wrap<'a, T, Tail: ?Sized>(&'a T, Tail);\n+\n+pub unsafe fn test() {\n+    let i = NoCopy;\n+    let j = Wrap(&i, ());\n+    let pointer = &j as *const _;\n+    core::arch::asm!(\n+        \"nop\",\n+        in(\"eax\") pointer,\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "744a563d3d147695436784a6445a5119a37eb94c", "filename": "src/test/ui/asm/issue-99122.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7151aaf94004915a50a70eaecfe76e4b0a33bade/src%2Ftest%2Fui%2Fasm%2Fissue-99122.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7151aaf94004915a50a70eaecfe76e4b0a33bade/src%2Ftest%2Fui%2Fasm%2Fissue-99122.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-99122.rs?ref=7151aaf94004915a50a70eaecfe76e4b0a33bade", "patch": "@@ -0,0 +1,13 @@\n+// needs-asm-support\n+// only-x86_64\n+\n+pub unsafe fn test() {\n+    let pointer = 1u32 as *const _;\n+    //~^ ERROR cannot cast to a pointer of an unknown kind\n+    core::arch::asm!(\n+        \"nop\",\n+        in(\"eax\") pointer,\n+    );\n+}\n+\n+fn main() {}"}, {"sha": "2758a4ac4377e955ce7d22860834b13c92259ef5", "filename": "src/test/ui/asm/issue-99122.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7151aaf94004915a50a70eaecfe76e4b0a33bade/src%2Ftest%2Fui%2Fasm%2Fissue-99122.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7151aaf94004915a50a70eaecfe76e4b0a33bade/src%2Ftest%2Fui%2Fasm%2Fissue-99122.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fissue-99122.stderr?ref=7151aaf94004915a50a70eaecfe76e4b0a33bade", "patch": "@@ -0,0 +1,11 @@\n+error[E0641]: cannot cast to a pointer of an unknown kind\n+  --> $DIR/issue-99122.rs:5:27\n+   |\n+LL |     let pointer = 1u32 as *const _;\n+   |                           ^^^^^^^^ needs more type information\n+   |\n+   = note: the type information given here is insufficient to check whether the pointer cast is valid\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0641`."}]}