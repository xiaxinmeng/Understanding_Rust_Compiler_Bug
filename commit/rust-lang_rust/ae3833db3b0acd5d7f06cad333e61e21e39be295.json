{"sha": "ae3833db3b0acd5d7f06cad333e61e21e39be295", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlMzgzM2RiM2IwYWNkNWQ3ZjA2Y2FkMzMzZTYxZTIxZTM5YmUyOTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-12T10:44:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-12T10:44:32Z"}, "message": "Auto merge of #56039 - ljedrz:sorted_map_upgrades, r=matthewjasper\n\nSortedMap upgrades\n\n- change the impl `From<Iterator<I>>` to `FromIterator<I>`\n- make the impls of `Index` and `get` match the ones from `BTreeMap`\n- add `is_empty` and `contains_key`\n- readability/whitespace fixes\n- add a proper `Iterator` implementation\n- `impl IntoIterator for &SortedMap`\n\nThese changes make `SortedMap` almost a drop-in replacement for `BTreeMap`, at least to the point it is used by `rustc`; what is left is `Entry` API that I'd like to follow this PR with, and possibly implementing `ParallelIterator`.", "tree": {"sha": "e260a37e715dfc035ddf4e0b85bc7262993fff71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e260a37e715dfc035ddf4e0b85bc7262993fff71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae3833db3b0acd5d7f06cad333e61e21e39be295", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae3833db3b0acd5d7f06cad333e61e21e39be295", "html_url": "https://github.com/rust-lang/rust/commit/ae3833db3b0acd5d7f06cad333e61e21e39be295", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae3833db3b0acd5d7f06cad333e61e21e39be295/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a64cdec1b48b0d042e5f0e38634a7c438c104b85", "url": "https://api.github.com/repos/rust-lang/rust/commits/a64cdec1b48b0d042e5f0e38634a7c438c104b85", "html_url": "https://github.com/rust-lang/rust/commit/a64cdec1b48b0d042e5f0e38634a7c438c104b85"}, {"sha": "5b6401f09db502b9e596bf7d756ccc97029dfe31", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b6401f09db502b9e596bf7d756ccc97029dfe31", "html_url": "https://github.com/rust-lang/rust/commit/5b6401f09db502b9e596bf7d756ccc97029dfe31"}], "stats": {"total": 69, "additions": 49, "deletions": 20}, "files": [{"sha": "3bd3d116607978dffd9b4d6d86c138334068a779", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ae3833db3b0acd5d7f06cad333e61e21e39be295/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae3833db3b0acd5d7f06cad333e61e21e39be295/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=ae3833db3b0acd5d7f06cad333e61e21e39be295", "patch": "@@ -10,7 +10,7 @@\n \n use std::borrow::Borrow;\n use std::cmp::Ordering;\n-use std::convert::From;\n+use std::iter::FromIterator;\n use std::mem;\n use std::ops::{RangeBounds, Bound, Index, IndexMut};\n \n@@ -25,11 +25,10 @@ use std::ops::{RangeBounds, Bound, Index, IndexMut};\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Default, Debug, RustcEncodable,\n          RustcDecodable)]\n pub struct SortedMap<K: Ord, V> {\n-    data: Vec<(K,V)>\n+    data: Vec<(K, V)>\n }\n \n impl<K: Ord, V> SortedMap<K, V> {\n-\n     #[inline]\n     pub fn new() -> SortedMap<K, V> {\n         SortedMap {\n@@ -82,7 +81,10 @@ impl<K: Ord, V> SortedMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn get(&self, key: &K) -> Option<&V> {\n+    pub fn get<Q>(&self, key: &Q) -> Option<&V>\n+        where K: Borrow<Q>,\n+              Q: Ord + ?Sized\n+    {\n         match self.lookup_index_for(key) {\n             Ok(index) => {\n                 unsafe {\n@@ -96,7 +98,10 @@ impl<K: Ord, V> SortedMap<K, V> {\n     }\n \n     #[inline]\n-    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+    pub fn get_mut<Q>(&mut self, key: &Q) -> Option<&mut V>\n+        where K: Borrow<Q>,\n+              Q: Ord + ?Sized\n+    {\n         match self.lookup_index_for(key) {\n             Ok(index) => {\n                 unsafe {\n@@ -122,13 +127,13 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n     /// Iterate over the keys, sorted\n     #[inline]\n-    pub fn keys(&self) -> impl Iterator<Item=&K> + ExactSizeIterator {\n+    pub fn keys(&self) -> impl Iterator<Item = &K> + ExactSizeIterator {\n         self.data.iter().map(|&(ref k, _)| k)\n     }\n \n     /// Iterate over values, sorted by key\n     #[inline]\n-    pub fn values(&self) -> impl Iterator<Item=&V> + ExactSizeIterator {\n+    pub fn values(&self) -> impl Iterator<Item = &V> + ExactSizeIterator {\n         self.data.iter().map(|&(_, ref v)| v)\n     }\n \n@@ -137,6 +142,11 @@ impl<K: Ord, V> SortedMap<K, V> {\n         self.data.len()\n     }\n \n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+\n     #[inline]\n     pub fn range<R>(&self, range: R) -> &[(K, V)]\n         where R: RangeBounds<K>\n@@ -207,8 +217,11 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n     /// Looks up the key in `self.data` via `slice::binary_search()`.\n     #[inline(always)]\n-    fn lookup_index_for(&self, key: &K) -> Result<usize, usize> {\n-        self.data.binary_search_by(|&(ref x, _)| x.cmp(key))\n+    fn lookup_index_for<Q>(&self, key: &Q) -> Result<usize, usize>\n+        where K: Borrow<Q>,\n+              Q: Ord + ?Sized\n+    {\n+        self.data.binary_search_by(|&(ref x, _)| x.borrow().cmp(key))\n     }\n \n     #[inline]\n@@ -247,38 +260,54 @@ impl<K: Ord, V> SortedMap<K, V> {\n \n         (start, end)\n     }\n+\n+    #[inline]\n+    pub fn contains_key<Q>(&self, key: &Q) -> bool\n+        where K: Borrow<Q>,\n+              Q: Ord + ?Sized\n+    {\n+        self.get(key).is_some()\n+    }\n }\n \n impl<K: Ord, V> IntoIterator for SortedMap<K, V> {\n     type Item = (K, V);\n     type IntoIter = ::std::vec::IntoIter<(K, V)>;\n+\n     fn into_iter(self) -> Self::IntoIter {\n         self.data.into_iter()\n     }\n }\n \n-impl<K: Ord, V, Q: Borrow<K>> Index<Q> for SortedMap<K, V> {\n+impl<'a, K, Q, V> Index<&'a Q> for SortedMap<K, V>\n+    where K: Ord + Borrow<Q>,\n+          Q: Ord + ?Sized\n+{\n     type Output = V;\n-    fn index(&self, index: Q) -> &Self::Output {\n-        let k: &K = index.borrow();\n-        self.get(k).unwrap()\n+\n+    fn index(&self, key: &Q) -> &Self::Output {\n+        self.get(key).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V, Q: Borrow<K>> IndexMut<Q> for SortedMap<K, V> {\n-    fn index_mut(&mut self, index: Q) -> &mut Self::Output {\n-        let k: &K = index.borrow();\n-        self.get_mut(k).unwrap()\n+impl<'a, K, Q, V> IndexMut<&'a Q> for SortedMap<K, V>\n+    where K: Ord + Borrow<Q>,\n+          Q: Ord + ?Sized\n+{\n+    fn index_mut(&mut self, key: &Q) -> &mut Self::Output {\n+        self.get_mut(key).expect(\"no entry found for key\")\n     }\n }\n \n-impl<K: Ord, V, I: Iterator<Item=(K, V)>> From<I> for SortedMap<K, V> {\n-    fn from(data: I) -> Self {\n-        let mut data: Vec<(K, V)> = data.collect();\n+impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n+    fn from_iter<T: IntoIterator<Item = (K, V)>>(iter: T) -> Self {\n+        let mut data: Vec<(K, V)> = iter.into_iter().collect();\n+\n         data.sort_unstable_by(|&(ref k1, _), &(ref k2, _)| k1.cmp(k2));\n         data.dedup_by(|&mut (ref k1, _), &mut (ref k2, _)| {\n             k1.cmp(k2) == Ordering::Equal\n         });\n+\n         SortedMap {\n             data\n         }"}]}