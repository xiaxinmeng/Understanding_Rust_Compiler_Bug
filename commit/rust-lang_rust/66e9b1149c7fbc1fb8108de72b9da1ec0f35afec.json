{"sha": "66e9b1149c7fbc1fb8108de72b9da1ec0f35afec", "node_id": "C_kwDOAAsO6NoAKDY2ZTliMTE0OWM3ZmJjMWZiODEwOGRlNzJiOWRhMWVjMGYzNWFmZWM", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-21T04:01:39Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-09-25T22:28:45Z"}, "message": "Rearrange `TokenTreesReader::parse_token_tree`.\n\n`parse_token_tree` is basically a match with four arms: `Eof`,\n`OpenDelim`, `CloseDelim`, and \"other\". It has two call sites, and at\neach call site one of the arms is unreachable. It's also not inlined.\n\nThis commit removes `parse_token_tree` by splitting it into four\nfunctions and inlining them. This avoids some repeated conditional\ntests and also some non-inlined function calls on the hot path.", "tree": {"sha": "e3194c6bc747d0cc8115be4c83a0b9d96905df5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3194c6bc747d0cc8115be4c83a0b9d96905df5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec", "html_url": "https://github.com/rust-lang/rust/commit/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3fafbb006ee98635874f73e480655912b465e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fafbb006ee98635874f73e480655912b465e65", "html_url": "https://github.com/rust-lang/rust/commit/f3fafbb006ee98635874f73e480655912b465e65"}], "stats": {"total": 349, "additions": 170, "deletions": 179}, "files": [{"sha": "babab1fa112fc931353797de3a0b5569ccfd1d9e", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=66e9b1149c7fbc1fb8108de72b9da1ec0f35afec", "patch": "@@ -63,7 +63,8 @@ pub mod translation;\n pub use diagnostic_builder::IntoDiagnostic;\n pub use snippet::Style;\n \n-pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a, ErrorGuaranteed>>;\n+pub type PErr<'a> = DiagnosticBuilder<'a, ErrorGuaranteed>;\n+pub type PResult<'a, T> = Result<T, PErr<'a>>;\n \n // `PResult` is used a lot. Make sure it doesn't unintentionally get bigger.\n // (See also the comment on `DiagnosticBuilder`'s `diagnostic` field.)"}, {"sha": "3372544a579a333b1e1b1884f2e26e8d63cd9e24", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 168, "deletions": 178, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e9b1149c7fbc1fb8108de72b9da1ec0f35afec/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=66e9b1149c7fbc1fb8108de72b9da1ec0f35afec", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::token::{self, Delimiter, Token};\n use rustc_ast::tokenstream::{DelimSpan, Spacing, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust::token_to_string;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::PResult;\n+use rustc_errors::{PErr, PResult};\n use rustc_span::Span;\n \n impl<'a> StringReader<'a> {\n@@ -48,220 +48,210 @@ impl<'a> TokenTreesReader<'a> {\n         let mut buf = TokenStreamBuilder::default();\n \n         self.bump();\n-        while self.token != token::Eof {\n-            buf.push(self.parse_token_tree()?);\n+        loop {\n+            match self.token.kind {\n+                token::OpenDelim(delim) => buf.push(self.parse_token_tree_open_delim(delim)),\n+                token::CloseDelim(delim) => return Err(self.close_delim_err(delim)),\n+                token::Eof => return Ok(buf.into_token_stream()),\n+                _ => buf.push(self.parse_token_tree_other()),\n+            }\n         }\n-\n-        Ok(buf.into_token_stream())\n     }\n \n     // Parse a stream of tokens into a list of `TokenTree`s, up to a `CloseDelim`.\n     fn parse_token_trees_until_close_delim(&mut self) -> TokenStream {\n         let mut buf = TokenStreamBuilder::default();\n         loop {\n-            if let token::CloseDelim(..) = self.token.kind {\n-                return buf.into_token_stream();\n-            }\n-\n-            match self.parse_token_tree() {\n-                Ok(tree) => buf.push(tree),\n-                Err(mut e) => {\n-                    e.emit();\n+            match self.token.kind {\n+                token::OpenDelim(delim) => buf.push(self.parse_token_tree_open_delim(delim)),\n+                token::CloseDelim(..) => return buf.into_token_stream(),\n+                token::Eof => {\n+                    let mut err = self.eof_err();\n+                    err.emit();\n                     return buf.into_token_stream();\n                 }\n+                _ => buf.push(self.parse_token_tree_other()),\n             }\n         }\n     }\n \n-    fn parse_token_tree(&mut self) -> PResult<'a, TokenTree> {\n-        let sm = self.string_reader.sess.source_map();\n-\n-        match self.token.kind {\n-            token::Eof => {\n-                let msg = \"this file contains an unclosed delimiter\";\n-                let mut err =\n-                    self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, msg);\n-                for &(_, sp) in &self.open_braces {\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                    self.unmatched_braces.push(UnmatchedBrace {\n-                        expected_delim: Delimiter::Brace,\n-                        found_delim: None,\n-                        found_span: self.token.span,\n-                        unclosed_span: Some(sp),\n-                        candidate_span: None,\n-                    });\n-                }\n+    fn eof_err(&mut self) -> PErr<'a> {\n+        let msg = \"this file contains an unclosed delimiter\";\n+        let mut err = self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, msg);\n+        for &(_, sp) in &self.open_braces {\n+            err.span_label(sp, \"unclosed delimiter\");\n+            self.unmatched_braces.push(UnmatchedBrace {\n+                expected_delim: Delimiter::Brace,\n+                found_delim: None,\n+                found_span: self.token.span,\n+                unclosed_span: Some(sp),\n+                candidate_span: None,\n+            });\n+        }\n \n-                if let Some((delim, _)) = self.open_braces.last() {\n-                    if let Some((_, open_sp, close_sp)) =\n-                        self.matching_delim_spans.iter().find(|(d, open_sp, close_sp)| {\n-                            if let Some(close_padding) = sm.span_to_margin(*close_sp) {\n-                                if let Some(open_padding) = sm.span_to_margin(*open_sp) {\n-                                    return delim == d && close_padding != open_padding;\n-                                }\n-                            }\n-                            false\n-                        })\n-                    // these are in reverse order as they get inserted on close, but\n-                    {\n-                        // we want the last open/first close\n-                        err.span_label(*open_sp, \"this delimiter might not be properly closed...\");\n-                        err.span_label(\n-                            *close_sp,\n-                            \"...as it matches this but it has different indentation\",\n-                        );\n+        if let Some((delim, _)) = self.open_braces.last() {\n+            if let Some((_, open_sp, close_sp)) =\n+                self.matching_delim_spans.iter().find(|(d, open_sp, close_sp)| {\n+                    let sm = self.string_reader.sess.source_map();\n+                    if let Some(close_padding) = sm.span_to_margin(*close_sp) {\n+                        if let Some(open_padding) = sm.span_to_margin(*open_sp) {\n+                            return delim == d && close_padding != open_padding;\n+                        }\n                     }\n-                }\n-                Err(err)\n+                    false\n+                })\n+            // these are in reverse order as they get inserted on close, but\n+            {\n+                // we want the last open/first close\n+                err.span_label(*open_sp, \"this delimiter might not be properly closed...\");\n+                err.span_label(*close_sp, \"...as it matches this but it has different indentation\");\n             }\n-            token::OpenDelim(delim) => {\n-                // The span for beginning of the delimited section\n-                let pre_span = self.token.span;\n-\n-                // Parse the open delimiter.\n-                self.open_braces.push((delim, self.token.span));\n-                self.bump();\n+        }\n+        err\n+    }\n \n-                // Parse the token trees within the delimiters.\n-                // We stop at any delimiter so we can try to recover if the user\n-                // uses an incorrect delimiter.\n-                let tts = self.parse_token_trees_until_close_delim();\n+    fn parse_token_tree_open_delim(&mut self, delim: Delimiter) -> TokenTree {\n+        // The span for beginning of the delimited section\n+        let pre_span = self.token.span;\n \n-                // Expand to cover the entire delimited token tree\n-                let delim_span = DelimSpan::from_pair(pre_span, self.token.span);\n+        // Parse the open delimiter.\n+        self.open_braces.push((delim, self.token.span));\n+        self.bump();\n \n-                match self.token.kind {\n-                    // Correct delimiter.\n-                    token::CloseDelim(d) if d == delim => {\n-                        let (open_brace, open_brace_span) = self.open_braces.pop().unwrap();\n-                        let close_brace_span = self.token.span;\n+        // Parse the token trees within the delimiters.\n+        // We stop at any delimiter so we can try to recover if the user\n+        // uses an incorrect delimiter.\n+        let tts = self.parse_token_trees_until_close_delim();\n \n-                        if tts.is_empty() {\n-                            let empty_block_span = open_brace_span.to(close_brace_span);\n-                            if !sm.is_multiline(empty_block_span) {\n-                                // Only track if the block is in the form of `{}`, otherwise it is\n-                                // likely that it was written on purpose.\n-                                self.last_delim_empty_block_spans.insert(delim, empty_block_span);\n-                            }\n-                        }\n+        // Expand to cover the entire delimited token tree\n+        let delim_span = DelimSpan::from_pair(pre_span, self.token.span);\n \n-                        //only add braces\n-                        if let (Delimiter::Brace, Delimiter::Brace) = (open_brace, delim) {\n-                            self.matching_block_spans.push((open_brace_span, close_brace_span));\n-                        }\n+        match self.token.kind {\n+            // Correct delimiter.\n+            token::CloseDelim(d) if d == delim => {\n+                let (open_brace, open_brace_span) = self.open_braces.pop().unwrap();\n+                let close_brace_span = self.token.span;\n \n-                        if self.open_braces.is_empty() {\n-                            // Clear up these spans to avoid suggesting them as we've found\n-                            // properly matched delimiters so far for an entire block.\n-                            self.matching_delim_spans.clear();\n-                        } else {\n-                            self.matching_delim_spans.push((\n-                                open_brace,\n-                                open_brace_span,\n-                                close_brace_span,\n-                            ));\n-                        }\n-                        // Parse the closing delimiter.\n-                        self.bump();\n+                if tts.is_empty() {\n+                    let empty_block_span = open_brace_span.to(close_brace_span);\n+                    let sm = self.string_reader.sess.source_map();\n+                    if !sm.is_multiline(empty_block_span) {\n+                        // Only track if the block is in the form of `{}`, otherwise it is\n+                        // likely that it was written on purpose.\n+                        self.last_delim_empty_block_spans.insert(delim, empty_block_span);\n                     }\n-                    // Incorrect delimiter.\n-                    token::CloseDelim(other) => {\n-                        let mut unclosed_delimiter = None;\n-                        let mut candidate = None;\n+                }\n+\n+                //only add braces\n+                if let (Delimiter::Brace, Delimiter::Brace) = (open_brace, delim) {\n+                    self.matching_block_spans.push((open_brace_span, close_brace_span));\n+                }\n+\n+                if self.open_braces.is_empty() {\n+                    // Clear up these spans to avoid suggesting them as we've found\n+                    // properly matched delimiters so far for an entire block.\n+                    self.matching_delim_spans.clear();\n+                } else {\n+                    self.matching_delim_spans.push((open_brace, open_brace_span, close_brace_span));\n+                }\n+                // Parse the closing delimiter.\n+                self.bump();\n+            }\n+            // Incorrect delimiter.\n+            token::CloseDelim(other) => {\n+                let mut unclosed_delimiter = None;\n+                let mut candidate = None;\n \n-                        if self.last_unclosed_found_span != Some(self.token.span) {\n-                            // do not complain about the same unclosed delimiter multiple times\n-                            self.last_unclosed_found_span = Some(self.token.span);\n-                            // This is a conservative error: only report the last unclosed\n-                            // delimiter. The previous unclosed delimiters could actually be\n-                            // closed! The parser just hasn't gotten to them yet.\n-                            if let Some(&(_, sp)) = self.open_braces.last() {\n-                                unclosed_delimiter = Some(sp);\n-                            };\n-                            if let Some(current_padding) = sm.span_to_margin(self.token.span) {\n-                                for (brace, brace_span) in &self.open_braces {\n-                                    if let Some(padding) = sm.span_to_margin(*brace_span) {\n-                                        // high likelihood of these two corresponding\n-                                        if current_padding == padding && brace == &other {\n-                                            candidate = Some(*brace_span);\n-                                        }\n-                                    }\n+                if self.last_unclosed_found_span != Some(self.token.span) {\n+                    // do not complain about the same unclosed delimiter multiple times\n+                    self.last_unclosed_found_span = Some(self.token.span);\n+                    // This is a conservative error: only report the last unclosed\n+                    // delimiter. The previous unclosed delimiters could actually be\n+                    // closed! The parser just hasn't gotten to them yet.\n+                    if let Some(&(_, sp)) = self.open_braces.last() {\n+                        unclosed_delimiter = Some(sp);\n+                    };\n+                    let sm = self.string_reader.sess.source_map();\n+                    if let Some(current_padding) = sm.span_to_margin(self.token.span) {\n+                        for (brace, brace_span) in &self.open_braces {\n+                            if let Some(padding) = sm.span_to_margin(*brace_span) {\n+                                // high likelihood of these two corresponding\n+                                if current_padding == padding && brace == &other {\n+                                    candidate = Some(*brace_span);\n                                 }\n                             }\n-                            let (tok, _) = self.open_braces.pop().unwrap();\n-                            self.unmatched_braces.push(UnmatchedBrace {\n-                                expected_delim: tok,\n-                                found_delim: Some(other),\n-                                found_span: self.token.span,\n-                                unclosed_span: unclosed_delimiter,\n-                                candidate_span: candidate,\n-                            });\n-                        } else {\n-                            self.open_braces.pop();\n-                        }\n-\n-                        // If the incorrect delimiter matches an earlier opening\n-                        // delimiter, then don't consume it (it can be used to\n-                        // close the earlier one). Otherwise, consume it.\n-                        // E.g., we try to recover from:\n-                        // fn foo() {\n-                        //     bar(baz(\n-                        // }  // Incorrect delimiter but matches the earlier `{`\n-                        if !self.open_braces.iter().any(|&(b, _)| b == other) {\n-                            self.bump();\n                         }\n                     }\n-                    token::Eof => {\n-                        // Silently recover, the EOF token will be seen again\n-                        // and an error emitted then. Thus we don't pop from\n-                        // self.open_braces here.\n-                    }\n-                    _ => {}\n+                    let (tok, _) = self.open_braces.pop().unwrap();\n+                    self.unmatched_braces.push(UnmatchedBrace {\n+                        expected_delim: tok,\n+                        found_delim: Some(other),\n+                        found_span: self.token.span,\n+                        unclosed_span: unclosed_delimiter,\n+                        candidate_span: candidate,\n+                    });\n+                } else {\n+                    self.open_braces.pop();\n                 }\n \n-                Ok(TokenTree::Delimited(delim_span, delim, tts))\n+                // If the incorrect delimiter matches an earlier opening\n+                // delimiter, then don't consume it (it can be used to\n+                // close the earlier one). Otherwise, consume it.\n+                // E.g., we try to recover from:\n+                // fn foo() {\n+                //     bar(baz(\n+                // }  // Incorrect delimiter but matches the earlier `{`\n+                if !self.open_braces.iter().any(|&(b, _)| b == other) {\n+                    self.bump();\n+                }\n             }\n-            token::CloseDelim(delim) => {\n-                // An unexpected closing delimiter (i.e., there is no\n-                // matching opening delimiter).\n-                let token_str = token_to_string(&self.token);\n-                let msg = format!(\"unexpected closing delimiter: `{}`\", token_str);\n-                let mut err =\n-                    self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n+            token::Eof => {\n+                // Silently recover, the EOF token will be seen again\n+                // and an error emitted then. Thus we don't pop from\n+                // self.open_braces here.\n+            }\n+            _ => {}\n+        }\n \n-                // Braces are added at the end, so the last element is the biggest block\n-                if let Some(parent) = self.matching_block_spans.last() {\n-                    if let Some(span) = self.last_delim_empty_block_spans.remove(&delim) {\n-                        // Check if the (empty block) is in the last properly closed block\n-                        if (parent.0.to(parent.1)).contains(span) {\n-                            err.span_label(\n-                                span,\n-                                \"block is empty, you might have not meant to close it\",\n-                            );\n-                        } else {\n-                            err.span_label(parent.0, \"this opening brace...\");\n+        TokenTree::Delimited(delim_span, delim, tts)\n+    }\n \n-                            err.span_label(parent.1, \"...matches this closing brace\");\n-                        }\n-                    } else {\n-                        err.span_label(parent.0, \"this opening brace...\");\n+    fn close_delim_err(&mut self, delim: Delimiter) -> PErr<'a> {\n+        // An unexpected closing delimiter (i.e., there is no\n+        // matching opening delimiter).\n+        let token_str = token_to_string(&self.token);\n+        let msg = format!(\"unexpected closing delimiter: `{}`\", token_str);\n+        let mut err =\n+            self.string_reader.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n \n-                        err.span_label(parent.1, \"...matches this closing brace\");\n-                    }\n+        // Braces are added at the end, so the last element is the biggest block\n+        if let Some(parent) = self.matching_block_spans.last() {\n+            if let Some(span) = self.last_delim_empty_block_spans.remove(&delim) {\n+                // Check if the (empty block) is in the last properly closed block\n+                if (parent.0.to(parent.1)).contains(span) {\n+                    err.span_label(span, \"block is empty, you might have not meant to close it\");\n+                } else {\n+                    err.span_label(parent.0, \"this opening brace...\");\n+                    err.span_label(parent.1, \"...matches this closing brace\");\n                 }\n-\n-                err.span_label(self.token.span, \"unexpected closing delimiter\");\n-                Err(err)\n-            }\n-            _ => {\n-                let tok = self.token.take();\n-                let mut spacing = self.bump();\n-                if !self.token.is_op() {\n-                    spacing = Spacing::Alone;\n-                }\n-                Ok(TokenTree::Token(tok, spacing))\n+            } else {\n+                err.span_label(parent.0, \"this opening brace...\");\n+                err.span_label(parent.1, \"...matches this closing brace\");\n             }\n         }\n+\n+        err.span_label(self.token.span, \"unexpected closing delimiter\");\n+        err\n+    }\n+\n+    #[inline]\n+    fn parse_token_tree_other(&mut self) -> TokenTree {\n+        let tok = self.token.take();\n+        let mut spacing = self.bump();\n+        if !self.token.is_op() {\n+            spacing = Spacing::Alone;\n+        }\n+        TokenTree::Token(tok, spacing)\n     }\n \n     fn bump(&mut self) -> Spacing {"}]}