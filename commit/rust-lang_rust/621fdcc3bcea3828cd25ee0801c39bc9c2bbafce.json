{"sha": "621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMWZkY2MzYmNlYTM4MjhjZDI1ZWUwODAxYzM5YmM5YzJiYmFmY2U=", "commit": {"author": {"name": "Wim Looman", "email": "wim@nemo157.com", "date": "2018-05-31T18:15:48Z"}, "committer": {"name": "Wim Looman", "email": "wim.looman@kiwi.ki", "date": "2018-06-15T14:53:34Z"}, "message": "Dogfood new trivially_copy_pass_by_ref lint", "tree": {"sha": "0f47c91a85bfb686cf151683aa39d57f359e1862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0f47c91a85bfb686cf151683aa39d57f359e1862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "html_url": "https://github.com/rust-lang/rust/commit/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/comments", "author": {"login": "Nemo157", "id": 81079, "node_id": "MDQ6VXNlcjgxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/81079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nemo157", "html_url": "https://github.com/Nemo157", "followers_url": "https://api.github.com/users/Nemo157/followers", "following_url": "https://api.github.com/users/Nemo157/following{/other_user}", "gists_url": "https://api.github.com/users/Nemo157/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nemo157/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nemo157/subscriptions", "organizations_url": "https://api.github.com/users/Nemo157/orgs", "repos_url": "https://api.github.com/users/Nemo157/repos", "events_url": "https://api.github.com/users/Nemo157/events{/privacy}", "received_events_url": "https://api.github.com/users/Nemo157/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nemo157", "id": 81079, "node_id": "MDQ6VXNlcjgxMDc5", "avatar_url": "https://avatars.githubusercontent.com/u/81079?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nemo157", "html_url": "https://github.com/Nemo157", "followers_url": "https://api.github.com/users/Nemo157/followers", "following_url": "https://api.github.com/users/Nemo157/following{/other_user}", "gists_url": "https://api.github.com/users/Nemo157/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nemo157/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nemo157/subscriptions", "organizations_url": "https://api.github.com/users/Nemo157/orgs", "repos_url": "https://api.github.com/users/Nemo157/repos", "events_url": "https://api.github.com/users/Nemo157/events{/privacy}", "received_events_url": "https://api.github.com/users/Nemo157/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "700ece5648a61516f0ed883cb2876363e3caedbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/700ece5648a61516f0ed883cb2876363e3caedbc", "html_url": "https://github.com/rust-lang/rust/commit/700ece5648a61516f0ed883cb2876363e3caedbc"}], "stats": {"total": 182, "additions": 91, "deletions": 91}, "files": [{"sha": "d3741d7880128b652f67985f35c6a102b69463fc", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -71,14 +71,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n-        LitKind::Float(ref s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n-        LitKind::Float(ref s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n-        LitKind::FloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        LitKind::Float(s, FloatTy::F32) => check_known_consts(cx, e, s, \"f32\"),\n+        LitKind::Float(s, FloatTy::F64) => check_known_consts(cx, e, s, \"f64\"),\n+        LitKind::FloatUnsuffixed(s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n         _ => (),\n     }\n }\n \n-fn check_known_consts(cx: &LateContext, e: &Expr, s: &symbol::Symbol, module: &str) {\n+fn check_known_consts(cx: &LateContext, e: &Expr, s: symbol::Symbol, module: &str) {\n     let s = s.as_str();\n     if s.parse::<f64>().is_ok() {\n         for &(constant, name, min_digits) in KNOWN_CONSTS {"}, {"sha": "46ec02a3473e20241bdb344b5640c3f190be4c47", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if is_relevant_item(cx.tcx, item) {\n-            check_attrs(cx, item.span, &item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n         match item.node {\n             ItemExternCrate(_) | ItemUse(_, _) => {\n@@ -195,13 +195,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if is_relevant_impl(cx.tcx, item) {\n-            check_attrs(cx, item.span, &item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if is_relevant_trait(cx.tcx, item) {\n-            check_attrs(cx, item.span, &item.name, &item.attrs)\n+            check_attrs(cx, item.span, item.name, &item.attrs)\n         }\n     }\n }\n@@ -260,7 +260,7 @@ fn is_relevant_expr(tcx: TyCtxt, tables: &ty::TypeckTables, expr: &Expr) -> bool\n     }\n }\n \n-fn check_attrs(cx: &LateContext, span: Span, name: &Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext, span: Span, name: Name, attrs: &[Attribute]) {\n     if in_macro(span) {\n         return;\n     }"}, {"sha": "9f548b9e32088bfedf8b334601ff10c409a11bcc", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -112,9 +112,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n-                    check_compare(cx, left, cmp.node, cmp_opt, &e.span)\n+                    check_compare(cx, left, cmp.node, cmp_opt, e.span)\n                 } else if let Some(cmp_val) = fetch_int_literal(cx, left) {\n-                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, &e.span)\n+                    check_compare(cx, right, invert_cmp(cmp.node), cmp_val, e.span)\n                 }\n             }\n         }\n@@ -156,7 +156,7 @@ fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: &Span) {\n+fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: Span) {\n     if let ExprBinary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BiBitAnd && op.node != BiBitOr {\n             return;\n@@ -167,15 +167,15 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u12\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: &Span) {\n+fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: Span) {\n     match cmp_op {\n         BiEq | BiNe => match bit_op {\n             BiBitAnd => if mask_value & cmp_value != cmp_value {\n                 if cmp_value != 0 {\n                     span_lint(\n                         cx,\n                         BAD_BIT_MASK,\n-                        *span,\n+                        span,\n                         &format!(\n                             \"incompatible bit mask: `_ & {}` can never be equal to `{}`\",\n                             mask_value,\n@@ -184,13 +184,13 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                     );\n                 }\n             } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n             BiBitOr => if mask_value | cmp_value != cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ | {}` can never be equal to `{}`\",\n                         mask_value,\n@@ -205,63 +205,63 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ & {}` will always be lower than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n             BiBitOr => if mask_value >= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ | {}` will never be lower than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else {\n-                check_ineffective_lt(cx, *span, mask_value, cmp_value, \"|\");\n+                check_ineffective_lt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_lt(cx, *span, mask_value, cmp_value, \"^\"),\n+            BiBitXor => check_ineffective_lt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         BiLe | BiGt => match bit_op {\n             BiBitAnd => if mask_value <= cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ & {}` will never be higher than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else if mask_value == 0 {\n-                span_lint(cx, BAD_BIT_MASK, *span, \"&-masking with zero\");\n+                span_lint(cx, BAD_BIT_MASK, span, \"&-masking with zero\");\n             },\n             BiBitOr => if mask_value > cmp_value {\n                 span_lint(\n                     cx,\n                     BAD_BIT_MASK,\n-                    *span,\n+                    span,\n                     &format!(\n                         \"incompatible bit mask: `_ | {}` will always be higher than `{}`\",\n                         mask_value,\n                         cmp_value\n                     ),\n                 );\n             } else {\n-                check_ineffective_gt(cx, *span, mask_value, cmp_value, \"|\");\n+                check_ineffective_gt(cx, span, mask_value, cmp_value, \"|\");\n             },\n-            BiBitXor => check_ineffective_gt(cx, *span, mask_value, cmp_value, \"^\"),\n+            BiBitXor => check_ineffective_gt(cx, span, mask_value, cmp_value, \"^\"),\n             _ => (),\n         },\n         _ => (),"}, {"sha": "19761fbe8649de34880fdf5a03f5ad33c4884633", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -52,7 +52,7 @@ impl LintPass for EqOp {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n-        if let ExprBinary(ref op, ref left, ref right) = e.node {\n+        if let ExprBinary(op, ref left, ref right) = e.node {\n             if in_macro(e.span) {\n                 return;\n             }\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n }\n \n \n-fn is_valid_operator(op: &BinOp) -> bool {\n+fn is_valid_operator(op: BinOp) -> bool {\n     match op.node {\n         BiSub | BiDiv | BiEq | BiLt | BiLe | BiGt | BiGe | BiNe | BiAnd | BiOr | BiBitXor | BiBitAnd | BiBitOr => true,\n         _ => false,"}, {"sha": "c33a3b50185feb30f10d8193f423b1d55eac9ff6", "filename": "clippy_lints/src/excessive_precision.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fexcessive_precision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexcessive_precision.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -46,9 +46,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if_chain! {\n             let ty = cx.tables.expr_ty(expr);\n-            if let TypeVariants::TyFloat(ref fty) = ty.sty;\n+            if let TypeVariants::TyFloat(fty) = ty.sty;\n             if let hir::ExprLit(ref lit) = expr.node;\n-            if let LitKind::Float(ref sym, _) | LitKind::FloatUnsuffixed(ref sym) = lit.node;\n+            if let LitKind::Float(sym, _) | LitKind::FloatUnsuffixed(sym) = lit.node;\n             if let Some(sugg) = self.check(sym, fty);\n             then {\n                 span_lint_and_sugg(\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExcessivePrecision {\n \n impl ExcessivePrecision {\n     // None if nothing to lint, Some(suggestion) if lint neccessary\n-    fn check(&self, sym: &Symbol, fty: &FloatTy) -> Option<String> {\n+    fn check(&self, sym: Symbol, fty: FloatTy) -> Option<String> {\n         let max = max_digits(fty);\n         let sym_str = sym.as_str();\n         if dot_zero_exclusion(&sym_str) {\n@@ -79,7 +79,7 @@ impl ExcessivePrecision {\n         let digits = count_digits(&sym_str);\n         if digits > max as usize {\n             let formatter = FloatFormat::new(&sym_str);\n-            let sr = match *fty {\n+            let sr = match fty {\n                 FloatTy::F32 => sym_str.parse::<f32>().map(|f| formatter.format(f)),\n                 FloatTy::F64 => sym_str.parse::<f64>().map(|f| formatter.format(f)),\n             };\n@@ -115,7 +115,7 @@ fn dot_zero_exclusion(s: &str) -> bool {\n     }\n }\n \n-fn max_digits(fty: &FloatTy) -> u32 {\n+fn max_digits(fty: FloatTy) -> u32 {\n     match fty {\n         FloatTy::F32 => f32::DIGITS,\n         FloatTy::F64 => f64::DIGITS,"}, {"sha": "904d0b1d245463937bc2c5c18a94b16f9c0ce12d", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n }\n \n impl<'a, 'tcx> Functions {\n-    fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n+    fn check_arg_number(self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n             span_lint(\n@@ -139,7 +139,7 @@ impl<'a, 'tcx> Functions {\n     }\n \n     fn check_raw_ptr(\n-        &self,\n+        self,\n         cx: &LateContext<'a, 'tcx>,\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,"}, {"sha": "1325ad66857b5360ee687dbb21453757bfb6855a", "filename": "clippy_lints/src/inline_fn_without_body.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Finline_fn_without_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finline_fn_without_body.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -38,12 +38,12 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let TraitItemKind::Method(_, TraitMethod::Required(_)) = item.node {\n-            check_attrs(cx, &item.name, &item.attrs);\n+            check_attrs(cx, item.name, &item.attrs);\n         }\n     }\n }\n \n-fn check_attrs(cx: &LateContext, name: &Name, attrs: &[Attribute]) {\n+fn check_attrs(cx: &LateContext, name: Name, attrs: &[Attribute]) {\n     for attr in attrs {\n         if attr.name() != \"inline\" {\n             continue;"}, {"sha": "09b66b872e9167d9ca97b9c682bcc304751fa813", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -227,36 +227,36 @@ enum WarningType {\n }\n \n impl WarningType {\n-    pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: &syntax_pos::Span) {\n-        match *self {\n+    pub fn display(&self, grouping_hint: &str, cx: &EarlyContext, span: syntax_pos::Span) {\n+        match self {\n             WarningType::UnreadableLiteral => span_lint_and_sugg(\n                 cx,\n                 UNREADABLE_LITERAL,\n-                *span,\n+                span,\n                 \"long literal lacking separators\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n             ),\n             WarningType::LargeDigitGroups => span_lint_and_sugg(\n                 cx,\n                 LARGE_DIGIT_GROUPS,\n-                *span,\n+                span,\n                 \"digit groups should be smaller\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n             ),\n             WarningType::InconsistentDigitGrouping => span_lint_and_sugg(\n                 cx,\n                 INCONSISTENT_DIGIT_GROUPING,\n-                *span,\n+                span,\n                 \"digits grouped inconsistently by underscores\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n             ),\n             WarningType::DecimalRepresentation => span_lint_and_sugg(\n                 cx,\n                 DECIMAL_LITERAL_REPRESENTATION,\n-                *span,\n+                span,\n                 \"integer literal has a better hexadecimal representation\",\n                 \"consider\",\n                 grouping_hint.to_owned(),\n@@ -291,7 +291,7 @@ impl EarlyLintPass for LiteralDigitGrouping {\n }\n \n impl LiteralDigitGrouping {\n-    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n         match lit.node {\n             LitKind::Int(..) => {\n                 // Lint integral literals.\n@@ -302,7 +302,7 @@ impl LiteralDigitGrouping {\n                     then {\n                         let digit_info = DigitInfo::new(&src, false);\n                         let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n-                            warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n+                            warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n                         });\n                     }\n                 }\n@@ -337,15 +337,15 @@ impl LiteralDigitGrouping {\n                                             if !consistent {\n                                                 WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(),\n                                                 cx,\n-                                                &lit.span);\n+                                                lit.span);\n                                             }\n                                         })\n                                     .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n                                     cx,\n-                                    &lit.span));\n+                                    lit.span));\n                                 }\n                             })\n-                        .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n+                        .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, lit.span));\n                     }\n                 }\n             },\n@@ -436,7 +436,7 @@ impl LiteralRepresentation {\n             threshold,\n         }\n     }\n-    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n         // Lint integral literals.\n         if_chain! {\n             if let LitKind::Int(..) = lit.node;\n@@ -457,7 +457,7 @@ impl LiteralRepresentation {\n                     let hex = format!(\"{:#X}\", val);\n                     let digit_info = DigitInfo::new(&hex[..], false);\n                     let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n-                        warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n+                        warning_type.display(&digit_info.grouping_hint(), cx, lit.span)\n                     });\n                 }\n             }"}, {"sha": "cfea6053fac9a38b611b0a4f7863a57490ee37e5", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -412,7 +412,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         // check for never_loop\n         match expr.node {\n             ExprWhile(_, ref block, _) | ExprLoop(ref block, _, _) => {\n-                match never_loop_block(block, &expr.id) {\n+                match never_loop_block(block, expr.id) {\n                     NeverLoopResult::AlwaysBreak =>\n                         span_lint(cx, NEVER_LOOP, expr.span, \"this loop never actually loops\"),\n                     NeverLoopResult::MayContinueMainLoop | NeverLoopResult::Otherwise => (),\n@@ -575,7 +575,7 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_block(block: &Block, main_loop_id: NodeId) -> NeverLoopResult {\n     let stmts = block.stmts.iter().map(stmt_to_expr);\n     let expr = once(block.expr.as_ref().map(|p| &**p));\n     let mut iter = stmts.chain(expr).filter_map(|e| e);\n@@ -596,7 +596,7 @@ fn decl_to_expr(decl: &Decl) -> Option<&Expr> {\n     }\n }\n \n-fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr(expr: &Expr, main_loop_id: NodeId) -> NeverLoopResult {\n     match expr.node {\n         ExprBox(ref e) |\n         ExprUnary(_, ref e) |\n@@ -643,7 +643,7 @@ fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n         ExprAgain(d) => {\n             let id = d.target_id\n                 .expect(\"target id can only be missing in the presence of compilation errors\");\n-            if id == *main_loop_id {\n+            if id == main_loop_id {\n                 NeverLoopResult::MayContinueMainLoop\n             } else {\n                 NeverLoopResult::AlwaysBreak\n@@ -668,17 +668,17 @@ fn never_loop_expr(expr: &Expr, main_loop_id: &NodeId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr_seq<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr_all<'a, T: Iterator<Item=&'a Expr>>(es: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     es.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, main_loop_id: &NodeId) -> NeverLoopResult {\n+fn never_loop_expr_branch<'a, T: Iterator<Item=&'a Expr>>(e: &mut T, main_loop_id: NodeId) -> NeverLoopResult {\n     e.map(|e| never_loop_expr(e, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n@@ -1032,7 +1032,7 @@ fn check_for_loop_range<'a, 'tcx>(\n                 };\n \n                 let take = if let Some(end) = *end {\n-                    if is_len_call(end, &indexed) {\n+                    if is_len_call(end, indexed) {\n                         \"\".to_owned()\n                     } else {\n                         match limits {\n@@ -1096,14 +1096,14 @@ fn check_for_loop_range<'a, 'tcx>(\n     }\n }\n \n-fn is_len_call(expr: &Expr, var: &Name) -> bool {\n+fn is_len_call(expr: &Expr, var: Name) -> bool {\n     if_chain! {\n         if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n         if len_args.len() == 1;\n         if method.name == \"len\";\n         if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n         if path.segments.len() == 1;\n-        if path.segments[0].name == *var;\n+        if path.segments[0].name == var;\n         then {\n             return true;\n         }"}, {"sha": "6d93e5bbd095d51f88e6f840d7041f8fd42505af", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -2079,8 +2079,8 @@ impl SelfKind {\n         }\n     }\n \n-    fn description(&self) -> &'static str {\n-        match *self {\n+    fn description(self) -> &'static str {\n+        match self {\n             SelfKind::Value => \"self by value\",\n             SelfKind::Ref => \"self by reference\",\n             SelfKind::RefMut => \"self by mutable reference\",\n@@ -2164,13 +2164,13 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(&self, ty: &hir::FunctionRetTy) -> bool {\n+    fn matches(self, ty: &hir::FunctionRetTy) -> bool {\n         match (self, ty) {\n-            (&OutType::Unit, &hir::DefaultReturn(_)) => true,\n-            (&OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n-            (&OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n-            (&OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n-            (&OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n+            (OutType::Unit, &hir::DefaultReturn(_)) => true,\n+            (OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n+            (OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n+            (OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n+            (OutType::Ref, &hir::Return(ref ty)) => matches!(ty.node, hir::TyRptr(_, _)),\n             _ => false,\n         }\n     }"}, {"sha": "fcd88f9f21906cf21ae3e3418ffc684750238bf3", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -349,7 +349,7 @@ impl EarlyLintPass for MiscEarly {\n }\n \n impl MiscEarly {\n-    fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n+    fn check_lit(self, cx: &EarlyContext, lit: &Lit) {\n         if_chain! {\n             if let LitKind::Int(value, ..) = lit.node;\n             if let Some(src) = snippet_opt(cx, lit.span);"}, {"sha": "e3ccfec46857f597beb5608ed08ff321830154ed", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             if let Some(impl_trait) = check_binop(\n                 cx,\n                 expr,\n-                &binop.node,\n+                binop.node,\n                 &[\"Add\", \"Sub\", \"Mul\", \"Div\"],\n                 &[BiAdd, BiSub, BiMul, BiDiv],\n             ) {\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n             if let Some(impl_trait) = check_binop(\n                 cx,\n                 expr,\n-                &binop.node,\n+                binop.node,\n                 &[\n                     \"AddAssign\",\n                     \"SubAssign\",\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for SuspiciousImpl {\n fn check_binop<'a>(\n     cx: &LateContext,\n     expr: &hir::Expr,\n-    binop: &hir::BinOp_,\n+    binop: hir::BinOp_,\n     traits: &[&'a str],\n     expected_ops: &[hir::BinOp_],\n ) -> Option<&'a str> {\n@@ -169,7 +169,7 @@ fn check_binop<'a>(\n         if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n         if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n         if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.def.def_id());\n-        if *binop != expected_ops[idx];\n+        if binop != expected_ops[idx];\n         then{\n             return Some(traits[idx])\n         }"}, {"sha": "0888aef89feea3068bf06da4962b715039c02fbb", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -1606,12 +1606,12 @@ fn node_as_const_fullint<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr)\n     }\n }\n \n-fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: bool) {\n+fn err_upcast_comparison(cx: &LateContext, span: Span, expr: &Expr, always: bool) {\n     if let ExprCast(ref cast_val, _) = expr.node {\n         span_lint(\n             cx,\n             INVALID_UPCAST_COMPARISONS,\n-            *span,\n+            span,\n             &format!(\n                 \"because of the numeric bounds on `{}` prior to casting, this expression is always {}\",\n                 snippet(cx, cast_val.span, \"the expression\"),\n@@ -1623,7 +1623,7 @@ fn err_upcast_comparison(cx: &LateContext, span: &Span, expr: &Expr, always: boo\n \n fn upcast_comparison_bounds_err<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n-    span: &Span,\n+    span: Span,\n     rel: comparisons::Rel,\n     lhs_bounds: Option<(FullInt, FullInt)>,\n     lhs: &'tcx Expr,\n@@ -1684,8 +1684,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n             let lhs_bounds = numeric_cast_precast_bounds(cx, normalized_lhs);\n             let rhs_bounds = numeric_cast_precast_bounds(cx, normalized_rhs);\n \n-            upcast_comparison_bounds_err(cx, &expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n-            upcast_comparison_bounds_err(cx, &expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, lhs_bounds, normalized_lhs, normalized_rhs, false);\n+            upcast_comparison_bounds_err(cx, expr.span, rel, rhs_bounds, normalized_rhs, normalized_lhs, true);\n         }\n     }\n }"}, {"sha": "56a8377d7dd82e0093e7c427f68f8fabd2f04e2e", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -36,12 +36,12 @@ impl LintPass for UnsafeNameRemoval {\n impl EarlyLintPass for UnsafeNameRemoval {\n     fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n         if let ItemKind::Use(ref use_tree) = item.node {\n-            check_use_tree(use_tree, cx, &item.span);\n+            check_use_tree(use_tree, cx, item.span);\n         }\n     }\n }\n \n-fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: &Span) {\n+fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: Span) {\n     match use_tree.kind {\n         UseTreeKind::Simple(Some(new_name)) => {\n             let old_name = use_tree\n@@ -62,14 +62,14 @@ fn check_use_tree(use_tree: &UseTree, cx: &EarlyContext, span: &Span) {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: &Span) {\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: Span) {\n     let old_str = old_name.name.as_str();\n     let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n         span_lint(\n             cx,\n             UNSAFE_REMOVED_FROM_NAME,\n-            *span,\n+            span,\n             &format!(\"removed \\\"unsafe\\\" from the name of `{}` in use as `{}`\", old_str, new_str),\n         );\n     }"}, {"sha": "ddac8bd3835e83d02c8fa404f1b4b745a8c243ae", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/621fdcc3bcea3828cd25ee0801c39bc9c2bbafce/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=621fdcc3bcea3828cd25ee0801c39bc9c2bbafce", "patch": "@@ -349,7 +349,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(i.name);\n                 }\n             },\n             ExprYield(ref e) => {\n@@ -386,7 +386,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i.label {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(i.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n@@ -419,7 +419,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprField;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n-                self.hash_name(&f.name);\n+                self.hash_name(f.name);\n             },\n             ExprIndex(ref a, ref i) => {\n                 let c: fn(_, _) -> _ = ExprIndex;\n@@ -450,7 +450,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n-                    self.hash_name(&i.name);\n+                    self.hash_name(i.name);\n                 }\n             },\n             ExprMatch(ref e, ref arms, ref s) => {\n@@ -471,7 +471,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n             ExprMethodCall(ref path, ref _tys, ref args) => {\n                 let c: fn(_, _, _) -> _ = ExprMethodCall;\n                 c.hash(&mut self.s);\n-                self.hash_name(&path.name);\n+                self.hash_name(path.name);\n                 self.hash_exprs(args);\n             },\n             ExprRepeat(ref e, ref l_id) => {\n@@ -502,7 +502,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_qpath(path);\n \n                 for f in fields {\n-                    self.hash_name(&f.ident.name);\n+                    self.hash_name(f.ident.name);\n                     self.hash_expr(&f.expr);\n                 }\n \n@@ -541,7 +541,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(cond);\n                 self.hash_block(b);\n                 if let Some(l) = l {\n-                    self.hash_name(&l.name);\n+                    self.hash_name(l.name);\n                 }\n             },\n         }\n@@ -553,7 +553,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         }\n     }\n \n-    pub fn hash_name(&mut self, n: &Name) {\n+    pub fn hash_name(&mut self, n: Name) {\n         n.as_str().hash(&mut self.s);\n     }\n \n@@ -563,7 +563,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_path(path);\n             },\n             QPath::TypeRelative(_, ref path) => {\n-                self.hash_name(&path.name);\n+                self.hash_name(path.name);\n             },\n         }\n         // self.cx.tables.qpath_def(p, id).hash(&mut self.s);\n@@ -572,7 +572,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     pub fn hash_path(&mut self, p: &Path) {\n         p.is_global().hash(&mut self.s);\n         for p in &p.segments {\n-            self.hash_name(&p.name);\n+            self.hash_name(p.name);\n         }\n     }\n "}]}