{"sha": "8a74d3357079e5edf2454f6523a9c93081e7348e", "node_id": "C_kwDOAAsO6NoAKDhhNzRkMzM1NzA3OWU1ZWRmMjQ1NGY2NTIzYTljOTMwODFlNzM0OGU", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-27T03:47:09Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:24Z"}, "message": "Add `explicit_auto_deref` lint", "tree": {"sha": "b0326a6afe25c207803c567f45810598de86fb11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0326a6afe25c207803c567f45810598de86fb11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a74d3357079e5edf2454f6523a9c93081e7348e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a74d3357079e5edf2454f6523a9c93081e7348e", "html_url": "https://github.com/rust-lang/rust/commit/8a74d3357079e5edf2454f6523a9c93081e7348e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a74d3357079e5edf2454f6523a9c93081e7348e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c107c97e69850a4da3ed3008591281fff7d611d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c107c97e69850a4da3ed3008591281fff7d611d3", "html_url": "https://github.com/rust-lang/rust/commit/c107c97e69850a4da3ed3008591281fff7d611d3"}], "stats": {"total": 1007, "additions": 954, "deletions": 53}, "files": [{"sha": "9bc93c1cb42c91ad045e77c9a5c88f83abdf095b", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -3400,6 +3400,7 @@ Released 2018-09-13\n [`expect_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_fun_call\n [`expect_used`]: https://rust-lang.github.io/rust-clippy/master/index.html#expect_used\n [`expl_impl_clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#expl_impl_clone_on_copy\n+[`explicit_auto_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_auto_deref\n [`explicit_counter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_counter_loop\n [`explicit_deref_methods`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_deref_methods\n [`explicit_into_iter_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#explicit_into_iter_loop"}, {"sha": "77518933a230f3fbcbf12c190af69afbdf89d4c7", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 303, "deletions": 6, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -1,18 +1,21 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_hir_and_then};\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::has_enclosing_paren;\n-use clippy_utils::ty::peel_mid_ty_refs;\n-use clippy_utils::{get_parent_expr, get_parent_node, is_lint_allowed, path_to_local};\n+use clippy_utils::ty::{expr_sig, peel_mid_ty_refs, variant_of_res};\n+use clippy_utils::{\n+    get_parent_expr, get_parent_node, is_lint_allowed, path_to_local, peel_hir_ty_refs, walk_to_expr_usage,\n+};\n use rustc_ast::util::parser::{PREC_POSTFIX, PREC_PREFIX};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir::{\n-    BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, HirId, MatchSource, Mutability, Node,\n-    Pat, PatKind, UnOp,\n+    self as hir, BindingAnnotation, Body, BodyId, BorrowKind, Destination, Expr, ExprKind, FnRetTy, GenericArg, HirId,\n+    ImplItem, ImplItemKind, Item, ItemKind, Local, MatchSource, Mutability, Node, Pat, PatKind, Path, QPath, TraitItem,\n+    TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n-use rustc_middle::ty::{self, Ty, TyCtxt, TypeckResults};\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{symbol::sym, Span};\n \n@@ -104,10 +107,34 @@ declare_clippy_lint! {\n     \"`ref` binding to a reference\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for dereferencing expressions which would be covered by auto-deref.\n+    ///\n+    /// ### Why is this bad?\n+    /// This unnecessarily complicates the code.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = String::new();\n+    /// let y: &str = &*x;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = String::new();\n+    /// let y: &str = &x;\n+    /// ```\n+    #[clippy::version = \"1.60.0\"]\n+    pub EXPLICIT_AUTO_DEREF,\n+    complexity,\n+    \"dereferencing when the compiler would automatically dereference\"\n+}\n+\n impl_lint_pass!(Dereferencing => [\n     EXPLICIT_DEREF_METHODS,\n     NEEDLESS_BORROW,\n     REF_BINDING_TO_REFERENCE,\n+    EXPLICIT_AUTO_DEREF,\n ]);\n \n #[derive(Default)]\n@@ -152,6 +179,11 @@ enum State {\n         required_precedence: i8,\n         msg: &'static str,\n     },\n+    ExplicitDeref {\n+        deref_span: Span,\n+        deref_hir_id: HirId,\n+    },\n+    Borrow,\n }\n \n // A reference operation considered by this lint pass\n@@ -305,6 +337,14 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                                     hir_id: expr.hir_id,\n                                 },\n                             ));\n+                        } else if is_stable_auto_deref_position(cx, expr) {\n+                            self.state = Some((\n+                                State::Borrow,\n+                                StateData {\n+                                    span: expr.span,\n+                                    hir_id: expr.hir_id,\n+                                },\n+                            ));\n                         }\n                     },\n                     _ => (),\n@@ -354,6 +394,18 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                     data,\n                 ));\n             },\n+            (Some((State::Borrow, data)), RefOp::Deref) => {\n+                self.state = Some((\n+                    State::ExplicitDeref {\n+                        deref_span: expr.span,\n+                        deref_hir_id: expr.hir_id,\n+                    },\n+                    data,\n+                ));\n+            },\n+            (state @ Some((State::ExplicitDeref { .. }, _)), RefOp::Deref) => {\n+                self.state = state;\n+            },\n \n             (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n@@ -596,8 +648,230 @@ fn find_adjustments<'tcx>(\n     }\n }\n \n+// Checks if the expression for the given id occurs in a position which auto dereferencing applies.\n+// Note that the target type must not be inferred in a way that may cause auto-deref to select a\n+// different type, nor may the position be the result of a macro expansion.\n+//\n+// e.g. the following should not linted\n+// macro_rules! foo { ($e:expr) => { let x: &str = $e; }}\n+// foo!(&*String::new());\n+// fn foo<T>(_: &T) {}\n+// foo(&*String::new())\n+fn is_stable_auto_deref_position<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n+    walk_to_expr_usage(cx, e, |node, child_id| match node {\n+        Node::Local(&Local { ty: Some(ty), .. }) => Some(is_binding_ty_auto_deref_stable(ty)),\n+        Node::Item(&Item {\n+            kind: ItemKind::Static(..) | ItemKind::Const(..),\n+            ..\n+        })\n+        | Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Const(..),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Const(..),\n+            ..\n+        }) => Some(true),\n+\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(..),\n+            def_id,\n+            ..\n+        })\n+        | Node::TraitItem(&TraitItem {\n+            kind: TraitItemKind::Fn(..),\n+            def_id,\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(..),\n+            def_id,\n+            ..\n+        }) => {\n+            let output = cx.tcx.fn_sig(def_id.to_def_id()).skip_binder().output();\n+            Some(!(output.has_placeholders() || output.has_opaque_types()))\n+        },\n+\n+        Node::Expr(e) => match e.kind {\n+            ExprKind::Ret(_) => {\n+                let output = cx\n+                    .tcx\n+                    .fn_sig(cx.tcx.hir().body_owner_def_id(cx.enclosing_body.unwrap()))\n+                    .skip_binder()\n+                    .output();\n+                Some(!(output.has_placeholders() || output.has_opaque_types()))\n+            },\n+            ExprKind::Call(func, args) => Some(\n+                args.iter()\n+                    .position(|arg| arg.hir_id == child_id)\n+                    .zip(expr_sig(cx, func))\n+                    .and_then(|(i, sig)| sig.input_with_hir(i))\n+                    .map_or(false, |(hir_ty, ty)| match hir_ty {\n+                        // Type inference for closures can depend on how they're called. Only go by the explicit\n+                        // types here.\n+                        Some(ty) => is_binding_ty_auto_deref_stable(ty),\n+                        None => is_param_auto_deref_stable(ty.skip_binder()),\n+                    }),\n+            ),\n+            ExprKind::MethodCall(_, [_, args @ ..], _) => {\n+                let id = cx.typeck_results().type_dependent_def_id(e.hir_id).unwrap();\n+                Some(args.iter().position(|arg| arg.hir_id == child_id).map_or(false, |i| {\n+                    let arg = cx.tcx.fn_sig(id).skip_binder().inputs()[i + 1];\n+                    is_param_auto_deref_stable(arg)\n+                }))\n+            },\n+            ExprKind::Struct(path, fields, _) => {\n+                let variant = variant_of_res(cx, cx.qpath_res(path, e.hir_id));\n+                Some(\n+                    fields\n+                        .iter()\n+                        .find(|f| f.expr.hir_id == child_id)\n+                        .zip(variant)\n+                        .and_then(|(field, variant)| variant.fields.iter().find(|f| f.name == field.ident.name))\n+                        .map_or(false, |field| is_param_auto_deref_stable(cx.tcx.type_of(field.did))),\n+                )\n+            },\n+            _ => None,\n+        },\n+        _ => None,\n+    })\n+    .unwrap_or(false)\n+}\n+\n+// Checks whether auto-dereferencing any type into a binding of the given type will definitely\n+// produce the same result.\n+//\n+// e.g.\n+// let x = Box::new(Box::new(0u32));\n+// let y1: &Box<_> = x.deref();\n+// let y2: &Box<_> = &x;\n+//\n+// Here `y1` and `y2` would resolve to different types, so the type `&Box<_>` is not stable when\n+// switching to auto-dereferencing.\n+fn is_binding_ty_auto_deref_stable(ty: &hir::Ty<'_>) -> bool {\n+    let (ty, count) = peel_hir_ty_refs(ty);\n+    if count != 1 {\n+        return false;\n+    }\n+\n+    match &ty.kind {\n+        TyKind::Rptr(_, ty) => is_binding_ty_auto_deref_stable(ty.ty),\n+        &TyKind::Path(\n+            QPath::TypeRelative(_, path)\n+            | QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: [.., path], ..\n+                },\n+            ),\n+        ) => {\n+            if let Some(args) = path.args {\n+                args.args.iter().all(|arg| {\n+                    if let GenericArg::Type(ty) = arg {\n+                        !ty_contains_infer(ty)\n+                    } else {\n+                        true\n+                    }\n+                })\n+            } else {\n+                true\n+            }\n+        },\n+        TyKind::Slice(_)\n+        | TyKind::Array(..)\n+        | TyKind::BareFn(_)\n+        | TyKind::Never\n+        | TyKind::Tup(_)\n+        | TyKind::Ptr(_)\n+        | TyKind::TraitObject(..)\n+        | TyKind::Path(_) => true,\n+        TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::Err => false,\n+    }\n+}\n+\n+// Checks whether a type is inferred at some point.\n+// e.g. `_`, `Box<_>`, `[_]`\n+fn ty_contains_infer(ty: &hir::Ty<'_>) -> bool {\n+    match &ty.kind {\n+        TyKind::Slice(ty) | TyKind::Array(ty, _) => ty_contains_infer(ty),\n+        TyKind::Ptr(ty) | TyKind::Rptr(_, ty) => ty_contains_infer(ty.ty),\n+        TyKind::Tup(tys) => tys.iter().any(ty_contains_infer),\n+        TyKind::BareFn(ty) => {\n+            if ty.decl.inputs.iter().any(ty_contains_infer) {\n+                return true;\n+            }\n+            if let FnRetTy::Return(ty) = &ty.decl.output {\n+                ty_contains_infer(ty)\n+            } else {\n+                false\n+            }\n+        },\n+        &TyKind::Path(\n+            QPath::TypeRelative(_, path)\n+            | QPath::Resolved(\n+                _,\n+                Path {\n+                    segments: [.., path], ..\n+                },\n+            ),\n+        ) => {\n+            if let Some(args) = path.args {\n+                args.args.iter().any(|arg| {\n+                    if let GenericArg::Type(ty) = arg {\n+                        ty_contains_infer(ty)\n+                    } else {\n+                        false\n+                    }\n+                })\n+            } else {\n+                false\n+            }\n+        },\n+        TyKind::Path(_) | TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(_) | TyKind::Err => true,\n+        TyKind::Never | TyKind::TraitObject(..) => false,\n+    }\n+}\n+\n+// Checks whether a type is stable when switching to auto dereferencing,\n+fn is_param_auto_deref_stable(ty: Ty<'_>) -> bool {\n+    let (ty, count) = peel_mid_ty_refs(ty);\n+    if count != 1 {\n+        return false;\n+    }\n+\n+    match ty.kind() {\n+        ty::Bool\n+        | ty::Char\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Foreign(_)\n+        | ty::Str\n+        | ty::Array(..)\n+        | ty::Slice(..)\n+        | ty::RawPtr(..)\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Closure(..)\n+        | ty::Generator(..)\n+        | ty::GeneratorWitness(..)\n+        | ty::Never\n+        | ty::Tuple(_)\n+        | ty::Ref(..)\n+        | ty::Projection(_) => true,\n+        ty::Infer(_)\n+        | ty::Error(_)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Opaque(..)\n+        | ty::Placeholder(_)\n+        | ty::Dynamic(..) => false,\n+        ty::Adt(..) => !(ty.has_placeholders() || ty.has_param_types_or_consts()),\n+    }\n+}\n+\n #[expect(clippy::needless_pass_by_value)]\n-fn report<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, state: State, data: StateData) {\n+fn report<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n     match state {\n         State::DerefMethod {\n             ty_changed_count,\n@@ -663,6 +937,29 @@ fn report<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, state: State, data: S\n                 diag.span_suggestion(data.span, \"change this to\", sugg, app);\n             });\n         },\n+        State::ExplicitDeref {\n+            deref_span,\n+            deref_hir_id,\n+        } => {\n+            let (span, hir_id) = if cx.typeck_results().expr_ty(expr).is_ref() {\n+                (data.span, data.hir_id)\n+            } else {\n+                (deref_span, deref_hir_id)\n+            };\n+            span_lint_hir_and_then(\n+                cx,\n+                EXPLICIT_AUTO_DEREF,\n+                hir_id,\n+                span,\n+                \"deref which would be done by auto-deref\",\n+                |diag| {\n+                    let mut app = Applicability::MachineApplicable;\n+                    let snip = snippet_with_context(cx, expr.span, span.ctxt(), \"..\", &mut app).0;\n+                    diag.span_suggestion(span, \"try this\", snip.into_owned(), app);\n+                },\n+            );\n+        },\n+        State::Borrow => (),\n     }\n }\n "}, {"sha": "56262c8f96e11e23ee8a6c894d91dc55d3d7447e", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -44,6 +44,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(crate_in_macro_def::CRATE_IN_MACRO_DEF),\n     LintId::of(default::FIELD_REASSIGN_WITH_DEFAULT),\n     LintId::of(default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY),\n+    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n     LintId::of(dereference::NEEDLESS_BORROW),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(derive::DERIVE_HASH_XOR_EQ),"}, {"sha": "d7f6140ca4b760a100102552a058d7cc3b7078e9", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -9,6 +9,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n+    LintId::of(dereference::EXPLICIT_AUTO_DEREF),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n     LintId::of(double_comparison::DOUBLE_COMPARISONS),\n     LintId::of(double_parens::DOUBLE_PARENS),"}, {"sha": "75993fa168f5830d8f95d0ca72acc080d171ca20", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -110,6 +110,7 @@ store.register_lints(&[\n     default_instead_of_iter_empty::DEFAULT_INSTEAD_OF_ITER_EMPTY,\n     default_numeric_fallback::DEFAULT_NUMERIC_FALLBACK,\n     default_union_representation::DEFAULT_UNION_REPRESENTATION,\n+    dereference::EXPLICIT_AUTO_DEREF,\n     dereference::EXPLICIT_DEREF_METHODS,\n     dereference::NEEDLESS_BORROW,\n     dereference::REF_BINDING_TO_REFERENCE,"}, {"sha": "fa3b8d1fceaaccb582e4c560ab4788d9828a26bc", "filename": "clippy_lints/src/matches/match_str_case_mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_str_case_mismatch.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -118,7 +118,7 @@ fn lint(cx: &LateContext<'_>, case_method: &CaseMethod, bad_case_span: Span, bad\n         MATCH_STR_CASE_MISMATCH,\n         bad_case_span,\n         \"this `match` arm has a differing case than its expression\",\n-        &*format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n+        &format!(\"consider changing the case of this arm to respect `{}`\", method_str),\n         format!(\"\\\"{}\\\"\", suggestion),\n         Applicability::MachineApplicable,\n     );"}, {"sha": "b96af06b8d7c69a63c5c177970b322f6f98d01fa", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n         // add the pattern after the expression because the bindings aren't available\n         // yet in the init\n         // expression\n-        SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n+        SimilarNamesNameVisitor(self).visit_pat(&local.pat);\n     }\n     fn visit_block(&mut self, blk: &'tcx Block) {\n         self.single_char_names.push(vec![]);"}, {"sha": "5678b8f6ca68ee96cdb802bc329bff1297364bda", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -574,14 +574,13 @@ fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args:\n                 Some((Node::Expr(e), child_id)) => match e.kind {\n                     ExprKind::Call(f, expr_args) => {\n                         let i = expr_args.iter().position(|arg| arg.hir_id == child_id).unwrap_or(0);\n-                        if expr_sig(self.cx, f)\n-                            .map(|sig| sig.input(i).skip_binder().peel_refs())\n-                            .map_or(true, |ty| match *ty.kind() {\n+                        if expr_sig(self.cx, f).and_then(|sig| sig.input(i)).map_or(true, |ty| {\n+                            match *ty.skip_binder().peel_refs().kind() {\n                                 ty::Param(_) => true,\n                                 ty::Adt(def, _) => def.did() == args.ty_did,\n                                 _ => false,\n-                            })\n-                        {\n+                            }\n+                        }) {\n                             // Passed to a function taking the non-dereferenced type.\n                             set_skip_flag();\n                         }"}, {"sha": "f8801f769e83d6cc2dddd94abac1f4bbc2f10da8", "filename": "clippy_lints/src/redundant_static_lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_static_lifetimes.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -87,7 +87,7 @@ impl RedundantStaticLifetimes {\n                         _ => {},\n                     }\n                 }\n-                self.visit_type(&*borrow_type.ty, cx, reason);\n+                self.visit_type(&borrow_type.ty, cx, reason);\n             },\n             _ => {},\n         }"}, {"sha": "ca056e7c1a0d6497cc71a0839a07fcf33a0ec93a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -2058,6 +2058,21 @@ pub fn peel_hir_expr_refs<'a>(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     (e, count)\n }\n \n+/// Peels off all references on the type. Returns the underlying type and the number of references\n+/// removed.\n+pub fn peel_hir_ty_refs<'a>(mut ty: &'a hir::Ty<'a>) -> (&'a hir::Ty<'a>, usize) {\n+    let mut count = 0;\n+    loop {\n+        match &ty.kind {\n+            TyKind::Rptr(_, ref_ty) => {\n+                ty = ref_ty.ty;\n+                count += 1;\n+            },\n+            _ => break (ty, count),\n+        }\n+    }\n+}\n+\n /// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n /// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n@@ -2110,7 +2125,7 @@ fn with_test_item_names<'tcx>(tcx: TyCtxt<'tcx>, module: LocalDefId, f: impl Fn(\n                 }\n             }\n             names.sort_unstable();\n-            f(&*entry.insert(names))\n+            f(entry.insert(names))\n         },\n     }\n }\n@@ -2168,6 +2183,57 @@ pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n             && item.ident.name.as_str().split('_').any(|a| a == \"test\" || a == \"tests\")\n }\n \n+/// Walks the HIR tree from the given expression, up to the node where the value produced by the\n+/// expression is consumed. Calls the function for every node encountered this way until it returns\n+/// `Some`.\n+///\n+/// This allows walking through `if`, `match`, `break`, block expressions to find where the value\n+/// produced by the expression is consumed.\n+pub fn walk_to_expr_usage<'tcx, T>(\n+    cx: &LateContext<'tcx>,\n+    e: &Expr<'tcx>,\n+    mut f: impl FnMut(Node<'tcx>, HirId) -> Option<T>,\n+) -> Option<T> {\n+    let map = cx.tcx.hir();\n+    let mut iter = map.parent_iter(e.hir_id);\n+    let mut child_id = e.hir_id;\n+\n+    while let Some((parent_id, parent)) = iter.next() {\n+        if let Some(x) = f(parent, child_id) {\n+            return Some(x);\n+        }\n+        let parent = match parent {\n+            Node::Expr(e) => e,\n+            Node::Block(Block { expr: Some(body), .. }) | Node::Arm(Arm { body, .. }) if body.hir_id == child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            Node::Arm(a) if a.body.hir_id == child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            _ => return None,\n+        };\n+        match parent.kind {\n+            ExprKind::If(child, ..) | ExprKind::Match(child, ..) if child.hir_id != child_id => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            ExprKind::Break(Destination { target_id: Ok(id), .. }, _) => {\n+                child_id = id;\n+                iter = map.parent_iter(id);\n+                continue;\n+            },\n+            ExprKind::Block(..) => {\n+                child_id = parent_id;\n+                continue;\n+            },\n+            _ => return None,\n+        }\n+    }\n+    None\n+}\n+\n macro_rules! op_utils {\n     ($($name:ident $assign:ident)*) => {\n         /// Binary operation traits like `LangItem::Add`"}, {"sha": "2c19e8a7adb226a0019ff3fa44bfbae9121b9370", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 61, "deletions": 12, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -6,16 +6,16 @@ use core::ops::ControlFlow;\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n-use rustc_hir::def::{CtorKind, DefKind, Res};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{Expr, LangItem, TyKind, Unsafety};\n+use rustc_hir::{Expr, FnDecl, LangItem, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{\n-    self, AdtDef, Binder, BoundRegion, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy, Region,\n-    RegionKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDiscr,\n+    self, AdtDef, Binder, BoundRegion, DefIdTree, FnSig, IntTy, ParamEnv, Predicate, PredicateKind, ProjectionTy,\n+    Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable, TypeVisitor, UintTy, VariantDef, VariantDiscr,\n };\n use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n@@ -502,24 +502,54 @@ pub fn all_predicates_of(tcx: TyCtxt<'_>, id: DefId) -> impl Iterator<Item = &(P\n #[derive(Clone, Copy)]\n pub enum ExprFnSig<'tcx> {\n     Sig(Binder<'tcx, FnSig<'tcx>>),\n-    Closure(Binder<'tcx, FnSig<'tcx>>),\n+    Closure(Option<&'tcx FnDecl<'tcx>>, Binder<'tcx, FnSig<'tcx>>),\n     Trait(Binder<'tcx, Ty<'tcx>>, Option<Binder<'tcx, Ty<'tcx>>>),\n }\n impl<'tcx> ExprFnSig<'tcx> {\n-    /// Gets the argument type at the given offset.\n-    pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n+    /// Gets the argument type at the given offset. This will return `None` when the index is out of\n+    /// bounds only for variadic functions, otherwise this will panic.\n+    pub fn input(self, i: usize) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) => sig.input(i),\n-            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n-            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_fields()[i]),\n+            Self::Sig(sig) => {\n+                if sig.c_variadic() {\n+                    sig.inputs().map_bound(|inputs| inputs.get(i).copied()).transpose()\n+                } else {\n+                    Some(sig.input(i))\n+                }\n+            },\n+            Self::Closure(_, sig) => Some(sig.input(0).map_bound(|ty| ty.tuple_fields()[i])),\n+            Self::Trait(inputs, _) => Some(inputs.map_bound(|ty| ty.tuple_fields()[i])),\n+        }\n+    }\n+\n+    /// Gets the argument type at the given offset. For closures this will also get the type as\n+    /// written. This will return `None` when the index is out of bounds only for variadic\n+    /// functions, otherwise this will panic.\n+    pub fn input_with_hir(self, i: usize) -> Option<(Option<&'tcx hir::Ty<'tcx>>, Binder<'tcx, Ty<'tcx>>)> {\n+        match self {\n+            Self::Sig(sig) => {\n+                if sig.c_variadic() {\n+                    sig.inputs()\n+                        .map_bound(|inputs| inputs.get(i).copied())\n+                        .transpose()\n+                        .map(|arg| (None, arg))\n+                } else {\n+                    Some((None, sig.input(i)))\n+                }\n+            },\n+            Self::Closure(decl, sig) => Some((\n+                decl.and_then(|decl| decl.inputs.get(i)),\n+                sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n+            )),\n+            Self::Trait(inputs, _) => Some((None, inputs.map_bound(|ty| ty.tuple_fields()[i]))),\n         }\n     }\n \n     /// Gets the result type, if one could be found. Note that the result type of a trait may not be\n     /// specified.\n     pub fn output(self) -> Option<Binder<'tcx, Ty<'tcx>>> {\n         match self {\n-            Self::Sig(sig) | Self::Closure(sig) => Some(sig.output()),\n+            Self::Sig(sig) | Self::Closure(_, sig) => Some(sig.output()),\n             Self::Trait(_, output) => output,\n         }\n     }\n@@ -536,7 +566,12 @@ pub fn expr_sig<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<ExprFnS\n \n fn ty_sig<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<ExprFnSig<'tcx>> {\n     match *ty.kind() {\n-        ty::Closure(_, subs) => Some(ExprFnSig::Closure(subs.as_closure().sig())),\n+        ty::Closure(id, subs) => {\n+            let decl = id\n+                .as_local()\n+                .and_then(|id| cx.tcx.hir().fn_decl_by_hir_id(cx.tcx.hir().local_def_id_to_hir_id(id)));\n+            Some(ExprFnSig::Closure(decl, subs.as_closure().sig()))\n+        },\n         ty::FnDef(id, subs) => Some(ExprFnSig::Sig(cx.tcx.bound_fn_sig(id).subst(cx.tcx, subs))),\n         ty::FnPtr(sig) => Some(ExprFnSig::Sig(sig)),\n         ty::Dynamic(bounds, _) => {\n@@ -739,3 +774,17 @@ pub fn for_each_top_level_late_bound_region<B>(\n     }\n     ty.visit_with(&mut V { index: 0, f })\n }\n+\n+pub fn variant_of_res<'tcx>(cx: &LateContext<'tcx>, res: Res) -> Option<&'tcx VariantDef> {\n+    match res {\n+        Res::Def(DefKind::Struct, id) => Some(cx.tcx.adt_def(id).non_enum_variant()),\n+        Res::Def(DefKind::Variant, id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).variant_with_id(id)),\n+        Res::Def(DefKind::Ctor(CtorOf::Struct, _), id) => Some(cx.tcx.adt_def(cx.tcx.parent(id)).non_enum_variant()),\n+        Res::Def(DefKind::Ctor(CtorOf::Variant, _), id) => {\n+            let var_id = cx.tcx.parent(id);\n+            Some(cx.tcx.adt_def(cx.tcx.parent(var_id)).variant_with_id(var_id))\n+        },\n+        Res::SelfCtor(id) => Some(cx.tcx.type_of(id).ty_adt_def().unwrap().non_enum_variant()),\n+        _ => None,\n+    }\n+}"}, {"sha": "b4e93774436a36da3c7d1a0f94cda4ac49feebb6", "filename": "tests/ui/borrow_deref_ref_unfixable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fborrow_deref_ref_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fborrow_deref_ref_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrow_deref_ref_unfixable.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code, unused_variables)]\n+#![allow(dead_code, unused_variables, clippy::explicit_auto_deref)]\n \n fn main() {}\n "}, {"sha": "04039ca31541c5574ca2328188444c66ebac9718", "filename": "tests/ui/explicit_auto_deref.fixed", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_auto_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_auto_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.fixed?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -0,0 +1,161 @@\n+// run-rustfix\n+\n+#![warn(clippy::explicit_auto_deref)]\n+#![allow(\n+    dead_code,\n+    unused_braces,\n+    clippy::borrowed_box,\n+    clippy::needless_borrow,\n+    clippy::ptr_arg,\n+    clippy::redundant_field_names,\n+    clippy::too_many_arguments\n+)]\n+\n+trait CallableStr {\n+    type T: Fn(&str);\n+    fn callable_str(&self) -> Self::T;\n+}\n+impl CallableStr for () {\n+    type T = fn(&str);\n+    fn callable_str(&self) -> Self::T {\n+        fn f(_: &str) {}\n+        f\n+    }\n+}\n+impl CallableStr for i32 {\n+    type T = <() as CallableStr>::T;\n+    fn callable_str(&self) -> Self::T {\n+        ().callable_str()\n+    }\n+}\n+\n+trait CallableT<U: ?Sized> {\n+    type T: Fn(&U);\n+    fn callable_t(&self) -> Self::T;\n+}\n+impl<U: ?Sized> CallableT<U> for () {\n+    type T = fn(&U);\n+    fn callable_t(&self) -> Self::T {\n+        fn f<U: ?Sized>(_: &U) {}\n+        f::<U>\n+    }\n+}\n+impl<U: ?Sized> CallableT<U> for i32 {\n+    type T = <() as CallableT<U>>::T;\n+    fn callable_t(&self) -> Self::T {\n+        ().callable_t()\n+    }\n+}\n+\n+fn f_str(_: &str) {}\n+fn f_t<T>(_: T) {}\n+fn f_ref_t<T: ?Sized>(_: &T) {}\n+\n+fn f_str_t<T>(_: &str, _: T) {}\n+\n+fn f_box_t<T>(_: &Box<T>) {}\n+\n+fn main() {\n+    let s = String::new();\n+\n+    let _: &str = &s;\n+    let _ = &*s; // Don't lint. Inferred type would change.\n+    let _: &_ = &*s; // Don't lint. Inferred type would change.\n+\n+    f_str(&s);\n+    f_t(&*s); // Don't lint. Inferred type would change.\n+    f_ref_t(&*s); // Don't lint. Inferred type would change.\n+\n+    f_str_t(&s, &*s); // Don't lint second param.\n+\n+    let b = Box::new(Box::new(Box::new(5)));\n+    let _: &Box<i32> = &b;\n+    let _: &Box<_> = &**b; // Don't lint. Inferred type would change.\n+\n+    f_box_t(&**b); // Don't lint. Inferred type would change.\n+\n+    let c = |_x: &str| ();\n+    c(&s);\n+\n+    let c = |_x| ();\n+    c(&*s); // Don't lint. Inferred type would change.\n+\n+    fn _f(x: &String) -> &str {\n+        x\n+    }\n+\n+    fn _f1(x: &String) -> &str {\n+        { x }\n+    }\n+\n+    fn _f2(x: &String) -> &str {\n+        { x }\n+    }\n+\n+    fn _f3(x: &Box<Box<Box<i32>>>) -> &Box<i32> {\n+        x\n+    }\n+\n+    fn _f4(\n+        x: String,\n+        f1: impl Fn(&str),\n+        f2: &dyn Fn(&str),\n+        f3: fn(&str),\n+        f4: impl CallableStr,\n+        f5: <() as CallableStr>::T,\n+        f6: <i32 as CallableStr>::T,\n+        f7: &dyn CallableStr<T = fn(&str)>,\n+        f8: impl CallableT<str>,\n+        f9: <() as CallableT<str>>::T,\n+        f10: <i32 as CallableT<str>>::T,\n+        f11: &dyn CallableT<str, T = fn(&str)>,\n+    ) {\n+        f1(&x);\n+        f2(&x);\n+        f3(&x);\n+        f4.callable_str()(&x);\n+        f5(&x);\n+        f6(&x);\n+        f7.callable_str()(&x);\n+        f8.callable_t()(&x);\n+        f9(&x);\n+        f10(&x);\n+        f11.callable_t()(&x);\n+    }\n+\n+    struct S1<'a>(&'a str);\n+    let _ = S1(&s);\n+\n+    struct S2<'a> {\n+        s: &'a str,\n+    }\n+    let _ = S2 { s: &s };\n+\n+    struct S3<'a, T: ?Sized>(&'a T);\n+    let _ = S3(&*s); // Don't lint. Inferred type would change.\n+\n+    struct S4<'a, T: ?Sized> {\n+        s: &'a T,\n+    }\n+    let _ = S4 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    enum E1<'a> {\n+        S1(&'a str),\n+        S2 { s: &'a str },\n+    }\n+    impl<'a> E1<'a> {\n+        fn m1(s: &'a String) {\n+            let _ = Self::S1(s);\n+            let _ = Self::S2 { s: s };\n+        }\n+    }\n+    let _ = E1::S1(&s);\n+    let _ = E1::S2 { s: &s };\n+\n+    enum E2<'a, T: ?Sized> {\n+        S1(&'a T),\n+        S2 { s: &'a T },\n+    }\n+    let _ = E2::S1(&*s); // Don't lint. Inferred type would change.\n+    let _ = E2::S2 { s: &*s }; // Don't lint. Inferred type would change.\n+}"}, {"sha": "1cc77c1b08f94f62fa4e64c29f43db9b2f7ca58d", "filename": "tests/ui/explicit_auto_deref.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_auto_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_auto_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -0,0 +1,161 @@\n+// run-rustfix\n+\n+#![warn(clippy::explicit_auto_deref)]\n+#![allow(\n+    dead_code,\n+    unused_braces,\n+    clippy::borrowed_box,\n+    clippy::needless_borrow,\n+    clippy::ptr_arg,\n+    clippy::redundant_field_names,\n+    clippy::too_many_arguments\n+)]\n+\n+trait CallableStr {\n+    type T: Fn(&str);\n+    fn callable_str(&self) -> Self::T;\n+}\n+impl CallableStr for () {\n+    type T = fn(&str);\n+    fn callable_str(&self) -> Self::T {\n+        fn f(_: &str) {}\n+        f\n+    }\n+}\n+impl CallableStr for i32 {\n+    type T = <() as CallableStr>::T;\n+    fn callable_str(&self) -> Self::T {\n+        ().callable_str()\n+    }\n+}\n+\n+trait CallableT<U: ?Sized> {\n+    type T: Fn(&U);\n+    fn callable_t(&self) -> Self::T;\n+}\n+impl<U: ?Sized> CallableT<U> for () {\n+    type T = fn(&U);\n+    fn callable_t(&self) -> Self::T {\n+        fn f<U: ?Sized>(_: &U) {}\n+        f::<U>\n+    }\n+}\n+impl<U: ?Sized> CallableT<U> for i32 {\n+    type T = <() as CallableT<U>>::T;\n+    fn callable_t(&self) -> Self::T {\n+        ().callable_t()\n+    }\n+}\n+\n+fn f_str(_: &str) {}\n+fn f_t<T>(_: T) {}\n+fn f_ref_t<T: ?Sized>(_: &T) {}\n+\n+fn f_str_t<T>(_: &str, _: T) {}\n+\n+fn f_box_t<T>(_: &Box<T>) {}\n+\n+fn main() {\n+    let s = String::new();\n+\n+    let _: &str = &*s;\n+    let _ = &*s; // Don't lint. Inferred type would change.\n+    let _: &_ = &*s; // Don't lint. Inferred type would change.\n+\n+    f_str(&*s);\n+    f_t(&*s); // Don't lint. Inferred type would change.\n+    f_ref_t(&*s); // Don't lint. Inferred type would change.\n+\n+    f_str_t(&*s, &*s); // Don't lint second param.\n+\n+    let b = Box::new(Box::new(Box::new(5)));\n+    let _: &Box<i32> = &**b;\n+    let _: &Box<_> = &**b; // Don't lint. Inferred type would change.\n+\n+    f_box_t(&**b); // Don't lint. Inferred type would change.\n+\n+    let c = |_x: &str| ();\n+    c(&*s);\n+\n+    let c = |_x| ();\n+    c(&*s); // Don't lint. Inferred type would change.\n+\n+    fn _f(x: &String) -> &str {\n+        &**x\n+    }\n+\n+    fn _f1(x: &String) -> &str {\n+        { &**x }\n+    }\n+\n+    fn _f2(x: &String) -> &str {\n+        &**{ x }\n+    }\n+\n+    fn _f3(x: &Box<Box<Box<i32>>>) -> &Box<i32> {\n+        &***x\n+    }\n+\n+    fn _f4(\n+        x: String,\n+        f1: impl Fn(&str),\n+        f2: &dyn Fn(&str),\n+        f3: fn(&str),\n+        f4: impl CallableStr,\n+        f5: <() as CallableStr>::T,\n+        f6: <i32 as CallableStr>::T,\n+        f7: &dyn CallableStr<T = fn(&str)>,\n+        f8: impl CallableT<str>,\n+        f9: <() as CallableT<str>>::T,\n+        f10: <i32 as CallableT<str>>::T,\n+        f11: &dyn CallableT<str, T = fn(&str)>,\n+    ) {\n+        f1(&*x);\n+        f2(&*x);\n+        f3(&*x);\n+        f4.callable_str()(&*x);\n+        f5(&*x);\n+        f6(&*x);\n+        f7.callable_str()(&*x);\n+        f8.callable_t()(&*x);\n+        f9(&*x);\n+        f10(&*x);\n+        f11.callable_t()(&*x);\n+    }\n+\n+    struct S1<'a>(&'a str);\n+    let _ = S1(&*s);\n+\n+    struct S2<'a> {\n+        s: &'a str,\n+    }\n+    let _ = S2 { s: &*s };\n+\n+    struct S3<'a, T: ?Sized>(&'a T);\n+    let _ = S3(&*s); // Don't lint. Inferred type would change.\n+\n+    struct S4<'a, T: ?Sized> {\n+        s: &'a T,\n+    }\n+    let _ = S4 { s: &*s }; // Don't lint. Inferred type would change.\n+\n+    enum E1<'a> {\n+        S1(&'a str),\n+        S2 { s: &'a str },\n+    }\n+    impl<'a> E1<'a> {\n+        fn m1(s: &'a String) {\n+            let _ = Self::S1(&**s);\n+            let _ = Self::S2 { s: &**s };\n+        }\n+    }\n+    let _ = E1::S1(&*s);\n+    let _ = E1::S2 { s: &*s };\n+\n+    enum E2<'a, T: ?Sized> {\n+        S1(&'a T),\n+        S2 { s: &'a T },\n+    }\n+    let _ = E2::S1(&*s); // Don't lint. Inferred type would change.\n+    let _ = E2::S2 { s: &*s }; // Don't lint. Inferred type would change.\n+}"}, {"sha": "f3cceb6b889d4c941f58c1ff55bed40fee1c9967", "filename": "tests/ui/explicit_auto_deref.stderr", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_auto_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_auto_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_auto_deref.stderr?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -0,0 +1,160 @@\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:61:20\n+   |\n+LL |     let _: &str = &*s;\n+   |                    ^^ help: try this: `s`\n+   |\n+   = note: `-D clippy::explicit-auto-deref` implied by `-D warnings`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:65:12\n+   |\n+LL |     f_str(&*s);\n+   |            ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:69:14\n+   |\n+LL |     f_str_t(&*s, &*s); // Don't lint second param.\n+   |              ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:72:25\n+   |\n+LL |     let _: &Box<i32> = &**b;\n+   |                         ^^^ help: try this: `b`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:78:8\n+   |\n+LL |     c(&*s);\n+   |        ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:84:9\n+   |\n+LL |         &**x\n+   |         ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:88:11\n+   |\n+LL |         { &**x }\n+   |           ^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:92:9\n+   |\n+LL |         &**{ x }\n+   |         ^^^^^^^^ help: try this: `{ x }`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:96:9\n+   |\n+LL |         &***x\n+   |         ^^^^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:113:13\n+   |\n+LL |         f1(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:114:13\n+   |\n+LL |         f2(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:115:13\n+   |\n+LL |         f3(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:116:28\n+   |\n+LL |         f4.callable_str()(&*x);\n+   |                            ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:117:13\n+   |\n+LL |         f5(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:118:13\n+   |\n+LL |         f6(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:119:28\n+   |\n+LL |         f7.callable_str()(&*x);\n+   |                            ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:120:26\n+   |\n+LL |         f8.callable_t()(&*x);\n+   |                          ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:121:13\n+   |\n+LL |         f9(&*x);\n+   |             ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:122:14\n+   |\n+LL |         f10(&*x);\n+   |              ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:123:27\n+   |\n+LL |         f11.callable_t()(&*x);\n+   |                           ^^ help: try this: `x`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:127:17\n+   |\n+LL |     let _ = S1(&*s);\n+   |                 ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:132:22\n+   |\n+LL |     let _ = S2 { s: &*s };\n+   |                      ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:148:30\n+   |\n+LL |             let _ = Self::S1(&**s);\n+   |                              ^^^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:149:35\n+   |\n+LL |             let _ = Self::S2 { s: &**s };\n+   |                                   ^^^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:152:21\n+   |\n+LL |     let _ = E1::S1(&*s);\n+   |                     ^^ help: try this: `s`\n+\n+error: deref which would be done by auto-deref\n+  --> $DIR/explicit_auto_deref.rs:153:26\n+   |\n+LL |     let _ = E1::S2 { s: &*s };\n+   |                          ^^ help: try this: `s`\n+\n+error: aborting due to 26 previous errors\n+"}, {"sha": "523cae183ee6ec27fac2400d22d128202b4b1b9d", "filename": "tests/ui/explicit_deref_methods.fixed", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.fixed?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -4,7 +4,8 @@\n     unused_variables,\n     clippy::clone_double_ref,\n     clippy::needless_borrow,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::explicit_auto_deref\n )]\n #![warn(clippy::explicit_deref_methods)]\n "}, {"sha": "0bbc1ae57cdf6dfc23eea738be3423db677a5dda", "filename": "tests/ui/explicit_deref_methods.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -4,7 +4,8 @@\n     unused_variables,\n     clippy::clone_double_ref,\n     clippy::needless_borrow,\n-    clippy::borrow_deref_ref\n+    clippy::borrow_deref_ref,\n+    clippy::explicit_auto_deref\n )]\n #![warn(clippy::explicit_deref_methods)]\n "}, {"sha": "4b10ed1377b0dc46f6eaf955bb23cb423542b2ab", "filename": "tests/ui/explicit_deref_methods.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_deref_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fexplicit_deref_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.stderr?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -1,73 +1,73 @@\n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:35:19\n+  --> $DIR/explicit_deref_methods.rs:36:19\n    |\n LL |     let b: &str = a.deref();\n    |                   ^^^^^^^^^ help: try this: `&*a`\n    |\n    = note: `-D clippy::explicit-deref-methods` implied by `-D warnings`\n \n error: explicit `deref_mut` method call\n-  --> $DIR/explicit_deref_methods.rs:37:23\n+  --> $DIR/explicit_deref_methods.rs:38:23\n    |\n LL |     let b: &mut str = a.deref_mut();\n    |                       ^^^^^^^^^^^^^ help: try this: `&mut **a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:40:39\n+  --> $DIR/explicit_deref_methods.rs:41:39\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                       ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:40:50\n+  --> $DIR/explicit_deref_methods.rs:41:50\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                                  ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:42:20\n+  --> $DIR/explicit_deref_methods.rs:43:20\n    |\n LL |     println!(\"{}\", a.deref());\n    |                    ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:45:11\n+  --> $DIR/explicit_deref_methods.rs:46:11\n    |\n LL |     match a.deref() {\n    |           ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:49:28\n+  --> $DIR/explicit_deref_methods.rs:50:28\n    |\n LL |     let b: String = concat(a.deref());\n    |                            ^^^^^^^^^ help: try this: `&*a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:51:13\n+  --> $DIR/explicit_deref_methods.rs:52:13\n    |\n LL |     let b = just_return(a).deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:53:28\n+  --> $DIR/explicit_deref_methods.rs:54:28\n    |\n LL |     let b: String = concat(just_return(a).deref());\n    |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:55:19\n+  --> $DIR/explicit_deref_methods.rs:56:19\n    |\n LL |     let b: &str = a.deref().deref();\n    |                   ^^^^^^^^^^^^^^^^^ help: try this: `&**a`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:58:13\n+  --> $DIR/explicit_deref_methods.rs:59:13\n    |\n LL |     let b = opt_a.unwrap().deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*opt_a.unwrap()`\n \n error: explicit `deref` method call\n-  --> $DIR/explicit_deref_methods.rs:84:31\n+  --> $DIR/explicit_deref_methods.rs:85:31\n    |\n LL |     let b: &str = expr_deref!(a.deref());\n    |                               ^^^^^^^^^ help: try this: `&*a`"}, {"sha": "90cb8945e77ff1a1d86f79d87b3cf9159302b3c9", "filename": "tests/ui/useless_asref.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fuseless_asref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fuseless_asref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.fixed?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::useless_asref)]\n+#![allow(clippy::explicit_auto_deref)]\n \n use std::fmt::Debug;\n "}, {"sha": "cb9f8ae5909a551856a33fe57e94f6c77eab6306", "filename": "tests/ui/useless_asref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.rs?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -1,6 +1,7 @@\n // run-rustfix\n \n #![deny(clippy::useless_asref)]\n+#![allow(clippy::explicit_auto_deref)]\n \n use std::fmt::Debug;\n "}, {"sha": "b21c67bb3645f0bee32311879842ecd86ebaf87c", "filename": "tests/ui/useless_asref.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fuseless_asref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a74d3357079e5edf2454f6523a9c93081e7348e/tests%2Fui%2Fuseless_asref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_asref.stderr?ref=8a74d3357079e5edf2454f6523a9c93081e7348e", "patch": "@@ -1,5 +1,5 @@\n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:43:18\n+  --> $DIR/useless_asref.rs:44:18\n    |\n LL |         foo_rstr(rstr.as_ref());\n    |                  ^^^^^^^^^^^^^ help: try this: `rstr`\n@@ -11,61 +11,61 @@ LL | #![deny(clippy::useless_asref)]\n    |         ^^^^^^^^^^^^^^^^^^^^^\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:45:20\n+  --> $DIR/useless_asref.rs:46:20\n    |\n LL |         foo_rslice(rslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^ help: try this: `rslice`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:49:21\n+  --> $DIR/useless_asref.rs:50:21\n    |\n LL |         foo_mrslice(mrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:51:20\n+  --> $DIR/useless_asref.rs:52:20\n    |\n LL |         foo_rslice(mrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^ help: try this: `mrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:58:20\n+  --> $DIR/useless_asref.rs:59:20\n    |\n LL |         foo_rslice(rrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^ help: try this: `rrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:60:18\n+  --> $DIR/useless_asref.rs:61:18\n    |\n LL |         foo_rstr(rrrrrstr.as_ref());\n    |                  ^^^^^^^^^^^^^^^^^ help: try this: `rrrrrstr`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:65:21\n+  --> $DIR/useless_asref.rs:66:21\n    |\n LL |         foo_mrslice(mrrrrrslice.as_mut());\n    |                     ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:67:20\n+  --> $DIR/useless_asref.rs:68:20\n    |\n LL |         foo_rslice(mrrrrrslice.as_ref());\n    |                    ^^^^^^^^^^^^^^^^^^^^ help: try this: `mrrrrrslice`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:71:16\n+  --> $DIR/useless_asref.rs:72:16\n    |\n LL |     foo_rrrrmr((&&&&MoreRef).as_ref());\n    |                ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(&&&&MoreRef)`\n \n error: this call to `as_mut` does nothing\n-  --> $DIR/useless_asref.rs:121:13\n+  --> $DIR/useless_asref.rs:122:13\n    |\n LL |     foo_mrt(mrt.as_mut());\n    |             ^^^^^^^^^^^^ help: try this: `mrt`\n \n error: this call to `as_ref` does nothing\n-  --> $DIR/useless_asref.rs:123:12\n+  --> $DIR/useless_asref.rs:124:12\n    |\n LL |     foo_rt(mrt.as_ref());\n    |            ^^^^^^^^^^^^ help: try this: `mrt`"}]}