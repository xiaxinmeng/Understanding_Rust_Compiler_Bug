{"sha": "1cc7621dec567ded8965fd6c01d80104cfec4d68", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYzc2MjFkZWM1NjdkZWQ4OTY1ZmQ2YzAxZDgwMTA0Y2ZlYzRkNjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-12T16:51:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-12T17:03:47Z"}, "message": "simplify code to remove now unused \"stack\" and fix comments", "tree": {"sha": "e93b61093fd04cce2f2ea3026e2f89f627b623c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e93b61093fd04cce2f2ea3026e2f89f627b623c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cc7621dec567ded8965fd6c01d80104cfec4d68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc7621dec567ded8965fd6c01d80104cfec4d68", "html_url": "https://github.com/rust-lang/rust/commit/1cc7621dec567ded8965fd6c01d80104cfec4d68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cc7621dec567ded8965fd6c01d80104cfec4d68/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa437f49af90e1a78771f2262d51ddd01b668199", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa437f49af90e1a78771f2262d51ddd01b668199", "html_url": "https://github.com/rust-lang/rust/commit/fa437f49af90e1a78771f2262d51ddd01b668199"}], "stats": {"total": 146, "additions": 54, "deletions": 92}, "files": [{"sha": "b73079b02bdd94ab0d050939f8de38716cbcadb7", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 51, "deletions": 88, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1cc7621dec567ded8965fd6c01d80104cfec4d68/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc7621dec567ded8965fd6c01d80104cfec4d68/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=1cc7621dec567ded8965fd6c01d80104cfec4d68", "patch": "@@ -47,7 +47,6 @@ use ty::relate::{RelateResult, TypeRelation};\n use traits::PredicateObligations;\n \n use syntax::ast;\n-use syntax::util::small_vector::SmallVector;\n use syntax_pos::Span;\n \n #[derive(Clone)]\n@@ -174,6 +173,15 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n         Glb::new(self, a_is_expected)\n     }\n \n+    /// Here dir is either EqTo, SubtypeOf, or SupertypeOf. The\n+    /// idea is that we should ensure that the type `a_ty` is equal\n+    /// to, a subtype of, or a supertype of (respectively) the type\n+    /// to which `b_vid` is bound.\n+    ///\n+    /// Since `b_vid` has not yet been instantiated with a type, we\n+    /// will first instantiate `b_vid` with a *generalized* version\n+    /// of `a_ty`. Generalization introduces other inference\n+    /// variables wherever subtyping could occur.\n     pub fn instantiate(&mut self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n@@ -183,109 +191,64 @@ impl<'infcx, 'gcx, 'tcx> CombineFields<'infcx, 'gcx, 'tcx> {\n     {\n         use self::RelationDir::*;\n \n-        // We use SmallVector here instead of Vec because this code is hot and\n-        // it's rare that the stack length exceeds 1.\n-        let mut stack = SmallVector::new();\n-        stack.push((a_ty, dir, b_vid));\n-        loop {\n-            // For each turn of the loop, we extract a tuple\n-            //\n-            //     (a_ty, dir, b_vid)\n-            //\n-            // to relate. Here dir is either SubtypeOf or\n-            // SupertypeOf. The idea is that we should ensure that\n-            // the type `a_ty` is a subtype or supertype (respectively) of the\n-            // type to which `b_vid` is bound.\n-            //\n-            // If `b_vid` has not yet been instantiated with a type\n-            // (which is always true on the first iteration, but not\n-            // necessarily true on later iterations), we will first\n-            // instantiate `b_vid` with a *generalized* version of\n-            // `a_ty`. Generalization introduces other inference\n-            // variables wherever subtyping could occur (at time of\n-            // this writing, this means replacing free regions with\n-            // region variables).\n-            let (a_ty, dir, b_vid) = match stack.pop() {\n-                None => break,\n-                Some(e) => e,\n-            };\n-            // Get the actual variable that b_vid has been inferred to\n-            let (b_vid, b_ty) = {\n-                let mut variables = self.infcx.type_variables.borrow_mut();\n-                let b_vid = variables.root_var(b_vid);\n-                (b_vid, variables.probe_root(b_vid))\n-            };\n-\n-            debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\",\n-                   a_ty,\n-                   dir,\n-                   b_vid);\n-\n-            // Check whether `vid` has been instantiated yet.  If not,\n-            // make a generalized form of `ty` and instantiate with\n-            // that.\n-            //\n-            // FIXME(#18653) -- we need to generalize nested type\n-            // variables too.\n-            let b_ty = match b_ty {\n-                Some(t) => t, // ...already instantiated.\n-                None => {     // ...not yet instantiated:\n-                    // Generalize type if necessary.\n-                    let generalized_ty = match dir {\n-                        EqTo => self.generalize(a_ty, b_vid, false),\n-                        SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n-                    }?;\n-                    debug!(\"instantiate(a_ty={:?}, dir={:?}, \\\n-                                        b_vid={:?}, generalized_ty={:?})\",\n-                           a_ty, dir, b_vid,\n-                           generalized_ty);\n-                    self.infcx.type_variables\n-                        .borrow_mut()\n-                        .instantiate(b_vid, generalized_ty);\n-                    generalized_ty\n-                }\n-            };\n-\n-            // The original triple was `(a_ty, dir, b_vid)` -- now we have\n-            // resolved `b_vid` to `b_ty`, so apply `(a_ty, dir, b_ty)`:\n-            //\n-            // FIXME(#16847): This code is non-ideal because all these subtype\n-            // relations wind up attributed to the same spans. We need\n-            // to associate causes/spans with each of the relations in\n-            // the stack to get this right.\n-            match dir {\n-                EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n-                SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n-                SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n-                    ty::Contravariant, &a_ty, &b_ty),\n-            }?;\n-        }\n+        // Get the actual variable that b_vid has been inferred to\n+        debug_assert!(self.infcx.type_variables.borrow_mut().probe(b_vid).is_none());\n+\n+        debug!(\"instantiate(a_ty={:?} dir={:?} b_vid={:?})\", a_ty, dir, b_vid);\n+\n+        // Generalize type of `a_ty` appropriately depending on the\n+        // direction.  As an example, assume:\n+        //\n+        // - `a_ty == &'x ?1`, where `'x` is some free region and `?1` is an\n+        //   inference variable,\n+        // - and `dir` == `SubtypeOf`.\n+        //\n+        // Then the generalized form `b_ty` would be `&'?2 ?3`, where\n+        // `'?2` and `?3` are fresh region/type inference\n+        // variables. (Down below, we will relate `a_ty <: b_ty`,\n+        // adding constraints like `'x: '?2` and `?1 <: ?3`.)\n+        let b_ty = self.generalize(a_ty, b_vid, dir == EqTo)?;\n+        debug!(\"instantiate(a_ty={:?}, dir={:?}, b_vid={:?}, generalized b_ty={:?})\",\n+               a_ty, dir, b_vid, b_ty);\n+        self.infcx.type_variables.borrow_mut().instantiate(b_vid, b_ty);\n+\n+        // Finally, relate `b_ty` to `a_ty`, as described in previous comment.\n+        //\n+        // FIXME(#16847): This code is non-ideal because all these subtype\n+        // relations wind up attributed to the same spans. We need\n+        // to associate causes/spans with each of the relations in\n+        // the stack to get this right.\n+        match dir {\n+            EqTo => self.equate(a_is_expected).relate(&a_ty, &b_ty),\n+            SubtypeOf => self.sub(a_is_expected).relate(&a_ty, &b_ty),\n+            SupertypeOf => self.sub(a_is_expected).relate_with_variance(\n+                ty::Contravariant, &a_ty, &b_ty),\n+        }?;\n \n         Ok(())\n     }\n \n     /// Attempts to generalize `ty` for the type variable `for_vid`.\n     /// This checks for cycle -- that is, whether the type `ty`\n-    /// references `for_vid`. If `make_region_vars` is true, it will\n-    /// also replace all regions with fresh variables. Returns\n-    /// `TyError` in the case of a cycle, `Ok` otherwise.\n+    /// references `for_vid`. If `is_eq_relation` is false, it will\n+    /// also replace all regions/unbound-type-variables with fresh\n+    /// variables. Returns `TyError` in the case of a cycle, `Ok`\n+    /// otherwise.\n     ///\n     /// Preconditions:\n     ///\n     /// - `for_vid` is a \"root vid\"\n     fn generalize(&self,\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n-                  make_region_vars: bool)\n+                  is_eq_relation: bool)\n                   -> RelateResult<'tcx, Ty<'tcx>>\n     {\n-        debug_assert!(self.infcx.type_variables.borrow_mut().root_var(for_vid) == for_vid);\n-\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n             span: self.trace.cause.span,\n             for_vid_sub_root: self.infcx.type_variables.borrow_mut().sub_root_var(for_vid),\n-            make_region_vars: make_region_vars,\n+            is_eq_relation: is_eq_relation,\n             cycle_detected: false\n         };\n         let u = ty.fold_with(&mut generalize);\n@@ -301,7 +264,7 @@ struct Generalizer<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n     span: Span,\n     for_vid_sub_root: ty::TyVid,\n-    make_region_vars: bool,\n+    is_eq_relation: bool,\n     cycle_detected: bool,\n }\n \n@@ -332,7 +295,7 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n                             self.fold_ty(u)\n                         }\n                         None => {\n-                            if self.make_region_vars {\n+                            if !self.is_eq_relation {\n                                 let origin = variables.origin(vid);\n                                 let new_var_id = variables.new_var(false, origin, None);\n                                 let u = self.tcx().mk_var(new_var_id);\n@@ -379,7 +342,7 @@ impl<'cx, 'gcx, 'tcx> ty::fold::TypeFolder<'gcx, 'tcx> for Generalizer<'cx, 'gcx\n             ty::ReScope(..) |\n             ty::ReVar(..) |\n             ty::ReFree(..) => {\n-                if !self.make_region_vars {\n+                if self.is_eq_relation {\n                     return r;\n                 }\n             }"}, {"sha": "4ae2a8026409d3fcd4082562c4f8d850041da957", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1cc7621dec567ded8965fd6c01d80104cfec4d68/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cc7621dec567ded8965fd6c01d80104cfec4d68/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=1cc7621dec567ded8965fd6c01d80104cfec4d68", "patch": "@@ -151,11 +151,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     /// Instantiates `vid` with the type `ty`.\n     ///\n-    /// Precondition: `vid` must be a root in the unification table\n-    /// and has not previously been instantiated.\n+    /// Precondition: `vid` must not have been previously instantiated.\n     pub fn instantiate(&mut self, vid: ty::TyVid, ty: Ty<'tcx>) {\n-        debug_assert!(self.root_var(vid) == vid);\n-        debug_assert!(self.probe(vid).is_none());\n+        let vid = self.root_var(vid);\n+        debug_assert!(self.probe_root(vid).is_none());\n \n         let old_value = {\n             let vid_data = &mut self.values[vid.index as usize];"}]}