{"sha": "e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "node_id": "C_kwDOAAsO6NoAKGU1MmQ0N2EzYjgyMTFjNDZkZTkzMjFmNzZhNTljZTVlOTgxMWE4Zjg", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-14T18:16:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-14T18:16:17Z"}, "message": "Merge #10539\n\n10539: Add \"generate delegate methods\" assist r=Veykril a=yoshuawuyts\n\n_Co-authored with `@rylev_.`\r\n\r\nThis patch adds a new assist: \"generate delegate method\" which creates a method that calls to a method defined on an inner field. Delegation is common when authoring newtypes, and having IDE support for this is the best way we can make this easier to author in Rust, bar adding language-level support for it. Thanks!\r\n\r\nCloses #5944.\r\n\r\n## Example\r\n\r\n__before__\r\n```rust\r\nstruct Age(u8);\r\nimpl Age {\r\n    fn age(&self) -> u8 {\r\n        self.0\r\n    }\r\n}\r\n\r\nstruct Person {\r\n    ag$0e: Age,\r\n}\r\n```\r\n\r\n__after__\r\n```rust\r\nstruct Age(u8);\r\nimpl Age {\r\n    fn age(&self) -> u8 {\r\n        self.0\r\n    }\r\n}\r\n\r\nstruct Person {\r\n    age: Age,\r\n}\r\n\r\nimpl Person {\r\n    $0fn age(&self) -> u8 {\r\n        self.age.age()\r\n    }\r\n}\r\n```\n\nCo-authored-by: Ryan Levick <me@ryanlevick.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>", "tree": {"sha": "118030f6959fc7e1d4a9b8c399113e84c09827a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/118030f6959fc7e1d4a9b8c399113e84c09827a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhaHPxCRBK7hj4Ov3rIwAAyTUIAJ2TMUDsBeWCA4wr4IazKJAL\nf5PMVIoQnAC1KB5mH2LjSbiDY2/+I2bzOAVA/1ARBCYJoJlvExzAwPXM/ddmEHqN\nz96xfrQH2ptKDy8SUMql7kBf9UwqodhlcGgjzBM9z7gTQK/QBgr7n1jhOh8TYePR\ndp+JTF8T6VbNSlmDDoxM1KEIdCOhSB5fdOKinRLrOWDOg+7eMn74q4cEAi6BAvhS\nplTWSDl2obMXhu5Wz2F6PNvo6TjvGY5086ULwlUIfhzDAw7F/na4D2xcwQnWMY0o\nXZ/y8in56eb8Ap5oKsta9L4SIf1hCIHBMm7EW+CXt3LaJNDBYtlp4qrqe6BjLWA=\n=yAqf\n-----END PGP SIGNATURE-----\n", "payload": "tree 118030f6959fc7e1d4a9b8c399113e84c09827a6\nparent a30941e2a553156ef891fa38d6241535eac3ce6f\nparent f84b0b32425b18301cabcecb61a485ad4a5c8bd4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1634235377 +0000\ncommitter GitHub <noreply@github.com> 1634235377 +0000\n\nMerge #10539\n\n10539: Add \"generate delegate methods\" assist r=Veykril a=yoshuawuyts\n\n_Co-authored with `@rylev_.`\r\n\r\nThis patch adds a new assist: \"generate delegate method\" which creates a method that calls to a method defined on an inner field. Delegation is common when authoring newtypes, and having IDE support for this is the best way we can make this easier to author in Rust, bar adding language-level support for it. Thanks!\r\n\r\nCloses #5944.\r\n\r\n## Example\r\n\r\n__before__\r\n```rust\r\nstruct Age(u8);\r\nimpl Age {\r\n    fn age(&self) -> u8 {\r\n        self.0\r\n    }\r\n}\r\n\r\nstruct Person {\r\n    ag$0e: Age,\r\n}\r\n```\r\n\r\n__after__\r\n```rust\r\nstruct Age(u8);\r\nimpl Age {\r\n    fn age(&self) -> u8 {\r\n        self.0\r\n    }\r\n}\r\n\r\nstruct Person {\r\n    age: Age,\r\n}\r\n\r\nimpl Person {\r\n    $0fn age(&self) -> u8 {\r\n        self.age.age()\r\n    }\r\n}\r\n```\n\nCo-authored-by: Ryan Levick <me@ryanlevick.com>\nCo-authored-by: Yoshua Wuyts <yoshuawuyts@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "html_url": "https://github.com/rust-lang/rust/commit/e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a30941e2a553156ef891fa38d6241535eac3ce6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a30941e2a553156ef891fa38d6241535eac3ce6f", "html_url": "https://github.com/rust-lang/rust/commit/a30941e2a553156ef891fa38d6241535eac3ce6f"}, {"sha": "f84b0b32425b18301cabcecb61a485ad4a5c8bd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f84b0b32425b18301cabcecb61a485ad4a5c8bd4", "html_url": "https://github.com/rust-lang/rust/commit/f84b0b32425b18301cabcecb61a485ad4a5c8bd4"}], "stats": {"total": 402, "additions": 401, "deletions": 1}, "files": [{"sha": "de59cb96130e2073570d70fded229f85b6f0eddb", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "patch": "@@ -3007,3 +3007,9 @@ impl HasCrate for Function {\n         self.module(db).krate()\n     }\n }\n+\n+impl HasCrate for Type {\n+    fn krate(&self, _db: &dyn HirDatabase) -> Crate {\n+        self.krate.into()\n+    }\n+}"}, {"sha": "233f26ed63707181b342316bd32c0114f2c5bded", "filename": "crates/ide_assists/src/handlers/generate_delegate_methods.rs", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "patch": "@@ -0,0 +1,314 @@\n+use hir::{self, HasCrate, HasSource};\n+use syntax::ast::{self, make, AstNode, HasGenericParams, HasName, HasVisibility};\n+\n+use crate::{\n+    utils::{convert_param_list_to_arg_list, find_struct_impl, render_snippet, Cursor},\n+    AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n+};\n+use syntax::ast::edit::AstNodeEdit;\n+\n+// Assist: generate_delegate_methods\n+//\n+// Generate delegate methods.\n+//\n+// ```\n+// struct Age(u8);\n+// impl Age {\n+//     fn age(&self) -> u8 {\n+//         self.0\n+//     }\n+// }\n+//\n+// struct Person {\n+//     ag$0e: Age,\n+// }\n+// ```\n+// ->\n+// ```\n+// struct Age(u8);\n+// impl Age {\n+//     fn age(&self) -> u8 {\n+//         self.0\n+//     }\n+// }\n+//\n+// struct Person {\n+//     age: Age,\n+// }\n+//\n+// impl Person {\n+//     $0fn age(&self) -> u8 {\n+//         self.age.age()\n+//     }\n+// }\n+// ```\n+pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let strukt = ctx.find_node_at_offset::<ast::Struct>()?;\n+    let strukt_name = strukt.name()?;\n+\n+    let (field_name, field_ty) = match ctx.find_node_at_offset::<ast::RecordField>() {\n+        Some(field) => {\n+            let field_name = field.name()?;\n+            let field_ty = field.ty()?;\n+            (format!(\"{}\", field_name), field_ty)\n+        }\n+        None => {\n+            let field = ctx.find_node_at_offset::<ast::TupleField>()?;\n+            let field_list = ctx.find_node_at_offset::<ast::TupleFieldList>()?;\n+            let field_list_index = field_list.fields().position(|it| it == field)?;\n+            let field_ty = field.ty()?;\n+            (format!(\"{}\", field_list_index), field_ty)\n+        }\n+    };\n+\n+    let sema_field_ty = ctx.sema.resolve_type(&field_ty)?;\n+    let krate = sema_field_ty.krate(ctx.db());\n+    let mut methods = vec![];\n+    sema_field_ty.iterate_assoc_items(ctx.db(), krate, |item| {\n+        if let hir::AssocItem::Function(f) = item {\n+            if f.self_param(ctx.db()).is_some() {\n+                methods.push(f)\n+            }\n+        }\n+        Option::<()>::None\n+    });\n+\n+    let target = field_ty.syntax().text_range();\n+    for method in methods {\n+        let adt = ast::Adt::Struct(strukt.clone());\n+        let name = method.name(ctx.db()).to_string();\n+        let impl_def = find_struct_impl(ctx, &adt, &name).flatten();\n+        acc.add_group(\n+            &GroupLabel(\"Generate delegate methods\u2026\".to_owned()),\n+            AssistId(\"generate_delegate_methods\", AssistKind::Generate),\n+            format!(\"Generate delegate for `{}.{}()`\", field_name, method.name(ctx.db())),\n+            target,\n+            |builder| {\n+                // Create the function\n+                let method_source = match method.source(ctx.db()) {\n+                    Some(source) => source.value,\n+                    None => return,\n+                };\n+                let method_name = method.name(ctx.db());\n+                let vis = method_source.visibility();\n+                let name = make::name(&method.name(ctx.db()).to_string());\n+                let params =\n+                    method_source.param_list().unwrap_or_else(|| make::param_list(None, []));\n+                let type_params = method_source.generic_param_list();\n+                let arg_list = match method_source.param_list() {\n+                    Some(list) => convert_param_list_to_arg_list(list),\n+                    None => make::arg_list([]),\n+                };\n+                let tail_expr = make::expr_method_call(\n+                    make::ext::field_from_idents([\"self\", &field_name]).unwrap(), // This unwrap is ok because we have at least 1 arg in the list\n+                    make::name_ref(&method_name.to_string()),\n+                    arg_list,\n+                );\n+                let body = make::block_expr([], Some(tail_expr));\n+                let ret_type = method_source.ret_type();\n+                let is_async = method_source.async_token().is_some();\n+                let f = make::fn_(vis, name, type_params, params, body, ret_type, is_async)\n+                    .indent(ast::edit::IndentLevel(1))\n+                    .clone_for_update();\n+\n+                let cursor = Cursor::Before(f.syntax());\n+\n+                // Create or update an impl block, attach the function to it,\n+                // then insert into our code.\n+                match impl_def {\n+                    Some(impl_def) => {\n+                        // Remember where in our source our `impl` block lives.\n+                        let impl_def = impl_def.clone_for_update();\n+                        let old_range = impl_def.syntax().text_range();\n+\n+                        // Attach the function to the impl block\n+                        let assoc_items = impl_def.get_or_create_assoc_item_list();\n+                        assoc_items.add_item(f.clone().into());\n+\n+                        // Update the impl block.\n+                        match ctx.config.snippet_cap {\n+                            Some(cap) => {\n+                                let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n+                                builder.replace_snippet(cap, old_range, snippet);\n+                            }\n+                            None => {\n+                                builder.replace(old_range, impl_def.syntax().to_string());\n+                            }\n+                        }\n+                    }\n+                    None => {\n+                        // Attach the function to the impl block\n+                        let name = &strukt_name.to_string();\n+                        let params = strukt.generic_param_list();\n+                        let ty_params = params.clone();\n+                        let impl_def = make::impl_(make::ext::ident_path(name), params, ty_params)\n+                            .clone_for_update();\n+                        let assoc_items = impl_def.get_or_create_assoc_item_list();\n+                        assoc_items.add_item(f.clone().into());\n+\n+                        // Insert the impl block.\n+                        match ctx.config.snippet_cap {\n+                            Some(cap) => {\n+                                let offset = strukt.syntax().text_range().end();\n+                                let snippet = render_snippet(cap, impl_def.syntax(), cursor);\n+                                let snippet = format!(\"\\n\\n{}\", snippet);\n+                                builder.insert_snippet(cap, offset, snippet);\n+                            }\n+                            None => {\n+                                let offset = strukt.syntax().text_range().end();\n+                                let snippet = format!(\"\\n\\n{}\", impl_def.syntax().to_string());\n+                                builder.insert(offset, snippet);\n+                            }\n+                        }\n+                    }\n+                }\n+            },\n+        )?;\n+    }\n+    Some(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::check_assist;\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_generate_delegate_create_impl_block() {\n+        check_assist(\n+            generate_delegate_methods,\n+            r#\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    ag$0e: Age,\n+}\"#,\n+            r#\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    age: Age,\n+}\n+\n+impl Person {\n+    $0fn age(&self) -> u8 {\n+        self.age.age()\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_delegate_update_impl_block() {\n+        check_assist(\n+            generate_delegate_methods,\n+            r#\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    ag$0e: Age,\n+}\n+\n+impl Person {}\"#,\n+            r#\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    age: Age,\n+}\n+\n+impl Person {\n+    $0fn age(&self) -> u8 {\n+        self.age.age()\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_delegate_tuple_struct() {\n+        check_assist(\n+            generate_delegate_methods,\n+            r#\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person(A$0ge);\"#,\n+            r#\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person(Age);\n+\n+impl Person {\n+    $0fn age(&self) -> u8 {\n+        self.0.age()\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_generate_delegate_enable_all_attributes() {\n+        check_assist(\n+            generate_delegate_methods,\n+            r#\"\n+struct Age<T>(T);\n+impl<T> Age<T> {\n+    pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> T {\n+        self.0\n+    }\n+}\n+\n+struct Person<T> {\n+    ag$0e: Age<T>,\n+}\"#,\n+            r#\"\n+struct Age<T>(T);\n+impl<T> Age<T> {\n+    pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> T {\n+        self.0\n+    }\n+}\n+\n+struct Person<T> {\n+    age: Age<T>,\n+}\n+\n+impl<T> Person<T> {\n+    $0pub(crate) async fn age<J, 'a>(&'a mut self, ty: T, arg: J) -> T {\n+        self.age.age(ty, arg)\n+    }\n+}\"#,\n+        );\n+    }\n+}"}, {"sha": "bd543ff3e476b6fa38f21027f0470d90a64e3fe3", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "patch": "@@ -144,6 +144,7 @@ mod handlers {\n     mod generate_is_empty_from_len;\n     mod generate_new;\n     mod generate_setter;\n+    mod generate_delegate_methods;\n     mod add_return_type;\n     mod inline_call;\n     mod inline_local_variable;\n@@ -210,6 +211,7 @@ mod handlers {\n             generate_constant::generate_constant,\n             generate_default_from_enum_variant::generate_default_from_enum_variant,\n             generate_default_from_new::generate_default_from_new,\n+            generate_delegate_methods::generate_delegate_methods,\n             generate_deref::generate_deref,\n             generate_derive::generate_derive,\n             generate_enum_is_method::generate_enum_is_method,"}, {"sha": "fba7736633ad1db238b5ae83b7e56d105a7170f0", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "patch": "@@ -728,6 +728,43 @@ impl Default for Example {\n     )\n }\n \n+#[test]\n+fn doctest_generate_delegate_methods() {\n+    check_doc_test(\n+        \"generate_delegate_methods\",\n+        r#####\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    ag$0e: Age,\n+}\n+\"#####,\n+        r#####\"\n+struct Age(u8);\n+impl Age {\n+    fn age(&self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+struct Person {\n+    age: Age,\n+}\n+\n+impl Person {\n+    $0fn age(&self) -> u8 {\n+        self.age.age()\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_deref() {\n     check_doc_test("}, {"sha": "c1092b97c2218fb76aa7b7b4158fc7db1596b890", "filename": "crates/ide_assists/src/utils.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fide_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils.rs?ref=e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "patch": "@@ -525,3 +525,19 @@ pub(crate) fn trimmed_text_range(source_file: &SourceFile, initial_range: TextRa\n     }\n     trimmed_range\n }\n+\n+/// Convert a list of function params to a list of arguments that can be passed\n+/// into a function call.\n+pub(crate) fn convert_param_list_to_arg_list(list: ast::ParamList) -> ast::ArgList {\n+    let mut args = vec![];\n+    for param in list.params() {\n+        if let Some(ast::Pat::IdentPat(pat)) = param.pat() {\n+            if let Some(name) = pat.name() {\n+                let name = name.to_string();\n+                let expr = make::expr_path(make::ext::ident_path(&name));\n+                args.push(expr);\n+            }\n+        }\n+    }\n+    make::arg_list(args)\n+}"}, {"sha": "e67ac69073ea5a8dbeb5d9da4ff514f546058fb7", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e52d47a3b8211c46de9321f76a59ce5e9811a8f8/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=e52d47a3b8211c46de9321f76a59ce5e9811a8f8", "patch": "@@ -44,6 +44,15 @@ pub mod ext {\n         Some(path)\n     }\n \n+    pub fn field_from_idents<'a>(\n+        parts: impl std::iter::IntoIterator<Item = &'a str>,\n+    ) -> Option<ast::Expr> {\n+        let mut iter = parts.into_iter();\n+        let base = expr_path(ext::ident_path(iter.next()?));\n+        let expr = iter.fold(base, |base, s| expr_field(base, s));\n+        Some(expr)\n+    }\n+\n     pub fn expr_unreachable() -> ast::Expr {\n         expr_from_text(\"unreachable!()\")\n     }\n@@ -124,6 +133,22 @@ pub fn assoc_item_list() -> ast::AssocItemList {\n     ast_from_text(\"impl C for D {}\")\n }\n \n+pub fn impl_(\n+    ty: ast::Path,\n+    params: Option<ast::GenericParamList>,\n+    ty_params: Option<ast::GenericParamList>,\n+) -> ast::Impl {\n+    let params = match params {\n+        Some(params) => params.to_string(),\n+        None => String::new(),\n+    };\n+    let ty_params = match ty_params {\n+        Some(params) => params.to_string(),\n+        None => String::new(),\n+    };\n+    ast_from_text(&format!(\"impl{} {}{} {{}}\", params, ty, ty_params))\n+}\n+\n pub fn impl_trait(trait_: ast::Path, ty: ast::Path) -> ast::Impl {\n     ast_from_text(&format!(\"impl {} for {} {{}}\", trait_, ty))\n }\n@@ -645,7 +670,7 @@ pub fn fn_(\n     is_async: bool,\n ) -> ast::Fn {\n     let type_params = match type_params {\n-        Some(type_params) => format!(\"<{}>\", type_params),\n+        Some(type_params) => format!(\"{}\", type_params),\n         None => \"\".into(),\n     };\n     let ret_type = match ret_type {"}]}