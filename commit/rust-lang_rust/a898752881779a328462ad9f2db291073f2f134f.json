{"sha": "a898752881779a328462ad9f2db291073f2f134f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4OTg3NTI4ODE3NzlhMzI4NDYyYWQ5ZjJkYjI5MTA3M2YyZjEzNGY=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-12T17:18:14Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-12T17:19:19Z"}, "message": "Reimplement import merging by making it recursive properly nesting all levels", "tree": {"sha": "4b6894416bf4f2a875b5bd4a3bc20510a00821d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b6894416bf4f2a875b5bd4a3bc20510a00821d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a898752881779a328462ad9f2db291073f2f134f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a898752881779a328462ad9f2db291073f2f134f", "html_url": "https://github.com/rust-lang/rust/commit/a898752881779a328462ad9f2db291073f2f134f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a898752881779a328462ad9f2db291073f2f134f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8623461a57e7882ac47b5da13a1a03efa58f603", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8623461a57e7882ac47b5da13a1a03efa58f603", "html_url": "https://github.com/rust-lang/rust/commit/c8623461a57e7882ac47b5da13a1a03efa58f603"}], "stats": {"total": 347, "additions": 264, "deletions": 83}, "files": [{"sha": "fe33cee53c41d1c7b41cac23b0c2430647258bb1", "filename": "crates/assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a898752881779a328462ad9f2db291073f2f134f/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a898752881779a328462ad9f2db291073f2f134f/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=a898752881779a328462ad9f2db291073f2f134f", "patch": "@@ -95,7 +95,7 @@ use std::fmt::Debug;\n use std::fmt<|>::Display;\n \",\n             r\"\n-use std::fmt::{Display, Debug};\n+use std::fmt::{Debug, Display};\n \",\n         );\n     }\n@@ -122,7 +122,7 @@ use std::fmt::{self, Display};\n use std::{fmt, <|>fmt::Display};\n \",\n             r\"\n-use std::{fmt::{Display, self}};\n+use std::{fmt::{self, Display}};\n \",\n         );\n     }\n@@ -210,13 +210,17 @@ use std::{fmt<|>::Debug, fmt::Display};\n use std::{fmt::{Debug, Display}};\n \",\n         );\n+    }\n+\n+    #[test]\n+    fn test_merge_nested2() {\n         check_assist(\n             merge_imports,\n             r\"\n use std::{fmt::Debug, fmt<|>::Display};\n \",\n             r\"\n-use std::{fmt::{Display, Debug}};\n+use std::{fmt::{Debug, Display}};\n \",\n         );\n     }\n@@ -310,9 +314,7 @@ use foo::<|>{\n };\n \",\n             r\"\n-use foo::{\n-    FooBar,\n-bar::baz};\n+use foo::{FooBar, bar::baz};\n \",\n         )\n     }"}, {"sha": "093c3b101da8e33ede38888c2ce8d504cec2efdc", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a898752881779a328462ad9f2db291073f2f134f/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a898752881779a328462ad9f2db291073f2f134f/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=a898752881779a328462ad9f2db291073f2f134f", "patch": "@@ -312,7 +312,7 @@ impl std::fmt<|> for Foo {\n }\n     \",\n             r\"\n-use std::fmt::{Debug, self};\n+use std::fmt::{self, Debug};\n \n impl fmt for Foo {\n }\n@@ -330,9 +330,8 @@ use std::fmt::{Debug, nested::{Display}};\n impl std::fmt::nested<|> for Foo {\n }\n \",\n-            // FIXME(veykril): should be nested::{self, Display} here\n             r\"\n-use std::fmt::{Debug, nested::{Display}, nested};\n+use std::fmt::{Debug, nested::{self, Display}};\n \n impl nested for Foo {\n }\n@@ -350,9 +349,8 @@ use std::fmt::{Debug, nested::{self, Display}};\n impl std::fmt::nested<|> for Foo {\n }\n \",\n-            // FIXME(veykril): nested is duplicated now\n             r\"\n-use std::fmt::{Debug, nested::{self, Display}, nested};\n+use std::fmt::{Debug, nested::{self, Display}};\n \n impl nested for Foo {\n }\n@@ -371,7 +369,7 @@ impl std::fmt::nested::Debug<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{Debug, nested::{Display}, nested::Debug};\n+use std::fmt::{Debug, nested::{Debug, Display}};\n \n impl Debug for Foo {\n }\n@@ -409,7 +407,7 @@ impl std::fmt::Display<|> for Foo {\n }\n \",\n             r\"\n-use std::fmt::{nested::Debug, Display};\n+use std::fmt::{Display, nested::Debug};\n \n impl Display for Foo {\n }\n@@ -429,12 +427,8 @@ use crate::{\n \n fn foo() { crate::ty::lower<|>::trait_env() }\n \",\n-            // FIXME(veykril): formatting broke here\n             r\"\n-use crate::{\n-    ty::{Substs, Ty},\n-    AssocItem,\n-ty::lower};\n+use crate::{AssocItem, ty::{Substs, Ty, lower}};\n \n fn foo() { lower::trait_env() }\n \",\n@@ -633,7 +627,7 @@ fn main() {\n }\n     \",\n             r\"\n-use std::fmt::{Display, self};\n+use std::fmt::{self, Display};\n \n fn main() {\n     fmt;"}, {"sha": "4f5fd317a3cb7592f593c5f391affad088d346e7", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 248, "deletions": 64, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/a898752881779a328462ad9f2db291073f2f134f/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a898752881779a328462ad9f2db291073f2f134f/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=a898752881779a328462ad9f2db291073f2f134f", "patch": "@@ -1,17 +1,18 @@\n //! Handle syntactic aspects of inserting a new `use`.\n-use std::iter::{self, successors};\n+use std::{\n+    cmp::Ordering,\n+    iter::{self, successors},\n+};\n \n-use algo::skip_trivia_token;\n use ast::{\n     edit::{AstNodeEdit, IndentLevel},\n     PathSegmentKind, VisibilityOwner,\n };\n use syntax::{\n     algo,\n     ast::{self, make, AstNode},\n-    Direction, InsertPosition, SyntaxElement, SyntaxNode, T,\n+    InsertPosition, SyntaxElement, SyntaxNode,\n };\n-use test_utils::mark;\n \n #[derive(Debug)]\n pub enum ImportScope {\n@@ -163,52 +164,138 @@ pub(crate) fn try_merge_imports(\n     Some(old.with_use_tree(merged))\n }\n \n-/// Simple function that checks if a UseTreeList is deeper than one level\n-fn use_tree_list_is_nested(tl: &ast::UseTreeList) -> bool {\n-    tl.use_trees().any(|use_tree| {\n-        use_tree.use_tree_list().is_some() || use_tree.path().and_then(|p| p.qualifier()).is_some()\n-    })\n+/// Orders paths in the following way:\n+/// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n+/// FIXME: rustfmt sort lowercase idents before uppercase\n+fn path_cmp(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    let a = segment_iter(a);\n+    let b = segment_iter(b);\n+    let mut a_clone = a.clone();\n+    let mut b_clone = b.clone();\n+    match (\n+        a_clone.next().and_then(|ps| ps.self_token()).is_some() && a_clone.next().is_none(),\n+        b_clone.next().and_then(|ps| ps.self_token()).is_some() && b_clone.next().is_none(),\n+    ) {\n+        (true, true) => Ordering::Equal,\n+        (true, false) => Ordering::Less,\n+        (false, true) => Ordering::Greater,\n+        (false, false) => {\n+            // cmp_by would be useful for us here but that is currently unstable\n+            // cmp doesnt work due the lifetimes on text's return type\n+            a.zip(b)\n+                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n+                .find_map(|(a, b)| match a.text().cmp(b.text()) {\n+                    ord @ Ordering::Greater | ord @ Ordering::Less => Some(ord),\n+                    Ordering::Equal => None,\n+                })\n+                .unwrap_or(Ordering::Equal)\n+        }\n+    }\n+}\n+\n+fn path_cmp_opt(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n+    match (a, b) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(a), Some(b)) => path_cmp(&a, &b),\n+    }\n }\n \n-// FIXME: currently this merely prepends the new tree into old, ideally it would insert the items in a sorted fashion\n pub(crate) fn try_merge_trees(\n     old: &ast::UseTree,\n     new: &ast::UseTree,\n-    merge_behaviour: MergeBehaviour,\n+    merge: MergeBehaviour,\n ) -> Option<ast::UseTree> {\n     let lhs_path = old.path()?;\n     let rhs_path = new.path()?;\n \n     let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n     let lhs = old.split_prefix(&lhs_prefix);\n     let rhs = new.split_prefix(&rhs_prefix);\n-    let lhs_tl = lhs.use_tree_list()?;\n-    let rhs_tl = rhs.use_tree_list()?;\n-\n-    // if we are only allowed to merge the last level check if the split off paths are only one level deep\n-    if merge_behaviour == MergeBehaviour::Last\n-        && (use_tree_list_is_nested(&lhs_tl) || use_tree_list_is_nested(&rhs_tl))\n-    {\n-        mark::hit!(test_last_merge_too_long);\n-        return None;\n-    }\n+    recursive_merge(&lhs, &rhs, merge).map(|(merged, _)| merged)\n+}\n \n-    let should_insert_comma = lhs_tl\n-        .r_curly_token()\n-        .and_then(|it| skip_trivia_token(it.prev_token()?, Direction::Prev))\n-        .map(|it| it.kind())\n-        != Some(T![,]);\n-    let mut to_insert: Vec<SyntaxElement> = Vec::new();\n-    if should_insert_comma {\n-        to_insert.push(make::token(T![,]).into());\n-        to_insert.push(make::tokens::single_space().into());\n-    }\n-    to_insert.extend(\n-        rhs_tl.syntax().children_with_tokens().filter(|it| !matches!(it.kind(), T!['{'] | T!['}'])),\n-    );\n-    let pos = InsertPosition::Before(lhs_tl.r_curly_token()?.into());\n-    let use_tree_list = lhs_tl.insert_children(pos, to_insert);\n-    Some(lhs.with_use_tree_list(use_tree_list))\n+/// Returns the merged tree and the number of children it has, which is required to check if the tree is allowed to be used for MergeBehaviour::Last\n+fn recursive_merge(\n+    lhs: &ast::UseTree,\n+    rhs: &ast::UseTree,\n+    merge: MergeBehaviour,\n+) -> Option<(ast::UseTree, usize)> {\n+    let mut use_trees = lhs\n+        .use_tree_list()\n+        .into_iter()\n+        .flat_map(|list| list.use_trees())\n+        // check if any of the use trees are nested, if they are and the behaviour is last only we are not allowed to merge this\n+        .map(|tree| match merge == MergeBehaviour::Last && tree.use_tree_list().is_some() {\n+            true => None,\n+            false => Some(tree),\n+        })\n+        .collect::<Option<Vec<_>>>()?;\n+    use_trees.sort_unstable_by(|a, b| path_cmp_opt(a.path(), b.path()));\n+    for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n+        let rhs_path = rhs_t.path();\n+        match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n+            Ok(idx) => {\n+                let lhs_path = use_trees[idx].path()?;\n+                let rhs_path = rhs_path?;\n+                let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n+                if lhs_prefix == lhs_path && rhs_prefix == rhs_path {\n+                    let tree_is_self =\n+                        |tree: ast::UseTree| tree.path().map(path_is_self).unwrap_or(false);\n+                    // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n+                    // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n+                    if use_trees[idx]\n+                        .use_tree_list()\n+                        .xor(rhs_t.use_tree_list())\n+                        .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n+                        .unwrap_or(false)\n+                    {\n+                        continue;\n+                    }\n+\n+                    // glob imports arent part of the use-tree lists so we need to special handle them here as well\n+                    // this special handling is only required for when we merge a module import into a glob import of said module\n+                    // see the `merge_self_glob` or `merge_mod_into_glob` tests\n+                    if use_trees[idx].star_token().is_some() || rhs_t.star_token().is_some() {\n+                        use_trees[idx] = make::use_tree(\n+                            make::path_unqualified(make::path_segment_self()),\n+                            None,\n+                            None,\n+                            false,\n+                        );\n+                        use_trees.insert(\n+                            idx,\n+                            make::use_tree(\n+                                make::path_unqualified(make::path_segment_self()),\n+                                None,\n+                                None,\n+                                true,\n+                            ),\n+                        );\n+                        continue;\n+                    }\n+                }\n+                let lhs = use_trees[idx].split_prefix(&lhs_prefix);\n+                let rhs = rhs_t.split_prefix(&rhs_prefix);\n+                match recursive_merge(&lhs, &rhs, merge) {\n+                    Some((_, count))\n+                        if merge == MergeBehaviour::Last && use_trees.len() > 1 && count > 1 =>\n+                    {\n+                        return None\n+                    }\n+                    Some((use_tree, _)) => use_trees[idx] = use_tree,\n+                    None => use_trees.insert(idx, rhs_t),\n+                }\n+            }\n+            Err(idx) => {\n+                use_trees.insert(idx, rhs_t);\n+            }\n+        }\n+    }\n+    let count = use_trees.len();\n+    let tl = make::use_tree_list(use_trees);\n+    Some((lhs.with_use_tree_list(tl), count))\n }\n \n /// Traverses both paths until they differ, returning the common prefix of both.\n@@ -235,6 +322,23 @@ fn common_prefix(lhs: &ast::Path, rhs: &ast::Path) -> Option<(ast::Path, ast::Pa\n     res\n }\n \n+fn path_is_self(path: ast::Path) -> bool {\n+    path.segment().and_then(|seg| seg.self_token()).is_some() && path.qualifier().is_none()\n+}\n+\n+fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n+    first_path(path).segment()\n+}\n+\n+fn first_path(path: &ast::Path) -> ast::Path {\n+    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n+}\n+\n+fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n+    // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n+    successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n+}\n+\n /// What type of merges are allowed.\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum MergeBehaviour {\n@@ -279,19 +383,6 @@ impl ImportGroup {\n     }\n }\n \n-fn first_segment(path: &ast::Path) -> Option<ast::PathSegment> {\n-    first_path(path).segment()\n-}\n-\n-fn first_path(path: &ast::Path) -> ast::Path {\n-    successors(Some(path.clone()), ast::Path::qualifier).last().unwrap()\n-}\n-\n-fn segment_iter(path: &ast::Path) -> impl Iterator<Item = ast::PathSegment> + Clone {\n-    // cant make use of SyntaxNode::siblings, because the returned Iterator is not clone\n-    successors(first_segment(path), |p| p.parent_path().parent_path().and_then(|p| p.segment()))\n-}\n-\n #[derive(PartialEq, Eq)]\n enum AddBlankLine {\n     Before,\n@@ -594,7 +685,7 @@ use std::io;\",\n         check_full(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::Qux;\",\n-            r\"use std::foo::bar::{Qux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Qux};\",\n         )\n     }\n \n@@ -603,7 +694,7 @@ use std::io;\",\n         check_last(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::Qux;\",\n-            r\"use std::foo::bar::{Qux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Qux};\",\n         )\n     }\n \n@@ -612,7 +703,7 @@ use std::io;\",\n         check_full(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::{Qux, Quux};\",\n-            r\"use std::foo::bar::{Qux, Quux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Quux, Qux};\",\n         )\n     }\n \n@@ -621,7 +712,7 @@ use std::io;\",\n         check_last(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::{Qux, Quux};\",\n-            r\"use std::foo::bar::{Qux, Quux, Baz};\",\n+            r\"use std::foo::bar::{Baz, Quux, Qux};\",\n         )\n     }\n \n@@ -630,7 +721,7 @@ use std::io;\",\n         check_full(\n             \"std::foo::bar::Baz\",\n             r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n-            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}, Baz};\",\n+            r\"use std::foo::bar::{Baz, Qux, quux::{Fez, Fizz}};\",\n         )\n     }\n \n@@ -644,6 +735,15 @@ use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n         )\n     }\n \n+    #[test]\n+    fn merge_groups_full_nested_deep() {\n+        check_full(\n+            \"std::foo::bar::quux::Baz\",\n+            r\"use std::foo::bar::{Qux, quux::{Fez, Fizz}};\",\n+            r\"use std::foo::bar::{Qux, quux::{Baz, Fez, Fizz}};\",\n+        )\n+    }\n+\n     #[test]\n     fn merge_groups_skip_pub() {\n         check_full(\n@@ -670,34 +770,63 @@ use std::io;\",\n         check_last(\n             \"std::fmt::Result\",\n             r\"use std::{fmt, io};\",\n-            r\"use std::{self, fmt::Result};\n+            r\"use std::fmt::{self, Result};\n use std::io;\",\n         )\n     }\n \n+    #[test]\n+    fn merge_into_module_import() {\n+        check_full(\n+            \"std::fmt::Result\",\n+            r\"use std::{fmt, io};\",\n+            r\"use std::{fmt::{self, Result}, io};\",\n+        )\n+    }\n+\n     #[test]\n     fn merge_groups_self() {\n         check_full(\"std::fmt::Debug\", r\"use std::fmt;\", r\"use std::fmt::{self, Debug};\")\n     }\n \n     #[test]\n-    fn merge_self_glob() {\n+    fn merge_mod_into_glob() {\n         check_full(\n             \"token::TokenKind\",\n             r\"use token::TokenKind::*;\",\n             r\"use token::TokenKind::{self::*, self};\",\n         )\n+        // FIXME: have it emit `use token::TokenKind::{self, *}`?\n+    }\n+\n+    #[test]\n+    fn merge_self_glob() {\n+        check_full(\"self\", r\"use self::*;\", r\"use self::{self::*, self};\")\n+        // FIXME: have it emit `use {self, *}`?\n+    }\n+\n+    #[test]\n+    #[ignore] // FIXME: Support this\n+    fn merge_partial_path() {\n+        check_full(\n+            \"ast::Foo\",\n+            r\"use syntax::{ast, algo};\",\n+            r\"use syntax::{ast::{self, Foo}, algo};\",\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_glob_nested() {\n+        check_full(\n+            \"foo::bar::quux::Fez\",\n+            r\"use foo::bar::{Baz, quux::*;\",\n+            r\"use foo::bar::{Baz, quux::{self::*, Fez}}\",\n+        )\n     }\n \n     #[test]\n     fn merge_last_too_long() {\n-        mark::check!(test_last_merge_too_long);\n-        check_last(\n-            \"foo::bar\",\n-            r\"use foo::bar::baz::Qux;\",\n-            r\"use foo::bar;\n-use foo::bar::baz::Qux;\",\n-        );\n+        check_last(\"foo::bar\", r\"use foo::bar::baz::Qux;\", r\"use foo::bar::{self, baz::Qux};\");\n     }\n \n     #[test]\n@@ -710,6 +839,42 @@ use foo::bar::baz::Qux;\",\n         );\n     }\n \n+    #[test]\n+    fn merge_last_fail() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::{baz::{Qux, Fez}};\",\n+            r\"use foo::bar::{baaz::{Quux, Feez}};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_last_fail1() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::{baz::{Qux, Fez}};\",\n+            r\"use foo::bar::baaz::{Quux, Feez};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_last_fail2() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::baz::{Qux, Fez};\",\n+            r\"use foo::bar::{baaz::{Quux, Feez}};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_last_fail3() {\n+        check_merge_only_fail(\n+            r\"use foo::bar::baz::{Qux, Fez};\",\n+            r\"use foo::bar::baaz::{Quux, Feez};\",\n+            MergeBehaviour::Last,\n+        );\n+    }\n+\n     fn check(\n         path: &str,\n         ra_fixture_before: &str,\n@@ -742,4 +907,23 @@ use foo::bar::baz::Qux;\",\n     fn check_none(path: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         check(path, ra_fixture_before, ra_fixture_after, None)\n     }\n+\n+    fn check_merge_only_fail(ra_fixture0: &str, ra_fixture1: &str, mb: MergeBehaviour) {\n+        let use0 = ast::SourceFile::parse(ra_fixture0)\n+            .tree()\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::Use::cast)\n+            .unwrap();\n+\n+        let use1 = ast::SourceFile::parse(ra_fixture1)\n+            .tree()\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::Use::cast)\n+            .unwrap();\n+\n+        let result = try_merge_imports(&use0, &use1, mb);\n+        assert_eq!(result, None);\n+    }\n }"}, {"sha": "45cf31f1308046a29ecb7aff2703caa5b391b58b", "filename": "crates/syntax/src/ast/edit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a898752881779a328462ad9f2db291073f2f134f/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a898752881779a328462ad9f2db291073f2f134f/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fedit.rs?ref=a898752881779a328462ad9f2db291073f2f134f", "patch": "@@ -347,6 +347,7 @@ impl ast::UseTree {\n         self.clone()\n     }\n \n+    /// Splits off the given prefix, making it the path component of the use tree, appending the rest of the path to all UseTreeList items.\n     #[must_use]\n     pub fn split_prefix(&self, prefix: &ast::Path) -> ast::UseTree {\n         let suffix = if self.path().as_ref() == Some(prefix) && self.use_tree_list().is_none() {"}]}