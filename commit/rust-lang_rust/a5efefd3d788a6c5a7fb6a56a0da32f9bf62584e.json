{"sha": "a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZWZlZmQzZDc4OGE2YzVhN2ZiNmE1NmEwZGEzMmY5YmY2MjU4NGU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-11-24T13:52:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-11-24T15:11:40Z"}, "message": "Properly infer tuple struct patterns when encountering ellipsis", "tree": {"sha": "727dfd24c866d9859c6fc497474f0637159aba1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/727dfd24c866d9859c6fc497474f0637159aba1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e", "html_url": "https://github.com/rust-lang/rust/commit/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35dd62e915905b6a93e2069a6d155cdf00cd254a", "url": "https://api.github.com/repos/rust-lang/rust/commits/35dd62e915905b6a93e2069a6d155cdf00cd254a", "html_url": "https://github.com/rust-lang/rust/commit/35dd62e915905b6a93e2069a6d155cdf00cd254a"}], "stats": {"total": 79, "additions": 70, "deletions": 9}, "files": [{"sha": "b70ec55eb5c50bf9a0f9b41b35981112933a623e", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e", "patch": "@@ -23,6 +23,7 @@ impl<'a> InferenceContext<'a> {\n         expected: &Ty,\n         default_bm: BindingMode,\n         id: PatId,\n+        ellipsis: Option<usize>,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n         let var_data = def.map(|it| variant_data(self.db.upcast(), it));\n@@ -34,8 +35,15 @@ impl<'a> InferenceContext<'a> {\n         let substs = ty.substs().unwrap_or_else(Substs::empty);\n \n         let field_tys = def.map(|it| self.db.field_types(it)).unwrap_or_default();\n+        let (pre, post) = match ellipsis {\n+            Some(idx) => subpats.split_at(idx),\n+            None => (&subpats[..], &[][..]),\n+        };\n+        let post_idx_offset = field_tys.iter().count() - post.len();\n \n-        for (i, &subpat) in subpats.iter().enumerate() {\n+        let pre_iter = pre.iter().enumerate();\n+        let post_iter = (post_idx_offset..).zip(post.iter());\n+        for (i, &subpat) in pre_iter.chain(post_iter) {\n             let expected_ty = var_data\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n@@ -111,23 +119,23 @@ impl<'a> InferenceContext<'a> {\n         let expected = expected;\n \n         let ty = match &body[pat] {\n-            Pat::Tuple { ref args, ellipsis } => {\n+            &Pat::Tuple { ref args, ellipsis } => {\n                 let expectations = match expected.as_tuple() {\n                     Some(parameters) => &*parameters.0,\n                     _ => &[],\n                 };\n \n                 let (pre, post) = match ellipsis {\n-                    &Some(idx) => args.split_at(idx),\n+                    Some(idx) => args.split_at(idx),\n                     None => (&args[..], &[][..]),\n                 };\n-                let uncovered_range = pre.len()..expectations.len().saturating_sub(post.len());\n+                let n_uncovered_patterns = expectations.len().saturating_sub(args.len());\n                 let mut expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n                 let mut infer_pat = |(&pat, ty)| self.infer_pat(pat, ty, default_bm);\n \n-                let mut inner_tys = Vec::with_capacity(expectations.len());\n+                let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n                 inner_tys.extend(pre.iter().zip(expectations_iter.by_ref()).map(&mut infer_pat));\n-                inner_tys.extend(expectations_iter.by_ref().take(uncovered_range.len()).cloned());\n+                inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n                 inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n \n                 Ty::apply(\n@@ -159,9 +167,14 @@ impl<'a> InferenceContext<'a> {\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::apply_one(TypeCtor::Ref(*mutability), subty)\n             }\n-            Pat::TupleStruct { path: p, args: subpats, .. } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm, pat)\n-            }\n+            Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n+                p.as_ref(),\n+                subpats,\n+                expected,\n+                default_bm,\n+                pat,\n+                *ellipsis,\n+            ),\n             Pat::Record { path: p, args: fields, ellipsis: _ } => {\n                 self.infer_record_pat(p.as_ref(), fields, expected, default_bm, pat)\n             }"}, {"sha": "5a5f48fd05b28a8234c5f335f368ef80f9847204", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=a5efefd3d788a6c5a7fb6a56a0da32f9bf62584e", "patch": "@@ -726,3 +726,51 @@ fn foo(tuple: (u8, i16, f32)) {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn tuple_struct_ellipsis_pattern() {\n+    check_infer(\n+        r#\"\n+struct Tuple(u8, i16, f32);\n+fn foo(tuple: Tuple) {\n+    match tuple {\n+        Tuple(.., b, c) => {},\n+        Tuple(a, .., c) => {},\n+        Tuple(a, b, ..) => {},\n+        Tuple(a, b) => {/*too short*/}\n+        Tuple(a, b, c, d) => {/*too long*/}\n+        _ => {}\n+    }\n+}\"#,\n+        expect![[r#\"\n+            35..40 'tuple': Tuple\n+            49..268 '{     ...   } }': ()\n+            55..266 'match ...     }': ()\n+            61..66 'tuple': Tuple\n+            77..92 'Tuple(.., b, c)': Tuple\n+            87..88 'b': i16\n+            90..91 'c': f32\n+            96..98 '{}': ()\n+            108..123 'Tuple(a, .., c)': Tuple\n+            114..115 'a': u8\n+            121..122 'c': f32\n+            127..129 '{}': ()\n+            139..154 'Tuple(a, b, ..)': Tuple\n+            145..146 'a': u8\n+            148..149 'b': i16\n+            158..160 '{}': ()\n+            170..181 'Tuple(a, b)': Tuple\n+            176..177 'a': u8\n+            179..180 'b': i16\n+            185..200 '{/*too short*/}': ()\n+            209..226 'Tuple(... c, d)': Tuple\n+            215..216 'a': u8\n+            218..219 'b': i16\n+            221..222 'c': f32\n+            224..225 'd': {unknown}\n+            230..244 '{/*too long*/}': ()\n+            253..254 '_': Tuple\n+            258..260 '{}': ()\n+        \"#]],\n+    );\n+}"}]}