{"sha": "8e15640adacd1f0cab8617d62f445024915e5214", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMTU2NDBhZGFjZDFmMGNhYjg2MTdkNjJmNDQ1MDI0OTE1ZTUyMTQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-26T23:13:59Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-26T23:16:18Z"}, "message": "Refactor operator precedence code\n\nUse functions instead of a dynamically created table to determine\noperator precedence. Gets rid of a FIXME in syntax::parse::prec.\nChange precedences from int to uint while we're at it, since\ndon't use negative precedences.", "tree": {"sha": "972289fe20071a381a288996d4dcfd4914cbd804", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/972289fe20071a381a288996d4dcfd4914cbd804"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e15640adacd1f0cab8617d62f445024915e5214", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e15640adacd1f0cab8617d62f445024915e5214", "html_url": "https://github.com/rust-lang/rust/commit/8e15640adacd1f0cab8617d62f445024915e5214", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e15640adacd1f0cab8617d62f445024915e5214/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f92538e38490725ce7fda7f2b6c4b1f4e9ecea8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f92538e38490725ce7fda7f2b6c4b1f4e9ecea8", "html_url": "https://github.com/rust-lang/rust/commit/1f92538e38490725ce7fda7f2b6c4b1f4e9ecea8"}], "stats": {"total": 129, "additions": 74, "deletions": 55}, "files": [{"sha": "2c6d8299554097944c8d9fcc3a66e8a8f62eb896", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=8e15640adacd1f0cab8617d62f445024915e5214", "patch": "@@ -344,6 +344,23 @@ fn is_self(d: ast::def) -> bool {\n     _                  { false }\n   }\n }\n+\n+#[doc = \"Maps a binary operator to its precedence\"]\n+fn operator_prec(op: ast::binop) -> uint {\n+  alt op {\n+      mul | div | rem   { 12u }\n+      // 'as' sits between here with 11\n+      add | subtract    { 10u }\n+      lsl | lsr | asr   {  9u }\n+      bitand            {  8u }\n+      bitxor            {  7u }\n+      bitor             {  6u }\n+      lt | le | ge | gt {  4u }\n+      eq | ne           {  3u }\n+      and               {  2u }\n+      or                {  1u }\n+  }\n+}\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "d1a997187dafc296d013eb52fd94fa00d8edd383", "filename": "src/librustsyntax/parse.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse.rs?ref=8e15640adacd1f0cab8617d62f445024915e5214", "patch": "@@ -130,7 +130,6 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n       mut buffer: [],\n       mut restriction: parser::UNRESTRICTED,\n       reader: rdr,\n-      binop_precs: prec::binop_prec_table(),\n       keywords: token::keyword_table(),\n       restricted_keywords: token::restricted_keyword_table()}\n }"}, {"sha": "99a6462bfca3b9e1c2a39044e63ee48e0e0b87fc", "filename": "src/librustsyntax/parse/classify.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fclassify.rs?ref=8e15640adacd1f0cab8617d62f445024915e5214", "patch": "@@ -1,6 +1,7 @@\n /*\n   Predicates on exprs and stmts that the pretty-printer and parser use\n  */\n+import ast_util::*;\n \n fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     alt e.node {\n@@ -31,14 +32,7 @@ fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n     }\n }\n \n-fn operator_prec(op: ast::binop) -> int {\n-    for vec::each(*parse::prec::binop_prec_table()) {|spec|\n-        if spec.op == op { ret spec.prec; }\n-    }\n-    core::unreachable();\n-}\n-\n-fn need_parens(expr: @ast::expr, outer_prec: int) -> bool {\n+fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n     alt expr.node {\n       ast::expr_binary(op, _, _) { operator_prec(op) < outer_prec }\n       ast::expr_cast(_, _) { parse::prec::as_prec < outer_prec }"}, {"sha": "6168d6e8b3c1b3bb793c2f4c0d9828ba8b1259df", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=8e15640adacd1f0cab8617d62f445024915e5214", "patch": "@@ -4,10 +4,10 @@ import std::map::{hashmap, str_hash};\n import token::{can_begin_expr, is_ident, is_plain_ident};\n import codemap::{span,fss_none};\n import util::interner;\n-import ast_util::{spanned, mk_sp, ident_to_path};\n+import ast_util::{spanned, mk_sp, ident_to_path, operator_prec};\n import ast::{node_id};\n import lexer::reader;\n-import prec::{op_spec, as_prec};\n+import prec::{as_prec, token_to_binop};\n import attr::{parse_outer_attrs_or_ext,\n               parse_inner_attrs_and_next,\n               parse_outer_attributes,\n@@ -57,7 +57,6 @@ type parser = @{\n     mut buffer: [{tok: token::token, span: span}],\n     mut restriction: restriction,\n     reader: reader,\n-    binop_precs: @[op_spec],\n     keywords: hashmap<str, ()>,\n     restricted_keywords: hashmap<str, ()>\n };\n@@ -1040,26 +1039,31 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n \n \n fn parse_binops(p: parser) -> @ast::expr {\n-    ret parse_more_binops(p, parse_prefix_expr(p), 0);\n+    ret parse_more_binops(p, parse_prefix_expr(p), 0u);\n }\n \n-fn parse_more_binops(p: parser, plhs: pexpr, min_prec: int) ->\n+fn parse_more_binops(p: parser, plhs: pexpr, min_prec: uint) ->\n    @ast::expr {\n     let lhs = to_expr(plhs);\n     if expr_is_complete(p, plhs) { ret lhs; }\n     let peeked = p.token;\n     if peeked == token::BINOP(token::OR) &&\n        p.restriction == RESTRICT_NO_BAR_OP { ret lhs; }\n-    for vec::each(*p.binop_precs) {|cur|\n-        if cur.prec > min_prec && cur.tok == peeked {\n-            p.bump();\n-            let expr = parse_prefix_expr(p);\n-            let rhs = parse_more_binops(p, expr, cur.prec);\n-            p.get_id(); // see ast_util::op_expr_callee_id\n-            let bin = mk_pexpr(p, lhs.span.lo, rhs.span.hi,\n-                              ast::expr_binary(cur.op, lhs, rhs));\n-            ret parse_more_binops(p, bin, min_prec);\n-        }\n+    let cur_opt   = token_to_binop(peeked);\n+    alt cur_opt {\n+     some(cur_op) {\n+       let cur_prec = operator_prec(cur_op);\n+       if cur_prec > min_prec {\n+          p.bump();\n+          let expr = parse_prefix_expr(p);\n+          let rhs = parse_more_binops(p, expr, cur_prec);\n+          p.get_id(); // see ast_util::op_expr_callee_id\n+          let bin = mk_pexpr(p, lhs.span.lo, rhs.span.hi,\n+                            ast::expr_binary(cur_op, lhs, rhs));\n+          ret parse_more_binops(p, bin, min_prec);\n+       }\n+     }\n+     _ {}\n     }\n     if as_prec > min_prec && eat_keyword(p, \"as\") {\n         let rhs = parse_ty(p, true);"}, {"sha": "6933ebb19d87a65369f8e3ec310d5533be3f4c9d", "filename": "src/librustsyntax/parse/prec.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse%2Fprec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fparse%2Fprec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fprec.rs?ref=8e15640adacd1f0cab8617d62f445024915e5214", "patch": "@@ -1,40 +1,44 @@\n export as_prec;\n export unop_prec;\n-export binop_prec_table;\n-export op_spec;\n+export token_to_binop;\n+\n+import token::*;\n+import token::token;\n+import ast::*;\n \n #[doc = \"Unary operators have higher precedence than binary\"]\n-const unop_prec: int = 100;\n+const unop_prec: uint = 100u;\n \n #[doc = \"\n Precedence of the `as` operator, which is a binary operator\n but is not represented in the precedence table.\n \"]\n-const as_prec: int = 11;\n-\n-type op_spec = {tok: token::token, op: ast::binop, prec: int};\n+const as_prec: uint = 11u;\n \n-// FIXME make this a const, don't store it in parser state\n-#[doc = \"The precedence of binary operators\"]\n-fn binop_prec_table() -> @[op_spec] {\n-    ret @[{tok: token::BINOP(token::STAR), op: ast::mul, prec: 12},\n-          {tok: token::BINOP(token::SLASH), op: ast::div, prec: 12},\n-          {tok: token::BINOP(token::PERCENT), op: ast::rem, prec: 12},\n-          // 'as' sits between here with 11\n-          {tok: token::BINOP(token::PLUS), op: ast::add, prec: 10},\n-          {tok: token::BINOP(token::MINUS), op: ast::subtract, prec: 10},\n-          {tok: token::BINOP(token::LSL), op: ast::lsl, prec: 9},\n-          {tok: token::BINOP(token::LSR), op: ast::lsr, prec: 9},\n-          {tok: token::BINOP(token::ASR), op: ast::asr, prec: 9},\n-          {tok: token::BINOP(token::AND), op: ast::bitand, prec: 8},\n-          {tok: token::BINOP(token::CARET), op: ast::bitxor, prec: 7},\n-          {tok: token::BINOP(token::OR), op: ast::bitor, prec: 6},\n-          {tok: token::LT, op: ast::lt, prec: 4},\n-          {tok: token::LE, op: ast::le, prec: 4},\n-          {tok: token::GE, op: ast::ge, prec: 4},\n-          {tok: token::GT, op: ast::gt, prec: 4},\n-          {tok: token::EQEQ, op: ast::eq, prec: 3},\n-          {tok: token::NE, op: ast::ne, prec: 3},\n-          {tok: token::ANDAND, op: ast::and, prec: 2},\n-          {tok: token::OROR, op: ast::or, prec: 1}];\n+#[doc = \"Maps a token to a record specifying the corresponding binary\n+         operator and its precedence\"]\n+fn token_to_binop(tok: token) -> option<ast::binop> {\n+  alt tok {\n+      BINOP(STAR)    { some(mul) }\n+      BINOP(SLASH)   { some(div) }\n+      BINOP(PERCENT) { some(rem) }\n+      // 'as' sits between here with 11\n+      BINOP(PLUS)    { some(add) }\n+      BINOP(MINUS)   { some(subtract) }\n+      BINOP(LSL)     { some(lsl) }\n+      BINOP(LSR)     { some(lsr) }\n+      BINOP(ASR)     { some(asr) }\n+      BINOP(AND)     { some(bitand) }\n+      BINOP(CARET)   { some(bitxor) }\n+      BINOP(OR)      { some(bitor) }\n+      LT             { some(lt) }\n+      LE             { some(le) }\n+      GE             { some(ge) }\n+      GT             { some(gt) }\n+      EQEQ           { some(eq) }\n+      NE             { some(ne) }\n+      ANDAND         { some(and) }\n+      OROR           { some(or) }\n+      _              { none }\n+  }\n }"}, {"sha": "6310a8b08a38b520df43ebd12fe802a8671c0804", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e15640adacd1f0cab8617d62f445024915e5214/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=8e15640adacd1f0cab8617d62f445024915e5214", "patch": "@@ -6,6 +6,7 @@ import pp::{break_offset, word, printer,\n             space, zerobreak, hardbreak, breaks, consistent,\n             inconsistent, eof};\n import diagnostic;\n+import ast_util::operator_prec;\n \n // The ps is stored here to prevent recursive type.\n enum ann_node {\n@@ -936,7 +937,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         print_op_maybe_parens(s, lhs, prec);\n         space(s.s);\n         word_space(s, ast_util::binop_to_str(op));\n-        print_op_maybe_parens(s, rhs, prec + 1);\n+        print_op_maybe_parens(s, rhs, prec + 1u);\n       }\n       ast::expr_unary(op, expr) {\n         word(s.s, ast_util::unop_to_str(op));\n@@ -1517,7 +1518,7 @@ fn print_view_item(s: ps, item: @ast::view_item) {\n     end(s); // end outer head-block\n }\n \n-fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: int) {\n+fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: uint) {\n     let add_them = need_parens(expr, outer_prec);\n     if add_them { popen(s); }\n     print_expr(s, expr);"}]}