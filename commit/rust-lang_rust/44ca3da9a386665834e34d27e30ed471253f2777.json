{"sha": "44ca3da9a386665834e34d27e30ed471253f2777", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0Y2EzZGE5YTM4NjY2NTgzNGUzNGQyN2UzMGVkNDcxMjUzZjI3Nzc=", "commit": {"author": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-05-21T01:10:02Z"}, "committer": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-05-21T01:10:02Z"}, "message": "Various minor improvements to Ipv6Addr::Display\n\n- Defer to Ipv4Addr::fmt when printing an Ipv4 address\n- Fast path: write directly to f without an intermediary buffer when\n  there are no alignment options\n- Simplify finding the inner zeroes-span", "tree": {"sha": "a71d11b7b297a165d19111557f3be838d5913530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a71d11b7b297a165d19111557f3be838d5913530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44ca3da9a386665834e34d27e30ed471253f2777", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44ca3da9a386665834e34d27e30ed471253f2777", "html_url": "https://github.com/rust-lang/rust/commit/44ca3da9a386665834e34d27e30ed471253f2777", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44ca3da9a386665834e34d27e30ed471253f2777/comments", "author": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "672b272077561ca7b5027a8aff9ea2957c7d4c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/672b272077561ca7b5027a8aff9ea2957c7d4c21", "html_url": "https://github.com/rust-lang/rust/commit/672b272077561ca7b5027a8aff9ea2957c7d4c21"}], "stats": {"total": 158, "additions": 78, "deletions": 80}, "files": [{"sha": "d50230a8859a1ce659d97ac7de87f18c2e769988", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/44ca3da9a386665834e34d27e30ed471253f2777/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44ca3da9a386665834e34d27e30ed471253f2777/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=44ca3da9a386665834e34d27e30ed471253f2777", "patch": "@@ -7,9 +7,9 @@\n )]\n \n use crate::cmp::Ordering;\n-use crate::fmt;\n+use crate::fmt::{self, Write as FmtWrite};\n use crate::hash;\n-use crate::io::Write;\n+use crate::io::Write as IoWrite;\n use crate::sys::net::netc as c;\n use crate::sys_common::{AsInner, FromInner};\n \n@@ -1525,102 +1525,100 @@ impl Ipv6Addr {\n     }\n }\n \n+/// Write an Ipv6Addr, conforming to the canonical style described by\n+/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Note: The calls to write should never fail, hence the unwraps in the function\n-        // Long enough for the longest possible IPv6: 39\n-        const IPV6_BUF_LEN: usize = 39;\n-        let mut buf = [0u8; IPV6_BUF_LEN];\n-        let mut buf_slice = &mut buf[..];\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write out the IP address to\n+        // f. Otherwise, write it to a local buffer, then use f.pad.\n+        if f.precision().is_none() && f.width().is_none() {\n+            let segments = self.segments();\n+\n+            // Special case for :: and ::1; otherwise they get written with the\n+            // IPv4 formatter\n+            if self.is_unspecified() {\n+                f.write_str(\"::\")\n+            } else if self.is_loopback() {\n+                f.write_str(\"::1\")\n+            } else if let Some(ipv4) = self.to_ipv4() {\n+                match segments[5] {\n+                    // IPv4 Compatible address\n+                    0 => write!(f, \"::{}\", ipv4),\n+                    // IPv4 Mapped address\n+                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                #[derive(Copy, Clone, Default)]\n+                struct Span {\n+                    start: usize,\n+                    len: usize,\n+                }\n \n-        match self.segments() {\n-            // We need special cases for :: and ::1, otherwise they're formatted\n-            // as ::0.0.0.[01]\n-            [0, 0, 0, 0, 0, 0, 0, 0] => write!(buf_slice, \"::\").unwrap(),\n-            [0, 0, 0, 0, 0, 0, 0, 1] => write!(buf_slice, \"::1\").unwrap(),\n-            // Ipv4 Compatible address\n-            [0, 0, 0, 0, 0, 0, g, h] => {\n-                write!(\n-                    buf_slice,\n-                    \"::{}.{}.{}.{}\",\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8\n-                )\n-                .unwrap();\n-            }\n-            // Ipv4-Mapped address\n-            [0, 0, 0, 0, 0, 0xffff, g, h] => {\n-                write!(\n-                    buf_slice,\n-                    \"::ffff:{}.{}.{}.{}\",\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8\n-                )\n-                .unwrap();\n-            }\n-            _ => {\n-                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) {\n-                    let mut longest_span_len = 0;\n-                    let mut longest_span_at = 0;\n-                    let mut cur_span_len = 0;\n-                    let mut cur_span_at = 0;\n-\n-                    for i in 0..8 {\n-                        if segments[i] == 0 {\n-                            if cur_span_len == 0 {\n-                                cur_span_at = i;\n+                // Find the inner 0 span\n+                let zeroes = {\n+                    let mut longest = Span::default();\n+                    let mut current = Span::default();\n+\n+                    for (i, &segment) in segments.iter().enumerate() {\n+                        if segment == 0 {\n+                            if current.len == 0 {\n+                                current.start = i;\n                             }\n \n-                            cur_span_len += 1;\n+                            current.len += 1;\n \n-                            if cur_span_len > longest_span_len {\n-                                longest_span_len = cur_span_len;\n-                                longest_span_at = cur_span_at;\n+                            if current.len > longest.len {\n+                                longest = current;\n                             }\n                         } else {\n-                            cur_span_len = 0;\n-                            cur_span_at = 0;\n+                            current = Span::default();\n                         }\n                     }\n \n-                    (longest_span_at, longest_span_len)\n-                }\n-\n-                let (zeros_at, zeros_len) = find_zero_slice(&self.segments());\n-\n-                if zeros_len > 1 {\n-                    fn fmt_subslice(segments: &[u16], buf: &mut &mut [u8]) {\n-                        if !segments.is_empty() {\n-                            write!(*buf, \"{:x}\", segments[0]).unwrap();\n-                            for &seg in &segments[1..] {\n-                                write!(*buf, \":{:x}\", seg).unwrap();\n-                            }\n+                    longest\n+                };\n+\n+                /// Write a colon-separated part of the address\n+                #[inline]\n+                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n+                    if let Some(first) = chunk.first() {\n+                        fmt::LowerHex::fmt(first, f)?;\n+                        for segment in &chunk[1..] {\n+                            f.write_char(':')?;\n+                            fmt::LowerHex::fmt(segment, f)?;\n                         }\n                     }\n+                    Ok(())\n+                }\n \n-                    fmt_subslice(&self.segments()[..zeros_at], &mut buf_slice);\n-                    write!(buf_slice, \"::\").unwrap();\n-                    fmt_subslice(&self.segments()[zeros_at + zeros_len..], &mut buf_slice);\n+                if zeroes.len > 1 {\n+                    fmt_subslice(f, &segments[..zeroes.start])?;\n+                    f.write_str(\"::\")?;\n+                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n                 } else {\n-                    let &[a, b, c, d, e, f, g, h] = &self.segments();\n-                    write!(\n-                        buf_slice,\n-                        \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n-                        a, b, c, d, e, f, g, h\n-                    )\n-                    .unwrap();\n+                    fmt_subslice(f, &segments)\n                 }\n             }\n+        } else {\n+            // Slow path: write the address to a local buffer, the use f.pad.\n+            // Defined recursively by using the fast path to write to the\n+            // buffer.\n+\n+            // This is the largest possible size of an IPv6 address\n+            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n+            let mut buf = [0u8; IPV6_BUF_LEN];\n+            let mut buf_slice = &mut buf[..];\n+\n+            // Note: This call to write should never fail, so unwrap is okay.\n+            write!(buf_slice, \"{}\", self).unwrap();\n+            let len = IPV6_BUF_LEN - buf_slice.len();\n+\n+            // This is safe because we know exactly what can be in this buffer\n+            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+            f.pad(buf)\n         }\n-        let len = IPV6_BUF_LEN - buf_slice.len();\n-        // This is safe because we know exactly what can be in this buffer\n-        let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-        fmt.pad(buf)\n     }\n }\n "}]}