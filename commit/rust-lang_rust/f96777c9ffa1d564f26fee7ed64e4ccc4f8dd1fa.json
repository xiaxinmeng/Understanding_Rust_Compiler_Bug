{"sha": "f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5Njc3N2M5ZmZhMWQ1NjRmMjZmZWU3ZWQ2NGU0Y2NjNGY4ZGQxZmE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-12-14T00:10:37Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-12-14T00:10:37Z"}, "message": "After discussion with ariel, replacing a guard within kill_loans_out_of_scope_at_location.\n\nInstead we are \"just\" careful to invoke it (which sets up a bunch of kill bits)\nbefore we go into the code that sets up the gen bits.\n\nThat way, when the gen bits are set up, they will override any\npreviously set kill-bits for those reservations or activations.", "tree": {"sha": "8c7a7e17a133f6aacd825d44d51ab056b6f0e218", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c7a7e17a133f6aacd825d44d51ab056b6f0e218"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa", "html_url": "https://github.com/rust-lang/rust/commit/f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c7d9ff90a06c44d31dad018ebb5e613b1c74033", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c7d9ff90a06c44d31dad018ebb5e613b1c74033", "html_url": "https://github.com/rust-lang/rust/commit/3c7d9ff90a06c44d31dad018ebb5e613b1c74033"}], "stats": {"total": 66, "additions": 33, "deletions": 33}, "files": [{"sha": "c61a57cdda0e91bfbb9964dff95eb38ae25ed8c7", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=f96777c9ffa1d564f26fee7ed64e4ccc4f8dd1fa", "patch": "@@ -292,32 +292,21 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n                                            location: Location,\n                                            is_activations: bool) {\n         if let Some(ref regioncx) = self.nonlexical_regioncx {\n+            // NOTE: The state associated with a given `location`\n+            // reflects the dataflow on entry to the statement. If it\n+            // does not contain `borrow_region`, then then that means\n+            // that the statement at `location` kills the borrow.\n+            //\n+            // We are careful always to call this function *before* we\n+            // set up the gen-bits for the statement or\n+            // termanator. That way, if the effect of the statement or\n+            // terminator *does* introduce a new loan of the same\n+            // region, then setting that gen-bit will override any\n+            // potential kill introduced here.\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {\n-                    // The region checker really considers the borrow\n-                    // to start at the point **after** the location of\n-                    // the borrow, but the borrow checker puts the gen\n-                    // directly **on** the location of the\n-                    // borrow. This results in a gen/kill both being\n-                    // generated for same point if we are not\n-                    // careful. Probably we should change the point of\n-                    // the gen, but for now we hackily account for the\n-                    // mismatch here by not generating a kill for the\n-                    // location on the borrow itself.\n-                    if location != borrow_data.location {\n-                        sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n-                    }\n-\n-                    // FIXME: the logic used to justify the above\n-                    // \"accounting for mismatch\" does not generalize\n-                    // to activations, so we set the kill-bits without\n-                    // that same location check here.\n-                    //\n-                    // But... can we get into a situation where the\n-                    // gen/kill bits are both sets in this case, in\n-                    // which case we *do* need an analogous guard of\n-                    // some kind?\n+                    sets.kill(&ReserveOrActivateIndex::reserved(borrow_index));\n                     if is_activations {\n                         sets.kill(&ReserveOrActivateIndex::active(borrow_index));\n                     }\n@@ -340,14 +329,18 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find statement at location {:?}\");\n         });\n \n+        // Do kills introduced by NLL before setting up any potential\n+        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n+        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n+\n         if is_activations {\n-            // INVARIANT: At this point, `sets.on_entry` should\n-            // correctly reflect the reservations as we enter the\n-            // statement (because accumulates_intrablock_state is\n-            // overridden)\n+            // INVARIANT: `sets.on_entry` accurately captures\n+            // reservations on entry to statement (b/c\n+            // accumulates_intrablock_state is overridden for\n+            // ActiveBorrows).\n             //\n-            // Now compute effect of the statement on the activations\n-            // themselves in the ActiveBorrows state.\n+            // Now compute the activations generated by uses within\n+            // the statement based on that reservation state.\n             let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n             find.visit_statement(location.block, stmt, location);\n         }\n@@ -414,8 +407,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::Nop => {}\n \n         }\n-\n-        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n     }\n \n     /// Models terminator effect in Reservations and ActiveBorrows\n@@ -429,9 +420,19 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             panic!(\"could not find block at location {:?}\", location);\n         });\n \n+        // Do kills introduced by NLL before setting up any potential\n+        // gens. (See NOTE in kill_loans_out_of_scope_at_location.)\n+        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n+\n         let term = block.terminator();\n         if is_activations {\n-            // Any uses of reserved Places in the statement are now activated.\n+            // INVARIANT: `sets.on_entry` accurately captures\n+            // reservations on entry to terminator (b/c\n+            // accumulates_intrablock_state is overridden for\n+            // ActiveBorrows).\n+            //\n+            // Now compute effect of the terminator on the activations\n+            // themselves in the ActiveBorrows state.\n             let mut find = FindPlaceUses { sets, assigned_map: &self.assigned_map };\n             find.visit_terminator(location.block, term, location);\n         }\n@@ -474,7 +475,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n             mir::TerminatorKind::FalseEdges {..} |\n             mir::TerminatorKind::Unreachable => {}\n         }\n-        self.kill_loans_out_of_scope_at_location(sets, location, is_activations);\n     }\n }\n "}]}