{"sha": "3db13f4892bc06ee038aef01dc9e5daf0451a561", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYjEzZjQ4OTJiYzA2ZWUwMzhhZWYwMWRjOWU1ZGFmMDQ1MWE1NjE=", "commit": {"author": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-29T20:20:06Z"}, "committer": {"name": "Jakub Bukaj", "email": "jakub@jakub.cc", "date": "2014-10-29T22:56:22Z"}, "message": "Always drop var IDs from type variables modulo -Z verbose, per PR discussion", "tree": {"sha": "d71c926e6222fa604271301de6cdd935f3f5369e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d71c926e6222fa604271301de6cdd935f3f5369e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3db13f4892bc06ee038aef01dc9e5daf0451a561", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3db13f4892bc06ee038aef01dc9e5daf0451a561", "html_url": "https://github.com/rust-lang/rust/commit/3db13f4892bc06ee038aef01dc9e5daf0451a561", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3db13f4892bc06ee038aef01dc9e5daf0451a561/comments", "author": null, "committer": null, "parents": [{"sha": "1b79303f4996d76e75588705e3ddb64031009564", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b79303f4996d76e75588705e3ddb64031009564", "html_url": "https://github.com/rust-lang/rust/commit/1b79303f4996d76e75588705e3ddb64031009564"}], "stats": {"total": 172, "additions": 71, "deletions": 101}, "files": [{"sha": "3baa9a7a5f964fb4038097e157ef58d229d087ba", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -62,7 +62,6 @@ time of error detection.\n use std::collections::HashSet;\n use middle::def;\n use middle::subst;\n-use middle::ty_fold::{mod, TypeFoldable};\n use middle::ty;\n use middle::ty::{Region, ReFree};\n use middle::typeck::infer;\n@@ -112,7 +111,7 @@ pub trait ErrorReporting {\n \n     fn values_str(&self, values: &ValuePairs) -> Option<String>;\n \n-    fn expected_found_str<T: UserString + Resolvable + HasRemainingTypeVariables>(\n+    fn expected_found_str<T: UserString + Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>;\n@@ -402,7 +401,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn expected_found_str<T: UserString + Resolvable + HasRemainingTypeVariables>(\n+    fn expected_found_str<T: UserString + Resolvable>(\n         &self,\n         exp_found: &ty::expected_found<T>)\n         -> Option<String>\n@@ -417,14 +416,9 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n             return None;\n         }\n \n-        // Only include variable IDs in the diagnostics if there are at least two\n-        // present across both types/traits.\n-        let should_print_var_ids = expected.remaining_type_variables(self.tcx)\n-            .union(&found.remaining_type_variables(self.tcx)).count() > 1;\n-\n         Some(format!(\"expected `{}`, found `{}`\",\n-                     expected.user_string_with_var_ids(self.tcx, should_print_var_ids),\n-                     found.user_string_with_var_ids(self.tcx, should_print_var_ids)))\n+                     expected.user_string(self.tcx),\n+                     found.user_string(self.tcx)))\n     }\n \n     fn report_param_bound_failure(&self,\n@@ -1658,29 +1652,6 @@ pub trait Resolvable {\n     fn contains_error(&self) -> bool;\n }\n \n-pub trait HasRemainingTypeVariables {\n-    fn remaining_type_variables(&self, tcx: &ty::ctxt) -> HashSet<ty::InferTy>;\n-}\n-\n-impl<T: TypeFoldable> HasRemainingTypeVariables for T {\n-    fn remaining_type_variables(&self, tcx: &ty::ctxt) -> HashSet<ty::InferTy> {\n-        let mut vars = HashSet::new();\n-        {\n-            let mut folder = ty_fold::BottomUpFolder {\n-                tcx: tcx,\n-                fldop: |t| {\n-                    if let ty::ty_infer(var) = ty::get(t).sty {\n-                        vars.insert(var);\n-                    }\n-                    t\n-                }\n-            };\n-            self.fold_with(&mut folder);\n-        }\n-        vars\n-    }\n-}\n-\n impl Resolvable for ty::t {\n     fn resolve(&self, infcx: &InferCtxt) -> ty::t {\n         infcx.resolve_type_vars_if_possible(*self)"}, {"sha": "633a350ddb2a49e6a51e12ce0a5d636ddc113a3f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -43,9 +43,6 @@ pub trait Repr {\n /// Produces a string suitable for showing to the user.\n pub trait UserString {\n     fn user_string(&self, tcx: &ctxt) -> String;\n-    fn user_string_with_var_ids(&self, tcx: &ctxt, _: bool) -> String {\n-        self.user_string(tcx)\n-    }\n }\n \n pub fn note_and_explain_region(cx: &ctxt,\n@@ -231,14 +228,10 @@ pub fn mutability_to_string(m: ast::Mutability) -> String {\n     }\n }\n \n-pub fn mt_to_string_with_var_ids(cx: &ctxt, m: &mt, print_var_ids: bool) -> String {\n+pub fn mt_to_string(cx: &ctxt, m: &mt) -> String {\n     format!(\"{}{}\",\n         mutability_to_string(m.mutbl),\n-        ty_to_string_with_var_ids(cx, m.ty, print_var_ids))\n-}\n-\n-pub fn mt_to_string(cx: &ctxt, m: &mt) -> String {\n-    mt_to_string_with_var_ids(cx, m, false)\n+        ty_to_string(cx, m.ty))\n }\n \n pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n@@ -265,17 +258,11 @@ pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n }\n \n pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n-    ty_to_string_with_var_ids(cx, typ, true)\n-}\n-\n-pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) -> String {\n-    print_var_ids = print_var_ids || cx.sess.verbose();\n     fn bare_fn_to_string(cx: &ctxt,\n                       fn_style: ast::FnStyle,\n                       abi: abi::Abi,\n                       ident: Option<ast::Ident>,\n-                      sig: &ty::FnSig,\n-                      print_var_ids: bool)\n+                      sig: &ty::FnSig)\n                       -> String {\n         let mut s = String::new();\n         match fn_style {\n@@ -300,12 +287,12 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n             _ => { }\n         }\n \n-        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\", print_var_ids);\n+        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n \n         s\n     }\n \n-    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy, print_var_ids: bool) -> String {\n+    fn closure_to_string(cx: &ctxt, cty: &ty::ClosureTy) -> String {\n         let mut s = String::new();\n \n         match cty.store {\n@@ -330,15 +317,15 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str.as_slice(), print_var_ids);\n+                                   bounds_str.as_slice());\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str.as_slice(), print_var_ids);\n+                                   bounds_str.as_slice());\n             }\n         }\n \n@@ -350,12 +337,11 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n                        bra: char,\n                        ket: char,\n                        sig: &ty::FnSig,\n-                       bounds: &str,\n-                       print_var_ids: bool) {\n+                       bounds: &str) {\n         s.push(bra);\n         let strs = sig.inputs\n             .iter()\n-            .map(|a| ty_to_string_with_var_ids(cx, *a, print_var_ids))\n+            .map(|a| ty_to_string(cx, *a))\n             .collect::<Vec<_>>();\n         s.push_str(strs.connect(\", \").as_slice());\n         if sig.variadic {\n@@ -372,7 +358,7 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string_with_var_ids(cx, t, print_var_ids).as_slice());\n+                   s.push_str(ty_to_string(cx, t).as_slice());\n                 }\n             }\n             ty::FnDiverging => {\n@@ -381,21 +367,20 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n         }\n     }\n \n-    fn infer_ty_to_string(ty: ty::InferTy, print_var_ids: bool) -> String {\n+    fn infer_ty_to_string(cx: &ctxt, ty: ty::InferTy) -> String {\n+        let print_var_ids = cx.sess.verbose();\n         match ty {\n-            ty::TyVar(ty::TyVid { index: vid }) |\n-            ty::IntVar(ty::IntVid { index: vid }) |\n-            ty::FloatVar(ty::FloatVid { index: vid }) => {\n-                match ty {\n-                    ty::TyVar(_) if print_var_ids => format!(\"_#{}\", vid),\n-                    ty::TyVar(_) => \"_\".to_string(),\n-                    ty::IntVar(_) => format!(\"_#{}i\", vid),\n-                    ty::FloatVar(_) => format!(\"_#{}f\", vid),\n-                    _ => unreachable!()\n-                }\n-            }\n+            ty::TyVar(ty::TyVid { index: vid }) if print_var_ids =>\n+                format!(\"_#{}\", vid),\n+            ty::IntVar(ty::IntVid { index: vid }) if print_var_ids =>\n+                format!(\"_#{}i\", vid),\n+            ty::FloatVar(ty::FloatVid { index: vid }) if print_var_ids =>\n+                format!(\"_#{}f\", vid),\n+            ty::TyVar(_) => \"_\".to_string(),\n+            ty::IntVar(_) => \"_#i\".to_string(),\n+            ty::FloatVar(_) => \"_#f\".to_string(),\n             ty::SkolemizedTy(v) => format!(\"SkolemizedTy({})\", v),\n-            ty::SkolemizedIntTy(v) => format!(\"SkolemizedIntTy({})\", v),\n+            ty::SkolemizedIntTy(v) => format!(\"SkolemizedIntTy({})\", v)\n         }\n     }\n \n@@ -407,7 +392,7 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n         ty_int(t) => ast_util::int_ty_to_string(t, None).to_string(),\n         ty_uint(t) => ast_util::uint_ty_to_string(t, None).to_string(),\n         ty_float(t) => ast_util::float_ty_to_string(t).to_string(),\n-        ty_uniq(typ) => format!(\"Box<{}>\", ty_to_string_with_var_ids(cx, typ, print_var_ids)),\n+        ty_uniq(typ) => format!(\"Box<{}>\", ty_to_string(cx, typ)),\n         ty_ptr(ref tm) => {\n             format!(\"*{} {}\", match tm.mutbl {\n                 ast::MutMutable => \"mut\",\n@@ -416,42 +401,42 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, r);\n-            buf.push_str(mt_to_string_with_var_ids(cx, tm, print_var_ids).as_slice());\n+            buf.push_str(mt_to_string(cx, tm).as_slice());\n             buf\n         }\n         ty_open(typ) =>\n-            format!(\"opened<{}>\", ty_to_string_with_var_ids(cx, typ, print_var_ids)),\n+            format!(\"opened<{}>\", ty_to_string(cx, typ)),\n         ty_tup(ref elems) => {\n             let strs = elems\n                 .iter()\n-                .map(|elem| ty_to_string_with_var_ids(cx, *elem, print_var_ids))\n+                .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n             match strs.as_slice() {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n         }\n         ty_closure(ref f) => {\n-            closure_to_string(cx, &**f, print_var_ids)\n+            closure_to_string(cx, &**f)\n         }\n         ty_bare_fn(ref f) => {\n-            bare_fn_to_string(cx, f.fn_style, f.abi, None, &f.sig, print_var_ids)\n+            bare_fn_to_string(cx, f.fn_style, f.abi, None, &f.sig)\n         }\n-        ty_infer(infer_ty) => infer_ty_to_string(infer_ty, print_var_ids),\n+        ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n         ty_param(ref param_ty) => param_ty.repr(cx),\n         ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n             let base = ty::item_path_str(cx, did);\n             let generics = ty::lookup_item_type(cx, did).generics;\n-            parameterized(cx, base.as_slice(), substs, &generics, print_var_ids)\n+            parameterized(cx, base.as_slice(), substs, &generics)\n         }\n         ty_trait(box ty::TyTrait {\n             def_id: did, ref substs, ref bounds\n         }) => {\n             let base = ty::item_path_str(cx, did);\n             let trait_def = ty::lookup_trait_def(cx, did);\n             let ty = parameterized(cx, base.as_slice(),\n-                                   substs, &trait_def.generics, print_var_ids);\n+                                   substs, &trait_def.generics);\n             let bound_str = bounds.user_string(cx);\n             let bound_sep = if bound_str.is_empty() { \"\" } else { \"+\" };\n             format!(\"{}{}{}\",\n@@ -463,11 +448,11 @@ pub fn ty_to_string_with_var_ids(cx: &ctxt, typ: t, mut print_var_ids: bool) ->\n         ty_unboxed_closure(ref did, _, ref substs) => {\n             let unboxed_closures = cx.unboxed_closures.borrow();\n             unboxed_closures.find(did).map(|cl| {\n-                closure_to_string(cx, &cl.closure_type.subst(cx, substs), print_var_ids)\n+                closure_to_string(cx, &cl.closure_type.subst(cx, substs))\n             }).unwrap_or_else(|| \"closure\".to_string())\n         }\n         ty_vec(t, sz) => {\n-            let inner_str = ty_to_string_with_var_ids(cx, t, print_var_ids);\n+            let inner_str = ty_to_string(cx, t);\n             match sz {\n                 Some(n) => format!(\"[{}, ..{}]\", inner_str, n),\n                 None => format!(\"[{}]\", inner_str),\n@@ -492,8 +477,7 @@ pub fn explicit_self_category_to_str(category: &ty::ExplicitSelfCategory)\n pub fn parameterized(cx: &ctxt,\n                      base: &str,\n                      substs: &subst::Substs,\n-                     generics: &ty::Generics,\n-                     print_var_ids: bool)\n+                     generics: &ty::Generics)\n                      -> String\n {\n     let mut strs = Vec::new();\n@@ -532,7 +516,7 @@ pub fn parameterized(cx: &ctxt,\n     };\n \n     for t in tps[..tps.len() - num_defaults].iter() {\n-        strs.push(ty_to_string_with_var_ids(cx, *t, print_var_ids))\n+        strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.sess.verbose() {\n@@ -743,7 +727,7 @@ impl Repr for ty::TraitRef {\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"<{} as {}>\",\n                 self.substs.self_ty().repr(tcx),\n-                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, false))\n+                parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics))\n     }\n }\n \n@@ -1128,22 +1112,16 @@ impl UserString for ty::BuiltinBounds {\n \n impl UserString for ty::TraitRef {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        self.user_string_with_var_ids(tcx, false)\n-    }\n-    fn user_string_with_var_ids(&self, tcx: &ctxt, print_var_ids: bool) -> String {\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, print_var_ids)\n+        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics)\n     }\n }\n \n impl UserString for ty::t {\n     fn user_string(&self, tcx: &ctxt) -> String {\n         ty_to_string(tcx, *self)\n     }\n-    fn user_string_with_var_ids(&self, tcx: &ctxt, print_var_ids: bool) -> String {\n-        ty_to_string_with_var_ids(tcx, *self, print_var_ids)\n-    }\n }\n \n impl UserString for ast::Ident {"}, {"sha": "6746b90e32d2e133a4294b3dd0f3de53d7fe3d86", "filename": "src/test/compile-fail/issue-13482-2.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482-2.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Z verbose\n+\n+fn main() {\n+    let x = [1,2];\n+    let y = match x {\n+        [] => None,\n+        //~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7, ..0]`\n+        //         (expected array of 2 elements, found array of 0 elements)\n+        [a,_] => Some(a)\n+    };\n+}"}, {"sha": "e0b1f8845e2367474e0808930a54caf2d5547df2", "filename": "src/test/compile-fail/issue-13482.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13482.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -12,7 +12,7 @@ fn main() {\n   let x = [1,2];\n   let y = match x {\n     [] => None,\n-//~^ ERROR types: expected `[_#0i, ..2]`, found `[_#7, ..0]`\n+//~^ ERROR types: expected `[_#i, ..2]`, found `[_, ..0]`\n //         (expected array of 2 elements, found array of 0 elements)\n     [a,_] => Some(a)\n   };"}, {"sha": "f018a02a945a925ee04b8fdc5f46a862ff57038f", "filename": "src/test/compile-fail/issue-3680.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3680.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -11,7 +11,7 @@\n fn main() {\n     match None {\n         Err(_) => ()\n-        //~^ ERROR mismatched types: expected `core::option::Option<_#1>`\n-        //         , found `core::result::Result<_#2, _#3>`\n+        //~^ ERROR mismatched types: expected `core::option::Option<_>`\n+        //         , found `core::result::Result<_, _>`\n     }\n }"}, {"sha": "5899fa43a48217151013ff57ccb2ce53c311aaee", "filename": "src/test/compile-fail/issue-4201.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4201.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -12,7 +12,7 @@ fn main() {\n     let a = if true {\n         0\n     } else if false {\n-//~^ ERROR if may be missing an else clause: expected `()`, found `_#1i`\n+//~^ ERROR if may be missing an else clause: expected `()`, found `_#i`\n         1\n     };\n }"}, {"sha": "54fd9d492bfcb27b5839ed6df2972aaef90c141c", "filename": "src/test/compile-fail/issue-4968.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4968.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -13,6 +13,6 @@\n const A: (int,int) = (4,2);\n fn main() {\n     match 42 { A => () }\n-    //~^ ERROR mismatched types: expected `_#0i`, found `(int, int)`\n+    //~^ ERROR mismatched types: expected `_#i`, found `(int, int)`\n     //         (expected integral variable, found tuple)\n }"}, {"sha": "ddd82af01a71e006eb16fc4b1011334728dc5e54", "filename": "src/test/compile-fail/issue-5100.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5100.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -19,7 +19,7 @@ fn main() {\n \n     match (true, false) {\n         (true, false, false) => ()\n-//~^ ERROR mismatched types: expected `(bool, bool)`, found `(_#9, _#10, _#11)`\n+//~^ ERROR mismatched types: expected `(bool, bool)`, found `(_, _, _)`\n     }\n \n     match (true, false) {"}, {"sha": "0d4dab9916dcf097a82928e42ada179271db30be", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -18,7 +18,7 @@ fn main() {\n     let c = [0, ..true]; //~ ERROR expected positive integer for repeat count, found boolean\n     //~^ ERROR: expected `uint`, found `bool`\n     let d = [0, ..0.5]; //~ ERROR expected positive integer for repeat count, found float\n-    //~^ ERROR: expected `uint`, found `_#0f`\n+    //~^ ERROR: expected `uint`, found `_#f`\n     let e = [0, ..\"foo\"]; //~ ERROR expected positive integer for repeat count, found string\n     //~^ ERROR: expected `uint`, found `&'static str`\n     let f = [0, ..-4];"}, {"sha": "3ac3988bad2bd7f68046151145c866453c96ad7a", "filename": "src/test/compile-fail/slightly-nice-generic-literal-messages.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslightly-nice-generic-literal-messages.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -13,7 +13,7 @@ struct Foo<T,U>(T);\n fn main() {\n     match Foo(1.1) {\n         1 => {}\n-    //~^ ERROR expected `Foo<_#0f, _#2>`, found `_#0i`\n+    //~^ ERROR expected `Foo<_#f, _>`, found `_#i`\n     }\n \n }"}, {"sha": "27f50be528c56fa56e855e296cef52e9448d6c48", "filename": "src/test/compile-fail/suppressed-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db13f4892bc06ee038aef01dc9e5daf0451a561/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs?ref=3db13f4892bc06ee038aef01dc9e5daf0451a561", "patch": "@@ -10,6 +10,6 @@\n \n fn main() {\n     let (x, y) = ();\n-//~^ ERROR expected `()`, found `(_#3, _#4)` (expected (), found tuple)\n+//~^ ERROR expected `()`, found `(_, _)` (expected (), found tuple)\n     return x;\n }"}]}