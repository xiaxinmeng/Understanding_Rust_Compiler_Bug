{"sha": "4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmN2QwZmRlMWM1ZjU3N2MxZjk1NmQ1ZDRlZGZiYjIwMmE1YmMzY2Y=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-24T05:19:20Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2018-03-24T14:48:07Z"}, "message": "Some cleanups and added comments", "tree": {"sha": "aa0fc01ce2cc181c6a242501d8a21d781c66f8cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa0fc01ce2cc181c6a242501d8a21d781c66f8cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "html_url": "https://github.com/rust-lang/rust/commit/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc", "html_url": "https://github.com/rust-lang/rust/commit/29a4ec0d434dba190dfe9e4d46f16e4c026dd6cc"}], "stats": {"total": 243, "additions": 157, "deletions": 86}, "files": [{"sha": "44b9d61cf020264350e7cebe76b52bd48de04919", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 67, "deletions": 25, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "patch": "@@ -1489,10 +1489,13 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n     /// Call the closure with a local `TyCtxt` using the given arena.\n-    pub fn enter_local<F, R>(&self,\n-                             arena: &'tcx DroplessArena,\n-                             f: F) -> R\n-        where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n+    pub fn enter_local<F, R>(\n+        &self,\n+        arena: &'tcx DroplessArena,\n+        f: F\n+    ) -> R\n+    where\n+        F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n         let interners = CtxtInterners::new(arena);\n         let tcx = TyCtxt {\n@@ -1665,12 +1668,23 @@ pub mod tls {\n     use rustc_data_structures::OnDrop;\n     use rustc_data_structures::sync::Lrc;\n \n+    /// This is the implicit state of rustc. It contains the current\n+    /// TyCtxt and query. It is updated when creating a local interner or\n+    /// executing a new query. Whenever there's a TyCtxt value available\n+    /// you should also have access to an ImplicitCtxt through the functions\n+    /// in this module.\n     #[derive(Clone)]\n     pub struct ImplicitCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+        /// The current TyCtxt. Initially created by `enter_global` and updated\n+        /// by `enter_local` with a new local interner\n         pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+        /// The current query job, if any. This is updated by start_job in\n+        /// ty::maps::plumbing when executing a query\n         pub query: Option<Lrc<maps::QueryJob<'gcx>>>,\n     }\n \n+    // A thread local value which stores a pointer to the current ImplicitCtxt\n     thread_local!(static TLV: Cell<usize> = Cell::new(0));\n \n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n@@ -1684,12 +1698,17 @@ pub mod tls {\n         TLV.with(|tlv| tlv.get())\n     }\n \n+    /// This is a callback from libsyntax as it cannot access the implicit state\n+    /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter) -> fmt::Result {\n         with(|tcx| {\n             write!(f, \"{}\", tcx.sess.codemap().span_to_string(span))\n         })\n     }\n \n+    /// This is a callback from libsyntax as it cannot access the implicit state\n+    /// in librustc otherwise. It is used to when diagnostic messages are\n+    /// emitted and stores them in the current query, if there is one.\n     fn track_diagnostic(diagnostic: &Diagnostic) {\n         with_context(|context| {\n             if let Some(ref query) = context.query {\n@@ -1698,6 +1717,7 @@ pub mod tls {\n         })\n     }\n \n+    /// Sets up the callbacks from libsyntax on the current thread\n     pub fn with_thread_locals<F, R>(f: F) -> R\n         where F: FnOnce() -> R\n     {\n@@ -1722,6 +1742,20 @@ pub mod tls {\n         })\n     }\n \n+    /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n+    pub fn enter_context<'a, 'gcx: 'tcx, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'gcx, 'tcx>,\n+                                                     f: F) -> R\n+        where F: FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        set_tlv(context as *const _ as usize, || {\n+            f(&context)\n+        })\n+    }\n+\n+    /// Enters GlobalCtxt by setting up libsyntax callbacks and\n+    /// creating a initial TyCtxt and ImplicitCtxt.\n+    /// This happens once per rustc session and TyCtxts only exists\n+    /// inside the `f` function.\n     pub fn enter_global<'gcx, F, R>(gcx: &GlobalCtxt<'gcx>, f: F) -> R\n         where F: for<'a> FnOnce(TyCtxt<'a, 'gcx, 'gcx>) -> R\n     {\n@@ -1740,15 +1774,7 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter_context<'a, 'gcx: 'tcx, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'gcx, 'tcx>,\n-                                                     f: F) -> R\n-        where F: FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n-    {\n-        set_tlv(context as *const _ as usize, || {\n-            f(&context)\n-        })\n-    }\n-\n+    /// Allows access to the current ImplicitCtxt in a closure if one is available\n     pub fn with_context_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<&ImplicitCtxt<'a, 'gcx, 'tcx>>) -> R\n     {\n@@ -1760,46 +1786,62 @@ pub mod tls {\n         }\n     }\n \n-    pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n-        where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n+    /// Allows access to the current ImplicitCtxt.\n+    /// Panics if there is no ImplicitCtxt available\n+    pub fn with_context<F, R>(f: F) -> R\n+        where F: for<'a, 'gcx, 'tcx> FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n+    {\n+        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n+    }\n+\n+    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n+    /// interner as the tcx argument passed in. This means the closure is given an ImplicitCtxt\n+    /// with the same 'gcx lifetime as the TyCtxt passed in.\n+    /// This will panic if you pass it a TyCtxt which has a different global interner from\n+    /// the current ImplicitCtxt's tcx field.\n+    pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n+        where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n     {\n         with_context(|context| {\n             unsafe {\n                 let gcx = tcx.gcx as *const _ as usize;\n-                let interners = tcx.interners as *const _ as usize;\n                 assert!(context.tcx.gcx as *const _ as usize == gcx);\n-                assert!(context.tcx.interners as *const _ as usize == interners);\n                 let context: &ImplicitCtxt = mem::transmute(context);\n                 f(context)\n             }\n         })\n     }\n \n-    pub fn with_related_context<'a, 'gcx, 'tcx1, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx1>, f: F) -> R\n-        where F: for<'b, 'tcx2> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx2>) -> R\n+    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n+    /// interner and local interner as the tcx argument passed in. This means the closure\n+    /// is given an ImplicitCtxt with the same 'tcx and 'gcx lifetimes as the TyCtxt passed in.\n+    /// This will panic if you pass it a TyCtxt which has a different global interner or\n+    /// a different local interner from the current ImplicitCtxt's tcx field.\n+    pub fn with_fully_related_context<'a, 'gcx, 'tcx, F, R>(tcx: TyCtxt<'a, 'gcx, 'tcx>, f: F) -> R\n+        where F: for<'b> FnOnce(&ImplicitCtxt<'b, 'gcx, 'tcx>) -> R\n     {\n         with_context(|context| {\n             unsafe {\n                 let gcx = tcx.gcx as *const _ as usize;\n+                let interners = tcx.interners as *const _ as usize;\n                 assert!(context.tcx.gcx as *const _ as usize == gcx);\n+                assert!(context.tcx.interners as *const _ as usize == interners);\n                 let context: &ImplicitCtxt = mem::transmute(context);\n                 f(context)\n             }\n         })\n     }\n \n-    pub fn with_context<F, R>(f: F) -> R\n-        where F: for<'a, 'gcx, 'tcx> FnOnce(&ImplicitCtxt<'a, 'gcx, 'tcx>) -> R\n-    {\n-        with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n-    }\n-\n+    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n+    /// Panics if there is no ImplicitCtxt available\n     pub fn with<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(TyCtxt<'a, 'gcx, 'tcx>) -> R\n     {\n         with_context(|context| f(context.tcx))\n     }\n \n+    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n+    /// The closure is passed None if there is no ImplicitCtxt available\n     pub fn with_opt<F, R>(f: F) -> R\n         where F: for<'a, 'gcx, 'tcx> FnOnce(Option<TyCtxt<'a, 'gcx, 'tcx>>) -> R\n     {"}, {"sha": "7d756fb16a453d0b03b4e82d1f1e82b0cef9df7d", "filename": "src/librustc/ty/maps/job.rs", "status": "modified", "additions": 34, "deletions": 35, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fjob.rs?ref=4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "patch": "@@ -8,65 +8,69 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(warnings)]\n-\n-use std::mem;\n-use std::sync::atomic::AtomicBool;\n-use std::sync::atomic::Ordering;\n-use rustc_data_structures::sync::{Lock, LockGuard, Lrc};\n+use rustc_data_structures::sync::{Lock, Lrc};\n use syntax_pos::Span;\n use ty::tls;\n use ty::maps::Query;\n use ty::maps::plumbing::CycleError;\n use ty::context::TyCtxt;\n use errors::Diagnostic;\n-use std::process;\n-use std::fmt;\n-use std::sync::{Arc, Mutex};\n-use std::collections::HashSet;\n \n-pub struct PoisonedJob;\n+/// Indicates the state of a query for a given key in a query map\n+pub(super) enum QueryResult<'tcx, T> {\n+    /// An already executing query. The query job can be used to await for its completion\n+    Started(Lrc<QueryJob<'tcx>>),\n+\n+    /// The query is complete and produced `T`\n+    Complete(T),\n \n+    /// The query panicked. Queries trying to wait on this will raise a fatal error / silently panic\n+    Poisoned,\n+}\n+\n+/// A span and a query key\n #[derive(Clone, Debug)]\n-pub struct StackEntry<'tcx> {\n+pub struct QueryInfo<'tcx> {\n     pub span: Span,\n     pub query: Query<'tcx>,\n }\n \n+/// A object representing an active query job.\n pub struct QueryJob<'tcx> {\n-    pub entry: StackEntry<'tcx>,\n+    pub info: QueryInfo<'tcx>,\n+\n+    /// The parent query job which created this job and is implicitly waiting on it.\n     pub parent: Option<Lrc<QueryJob<'tcx>>>,\n-    pub track_diagnostics: bool,\n+\n+    /// Diagnostic messages which are emitted while the query executes\n     pub diagnostics: Lock<Vec<Diagnostic>>,\n }\n \n impl<'tcx> QueryJob<'tcx> {\n-    pub fn new(\n-        entry: StackEntry<'tcx>,\n-        track_diagnostics: bool,\n-        parent: Option<Lrc<QueryJob<'tcx>>>,\n-    ) -> Self {\n+    /// Creates a new query job\n+    pub fn new(info: QueryInfo<'tcx>, parent: Option<Lrc<QueryJob<'tcx>>>) -> Self {\n         QueryJob {\n-            track_diagnostics,\n             diagnostics: Lock::new(Vec::new()),\n-            entry,\n+            info,\n             parent,\n         }\n     }\n \n+    /// Awaits for the query job to complete.\n+    ///\n+    /// For single threaded rustc there's no concurrent jobs running, so if we are waiting for any\n+    /// query that means that there is a query cycle, thus this always running a cycle error.\n     pub(super) fn await<'lcx>(\n         &self,\n         tcx: TyCtxt<'_, 'tcx, 'lcx>,\n         span: Span,\n     ) -> Result<(), CycleError<'tcx>> {\n-        // The query is already executing, so this must be a cycle for single threaded rustc,\n-        // so we find the cycle and return it\n-\n+        // Get the current executing query (waiter) and find the waitee amongst its parents\n         let mut current_job = tls::with_related_context(tcx, |icx| icx.query.clone());\n         let mut cycle = Vec::new();\n \n         while let Some(job) = current_job {\n-            cycle.insert(0, job.entry.clone());\n+            cycle.insert(0, job.info.clone());\n \n             if &*job as *const _ == self as *const _ {\n                 break;\n@@ -78,14 +82,9 @@ impl<'tcx> QueryJob<'tcx> {\n         Err(CycleError { span, cycle })\n     }\n \n-    pub fn signal_complete(&self) {\n-        // Signals to waiters that the query is complete.\n-        // This is a no-op for single threaded rustc\n-    }\n-}\n-\n-pub(super) enum QueryResult<'tcx, T> {\n-    Started(Lrc<QueryJob<'tcx>>),\n-    Complete(T),\n-    Poisoned,\n+    /// Signals to waiters that the query is complete.\n+    ///\n+    /// This does nothing for single threaded rustc,\n+    /// as there are no concurrent jobs which could be waiting on us\n+    pub fn signal_complete(&self) {}\n }"}, {"sha": "f4977be78776b1c44b64a788f9f2bab17ce515d2", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "patch": "@@ -67,7 +67,7 @@ use self::plumbing::*;\n pub use self::plumbing::force_from_dep_node;\n \n mod job;\n-pub use self::job::{QueryJob, StackEntry, PoisonedJob};\n+pub use self::job::{QueryJob, QueryInfo};\n use self::job::QueryResult;\n \n mod keys;"}, {"sha": "c21b53cd427c005a0e52c5b9eec7af96477433ef", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 55, "deletions": 25, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=4f7d0fde1c5f577c1f956d5d4edfbb202a5bc3cf", "patch": "@@ -16,7 +16,7 @@ use dep_graph::{DepNodeIndex, DepNode, DepKind, DepNodeColor};\n use errors::DiagnosticBuilder;\n use ty::{TyCtxt};\n use ty::maps::config::QueryDescription;\n-use ty::maps::job::{QueryResult, StackEntry};\n+use ty::maps::job::{QueryResult, QueryInfo};\n use ty::item_path;\n \n use rustc_data_structures::fx::{FxHashMap};\n@@ -62,7 +62,18 @@ pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n #[derive(Clone)]\n pub(super) struct CycleError<'tcx> {\n     pub(super) span: Span,\n-    pub(super) cycle: Vec<StackEntry<'tcx>>,\n+    pub(super) cycle: Vec<QueryInfo<'tcx>>,\n+}\n+\n+/// The result of `try_get_lock`\n+pub(super) enum TryGetLock<'a, 'tcx: 'a, T, D: QueryDescription<'tcx> + 'a> {\n+    /// The query is not yet started. Contains a guard to the map eventually used to start it.\n+    NotYetStarted(LockGuard<'a, QueryMap<'tcx, D>>),\n+\n+    /// The query was already completed.\n+    /// Returns the result of the query and its dep node index\n+    /// if it succeeded or a cycle error if it failed\n+    JobCompleted(Result<(T, DepNodeIndex), CycleError<'tcx>>),\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -85,7 +96,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             err.span_note(self.sess.codemap().def_span(stack[0].span),\n                           &format!(\"the cycle begins when {}...\", stack[0].query.describe(self)));\n \n-            for &StackEntry { span, ref query, .. } in &stack[1..] {\n+            for &QueryInfo { span, ref query, .. } in &stack[1..] {\n                 err.span_note(self.sess.codemap().def_span(span),\n                               &format!(\"...which then requires {}...\", query.describe(self)));\n             }\n@@ -252,11 +263,14 @@ macro_rules! define_maps {\n                 DepNode::new(tcx, $node(*key))\n             }\n \n-            fn try_get_lock(tcx: TyCtxt<'a, $tcx, 'lcx>,\n-                            mut span: Span,\n-                            key: &$K)\n-                            -> Result<LockGuard<'a, QueryMap<$tcx, Self>>,\n-                                      Result<($V, DepNodeIndex), CycleError<$tcx>>>\n+            /// Either get the lock of the query map, allowing us to\n+            /// start executing the query, or it returns with the result of the query.\n+            /// If the query already executed and panicked, this will fatal error / silently panic\n+            fn try_get_lock(\n+                tcx: TyCtxt<'a, $tcx, 'lcx>,\n+                mut span: Span,\n+                key: &$K\n+            ) -> TryGetLock<'a, $tcx, $V, Self>\n             {\n                 loop {\n                     let lock = tcx.maps.$name.borrow_mut();\n@@ -265,7 +279,8 @@ macro_rules! define_maps {\n                             QueryResult::Started(ref job) => Some(job.clone()),\n                             QueryResult::Complete(ref value) => {\n                                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                                return Err(Ok(((&value.value).clone(), value.index)));\n+                                let result = Ok(((&value.value).clone(), value.index));\n+                                return TryGetLock::JobCompleted(result);\n                             },\n                             QueryResult::Poisoned => FatalError.raise(),\n                         }\n@@ -275,16 +290,19 @@ macro_rules! define_maps {\n                     let job = if let Some(job) = job {\n                         job\n                     } else {\n-                        return Ok(lock);\n+                        return TryGetLock::NotYetStarted(lock);\n                     };\n                     mem::drop(lock);\n \n+                    // This just matches the behavior of `try_get_with` so the span when\n+                    // we await matches the span we would use when executing.\n+                    // See the FIXME there.\n                     if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n                         span = key.default_span(tcx);\n                     }\n \n                     if let Err(cycle) = job.await(tcx, span) {\n-                        return Err(Err(cycle));\n+                        return TryGetLock::JobCompleted(Err(cycle));\n                     }\n                 }\n             }\n@@ -306,21 +324,23 @@ macro_rules! define_maps {\n                     )\n                 );\n \n-                macro_rules! get_lock {\n+                /// Get the lock used to start the query or\n+                /// return the result of the completed query\n+                macro_rules! get_lock_or_return {\n                     () => {{\n                         match Self::try_get_lock(tcx, span, &key) {\n-                            Ok(lock) => lock,\n-                            Err(result) => {\n+                            TryGetLock::NotYetStarted(lock) => lock,\n+                            TryGetLock::JobCompleted(result) => {\n                                 return result.map(|(v, index)| {\n                                     tcx.dep_graph.read_index(index);\n                                     v\n-                                });\n-                            },\n+                                })\n+                            }\n                         }\n                     }}\n                 }\n \n-                let mut lock = get_lock!();\n+                let mut lock = get_lock_or_return!();\n \n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n@@ -331,7 +351,7 @@ macro_rules! define_maps {\n                     // So we drop the lock here and reacquire it\n                     mem::drop(lock);\n                     span = key.default_span(tcx);\n-                    lock = get_lock!();\n+                    lock = get_lock_or_return!();\n                 }\n \n                 // Fast path for when incr. comp. is off. `to_dep_node` is\n@@ -385,7 +405,7 @@ macro_rules! define_maps {\n                                                                         dep_node_index,\n                                                                         &dep_node)\n                     }\n-                    lock = get_lock!();\n+                    lock = get_lock_or_return!();\n                 }\n \n                 match Self::force_with_lock(tcx, key, span, lock, dep_node) {\n@@ -421,6 +441,9 @@ macro_rules! define_maps {\n                 }\n             }\n \n+            /// Creates a job for the query and updates the query map indicating that it started.\n+            /// Then it changes ImplicitCtxt to point to the new query job while it executes.\n+            /// If the query panics, this updates the query map to indicate so.\n             fn start_job<F, R>(tcx: TyCtxt<'_, $tcx, 'lcx>,\n                                span: Span,\n                                key: $K,\n@@ -431,21 +454,25 @@ macro_rules! define_maps {\n             {\n                 let query = Query::$name(Clone::clone(&key));\n \n-                let entry = StackEntry {\n+                let entry = QueryInfo {\n                     span,\n                     query,\n                 };\n \n+                // The TyCtxt stored in TLS has the same global interner lifetime\n+                // as `tcx`, so we use `with_related_context` to relate the 'gcx lifetimes\n+                // when accessing the ImplicitCtxt\n                 let (r, job) = ty::tls::with_related_context(tcx, move |icx| {\n-                    let job = Lrc::new(QueryJob::new(entry, true, icx.query.clone()));\n+                    let job = Lrc::new(QueryJob::new(entry, icx.query.clone()));\n \n+                    // Store the job in the query map and drop the lock to allow\n+                    // others to wait it\n                     map.map.entry(key).or_insert(QueryResult::Started(job.clone()));\n-\n                     mem::drop(map);\n \n                     let r = {\n                         let on_drop = OnDrop(|| {\n-                            // Poison the query so jobs waiting on it panics\n+                            // Poison the query so jobs waiting on it panic\n                             tcx.maps\n                             .$name\n                             .borrow_mut()\n@@ -456,11 +483,13 @@ macro_rules! define_maps {\n                             job.signal_complete();\n                         });\n \n+                        // Update the ImplicitCtxt to point to our new query job\n                         let icx = ty::tls::ImplicitCtxt {\n                             tcx,\n                             query: Some(job.clone()),\n                         };\n \n+                        // Use the ImplicitCtxt while we execute the query\n                         let r = ty::tls::enter_context(&icx, |icx| {\n                             compute(icx.tcx)\n                         });\n@@ -473,6 +502,7 @@ macro_rules! define_maps {\n                     (r, job)\n                 });\n \n+                // Extract the diagnostic from the job\n                 let diagnostics: Vec<_> = mem::replace(&mut *job.diagnostics.lock(), Vec::new());\n \n                 Ok(((r, diagnostics), job))\n@@ -590,8 +620,8 @@ macro_rules! define_maps {\n                 // We may be concurrently trying both execute and force a query\n                 // Ensure that only one of them runs the query\n                 let lock = match Self::try_get_lock(tcx, span, &key) {\n-                    Ok(lock) => lock,\n-                    Err(result) => return result,\n+                    TryGetLock::NotYetStarted(lock) => lock,\n+                    TryGetLock::JobCompleted(result) => return result,\n                 };\n                 Self::force_with_lock(tcx,\n                                       key,"}]}