{"sha": "82cf3a4486bc882207a09bf0d9e2dea4632781aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyY2YzYTQ0ODZiYzg4MjIwN2EwOWJmMGQ5ZTJkZWE0NjMyNzgxYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-14T14:11:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-14T14:11:38Z"}, "message": "Auto merge of #66314 - GuillaumeGomez:move-error-codes, r=Centril\n\nMove error codes\n\nWorks towards #66210.\n\nr? @Centril\n\nOh btw, for the ones interested, I used this python script to get all error codes content sorted into one final file:\n\n<details>\n\n```python\nfrom os import listdir\nfrom os.path import isdir, isfile, join\n\ndef get_error_codes(error_codes, f_path):\n    with open(f_path) as f:\n        short_mode = False\n        lines = f.read().split(\"\\n\")\n        i = 0\n        while i < len(lines):\n            line = lines[i]\n            if not short_mode and line.startswith(\"E0\") and line.endswith(\": r##\\\"\"):\n                error = line\n                error += \"\\n\"\n                i += 1\n                while i < len(lines):\n                    line = lines[i]\n                    error += line\n                    if line.endswith(\"\\\"##,\"):\n                        break\n                    error += \"\\n\"\n                    i += 1\n                error_codes[\"long\"].append(error)\n            elif line == ';':\n                short_mode = True\n            elif short_mode is True and len(line) > 0 and line != \"}\":\n                error_codes[\"short\"].append(line)\n                while i + 1 < len(lines):\n                    line = lines[i + 1].strip()\n                    if not line.startswith(\"//\"):\n                        break\n                    parts = line.split(\"//\")\n                    if len(parts) < 2:\n                        break\n                    if parts[1].strip().startswith(\"E0\"):\n                        break\n                    error_codes[\"short\"][-1] += \"\\n\"\n                    error_codes[\"short\"][-1] += lines[i + 1]\n                    i += 1\n            i += 1\n\ndef loop_dirs(error_codes, cur_dir):\n    for entry in listdir(cur_dir):\n        f = join(cur_dir, entry)\n        if isfile(f) and entry == \"error_codes.rs\":\n            get_error_codes(error_codes, f)\n        elif isdir(f) and not entry.startswith(\"librustc_error_codes\"):\n            loop_dirs(error_codes, f)\n\ndef get_error_code(err):\n    x = err.split(\",\")\n    if len(x) < 2:\n        return err\n    x = x[0]\n    if x.strip().startswith(\"//\"):\n        x = x.split(\"//\")[1].strip()\n    return x.strip()\n\ndef write_into_file(error_codes, f_path):\n    with open(f_path, \"w\") as f:\n        f.write(\"// Error messages for EXXXX errors.  Each message should start and end with a\\n\")\n        f.write(\"// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\\n\")\n        f.write(\"// use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\\n\\n\")\n        f.write(\"syntax::register_diagnostics! {\\n\\n\")\n        error_codes[\"long\"].sort()\n        for i in error_codes[\"long\"]:\n            f.write(i)\n            f.write(\"\\n\\n\")\n        f.write(\";\\n\")\n        error_codes[\"short\"] = sorted(error_codes[\"short\"], key=lambda err: get_error_code(err))\n        for i in error_codes[\"short\"]:\n            f.write(i)\n            f.write(\"\\n\")\n        f.write(\"}\\n\")\n\nerror_codes = {\n    \"long\": [],\n    \"short\": []\n}\nloop_dirs(error_codes, \"src\")\nwrite_into_file(error_codes, \"src/librustc_error_codes/src/error_codes.rs\")\n```\n</details>\n\nAnd to move the error codes into their own files:\n\n<details>\n\n```python\nimport os\n\ntry:\n    os.mkdir(\"src/librustc_error_codes/error_codes\")\nexcept OSError:\n    print(\"Seems like folder already exist, moving on!\")\ndata = ''\nwith open(\"src/librustc_error_codes/error_codes.rs\") as f:\n    x = f.read().split('\\n')\n    i = 0\n    short_part = False\n    while i < len(x):\n        line = x[i]\n        if short_part is False and line.startswith('E0') and line.endswith(': r##\"'):\n            err_code = line.split(':')[0]\n            i += 1\n            content = ''\n            while i < len(x):\n                if x[i] == '\"##,':\n                    break\n                content += x[i]\n                content += '\\n'\n                i += 1\n            f_path = \"src/librustc_error_codes/error_codes/{}.md\".format(err_code)\n            with open(f_path, \"w\") as ff:\n                ff.write(content)\n            data += '{}: include_str!(\"./error_codes/{}.md\"),'.format(err_code, err_code)\n        elif short_part is False and line == ';':\n            short_part is True\n            data += ';\\n'\n        else:\n            data += line\n            data += '\\n'\n        i += 1\nwith open(\"src/librustc_error_codes/error_codes.rs\", \"w\") as f:\n    f.write(data)\n```\n</details>", "tree": {"sha": "36152685fe6c0e03e5a834a396f553263086e27d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36152685fe6c0e03e5a834a396f553263086e27d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82cf3a4486bc882207a09bf0d9e2dea4632781aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82cf3a4486bc882207a09bf0d9e2dea4632781aa", "html_url": "https://github.com/rust-lang/rust/commit/82cf3a4486bc882207a09bf0d9e2dea4632781aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82cf3a4486bc882207a09bf0d9e2dea4632781aa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d63b24ffcc48f44ef09e0369e6516d6f2dec3520", "url": "https://api.github.com/repos/rust-lang/rust/commits/d63b24ffcc48f44ef09e0369e6516d6f2dec3520", "html_url": "https://github.com/rust-lang/rust/commit/d63b24ffcc48f44ef09e0369e6516d6f2dec3520"}, {"sha": "b5b2a8984e57260bb91d3327490da74f6fa310db", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b2a8984e57260bb91d3327490da74f6fa310db", "html_url": "https://github.com/rust-lang/rust/commit/b5b2a8984e57260bb91d3327490da74f6fa310db"}], "stats": {"total": 27223, "additions": 13256, "deletions": 13967}, "files": [{"sha": "781184af9a96c85b573f11196b157e5c8f018d4e", "filename": "Cargo.lock", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -3120,13 +3120,15 @@ dependencies = [\n  \"graphviz\",\n  \"jobserver\",\n  \"log\",\n+ \"measureme\",\n  \"num_cpus\",\n  \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n  \"rustc-rayon 0.3.0\",\n  \"rustc-rayon-core 0.3.0\",\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n  \"rustc_index\",\n@@ -3439,6 +3441,7 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_fs_util\",\n  \"rustc_incremental\",\n@@ -3516,6 +3519,10 @@ dependencies = [\n  \"syntax_pos\",\n ]\n \n+[[package]]\n+name = \"rustc_error_codes\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"rustc_errors\"\n version = \"0.0.0\"\n@@ -3569,6 +3576,7 @@ dependencies = [\n  \"rustc_codegen_ssa\",\n  \"rustc_codegen_utils\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_incremental\",\n  \"rustc_lint\",\n@@ -3605,6 +3613,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_index\",\n  \"rustc_target\",\n  \"syntax\",\n@@ -3650,6 +3659,7 @@ dependencies = [\n  \"memmap\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_parse\",\n@@ -3675,6 +3685,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n@@ -3703,6 +3714,7 @@ dependencies = [\n  \"bitflags\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_lexer\",\n  \"rustc_target\",\n@@ -3718,6 +3730,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_parse\",\n@@ -3738,6 +3751,7 @@ name = \"rustc_plugin_impl\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustc\",\n+ \"rustc_error_codes\",\n  \"rustc_metadata\",\n  \"syntax\",\n  \"syntax_expand\",\n@@ -3751,6 +3765,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_typeck\",\n  \"syntax\",\n  \"syntax_pos\",\n@@ -3765,6 +3780,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_metadata\",\n  \"smallvec 1.0.0\",\n@@ -3844,6 +3860,7 @@ dependencies = [\n  \"log\",\n  \"rustc\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_target\",\n@@ -4380,6 +4397,7 @@ dependencies = [\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n@@ -4411,6 +4429,7 @@ dependencies = [\n  \"fmt_macros\",\n  \"log\",\n  \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_parse\",\n  \"rustc_target\","}, {"sha": "adf58d6471b5e860b9d15d0a6b3419f1bdbf2266", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -40,3 +40,5 @@ byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+measureme = \"0.4\"\n+rustc_error_codes = { path = \"../librustc_error_codes\" }"}, {"sha": "d5c2db5fb970532a0ad078d9c042cf6647a048ba", "filename": "src/librustc/error_codes.rs", "status": "removed", "additions": 0, "deletions": 2394, "changes": 2394, "blob_url": "https://github.com/rust-lang/rust/blob/d63b24ffcc48f44ef09e0369e6516d6f2dec3520/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63b24ffcc48f44ef09e0369e6516d6f2dec3520/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=d63b24ffcc48f44ef09e0369e6516d6f2dec3520", "patch": "@@ -1,2394 +0,0 @@\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80\n-// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n-// `:set tw=0` to disable.\n-syntax::register_diagnostics! {\n-E0038: r##\"\n-Trait objects like `Box<Trait>` can only be constructed when certain\n-requirements are satisfied by the trait in question.\n-\n-Trait objects are a form of dynamic dispatch and use a dynamically sized type\n-for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n-type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n-pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n-(among other things) for dynamic dispatch. This design mandates some\n-restrictions on the types of traits that are allowed to be used in trait\n-objects, which are collectively termed as 'object safety' rules.\n-\n-Attempting to create a trait object for a non object-safe trait will trigger\n-this error.\n-\n-There are various rules:\n-\n-### The trait cannot require `Self: Sized`\n-\n-When `Trait` is treated as a type, the type does not implement the special\n-`Sized` trait, because the type does not have a known size at compile time and\n-can only be accessed behind a pointer. Thus, if we have a trait like the\n-following:\n-\n-```\n-trait Foo where Self: Sized {\n-\n-}\n-```\n-\n-We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n-`Self` would not be `Sized`.\n-\n-Generally, `Self: Sized` is used to indicate that the trait should not be used\n-as a trait object. If the trait comes from your own crate, consider removing\n-this restriction.\n-\n-### Method references the `Self` type in its parameters or return type\n-\n-This happens when a trait has a method like the following:\n-\n-```\n-trait Trait {\n-    fn foo(&self) -> Self;\n-}\n-\n-impl Trait for String {\n-    fn foo(&self) -> Self {\n-        \"hi\".to_owned()\n-    }\n-}\n-\n-impl Trait for u8 {\n-    fn foo(&self) -> Self {\n-        1\n-    }\n-}\n-```\n-\n-(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n-cause this problem.)\n-\n-In such a case, the compiler cannot predict the return type of `foo()` in a\n-situation like the following:\n-\n-```compile_fail\n-trait Trait {\n-    fn foo(&self) -> Self;\n-}\n-\n-fn call_foo(x: Box<Trait>) {\n-    let y = x.foo(); // What type is y?\n-    // ...\n-}\n-```\n-\n-If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n-on them to mark them as explicitly unavailable to trait objects. The\n-functionality will still be available to all other implementers, including\n-`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n-\n-```\n-trait Trait {\n-    fn foo(&self) -> Self where Self: Sized;\n-    // more functions\n-}\n-```\n-\n-Now, `foo()` can no longer be called on a trait object, but you will now be\n-allowed to make a trait object, and that will be able to call any object-safe\n-methods. With such a bound, one can still call `foo()` on types implementing\n-that trait that aren't behind trait objects.\n-\n-### Method has generic type parameters\n-\n-As mentioned before, trait objects contain pointers to method tables. So, if we\n-have:\n-\n-```\n-trait Trait {\n-    fn foo(&self);\n-}\n-\n-impl Trait for String {\n-    fn foo(&self) {\n-        // implementation 1\n-    }\n-}\n-\n-impl Trait for u8 {\n-    fn foo(&self) {\n-        // implementation 2\n-    }\n-}\n-// ...\n-```\n-\n-At compile time each implementation of `Trait` will produce a table containing\n-the various methods (and other items) related to the implementation.\n-\n-This works fine, but when the method gains generic parameters, we can have a\n-problem.\n-\n-Usually, generic parameters get _monomorphized_. For example, if I have\n-\n-```\n-fn foo<T>(x: T) {\n-    // ...\n-}\n-```\n-\n-The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n-other type substitution is different. Hence the compiler generates the\n-implementation on-demand. If you call `foo()` with a `bool` parameter, the\n-compiler will only generate code for `foo::<bool>()`. When we have additional\n-type parameters, the number of monomorphized implementations the compiler\n-generates does not grow drastically, since the compiler will only generate an\n-implementation if the function is called with unparametrized substitutions\n-(i.e., substitutions where none of the substituted types are themselves\n-parametrized).\n-\n-However, with trait objects we have to make a table containing _every_ object\n-that implements the trait. Now, if it has type parameters, we need to add\n-implementations for every type that implements the trait, and there could\n-theoretically be an infinite number of types.\n-\n-For example, with:\n-\n-```\n-trait Trait {\n-    fn foo<T>(&self, on: T);\n-    // more methods\n-}\n-\n-impl Trait for String {\n-    fn foo<T>(&self, on: T) {\n-        // implementation 1\n-    }\n-}\n-\n-impl Trait for u8 {\n-    fn foo<T>(&self, on: T) {\n-        // implementation 2\n-    }\n-}\n-\n-// 8 more implementations\n-```\n-\n-Now, if we have the following code:\n-\n-```compile_fail,E0038\n-# trait Trait { fn foo<T>(&self, on: T); }\n-# impl Trait for String { fn foo<T>(&self, on: T) {} }\n-# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n-# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n-# // etc.\n-fn call_foo(thing: Box<Trait>) {\n-    thing.foo(true); // this could be any one of the 8 types above\n-    thing.foo(1);\n-    thing.foo(\"hello\");\n-}\n-```\n-\n-We don't just need to create a table of all implementations of all methods of\n-`Trait`, we need to create such a table, for each different type fed to\n-`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n-types being fed to `foo()`) = 30 implementations!\n-\n-With real world traits these numbers can grow drastically.\n-\n-To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n-fix for the sub-error above if you do not intend to call the method with type\n-parameters:\n-\n-```\n-trait Trait {\n-    fn foo<T>(&self, on: T) where Self: Sized;\n-    // more methods\n-}\n-```\n-\n-If this is not an option, consider replacing the type parameter with another\n-trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n-number of types you intend to feed to this method is limited, consider manually\n-listing out the methods of different types.\n-\n-### Method has no receiver\n-\n-Methods that do not take a `self` parameter can't be called since there won't be\n-a way to get a pointer to the method table for them.\n-\n-```\n-trait Foo {\n-    fn foo() -> u8;\n-}\n-```\n-\n-This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n-an implementation.\n-\n-Adding a `Self: Sized` bound to these methods will generally make this compile.\n-\n-```\n-trait Foo {\n-    fn foo() -> u8 where Self: Sized;\n-}\n-```\n-\n-### The trait cannot contain associated constants\n-\n-Just like static functions, associated constants aren't stored on the method\n-table. If the trait or any subtrait contain an associated constant, they cannot\n-be made into an object.\n-\n-```compile_fail,E0038\n-trait Foo {\n-    const X: i32;\n-}\n-\n-impl Foo {}\n-```\n-\n-A simple workaround is to use a helper method instead:\n-\n-```\n-trait Foo {\n-    fn x(&self) -> i32;\n-}\n-```\n-\n-### The trait cannot use `Self` as a type parameter in the supertrait listing\n-\n-This is similar to the second sub-error, but subtler. It happens in situations\n-like the following:\n-\n-```compile_fail,E0038\n-trait Super<A: ?Sized> {}\n-\n-trait Trait: Super<Self> {\n-}\n-\n-struct Foo;\n-\n-impl Super<Foo> for Foo{}\n-\n-impl Trait for Foo {}\n-\n-fn main() {\n-    let x: Box<dyn Trait>;\n-}\n-```\n-\n-Here, the supertrait might have methods as follows:\n-\n-```\n-trait Super<A: ?Sized> {\n-    fn get_a(&self) -> &A; // note that this is object safe!\n-}\n-```\n-\n-If the trait `Trait` was deriving from something like `Super<String>` or\n-`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n-`get_a()` will definitely return an object of that type.\n-\n-However, if it derives from `Super<Self>`, even though `Super` is object safe,\n-the method `get_a()` would return an object of unknown type when called on the\n-function. `Self` type parameters let us make object safe traits no longer safe,\n-so they are forbidden when specifying supertraits.\n-\n-There's no easy fix for this, generally code will need to be refactored so that\n-you no longer need to derive from `Super<Self>`.\n-\"##,\n-\n-E0072: r##\"\n-When defining a recursive struct or enum, any use of the type being defined\n-from inside the definition must occur behind a pointer (like `Box` or `&`).\n-This is because structs and enums must have a well-defined size, and without\n-the pointer, the size of the type would need to be unbounded.\n-\n-Consider the following erroneous definition of a type for a list of bytes:\n-\n-```compile_fail,E0072\n-// error, invalid recursive struct type\n-struct ListNode {\n-    head: u8,\n-    tail: Option<ListNode>,\n-}\n-```\n-\n-This type cannot have a well-defined size, because it needs to be arbitrarily\n-large (since we would be able to nest `ListNode`s to any depth). Specifically,\n-\n-```plain\n-size of `ListNode` = 1 byte for `head`\n-                   + 1 byte for the discriminant of the `Option`\n-                   + size of `ListNode`\n-```\n-\n-One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n-\n-```\n-struct ListNode {\n-    head: u8,\n-    tail: Option<Box<ListNode>>,\n-}\n-```\n-\n-This works because `Box` is a pointer, so its size is well-known.\n-\"##,\n-\n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate a\n-constant expression that had to be evaluated. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```compile_fail,E0080\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n-E0106: r##\"\n-This error indicates that a lifetime is missing from a type. If it is an error\n-inside a function signature, the problem may be with failing to adhere to the\n-lifetime elision rules (see below).\n-\n-Here are some simple examples of where you'll run into this error:\n-\n-```compile_fail,E0106\n-struct Foo1 { x: &bool }\n-              // ^ expected lifetime parameter\n-struct Foo2<'a> { x: &'a bool } // correct\n-\n-struct Bar1 { x: Foo2 }\n-              // ^^^^ expected lifetime parameter\n-struct Bar2<'a> { x: Foo2<'a> } // correct\n-\n-enum Baz1 { A(u8), B(&bool), }\n-                  // ^ expected lifetime parameter\n-enum Baz2<'a> { A(u8), B(&'a bool), } // correct\n-\n-type MyStr1 = &str;\n-           // ^ expected lifetime parameter\n-type MyStr2<'a> = &'a str; // correct\n-```\n-\n-Lifetime elision is a special, limited kind of inference for lifetimes in\n-function signatures which allows you to leave out lifetimes in certain cases.\n-For more background on lifetime elision see [the book][book-le].\n-\n-The lifetime elision rules require that any function signature with an elided\n-output lifetime must either have\n-\n- - exactly one input lifetime\n- - or, multiple input lifetimes, but the function must also be a method with a\n-   `&self` or `&mut self` receiver\n-\n-In the first case, the output lifetime is inferred to be the same as the unique\n-input lifetime. In the second case, the lifetime is instead inferred to be the\n-same as the lifetime on `&self` or `&mut self`.\n-\n-Here are some examples of elision errors:\n-\n-```compile_fail,E0106\n-// error, no input lifetimes\n-fn foo() -> &str { }\n-\n-// error, `x` and `y` have distinct lifetimes inferred\n-fn bar(x: &str, y: &str) -> &str { }\n-\n-// error, `y`'s lifetime is inferred to be distinct from `x`'s\n-fn baz<'a>(x: &'a str, y: &str) -> &str { }\n-```\n-\n-[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision\n-\"##,\n-\n-E0119: r##\"\n-There are conflicting trait implementations for the same type.\n-Example of erroneous code:\n-\n-```compile_fail,E0119\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo {\n-    value: usize\n-}\n-\n-impl MyTrait for Foo { // error: conflicting implementations of trait\n-                       //        `MyTrait` for type `Foo`\n-    fn get(&self) -> usize { self.value }\n-}\n-```\n-\n-When looking for the implementation for the trait, the compiler finds\n-both the `impl<T> MyTrait for T` where T is all types and the `impl\n-MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n-this is an error. So, when you write:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-```\n-\n-This makes the trait implemented on all types in the scope. So if you\n-try to implement it on another one after that, the implementations will\n-conflict. Example:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo;\n-\n-fn main() {\n-    let f = Foo;\n-\n-    f.get(); // the trait is implemented so we can use it\n-}\n-```\n-\"##,\n-\n-E0139: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-There are various restrictions on transmuting between types in Rust; for example\n-types being transmuted must have the same size. To apply all these restrictions,\n-the compiler must know the exact types that may be transmuted. When type\n-parameters are involved, this cannot always be done.\n-\n-So, for example, the following is not allowed:\n-\n-```\n-use std::mem::transmute;\n-\n-struct Foo<T>(Vec<T>);\n-\n-fn foo<T>(x: Vec<T>) {\n-    // we are transmuting between Vec<T> and Foo<F> here\n-    let y: Foo<T> = unsafe { transmute(x) };\n-    // do something with y\n-}\n-```\n-\n-In this specific case there's a good chance that the transmute is harmless (but\n-this is not guaranteed by Rust). However, when alignment and enum optimizations\n-come into the picture, it's quite likely that the sizes may or may not match\n-with different type parameter substitutions. It's not possible to check this for\n-_all_ possible types, so `transmute()` simply only accepts types without any\n-unsubstituted type parameters.\n-\n-If you need this, there's a good chance you're doing something wrong. Keep in\n-mind that Rust doesn't guarantee much about the layout of different structs\n-(even two structs with identical declarations may have different layouts). If\n-there is a solution that avoids the transmute entirely, try it instead.\n-\n-If it's possible, hand-monomorphize the code by writing the function for each\n-possible type substitution. It's possible to use traits to do this cleanly,\n-for example:\n-\n-```\n-use std::mem::transmute;\n-\n-struct Foo<T>(Vec<T>);\n-\n-trait MyTransmutableType: Sized {\n-    fn transmute(_: Vec<Self>) -> Foo<Self>;\n-}\n-\n-impl MyTransmutableType for u8 {\n-    fn transmute(x: Vec<u8>) -> Foo<u8> {\n-        unsafe { transmute(x) }\n-    }\n-}\n-\n-impl MyTransmutableType for String {\n-    fn transmute(x: Vec<String>) -> Foo<String> {\n-        unsafe { transmute(x) }\n-    }\n-}\n-\n-// ... more impls for the types you intend to transmute\n-\n-fn foo<T: MyTransmutableType>(x: Vec<T>) {\n-    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n-    // do something with y\n-}\n-```\n-\n-Each impl will be checked for a size match in the transmute as usual, and since\n-there are no unbound type parameters involved, this should compile unless there\n-is a size mismatch in one of the impls.\n-\n-It is also possible to manually transmute:\n-\n-```\n-# use std::ptr;\n-# let v = Some(\"value\");\n-# type SomeType = &'static [u8];\n-unsafe {\n-    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n-}\n-# ;\n-```\n-\n-Note that this does not move `v` (unlike `transmute`), and may need a\n-call to `mem::forget(v)` in case you want to avoid destructors being called.\n-\"##,\n-\n-E0152: r##\"\n-A lang item was redefined.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0152\n-#![feature(lang_items)]\n-\n-#[lang = \"arc\"]\n-struct Foo; // error: duplicate lang item found: `arc`\n-```\n-\n-Lang items are already implemented in the standard library. Unless you are\n-writing a free-standing application (e.g., a kernel), you do not need to provide\n-them yourself.\n-\n-You can build a free-standing crate by adding `#![no_std]` to the crate\n-attributes:\n-\n-```ignore (only-for-syntax-highlight)\n-#![no_std]\n-```\n-\n-See also the [unstable book][1].\n-\n-[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n-\"##,\n-\n-E0214: r##\"\n-A generic type was described using parentheses rather than angle brackets.\n-For example:\n-\n-```compile_fail,E0214\n-fn main() {\n-    let v: Vec(&str) = vec![\"foo\"];\n-}\n-```\n-\n-This is not currently supported: `v` should be defined as `Vec<&str>`.\n-Parentheses are currently only used with generic types when defining parameters\n-for `Fn`-family traits.\n-\"##,\n-\n-E0230: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(rustc_attrs)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-There will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces contain an identifier which doesn't\n-match with any of the type parameters or the string `Self`. This might happen\n-if you misspelled a type parameter, or if you intended to use literal curly\n-braces. If it is the latter, escape the curly braces with a second curly brace\n-of the same type; e.g., a literal `{` is `{{`.\n-\"##,\n-\n-E0231: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(rustc_attrs)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-As you can see, you can specify type parameters in curly braces for\n-substitution with the actual types (using the regular format string syntax) in\n-a given situation. Furthermore, `{Self}` will substitute to the type (in this\n-case, `bool`) that we tried to use.\n-\n-This error appears when the curly braces do not contain an identifier. Please\n-add one of the same name as a type parameter. If you intended to use literal\n-braces, use `{{` and `}}` to escape them.\n-\"##,\n-\n-E0232: r##\"\n-The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n-message for when a particular trait isn't implemented on a type placed in a\n-position that needs that trait. For example, when the following code is\n-compiled:\n-\n-```compile_fail\n-#![feature(rustc_attrs)]\n-\n-fn foo<T: Index<u8>>(x: T){}\n-\n-#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n-trait Index<Idx> { /* ... */ }\n-\n-foo(true); // `bool` does not implement `Index<u8>`\n-```\n-\n-there will be an error about `bool` not implementing `Index<u8>`, followed by a\n-note saying \"the type `bool` cannot be indexed by `u8`\".\n-\n-For this to work, some note must be specified. An empty attribute will not do\n-anything, please remove the attribute or add some helpful note for users of the\n-trait.\n-\"##,\n-\n-E0261: r##\"\n-When using a lifetime like `'a` in a type, it must be declared before being\n-used.\n-\n-These two examples illustrate the problem:\n-\n-```compile_fail,E0261\n-// error, use of undeclared lifetime name `'a`\n-fn foo(x: &'a str) { }\n-\n-struct Foo {\n-    // error, use of undeclared lifetime name `'a`\n-    x: &'a str,\n-}\n-```\n-\n-These can be fixed by declaring lifetime parameters:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a str,\n-}\n-\n-fn foo<'a>(x: &'a str) {}\n-```\n-\n-Impl blocks declare lifetime parameters separately. You need to add lifetime\n-parameters to an impl block if you're implementing a type that has a lifetime\n-parameter of its own.\n-For example:\n-\n-```compile_fail,E0261\n-struct Foo<'a> {\n-    x: &'a str,\n-}\n-\n-// error,  use of undeclared lifetime name `'a`\n-impl Foo<'a> {\n-    fn foo<'a>(x: &'a str) {}\n-}\n-```\n-\n-This is fixed by declaring the impl block like this:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a str,\n-}\n-\n-// correct\n-impl<'a> Foo<'a> {\n-    fn foo(x: &'a str) {}\n-}\n-```\n-\"##,\n-\n-E0262: r##\"\n-Declaring certain lifetime names in parameters is disallowed. For example,\n-because the `'static` lifetime is a special built-in lifetime name denoting\n-the lifetime of the entire program, this is an error:\n-\n-```compile_fail,E0262\n-// error, invalid lifetime parameter name `'static`\n-fn foo<'static>(x: &'static str) { }\n-```\n-\"##,\n-\n-E0263: r##\"\n-A lifetime name cannot be declared more than once in the same scope. For\n-example:\n-\n-```compile_fail,E0263\n-// error, lifetime name `'a` declared twice in the same scope\n-fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n-```\n-\"##,\n-\n-E0264: r##\"\n-An unknown external lang item was used. Erroneous code example:\n-\n-```compile_fail,E0264\n-#![feature(lang_items)]\n-\n-extern \"C\" {\n-    #[lang = \"cake\"] // error: unknown external lang item: `cake`\n-    fn cake();\n-}\n-```\n-\n-A list of available external lang items is available in\n-`src/librustc/middle/weak_lang_items.rs`. Example:\n-\n-```\n-#![feature(lang_items)]\n-\n-extern \"C\" {\n-    #[lang = \"panic_impl\"] // ok!\n-    fn cake();\n-}\n-```\n-\"##,\n-\n-E0271: r##\"\n-This is because of a type mismatch between the associated type of some\n-trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n-and another type `U` that is required to be equal to `T::Bar`, but is not.\n-Examples follow.\n-\n-Here is a basic example:\n-\n-```compile_fail,E0271\n-trait Trait { type AssociatedType; }\n-\n-fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-\n-foo(3_i8);\n-```\n-\n-Here is that same example again, with some explanatory comments:\n-\n-```compile_fail,E0271\n-trait Trait { type AssociatedType; }\n-\n-fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n-//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n-//                        |            |\n-//         This says `foo` can         |\n-//           only be used with         |\n-//              some type that         |\n-//         implements `Trait`.         |\n-//                                     |\n-//                             This says not only must\n-//                             `T` be an impl of `Trait`\n-//                             but also that the impl\n-//                             must assign the type `u32`\n-//                             to the associated type.\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-//      |                             |\n-// `i8` does have                     |\n-// implementation                     |\n-// of `Trait`...                      |\n-//                     ... but it is an implementation\n-//                     that assigns `&'static str` to\n-//                     the associated type.\n-\n-foo(3_i8);\n-// Here, we invoke `foo` with an `i8`, which does not satisfy\n-// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n-// therefore the type-checker complains with this error code.\n-```\n-\n-To avoid those issues, you have to make the types match correctly.\n-So we can fix the previous examples like this:\n-\n-```\n-// Basic Example:\n-trait Trait { type AssociatedType; }\n-\n-fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n-    println!(\"in foo\");\n-}\n-\n-impl Trait for i8 { type AssociatedType = &'static str; }\n-\n-foo(3_i8);\n-\n-// For-Loop Example:\n-let vs = vec![1, 2, 3, 4];\n-for v in &vs {\n-    match v {\n-        &1 => {}\n-        _ => {}\n-    }\n-}\n-```\n-\"##,\n-\n-\n-E0275: r##\"\n-This error occurs when there was a recursive trait requirement that overflowed\n-before it could be evaluated. Often this means that there is unbounded\n-recursion in resolving some type bounds.\n-\n-For example, in the following code:\n-\n-```compile_fail,E0275\n-trait Foo {}\n-\n-struct Bar<T>(T);\n-\n-impl<T> Foo for T where Bar<T>: Foo {}\n-```\n-\n-To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n-to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n-determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\n-clearly a recursive requirement that can't be resolved directly.\n-\n-Consider changing your trait bounds so that they're less self-referential.\n-\"##,\n-\n-E0276: r##\"\n-This error occurs when a bound in an implementation of a trait does not match\n-the bounds specified in the original trait. For example:\n-\n-```compile_fail,E0276\n-trait Foo {\n-    fn foo<T>(x: T);\n-}\n-\n-impl Foo for bool {\n-    fn foo<T>(x: T) where T: Copy {}\n-}\n-```\n-\n-Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\n-take any type `T`. However, in the `impl` for `bool`, we have added an extra\n-bound that `T` is `Copy`, which isn't compatible with the original trait.\n-\n-Consider removing the bound from the method or adding the bound to the original\n-method definition in the trait.\n-\"##,\n-\n-E0277: r##\"\n-You tried to use a type which doesn't implement some trait in a place which\n-expected that trait. Erroneous code example:\n-\n-```compile_fail,E0277\n-// here we declare the Foo trait with a bar method\n-trait Foo {\n-    fn bar(&self);\n-}\n-\n-// we now declare a function which takes an object implementing the Foo trait\n-fn some_func<T: Foo>(foo: T) {\n-    foo.bar();\n-}\n-\n-fn main() {\n-    // we now call the method with the i32 type, which doesn't implement\n-    // the Foo trait\n-    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n-}\n-```\n-\n-In order to fix this error, verify that the type you're using does implement\n-the trait. Example:\n-\n-```\n-trait Foo {\n-    fn bar(&self);\n-}\n-\n-fn some_func<T: Foo>(foo: T) {\n-    foo.bar(); // we can now use this method since i32 implements the\n-               // Foo trait\n-}\n-\n-// we implement the trait on the i32 type\n-impl Foo for i32 {\n-    fn bar(&self) {}\n-}\n-\n-fn main() {\n-    some_func(5i32); // ok!\n-}\n-```\n-\n-Or in a generic context, an erroneous code example would look like:\n-\n-```compile_fail,E0277\n-fn some_func<T>(foo: T) {\n-    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n-                           //        implemented for the type `T`\n-}\n-\n-fn main() {\n-    // We now call the method with the i32 type,\n-    // which *does* implement the Debug trait.\n-    some_func(5i32);\n-}\n-```\n-\n-Note that the error here is in the definition of the generic function: Although\n-we only call it with a parameter that does implement `Debug`, the compiler\n-still rejects the function: It must work with all possible input types. In\n-order to make this example compile, we need to restrict the generic type we're\n-accepting:\n-\n-```\n-use std::fmt;\n-\n-// Restrict the input type to types that implement Debug.\n-fn some_func<T: fmt::Debug>(foo: T) {\n-    println!(\"{:?}\", foo);\n-}\n-\n-fn main() {\n-    // Calling the method is still fine, as i32 implements Debug.\n-    some_func(5i32);\n-\n-    // This would fail to compile now:\n-    // struct WithoutDebug;\n-    // some_func(WithoutDebug);\n-}\n-```\n-\n-Rust only looks at the signature of the called function, as such it must\n-already specify all requirements that will be used for every type parameter.\n-\"##,\n-\n-E0281: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-You tried to supply a type which doesn't implement some trait in a location\n-which expected that trait. This error typically occurs when working with\n-`Fn`-based types. Erroneous code example:\n-\n-```compile-fail\n-fn foo<F: Fn(usize)>(x: F) { }\n-\n-fn main() {\n-    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,\n-    // but the trait `core::ops::Fn<(usize,)>` is required\n-    // [E0281]\n-    foo(|y: String| { });\n-}\n-```\n-\n-The issue in this case is that `foo` is defined as accepting a `Fn` with one\n-argument of type `String`, but the closure we attempted to pass to it requires\n-one arguments of type `usize`.\n-\"##,\n-\n-E0282: r##\"\n-This error indicates that type inference did not result in one unique possible\n-type, and extra information is required. In most cases this can be provided\n-by adding a type annotation. Sometimes you need to specify a generic type\n-parameter manually.\n-\n-A common example is the `collect` method on `Iterator`. It has a generic type\n-parameter with a `FromIterator` bound, which for a `char` iterator is\n-implemented by `Vec` and `String` among others. Consider the following snippet\n-that reverses the characters of a string:\n-\n-```compile_fail,E0282\n-let x = \"hello\".chars().rev().collect();\n-```\n-\n-In this case, the compiler cannot infer what the type of `x` should be:\n-`Vec<char>` and `String` are both suitable candidates. To specify which type to\n-use, you can use a type annotation on `x`:\n-\n-```\n-let x: Vec<char> = \"hello\".chars().rev().collect();\n-```\n-\n-It is not necessary to annotate the full type. Once the ambiguity is resolved,\n-the compiler can infer the rest:\n-\n-```\n-let x: Vec<_> = \"hello\".chars().rev().collect();\n-```\n-\n-Another way to provide the compiler with enough information, is to specify the\n-generic type parameter:\n-\n-```\n-let x = \"hello\".chars().rev().collect::<Vec<char>>();\n-```\n-\n-Again, you need not specify the full type if the compiler can infer it:\n-\n-```\n-let x = \"hello\".chars().rev().collect::<Vec<_>>();\n-```\n-\n-Apart from a method or function with a generic type parameter, this error can\n-occur when a type parameter of a struct or trait cannot be inferred. In that\n-case it is not always possible to use a type annotation, because all candidates\n-have the same return type. For instance:\n-\n-```compile_fail,E0282\n-struct Foo<T> {\n-    num: T,\n-}\n-\n-impl<T> Foo<T> {\n-    fn bar() -> i32 {\n-        0\n-    }\n-\n-    fn baz() {\n-        let number = Foo::bar();\n-    }\n-}\n-```\n-\n-This will fail because the compiler does not know which instance of `Foo` to\n-call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n-\"##,\n-\n-E0283: r##\"\n-This error occurs when the compiler doesn't have enough information\n-to unambiguously choose an implementation.\n-\n-For example:\n-\n-```compile_fail,E0283\n-trait Generator {\n-    fn create() -> u32;\n-}\n-\n-struct Impl;\n-\n-impl Generator for Impl {\n-    fn create() -> u32 { 1 }\n-}\n-\n-struct AnotherImpl;\n-\n-impl Generator for AnotherImpl {\n-    fn create() -> u32 { 2 }\n-}\n-\n-fn main() {\n-    let cont: u32 = Generator::create();\n-    // error, impossible to choose one of Generator trait implementation\n-    // Should it be Impl or AnotherImpl, maybe something else?\n-}\n-```\n-\n-To resolve this error use the concrete type:\n-\n-```\n-trait Generator {\n-    fn create() -> u32;\n-}\n-\n-struct AnotherImpl;\n-\n-impl Generator for AnotherImpl {\n-    fn create() -> u32 { 2 }\n-}\n-\n-fn main() {\n-    let gen1 = AnotherImpl::create();\n-\n-    // if there are multiple methods with same name (different traits)\n-    let gen2 = <AnotherImpl as Generator>::create();\n-}\n-```\n-\"##,\n-\n-E0284: r##\"\n-This error occurs when the compiler is unable to unambiguously infer the\n-return type of a function or method which is generic on return type, such\n-as the `collect` method for `Iterator`s.\n-\n-For example:\n-\n-```compile_fail,E0284\n-fn foo() -> Result<bool, ()> {\n-    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n-    let v: Vec<bool> = results.collect()?;\n-    // Do things with v...\n-    Ok(true)\n-}\n-```\n-\n-Here we have an iterator `results` over `Result<bool, ()>`.\n-Hence, `results.collect()` can return any type implementing\n-`FromIterator<Result<bool, ()>>`. On the other hand, the\n-`?` operator can accept any type implementing `Try`.\n-\n-The author of this code probably wants `collect()` to return a\n-`Result<Vec<bool>, ()>`, but the compiler can't be sure\n-that there isn't another type `T` implementing both `Try` and\n-`FromIterator<Result<bool, ()>>` in scope such that\n-`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\n-is returned.\n-\n-To resolve this error, use a concrete type for the intermediate expression:\n-\n-```\n-fn foo() -> Result<bool, ()> {\n-    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n-    let v = {\n-        let temp: Result<Vec<bool>, ()> = results.collect();\n-        temp?\n-    };\n-    // Do things with v...\n-    Ok(true)\n-}\n-```\n-\n-Note that the type of `v` can now be inferred from the type of `temp`.\n-\"##,\n-\n-E0308: r##\"\n-This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n-\n-For example:\n-\n-```compile_fail,E0308\n-let x: i32 = \"I am not a number!\";\n-//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n-//      |             |\n-//      |    initializing expression;\n-//      |    compiler infers type `&str`\n-//      |\n-//    type `i32` assigned to variable `x`\n-```\n-\"##,\n-\n-E0309: r##\"\n-The type definition contains some field whose type\n-requires an outlives annotation. Outlives annotations\n-(e.g., `T: 'a`) are used to guarantee that all the data in T is valid\n-for at least the lifetime `'a`. This scenario most commonly\n-arises when the type contains an associated type reference\n-like `<T as SomeTrait<'a>>::Output`, as shown in this example:\n-\n-```compile_fail,E0309\n-// This won't compile because the applicable impl of\n-// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n-// not have a matching where-clause.\n-struct Foo<'a, T> {\n-    foo: <T as SomeTrait<'a>>::Output,\n-}\n-\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T\n-where\n-    T: 'a,\n-{\n-    type Output = u32;\n-}\n-```\n-\n-Here, the where clause `T: 'a` that appears on the impl is not known to be\n-satisfied on the struct. To make this example compile, you have to add\n-a where-clause like `T: 'a` to the struct definition:\n-\n-```\n-struct Foo<'a, T>\n-where\n-    T: 'a,\n-{\n-    foo: <T as SomeTrait<'a>>::Output\n-}\n-\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T\n-where\n-    T: 'a,\n-{\n-    type Output = u32;\n-}\n-```\n-\"##,\n-\n-E0310: r##\"\n-Types in type definitions have lifetimes associated with them that represent\n-how long the data stored within them is guaranteed to be live. This lifetime\n-must be as long as the data needs to be alive, and missing the constraint that\n-denotes this will cause this error.\n-\n-```compile_fail,E0310\n-// This won't compile because T is not constrained to the static lifetime\n-// the reference needs\n-struct Foo<T> {\n-    foo: &'static T\n-}\n-```\n-\n-This will compile, because it has the constraint on the type parameter:\n-\n-```\n-struct Foo<T: 'static> {\n-    foo: &'static T\n-}\n-```\n-\"##,\n-\n-E0312: r##\"\n-Reference's lifetime of borrowed content doesn't match the expected lifetime.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0312\n-pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'static str {\n-    if maybestr.is_none() {\n-        \"(none)\"\n-    } else {\n-        let s: &'a str = maybestr.as_ref().unwrap();\n-        s  // Invalid lifetime!\n-    }\n-}\n-```\n-\n-To fix this error, either lessen the expected lifetime or find a way to not have\n-to use this reference outside of its current scope (by running the code directly\n-in the same block for example?):\n-\n-```\n-// In this case, we can fix the issue by switching from \"static\" lifetime to 'a\n-pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n-    if maybestr.is_none() {\n-        \"(none)\"\n-    } else {\n-        let s: &'a str = maybestr.as_ref().unwrap();\n-        s  // Ok!\n-    }\n-}\n-```\n-\"##,\n-\n-E0317: r##\"\n-This error occurs when an `if` expression without an `else` block is used in a\n-context where a type other than `()` is expected, for example a `let`\n-expression:\n-\n-```compile_fail,E0317\n-fn main() {\n-    let x = 5;\n-    let a = if x == 5 { 1 };\n-}\n-```\n-\n-An `if` expression without an `else` block has the type `()`, so this is a type\n-error. To resolve it, add an `else` block having the same type as the `if`\n-block.\n-\"##,\n-\n-E0391: r##\"\n-This error indicates that some types or traits depend on each other\n-and therefore cannot be constructed.\n-\n-The following example contains a circular dependency between two traits:\n-\n-```compile_fail,E0391\n-trait FirstTrait : SecondTrait {\n-\n-}\n-\n-trait SecondTrait : FirstTrait {\n-\n-}\n-```\n-\"##,\n-\n-E0398: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-In Rust 1.3, the default object lifetime bounds are expected to change, as\n-described in [RFC 1156]. You are getting a warning because the compiler\n-thinks it is possible that this change will cause a compilation error in your\n-code. It is possible, though unlikely, that this is a false alarm.\n-\n-The heart of the change is that where `&'a Box<SomeTrait>` used to default to\n-`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,\n-`SomeTrait` is the name of some trait type). Note that the only types which are\n-affected are references to boxes, like `&Box<SomeTrait>` or\n-`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\n-are unaffected.\n-\n-To silence this warning, edit your code to use an explicit bound. Most of the\n-time, this means that you will want to change the signature of a function that\n-you are calling. For example, if the error is reported on a call like `foo(x)`,\n-and `foo` is defined as follows:\n-\n-```\n-# trait SomeTrait {}\n-fn foo(arg: &Box<SomeTrait>) { /* ... */ }\n-```\n-\n-You might change it to:\n-\n-```\n-# trait SomeTrait {}\n-fn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }\n-```\n-\n-This explicitly states that you expect the trait object `SomeTrait` to contain\n-references (with a maximum lifetime of `'a`).\n-\n-[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md\n-\"##,\n-\n-E0452: r##\"\n-An invalid lint attribute has been given. Erroneous code example:\n-\n-```compile_fail,E0452\n-#![allow(foo = \"\")] // error: malformed lint attribute\n-```\n-\n-Lint attributes only accept a list of identifiers (where each identifier is a\n-lint name). Ensure the attribute is of this form:\n-\n-```\n-#![allow(foo)] // ok!\n-// or:\n-#![allow(foo, foo2)] // ok!\n-```\n-\"##,\n-\n-E0453: r##\"\n-A lint check attribute was overruled by a `forbid` directive set as an\n-attribute on an enclosing scope, or on the command line with the `-F` option.\n-\n-Example of erroneous code:\n-\n-```compile_fail,E0453\n-#![forbid(non_snake_case)]\n-\n-#[allow(non_snake_case)]\n-fn main() {\n-    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer\n-                      //        forbid(non_snake_case)\n-}\n-```\n-\n-The `forbid` lint setting, like `deny`, turns the corresponding compiler\n-warning into a hard error. Unlike `deny`, `forbid` prevents itself from being\n-overridden by inner attributes.\n-\n-If you're sure you want to override the lint check, you can change `forbid` to\n-`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a\n-command-line option) to allow the inner lint check attribute:\n-\n-```\n-#![deny(non_snake_case)]\n-\n-#[allow(non_snake_case)]\n-fn main() {\n-    let MyNumber = 2; // ok!\n-}\n-```\n-\n-Otherwise, edit the code to pass the lint check, and remove the overruled\n-attribute:\n-\n-```\n-#![forbid(non_snake_case)]\n-\n-fn main() {\n-    let my_number = 2;\n-}\n-```\n-\"##,\n-\n-E0478: r##\"\n-A lifetime bound was not satisfied.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0478\n-// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must\n-// outlive all the superbounds from the trait (`'kiss`, in this example).\n-\n-trait Wedding<'t>: 't { }\n-\n-struct Prince<'kiss, 'SnowWhite> {\n-    child: Box<Wedding<'kiss> + 'SnowWhite>,\n-    // error: lifetime bound not satisfied\n-}\n-```\n-\n-In this example, the `'SnowWhite` lifetime is supposed to outlive the `'kiss`\n-lifetime but the declaration of the `Prince` struct doesn't enforce it. To fix\n-this issue, you need to specify it:\n-\n-```\n-trait Wedding<'t>: 't { }\n-\n-struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'kiss must live\n-                                          // longer than 'SnowWhite.\n-    child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!\n-}\n-```\n-\"##,\n-\n-E0491: r##\"\n-A reference has a longer lifetime than the data it references.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0491\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T {\n-    type Output = &'a T; // compile error E0491\n-}\n-```\n-\n-Here, the problem is that a reference type like `&'a T` is only valid\n-if all the data in T outlives the lifetime `'a`. But this impl as written\n-is applicable to any lifetime `'a` and any type `T` -- we have no guarantee\n-that `T` outlives `'a`. To fix this, you can add a where clause like\n-`where T: 'a`.\n-\n-```\n-trait SomeTrait<'a> {\n-    type Output;\n-}\n-\n-impl<'a, T> SomeTrait<'a> for T\n-where\n-    T: 'a,\n-{\n-    type Output = &'a T; // compile error E0491\n-}\n-```\n-\"##,\n-\n-E0495: r##\"\n-A lifetime cannot be determined in the given situation.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0495\n-fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n-    match (&t,) { // error!\n-        ((u,),) => u,\n-    }\n-}\n-\n-let y = Box::new((42,));\n-let x = transmute_lifetime(&y);\n-```\n-\n-In this code, you have two ways to solve this issue:\n- 1. Enforce that `'a` lives at least as long as `'b`.\n- 2. Use the same lifetime requirement for both input and output values.\n-\n-So for the first solution, you can do it by replacing `'a` with `'a: 'b`:\n-\n-```\n-fn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n-    match (&t,) { // ok!\n-        ((u,),) => u,\n-    }\n-}\n-```\n-\n-In the second you can do it by simply removing `'b` so they both use `'a`:\n-\n-```\n-fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n-    match (&t,) { // ok!\n-        ((u,),) => u,\n-    }\n-}\n-```\n-\"##,\n-\n-E0496: r##\"\n-A lifetime name is shadowing another lifetime name.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0496\n-struct Foo<'a> {\n-    a: &'a i32,\n-}\n-\n-impl<'a> Foo<'a> {\n-    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime\n-                           //        name that is already in scope\n-    }\n-}\n-```\n-\n-Please change the name of one of the lifetimes to remove this error. Example:\n-\n-```\n-struct Foo<'a> {\n-    a: &'a i32,\n-}\n-\n-impl<'a> Foo<'a> {\n-    fn f<'b>(x: &'b i32) { // ok!\n-    }\n-}\n-\n-fn main() {\n-}\n-```\n-\"##,\n-\n-E0497: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-A stability attribute was used outside of the standard library.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-#[stable] // error: stability attributes may not be used outside of the\n-          //        standard library\n-fn foo() {}\n-```\n-\n-It is not possible to use stability attributes outside of the standard library.\n-Also, for now, it is not possible to write deprecation messages either.\n-\"##,\n-\n-E0517: r##\"\n-This error indicates that a `#[repr(..)]` attribute was placed on an\n-unsupported item.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0517\n-#[repr(C)]\n-type Foo = u8;\n-\n-#[repr(packed)]\n-enum Foo {Bar, Baz}\n-\n-#[repr(u8)]\n-struct Foo {bar: bool, baz: bool}\n-\n-#[repr(C)]\n-impl Foo {\n-    // ...\n-}\n-```\n-\n-* The `#[repr(C)]` attribute can only be placed on structs and enums.\n-* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n-* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n-\n-These attributes do not work on typedefs, since typedefs are just aliases.\n-\n-Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n-discriminant size for enums with no data fields on any of the variants, e.g.\n-`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to\n-the size of the provided type. Such an enum can be cast to a value of the same\n-type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n-with a constrained set of allowed values.\n-\n-Only field-less enums can be cast to numerical primitives, so this attribute\n-will not apply to structs.\n-\n-`#[repr(packed)]` reduces padding to make the struct size smaller. The\n-representation of enums isn't strictly defined in Rust, and this attribute\n-won't work on enums.\n-\n-`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n-types (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\n-SIMD. This doesn't make much sense for enums since they don't consist of a\n-single list of data.\n-\"##,\n-\n-E0518: r##\"\n-This error indicates that an `#[inline(..)]` attribute was incorrectly placed\n-on something other than a function or method.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0518\n-#[inline(always)]\n-struct Foo;\n-\n-#[inline(never)]\n-impl Foo {\n-    // ...\n-}\n-```\n-\n-`#[inline]` hints the compiler whether or not to attempt to inline a method or\n-function. By default, the compiler does a pretty good job of figuring this out\n-itself, but if you feel the need for annotations, `#[inline(always)]` and\n-`#[inline(never)]` can override or force the compiler's decision.\n-\n-If you wish to apply this attribute to all methods in an impl, manually annotate\n-each method; it is not possible to annotate the entire impl with an `#[inline]`\n-attribute.\n-\"##,\n-\n-E0522: r##\"\n-The lang attribute is intended for marking special items that are built-in to\n-Rust itself. This includes special traits (like `Copy` and `Sized`) that affect\n-how the compiler behaves, as well as special functions that may be automatically\n-invoked (such as the handler for out-of-bounds accesses when indexing a slice).\n-Erroneous code example:\n-\n-```compile_fail,E0522\n-#![feature(lang_items)]\n-\n-#[lang = \"cookie\"]\n-fn cookie() -> ! { // error: definition of an unknown language item: `cookie`\n-    loop {}\n-}\n-```\n-\"##,\n-\n-E0525: r##\"\n-A closure was used but didn't implement the expected trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0525\n-struct X;\n-\n-fn foo<T>(_: T) {}\n-fn bar<T: Fn(u32)>(_: T) {}\n-\n-fn main() {\n-    let x = X;\n-    let closure = |_| foo(x); // error: expected a closure that implements\n-                              //        the `Fn` trait, but this closure only\n-                              //        implements `FnOnce`\n-    bar(closure);\n-}\n-```\n-\n-In the example above, `closure` is an `FnOnce` closure whereas the `bar`\n-function expected an `Fn` closure. In this case, it's simple to fix the issue,\n-you just have to implement `Copy` and `Clone` traits on `struct X` and it'll\n-be ok:\n-\n-```\n-#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\n-struct X;\n-\n-fn foo<T>(_: T) {}\n-fn bar<T: Fn(u32)>(_: T) {}\n-\n-fn main() {\n-    let x = X;\n-    let closure = |_| foo(x);\n-    bar(closure); // ok!\n-}\n-```\n-\n-To understand better how closures work in Rust, read:\n-https://doc.rust-lang.org/book/ch13-01-closures.html\n-\"##,\n-\n-E0566: r##\"\n-Conflicting representation hints have been used on a same item.\n-\n-Erroneous code example:\n-\n-```\n-#[repr(u32, u64)] // warning!\n-enum Repr { A }\n-```\n-\n-In most cases (if not all), using just one representation hint is more than\n-enough. If you want to have a representation hint depending on the current\n-architecture, use `cfg_attr`. Example:\n-\n-```\n-#[cfg_attr(linux, repr(u32))]\n-#[cfg_attr(not(linux), repr(u64))]\n-enum Repr { A }\n-```\n-\"##,\n-\n-E0580: r##\"\n-The `main` function was incorrectly declared.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0580\n-fn main(x: i32) { // error: main function has wrong type\n-    println!(\"{}\", x);\n-}\n-```\n-\n-The `main` function prototype should never take arguments.\n-Example:\n-\n-```\n-fn main() {\n-    // your code\n-}\n-```\n-\n-If you want to get command-line arguments, use `std::env::args`. To exit with a\n-specified exit code, use `std::process::exit`.\n-\"##,\n-\n-E0562: r##\"\n-Abstract return types (written `impl Trait` for some trait `Trait`) are only\n-allowed as function and inherent impl return types.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0562\n-fn main() {\n-    let count_to_ten: impl Iterator<Item=usize> = 0..10;\n-    // error: `impl Trait` not allowed outside of function and inherent method\n-    //        return types\n-    for i in count_to_ten {\n-        println!(\"{}\", i);\n-    }\n-}\n-```\n-\n-Make sure `impl Trait` only appears in return-type position.\n-\n-```\n-fn count_to_n(n: usize) -> impl Iterator<Item=usize> {\n-    0..n\n-}\n-\n-fn main() {\n-    for i in count_to_n(10) {  // ok!\n-        println!(\"{}\", i);\n-    }\n-}\n-```\n-\n-See [RFC 1522] for more details.\n-\n-[RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n-\"##,\n-\n-E0593: r##\"\n-You tried to supply an `Fn`-based type with an incorrect number of arguments\n-than what was expected.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0593\n-fn foo<F: Fn()>(x: F) { }\n-\n-fn main() {\n-    // [E0593] closure takes 1 argument but 0 arguments are required\n-    foo(|y| { });\n-}\n-```\n-\"##,\n-\n-E0602: r##\"\n-An unknown lint was used on the command line.\n-\n-Erroneous example:\n-\n-```sh\n-rustc -D bogus omse_file.rs\n-```\n-\n-Maybe you just misspelled the lint name or the lint doesn't exist anymore.\n-Either way, try to update/remove it in order to fix the error.\n-\"##,\n-\n-E0621: r##\"\n-This error code indicates a mismatch between the lifetimes appearing in the\n-function signature (i.e., the parameter types and the return type) and the\n-data-flow found in the function body.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0621\n-fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 { // error: explicit lifetime\n-                                             //        required in the type of\n-                                             //        `y`\n-    if x > y { x } else { y }\n-}\n-```\n-\n-In the code above, the function is returning data borrowed from either `x` or\n-`y`, but the `'a` annotation indicates that it is returning data only from `x`.\n-To fix the error, the signature and the body must be made to match. Typically,\n-this is done by updating the function signature. So, in this case, we change\n-the type of `y` to `&'a i32`, like so:\n-\n-```\n-fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n-    if x > y { x } else { y }\n-}\n-```\n-\n-Now the signature indicates that the function data borrowed from either `x` or\n-`y`. Alternatively, you could change the body to not return data from `y`:\n-\n-```\n-fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32 {\n-    x\n-}\n-```\n-\"##,\n-\n-E0623: r##\"\n-A lifetime didn't match what was expected.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0623\n-struct Foo<'a> {\n-    x: &'a isize,\n-}\n-\n-fn bar<'short, 'long>(c: Foo<'short>, l: &'long isize) {\n-    let _: Foo<'long> = c; // error!\n-}\n-```\n-\n-In this example, we tried to set a value with an incompatible lifetime to\n-another one (`'long` is unrelated to `'short`). We can solve this issue in\n-two different ways:\n-\n-Either we make `'short` live at least as long as `'long`:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a isize,\n-}\n-\n-// we set 'short to live at least as long as 'long\n-fn bar<'short: 'long, 'long>(c: Foo<'short>, l: &'long isize) {\n-    let _: Foo<'long> = c; // ok!\n-}\n-```\n-\n-Or we use only one lifetime:\n-\n-```\n-struct Foo<'a> {\n-    x: &'a isize,\n-}\n-\n-fn bar<'short>(c: Foo<'short>, l: &'short isize) {\n-    let _: Foo<'short> = c; // ok!\n-}\n-```\n-\"##,\n-\n-E0635: r##\"\n-The `#![feature]` attribute specified an unknown feature.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0635\n-#![feature(nonexistent_rust_feature)] // error: unknown feature\n-```\n-\n-\"##,\n-\n-E0636: r##\"\n-A `#![feature]` attribute was declared multiple times.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0636\n-#![allow(stable_features)]\n-#![feature(rust1)]\n-#![feature(rust1)] // error: the feature `rust1` has already been declared\n-```\n-\n-\"##,\n-\n-E0644: r##\"\n-A closure or generator was constructed that references its own type.\n-\n-Erroneous example:\n-\n-```compile-fail,E0644\n-fn fix<F>(f: &F)\n-  where F: Fn(&F)\n-{\n-  f(&f);\n-}\n-\n-fn main() {\n-  fix(&|y| {\n-    // Here, when `x` is called, the parameter `y` is equal to `x`.\n-  });\n-}\n-```\n-\n-Rust does not permit a closure to directly reference its own type,\n-either through an argument (as in the example above) or by capturing\n-itself through its environment. This restriction helps keep closure\n-inference tractable.\n-\n-The easiest fix is to rewrite your closure into a top-level function,\n-or into a method. In some cases, you may also be able to have your\n-closure call itself by capturing a `&Fn()` object or `fn()` pointer\n-that refers to itself. That is permitting, since the closure would be\n-invoking itself via a virtual call, and hence does not directly\n-reference its own *type*.\n-\n-\"##,\n-\n-E0692: r##\"\n-A `repr(transparent)` type was also annotated with other, incompatible\n-representation hints.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0692\n-#[repr(transparent, C)] // error: incompatible representation hints\n-struct Grams(f32);\n-```\n-\n-A type annotated as `repr(transparent)` delegates all representation concerns to\n-another type, so adding more representation hints is contradictory. Remove\n-either the `transparent` hint or the other hints, like this:\n-\n-```\n-#[repr(transparent)]\n-struct Grams(f32);\n-```\n-\n-Alternatively, move the other attributes to the contained type:\n-\n-```\n-#[repr(C)]\n-struct Foo {\n-    x: i32,\n-    // ...\n-}\n-\n-#[repr(transparent)]\n-struct FooWrapper(Foo);\n-```\n-\n-Note that introducing another `struct` just to have a place for the other\n-attributes may have unintended side effects on the representation:\n-\n-```\n-#[repr(transparent)]\n-struct Grams(f32);\n-\n-#[repr(C)]\n-struct Float(f32);\n-\n-#[repr(transparent)]\n-struct Grams2(Float); // this is not equivalent to `Grams` above\n-```\n-\n-Here, `Grams2` is a not equivalent to `Grams` -- the former transparently wraps\n-a (non-transparent) struct containing a single float, while `Grams` is a\n-transparent wrapper around a float. This can make a difference for the ABI.\n-\"##,\n-\n-E0697: r##\"\n-A closure has been used as `static`.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0697\n-fn main() {\n-    static || {}; // used as `static`\n-}\n-```\n-\n-Closures cannot be used as `static`. They \"save\" the environment,\n-and as such a static closure would save only a static environment\n-which would consist only of variables with a static lifetime. Given\n-this it would be better to use a proper function. The easiest fix\n-is to remove the `static` keyword.\n-\"##,\n-\n-E0698: r##\"\n-When using generators (or async) all type variables must be bound so a\n-generator can be constructed.\n-\n-Erroneous code example:\n-\n-```edition2018,compile-fail,E0698\n-async fn bar<T>() -> () {}\n-\n-async fn foo() {\n-    bar().await; // error: cannot infer type for `T`\n-}\n-```\n-\n-In the above example `T` is unknowable by the compiler.\n-To fix this you must bind `T` to a concrete type such as `String`\n-so that a generator can then be constructed:\n-\n-```edition2018\n-async fn bar<T>() -> () {}\n-\n-async fn foo() {\n-    bar::<String>().await;\n-    //   ^^^^^^^^ specify type explicitly\n-}\n-```\n-\"##,\n-\n-E0700: r##\"\n-The `impl Trait` return type captures lifetime parameters that do not\n-appear within the `impl Trait` itself.\n-\n-Erroneous code example:\n-\n-```compile-fail,E0700\n-use std::cell::Cell;\n-\n-trait Trait<'a> { }\n-\n-impl<'a, 'b> Trait<'b> for Cell<&'a u32> { }\n-\n-fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n-where 'x: 'y\n-{\n-    x\n-}\n-```\n-\n-Here, the function `foo` returns a value of type `Cell<&'x u32>`,\n-which references the lifetime `'x`. However, the return type is\n-declared as `impl Trait<'y>` -- this indicates that `foo` returns\n-\"some type that implements `Trait<'y>`\", but it also indicates that\n-the return type **only captures data referencing the lifetime `'y`**.\n-In this case, though, we are referencing data with lifetime `'x`, so\n-this function is in error.\n-\n-To fix this, you must reference the lifetime `'x` from the return\n-type. For example, changing the return type to `impl Trait<'y> + 'x`\n-would work:\n-\n-```\n-use std::cell::Cell;\n-\n-trait Trait<'a> { }\n-\n-impl<'a,'b> Trait<'b> for Cell<&'a u32> { }\n-\n-fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n-where 'x: 'y\n-{\n-    x\n-}\n-```\n-\"##,\n-\n-E0701: r##\"\n-This error indicates that a `#[non_exhaustive]` attribute was incorrectly placed\n-on something other than a struct or enum.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0701\n-#[non_exhaustive]\n-trait Foo { }\n-```\n-\"##,\n-\n-E0718: r##\"\n-This error indicates that a `#[lang = \"..\"]` attribute was placed\n-on the wrong type of item.\n-\n-Examples of erroneous code:\n-\n-```compile_fail,E0718\n-#![feature(lang_items)]\n-\n-#[lang = \"arc\"]\n-static X: u32 = 42;\n-```\n-\"##,\n-\n-E0728: r##\"\n-[`await`] has been used outside [`async`] function or block.\n-\n-Erroneous code examples:\n-\n-```edition2018,compile_fail,E0728\n-# use std::pin::Pin;\n-# use std::future::Future;\n-# use std::task::{Context, Poll};\n-#\n-# struct WakeOnceThenComplete(bool);\n-#\n-# fn wake_and_yield_once() -> WakeOnceThenComplete {\n-#     WakeOnceThenComplete(false)\n-# }\n-#\n-# impl Future for WakeOnceThenComplete {\n-#     type Output = ();\n-#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n-#         if self.0 {\n-#             Poll::Ready(())\n-#         } else {\n-#             cx.waker().wake_by_ref();\n-#             self.0 = true;\n-#             Poll::Pending\n-#         }\n-#     }\n-# }\n-#\n-fn foo() {\n-    wake_and_yield_once().await // `await` is used outside `async` context\n-}\n-```\n-\n-[`await`] is used to suspend the current computation until the given\n-future is ready to produce a value. So it is legal only within\n-an [`async`] context, like an `async fn` or an `async` block.\n-\n-```edition2018\n-# use std::pin::Pin;\n-# use std::future::Future;\n-# use std::task::{Context, Poll};\n-#\n-# struct WakeOnceThenComplete(bool);\n-#\n-# fn wake_and_yield_once() -> WakeOnceThenComplete {\n-#     WakeOnceThenComplete(false)\n-# }\n-#\n-# impl Future for WakeOnceThenComplete {\n-#     type Output = ();\n-#     fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n-#         if self.0 {\n-#             Poll::Ready(())\n-#         } else {\n-#             cx.waker().wake_by_ref();\n-#             self.0 = true;\n-#             Poll::Pending\n-#         }\n-#     }\n-# }\n-#\n-async fn foo() {\n-    wake_and_yield_once().await // `await` is used within `async` function\n-}\n-\n-fn bar(x: u8) -> impl Future<Output = u8> {\n-    async move {\n-        wake_and_yield_once().await; // `await` is used within `async` block\n-        x\n-    }\n-}\n-```\n-\n-[`async`]: https://doc.rust-lang.org/std/keyword.async.html\n-[`await`]: https://doc.rust-lang.org/std/keyword.await.html\n-\"##,\n-\n-E0734: r##\"\n-A stability attribute has been used outside of the standard library.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0734\n-#[rustc_deprecated(since = \"b\", reason = \"text\")] // invalid\n-#[stable(feature = \"a\", since = \"b\")] // invalid\n-#[unstable(feature = \"b\", issue = \"0\")] // invalid\n-fn foo(){}\n-```\n-\n-These attributes are meant to only be used by the standard library and are\n-rejected in your own crates.\n-\"##,\n-\n-E0736: r##\"\n-`#[track_caller]` and `#[naked]` cannot both be applied to the same function.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0736\n-#![feature(track_caller)]\n-\n-#[naked]\n-#[track_caller]\n-fn foo() {}\n-```\n-\n-This is primarily due to ABI incompatibilities between the two attributes.\n-See [RFC 2091] for details on this and other limitations.\n-\n-[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n-\"##,\n-\n-E0738: r##\"\n-`#[track_caller]` cannot be used in traits yet. This is due to limitations in\n-the compiler which are likely to be temporary. See [RFC 2091] for details on\n-this and other restrictions.\n-\n-Erroneous example with a trait method implementation:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-\n-trait Foo {\n-    fn bar(&self);\n-}\n-\n-impl Foo for u64 {\n-    #[track_caller]\n-    fn bar(&self) {}\n-}\n-```\n-\n-Erroneous example with a blanket trait method implementation:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-\n-trait Foo {\n-    #[track_caller]\n-    fn bar(&self) {}\n-    fn baz(&self);\n-}\n-```\n-\n-Erroneous example with a trait method declaration:\n-\n-```compile_fail,E0738\n-#![feature(track_caller)]\n-\n-trait Foo {\n-    fn bar(&self) {}\n-\n-    #[track_caller]\n-    fn baz(&self);\n-}\n-```\n-\n-Note that while the compiler may be able to support the attribute in traits in\n-the future, [RFC 2091] prohibits their implementation without a follow-up RFC.\n-\n-[RFC 2091]: https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md\n-\"##,\n-\n-;\n-//  E0006, // merged with E0005\n-//  E0101, // replaced with E0282\n-//  E0102, // replaced with E0282\n-//  E0134,\n-//  E0135,\n-//  E0272, // on_unimplemented #0\n-//  E0273, // on_unimplemented #1\n-//  E0274, // on_unimplemented #2\n-//  E0278, // requirement is not satisfied\n-    E0279, // requirement is not satisfied\n-    E0280, // requirement is not satisfied\n-//  E0285, // overflow evaluation builtin bounds\n-//  E0296, // replaced with a generic attribute input check\n-//  E0300, // unexpanded macro\n-//  E0304, // expected signed integer constant\n-//  E0305, // expected constant\n-    E0311, // thing may not live long enough\n-    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n-           // variable\n-    E0314, // closure outlives stack frame\n-    E0315, // cannot invoke closure outside of its lifetime\n-    E0316, // nested quantification of lifetimes\n-    E0320, // recursive overflow during dropck\n-    E0473, // dereference of reference outside its lifetime\n-    E0474, // captured variable `..` does not outlive the enclosing closure\n-    E0475, // index of slice outside its lifetime\n-    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n-    E0477, // the type `..` does not fulfill the required lifetime...\n-    E0479, // the type `..` (provided as the value of a type parameter) is...\n-    E0480, // lifetime of method receiver does not outlive the method call\n-    E0481, // lifetime of function argument does not outlive the function call\n-    E0482, // lifetime of return value does not outlive the function call\n-    E0483, // lifetime of operand does not outlive the operation\n-    E0484, // reference is not valid at the time of borrow\n-    E0485, // automatically reference is not valid at the time of borrow\n-    E0486, // type of expression contains references that are not valid during..\n-    E0487, // unsafe use of destructor: destructor might be called while...\n-    E0488, // lifetime of variable does not enclose its declaration\n-    E0489, // type/lifetime parameter not in scope here\n-    E0490, // a value of type `..` is borrowed for too long\n-    E0628, // generators cannot have explicit parameters\n-    E0631, // type mismatch in closure arguments\n-    E0637, // \"'_\" is not a valid lifetime bound\n-    E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n-    E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n-    E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n-    E0703, // invalid ABI\n-//  E0707, // multiple elided lifetimes used in arguments of `async fn`\n-    E0708, // `async` non-`move` closures with parameters are not currently\n-           // supported\n-//  E0709, // multiple different lifetimes used in arguments of `async fn`\n-    E0710, // an unknown tool name found in scoped lint\n-    E0711, // a feature has been declared with conflicting stability attributes\n-//  E0702, // replaced with a generic attribute input check\n-    E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n-    E0727, // `async` generators are not yet supported\n-    E0739, // invalid track_caller application/syntax\n-}"}, {"sha": "ea1c585176d57c837e9cb6c310fc1cb3338cf3de", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -16,6 +16,8 @@ use std::fmt::{self, Display};\n use syntax::{attr, symbol::sym};\n use syntax_pos::Span;\n \n+use rustc_error_codes::*;\n+\n #[derive(Copy, Clone, PartialEq)]\n pub(crate) enum MethodKind {\n     Trait { body: bool },"}, {"sha": "9c09ce9948672e318b961e012b8d55a9e7967b33", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -74,6 +74,8 @@ use syntax::visit::{self, Visitor};\n use syntax_pos::hygiene::ExpnId;\n use syntax_pos::Span;\n \n+use rustc_error_codes::*;\n+\n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n pub struct LoweringContext<'a> {"}, {"sha": "d5d3ff0db2ebc0e00939bdd53ddb52265a61a52f", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -11,6 +11,8 @@ use syntax::ast::*;\n use syntax::source_map::{respan, DesugaringKind, Span, Spanned};\n use syntax::symbol::{sym, Symbol};\n \n+use rustc_error_codes::*;\n+\n impl LoweringContext<'_> {\n     fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n         exprs.iter().map(|x| self.lower_expr(x)).collect()"}, {"sha": "137d21c35804f04f088ba2d0c12da55aab94a825", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -23,6 +23,8 @@ use syntax::source_map::{respan, DesugaringKind};\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n+use rustc_error_codes::*;\n+\n pub(super) struct ItemLowerer<'tcx, 'interner> {\n     pub(super) lctx: &'tcx mut LoweringContext<'interner>,\n }"}, {"sha": "d0f6a8a434d67a8c2c6e8627c5b3f2994915f24d", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -63,6 +63,8 @@ use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use std::{cmp, fmt};\n use syntax_pos::{Pos, Span};\n \n+use rustc_error_codes::*;\n+\n mod note;\n \n mod need_type_info;"}, {"sha": "32eecdf01a31fc7d908cd6036572cd1efb621ab4", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -9,6 +9,8 @@ use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n use errors::{Applicability, DiagnosticBuilder};\n \n+use rustc_error_codes::*;\n+\n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target_ty: Ty<'tcx>,"}, {"sha": "d7cba87e6b132cd942188a895b63c1702e2df64f", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -5,6 +5,8 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::util::common::ErrorReported;\n \n+use rustc_error_codes::*;\n+\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when both the concerned regions are anonymous.\n     ///"}, {"sha": "361318491916491badd83e30b36eaadc8112f4e2", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -5,6 +5,8 @@ use crate::hir::{FunctionRetTy, TyKind};\n use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n+use rustc_error_codes::*;\n+\n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error."}, {"sha": "c1f840ad678151ee53198ed16ec05de6c232ed2e", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -4,6 +4,8 @@ use crate::ty::{self, Region};\n use crate::ty::error::TypeError;\n use errors::DiagnosticBuilder;\n \n+use rustc_error_codes::*;\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin(&self,\n                                      err: &mut DiagnosticBuilder<'_>,"}, {"sha": "9ed60b1f0c1120bc3fa03f08caa21ad20fd198d9", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -15,6 +15,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::Span;\n \n+use rustc_error_codes::*;\n+\n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n \n /// Information about the opaque types whose values we"}, {"sha": "82994f9170fe028525123da29c22cabaa17c6d12", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -83,8 +83,6 @@ mod tests;\n #[macro_use]\n mod macros;\n \n-pub mod error_codes;\n-\n #[macro_use]\n pub mod query;\n "}, {"sha": "2f865f1f8b50148770eef8cd94c3ae7963a6c895", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -40,6 +40,8 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n \n+use rustc_error_codes::*;\n+\n /// Information about the registered lints.\n ///\n /// This is basically the subset of `Context` that we can"}, {"sha": "27bf9649324b4730f560049bd814ca2b43bd40b6", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -16,6 +16,8 @@ use syntax::print::pprust;\n use syntax::source_map::MultiSpan;\n use syntax::symbol::{Symbol, sym};\n \n+use rustc_error_codes::*;\n+\n pub struct LintLevelSets {\n     list: Vec<LintSet>,\n     lint_cap: Level,"}, {"sha": "f6cd9b1c7ec0bdac2b1a4321939c1c2f833285ad", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -23,6 +23,8 @@ use rustc_macros::HashStable;\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::hir;\n \n+use rustc_error_codes::*;\n+\n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n macro_rules! language_item_table {"}, {"sha": "e6f8521216b3cd02fc735fe7fcfdc9ca12976dfd", "filename": "src/librustc/middle/lib_features.rs", "status": "modified", "additions": 28, "deletions": 16, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flib_features.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -11,7 +11,8 @@ use syntax::ast::{Attribute, MetaItem, MetaItemKind};\n use syntax_pos::{Span, sym};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc_macros::HashStable;\n-use errors::DiagnosticId;\n+\n+use rustc_error_codes::*;\n \n #[derive(HashStable)]\n pub struct LibFeatures {\n@@ -98,15 +99,16 @@ impl LibFeatureCollector<'tcx> {\n             (Some(since), _, false) => {\n                 if let Some(prev_since) = self.lib_features.stable.get(&feature) {\n                     if *prev_since != since {\n-                        let msg = format!(\n-                            \"feature `{}` is declared stable since {}, \\\n-                             but was previously declared stable since {}\",\n-                            feature,\n-                            since,\n-                            prev_since,\n+                        self.span_feature_error(\n+                            span,\n+                            &format!(\n+                                \"feature `{}` is declared stable since {}, \\\n+                                 but was previously declared stable since {}\",\n+                                feature,\n+                                since,\n+                                prev_since,\n+                            ),\n                         );\n-                        self.tcx.sess.struct_span_err_with_code(span, &msg,\n-                            DiagnosticId::Error(\"E0711\".into())).emit();\n                         return;\n                     }\n                 }\n@@ -117,17 +119,27 @@ impl LibFeatureCollector<'tcx> {\n                 self.lib_features.unstable.insert(feature);\n             }\n             (Some(_), _, true) | (None, true, _) => {\n-                let msg = format!(\n-                    \"feature `{}` is declared {}, but was previously declared {}\",\n-                    feature,\n-                    if since.is_some() { \"stable\" } else { \"unstable\" },\n-                    if since.is_none() { \"stable\" } else { \"unstable\" },\n+                self.span_feature_error(\n+                    span,\n+                    &format!(\n+                        \"feature `{}` is declared {}, but was previously declared {}\",\n+                        feature,\n+                        if since.is_some() { \"stable\" } else { \"unstable\" },\n+                        if since.is_none() { \"stable\" } else { \"unstable\" },\n+                    ),\n                 );\n-                self.tcx.sess.struct_span_err_with_code(span, &msg,\n-                    DiagnosticId::Error(\"E0711\".into())).emit();\n             }\n         }\n     }\n+\n+    fn span_feature_error(&self, span: Span, msg: &str) {\n+        struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0711,\n+            \"{}\", &msg,\n+        ).emit();\n+    }\n }\n \n impl Visitor<'tcx> for LibFeatureCollector<'tcx> {"}, {"sha": "a70fe2be96cc12307de396e8563fd573b592599d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -30,6 +30,8 @@ use syntax_pos::Span;\n use crate::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use crate::hir::{self, GenericParamKind, LifetimeParamKind};\n \n+use rustc_error_codes::*;\n+\n /// The origin of a named lifetime definition.\n ///\n /// This is used to prevent the usage of in-band lifetimes in `Fn`/`fn` syntax."}, {"sha": "8f8b4ed98bd3b47b02166c2915310bdeadef5cbf", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -26,6 +26,9 @@ use std::cmp::Ordering;\n use std::mem::replace;\n use std::num::NonZeroU32;\n \n+use rustc_error_codes::*;\n+\n+\n #[derive(PartialEq, Clone, Copy, Debug)]\n pub enum StabilityLevel {\n     Unstable,"}, {"sha": "48c1226232f1376311400dd171718a64a1337720", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -14,6 +14,8 @@ use crate::hir::intravisit;\n use crate::hir;\n use crate::ty::TyCtxt;\n \n+use rustc_error_codes::*;\n+\n macro_rules! weak_lang_items {\n     ($($name:ident, $item:ident, $sym:ident;)*) => (\n "}, {"sha": "5f605756438c0945ebefe05a51bb08318c953970", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -16,6 +16,8 @@ use syntax::symbol::Symbol;\n \n use std::{fmt, env};\n \n+use rustc_error_codes::*;\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation."}, {"sha": "82631ce7435961f1ece9545c982a5c446bd69e65", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -39,6 +39,8 @@ use syntax::ast;\n use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind, MultiSpan};\n \n+use rustc_error_codes::*;\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(\n         &self,"}, {"sha": "59aa0810975e85e30d8ea42dc0f06b0757195f08", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -10,6 +10,8 @@ use syntax::attr;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n \n+use rustc_error_codes::*;\n+\n #[derive(Clone, Debug)]\n pub struct OnUnimplementedFormatString(Symbol);\n "}, {"sha": "9a9c8e9d0d396fba897c6fef329bec28558b9df7", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -6,6 +6,8 @@ use syntax::source_map::Span;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n \n+use rustc_error_codes::*;\n+\n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n     /// of \"kinds\" (types, regions) that must be outlive the execution"}, {"sha": "475037f54ba3813e70cb0d8d9905ab3b67ee4d0d", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -24,6 +24,8 @@ use crate::ty::subst::{Subst, InternalSubsts, SubstsRef};\n use super::{SelectionContext, FulfillmentContext};\n use super::util::impl_trait_ref_and_oblig;\n \n+use rustc_error_codes::*;\n+\n /// Information pertinent to an overlapping impl error.\n #[derive(Debug)]\n pub struct OverlapError {"}, {"sha": "214de35b6d0a9d0f41b1839b0b46aa7d97f828be", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -26,6 +26,8 @@ use std::collections::hash_map::Entry;\n use syntax_pos::Span;\n use syntax::source_map::DUMMY_SP;\n \n+use rustc_error_codes::*;\n+\n pub struct QueryCache<'tcx, D: QueryConfig<'tcx> + ?Sized> {\n     pub(super) results: FxHashMap<D::Key, QueryValue<D::Value>>,\n     pub(super) active: FxHashMap<D::Key, QueryResult<'tcx>>,"}, {"sha": "478c3a9084c09345e284282e7c4fcb26d3f09d85", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -31,3 +31,4 @@ rustc_fs_util = { path = \"../librustc_fs_util\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_error_codes = { path = \"../librustc_error_codes\" }"}, {"sha": "9bebca93964ea71555bb747327fbae4f47892af2", "filename": "src/librustc_codegen_ssa/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcommon.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -12,6 +12,8 @@ use crate::traits::*;\n use rustc::hir;\n use crate::traits::BuilderMethods;\n \n+use rustc_error_codes::*;\n+\n pub enum IntPredicate {\n     IntEQ,\n     IntNE,"}, {"sha": "02e26d8f6ecf0f9bebb552fc5dbb11b3717c7120", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d63b24ffcc48f44ef09e0369e6516d6f2dec3520/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d63b24ffcc48f44ef09e0369e6516d6f2dec3520/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=d63b24ffcc48f44ef09e0369e6516d6f2dec3520", "patch": "@@ -1,71 +0,0 @@\n-syntax::register_diagnostics! {\n-\n-E0511: r##\"\n-Invalid monomorphization of an intrinsic function was used. Erroneous code\n-example:\n-\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(platform_intrinsics)]\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-fn main() {\n-    unsafe { simd_add(0, 1); }\n-    // error: invalid monomorphization of `simd_add` intrinsic\n-}\n-```\n-\n-The generic type has to be a SIMD type. Example:\n-\n-```\n-#![feature(repr_simd)]\n-#![feature(platform_intrinsics)]\n-\n-#[repr(simd)]\n-#[derive(Copy, Clone)]\n-struct i32x2(i32, i32);\n-\n-extern \"platform-intrinsic\" {\n-    fn simd_add<T>(a: T, b: T) -> T;\n-}\n-\n-unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n-```\n-\"##,\n-\n-E0668: r##\"\n-Malformed inline assembly rejected by LLVM.\n-\n-LLVM checks the validity of the constraints and the assembly string passed to\n-it. This error implies that LLVM seems something wrong with the inline\n-assembly call.\n-\n-In particular, it can happen if you forgot the closing bracket of a register\n-constraint (see issue #51430):\n-```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n-#![feature(asm)]\n-\n-fn main() {\n-    let rax: u64;\n-    unsafe {\n-        asm!(\"\" :\"={rax\"(rax));\n-        println!(\"Accumulator is: {}\", rax);\n-    }\n-}\n-```\n-\"##,\n-\n-E0669: r##\"\n-Cannot convert inline assembly operand to a single LLVM value.\n-\n-This error usually happens when trying to pass in a value to an input inline\n-assembly operand that is actually a pair of values. In particular, this can\n-happen when trying to pass in a slice, for instance a `&str`. In Rust, these\n-values are represented internally as a pair of values, the pointer and its\n-length. When passed as an input operand, this pair of values can not be\n-coerced into a register and thus we must fail with an error.\n-\"##,\n-\n-}"}, {"sha": "9784d870b31ba44ae4aa69d6ea5faf0c9176b429", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -35,8 +35,6 @@ use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n use rustc::middle::dependency_format::Dependencies;\n use syntax_pos::symbol::Symbol;\n \n-mod error_codes;\n-\n pub mod common;\n pub mod traits;\n pub mod mir;"}, {"sha": "0b82edea157902dac27eddf078ecc4c2521128e0", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -6,6 +6,8 @@ use super::LocalRef;\n use super::OperandValue;\n use crate::traits::*;\n \n+use rustc_error_codes::*;\n+\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_statement(\n         &mut self,"}, {"sha": "d4f796ee3a7023672667165b72139e9d73a0ddc8", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -524,13 +524,13 @@ fn handle_explain(code: &str,\n             let mut text = String::new();\n \n             // Slice off the leading newline and print.\n-            for line in description[1..].lines() {\n+            for line in description.lines() {\n                 let indent_level = line.find(|c: char| !c.is_whitespace())\n                     .unwrap_or_else(|| line.len());\n                 let dedented_line = &line[indent_level..];\n                 if dedented_line.starts_with(\"```\") {\n                     is_in_code_block = !is_in_code_block;\n-                    text.push_str(&line[..(indent_level+3)]);\n+                    text.push_str(&line[..(indent_level + 3)]);\n                 } else if is_in_code_block && dedented_line.starts_with(\"# \") {\n                     continue;\n                 } else {"}, {"sha": "5def867ff11f430623c41544cc621805849a32d4", "filename": "src/librustc_error_codes/Cargo.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2FCargo.toml?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,9 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_error_codes\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_error_codes\"\n+path = \"lib.rs\""}, {"sha": "5e6d5ce159d0f071daa97111d9ae838351c1671a", "filename": "src/librustc_error_codes/error_codes.rs", "status": "added", "additions": 609, "deletions": 0, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,609 @@\n+// Error messages for EXXXX errors.  Each message should start and end with a\n+// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n+// use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n+\n+crate::register_diagnostics! {\n+\n+E0001: include_str!(\"./error_codes/E0001.md\"),\n+E0002: include_str!(\"./error_codes/E0002.md\"),\n+E0004: include_str!(\"./error_codes/E0004.md\"),\n+E0005: include_str!(\"./error_codes/E0005.md\"),\n+E0007: include_str!(\"./error_codes/E0007.md\"),\n+E0009: include_str!(\"./error_codes/E0009.md\"),\n+E0010: include_str!(\"./error_codes/E0010.md\"),\n+E0013: include_str!(\"./error_codes/E0013.md\"),\n+E0014: include_str!(\"./error_codes/E0014.md\"),\n+E0015: include_str!(\"./error_codes/E0015.md\"),\n+E0017: include_str!(\"./error_codes/E0017.md\"),\n+E0019: include_str!(\"./error_codes/E0019.md\"),\n+E0023: include_str!(\"./error_codes/E0023.md\"),\n+E0025: include_str!(\"./error_codes/E0025.md\"),\n+E0026: include_str!(\"./error_codes/E0026.md\"),\n+E0027: include_str!(\"./error_codes/E0027.md\"),\n+E0029: include_str!(\"./error_codes/E0029.md\"),\n+E0030: include_str!(\"./error_codes/E0030.md\"),\n+E0033: include_str!(\"./error_codes/E0033.md\"),\n+E0034: include_str!(\"./error_codes/E0034.md\"),\n+E0038: include_str!(\"./error_codes/E0038.md\"),\n+E0040: include_str!(\"./error_codes/E0040.md\"),\n+E0044: include_str!(\"./error_codes/E0044.md\"),\n+E0045: include_str!(\"./error_codes/E0045.md\"),\n+E0046: include_str!(\"./error_codes/E0046.md\"),\n+E0049: include_str!(\"./error_codes/E0049.md\"),\n+E0050: include_str!(\"./error_codes/E0050.md\"),\n+E0053: include_str!(\"./error_codes/E0053.md\"),\n+E0054: include_str!(\"./error_codes/E0054.md\"),\n+E0055: include_str!(\"./error_codes/E0055.md\"),\n+E0057: include_str!(\"./error_codes/E0057.md\"),\n+E0059: include_str!(\"./error_codes/E0059.md\"),\n+E0060: include_str!(\"./error_codes/E0060.md\"),\n+E0061: include_str!(\"./error_codes/E0061.md\"),\n+E0062: include_str!(\"./error_codes/E0062.md\"),\n+E0063: include_str!(\"./error_codes/E0063.md\"),\n+E0067: include_str!(\"./error_codes/E0067.md\"),\n+E0069: include_str!(\"./error_codes/E0069.md\"),\n+E0070: include_str!(\"./error_codes/E0070.md\"),\n+E0071: include_str!(\"./error_codes/E0071.md\"),\n+E0072: include_str!(\"./error_codes/E0072.md\"),\n+E0073: include_str!(\"./error_codes/E0073.md\"),\n+E0074: include_str!(\"./error_codes/E0074.md\"),\n+E0075: include_str!(\"./error_codes/E0075.md\"),\n+E0076: include_str!(\"./error_codes/E0076.md\"),\n+E0077: include_str!(\"./error_codes/E0077.md\"),\n+E0080: include_str!(\"./error_codes/E0080.md\"),\n+E0081: include_str!(\"./error_codes/E0081.md\"),\n+E0084: include_str!(\"./error_codes/E0084.md\"),\n+E0087: include_str!(\"./error_codes/E0087.md\"),\n+E0088: include_str!(\"./error_codes/E0088.md\"),\n+E0089: include_str!(\"./error_codes/E0089.md\"),\n+E0090: include_str!(\"./error_codes/E0090.md\"),\n+E0091: include_str!(\"./error_codes/E0091.md\"),\n+E0092: include_str!(\"./error_codes/E0092.md\"),\n+E0093: include_str!(\"./error_codes/E0093.md\"),\n+E0094: include_str!(\"./error_codes/E0094.md\"),\n+E0106: include_str!(\"./error_codes/E0106.md\"),\n+E0107: include_str!(\"./error_codes/E0107.md\"),\n+E0109: include_str!(\"./error_codes/E0109.md\"),\n+E0110: include_str!(\"./error_codes/E0110.md\"),\n+E0116: include_str!(\"./error_codes/E0116.md\"),\n+E0117: include_str!(\"./error_codes/E0117.md\"),\n+E0118: include_str!(\"./error_codes/E0118.md\"),\n+E0119: include_str!(\"./error_codes/E0119.md\"),\n+E0120: include_str!(\"./error_codes/E0120.md\"),\n+E0121: include_str!(\"./error_codes/E0121.md\"),\n+E0124: include_str!(\"./error_codes/E0124.md\"),\n+E0128: include_str!(\"./error_codes/E0128.md\"),\n+E0130: include_str!(\"./error_codes/E0130.md\"),\n+E0131: include_str!(\"./error_codes/E0131.md\"),\n+E0132: include_str!(\"./error_codes/E0132.md\"),\n+E0133: include_str!(\"./error_codes/E0133.md\"),\n+E0136: include_str!(\"./error_codes/E0136.md\"),\n+E0137: include_str!(\"./error_codes/E0137.md\"),\n+E0138: include_str!(\"./error_codes/E0138.md\"),\n+E0139: include_str!(\"./error_codes/E0139.md\"),\n+E0152: include_str!(\"./error_codes/E0152.md\"),\n+E0154: include_str!(\"./error_codes/E0154.md\"),\n+E0158: include_str!(\"./error_codes/E0158.md\"),\n+E0161: include_str!(\"./error_codes/E0161.md\"),\n+E0162: include_str!(\"./error_codes/E0162.md\"),\n+E0164: include_str!(\"./error_codes/E0164.md\"),\n+E0165: include_str!(\"./error_codes/E0165.md\"),\n+E0170: include_str!(\"./error_codes/E0170.md\"),\n+E0178: include_str!(\"./error_codes/E0178.md\"),\n+E0184: include_str!(\"./error_codes/E0184.md\"),\n+E0185: include_str!(\"./error_codes/E0185.md\"),\n+E0186: include_str!(\"./error_codes/E0186.md\"),\n+E0191: include_str!(\"./error_codes/E0191.md\"),\n+E0192: include_str!(\"./error_codes/E0192.md\"),\n+E0193: include_str!(\"./error_codes/E0193.md\"),\n+E0195: include_str!(\"./error_codes/E0195.md\"),\n+E0197: include_str!(\"./error_codes/E0197.md\"),\n+E0198: include_str!(\"./error_codes/E0198.md\"),\n+E0199: include_str!(\"./error_codes/E0199.md\"),\n+E0200: include_str!(\"./error_codes/E0200.md\"),\n+E0201: include_str!(\"./error_codes/E0201.md\"),\n+E0202: include_str!(\"./error_codes/E0202.md\"),\n+E0204: include_str!(\"./error_codes/E0204.md\"),\n+E0205: include_str!(\"./error_codes/E0205.md\"),\n+E0206: include_str!(\"./error_codes/E0206.md\"),\n+E0207: include_str!(\"./error_codes/E0207.md\"),\n+E0210: include_str!(\"./error_codes/E0210.md\"),\n+E0211: include_str!(\"./error_codes/E0211.md\"),\n+E0214: include_str!(\"./error_codes/E0214.md\"),\n+E0220: include_str!(\"./error_codes/E0220.md\"),\n+E0221: include_str!(\"./error_codes/E0221.md\"),\n+E0223: include_str!(\"./error_codes/E0223.md\"),\n+E0225: include_str!(\"./error_codes/E0225.md\"),\n+E0229: include_str!(\"./error_codes/E0229.md\"),\n+E0230: include_str!(\"./error_codes/E0230.md\"),\n+E0231: include_str!(\"./error_codes/E0231.md\"),\n+E0232: include_str!(\"./error_codes/E0232.md\"),\n+E0243: include_str!(\"./error_codes/E0243.md\"),\n+E0244: include_str!(\"./error_codes/E0244.md\"),\n+E0251: include_str!(\"./error_codes/E0251.md\"),\n+E0252: include_str!(\"./error_codes/E0252.md\"),\n+E0253: include_str!(\"./error_codes/E0253.md\"),\n+E0254: include_str!(\"./error_codes/E0254.md\"),\n+E0255: include_str!(\"./error_codes/E0255.md\"),\n+E0256: include_str!(\"./error_codes/E0256.md\"),\n+E0259: include_str!(\"./error_codes/E0259.md\"),\n+E0260: include_str!(\"./error_codes/E0260.md\"),\n+E0261: include_str!(\"./error_codes/E0261.md\"),\n+E0262: include_str!(\"./error_codes/E0262.md\"),\n+E0263: include_str!(\"./error_codes/E0263.md\"),\n+E0264: include_str!(\"./error_codes/E0264.md\"),\n+E0267: include_str!(\"./error_codes/E0267.md\"),\n+E0268: include_str!(\"./error_codes/E0268.md\"),\n+E0271: include_str!(\"./error_codes/E0271.md\"),\n+E0275: include_str!(\"./error_codes/E0275.md\"),\n+E0276: include_str!(\"./error_codes/E0276.md\"),\n+E0277: include_str!(\"./error_codes/E0277.md\"),\n+E0281: include_str!(\"./error_codes/E0281.md\"),\n+E0282: include_str!(\"./error_codes/E0282.md\"),\n+E0283: include_str!(\"./error_codes/E0283.md\"),\n+E0284: include_str!(\"./error_codes/E0284.md\"),\n+E0297: include_str!(\"./error_codes/E0297.md\"),\n+E0301: include_str!(\"./error_codes/E0301.md\"),\n+E0302: include_str!(\"./error_codes/E0302.md\"),\n+E0303: include_str!(\"./error_codes/E0303.md\"),\n+E0307: include_str!(\"./error_codes/E0307.md\"),\n+E0308: include_str!(\"./error_codes/E0308.md\"),\n+E0309: include_str!(\"./error_codes/E0309.md\"),\n+E0310: include_str!(\"./error_codes/E0310.md\"),\n+E0312: include_str!(\"./error_codes/E0312.md\"),\n+E0317: include_str!(\"./error_codes/E0317.md\"),\n+E0321: include_str!(\"./error_codes/E0321.md\"),\n+E0322: include_str!(\"./error_codes/E0322.md\"),\n+E0323: include_str!(\"./error_codes/E0323.md\"),\n+E0324: include_str!(\"./error_codes/E0324.md\"),\n+E0325: include_str!(\"./error_codes/E0325.md\"),\n+E0326: include_str!(\"./error_codes/E0326.md\"),\n+E0328: include_str!(\"./error_codes/E0328.md\"),\n+E0329: include_str!(\"./error_codes/E0329.md\"),\n+E0364: include_str!(\"./error_codes/E0364.md\"),\n+E0365: include_str!(\"./error_codes/E0365.md\"),\n+E0366: include_str!(\"./error_codes/E0366.md\"),\n+E0367: include_str!(\"./error_codes/E0367.md\"),\n+E0368: include_str!(\"./error_codes/E0368.md\"),\n+E0369: include_str!(\"./error_codes/E0369.md\"),\n+E0370: include_str!(\"./error_codes/E0370.md\"),\n+E0371: include_str!(\"./error_codes/E0371.md\"),\n+E0373: include_str!(\"./error_codes/E0373.md\"),\n+E0374: include_str!(\"./error_codes/E0374.md\"),\n+E0375: include_str!(\"./error_codes/E0375.md\"),\n+E0376: include_str!(\"./error_codes/E0376.md\"),\n+E0378: include_str!(\"./error_codes/E0378.md\"),\n+E0379: include_str!(\"./error_codes/E0379.md\"),\n+E0380: include_str!(\"./error_codes/E0380.md\"),\n+E0381: include_str!(\"./error_codes/E0381.md\"),\n+E0382: include_str!(\"./error_codes/E0382.md\"),\n+E0383: include_str!(\"./error_codes/E0383.md\"),\n+E0384: include_str!(\"./error_codes/E0384.md\"),\n+E0386: include_str!(\"./error_codes/E0386.md\"),\n+E0387: include_str!(\"./error_codes/E0387.md\"),\n+E0388: include_str!(\"./error_codes/E0388.md\"),\n+E0389: include_str!(\"./error_codes/E0389.md\"),\n+E0390: include_str!(\"./error_codes/E0390.md\"),\n+E0391: include_str!(\"./error_codes/E0391.md\"),\n+E0392: include_str!(\"./error_codes/E0392.md\"),\n+E0393: include_str!(\"./error_codes/E0393.md\"),\n+E0398: include_str!(\"./error_codes/E0398.md\"),\n+E0399: include_str!(\"./error_codes/E0399.md\"),\n+E0401: include_str!(\"./error_codes/E0401.md\"),\n+E0403: include_str!(\"./error_codes/E0403.md\"),\n+E0404: include_str!(\"./error_codes/E0404.md\"),\n+E0405: include_str!(\"./error_codes/E0405.md\"),\n+E0407: include_str!(\"./error_codes/E0407.md\"),\n+E0408: include_str!(\"./error_codes/E0408.md\"),\n+E0409: include_str!(\"./error_codes/E0409.md\"),\n+E0411: include_str!(\"./error_codes/E0411.md\"),\n+E0412: include_str!(\"./error_codes/E0412.md\"),\n+E0415: include_str!(\"./error_codes/E0415.md\"),\n+E0416: include_str!(\"./error_codes/E0416.md\"),\n+E0422: include_str!(\"./error_codes/E0422.md\"),\n+E0423: include_str!(\"./error_codes/E0423.md\"),\n+E0424: include_str!(\"./error_codes/E0424.md\"),\n+E0425: include_str!(\"./error_codes/E0425.md\"),\n+E0426: include_str!(\"./error_codes/E0426.md\"),\n+E0428: include_str!(\"./error_codes/E0428.md\"),\n+E0429: include_str!(\"./error_codes/E0429.md\"),\n+E0430: include_str!(\"./error_codes/E0430.md\"),\n+E0431: include_str!(\"./error_codes/E0431.md\"),\n+E0432: include_str!(\"./error_codes/E0432.md\"),\n+E0433: include_str!(\"./error_codes/E0433.md\"),\n+E0434: include_str!(\"./error_codes/E0434.md\"),\n+E0435: include_str!(\"./error_codes/E0435.md\"),\n+E0436: include_str!(\"./error_codes/E0436.md\"),\n+E0437: include_str!(\"./error_codes/E0437.md\"),\n+E0438: include_str!(\"./error_codes/E0438.md\"),\n+E0439: include_str!(\"./error_codes/E0439.md\"),\n+E0445: include_str!(\"./error_codes/E0445.md\"),\n+E0446: include_str!(\"./error_codes/E0446.md\"),\n+E0447: include_str!(\"./error_codes/E0447.md\"),\n+E0448: include_str!(\"./error_codes/E0448.md\"),\n+E0449: include_str!(\"./error_codes/E0449.md\"),\n+E0451: include_str!(\"./error_codes/E0451.md\"),\n+E0452: include_str!(\"./error_codes/E0452.md\"),\n+E0453: include_str!(\"./error_codes/E0453.md\"),\n+E0454: include_str!(\"./error_codes/E0454.md\"),\n+E0455: include_str!(\"./error_codes/E0455.md\"),\n+E0458: include_str!(\"./error_codes/E0458.md\"),\n+E0459: include_str!(\"./error_codes/E0459.md\"),\n+E0463: include_str!(\"./error_codes/E0463.md\"),\n+E0466: include_str!(\"./error_codes/E0466.md\"),\n+E0468: include_str!(\"./error_codes/E0468.md\"),\n+E0469: include_str!(\"./error_codes/E0469.md\"),\n+E0478: include_str!(\"./error_codes/E0478.md\"),\n+E0491: include_str!(\"./error_codes/E0491.md\"),\n+E0492: include_str!(\"./error_codes/E0492.md\"),\n+E0493: include_str!(\"./error_codes/E0493.md\"),\n+E0495: include_str!(\"./error_codes/E0495.md\"),\n+E0496: include_str!(\"./error_codes/E0496.md\"),\n+E0497: include_str!(\"./error_codes/E0497.md\"),\n+E0499: include_str!(\"./error_codes/E0499.md\"),\n+E0500: include_str!(\"./error_codes/E0500.md\"),\n+E0501: include_str!(\"./error_codes/E0501.md\"),\n+E0502: include_str!(\"./error_codes/E0502.md\"),\n+E0503: include_str!(\"./error_codes/E0503.md\"),\n+E0504: include_str!(\"./error_codes/E0504.md\"),\n+E0505: include_str!(\"./error_codes/E0505.md\"),\n+E0506: include_str!(\"./error_codes/E0506.md\"),\n+E0507: include_str!(\"./error_codes/E0507.md\"),\n+E0508: include_str!(\"./error_codes/E0508.md\"),\n+E0509: include_str!(\"./error_codes/E0509.md\"),\n+E0510: include_str!(\"./error_codes/E0510.md\"),\n+E0511: include_str!(\"./error_codes/E0511.md\"),\n+E0512: include_str!(\"./error_codes/E0512.md\"),\n+E0515: include_str!(\"./error_codes/E0515.md\"),\n+E0516: include_str!(\"./error_codes/E0516.md\"),\n+E0517: include_str!(\"./error_codes/E0517.md\"),\n+E0518: include_str!(\"./error_codes/E0518.md\"),\n+E0520: include_str!(\"./error_codes/E0520.md\"),\n+E0522: include_str!(\"./error_codes/E0522.md\"),\n+E0524: include_str!(\"./error_codes/E0524.md\"),\n+E0525: include_str!(\"./error_codes/E0525.md\"),\n+E0527: include_str!(\"./error_codes/E0527.md\"),\n+E0528: include_str!(\"./error_codes/E0528.md\"),\n+E0529: include_str!(\"./error_codes/E0529.md\"),\n+E0530: include_str!(\"./error_codes/E0530.md\"),\n+E0531: include_str!(\"./error_codes/E0531.md\"),\n+E0532: include_str!(\"./error_codes/E0532.md\"),\n+E0533: include_str!(\"./error_codes/E0533.md\"),\n+E0534: include_str!(\"./error_codes/E0534.md\"),\n+E0535: include_str!(\"./error_codes/E0535.md\"),\n+E0536: include_str!(\"./error_codes/E0536.md\"),\n+E0537: include_str!(\"./error_codes/E0537.md\"),\n+E0538: include_str!(\"./error_codes/E0538.md\"),\n+E0541: include_str!(\"./error_codes/E0541.md\"),\n+E0550: include_str!(\"./error_codes/E0550.md\"),\n+E0551: include_str!(\"./error_codes/E0551.md\"),\n+E0552: include_str!(\"./error_codes/E0552.md\"),\n+E0554: include_str!(\"./error_codes/E0554.md\"),\n+E0556: include_str!(\"./error_codes/E0556.md\"),\n+E0557: include_str!(\"./error_codes/E0557.md\"),\n+E0559: include_str!(\"./error_codes/E0559.md\"),\n+E0560: include_str!(\"./error_codes/E0560.md\"),\n+E0561: include_str!(\"./error_codes/E0561.md\"),\n+E0562: include_str!(\"./error_codes/E0562.md\"),\n+E0565: include_str!(\"./error_codes/E0565.md\"),\n+E0566: include_str!(\"./error_codes/E0566.md\"),\n+E0567: include_str!(\"./error_codes/E0567.md\"),\n+E0568: include_str!(\"./error_codes/E0568.md\"),\n+E0569: include_str!(\"./error_codes/E0569.md\"),\n+E0570: include_str!(\"./error_codes/E0570.md\"),\n+E0571: include_str!(\"./error_codes/E0571.md\"),\n+E0572: include_str!(\"./error_codes/E0572.md\"),\n+E0573: include_str!(\"./error_codes/E0573.md\"),\n+E0574: include_str!(\"./error_codes/E0574.md\"),\n+E0575: include_str!(\"./error_codes/E0575.md\"),\n+E0576: include_str!(\"./error_codes/E0576.md\"),\n+E0577: include_str!(\"./error_codes/E0577.md\"),\n+E0578: include_str!(\"./error_codes/E0578.md\"),\n+E0579: include_str!(\"./error_codes/E0579.md\"),\n+E0580: include_str!(\"./error_codes/E0580.md\"),\n+E0581: include_str!(\"./error_codes/E0581.md\"),\n+E0582: include_str!(\"./error_codes/E0582.md\"),\n+E0583: include_str!(\"./error_codes/E0583.md\"),\n+E0584: include_str!(\"./error_codes/E0584.md\"),\n+E0585: include_str!(\"./error_codes/E0585.md\"),\n+E0586: include_str!(\"./error_codes/E0586.md\"),\n+E0587: include_str!(\"./error_codes/E0587.md\"),\n+E0588: include_str!(\"./error_codes/E0588.md\"),\n+E0589: include_str!(\"./error_codes/E0589.md\"),\n+E0590: include_str!(\"./error_codes/E0590.md\"),\n+E0591: include_str!(\"./error_codes/E0591.md\"),\n+E0592: include_str!(\"./error_codes/E0592.md\"),\n+E0593: include_str!(\"./error_codes/E0593.md\"),\n+E0595: include_str!(\"./error_codes/E0595.md\"),\n+E0596: include_str!(\"./error_codes/E0596.md\"),\n+E0597: include_str!(\"./error_codes/E0597.md\"),\n+E0599: include_str!(\"./error_codes/E0599.md\"),\n+E0600: include_str!(\"./error_codes/E0600.md\"),\n+E0601: include_str!(\"./error_codes/E0601.md\"),\n+E0602: include_str!(\"./error_codes/E0602.md\"),\n+E0603: include_str!(\"./error_codes/E0603.md\"),\n+E0604: include_str!(\"./error_codes/E0604.md\"),\n+E0605: include_str!(\"./error_codes/E0605.md\"),\n+E0606: include_str!(\"./error_codes/E0606.md\"),\n+E0607: include_str!(\"./error_codes/E0607.md\"),\n+E0608: include_str!(\"./error_codes/E0608.md\"),\n+E0609: include_str!(\"./error_codes/E0609.md\"),\n+E0610: include_str!(\"./error_codes/E0610.md\"),\n+E0614: include_str!(\"./error_codes/E0614.md\"),\n+E0615: include_str!(\"./error_codes/E0615.md\"),\n+E0616: include_str!(\"./error_codes/E0616.md\"),\n+E0617: include_str!(\"./error_codes/E0617.md\"),\n+E0618: include_str!(\"./error_codes/E0618.md\"),\n+E0619: include_str!(\"./error_codes/E0619.md\"),\n+E0620: include_str!(\"./error_codes/E0620.md\"),\n+E0621: include_str!(\"./error_codes/E0621.md\"),\n+E0622: include_str!(\"./error_codes/E0622.md\"),\n+E0623: include_str!(\"./error_codes/E0623.md\"),\n+E0624: include_str!(\"./error_codes/E0624.md\"),\n+E0626: include_str!(\"./error_codes/E0626.md\"),\n+E0633: include_str!(\"./error_codes/E0633.md\"),\n+E0635: include_str!(\"./error_codes/E0635.md\"),\n+E0636: include_str!(\"./error_codes/E0636.md\"),\n+E0638: include_str!(\"./error_codes/E0638.md\"),\n+E0639: include_str!(\"./error_codes/E0639.md\"),\n+E0642: include_str!(\"./error_codes/E0642.md\"),\n+E0643: include_str!(\"./error_codes/E0643.md\"),\n+E0644: include_str!(\"./error_codes/E0644.md\"),\n+E0646: include_str!(\"./error_codes/E0646.md\"),\n+E0647: include_str!(\"./error_codes/E0647.md\"),\n+E0648: include_str!(\"./error_codes/E0648.md\"),\n+E0658: include_str!(\"./error_codes/E0658.md\"),\n+E0659: include_str!(\"./error_codes/E0659.md\"),\n+E0660: include_str!(\"./error_codes/E0660.md\"),\n+E0661: include_str!(\"./error_codes/E0661.md\"),\n+E0662: include_str!(\"./error_codes/E0662.md\"),\n+E0663: include_str!(\"./error_codes/E0663.md\"),\n+E0664: include_str!(\"./error_codes/E0664.md\"),\n+E0665: include_str!(\"./error_codes/E0665.md\"),\n+E0666: include_str!(\"./error_codes/E0666.md\"),\n+E0668: include_str!(\"./error_codes/E0668.md\"),\n+E0669: include_str!(\"./error_codes/E0669.md\"),\n+E0670: include_str!(\"./error_codes/E0670.md\"),\n+E0671: include_str!(\"./error_codes/E0671.md\"),\n+E0689: include_str!(\"./error_codes/E0689.md\"),\n+E0690: include_str!(\"./error_codes/E0690.md\"),\n+E0691: include_str!(\"./error_codes/E0691.md\"),\n+E0692: include_str!(\"./error_codes/E0692.md\"),\n+E0695: include_str!(\"./error_codes/E0695.md\"),\n+E0697: include_str!(\"./error_codes/E0697.md\"),\n+E0698: include_str!(\"./error_codes/E0698.md\"),\n+E0699: include_str!(\"./error_codes/E0699.md\"),\n+E0700: include_str!(\"./error_codes/E0700.md\"),\n+E0701: include_str!(\"./error_codes/E0701.md\"),\n+E0704: include_str!(\"./error_codes/E0704.md\"),\n+E0705: include_str!(\"./error_codes/E0705.md\"),\n+E0712: include_str!(\"./error_codes/E0712.md\"),\n+E0713: include_str!(\"./error_codes/E0713.md\"),\n+E0714: include_str!(\"./error_codes/E0714.md\"),\n+E0715: include_str!(\"./error_codes/E0715.md\"),\n+E0716: include_str!(\"./error_codes/E0716.md\"),\n+E0718: include_str!(\"./error_codes/E0718.md\"),\n+E0720: include_str!(\"./error_codes/E0720.md\"),\n+E0723: include_str!(\"./error_codes/E0723.md\"),\n+E0725: include_str!(\"./error_codes/E0725.md\"),\n+E0728: include_str!(\"./error_codes/E0728.md\"),\n+E0729: include_str!(\"./error_codes/E0729.md\"),\n+E0730: include_str!(\"./error_codes/E0730.md\"),\n+E0731: include_str!(\"./error_codes/E0731.md\"),\n+E0732: include_str!(\"./error_codes/E0732.md\"),\n+E0733: include_str!(\"./error_codes/E0733.md\"),\n+E0734: include_str!(\"./error_codes/E0734.md\"),\n+E0735: include_str!(\"./error_codes/E0735.md\"),\n+E0736: include_str!(\"./error_codes/E0736.md\"),\n+E0737: include_str!(\"./error_codes/E0737.md\"),\n+E0738: include_str!(\"./error_codes/E0738.md\"),\n+E0740: include_str!(\"./error_codes/E0740.md\"),\n+E0741: include_str!(\"./error_codes/E0741.md\"),\n+E0742: include_str!(\"./error_codes/E0742.md\"),\n+E0743: include_str!(\"./error_codes/E0743.md\"),\n+E0744: include_str!(\"./error_codes/E0744.md\"),\n+;\n+//  E0006, // merged with E0005\n+//  E0008, // cannot bind by-move into a pattern guard\n+//  E0035, merged into E0087/E0089\n+//  E0036, merged into E0087/E0089\n+//  E0068,\n+//  E0085,\n+//  E0086,\n+//  E0101, // replaced with E0282\n+//  E0102, // replaced with E0282\n+//  E0103,\n+//  E0104,\n+//  E0122, // bounds in type aliases are ignored, turned into proper lint\n+//  E0123,\n+//  E0127,\n+//  E0129,\n+//  E0134,\n+//  E0135,\n+//  E0141,\n+//  E0153, unused error code\n+//  E0157, unused error code\n+//  E0159, // use of trait `{}` as struct constructor\n+//  E0163, // merged into E0071\n+//  E0167,\n+//  E0168,\n+//  E0172, // non-trait found in a type sum, moved to resolve\n+//  E0173, // manual implementations of unboxed closure traits are experimental\n+//  E0174,\n+//  E0182, // merged into E0229\n+    E0183,\n+//  E0187, // cannot infer the kind of the closure\n+//  E0188, // can not cast an immutable reference to a mutable pointer\n+//  E0189, // deprecated: can only cast a boxed pointer to a boxed object\n+//  E0190, // deprecated: can only cast a &-pointer to an &-object\n+//  E0194, // merged into E0403\n+//  E0196, // cannot determine a type for this closure\n+    E0203, // type parameter has more than one relaxed default bound,\n+           // and only one is supported\n+    E0208,\n+//  E0209, // builtin traits can only be implemented on structs or enums\n+    E0212, // cannot extract an associated type from a higher-ranked trait bound\n+//  E0213, // associated types are not accepted in this context\n+//  E0215, // angle-bracket notation is not stable with `Fn`\n+//  E0216, // parenthetical notation is only stable with `Fn`\n+//  E0217, // ambiguous associated type, defined in multiple supertraits\n+//  E0218, // no associated type defined\n+//  E0219, // associated type defined in higher-ranked supertrait\n+//  E0222, // Error code E0045 (variadic function must have C or cdecl calling\n+           // convention) duplicate\n+    E0224, // at least one non-builtin train is required for an object type\n+    E0226, // only a single explicit lifetime bound is permitted\n+    E0227, // ambiguous lifetime bound, explicit lifetime bound required\n+    E0228, // explicit lifetime bound required\n+//  E0233,\n+//  E0234,\n+//  E0235, // structure constructor specifies a structure of type but\n+//  E0236, // no lang item for range syntax\n+//  E0237, // no lang item for range syntax\n+//  E0238, // parenthesized parameters may only be used with a trait\n+//  E0239, // `next` method of `Iterator` trait has unexpected type\n+//  E0240,\n+//  E0241,\n+//  E0242,\n+//  E0245, // not a trait\n+//  E0246, // invalid recursive type\n+//  E0247,\n+//  E0248, // value used as a type, now reported earlier during resolution\n+           // as E0412\n+//  E0249,\n+//  E0257,\n+//  E0258,\n+//  E0272, // on_unimplemented #0\n+//  E0273, // on_unimplemented #1\n+//  E0274, // on_unimplemented #2\n+//  E0278, // requirement is not satisfied\n+    E0279, // requirement is not satisfied\n+    E0280, // requirement is not satisfied\n+//  E0285, // overflow evaluation builtin bounds\n+//  E0296, // replaced with a generic attribute input check\n+//  E0298, // cannot compare constants\n+//  E0299, // mismatched types between arms\n+//  E0300, // unexpanded macro\n+//  E0304, // expected signed integer constant\n+//  E0305, // expected constant\n+    E0311, // thing may not live long enough\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n+           // variable\n+    E0314, // closure outlives stack frame\n+    E0315, // cannot invoke closure outside of its lifetime\n+    E0316, // nested quantification of lifetimes\n+//  E0319, // trait impls for defaulted traits allowed just for structs/enums\n+    E0320, // recursive overflow during dropck\n+//  E0372, // coherence not object safe\n+    E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with the same definition\n+//  E0385, // {} in an aliasable location\n+//  E0402, // cannot use an outer type parameter in this context\n+//  E0406, merged into 420\n+//  E0410, merged into 408\n+//  E0413, merged into 530\n+//  E0414, merged into 530\n+//  E0417, merged into 532\n+//  E0418, merged into 532\n+//  E0419, merged into 531\n+//  E0420, merged into 532\n+//  E0421, merged into 531\n+//  E0427, merged into 530\n+    E0456, // plugin `..` is not available for triple `..`\n+    E0457, // plugin `..` only found in rlib format, but must be available...\n+    E0460, // found possibly newer version of crate `..`\n+    E0461, // couldn't find crate `..` with expected target triple ..\n+    E0462, // found staticlib `..` instead of rlib or dylib\n+    E0464, // multiple matching crates for `..`\n+    E0465, // multiple .. candidates for `..` found\n+//  E0467, removed\n+//  E0470, removed\n+//  E0471, // constant evaluation error (in pattern)\n+    E0472, // asm! is unsupported on this target\n+    E0473, // dereference of reference outside its lifetime\n+    E0474, // captured variable `..` does not outlive the enclosing closure\n+    E0475, // index of slice outside its lifetime\n+    E0476, // lifetime of the source pointer does not outlive lifetime bound...\n+    E0477, // the type `..` does not fulfill the required lifetime...\n+    E0479, // the type `..` (provided as the value of a type parameter) is...\n+    E0480, // lifetime of method receiver does not outlive the method call\n+    E0481, // lifetime of function argument does not outlive the function call\n+    E0482, // lifetime of return value does not outlive the function call\n+    E0483, // lifetime of operand does not outlive the operation\n+    E0484, // reference is not valid at the time of borrow\n+    E0485, // automatically reference is not valid at the time of borrow\n+    E0486, // type of expression contains references that are not valid during..\n+    E0487, // unsafe use of destructor: destructor might be called while...\n+    E0488, // lifetime of variable does not enclose its declaration\n+    E0489, // type/lifetime parameter not in scope here\n+    E0490, // a value of type `..` is borrowed for too long\n+    E0498,  // malformed plugin attribute\n+    E0514, // metadata version mismatch\n+    E0519, // local crate and dependency have same (crate-name, disambiguator)\n+    // two dependencies have same (crate-name, disambiguator) but different SVH\n+    E0521, // borrowed data escapes outside of closure\n+    E0523,\n+//  E0526, // shuffle indices are not constant\n+    E0539, // incorrect meta item\n+    E0540, // multiple rustc_deprecated attributes\n+    E0542, // missing 'since'\n+    E0543, // missing 'reason'\n+    E0544, // multiple stability levels\n+    E0545, // incorrect 'issue'\n+    E0546, // missing 'feature'\n+    E0547, // missing 'issue'\n+//  E0548, // replaced with a generic attribute input check\n+    // rustc_deprecated attribute must be paired with either stable or unstable\n+    // attribute\n+    E0549,\n+    E0553, // multiple rustc_const_unstable attributes\n+//  E0555, // replaced with a generic attribute input check\n+//  E0558, // replaced with a generic attribute input check\n+//  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n+//  E0564, // only named lifetimes are allowed in `impl Trait`,\n+           // but `{}` was found in the type `{}`\n+    E0594, // cannot assign to {}\n+//  E0598, // lifetime of {} is too short to guarantee its contents can be...\n+//  E0611, // merged into E0616\n+//  E0612, // merged into E0609\n+//  E0613, // Removed (merged with E0609)\n+    E0625, // thread-local statics cannot be accessed at compile-time\n+    E0627, // yield statement outside of generator literal\n+    E0628, // generators cannot have explicit parameters\n+    E0629, // missing 'feature' (rustc_const_unstable)\n+    // rustc_const_unstable attribute must be paired with stable/unstable\n+    // attribute\n+    E0630,\n+    E0631, // type mismatch in closure arguments\n+    E0632, // cannot provide explicit generic arguments when `impl Trait` is\n+           // used in argument position\n+    E0634, // type has conflicting packed representaton hints\n+    E0637, // \"'_\" is not a valid lifetime bound\n+    E0640, // infer outlives requirements\n+    E0641, // cannot cast to/from a pointer with an unknown kind\n+//  E0645, // trait aliases not finished\n+    E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n+    E0667, // `impl Trait` in projections\n+    E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n+    E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n+    E0693, // incorrect `repr(align)` attribute format\n+//  E0694, // an unknown tool name found in scoped attributes\n+    E0696, // `continue` pointing to a labeled block\n+//  E0702, // replaced with a generic attribute input check\n+    E0703, // invalid ABI\n+    E0706, // `async fn` in trait\n+//  E0707, // multiple elided lifetimes used in arguments of `async fn`\n+    E0708, // `async` non-`move` closures with parameters are not currently\n+           // supported\n+//  E0709, // multiple different lifetimes used in arguments of `async fn`\n+    E0710, // an unknown tool name found in scoped lint\n+    E0711, // a feature has been declared with conflicting stability attributes\n+    E0717, // rustc_promotable without stability attribute\n+    E0719, // duplicate values for associated type binding\n+//  E0721, // `await` keyword\n+    E0722, // Malformed `#[optimize]` attribute\n+    E0724, // `#[ffi_returns_twice]` is only allowed in foreign functions\n+    E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n+    E0727, // `async` generators are not yet supported\n+    E0739, // invalid track_caller application/syntax\n+}"}, {"sha": "90756780d15024d6d2d6415929f84153f12c7fda", "filename": "src/librustc_error_codes/error_codes/E0001.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0001.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0001.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0001.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```\n+match Some(0) {\n+    Some(bar) => {/* ... */}\n+    x => {/* ... */} // This handles the `None` case\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms."}, {"sha": "5cb59da10e00bc0074f0d134c8fabb625c3b0c95", "filename": "src/librustc_error_codes/error_codes/E0002.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0002.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0002.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0002.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that an empty match expression is invalid because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired. This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+enum Empty {}\n+\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```compile_fail\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```"}, {"sha": "b79ef5fd8cb73685c80a74661f6c818114b50fe0", "filename": "src/librustc_error_codes/error_codes/E0004.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0004.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0004.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0004.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,46 @@\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0004\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n+\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```"}, {"sha": "e2e7db5082d168e2e6821dcb845fe57cd658f88d", "filename": "src/librustc_error_codes/error_codes/E0005.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0005.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0005.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0005.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,30 @@\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0005\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```"}, {"sha": "2be7870d5aeee8eff87cb77aff14dc42179779c1", "filename": "src/librustc_error_codes/error_codes/E0007.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0007.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0007.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0007.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,18 @@\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0007\n+let x = Some(\"s\".to_string());\n+\n+match x {\n+    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n+    None => {},\n+}\n+```\n+\n+See also the error E0303."}, {"sha": "abb7fe41ab7a29e1889ceb6f1d9ebf1935fcff5a", "filename": "src/librustc_error_codes/error_codes/E0009.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0009.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,48 @@\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0009\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n+                            //        same pattern\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+\n+Solution #1: Bind the pattern's values the same way.\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```"}, {"sha": "71c790e102f93df46a69bcd5fe8c295f9051a945", "filename": "src/librustc_error_codes/error_codes/E0010.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0010.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0010.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0010.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,11 @@\n+The value of statics and constants must be known at compile time, and they live\n+for the entire lifetime of a program. Creating a boxed value allocates memory on\n+the heap at runtime, and therefore cannot be done at compile time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0010\n+#![feature(box_syntax)]\n+\n+const CON : Box<i32> = box 0;\n+```"}, {"sha": "8de177590ece8c7a0fdb6fef686654d09e949fa4", "filename": "src/librustc_error_codes/error_codes/E0013.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0013.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0013.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0013.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,18 @@\n+Static and const variables can refer to other const variables. But a const\n+variable cannot refer to a static variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0013\n+static X: i32 = 42;\n+const Y: i32 = X;\n+```\n+\n+In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n+extracted as a const and then used:\n+\n+```\n+const A: i32 = 42;\n+static X: i32 = A;\n+const Y: i32 = A;\n+```"}, {"sha": "2c69957e9f6425be986c319523a4d5572f7075d3", "filename": "src/librustc_error_codes/error_codes/E0014.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0014.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0014.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0014.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Constants can only be initialized by a constant value or, in a future\n+version of Rust, a call to a const function. This error indicates the use\n+of a path (like a::b, or x) denoting something other than one of these\n+allowed items.\n+\n+Erroneous code example:\n+\n+```\n+const FOO: i32 = { let x = 0; x }; // 'x' isn't a constant nor a function!\n+```\n+\n+To avoid it, you have to replace the non-constant value:\n+\n+```\n+const FOO: i32 = { const X : i32 = 0; X };\n+// or even:\n+const FOO2: i32 = { 0 }; // but brackets are useless here\n+```"}, {"sha": "2bf59983fa93af05b6664b5f008515ce274c8b69", "filename": "src/librustc_error_codes/error_codes/E0015.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0015.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+The only functions that can be called in static or constant expressions are\n+`const` functions, and struct/enum constructors. `const` functions are only\n+available on a nightly compiler. Rust currently does not support more general\n+compile-time function execution.\n+\n+```\n+const FOO: Option<u8> = Some(1); // enum constructor\n+struct Bar {x: u8}\n+const BAR: Bar = Bar {x: 1}; // struct constructor\n+```\n+\n+See [RFC 911] for more details on the design of `const fn`s.\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md"}, {"sha": "d5e6857b4d6f893c2418f0962d15dcabef21fa83", "filename": "src/librustc_error_codes/error_codes/E0017.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0017.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+References in statics and constants may only refer to immutable values.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0017\n+static X: i32 = 1;\n+const C: i32 = 2;\n+\n+// these three are not allowed:\n+const CR: &mut i32 = &mut C;\n+static STATIC_REF: &'static mut i32 = &mut X;\n+static CONST_REF: &'static mut i32 = &mut C;\n+```\n+\n+Statics are shared everywhere, and if they refer to mutable data one might\n+violate memory safety since holding multiple mutable references to shared data\n+is not allowed.\n+\n+If you really want global mutable state, try using `static mut` or a global\n+`UnsafeCell`."}, {"sha": "7832468a539d315c71cab09ebc1e936258fe616b", "filename": "src/librustc_error_codes/error_codes/E0019.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0019.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0019.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0019.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,36 @@\n+A function call isn't allowed in the const's initialization expression\n+because the expression's value must be known at compile-time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0019\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    struct MyOwned;\n+\n+    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n+}\n+```\n+\n+Remember: you can't use a function call inside a const's initialization\n+expression! However, you can totally use it anywhere else:\n+\n+```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn func(&self) -> i32 {\n+        12\n+    }\n+}\n+\n+fn main() {\n+    const FOO: Test = Test::V1;\n+\n+    FOO.func(); // here is good\n+    let x = FOO.func(); // or even here!\n+}\n+```"}, {"sha": "92cae460c81db15a697b9c466509f1c3e53b5e6d", "filename": "src/librustc_error_codes/error_codes/E0023.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0023.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,47 @@\n+A pattern used to match against an enum variant must provide a sub-pattern for\n+each field of the enum variant. This error indicates that a pattern attempted to\n+extract an incorrect number of fields from a variant.\n+\n+```\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+```\n+\n+Here the `Apple` variant has two fields, and should be matched against like so:\n+\n+```\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n+// Correct.\n+match x {\n+    Fruit::Apple(a, b) => {},\n+    _ => {}\n+}\n+```\n+\n+Matching with the wrong number of fields has no sensible interpretation:\n+\n+```compile_fail,E0023\n+enum Fruit {\n+    Apple(String, String),\n+    Pear(u32),\n+}\n+\n+let x = Fruit::Apple(String::new(), String::new());\n+\n+// Incorrect.\n+match x {\n+    Fruit::Apple(a) => {},\n+    Fruit::Apple(a, b, c) => {},\n+}\n+```\n+\n+Check how many fields the enum was declared with and ensure that your pattern\n+uses the same number."}, {"sha": "51073babd01de112ecf4cee325dda7e8905b52e9", "filename": "src/librustc_error_codes/error_codes/E0025.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0025.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0025.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0025.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,33 @@\n+Each field of a struct can only be bound once in a pattern. Erroneous code\n+example:\n+\n+```compile_fail,E0025\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main(){\n+    let x = Foo { a:1, b:2 };\n+\n+    let Foo { a: x, a: y } = x;\n+    // error: field `a` bound multiple times in the pattern\n+}\n+```\n+\n+Each occurrence of a field name binds the value of that field, so to fix this\n+error you will have to remove or alter the duplicate uses of the field name.\n+Perhaps you misspelled another field name? Example:\n+\n+```\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main(){\n+    let x = Foo { a:1, b:2 };\n+\n+    let Foo { a: x, b: y } = x; // ok!\n+}\n+```"}, {"sha": "9327b31ac4b9b11c8f0bd0ae950128b347c45401", "filename": "src/librustc_error_codes/error_codes/E0026.md", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0026.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0026.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0026.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,51 @@\n+This error indicates that a struct pattern attempted to extract a non-existent\n+field from a struct. Struct fields are identified by the name used before the\n+colon `:` so struct patterns should resemble the declaration of the struct type\n+being matched.\n+\n+```\n+// Correct matching.\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 1, y: 2 };\n+\n+match thing {\n+    Thing { x: xfield, y: yfield } => {}\n+}\n+```\n+\n+If you are using shorthand field patterns but want to refer to the struct field\n+by a different name, you should rename it explicitly.\n+\n+Change this:\n+\n+```compile_fail,E0026\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 0, y: 0 };\n+\n+match thing {\n+    Thing { x, z } => {}\n+}\n+```\n+\n+To this:\n+\n+```\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 0, y: 0 };\n+\n+match thing {\n+    Thing { x, y: z } => {}\n+}\n+```"}, {"sha": "ab2a20fe9e56d00fb9472b30cbc542a604aeaa71", "filename": "src/librustc_error_codes/error_codes/E0027.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0027.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0027.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0027.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,39 @@\n+This error indicates that a pattern for a struct fails to specify a sub-pattern\n+for every one of the struct's fields. Ensure that each field from the struct's\n+definition is mentioned in the pattern, or use `..` to ignore unwanted fields.\n+\n+For example:\n+\n+```compile_fail,E0027\n+struct Dog {\n+    name: String,\n+    age: u32,\n+}\n+\n+let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n+\n+// This is incorrect.\n+match d {\n+    Dog { age: x } => {}\n+}\n+```\n+\n+This is correct (explicit):\n+\n+```\n+struct Dog {\n+    name: String,\n+    age: u32,\n+}\n+\n+let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n+\n+match d {\n+    Dog { name: ref n, age: x } => {}\n+}\n+\n+// This is also correct (ignore unused fields).\n+match d {\n+    Dog { age: x, .. } => {}\n+}\n+```"}, {"sha": "fadfda0a80c18052bac2ee2baf685ebad44ce662", "filename": "src/librustc_error_codes/error_codes/E0029.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0029.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0029.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0029.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+In a match expression, only numbers and characters can be matched against a\n+range. This is because the compiler checks that the range is non-empty at\n+compile-time, and is unable to evaluate arbitrary comparison functions. If you\n+want to capture values of an orderable type between two end-points, you can use\n+a guard.\n+\n+```compile_fail,E0029\n+let string = \"salutations !\";\n+\n+// The ordering relation for strings cannot be evaluated at compile time,\n+// so this doesn't work:\n+match string {\n+    \"hello\" ..= \"world\" => {}\n+    _ => {}\n+}\n+\n+// This is a more general version, using a guard:\n+match string {\n+    s if s >= \"hello\" && s <= \"world\" => {}\n+    _ => {}\n+}\n+```"}, {"sha": "67d496da5e4eb771f8a2d17eba905ca20492a5db", "filename": "src/librustc_error_codes/error_codes/E0030.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0030.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0030.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0030.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,15 @@\n+When matching against a range, the compiler verifies that the range is\n+non-empty. Range patterns include both end-points, so this is equivalent to\n+requiring the start of the range to be less than or equal to the end of the\n+range.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0030\n+match 5u32 {\n+    // This range is ok, albeit pointless.\n+    1 ..= 1 => {}\n+    // This range is empty, and the compiler can tell.\n+    1000 ..= 5 => {}\n+}\n+```"}, {"sha": "0bb70e89f3dc81a5418f4c2a7cb79763ccaec5a1", "filename": "src/librustc_error_codes/error_codes/E0033.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0033.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,23 @@\n+This error indicates that a pointer to a trait type cannot be implicitly\n+dereferenced by a pattern. Every trait defines a type, but because the\n+size of trait implementers isn't fixed, this type has no compile-time size.\n+Therefore, all accesses to trait types must be through pointers. If you\n+encounter this error you should try to avoid dereferencing the pointer.\n+\n+```compile_fail,E0033\n+# trait SomeTrait { fn method_one(&self){} fn method_two(&self){} }\n+# impl<T> SomeTrait for T {}\n+let trait_obj: &SomeTrait = &\"some_value\";\n+\n+// This tries to implicitly dereference to create an unsized local variable.\n+let &invalid = trait_obj;\n+\n+// You can call methods without binding to the value being pointed at.\n+trait_obj.method_one();\n+trait_obj.method_two();\n+```\n+\n+You can read more about trait objects in the [Trait Objects] section of the\n+Reference.\n+\n+[Trait Objects]: https://doc.rust-lang.org/reference/types.html#trait-objects"}, {"sha": "bc804b7faefca52912316adf650169f012d08d2f", "filename": "src/librustc_error_codes/error_codes/E0034.md", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0034.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0034.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0034.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,84 @@\n+The compiler doesn't know what method to call because more than one method\n+has the same prototype. Erroneous code example:\n+\n+```compile_fail,E0034\n+struct Test;\n+\n+trait Trait1 {\n+    fn foo();\n+}\n+\n+trait Trait2 {\n+    fn foo();\n+}\n+\n+impl Trait1 for Test { fn foo() {} }\n+impl Trait2 for Test { fn foo() {} }\n+\n+fn main() {\n+    Test::foo() // error, which foo() to call?\n+}\n+```\n+\n+To avoid this error, you have to keep only one of them and remove the others.\n+So let's take our example and fix it:\n+\n+```\n+struct Test;\n+\n+trait Trait1 {\n+    fn foo();\n+}\n+\n+impl Trait1 for Test { fn foo() {} }\n+\n+fn main() {\n+    Test::foo() // and now that's good!\n+}\n+```\n+\n+However, a better solution would be using fully explicit naming of type and\n+trait:\n+\n+```\n+struct Test;\n+\n+trait Trait1 {\n+    fn foo();\n+}\n+\n+trait Trait2 {\n+    fn foo();\n+}\n+\n+impl Trait1 for Test { fn foo() {} }\n+impl Trait2 for Test { fn foo() {} }\n+\n+fn main() {\n+    <Test as Trait1>::foo()\n+}\n+```\n+\n+One last example:\n+\n+```\n+trait F {\n+    fn m(&self);\n+}\n+\n+trait G {\n+    fn m(&self);\n+}\n+\n+struct X;\n+\n+impl F for X { fn m(&self) { println!(\"I am F\"); } }\n+impl G for X { fn m(&self) { println!(\"I am G\"); } }\n+\n+fn main() {\n+    let f = X;\n+\n+    F::m(&f); // it displays \"I am F\"\n+    G::m(&f); // it displays \"I am G\"\n+}\n+```"}, {"sha": "21b5eb47480e62d85feec6a252ee5995a72038a3", "filename": "src/librustc_error_codes/error_codes/E0038.md", "status": "added", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0038.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,291 @@\n+Trait objects like `Box<Trait>` can only be constructed when certain\n+requirements are satisfied by the trait in question.\n+\n+Trait objects are a form of dynamic dispatch and use a dynamically sized type\n+for the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\n+type, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\n+pointer is a 'fat pointer' that contains an extra pointer to a table of methods\n+(among other things) for dynamic dispatch. This design mandates some\n+restrictions on the types of traits that are allowed to be used in trait\n+objects, which are collectively termed as 'object safety' rules.\n+\n+Attempting to create a trait object for a non object-safe trait will trigger\n+this error.\n+\n+There are various rules:\n+\n+### The trait cannot require `Self: Sized`\n+\n+When `Trait` is treated as a type, the type does not implement the special\n+`Sized` trait, because the type does not have a known size at compile time and\n+can only be accessed behind a pointer. Thus, if we have a trait like the\n+following:\n+\n+```\n+trait Foo where Self: Sized {\n+\n+}\n+```\n+\n+We cannot create an object of type `Box<Foo>` or `&Foo` since in this case\n+`Self` would not be `Sized`.\n+\n+Generally, `Self: Sized` is used to indicate that the trait should not be used\n+as a trait object. If the trait comes from your own crate, consider removing\n+this restriction.\n+\n+### Method references the `Self` type in its parameters or return type\n+\n+This happens when a trait has a method like the following:\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n+impl Trait for String {\n+    fn foo(&self) -> Self {\n+        \"hi\".to_owned()\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) -> Self {\n+        1\n+    }\n+}\n+```\n+\n+(Note that `&self` and `&mut self` are okay, it's additional `Self` types which\n+cause this problem.)\n+\n+In such a case, the compiler cannot predict the return type of `foo()` in a\n+situation like the following:\n+\n+```compile_fail\n+trait Trait {\n+    fn foo(&self) -> Self;\n+}\n+\n+fn call_foo(x: Box<Trait>) {\n+    let y = x.foo(); // What type is y?\n+    // ...\n+}\n+```\n+\n+If only some methods aren't object-safe, you can add a `where Self: Sized` bound\n+on them to mark them as explicitly unavailable to trait objects. The\n+functionality will still be available to all other implementers, including\n+`Box<Trait>` which is itself sized (assuming you `impl Trait for Box<Trait>`).\n+\n+```\n+trait Trait {\n+    fn foo(&self) -> Self where Self: Sized;\n+    // more functions\n+}\n+```\n+\n+Now, `foo()` can no longer be called on a trait object, but you will now be\n+allowed to make a trait object, and that will be able to call any object-safe\n+methods. With such a bound, one can still call `foo()` on types implementing\n+that trait that aren't behind trait objects.\n+\n+### Method has generic type parameters\n+\n+As mentioned before, trait objects contain pointers to method tables. So, if we\n+have:\n+\n+```\n+trait Trait {\n+    fn foo(&self);\n+}\n+\n+impl Trait for String {\n+    fn foo(&self) {\n+        // implementation 1\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo(&self) {\n+        // implementation 2\n+    }\n+}\n+// ...\n+```\n+\n+At compile time each implementation of `Trait` will produce a table containing\n+the various methods (and other items) related to the implementation.\n+\n+This works fine, but when the method gains generic parameters, we can have a\n+problem.\n+\n+Usually, generic parameters get _monomorphized_. For example, if I have\n+\n+```\n+fn foo<T>(x: T) {\n+    // ...\n+}\n+```\n+\n+The machine code for `foo::<u8>()`, `foo::<bool>()`, `foo::<String>()`, or any\n+other type substitution is different. Hence the compiler generates the\n+implementation on-demand. If you call `foo()` with a `bool` parameter, the\n+compiler will only generate code for `foo::<bool>()`. When we have additional\n+type parameters, the number of monomorphized implementations the compiler\n+generates does not grow drastically, since the compiler will only generate an\n+implementation if the function is called with unparametrized substitutions\n+(i.e., substitutions where none of the substituted types are themselves\n+parametrized).\n+\n+However, with trait objects we have to make a table containing _every_ object\n+that implements the trait. Now, if it has type parameters, we need to add\n+implementations for every type that implements the trait, and there could\n+theoretically be an infinite number of types.\n+\n+For example, with:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T);\n+    // more methods\n+}\n+\n+impl Trait for String {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 1\n+    }\n+}\n+\n+impl Trait for u8 {\n+    fn foo<T>(&self, on: T) {\n+        // implementation 2\n+    }\n+}\n+\n+// 8 more implementations\n+```\n+\n+Now, if we have the following code:\n+\n+```compile_fail,E0038\n+# trait Trait { fn foo<T>(&self, on: T); }\n+# impl Trait for String { fn foo<T>(&self, on: T) {} }\n+# impl Trait for u8 { fn foo<T>(&self, on: T) {} }\n+# impl Trait for bool { fn foo<T>(&self, on: T) {} }\n+# // etc.\n+fn call_foo(thing: Box<Trait>) {\n+    thing.foo(true); // this could be any one of the 8 types above\n+    thing.foo(1);\n+    thing.foo(\"hello\");\n+}\n+```\n+\n+We don't just need to create a table of all implementations of all methods of\n+`Trait`, we need to create such a table, for each different type fed to\n+`foo()`. In this case this turns out to be (10 types implementing `Trait`)*(3\n+types being fed to `foo()`) = 30 implementations!\n+\n+With real world traits these numbers can grow drastically.\n+\n+To fix this, it is suggested to use a `where Self: Sized` bound similar to the\n+fix for the sub-error above if you do not intend to call the method with type\n+parameters:\n+\n+```\n+trait Trait {\n+    fn foo<T>(&self, on: T) where Self: Sized;\n+    // more methods\n+}\n+```\n+\n+If this is not an option, consider replacing the type parameter with another\n+trait object (e.g., if `T: OtherTrait`, use `on: Box<OtherTrait>`). If the\n+number of types you intend to feed to this method is limited, consider manually\n+listing out the methods of different types.\n+\n+### Method has no receiver\n+\n+Methods that do not take a `self` parameter can't be called since there won't be\n+a way to get a pointer to the method table for them.\n+\n+```\n+trait Foo {\n+    fn foo() -> u8;\n+}\n+```\n+\n+This could be called as `<Foo as Foo>::foo()`, which would not be able to pick\n+an implementation.\n+\n+Adding a `Self: Sized` bound to these methods will generally make this compile.\n+\n+```\n+trait Foo {\n+    fn foo() -> u8 where Self: Sized;\n+}\n+```\n+\n+### The trait cannot contain associated constants\n+\n+Just like static functions, associated constants aren't stored on the method\n+table. If the trait or any subtrait contain an associated constant, they cannot\n+be made into an object.\n+\n+```compile_fail,E0038\n+trait Foo {\n+    const X: i32;\n+}\n+\n+impl Foo {}\n+```\n+\n+A simple workaround is to use a helper method instead:\n+\n+```\n+trait Foo {\n+    fn x(&self) -> i32;\n+}\n+```\n+\n+### The trait cannot use `Self` as a type parameter in the supertrait listing\n+\n+This is similar to the second sub-error, but subtler. It happens in situations\n+like the following:\n+\n+```compile_fail,E0038\n+trait Super<A: ?Sized> {}\n+\n+trait Trait: Super<Self> {\n+}\n+\n+struct Foo;\n+\n+impl Super<Foo> for Foo{}\n+\n+impl Trait for Foo {}\n+\n+fn main() {\n+    let x: Box<dyn Trait>;\n+}\n+```\n+\n+Here, the supertrait might have methods as follows:\n+\n+```\n+trait Super<A: ?Sized> {\n+    fn get_a(&self) -> &A; // note that this is object safe!\n+}\n+```\n+\n+If the trait `Trait` was deriving from something like `Super<String>` or\n+`Super<T>` (where `Foo` itself is `Foo<T>`), this is okay, because given a type\n+`get_a()` will definitely return an object of that type.\n+\n+However, if it derives from `Super<Self>`, even though `Super` is object safe,\n+the method `get_a()` would return an object of unknown type when called on the\n+function. `Self` type parameters let us make object safe traits no longer safe,\n+so they are forbidden when specifying supertraits.\n+\n+There's no easy fix for this, generally code will need to be refactored so that\n+you no longer need to derive from `Super<Self>`."}, {"sha": "fb262018c35b1e03b1614542cd587747456db7e3", "filename": "src/librustc_error_codes/error_codes/E0040.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0040.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0040.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0040.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+It is not allowed to manually call destructors in Rust. It is also not\n+necessary to do this since `drop` is called automatically whenever a value goes\n+out of scope.\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0040\n+struct Foo {\n+    x: i32,\n+}\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        println!(\"kaboom\");\n+    }\n+}\n+\n+fn main() {\n+    let mut x = Foo { x: -7 };\n+    x.drop(); // error: explicit use of destructor method\n+}\n+```"}, {"sha": "8e877e718599757990c1ee22da3f2c892cdadbca", "filename": "src/librustc_error_codes/error_codes/E0044.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0044.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0044.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0044.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+You cannot use type or const parameters on foreign items.\n+Example of erroneous code:\n+\n+```compile_fail,E0044\n+extern { fn some_func<T>(x: T); }\n+```\n+\n+To fix this, replace the generic parameter with the specializations that you\n+need:\n+\n+```\n+extern { fn some_func_i32(x: i32); }\n+extern { fn some_func_i64(x: i64); }\n+```"}, {"sha": "537490eb4cf5b155e72076a47b6e5c2bb9ca1969", "filename": "src/librustc_error_codes/error_codes/E0045.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0045.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0045.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0045.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+Rust only supports variadic parameters for interoperability with C code in its\n+FFI. As such, variadic parameters can only be used with functions which are\n+using the C ABI. Examples of erroneous code:\n+\n+```compile_fail\n+#![feature(unboxed_closures)]\n+\n+extern \"rust-call\" { fn foo(x: u8, ...); }\n+\n+// or\n+\n+fn foo(x: u8, ...) {}\n+```\n+\n+To fix such code, put them in an extern \"C\" block:\n+\n+```\n+extern \"C\" {\n+    fn foo (x: u8, ...);\n+}\n+```"}, {"sha": "2d0bb0863e8831d6a642cb7b15861df34bea702f", "filename": "src/librustc_error_codes/error_codes/E0046.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0046.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0046.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0046.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+Items are missing in a trait implementation. Erroneous code example:\n+\n+```compile_fail,E0046\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {}\n+// error: not all trait items implemented, missing: `foo`\n+```\n+\n+When trying to make some type implement a trait `Foo`, you must, at minimum,\n+provide implementations for all of `Foo`'s required methods (meaning the\n+methods that do not have default implementations), as well as any required\n+trait items like associated types or constants. Example:\n+\n+```\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo() {} // ok!\n+}\n+```"}, {"sha": "721a7fd57a51f9d959e4e63711fe87329162267d", "filename": "src/librustc_error_codes/error_codes/E0049.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0049.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0049.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0049.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of type or const parameters.\n+\n+For example, the trait below has a method `foo` with a type parameter `T`,\n+but the implementation of `foo` for the type `Bar` is missing this parameter:\n+\n+```compile_fail,E0049\n+trait Foo {\n+    fn foo<T: Default>(x: T) -> Self;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 0 type parameters but its trait declaration has 1\n+// type parameter\n+impl Foo for Bar {\n+    fn foo(x: bool) -> Self { Bar }\n+}\n+```"}, {"sha": "79d070802d3040f0e1fe6a838c04f8647e901553", "filename": "src/librustc_error_codes/error_codes/E0050.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0050.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0050.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0050.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of function parameters.\n+\n+For example, the trait below has a method `foo` with two function parameters\n+(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\n+the `u8` parameter:\n+\n+```compile_fail,E0050\n+trait Foo {\n+    fn foo(&self, x: u8) -> bool;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n+// has 2\n+impl Foo for Bar {\n+    fn foo(&self) -> bool { true }\n+}\n+```"}, {"sha": "822d1f0094d3603b26fb63d33b3a39af25709a25", "filename": "src/librustc_error_codes/error_codes/E0053.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0053.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0053.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0053.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+The parameters of any trait method must match between a trait implementation\n+and the trait definition.\n+\n+Here are a couple examples of this error:\n+\n+```compile_fail,E0053\n+trait Foo {\n+    fn foo(x: u16);\n+    fn bar(&self);\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, expected u16, found i16\n+    fn foo(x: i16) { }\n+\n+    // error, types differ in mutability\n+    fn bar(&mut self) { }\n+}\n+```"}, {"sha": "af71cb44462a69dc7ae7b2b40afce598922a02ba", "filename": "src/librustc_error_codes/error_codes/E0054.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0054.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0054.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0054.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+It is not allowed to cast to a bool. If you are trying to cast a numeric type\n+to a bool, you can compare it with zero instead:\n+\n+```compile_fail,E0054\n+let x = 5;\n+\n+// Not allowed, won't compile\n+let x_is_nonzero = x as bool;\n+```\n+\n+```\n+let x = 5;\n+\n+// Ok\n+let x_is_nonzero = x != 0;\n+```"}, {"sha": "d5b863081a61688d3b11a2ea7c68bb4b26dfa5da", "filename": "src/librustc_error_codes/error_codes/E0055.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0055.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+During a method call, a value is automatically dereferenced as many times as\n+needed to make the value's type match the method's receiver. The catch is that\n+the compiler will only attempt to dereference a number of times up to the\n+recursion limit (which can be set via the `recursion_limit` attribute).\n+\n+For a somewhat artificial example:\n+\n+```compile_fail,E0055\n+#![recursion_limit=\"5\"]\n+\n+struct Foo;\n+\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+fn main() {\n+    let foo = Foo;\n+    let ref_foo = &&&&&Foo;\n+\n+    // error, reached the recursion limit while auto-dereferencing `&&&&&Foo`\n+    ref_foo.foo();\n+}\n+```\n+\n+One fix may be to increase the recursion limit. Note that it is possible to\n+create an infinite recursion of dereferencing, in which case the only fix is to\n+somehow break the recursion."}, {"sha": "e11c07f835ad765fcefbea278127afcd1fa4c892", "filename": "src/librustc_error_codes/error_codes/E0057.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0057.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+When invoking closures or other implementations of the function traits `Fn`,\n+`FnMut` or `FnOnce` using call notation, the number of parameters passed to the\n+function must match its definition.\n+\n+An example using a closure:\n+\n+```compile_fail,E0057\n+let f = |x| x * 3;\n+let a = f();        // invalid, too few parameters\n+let b = f(4);       // this works!\n+let c = f(2, 3);    // invalid, too many parameters\n+```\n+\n+A generic function must be treated similarly:\n+\n+```\n+fn foo<F: Fn()>(f: F) {\n+    f(); // this is valid, but f(3) would not work\n+}\n+```"}, {"sha": "b22edead25e7b26bc6dfe466001d0150c3081f2f", "filename": "src/librustc_error_codes/error_codes/E0059.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0059.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0059.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0059.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,25 @@\n+The built-in function traits are generic over a tuple of the function arguments.\n+If one uses angle-bracket notation (`Fn<(T,), Output=U>`) instead of parentheses\n+(`Fn(T) -> U`) to denote the function trait, the type parameter should be a\n+tuple. Otherwise function call notation cannot be used and the trait will not be\n+implemented by closures.\n+\n+The most likely source of this error is using angle-bracket notation without\n+wrapping the function argument type into a tuple, for example:\n+\n+```compile_fail,E0059\n+#![feature(unboxed_closures)]\n+\n+fn foo<F: Fn<i32>>(f: F) -> F::Output { f(3) }\n+```\n+\n+It can be fixed by adjusting the trait bound like this:\n+\n+```\n+#![feature(unboxed_closures)]\n+\n+fn foo<F: Fn<(i32,)>>(f: F) -> F::Output { f(3) }\n+```\n+\n+Note that `(T,)` always denotes the type of a 1-tuple containing an element of\n+type `T`. The comma is necessary for syntactic disambiguation."}, {"sha": "7a07b8e7ed6697ce9dc94f953e7faabc33950177", "filename": "src/librustc_error_codes/error_codes/E0060.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0060.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,36 @@\n+External C functions are allowed to be variadic. However, a variadic function\n+takes a minimum number of arguments. For example, consider C's variadic `printf`\n+function:\n+\n+```\n+use std::os::raw::{c_char, c_int};\n+\n+extern \"C\" {\n+    fn printf(_: *const c_char, ...) -> c_int;\n+}\n+```\n+\n+Using this declaration, it must be called with at least one argument, so\n+simply calling `printf()` is invalid. But the following uses are allowed:\n+\n+```\n+# #![feature(static_nobundle)]\n+# use std::os::raw::{c_char, c_int};\n+# #[cfg_attr(all(windows, target_env = \"msvc\"),\n+#            link(name = \"legacy_stdio_definitions\", kind = \"static-nobundle\"))]\n+# extern \"C\" { fn printf(_: *const c_char, ...) -> c_int; }\n+# fn main() {\n+unsafe {\n+    use std::ffi::CString;\n+\n+    let fmt = CString::new(\"test\\n\").unwrap();\n+    printf(fmt.as_ptr());\n+\n+    let fmt = CString::new(\"number = %d\\n\").unwrap();\n+    printf(fmt.as_ptr(), 3);\n+\n+    let fmt = CString::new(\"%d, %d\\n\").unwrap();\n+    printf(fmt.as_ptr(), 10, 5);\n+}\n+# }\n+```"}, {"sha": "3386dff2c8513c2bde8e9bfb99f6d6119fbb41fe", "filename": "src/librustc_error_codes/error_codes/E0061.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0061.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+The number of arguments passed to a function must match the number of arguments\n+specified in the function signature.\n+\n+For example, a function like:\n+\n+```\n+fn f(a: u16, b: &str) {}\n+```\n+\n+Must always be called with exactly two arguments, e.g., `f(2, \"test\")`.\n+\n+Note that Rust does not have a notion of optional function arguments or\n+variadic functions (except for its C-FFI)."}, {"sha": "0ebeb1bd78ed0af2a683f564b643511db32cb2bc", "filename": "src/librustc_error_codes/error_codes/E0062.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0062.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+This error indicates that during an attempt to build a struct or struct-like\n+enum variant, one of the fields was specified more than once. Erroneous code\n+example:\n+\n+```compile_fail,E0062\n+struct Foo {\n+    x: i32,\n+}\n+\n+fn main() {\n+    let x = Foo {\n+                x: 0,\n+                x: 0, // error: field `x` specified more than once\n+            };\n+}\n+```\n+\n+Each field should be specified exactly one time. Example:\n+\n+```\n+struct Foo {\n+    x: i32,\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0 }; // ok!\n+}\n+```"}, {"sha": "0d1f60437acf015228ead632d8a9f09504f05401", "filename": "src/librustc_error_codes/error_codes/E0063.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0063.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,26 @@\n+This error indicates that during an attempt to build a struct or struct-like\n+enum variant, one of the fields was not provided. Erroneous code example:\n+\n+```compile_fail,E0063\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0 }; // error: missing field: `y`\n+}\n+```\n+\n+Each field should be specified exactly once. Example:\n+\n+```\n+struct Foo {\n+    x: i32,\n+    y: i32,\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0, y: 0 }; // ok!\n+}\n+```"}, {"sha": "101b96f7983f624854157cc842dfc4b8538c6cde", "filename": "src/librustc_error_codes/error_codes/E0067.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0067.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,33 @@\n+The left-hand side of a compound assignment expression must be a place\n+expression. A place expression represents a memory location and includes\n+item paths (ie, namespaced variables), dereferences, indexing expressions,\n+and field references.\n+\n+Let's start with some erroneous code examples:\n+\n+```compile_fail,E0067\n+use std::collections::LinkedList;\n+\n+// Bad: assignment to non-place expression\n+LinkedList::new() += 1;\n+\n+// ...\n+\n+fn some_func(i: &mut i32) {\n+    i += 12; // Error : '+=' operation cannot be applied on a reference !\n+}\n+```\n+\n+And now some working examples:\n+\n+```\n+let mut i : i32 = 0;\n+\n+i += 12; // Good !\n+\n+// ...\n+\n+fn some_func(i: &mut i32) {\n+    *i += 12; // Good !\n+}\n+```"}, {"sha": "ad3b1803b54dbb4b12dc6d31014c2078ca50e114", "filename": "src/librustc_error_codes/error_codes/E0069.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0069.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,12 @@\n+The compiler found a function whose body contains a `return;` statement but\n+whose return type is not `()`. An example of this is:\n+\n+```compile_fail,E0069\n+// error\n+fn foo() -> u8 {\n+    return;\n+}\n+```\n+\n+Since `return;` is just like `return ();`, there is a mismatch between the\n+function's return type and the value being returned."}, {"sha": "1a56080a09734338de12867d30c25d09e34948a0", "filename": "src/librustc_error_codes/error_codes/E0070.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0070.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,47 @@\n+The left-hand side of an assignment operator must be a place expression. A\n+place expression represents a memory location and can be a variable (with\n+optional namespacing), a dereference, an indexing expression or a field\n+reference.\n+\n+More details can be found in the [Expressions] section of the Reference.\n+\n+[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\n+\n+Now, we can go further. Here are some erroneous code examples:\n+\n+```compile_fail,E0070\n+struct SomeStruct {\n+    x: i32,\n+    y: i32\n+}\n+\n+const SOME_CONST : i32 = 12;\n+\n+fn some_other_func() {}\n+\n+fn some_function() {\n+    SOME_CONST = 14; // error : a constant value cannot be changed!\n+    1 = 3; // error : 1 isn't a valid place!\n+    some_other_func() = 4; // error : we cannot assign value to a function!\n+    SomeStruct.x = 12; // error : SomeStruct a structure name but it is used\n+                       // like a variable!\n+}\n+```\n+\n+And now let's give working examples:\n+\n+```\n+struct SomeStruct {\n+    x: i32,\n+    y: i32\n+}\n+let mut s = SomeStruct {x: 0, y: 0};\n+\n+s.x = 3; // that's good !\n+\n+// ...\n+\n+fn some_func(x: &mut i32) {\n+    *x = 12; // that's good !\n+}\n+```"}, {"sha": "768dd0c7a48c29624779a101ad6c99e136c98603", "filename": "src/librustc_error_codes/error_codes/E0071.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0071.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,27 @@\n+You tried to use structure-literal syntax to create an item that is\n+not a structure or enum variant.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0071\n+type U32 = u32;\n+let t = U32 { value: 4 }; // error: expected struct, variant or union type,\n+                          // found builtin type `u32`\n+```\n+\n+To fix this, ensure that the name was correctly spelled, and that\n+the correct form of initializer was used.\n+\n+For example, the code above can be fixed to:\n+\n+```\n+enum Foo {\n+    FirstValue(i32)\n+}\n+\n+fn main() {\n+    let u = Foo::FirstValue(0i32);\n+\n+    let t = 4;\n+}\n+```"}, {"sha": "e461d45f30c858902dd327acaab0328777fae3ce", "filename": "src/librustc_error_codes/error_codes/E0072.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0072.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+When defining a recursive struct or enum, any use of the type being defined\n+from inside the definition must occur behind a pointer (like `Box` or `&`).\n+This is because structs and enums must have a well-defined size, and without\n+the pointer, the size of the type would need to be unbounded.\n+\n+Consider the following erroneous definition of a type for a list of bytes:\n+\n+```compile_fail,E0072\n+// error, invalid recursive struct type\n+struct ListNode {\n+    head: u8,\n+    tail: Option<ListNode>,\n+}\n+```\n+\n+This type cannot have a well-defined size, because it needs to be arbitrarily\n+large (since we would be able to nest `ListNode`s to any depth). Specifically,\n+\n+```plain\n+size of `ListNode` = 1 byte for `head`\n+                   + 1 byte for the discriminant of the `Option`\n+                   + size of `ListNode`\n+```\n+\n+One way to fix this is by wrapping `ListNode` in a `Box`, like so:\n+\n+```\n+struct ListNode {\n+    head: u8,\n+    tail: Option<Box<ListNode>>,\n+}\n+```\n+\n+This works because `Box` is a pointer, so its size is well-known."}, {"sha": "a5aea86ff2d9df6f371070756478b8045c25b18f", "filename": "src/librustc_error_codes/error_codes/E0073.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0073.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0073.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0073.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You cannot define a struct (or enum) `Foo` that requires an instance of `Foo`\n+in order to make a new `Foo` value. This is because there would be no way a\n+first instance of `Foo` could be made to initialize another instance!\n+\n+Here's an example of a struct that has this problem:\n+\n+```\n+struct Foo { x: Box<Foo> } // error\n+```\n+\n+One fix is to use `Option`, like so:\n+\n+```\n+struct Foo { x: Option<Box<Foo>> }\n+```\n+\n+Now it's possible to create at least one instance of `Foo`: `Foo { x: None }`."}, {"sha": "e25dec7681be5e4715f33d92edc7db7bd8404978", "filename": "src/librustc_error_codes/error_codes/E0074.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0074.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0074.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0074.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+When using the `#[simd]` attribute on a tuple struct, the components of the\n+tuple struct must all be of a concrete, nongeneric type so the compiler can\n+reason about how to use SIMD with them. This error will occur if the types\n+are generic.\n+\n+This will cause an error:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad<T>(T, T, T);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32, u32, u32);\n+```"}, {"sha": "f15af8150baaacd25875a4eb5fddfc4cdfcef606", "filename": "src/librustc_error_codes/error_codes/E0075.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0075.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+The `#[simd]` attribute can only be applied to non empty tuple structs, because\n+it doesn't make sense to try to use SIMD operations when there are no values to\n+operate on.\n+\n+This will cause an error:\n+\n+```compile_fail,E0075\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad;\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32);\n+```"}, {"sha": "466e0a96e6b018a91b5b5cd8d7d52f883f27cc7b", "filename": "src/librustc_error_codes/error_codes/E0076.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0076.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+When using the `#[simd]` attribute to automatically use SIMD operations in tuple\n+struct, the types in the struct must all be of the same type, or the compiler\n+will trigger this error.\n+\n+This will cause an error:\n+\n+```compile_fail,E0076\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad(u16, u32, u32);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32, u32, u32);\n+```"}, {"sha": "6ae35a6aa17fe504744433e3c09cca54e20efeca", "filename": "src/librustc_error_codes/error_codes/E0077.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0077.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+When using the `#[simd]` attribute on a tuple struct, the elements in the tuple\n+must be machine types so SIMD operations can be applied to them.\n+\n+This will cause an error:\n+\n+```compile_fail,E0077\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Bad(String);\n+```\n+\n+This will not:\n+\n+```\n+#![feature(repr_simd)]\n+\n+#[repr(simd)]\n+struct Good(u32, u32, u32);\n+```"}, {"sha": "262bf00d385406e18278a828bfd4fd7e22683402", "filename": "src/librustc_error_codes/error_codes/E0080.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0080.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+This error indicates that the compiler was unable to sensibly evaluate a\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n+\n+```compile_fail,E0080\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n+```\n+\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n+\n+https://doc.rust-lang.org/reference.html#ffi-attributes"}, {"sha": "ec88ca9765e292ad1ab8898f6988f72528237950", "filename": "src/librustc_error_codes/error_codes/E0081.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0081.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,35 @@\n+Enum discriminants are used to differentiate enum variants stored in memory.\n+This error indicates that the same value was used for two or more variants,\n+making them impossible to tell apart.\n+\n+```compile_fail,E0081\n+// Bad.\n+enum Enum {\n+    P = 3,\n+    X = 3,\n+    Y = 5,\n+}\n+```\n+\n+```\n+// Good.\n+enum Enum {\n+    P,\n+    X = 3,\n+    Y = 5,\n+}\n+```\n+\n+Note that variants without a manually specified discriminant are numbered from\n+top to bottom starting from 0, so clashes can occur with seemingly unrelated\n+variants.\n+\n+```compile_fail,E0081\n+enum Bad {\n+    X,\n+    Y = 0\n+}\n+```\n+\n+Here `X` will have already been specified the discriminant 0 by the time `Y` is\n+encountered, so a conflict occurs."}, {"sha": "2388bc635d9f5a433756d6150eb20581e80d7b52", "filename": "src/librustc_error_codes/error_codes/E0084.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0084.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0084.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0084.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,27 @@\n+An unsupported representation was attempted on a zero-variant enum.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0084\n+#[repr(i32)]\n+enum NightsWatch {} // error: unsupported representation for zero-variant enum\n+```\n+\n+It is impossible to define an integer type to be used to represent zero-variant\n+enum values because there are no zero-variant enum values. There is no way to\n+construct an instance of the following type using only safe code. So you have\n+two solutions. Either you add variants in your enum:\n+\n+```\n+#[repr(i32)]\n+enum NightsWatch {\n+    JonSnow,\n+    Commander,\n+}\n+```\n+\n+or you remove the integer represention of your enum:\n+\n+```\n+enum NightsWatch {}\n+```"}, {"sha": "9d292186f0fa587f2dddb6651e256f9b5189be85", "filename": "src/librustc_error_codes/error_codes/E0087.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0087.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0087.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0087.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,15 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Too many type arguments were supplied for a function. For example:\n+\n+```compile_fail,E0107\n+fn foo<T>() {}\n+\n+fn main() {\n+    foo::<f64, bool>(); // error: wrong number of type arguments:\n+                        //        expected 1, found 2\n+}\n+```\n+\n+The number of supplied arguments must exactly match the number of defined type\n+parameters."}, {"sha": "7780ad5b56e03dc6e0c58e67e1aadcf4b832965c", "filename": "src/librustc_error_codes/error_codes/E0088.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0088.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0088.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0088.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,45 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You gave too many lifetime arguments. Erroneous code example:\n+\n+```compile_fail,E0107\n+fn f() {}\n+\n+fn main() {\n+    f::<'static>() // error: wrong number of lifetime arguments:\n+                   //        expected 0, found 1\n+}\n+```\n+\n+Please check you give the right number of lifetime arguments. Example:\n+\n+```\n+fn f() {}\n+\n+fn main() {\n+    f() // ok!\n+}\n+```\n+\n+It's also important to note that the Rust compiler can generally\n+determine the lifetime by itself. Example:\n+\n+```\n+struct Foo {\n+    value: String\n+}\n+\n+impl Foo {\n+    // it can be written like this\n+    fn get_value<'a>(&'a self) -> &'a str { &self.value }\n+    // but the compiler works fine with this too:\n+    fn without_lifetime(&self) -> &str { &self.value }\n+}\n+\n+fn main() {\n+    let f = Foo { value: \"hello\".to_owned() };\n+\n+    println!(\"{}\", f.get_value());\n+    println!(\"{}\", f.without_lifetime());\n+}\n+```"}, {"sha": "504fbc7b96a98552777383d621f2107031aaf6a0", "filename": "src/librustc_error_codes/error_codes/E0089.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0089.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0089.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0089.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,25 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Too few type arguments were supplied for a function. For example:\n+\n+```compile_fail,E0107\n+fn foo<T, U>() {}\n+\n+fn main() {\n+    foo::<f64>(); // error: wrong number of type arguments: expected 2, found 1\n+}\n+```\n+\n+Note that if a function takes multiple type arguments but you want the compiler\n+to infer some of them, you can use type placeholders:\n+\n+```compile_fail,E0107\n+fn foo<T, U>(x: T) {}\n+\n+fn main() {\n+    let x: bool = true;\n+    foo::<f64>(x);    // error: wrong number of type arguments:\n+                      //        expected 2, found 1\n+    foo::<_, f64>(x); // same as `foo::<bool, f64>(x)`\n+}\n+```"}, {"sha": "e091bb6c9f2f74786df375ea08dc081b65ac4645", "filename": "src/librustc_error_codes/error_codes/E0090.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0090.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0090.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0090.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You gave too few lifetime arguments. Example:\n+\n+```compile_fail,E0107\n+fn foo<'a: 'b, 'b: 'a>() {}\n+\n+fn main() {\n+    foo::<'static>(); // error: wrong number of lifetime arguments:\n+                      //        expected 2, found 1\n+}\n+```\n+\n+Please check you give the right number of lifetime arguments. Example:\n+\n+```\n+fn foo<'a: 'b, 'b: 'a>() {}\n+\n+fn main() {\n+    foo::<'static, 'static>();\n+}\n+```"}, {"sha": "2a092402429f13fcedbfcb8adb2fe69f1c4b0491", "filename": "src/librustc_error_codes/error_codes/E0091.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0091.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,15 @@\n+You gave an unnecessary type or const parameter in a type alias. Erroneous\n+code example:\n+\n+```compile_fail,E0091\n+type Foo<T> = u32; // error: type parameter `T` is unused\n+// or:\n+type Foo<A,B> = Box<A>; // error: type parameter `B` is unused\n+```\n+\n+Please check you didn't write too many parameters. Example:\n+\n+```\n+type Foo = u32; // ok!\n+type Foo2<A> = Box<A>; // ok!\n+```"}, {"sha": "2750a7d45b48e56a45646764288b295c1b1fbadb", "filename": "src/librustc_error_codes/error_codes/E0092.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0092.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,23 @@\n+You tried to declare an undefined atomic operation function.\n+Erroneous code example:\n+\n+```compile_fail,E0092\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_foo(); // error: unrecognized atomic operation\n+                     //        function\n+}\n+```\n+\n+Please check you didn't make a mistake in the function's name. All intrinsic\n+functions are defined in librustc_codegen_llvm/intrinsic.rs and in\n+libcore/intrinsics.rs in the Rust source code. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_fence(); // ok!\n+}\n+```"}, {"sha": "9633f794d8bb7457348b4d4794bed7eb14b28825", "filename": "src/librustc_error_codes/error_codes/E0093.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0093.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,33 @@\n+You declared an unknown intrinsic function. Erroneous code example:\n+\n+```compile_fail,E0093\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn foo(); // error: unrecognized intrinsic function: `foo`\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo();\n+    }\n+}\n+```\n+\n+Please check you didn't make a mistake in the function's name. All intrinsic\n+functions are defined in librustc_codegen_llvm/intrinsic.rs and in\n+libcore/intrinsics.rs in the Rust source code. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn atomic_fence(); // ok!\n+}\n+\n+fn main() {\n+    unsafe {\n+        atomic_fence();\n+    }\n+}\n+```"}, {"sha": "4d27f616d2d84250bc24f0d26355866ba36336a5", "filename": "src/librustc_error_codes/error_codes/E0094.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0094.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,23 @@\n+You gave an invalid number of type parameters to an intrinsic function.\n+Erroneous code example:\n+\n+```compile_fail,E0094\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T, U>() -> usize; // error: intrinsic has wrong number\n+                                 //        of type parameters\n+}\n+```\n+\n+Please check that you provided the right number of type parameters\n+and verify with the function declaration in the Rust source code.\n+Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T>() -> usize; // ok!\n+}\n+```"}, {"sha": "8a49c1f79e475e95b79ebe5c56f1234821555a6d", "filename": "src/librustc_error_codes/error_codes/E0106.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0106.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,53 @@\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```compile_fail,E0106\n+struct Foo1 { x: &bool }\n+              // ^ expected lifetime parameter\n+struct Foo2<'a> { x: &'a bool } // correct\n+\n+struct Bar1 { x: Foo2 }\n+              // ^^^^ expected lifetime parameter\n+struct Bar2<'a> { x: Foo2<'a> } // correct\n+\n+enum Baz1 { A(u8), B(&bool), }\n+                  // ^ expected lifetime parameter\n+enum Baz2<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr1 = &str;\n+           // ^ expected lifetime parameter\n+type MyStr2<'a> = &'a str; // correct\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```compile_fail,E0106\n+// error, no input lifetimes\n+fn foo() -> &str { }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { }\n+```\n+\n+[book-le]: https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision"}, {"sha": "3a8acba061c81d5d2241373f07abeb04b863f1b6", "filename": "src/librustc_error_codes/error_codes/E0107.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0107.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+This error means that an incorrect number of generic arguments were provided:\n+\n+```compile_fail,E0107\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }             // error: wrong number of type arguments:\n+                                  //        expected 1, found 0\n+struct Baz<S, T> { x: Foo<S, T> } // error: wrong number of type arguments:\n+                                  //        expected 1, found 2\n+\n+fn foo<T, U>(x: T, y: U) {}\n+\n+fn main() {\n+    let x: bool = true;\n+    foo::<bool>(x);                 // error: wrong number of type arguments:\n+                                    //        expected 2, found 1\n+    foo::<bool, i32, i32>(x, 2, 4); // error: wrong number of type arguments:\n+                                    //        expected 2, found 3\n+}\n+\n+fn f() {}\n+\n+fn main() {\n+    f::<'static>(); // error: wrong number of lifetime arguments:\n+                    //        expected 0, found 1\n+}\n+```\n+"}, {"sha": "5bc229ade52f471abe53cb60effb5c511edf6203", "filename": "src/librustc_error_codes/error_codes/E0109.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0109.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+You tried to provide a generic argument to a type which doesn't need it.\n+Erroneous code example:\n+\n+```compile_fail,E0109\n+type X = u32<i32>; // error: type arguments are not allowed for this type\n+type Y = bool<'static>; // error: lifetime parameters are not allowed on\n+                        //        this type\n+```\n+\n+Check that you used the correct argument and that the definition is correct.\n+\n+Example:\n+\n+```\n+type X = u32; // ok!\n+type Y = bool; // ok!\n+```\n+\n+Note that generic arguments for enum variant constructors go after the variant,\n+not after the enum. For example, you would write `Option::None::<u32>`,\n+rather than `Option::<u32>::None`."}, {"sha": "b9fe406ffb9bdb0a0c8c222d15a4f5dfde8c44cb", "filename": "src/librustc_error_codes/error_codes/E0110.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0110.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0110.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0110.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,4 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You tried to provide a lifetime to a type which doesn't need it.\n+See `E0109` for more details."}, {"sha": "27759a423433fa0eb50a47bc7c9497c28575a9a4", "filename": "src/librustc_error_codes/error_codes/E0116.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0116.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,23 @@\n+You can only define an inherent implementation for a type in the same crate\n+where the type was defined. For example, an `impl` block as below is not allowed\n+since `Vec` is defined in the standard library:\n+\n+```compile_fail,E0116\n+impl Vec<u8> { } // error\n+```\n+\n+To fix this problem, you can do either of these things:\n+\n+ - define a trait that has the desired associated functions/types/constants and\n+   implement the trait for the type in question\n+ - define a new type wrapping the type and define an implementation on the new\n+   type\n+\n+Note that using the `type` keyword does not work here because `type` only\n+introduces a type alias:\n+\n+```compile_fail,E0116\n+type Bytes = Vec<u8>;\n+\n+impl Bytes { } // error, same as above\n+```"}, {"sha": "bd36230566262bc6527ef23ac42a41ddefe83a70", "filename": "src/librustc_error_codes/error_codes/E0117.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0117.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,48 @@\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule prohibits any implementation of a foreign trait (a\n+trait defined in another crate) where\n+\n+ - the type that is implementing the trait is foreign\n+ - all of the parameters being passed to the trait (if there are any) are also\n+   foreign.\n+\n+Here's one example of this error:\n+\n+```compile_fail,E0117\n+impl Drop for u32 {}\n+```\n+\n+To avoid this kind of error, ensure that at least one local type is referenced\n+by the `impl`:\n+\n+```\n+pub struct Foo; // you define your type in your crate\n+\n+impl Drop for Foo { // and you can implement the trait on it!\n+    // code of trait implementation here\n+#   fn drop(&mut self) { }\n+}\n+\n+impl From<Foo> for i32 { // or you use a type from your crate as\n+                         // a type parameter\n+    fn from(i: Foo) -> i32 {\n+        0\n+    }\n+}\n+```\n+\n+Alternatively, define a trait locally and implement that instead:\n+\n+```\n+trait Bar {\n+    fn get(&self) -> usize;\n+}\n+\n+impl Bar for u32 {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md"}, {"sha": "baf35ffbb0b530facae434b1c59b45a71b30c314", "filename": "src/librustc_error_codes/error_codes/E0118.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0118.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,41 @@\n+You're trying to write an inherent implementation for something which isn't a\n+struct nor an enum. Erroneous code example:\n+\n+```compile_fail,E0118\n+impl (u8, u8) { // error: no base type found for inherent implementation\n+    fn get_state(&self) -> String {\n+        // ...\n+    }\n+}\n+```\n+\n+To fix this error, please implement a trait on the type or wrap it in a struct.\n+Example:\n+\n+```\n+// we create a trait here\n+trait LiveLongAndProsper {\n+    fn get_state(&self) -> String;\n+}\n+\n+// and now you can implement it on (u8, u8)\n+impl LiveLongAndProsper for (u8, u8) {\n+    fn get_state(&self) -> String {\n+        \"He's dead, Jim!\".to_owned()\n+    }\n+}\n+```\n+\n+Alternatively, you can create a newtype. A newtype is a wrapping tuple-struct.\n+For example, `NewType` is a newtype over `Foo` in `struct NewType(Foo)`.\n+Example:\n+\n+```\n+struct TypeWrapper((u8, u8));\n+\n+impl TypeWrapper {\n+    fn get_state(&self) -> String {\n+        \"Fascinating!\".to_owned()\n+    }\n+}\n+```"}, {"sha": "0af3bd4a0de796706224cd7a2c5b5189d66c7865", "filename": "src/librustc_error_codes/error_codes/E0119.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0119.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,58 @@\n+There are conflicting trait implementations for the same type.\n+Example of erroneous code:\n+\n+```compile_fail,E0119\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo {\n+    value: usize\n+}\n+\n+impl MyTrait for Foo { // error: conflicting implementations of trait\n+                       //        `MyTrait` for type `Foo`\n+    fn get(&self) -> usize { self.value }\n+}\n+```\n+\n+When looking for the implementation for the trait, the compiler finds\n+both the `impl<T> MyTrait for T` where T is all types and the `impl\n+MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n+this is an error. So, when you write:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+This makes the trait implemented on all types in the scope. So if you\n+try to implement it on another one after that, the implementations will\n+conflict. Example:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo;\n+\n+fn main() {\n+    let f = Foo;\n+\n+    f.get(); // the trait is implemented so we can use it\n+}\n+```"}, {"sha": "99c2a493a46b9ec7784b87191bedb2dfce6745ff", "filename": "src/librustc_error_codes/error_codes/E0120.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0120.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,36 @@\n+An attempt was made to implement Drop on a trait, which is not allowed: only\n+structs and enums can implement Drop. An example causing this error:\n+\n+```compile_fail,E0120\n+trait MyTrait {}\n+\n+impl Drop for MyTrait {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+A workaround for this problem is to wrap the trait up in a struct, and implement\n+Drop on that. An example is shown below:\n+\n+```\n+trait MyTrait {}\n+struct MyWrapper<T: MyTrait> { foo: T }\n+\n+impl <T: MyTrait> Drop for MyWrapper<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+```\n+\n+Alternatively, wrapping trait objects requires something like the following:\n+\n+```\n+trait MyTrait {}\n+\n+//or Box<MyTrait>, if you wanted an owned trait object\n+struct MyWrapper<'a> { foo: &'a MyTrait }\n+\n+impl <'a> Drop for MyWrapper<'a> {\n+    fn drop(&mut self) {}\n+}\n+```"}, {"sha": "069d0fc48fb0f7c4cf1b78a3f824ad7c7640438c", "filename": "src/librustc_error_codes/error_codes/E0121.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0121.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,10 @@\n+In order to be consistent with Rust's lack of global type inference,\n+type and const placeholders are disallowed by design in item signatures.\n+\n+Examples of this error include:\n+\n+```compile_fail,E0121\n+fn foo() -> _ { 5 } // error, explicitly write out the return type instead\n+\n+static BAR: _ = \"test\"; // error, explicitly write out the type instead\n+```"}, {"sha": "a7836526a7dd4f9eb5f0312528a7dd4381a3bb6a", "filename": "src/librustc_error_codes/error_codes/E0124.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0124.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0124.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0124.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,18 @@\n+You declared two fields of a struct with the same name. Erroneous code\n+example:\n+\n+```compile_fail,E0124\n+struct Foo {\n+    field1: i32,\n+    field1: i32, // error: field is already declared\n+}\n+```\n+\n+Please verify that the field names have been correctly spelled. Example:\n+\n+```\n+struct Foo {\n+    field1: i32,\n+    field2: i32, // ok!\n+}\n+```"}, {"sha": "d0a4b32f9688e84ab983bed4ad65857d6494e9e2", "filename": "src/librustc_error_codes/error_codes/E0128.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0128.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0128.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0128.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+Type parameter defaults can only use parameters that occur before them.\n+Erroneous code example:\n+\n+```compile_fail,E0128\n+struct Foo<T = U, U = ()> {\n+    field1: T,\n+    field2: U,\n+}\n+// error: type parameters with a default cannot use forward declared\n+// identifiers\n+```\n+\n+Since type parameters are evaluated in-order, you may be able to fix this issue\n+by doing:\n+\n+```\n+struct Foo<U = (), T = U> {\n+    field1: T,\n+    field2: U,\n+}\n+```\n+\n+Please also verify that this wasn't because of a name-clash and rename the type\n+parameter if so."}, {"sha": "5273f3ad14f46a8f8388731329223d2ef398d6cd", "filename": "src/librustc_error_codes/error_codes/E0130.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0130.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,31 @@\n+You declared a pattern as an argument in a foreign function declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+extern {\n+    fn foo((a, b): (u32, u32)); // error: patterns aren't allowed in foreign\n+                                //        function declarations\n+}\n+```\n+\n+Please replace the pattern argument with a regular one. Example:\n+\n+```\n+struct SomeStruct {\n+    a: u32,\n+    b: u32,\n+}\n+\n+extern {\n+    fn foo(s: SomeStruct); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+extern {\n+    fn foo(a: (u32, u32)); // ok!\n+}\n+```"}, {"sha": "a70a02925b0fb73bc3bcfab54d74f16af61970b4", "filename": "src/librustc_error_codes/error_codes/E0131.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0131.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0131.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0131.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,8 @@\n+It is not possible to define `main` with generic parameters.\n+When `main` is present, it must take no arguments and return `()`.\n+Erroneous code example:\n+\n+```compile_fail,E0131\n+fn main<T>() { // error: main function is not allowed to have generic parameters\n+}\n+```"}, {"sha": "a23cc988bdb66606e1f295ac63d55ba4dff75b7f", "filename": "src/librustc_error_codes/error_codes/E0132.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0132.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0132.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0132.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+A function with the `start` attribute was declared with type parameters.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0132\n+#![feature(start)]\n+\n+#[start]\n+fn f<T>() {}\n+```\n+\n+It is not possible to declare type parameters on a function that has the `start`\n+attribute. Such a function must have the following type signature (for more\n+information, view [the unstable book][1]):\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib\n+\n+```\n+# let _:\n+fn(isize, *const *const u8) -> isize;\n+```\n+\n+Example:\n+\n+```\n+#![feature(start)]\n+\n+#[start]\n+fn my_start(argc: isize, argv: *const *const u8) -> isize {\n+    0\n+}\n+```"}, {"sha": "0488cdd808d6c60f54167021c4b40cd9ba1b4f75", "filename": "src/librustc_error_codes/error_codes/E0133.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0133.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,31 @@\n+Unsafe code was used outside of an unsafe function or block.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0133\n+unsafe fn f() { return; } // This is the unsafe code\n+\n+fn main() {\n+    f(); // error: call to unsafe function requires unsafe function or block\n+}\n+```\n+\n+Using unsafe functionality is potentially dangerous and disallowed by safety\n+checks. Examples:\n+\n+* Dereferencing raw pointers\n+* Calling functions via FFI\n+* Calling functions marked unsafe\n+\n+These safety checks can be relaxed for a section of the code by wrapping the\n+unsafe instructions with an `unsafe` block. For instance:\n+\n+```\n+unsafe fn f() { return; }\n+\n+fn main() {\n+    unsafe { f(); } // ok!\n+}\n+```\n+\n+See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}, {"sha": "c0e8c7e061cf594e2b31387507311d5dc584b78e", "filename": "src/librustc_error_codes/error_codes/E0136.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0136.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0136.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0136.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+A binary can only have one entry point, and by default that entry point is the\n+function `main()`. If there are multiple such functions, please rename one.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0136\n+fn main() {\n+    // ...\n+}\n+\n+// ...\n+\n+fn main() { // error!\n+    // ...\n+}\n+```"}, {"sha": "0a02913d2364d6716caba2ab49e45410edc00be2", "filename": "src/librustc_error_codes/error_codes/E0137.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0137.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0137.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0137.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+More than one function was declared with the `#[main]` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0137\n+#![feature(main)]\n+\n+#[main]\n+fn foo() {}\n+\n+#[main]\n+fn f() {} // error: multiple functions with a `#[main]` attribute\n+```\n+\n+This error indicates that the compiler found multiple functions with the\n+`#[main]` attribute. This is an error because there must be a unique entry\n+point into a Rust program. Example:\n+\n+```\n+#![feature(main)]\n+\n+#[main]\n+fn f() {} // ok!\n+```"}, {"sha": "3f5eaea9f989e6ab8afc72aae6ce6145186ebf80", "filename": "src/librustc_error_codes/error_codes/E0138.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0138.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0138.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0138.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,25 @@\n+More than one function was declared with the `#[start]` attribute.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0138\n+#![feature(start)]\n+\n+#[start]\n+fn foo(argc: isize, argv: *const *const u8) -> isize {}\n+\n+#[start]\n+fn f(argc: isize, argv: *const *const u8) -> isize {}\n+// error: multiple 'start' functions\n+```\n+\n+This error indicates that the compiler found multiple functions with the\n+`#[start]` attribute. This is an error because there must be a unique entry\n+point into a Rust program. Example:\n+\n+```\n+#![feature(start)]\n+\n+#[start]\n+fn foo(argc: isize, argv: *const *const u8) -> isize { 0 } // ok!\n+```"}, {"sha": "a116cf29395faa7168910465eee27e14f1c4b38e", "filename": "src/librustc_error_codes/error_codes/E0139.md", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0139.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0139.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0139.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,84 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+There are various restrictions on transmuting between types in Rust; for example\n+types being transmuted must have the same size. To apply all these restrictions,\n+the compiler must know the exact types that may be transmuted. When type\n+parameters are involved, this cannot always be done.\n+\n+So, for example, the following is not allowed:\n+\n+```\n+use std::mem::transmute;\n+\n+struct Foo<T>(Vec<T>);\n+\n+fn foo<T>(x: Vec<T>) {\n+    // we are transmuting between Vec<T> and Foo<F> here\n+    let y: Foo<T> = unsafe { transmute(x) };\n+    // do something with y\n+}\n+```\n+\n+In this specific case there's a good chance that the transmute is harmless (but\n+this is not guaranteed by Rust). However, when alignment and enum optimizations\n+come into the picture, it's quite likely that the sizes may or may not match\n+with different type parameter substitutions. It's not possible to check this for\n+_all_ possible types, so `transmute()` simply only accepts types without any\n+unsubstituted type parameters.\n+\n+If you need this, there's a good chance you're doing something wrong. Keep in\n+mind that Rust doesn't guarantee much about the layout of different structs\n+(even two structs with identical declarations may have different layouts). If\n+there is a solution that avoids the transmute entirely, try it instead.\n+\n+If it's possible, hand-monomorphize the code by writing the function for each\n+possible type substitution. It's possible to use traits to do this cleanly,\n+for example:\n+\n+```\n+use std::mem::transmute;\n+\n+struct Foo<T>(Vec<T>);\n+\n+trait MyTransmutableType: Sized {\n+    fn transmute(_: Vec<Self>) -> Foo<Self>;\n+}\n+\n+impl MyTransmutableType for u8 {\n+    fn transmute(x: Vec<u8>) -> Foo<u8> {\n+        unsafe { transmute(x) }\n+    }\n+}\n+\n+impl MyTransmutableType for String {\n+    fn transmute(x: Vec<String>) -> Foo<String> {\n+        unsafe { transmute(x) }\n+    }\n+}\n+\n+// ... more impls for the types you intend to transmute\n+\n+fn foo<T: MyTransmutableType>(x: Vec<T>) {\n+    let y: Foo<T> = <T as MyTransmutableType>::transmute(x);\n+    // do something with y\n+}\n+```\n+\n+Each impl will be checked for a size match in the transmute as usual, and since\n+there are no unbound type parameters involved, this should compile unless there\n+is a size mismatch in one of the impls.\n+\n+It is also possible to manually transmute:\n+\n+```\n+# use std::ptr;\n+# let v = Some(\"value\");\n+# type SomeType = &'static [u8];\n+unsafe {\n+    ptr::read(&v as *const _ as *const SomeType) // `v` transmuted to `SomeType`\n+}\n+# ;\n+```\n+\n+Note that this does not move `v` (unlike `transmute`), and may need a\n+call to `mem::forget(v)` in case you want to avoid destructors being called."}, {"sha": "602dcb6e2c5b754fe6023a07c2f570145d5df02f", "filename": "src/librustc_error_codes/error_codes/E0152.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0152.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,25 @@\n+A lang item was redefined.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0152\n+#![feature(lang_items)]\n+\n+#[lang = \"arc\"]\n+struct Foo; // error: duplicate lang item found: `arc`\n+```\n+\n+Lang items are already implemented in the standard library. Unless you are\n+writing a free-standing application (e.g., a kernel), you do not need to provide\n+them yourself.\n+\n+You can build a free-standing crate by adding `#![no_std]` to the crate\n+attributes:\n+\n+```ignore (only-for-syntax-highlight)\n+#![no_std]\n+```\n+\n+See also the [unstable book][1].\n+\n+[1]: https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib"}, {"sha": "725a775e72cca31ed2e21f7f8cfbdd49b36c384b", "filename": "src/librustc_error_codes/error_codes/E0154.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0154.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,33 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Imports (`use` statements) are not allowed after non-item statements, such as\n+variable declarations and expression statements.\n+\n+Here is an example that demonstrates the error:\n+\n+```\n+fn f() {\n+    // Variable declaration before import\n+    let x = 0;\n+    use std::io::Read;\n+    // ...\n+}\n+```\n+\n+The solution is to declare the imports at the top of the block, function, or\n+file.\n+\n+Here is the previous example again, with the correct order:\n+\n+```\n+fn f() {\n+    use std::io::Read;\n+    let x = 0;\n+    // ...\n+}\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+https://doc.rust-lang.org/reference.html#statements"}, {"sha": "0a9ef9c39385cc6aa18af1c4e22df9a05ba70179", "filename": "src/librustc_error_codes/error_codes/E0158.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0158.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0158.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0158.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,38 @@\n+An associated const has been referenced in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0158\n+enum EFoo { A, B, C, D }\n+\n+trait Foo {\n+    const X: EFoo;\n+}\n+\n+fn test<A: Foo>(arg: EFoo) {\n+    match arg {\n+        A::X => { // error!\n+            println!(\"A::X\");\n+        }\n+    }\n+}\n+```\n+\n+`const` and `static` mean different things. A `const` is a compile-time\n+constant, an alias for a literal value. This property means you can match it\n+directly within a pattern.\n+\n+The `static` keyword, on the other hand, guarantees a fixed location in memory.\n+This does not always mean that the value is constant. For example, a global\n+mutex can be declared `static` as well.\n+\n+If you want to match against a `static`, consider using a guard instead:\n+\n+```\n+static FORTY_TWO: i32 = 42;\n+\n+match Some(42) {\n+    Some(x) if x == FORTY_TWO => {}\n+    _ => {}\n+}\n+```"}, {"sha": "26269db2327ce73122d6713bef481f3d138d85b2", "filename": "src/librustc_error_codes/error_codes/E0161.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0161.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0161.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0161.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,30 @@\n+A value was moved. However, its size was not known at compile time, and only\n+values of a known size can be moved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0161\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<[isize]> = box *array;\n+    // error: cannot move a value of type [isize]: the size of [isize] cannot\n+    //        be statically determined\n+}\n+```\n+\n+In Rust, you can only move a value when its size is known at compile time.\n+\n+To work around this restriction, consider \"hiding\" the value behind a reference:\n+either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n+it around as usual. Example:\n+\n+```\n+#![feature(box_syntax)]\n+\n+fn main() {\n+    let array: &[isize] = &[1, 2, 3];\n+    let _x: Box<&[isize]> = box array; // ok!\n+}\n+```"}, {"sha": "98146147f3950da35f564707003d7e5701d64745", "filename": "src/librustc_error_codes/error_codes/E0162.md", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0162.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0162.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0162.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,26 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An if-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+if let Irrefutable(x) = irr {\n+    // This body will always be executed.\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+let Irrefutable(x) = irr;\n+println!(\"{}\", x);\n+```"}, {"sha": "b41ce6fad8e572fe2f0e0b045dd3f648989dcf00", "filename": "src/librustc_error_codes/error_codes/E0164.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0164.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0164.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0164.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+This error means that an attempt was made to match a struct type enum\n+variant as a non-struct type:\n+\n+```compile_fail,E0164\n+enum Foo { B { i: u32 } }\n+\n+fn bar(foo: Foo) -> u32 {\n+    match foo {\n+        Foo::B(i) => i, // error E0164\n+    }\n+}\n+```\n+\n+Try using `{}` instead:\n+\n+```\n+enum Foo { B { i: u32 } }\n+\n+fn bar(foo: Foo) -> u32 {\n+    match foo {\n+        Foo::B{i} => i,\n+    }\n+}\n+```"}, {"sha": "92243db455015404b2aa836aba97009f5b4e6072", "filename": "src/librustc_error_codes/error_codes/E0165.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0165.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0165.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0165.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,27 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A while-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n+\n+```no_run\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+while let Irrefutable(x) = irr {\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```no_run\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+loop {\n+    let Irrefutable(x) = irr;\n+    // ...\n+}\n+```"}, {"sha": "4b870dbf22155cc38fc676c8bbd4a7c6d2a63d1a", "filename": "src/librustc_error_codes/error_codes/E0170.md", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0170.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,46 @@\n+Enum variants are qualified by default. For example, given this type:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+```\n+\n+You would match it using:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+let m = Method::GET;\n+\n+match m {\n+    Method::GET => {},\n+    Method::POST => {},\n+}\n+```\n+\n+If you don't qualify the names, the code will bind new variables named \"GET\" and\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n+that happens.\n+\n+Qualified names are good practice, and most code works well with them. But if\n+you prefer them unqualified, you can import the variants into scope:\n+\n+```\n+use Method::*;\n+enum Method { GET, POST }\n+# fn main() {}\n+```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```\n+pub use Method::*;\n+pub enum Method { GET, POST }\n+# fn main() {}\n+```"}, {"sha": "07980ad83f1b5dc3c50080b28d65d940c18ed102", "filename": "src/librustc_error_codes/error_codes/E0178.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0178.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0178.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0178.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+In types, the `+` type operator has low precedence, so it is often necessary\n+to use parentheses.\n+\n+For example:\n+\n+```compile_fail,E0178\n+trait Foo {}\n+\n+struct Bar<'a> {\n+    w: &'a Foo + Copy,   // error, use &'a (Foo + Copy)\n+    x: &'a Foo + 'a,     // error, use &'a (Foo + 'a)\n+    y: &'a mut Foo + 'a, // error, use &'a mut (Foo + 'a)\n+    z: fn() -> Foo + 'a, // error, use fn() -> (Foo + 'a)\n+}\n+```\n+\n+More details can be found in [RFC 438].\n+\n+[RFC 438]: https://github.com/rust-lang/rfcs/pull/438"}, {"sha": "e7fa8dfd8313e7be690d7e42b3c246da49700a0a", "filename": "src/librustc_error_codes/error_codes/E0184.md", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0184.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0184.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0184.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,6 @@\n+Explicitly implementing both Drop and Copy for a type is currently disallowed.\n+This feature can make some sense in theory, but the current implementation is\n+incorrect and can lead to memory unsafety (see [issue #20126][iss20126]), so\n+it has been disabled for now.\n+\n+[iss20126]: https://github.com/rust-lang/rust/issues/20126"}, {"sha": "f0ad2af144aa00fe42d92d47df79d0aa7b3f20f4", "filename": "src/librustc_error_codes/error_codes/E0185.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0185.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+An associated function for a trait was defined to be static, but an\n+implementation of the trait declared the same function to be a method (i.e., to\n+take a `self` parameter).\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0185\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, method `foo` has a `&self` declaration in the impl, but not in\n+    // the trait\n+    fn foo(&self) {}\n+}\n+```"}, {"sha": "9135d5c1d5e9ad13f16b78109f9abf0bf61a489f", "filename": "src/librustc_error_codes/error_codes/E0186.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0186.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0186.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0186.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+An associated function for a trait was defined to be a method (i.e., to take a\n+`self` parameter), but an implementation of the trait declared the same function\n+to be static.\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0186\n+trait Foo {\n+    fn foo(&self);\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, method `foo` has a `&self` declaration in the trait, but not in\n+    // the impl\n+    fn foo() {}\n+}\n+```"}, {"sha": "b79196f6cec7a15c48e41987e5c3c79b8a01af95", "filename": "src/librustc_error_codes/error_codes/E0191.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0191.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0191.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0191.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+Trait objects need to have all associated types specified. Erroneous code\n+example:\n+\n+```compile_fail,E0191\n+trait Trait {\n+    type Bar;\n+}\n+\n+type Foo = Trait; // error: the value of the associated type `Bar` (from\n+                  //        the trait `Trait`) must be specified\n+```\n+\n+Please verify you specified all associated types of the trait and that you\n+used the right trait. Example:\n+\n+```\n+trait Trait {\n+    type Bar;\n+}\n+\n+type Foo = Trait<Bar=i32>; // ok!\n+```"}, {"sha": "33308868cb235caaeebb54f8ea5687b754763b32", "filename": "src/librustc_error_codes/error_codes/E0192.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0192.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0192.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0192.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,4 @@\n+Negative impls are only allowed for auto traits. For more\n+information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md"}, {"sha": "e29a949ffba919329b2bac68d8628716f432cb35", "filename": "src/librustc_error_codes/error_codes/E0193.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0193.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0193.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0193.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,44 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+`where` clauses must use generic type parameters: it does not make sense to use\n+them otherwise. An example causing this error:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+#[derive(Copy,Clone)]\n+struct Wrapper<T> {\n+    Wrapped: T\n+}\n+\n+impl Foo for Wrapper<u32> where Wrapper<u32>: Clone {\n+    fn bar(&self) { }\n+}\n+```\n+\n+This use of a `where` clause is strange - a more common usage would look\n+something like the following:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+#[derive(Copy,Clone)]\n+struct Wrapper<T> {\n+    Wrapped: T\n+}\n+impl <T> Foo for Wrapper<T> where Wrapper<T>: Clone {\n+    fn bar(&self) { }\n+}\n+```\n+\n+Here, we're saying that the implementation exists on Wrapper only when the\n+wrapped type `T` implements `Clone`. The `where` clause is important because\n+some types will not implement `Clone`, and thus will not get this method.\n+\n+In our erroneous example, however, we're referencing a single concrete type.\n+Since we know for certain that `Wrapper<u32>` implements `Clone`, there's no\n+reason to also specify it in a `where` clause."}, {"sha": "3606521020a11f1f3e4c8b96aa30c2b2ca9adc55", "filename": "src/librustc_error_codes/error_codes/E0195.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0195.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+Your method's lifetime parameters do not match the trait declaration.\n+Erroneous code example:\n+\n+```compile_fail,E0195\n+trait Trait {\n+    fn bar<'a,'b:'a>(x: &'a str, y: &'b str);\n+}\n+\n+struct Foo;\n+\n+impl Trait for Foo {\n+    fn bar<'a,'b>(x: &'a str, y: &'b str) {\n+    // error: lifetime parameters or bounds on method `bar`\n+    // do not match the trait declaration\n+    }\n+}\n+```\n+\n+The lifetime constraint `'b` for bar() implementation does not match the\n+trait declaration. Ensure lifetime declarations match exactly in both trait\n+declaration and implementation. Example:\n+\n+```\n+trait Trait {\n+    fn t<'a,'b:'a>(x: &'a str, y: &'b str);\n+}\n+\n+struct Foo;\n+\n+impl Trait for Foo {\n+    fn t<'a,'b:'a>(x: &'a str, y: &'b str) { // ok!\n+    }\n+}\n+```"}, {"sha": "0d91157e572ccf3d51499c63b2f73f45162982e7", "filename": "src/librustc_error_codes/error_codes/E0197.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0197.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+Inherent implementations (one that do not implement a trait but provide\n+methods associated with a type) are always safe because they are not\n+implementing an unsafe trait. Removing the `unsafe` keyword from the inherent\n+implementation will resolve this error.\n+\n+```compile_fail,E0197\n+struct Foo;\n+\n+// this will cause this error\n+unsafe impl Foo { }\n+// converting it to this will fix it\n+impl Foo { }\n+```"}, {"sha": "6504d60dbd1d53d1abcb95433e9913f0941410a1", "filename": "src/librustc_error_codes/error_codes/E0198.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0198.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,27 @@\n+A negative implementation is one that excludes a type from implementing a\n+particular trait. Not being able to use a trait is always a safe operation,\n+so negative implementations are always safe and never need to be marked as\n+unsafe.\n+\n+```compile_fail\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+// unsafe is unnecessary\n+unsafe impl !Clone for Foo { }\n+```\n+\n+This will compile:\n+\n+```ignore (ignore auto_trait future compatibility warning)\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+auto trait Enterprise {}\n+\n+impl !Enterprise for Foo { }\n+```\n+\n+Please note that negative impls are only allowed for auto traits."}, {"sha": "d0c12dc6f17550e4cbbecf4302c27af57e2e2382", "filename": "src/librustc_error_codes/error_codes/E0199.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0199.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+Safe traits should not have unsafe implementations, therefore marking an\n+implementation for a safe trait unsafe will cause a compiler error. Removing\n+the unsafe marker on the trait noted in the error will resolve this problem.\n+\n+```compile_fail,E0199\n+struct Foo;\n+\n+trait Bar { }\n+\n+// this won't compile because Bar is safe\n+unsafe impl Bar for Foo { }\n+// this will compile\n+impl Bar for Foo { }\n+```"}, {"sha": "865e91430ac44e7462ce9430df04c3c043ca9217", "filename": "src/librustc_error_codes/error_codes/E0200.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0200.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+Unsafe traits must have unsafe implementations. This error occurs when an\n+implementation for an unsafe trait isn't marked as unsafe. This may be resolved\n+by marking the unsafe implementation as unsafe.\n+\n+```compile_fail,E0200\n+struct Foo;\n+\n+unsafe trait Bar { }\n+\n+// this won't compile because Bar is unsafe and impl isn't unsafe\n+impl Bar for Foo { }\n+// this will compile\n+unsafe impl Bar for Foo { }\n+```"}, {"sha": "bdbf02f0033ab9dc111aaaf0d441a52265999908", "filename": "src/librustc_error_codes/error_codes/E0201.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0201.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0201.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0201.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,45 @@\n+It is an error to define two associated items (like methods, associated types,\n+associated functions, etc.) with the same identifier.\n+\n+For example:\n+\n+```compile_fail,E0201\n+struct Foo(u8);\n+\n+impl Foo {\n+    fn bar(&self) -> bool { self.0 > 5 }\n+    fn bar() {} // error: duplicate associated function\n+}\n+\n+trait Baz {\n+    type Quux;\n+    fn baz(&self) -> bool;\n+}\n+\n+impl Baz for Foo {\n+    type Quux = u32;\n+\n+    fn baz(&self) -> bool { true }\n+\n+    // error: duplicate method\n+    fn baz(&self) -> bool { self.0 > 5 }\n+\n+    // error: duplicate associated type\n+    type Quux = u32;\n+}\n+```\n+\n+Note, however, that items with the same name are allowed for inherent `impl`\n+blocks that don't overlap:\n+\n+```\n+struct Foo<T>(T);\n+\n+impl Foo<u8> {\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+\n+impl Foo<bool> {\n+    fn bar(&self) -> bool { self.0 }\n+}\n+```"}, {"sha": "b20d338c5fd99a2a64ae5c7d33c60a8a0d514439", "filename": "src/librustc_error_codes/error_codes/E0202.md", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0202.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,5 @@\n+Inherent associated types were part of [RFC 195] but are not yet implemented.\n+See [the tracking issue][iss8995] for the status of this implementation.\n+\n+[RFC 195]: https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md\n+[iss8995]: https://github.com/rust-lang/rust/issues/8995"}, {"sha": "315690111359fde1b9a6859cc3f88a55f6fefb3e", "filename": "src/librustc_error_codes/error_codes/E0204.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0204.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0204.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0204.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,25 @@\n+An attempt to implement the `Copy` trait for a struct failed because one of the\n+fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n+mentioned field. Note that this may not be possible, as in the example of\n+\n+```compile_fail,E0204\n+struct Foo {\n+    foo : Vec<u32>,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```compile_fail,E0204\n+#[derive(Copy)]\n+struct Foo<'a> {\n+    ty: &'a mut bool,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is always `Copy`)."}, {"sha": "7916f53ad3b411b5ba4695b5c3a9cefe22015af2", "filename": "src/librustc_error_codes/error_codes/E0205.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0205.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0205.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0205.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An attempt to implement the `Copy` trait for an enum failed because one of the\n+variants does not implement `Copy`. To fix this, you must implement `Copy` for\n+the mentioned variant. Note that this may not be possible, as in the example of\n+\n+```compile_fail,E0204\n+enum Foo {\n+    Bar(Vec<u32>),\n+    Baz,\n+}\n+\n+impl Copy for Foo { }\n+```\n+\n+This fails because `Vec<T>` does not implement `Copy` for any `T`.\n+\n+Here's another example that will fail:\n+\n+```compile_fail,E0204\n+#[derive(Copy)]\n+enum Foo<'a> {\n+    Bar(&'a mut bool),\n+    Baz,\n+}\n+```\n+\n+This fails because `&mut T` is not `Copy`, even when `T` is `Copy` (this\n+differs from the behavior for `&T`, which is always `Copy`)."}, {"sha": "fc4c0e07a16bf5ce9a26647d29ff4959f4cc10b7", "filename": "src/librustc_error_codes/error_codes/E0206.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0206.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0206.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0206.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,12 @@\n+You can only implement `Copy` for a struct or enum. Both of the following\n+examples will fail, because neither `[u8; 256]` nor `&'static mut Bar`\n+(mutable reference to `Bar`) is a struct or enum:\n+\n+```compile_fail,E0206\n+type Foo = [u8; 256];\n+impl Copy for Foo { } // error\n+\n+#[derive(Copy, Clone)]\n+struct Bar;\n+impl Copy for &'static mut Bar { } // error\n+```"}, {"sha": "67b2063504c07f550772dd8c815aacdbd4c058b7", "filename": "src/librustc_error_codes/error_codes/E0207.md", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0207.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,131 @@\n+Any type parameter or lifetime parameter of an `impl` must meet at least one of\n+the following criteria:\n+\n+ - it appears in the _implementing type_ of the impl, e.g. `impl<T> Foo<T>`\n+ - for a trait impl, it appears in the _implemented trait_, e.g.\n+   `impl<T> SomeTrait<T> for Foo`\n+ - it is bound as an associated type, e.g. `impl<T, U> SomeTrait for T\n+   where T: AnotherTrait<AssocType=U>`\n+\n+### Error example 1\n+\n+Suppose we have a struct `Foo` and we would like to define some methods for it.\n+The following definition leads to a compiler error:\n+\n+```compile_fail,E0207\n+struct Foo;\n+\n+impl<T: Default> Foo {\n+// error: the type parameter `T` is not constrained by the impl trait, self\n+// type, or predicates [E0207]\n+    fn get(&self) -> T {\n+        <T as Default>::default()\n+    }\n+}\n+```\n+\n+The problem is that the parameter `T` does not appear in the implementing type\n+(`Foo`) of the impl. In this case, we can fix the error by moving the type\n+parameter from the `impl` to the method `get`:\n+\n+\n+```\n+struct Foo;\n+\n+// Move the type parameter from the impl to the method\n+impl Foo {\n+    fn get<T: Default>(&self) -> T {\n+        <T as Default>::default()\n+    }\n+}\n+```\n+\n+### Error example 2\n+\n+As another example, suppose we have a `Maker` trait and want to establish a\n+type `FooMaker` that makes `Foo`s:\n+\n+```compile_fail,E0207\n+trait Maker {\n+    type Item;\n+    fn make(&mut self) -> Self::Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+struct FooMaker;\n+\n+impl<T: Default> Maker for FooMaker {\n+// error: the type parameter `T` is not constrained by the impl trait, self\n+// type, or predicates [E0207]\n+    type Item = Foo<T>;\n+\n+    fn make(&mut self) -> Foo<T> {\n+        Foo { foo: <T as Default>::default() }\n+    }\n+}\n+```\n+\n+This fails to compile because `T` does not appear in the trait or in the\n+implementing type.\n+\n+One way to work around this is to introduce a phantom type parameter into\n+`FooMaker`, like so:\n+\n+```\n+use std::marker::PhantomData;\n+\n+trait Maker {\n+    type Item;\n+    fn make(&mut self) -> Self::Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+// Add a type parameter to `FooMaker`\n+struct FooMaker<T> {\n+    phantom: PhantomData<T>,\n+}\n+\n+impl<T: Default> Maker for FooMaker<T> {\n+    type Item = Foo<T>;\n+\n+    fn make(&mut self) -> Foo<T> {\n+        Foo {\n+            foo: <T as Default>::default(),\n+        }\n+    }\n+}\n+```\n+\n+Another way is to do away with the associated type in `Maker` and use an input\n+type parameter instead:\n+\n+```\n+// Use a type parameter instead of an associated type here\n+trait Maker<Item> {\n+    fn make(&mut self) -> Item;\n+}\n+\n+struct Foo<T> {\n+    foo: T\n+}\n+\n+struct FooMaker;\n+\n+impl<T: Default> Maker<Foo<T>> for FooMaker {\n+    fn make(&mut self) -> Foo<T> {\n+        Foo { foo: <T as Default>::default() }\n+    }\n+}\n+```\n+\n+### Additional information\n+\n+For more information, please see [RFC 447].\n+\n+[RFC 447]: https://github.com/rust-lang/rfcs/blob/master/text/0447-no-unused-impl-parameters.md"}, {"sha": "dc2fd9b0ca049fe0c4554c9ac1a96761a47caab1", "filename": "src/librustc_error_codes/error_codes/E0210.md", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0210.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0210.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0210.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,82 @@\n+This error indicates a violation of one of Rust's orphan rules for trait\n+implementations. The rule concerns the use of type parameters in an\n+implementation of a foreign trait (a trait defined in another crate), and\n+states that type parameters must be \"covered\" by a local type.\n+\n+When implementing a foreign trait for a foreign type,\n+the trait must have one or more type parameters.\n+A type local to your crate must appear before any use of any type parameters.\n+\n+To understand what this means, it is perhaps easier to consider a few examples.\n+\n+If `ForeignTrait` is a trait defined in some external crate `foo`, then the\n+following trait `impl` is an error:\n+\n+```compile_fail,E0210\n+# #[cfg(for_demonstration_only)]\n+extern crate foo;\n+# #[cfg(for_demonstration_only)]\n+use foo::ForeignTrait;\n+# use std::panic::UnwindSafe as ForeignTrait;\n+\n+impl<T> ForeignTrait for T { } // error\n+# fn main() {}\n+```\n+\n+To work around this, it can be covered with a local type, `MyType`:\n+\n+```\n+# use std::panic::UnwindSafe as ForeignTrait;\n+struct MyType<T>(T);\n+impl<T> ForeignTrait for MyType<T> { } // Ok\n+```\n+\n+Please note that a type alias is not sufficient.\n+\n+For another example of an error, suppose there's another trait defined in `foo`\n+named `ForeignTrait2` that takes two type parameters. Then this `impl` results\n+in the same rule violation:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+struct MyType2;\n+impl<T> ForeignTrait2<T, MyType<T>> for MyType2 { } // error\n+```\n+\n+The reason for this is that there are two appearances of type parameter `T` in\n+the `impl` header, both as parameters for `ForeignTrait2`. The first appearance\n+is uncovered, and so runs afoul of the orphan rule.\n+\n+Consider one more example:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+impl<T> ForeignTrait2<MyType<T>, T> for MyType2 { } // Ok\n+```\n+\n+This only differs from the previous `impl` in that the parameters `T` and\n+`MyType<T>` for `ForeignTrait2` have been swapped. This example does *not*\n+violate the orphan rule; it is permitted.\n+\n+To see why that last example was allowed, you need to understand the general\n+rule. Unfortunately this rule is a bit tricky to state. Consider an `impl`:\n+\n+```ignore (only-for-syntax-highlight)\n+impl<P1, ..., Pm> ForeignTrait<T1, ..., Tn> for T0 { ... }\n+```\n+\n+where `P1, ..., Pm` are the type parameters of the `impl` and `T0, ..., Tn`\n+are types. One of the types `T0, ..., Tn` must be a local type (this is another\n+orphan rule, see the explanation for E0117).\n+\n+Both of the following must be true:\n+1. At least one of the types `T0..=Tn` must be a local type.\n+Let `Ti` be the first such type.\n+2. No uncovered type parameters `P1..=Pm` may appear in `T0..Ti`\n+(excluding `Ti`).\n+\n+For information on the design of the orphan rules,\n+see [RFC 2451] and [RFC 1023].\n+\n+For information on the design of the orphan rules, see [RFC 1023].\n+\n+[RFC 2451]: https://rust-lang.github.io/rfcs/2451-re-rebalancing-coherence.html\n+[RFC 1023]: https://github.com/rust-lang/rfcs/blob/master/text/1023-rebalancing-coherence.md"}, {"sha": "77289f019005ec0b7f4ea6e40116fc1b52ac4327", "filename": "src/librustc_error_codes/error_codes/E0211.md", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0211.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0211.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0211.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,79 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You used a function or type which doesn't fit the requirements for where it was\n+used. Erroneous code examples:\n+\n+```compile_fail\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T>(); // error: intrinsic has wrong type\n+}\n+\n+// or:\n+\n+fn main() -> i32 { 0 }\n+// error: main function expects type: `fn() {main}`: expected (), found i32\n+\n+// or:\n+\n+let x = 1u8;\n+match x {\n+    0u8..=3i8 => (),\n+    // error: mismatched types in range: expected u8, found i8\n+    _ => ()\n+}\n+\n+// or:\n+\n+use std::rc::Rc;\n+struct Foo;\n+\n+impl Foo {\n+    fn x(self: Rc<Foo>) {}\n+    // error: mismatched self type: expected `Foo`: expected struct\n+    //        `Foo`, found struct `alloc::rc::Rc`\n+}\n+```\n+\n+For the first code example, please check the function definition. Example:\n+\n+```\n+#![feature(intrinsics)]\n+\n+extern \"rust-intrinsic\" {\n+    fn size_of<T>() -> usize; // ok!\n+}\n+```\n+\n+The second case example is a bit particular: the main function must always\n+have this definition:\n+\n+```compile_fail\n+fn main();\n+```\n+\n+They never take parameters and never return types.\n+\n+For the third example, when you match, all patterns must have the same type\n+as the type you're matching on. Example:\n+\n+```\n+let x = 1u8;\n+\n+match x {\n+    0u8..=3u8 => (), // ok!\n+    _ => ()\n+}\n+```\n+\n+And finally, for the last example, only `Box<Self>`, `&Self`, `Self`,\n+or `&mut Self` work as explicit self parameters. Example:\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn x(self: Box<Foo>) {} // ok!\n+}\n+```"}, {"sha": "f78c1c0cd01379d55323b00c5793544751e8e67c", "filename": "src/librustc_error_codes/error_codes/E0214.md", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0214.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0214.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0214.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,12 @@\n+A generic type was described using parentheses rather than angle brackets.\n+For example:\n+\n+```compile_fail,E0214\n+fn main() {\n+    let v: Vec(&str) = vec![\"foo\"];\n+}\n+```\n+\n+This is not currently supported: `v` should be defined as `Vec<&str>`.\n+Parentheses are currently only used with generic types when defining parameters\n+for `Fn`-family traits."}, {"sha": "43e075b522b4e8bca46bea34b162b0ef83178a65", "filename": "src/librustc_error_codes/error_codes/E0220.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0220.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0220.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0220.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,41 @@\n+You used an associated type which isn't defined in the trait.\n+Erroneous code example:\n+\n+```compile_fail,E0220\n+trait T1 {\n+    type Bar;\n+}\n+\n+type Foo = T1<F=i32>; // error: associated type `F` not found for `T1`\n+\n+// or:\n+\n+trait T2 {\n+    type Bar;\n+\n+    // error: Baz is used but not declared\n+    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n+}\n+```\n+\n+Make sure that you have defined the associated type in the trait body.\n+Also, verify that you used the right trait or you didn't misspell the\n+associated type name. Example:\n+\n+```\n+trait T1 {\n+    type Bar;\n+}\n+\n+type Foo = T1<Bar=i32>; // ok!\n+\n+// or:\n+\n+trait T2 {\n+    type Bar;\n+    type Baz; // we declare `Baz` in our trait.\n+\n+    // and now we can use it here:\n+    fn return_bool(&self, _: &Self::Bar, _: &Self::Baz) -> bool;\n+}\n+```"}, {"sha": "53fabf490e2c30b8ae35fd612927d1e84606c967", "filename": "src/librustc_error_codes/error_codes/E0221.md", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0221.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0221.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0221.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,43 @@\n+An attempt was made to retrieve an associated type, but the type was ambiguous.\n+For example:\n+\n+```compile_fail,E0221\n+trait T1 {}\n+trait T2 {}\n+\n+trait Foo {\n+    type A: T1;\n+}\n+\n+trait Bar : Foo {\n+    type A: T2;\n+    fn do_something() {\n+        let _: Self::A;\n+    }\n+}\n+```\n+\n+In this example, `Foo` defines an associated type `A`. `Bar` inherits that type\n+from `Foo`, and defines another associated type of the same name. As a result,\n+when we attempt to use `Self::A`, it's ambiguous whether we mean the `A` defined\n+by `Foo` or the one defined by `Bar`.\n+\n+There are two options to work around this issue. The first is simply to rename\n+one of the types. Alternatively, one can specify the intended type using the\n+following syntax:\n+\n+```\n+trait T1 {}\n+trait T2 {}\n+\n+trait Foo {\n+    type A: T1;\n+}\n+\n+trait Bar : Foo {\n+    type A: T2;\n+    fn do_something() {\n+        let _: <Self as Bar>::A;\n+    }\n+}\n+```"}, {"sha": "9fe036042558760f36b40270340533f42528b775", "filename": "src/librustc_error_codes/error_codes/E0223.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0223.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0223.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0223.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+An attempt was made to retrieve an associated type, but the type was ambiguous.\n+For example:\n+\n+```compile_fail,E0223\n+trait MyTrait {type X; }\n+\n+fn main() {\n+    let foo: MyTrait::X;\n+}\n+```\n+\n+The problem here is that we're attempting to take the type of X from MyTrait.\n+Unfortunately, the type of X is not defined, because it's only made concrete in\n+implementations of the trait. A working version of this code might look like:\n+\n+```\n+trait MyTrait {type X; }\n+struct MyStruct;\n+\n+impl MyTrait for MyStruct {\n+    type X = u32;\n+}\n+\n+fn main() {\n+    let foo: <MyStruct as MyTrait>::X;\n+}\n+```\n+\n+This syntax specifies that we want the X type from MyTrait, as made concrete in\n+MyStruct. The reason that we cannot simply use `MyStruct::X` is that MyStruct\n+might implement two different traits with identically-named associated types.\n+This syntax allows disambiguation between the two."}, {"sha": "b9820dc68eeeb585382064d9d417ddfdc688984c", "filename": "src/librustc_error_codes/error_codes/E0225.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0225.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0225.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0225.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,18 @@\n+You attempted to use multiple types as bounds for a closure or trait object.\n+Rust does not currently support this. A simple example that causes this error:\n+\n+```compile_fail,E0225\n+fn main() {\n+    let _: Box<dyn std::io::Read + std::io::Write>;\n+}\n+```\n+\n+Auto traits such as Send and Sync are an exception to this rule:\n+It's possible to have bounds of one non-builtin trait, plus any number of\n+auto traits. For example, the following compiles correctly:\n+\n+```\n+fn main() {\n+    let _: Box<dyn std::io::Read + Send + Sync>;\n+}\n+```"}, {"sha": "a8bd341a62ba0df9787126301203178cf3091a19", "filename": "src/librustc_error_codes/error_codes/E0229.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0229.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0229.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0229.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,36 @@\n+An associated type binding was done outside of the type parameter declaration\n+and `where` clause. Erroneous code example:\n+\n+```compile_fail,E0229\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for isize {\n+    type A = usize;\n+    fn boo(&self) -> usize { 42 }\n+}\n+\n+fn baz<I>(x: &<I as Foo<A=Bar>>::A) {}\n+// error: associated type bindings are not allowed here\n+```\n+\n+To solve this error, please move the type bindings in the type parameter\n+declaration:\n+\n+```\n+# struct Bar;\n+# trait Foo { type A; }\n+fn baz<I: Foo<A=Bar>>(x: &<I as Foo>::A) {} // ok!\n+```\n+\n+Or in the `where` clause:\n+\n+```\n+# struct Bar;\n+# trait Foo { type A; }\n+fn baz<I>(x: &<I as Foo>::A) where I: Foo<A=Bar> {}\n+```"}, {"sha": "9dbcb8e010b1cd387afe78923c199bcf4d361e47", "filename": "src/librustc_error_codes/error_codes/E0230.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0230.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(rustc_attrs)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+There will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces contain an identifier which doesn't\n+match with any of the type parameters or the string `Self`. This might happen\n+if you misspelled a type parameter, or if you intended to use literal curly\n+braces. If it is the latter, escape the curly braces with a second curly brace\n+of the same type; e.g., a literal `{` is `{{`."}, {"sha": "4f80da54540b156515edb47fbcc6a9677250ff32", "filename": "src/librustc_error_codes/error_codes/E0231.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0231.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,27 @@\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(rustc_attrs)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+As you can see, you can specify type parameters in curly braces for\n+substitution with the actual types (using the regular format string syntax) in\n+a given situation. Furthermore, `{Self}` will substitute to the type (in this\n+case, `bool`) that we tried to use.\n+\n+This error appears when the curly braces do not contain an identifier. Please\n+add one of the same name as a type parameter. If you intended to use literal\n+braces, use `{{` and `}}` to escape them."}, {"sha": "07a031488d0917dd8e7b4c87b892bf1df3c40e59", "filename": "src/librustc_error_codes/error_codes/E0232.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0232.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+The `#[rustc_on_unimplemented]` attribute lets you specify a custom error\n+message for when a particular trait isn't implemented on a type placed in a\n+position that needs that trait. For example, when the following code is\n+compiled:\n+\n+```compile_fail\n+#![feature(rustc_attrs)]\n+\n+fn foo<T: Index<u8>>(x: T){}\n+\n+#[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n+trait Index<Idx> { /* ... */ }\n+\n+foo(true); // `bool` does not implement `Index<u8>`\n+```\n+\n+there will be an error about `bool` not implementing `Index<u8>`, followed by a\n+note saying \"the type `bool` cannot be indexed by `u8`\".\n+\n+For this to work, some note must be specified. An empty attribute will not do\n+anything, please remove the attribute or add some helpful note for users of the\n+trait."}, {"sha": "5d3d1828bf59bc4e77e2afb160766e5f556910eb", "filename": "src/librustc_error_codes/error_codes/E0243.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0243.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0243.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0243.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that not enough type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below is defined to be generic in `T`, but the\n+type parameter is missing in the definition of `Bar`:\n+\n+```compile_fail,E0107\n+struct Foo<T> { x: T }\n+\n+struct Bar { x: Foo }\n+```"}, {"sha": "5187b7b05d2c17e7b746a3729450325539d53bd6", "filename": "src/librustc_error_codes/error_codes/E0244.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0244.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0244.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0244.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that too many type parameters were found in a type or\n+trait.\n+\n+For example, the `Foo` struct below has no type parameters, but is supplied\n+with two in the definition of `Bar`:\n+\n+```compile_fail,E0107\n+struct Foo { x: bool }\n+\n+struct Bar<S, T> { x: Foo<S, T> }\n+```"}, {"sha": "4121dd27877a024aaab180aca047e78be8e4e8cc", "filename": "src/librustc_error_codes/error_codes/E0251.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0251.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0251.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0251.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```"}, {"sha": "e678944650f6039bf8d4337c0dab505f3c721d03", "filename": "src/librustc_error_codes/error_codes/E0252.md", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0252.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0252.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0252.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,54 @@\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0252\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use foo::baz as foo_baz;\n+use bar::baz; // ok!\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+use bar::baz;\n+\n+fn main() {\n+    let x = foo::baz; // ok!\n+}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```"}, {"sha": "aea51d4023821b1442bb14314bcde82dd29388ed", "filename": "src/librustc_error_codes/error_codes/E0253.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0253.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0253.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0253.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+Attempt was made to import an unimportable value. This can happen when trying\n+to import a method from a trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0253\n+mod foo {\n+    pub trait MyTrait {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::MyTrait::do_something;\n+// error: `do_something` is not directly importable\n+\n+fn main() {}\n+```\n+\n+It's invalid to directly import methods belonging to a trait or concrete type."}, {"sha": "44383ed6eab28e245c5adac1ef2aa972a5cf1416", "filename": "src/librustc_error_codes/error_codes/E0254.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0254.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0254.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0254.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,36 @@\n+Attempt was made to import an item whereas an extern crate with this name has\n+already been imported.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0254\n+extern crate core;\n+\n+mod foo {\n+    pub trait core {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::core;  // error: an extern crate named `core` has already\n+                //        been imported in this module\n+\n+fn main() {}\n+```\n+\n+To fix this issue, you have to rename at least one of the two imports.\n+Example:\n+\n+```\n+extern crate core as libcore; // ok!\n+\n+mod foo {\n+    pub trait core {\n+        fn do_something();\n+    }\n+}\n+\n+use foo::core;\n+\n+fn main() {}\n+```"}, {"sha": "83f5ec3dda4c39207b4debb3120e1c3ac6606dd2", "filename": "src/librustc_error_codes/error_codes/E0255.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0255.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0255.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0255.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,44 @@\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0255\n+use bar::foo; // error: an item named `foo` is already in scope\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+You can use aliases in order to fix this error. Example:\n+\n+```\n+use bar::foo as bar_foo; // ok!\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\n+Or you can reference the item with its parent:\n+\n+```\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {\n+    bar::foo(); // we get the item by referring to its parent\n+}\n+```"}, {"sha": "385376cdade91ce0575dfd8259185ce9dd2f0fa8", "filename": "src/librustc_error_codes/error_codes/E0256.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0256.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0256.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0256.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,18 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```compile_fail\n+use foo::Bar; // error\n+\n+type Bar = u32;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```"}, {"sha": "8d8f93db30ff87a1efd54d2d0d47c40ab0f366fd", "filename": "src/librustc_error_codes/error_codes/E0259.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0259.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0259.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0259.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,23 @@\n+The name chosen for an external crate conflicts with another external crate\n+that has been imported into the current module.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0259\n+extern crate core;\n+extern crate std as core;\n+\n+fn main() {}\n+```\n+\n+The solution is to choose a different name that doesn't conflict with any\n+external crate imported into the current module.\n+\n+Correct example:\n+\n+```\n+extern crate core;\n+extern crate std as other_name;\n+\n+fn main() {}\n+```"}, {"sha": "4a36735ae764c20b236b40832205f194dd6aca43", "filename": "src/librustc_error_codes/error_codes/E0260.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0260.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+The name for an item declaration conflicts with an external crate's name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0260\n+extern crate core;\n+\n+struct core;\n+\n+fn main() {}\n+```\n+\n+There are two possible solutions:\n+\n+Solution #1: Rename the item.\n+\n+```\n+extern crate core;\n+\n+struct xyz;\n+```\n+\n+Solution #2: Import the crate with a different name.\n+\n+```\n+extern crate core as xyz;\n+\n+struct abc;\n+```\n+\n+See the Declaration Statements section of the reference for more information\n+about what constitutes an Item declaration and what does not:\n+\n+https://doc.rust-lang.org/reference.html#statements"}, {"sha": "21cf8e70452e0aae29f90a73553b870c4e7ff70c", "filename": "src/librustc_error_codes/error_codes/E0261.md", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0261.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0261.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0261.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,53 @@\n+When using a lifetime like `'a` in a type, it must be declared before being\n+used.\n+\n+These two examples illustrate the problem:\n+\n+```compile_fail,E0261\n+// error, use of undeclared lifetime name `'a`\n+fn foo(x: &'a str) { }\n+\n+struct Foo {\n+    // error, use of undeclared lifetime name `'a`\n+    x: &'a str,\n+}\n+```\n+\n+These can be fixed by declaring lifetime parameters:\n+\n+```\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+fn foo<'a>(x: &'a str) {}\n+```\n+\n+Impl blocks declare lifetime parameters separately. You need to add lifetime\n+parameters to an impl block if you're implementing a type that has a lifetime\n+parameter of its own.\n+For example:\n+\n+```compile_fail,E0261\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+// error,  use of undeclared lifetime name `'a`\n+impl Foo<'a> {\n+    fn foo<'a>(x: &'a str) {}\n+}\n+```\n+\n+This is fixed by declaring the impl block like this:\n+\n+```\n+struct Foo<'a> {\n+    x: &'a str,\n+}\n+\n+// correct\n+impl<'a> Foo<'a> {\n+    fn foo(x: &'a str) {}\n+}\n+```"}, {"sha": "2dca6b1bb07814e53a3744f5dce5f5fb3d04796f", "filename": "src/librustc_error_codes/error_codes/E0262.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0262.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0262.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0262.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,8 @@\n+Declaring certain lifetime names in parameters is disallowed. For example,\n+because the `'static` lifetime is a special built-in lifetime name denoting\n+the lifetime of the entire program, this is an error:\n+\n+```compile_fail,E0262\n+// error, invalid lifetime parameter name `'static`\n+fn foo<'static>(x: &'static str) { }\n+```"}, {"sha": "bb4da43b3f58bd5e212dfbbe0b58aeb2c6230d0a", "filename": "src/librustc_error_codes/error_codes/E0263.md", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0263.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0263.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0263.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,7 @@\n+A lifetime name cannot be declared more than once in the same scope. For\n+example:\n+\n+```compile_fail,E0263\n+// error, lifetime name `'a` declared twice in the same scope\n+fn foo<'a, 'b, 'a>(x: &'a str, y: &'b str) { }\n+```"}, {"sha": "e1e7516cec2c79ef9d5d51bbfeaba61de9179861", "filename": "src/librustc_error_codes/error_codes/E0264.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0264.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+An unknown external lang item was used. Erroneous code example:\n+\n+```compile_fail,E0264\n+#![feature(lang_items)]\n+\n+extern \"C\" {\n+    #[lang = \"cake\"] // error: unknown external lang item: `cake`\n+    fn cake();\n+}\n+```\n+\n+A list of available external lang items is available in\n+`src/librustc/middle/weak_lang_items.rs`. Example:\n+\n+```\n+#![feature(lang_items)]\n+\n+extern \"C\" {\n+    #[lang = \"panic_impl\"] // ok!\n+    fn cake();\n+}\n+```"}, {"sha": "066ebee0ffb74162b82fd6e1c7e95e8d31aba0cc", "filename": "src/librustc_error_codes/error_codes/E0267.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0267.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0267.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0267.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+This error indicates the use of a loop keyword (`break` or `continue`) inside a\n+closure but outside of any loop. Erroneous code example:\n+\n+```compile_fail,E0267\n+let w = || { break; }; // error: `break` inside of a closure\n+```\n+\n+`break` and `continue` keywords can be used as normal inside closures as long as\n+they are also contained within a loop. To halt the execution of a closure you\n+should instead use a return statement. Example:\n+\n+```\n+let w = || {\n+    for _ in 0..10 {\n+        break;\n+    }\n+};\n+\n+w();\n+```"}, {"sha": "7f3ac1186018ad61453e84541c4a8e891b53053d", "filename": "src/librustc_error_codes/error_codes/E0268.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0268.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0268.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0268.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+This error indicates the use of a loop keyword (`break` or `continue`) outside\n+of a loop. Without a loop to break out of or continue in, no sensible action can\n+be taken. Erroneous code example:\n+\n+```compile_fail,E0268\n+fn some_func() {\n+    break; // error: `break` outside of a loop\n+}\n+```\n+\n+Please verify that you are using `break` and `continue` only in loops. Example:\n+\n+```\n+fn some_func() {\n+    for _ in 0..10 {\n+        break; // ok!\n+    }\n+}\n+```"}, {"sha": "4078598b394151194a668d306bdf7b9c4eecf3ec", "filename": "src/librustc_error_codes/error_codes/E0271.md", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0271.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,80 @@\n+This is because of a type mismatch between the associated type of some\n+trait (e.g., `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n+and another type `U` that is required to be equal to `T::Bar`, but is not.\n+Examples follow.\n+\n+Here is a basic example:\n+\n+```compile_fail,E0271\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+\n+foo(3_i8);\n+```\n+\n+Here is that same example again, with some explanatory comments:\n+\n+```compile_fail,E0271\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType=u32> {\n+//                    ~~~~~~~~ ~~~~~~~~~~~~~~~~~~\n+//                        |            |\n+//         This says `foo` can         |\n+//           only be used with         |\n+//              some type that         |\n+//         implements `Trait`.         |\n+//                                     |\n+//                             This says not only must\n+//                             `T` be an impl of `Trait`\n+//                             but also that the impl\n+//                             must assign the type `u32`\n+//                             to the associated type.\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+//~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+//      |                             |\n+// `i8` does have                     |\n+// implementation                     |\n+// of `Trait`...                      |\n+//                     ... but it is an implementation\n+//                     that assigns `&'static str` to\n+//                     the associated type.\n+\n+foo(3_i8);\n+// Here, we invoke `foo` with an `i8`, which does not satisfy\n+// the constraint `<i8 as Trait>::AssociatedType=u32`, and\n+// therefore the type-checker complains with this error code.\n+```\n+\n+To avoid those issues, you have to make the types match correctly.\n+So we can fix the previous examples like this:\n+\n+```\n+// Basic Example:\n+trait Trait { type AssociatedType; }\n+\n+fn foo<T>(t: T) where T: Trait<AssociatedType = &'static str> {\n+    println!(\"in foo\");\n+}\n+\n+impl Trait for i8 { type AssociatedType = &'static str; }\n+\n+foo(3_i8);\n+\n+// For-Loop Example:\n+let vs = vec![1, 2, 3, 4];\n+for v in &vs {\n+    match v {\n+        &1 => {}\n+        _ => {}\n+    }\n+}\n+```"}, {"sha": "836a9a95fa17b4470217659f0d6b962c5d4b3c63", "filename": "src/librustc_error_codes/error_codes/E0275.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0275.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+This error occurs when there was a recursive trait requirement that overflowed\n+before it could be evaluated. Often this means that there is unbounded\n+recursion in resolving some type bounds.\n+\n+For example, in the following code:\n+\n+```compile_fail,E0275\n+trait Foo {}\n+\n+struct Bar<T>(T);\n+\n+impl<T> Foo for T where Bar<T>: Foo {}\n+```\n+\n+To determine if a `T` is `Foo`, we need to check if `Bar<T>` is `Foo`. However,\n+to do this check, we need to determine that `Bar<Bar<T>>` is `Foo`. To\n+determine this, we check if `Bar<Bar<Bar<T>>>` is `Foo`, and so on. This is\n+clearly a recursive requirement that can't be resolved directly.\n+\n+Consider changing your trait bounds so that they're less self-referential."}, {"sha": "0e3a613bf9c024e6ba725a5c02de7981fd0a577a", "filename": "src/librustc_error_codes/error_codes/E0276.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0276.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+This error occurs when a bound in an implementation of a trait does not match\n+the bounds specified in the original trait. For example:\n+\n+```compile_fail,E0276\n+trait Foo {\n+    fn foo<T>(x: T);\n+}\n+\n+impl Foo for bool {\n+    fn foo<T>(x: T) where T: Copy {}\n+}\n+```\n+\n+Here, all types implementing `Foo` must have a method `foo<T>(x: T)` which can\n+take any type `T`. However, in the `impl` for `bool`, we have added an extra\n+bound that `T` is `Copy`, which isn't compatible with the original trait.\n+\n+Consider removing the bound from the method or adding the bound to the original\n+method definition in the trait."}, {"sha": "2034a5b988cbf711f25a2422a03eab0fbe89f6ab", "filename": "src/librustc_error_codes/error_codes/E0277.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0277.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,85 @@\n+You tried to use a type which doesn't implement some trait in a place which\n+expected that trait. Erroneous code example:\n+\n+```compile_fail,E0277\n+// here we declare the Foo trait with a bar method\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+// we now declare a function which takes an object implementing the Foo trait\n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar();\n+}\n+\n+fn main() {\n+    // we now call the method with the i32 type, which doesn't implement\n+    // the Foo trait\n+    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n+}\n+```\n+\n+In order to fix this error, verify that the type you're using does implement\n+the trait. Example:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+}\n+\n+fn some_func<T: Foo>(foo: T) {\n+    foo.bar(); // we can now use this method since i32 implements the\n+               // Foo trait\n+}\n+\n+// we implement the trait on the i32 type\n+impl Foo for i32 {\n+    fn bar(&self) {}\n+}\n+\n+fn main() {\n+    some_func(5i32); // ok!\n+}\n+```\n+\n+Or in a generic context, an erroneous code example would look like:\n+\n+```compile_fail,E0277\n+fn some_func<T>(foo: T) {\n+    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n+                           //        implemented for the type `T`\n+}\n+\n+fn main() {\n+    // We now call the method with the i32 type,\n+    // which *does* implement the Debug trait.\n+    some_func(5i32);\n+}\n+```\n+\n+Note that the error here is in the definition of the generic function: Although\n+we only call it with a parameter that does implement `Debug`, the compiler\n+still rejects the function: It must work with all possible input types. In\n+order to make this example compile, we need to restrict the generic type we're\n+accepting:\n+\n+```\n+use std::fmt;\n+\n+// Restrict the input type to types that implement Debug.\n+fn some_func<T: fmt::Debug>(foo: T) {\n+    println!(\"{:?}\", foo);\n+}\n+\n+fn main() {\n+    // Calling the method is still fine, as i32 implements Debug.\n+    some_func(5i32);\n+\n+    // This would fail to compile now:\n+    // struct WithoutDebug;\n+    // some_func(WithoutDebug);\n+}\n+```\n+\n+Rust only looks at the signature of the called function, as such it must\n+already specify all requirements that will be used for every type parameter."}, {"sha": "1a9796d2790ea262f013f46fdbe9ad86051d32c9", "filename": "src/librustc_error_codes/error_codes/E0281.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0281.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You tried to supply a type which doesn't implement some trait in a location\n+which expected that trait. This error typically occurs when working with\n+`Fn`-based types. Erroneous code example:\n+\n+```compile-fail\n+fn foo<F: Fn(usize)>(x: F) { }\n+\n+fn main() {\n+    // type mismatch: ... implements the trait `core::ops::Fn<(String,)>`,\n+    // but the trait `core::ops::Fn<(usize,)>` is required\n+    // [E0281]\n+    foo(|y: String| { });\n+}\n+```\n+\n+The issue in this case is that `foo` is defined as accepting a `Fn` with one\n+argument of type `String`, but the closure we attempted to pass to it requires\n+one arguments of type `usize`."}, {"sha": "54a9de0025a3d6f51a02e68b6a6dfdfb47594f46", "filename": "src/librustc_error_codes/error_codes/E0282.md", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0282.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,65 @@\n+This error indicates that type inference did not result in one unique possible\n+type, and extra information is required. In most cases this can be provided\n+by adding a type annotation. Sometimes you need to specify a generic type\n+parameter manually.\n+\n+A common example is the `collect` method on `Iterator`. It has a generic type\n+parameter with a `FromIterator` bound, which for a `char` iterator is\n+implemented by `Vec` and `String` among others. Consider the following snippet\n+that reverses the characters of a string:\n+\n+```compile_fail,E0282\n+let x = \"hello\".chars().rev().collect();\n+```\n+\n+In this case, the compiler cannot infer what the type of `x` should be:\n+`Vec<char>` and `String` are both suitable candidates. To specify which type to\n+use, you can use a type annotation on `x`:\n+\n+```\n+let x: Vec<char> = \"hello\".chars().rev().collect();\n+```\n+\n+It is not necessary to annotate the full type. Once the ambiguity is resolved,\n+the compiler can infer the rest:\n+\n+```\n+let x: Vec<_> = \"hello\".chars().rev().collect();\n+```\n+\n+Another way to provide the compiler with enough information, is to specify the\n+generic type parameter:\n+\n+```\n+let x = \"hello\".chars().rev().collect::<Vec<char>>();\n+```\n+\n+Again, you need not specify the full type if the compiler can infer it:\n+\n+```\n+let x = \"hello\".chars().rev().collect::<Vec<_>>();\n+```\n+\n+Apart from a method or function with a generic type parameter, this error can\n+occur when a type parameter of a struct or trait cannot be inferred. In that\n+case it is not always possible to use a type annotation, because all candidates\n+have the same return type. For instance:\n+\n+```compile_fail,E0282\n+struct Foo<T> {\n+    num: T,\n+}\n+\n+impl<T> Foo<T> {\n+    fn bar() -> i32 {\n+        0\n+    }\n+\n+    fn baz() {\n+        let number = Foo::bar();\n+    }\n+}\n+```\n+\n+This will fail because the compiler does not know which instance of `Foo` to\n+call `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error."}, {"sha": "075f8b2e3bb80975e5e1ca862b932aa661a86708", "filename": "src/librustc_error_codes/error_codes/E0283.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0283.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,49 @@\n+This error occurs when the compiler doesn't have enough information\n+to unambiguously choose an implementation.\n+\n+For example:\n+\n+```compile_fail,E0283\n+trait Generator {\n+    fn create() -> u32;\n+}\n+\n+struct Impl;\n+\n+impl Generator for Impl {\n+    fn create() -> u32 { 1 }\n+}\n+\n+struct AnotherImpl;\n+\n+impl Generator for AnotherImpl {\n+    fn create() -> u32 { 2 }\n+}\n+\n+fn main() {\n+    let cont: u32 = Generator::create();\n+    // error, impossible to choose one of Generator trait implementation\n+    // Should it be Impl or AnotherImpl, maybe something else?\n+}\n+```\n+\n+To resolve this error use the concrete type:\n+\n+```\n+trait Generator {\n+    fn create() -> u32;\n+}\n+\n+struct AnotherImpl;\n+\n+impl Generator for AnotherImpl {\n+    fn create() -> u32 { 2 }\n+}\n+\n+fn main() {\n+    let gen1 = AnotherImpl::create();\n+\n+    // if there are multiple methods with same name (different traits)\n+    let gen2 = <AnotherImpl as Generator>::create();\n+}\n+```"}, {"sha": "a1ffa2bda0050c267a917ef365e9dcaa8fc048e1", "filename": "src/librustc_error_codes/error_codes/E0284.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0284.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0284.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0284.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,42 @@\n+This error occurs when the compiler is unable to unambiguously infer the\n+return type of a function or method which is generic on return type, such\n+as the `collect` method for `Iterator`s.\n+\n+For example:\n+\n+```compile_fail,E0284\n+fn foo() -> Result<bool, ()> {\n+    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n+    let v: Vec<bool> = results.collect()?;\n+    // Do things with v...\n+    Ok(true)\n+}\n+```\n+\n+Here we have an iterator `results` over `Result<bool, ()>`.\n+Hence, `results.collect()` can return any type implementing\n+`FromIterator<Result<bool, ()>>`. On the other hand, the\n+`?` operator can accept any type implementing `Try`.\n+\n+The author of this code probably wants `collect()` to return a\n+`Result<Vec<bool>, ()>`, but the compiler can't be sure\n+that there isn't another type `T` implementing both `Try` and\n+`FromIterator<Result<bool, ()>>` in scope such that\n+`T::Ok == Vec<bool>`. Hence, this code is ambiguous and an error\n+is returned.\n+\n+To resolve this error, use a concrete type for the intermediate expression:\n+\n+```\n+fn foo() -> Result<bool, ()> {\n+    let results = [Ok(true), Ok(false), Err(())].iter().cloned();\n+    let v = {\n+        let temp: Result<Vec<bool>, ()> = results.collect();\n+        temp?\n+    };\n+    // Do things with v...\n+    Ok(true)\n+}\n+```\n+\n+Note that the type of `v` can now be inferred from the type of `temp`."}, {"sha": "66c31376d8b2851d234446221daeb2504ec183d1", "filename": "src/librustc_error_codes/error_codes/E0297.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0297.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0297.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0297.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,40 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Patterns used to bind names must be irrefutable. That is, they must guarantee\n+that a name will be extracted in all cases. Instead of pattern matching the\n+loop variable, consider using a `match` or `if let` inside the loop body. For\n+instance:\n+\n+```compile_fail,E0005\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+// This fails because `None` is not covered.\n+for Some(x) in xs {\n+    // ...\n+}\n+```\n+\n+Match inside the loop instead:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    match item {\n+        Some(x) => {},\n+        None => {},\n+    }\n+}\n+```\n+\n+Or use `if let`:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    if let Some(x) = item {\n+        // ...\n+    }\n+}\n+```"}, {"sha": "485e19fbb8d9c2a394a0d4176f8b9c94f55fb939", "filename": "src/librustc_error_codes/error_codes/E0301.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0301.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0301.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0301.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,17 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Mutable borrows are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if mutable\n+borrows were allowed:\n+\n+```compile_fail,E0596\n+match Some(()) {\n+    None => { },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```"}, {"sha": "e6ac9d590c88f920eb0d64ddf886229b5270215f", "filename": "src/librustc_error_codes/error_codes/E0302.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0302.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0302.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0302.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,15 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Assignments are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if assignments\n+were allowed:\n+\n+```compile_fail,E0594\n+match Some(()) {\n+    None => { },\n+    option if { option = None; false } => { },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```"}, {"sha": "20a6c078f4fa279bee7779da3e323f1068a0d32c", "filename": "src/librustc_error_codes/error_codes/E0303.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0303.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+Before:\n+\n+```compile_fail,E0303\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(s) => {},\n+    None => {},\n+}\n+```\n+\n+After:\n+\n+```\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(s);\n+        // ...\n+    },\n+    None => {},\n+}\n+```\n+\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n+\n+See also https://github.com/rust-lang/rust/issues/14587"}, {"sha": "c382f406e4b5b247f101461960f733300eb31223", "filename": "src/librustc_error_codes/error_codes/E0307.md", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0307.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,78 @@\n+This error indicates that the `self` parameter in a method has an invalid\n+\"reciever type\".\n+\n+Methods take a special first parameter, of which there are three variants:\n+`self`, `&self`, and `&mut self`. These are syntactic sugar for\n+`self: Self`, `self: &Self`, and `self: &mut Self` respectively.\n+\n+```\n+# struct Foo;\n+trait Trait {\n+    fn foo(&self);\n+//         ^^^^^ `self` here is a reference to the receiver object\n+}\n+\n+impl Trait for Foo {\n+    fn foo(&self) {}\n+//         ^^^^^ the receiver type is `&Foo`\n+}\n+```\n+\n+The type `Self` acts as an alias to the type of the current trait\n+implementer, or \"receiver type\". Besides the already mentioned `Self`,\n+`&Self` and `&mut Self` valid receiver types, the following are also valid:\n+`self: Box<Self>`, `self: Rc<Self>`, `self: Arc<Self>`, and `self: Pin<P>`\n+(where P is one of the previous types except `Self`). Note that `Self` can\n+also be the underlying implementing type, like `Foo` in the following\n+example:\n+\n+```\n+# struct Foo;\n+# trait Trait {\n+#     fn foo(&self);\n+# }\n+impl Trait for Foo {\n+    fn foo(self: &Foo) {}\n+}\n+```\n+\n+E0307 will be emitted by the compiler when using an invalid reciver type,\n+like in the following example:\n+\n+```compile_fail,E0307\n+# struct Foo;\n+# struct Bar;\n+# trait Trait {\n+#     fn foo(&self);\n+# }\n+impl Trait for Foo {\n+    fn foo(self: &Bar) {}\n+}\n+```\n+\n+The nightly feature [Arbintrary self types][AST] extends the accepted\n+set of receiver types to also include any type that can dereference to\n+`Self`:\n+\n+```\n+#![feature(arbitrary_self_types)]\n+\n+struct Foo;\n+struct Bar;\n+\n+// Because you can dereference `Bar` into `Foo`...\n+impl std::ops::Deref for Bar {\n+    type Target = Foo;\n+\n+    fn deref(&self) -> &Foo {\n+        &Foo\n+    }\n+}\n+\n+impl Foo {\n+    fn foo(self: Bar) {}\n+//         ^^^^^^^^^ ...it can be used as the receiver type\n+}\n+```\n+\n+[AST]: https://doc.rust-lang.org/unstable-book/language-features/arbitrary-self-types.html"}, {"sha": "a907ca272970e0a3f72ee29cd3f8810f7e36e3ee", "filename": "src/librustc_error_codes/error_codes/E0308.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,17 @@\n+This error occurs when the compiler was unable to infer the concrete type of a\n+variable. It can occur for several cases, the most common of which is a\n+mismatch in the expected type that the compiler inferred for a variable's\n+initializing expression, and the actual type explicitly assigned to the\n+variable.\n+\n+For example:\n+\n+```compile_fail,E0308\n+let x: i32 = \"I am not a number!\";\n+//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n+//      |             |\n+//      |    initializing expression;\n+//      |    compiler infers type `&str`\n+//      |\n+//    type `i32` assigned to variable `x`\n+```"}, {"sha": "73ce7407476f9d41edfcabb100689387510fbda3", "filename": "src/librustc_error_codes/error_codes/E0309.md", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0309.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,50 @@\n+The type definition contains some field whose type\n+requires an outlives annotation. Outlives annotations\n+(e.g., `T: 'a`) are used to guarantee that all the data in T is valid\n+for at least the lifetime `'a`. This scenario most commonly\n+arises when the type contains an associated type reference\n+like `<T as SomeTrait<'a>>::Output`, as shown in this example:\n+\n+```compile_fail,E0309\n+// This won't compile because the applicable impl of\n+// `SomeTrait` (below) requires that `T: 'a`, but the struct does\n+// not have a matching where-clause.\n+struct Foo<'a, T> {\n+    foo: <T as SomeTrait<'a>>::Output,\n+}\n+\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T\n+where\n+    T: 'a,\n+{\n+    type Output = u32;\n+}\n+```\n+\n+Here, the where clause `T: 'a` that appears on the impl is not known to be\n+satisfied on the struct. To make this example compile, you have to add\n+a where-clause like `T: 'a` to the struct definition:\n+\n+```\n+struct Foo<'a, T>\n+where\n+    T: 'a,\n+{\n+    foo: <T as SomeTrait<'a>>::Output\n+}\n+\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T\n+where\n+    T: 'a,\n+{\n+    type Output = u32;\n+}\n+```"}, {"sha": "be87ccb114ad0ed78f7926b524194830a8df4104", "filename": "src/librustc_error_codes/error_codes/E0310.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0310.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+Types in type definitions have lifetimes associated with them that represent\n+how long the data stored within them is guaranteed to be live. This lifetime\n+must be as long as the data needs to be alive, and missing the constraint that\n+denotes this will cause this error.\n+\n+```compile_fail,E0310\n+// This won't compile because T is not constrained to the static lifetime\n+// the reference needs\n+struct Foo<T> {\n+    foo: &'static T\n+}\n+```\n+\n+This will compile, because it has the constraint on the type parameter:\n+\n+```\n+struct Foo<T: 'static> {\n+    foo: &'static T\n+}\n+```"}, {"sha": "cb090d0138221e85b1b253d3faf06e6873f62f6c", "filename": "src/librustc_error_codes/error_codes/E0312.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0312.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0312.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0312.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,30 @@\n+Reference's lifetime of borrowed content doesn't match the expected lifetime.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0312\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'static str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = maybestr.as_ref().unwrap();\n+        s  // Invalid lifetime!\n+    }\n+}\n+```\n+\n+To fix this error, either lessen the expected lifetime or find a way to not have\n+to use this reference outside of its current scope (by running the code directly\n+in the same block for example?):\n+\n+```\n+// In this case, we can fix the issue by switching from \"static\" lifetime to 'a\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = maybestr.as_ref().unwrap();\n+        s  // Ok!\n+    }\n+}\n+```"}, {"sha": "e31a2b56be37193a1832252a3bd82d59bb6cebd1", "filename": "src/librustc_error_codes/error_codes/E0317.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+This error occurs when an `if` expression without an `else` block is used in a\n+context where a type other than `()` is expected, for example a `let`\n+expression:\n+\n+```compile_fail,E0317\n+fn main() {\n+    let x = 5;\n+    let a = if x == 5 { 1 };\n+}\n+```\n+\n+An `if` expression without an `else` block has the type `()`, so this is a type\n+error. To resolve it, add an `else` block having the same type as the `if`\n+block."}, {"sha": "49cec94430bca8c229bd4c234f7e8c50a4bdfbed", "filename": "src/librustc_error_codes/error_codes/E0321.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0321.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+A cross-crate opt-out trait was implemented on something which wasn't a struct\n+or enum type. Erroneous code example:\n+\n+```compile_fail,E0321\n+#![feature(optin_builtin_traits)]\n+\n+struct Foo;\n+\n+impl !Sync for Foo {}\n+\n+unsafe impl Send for &'static Foo {}\n+// error: cross-crate traits with a default impl, like `core::marker::Send`,\n+//        can only be implemented for a struct/enum type, not\n+//        `&'static Foo`\n+```\n+\n+Only structs and enums are permitted to impl Send, Sync, and other opt-out\n+trait, and the struct or enum must be local to the current crate. So, for\n+example, `unsafe impl Send for Rc<Foo>` is not allowed."}, {"sha": "d2ee426763e7b1b60f7cb6a23b0d1b02aecf94a3", "filename": "src/librustc_error_codes/error_codes/E0322.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0322.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,4 @@\n+The `Sized` trait is a special trait built-in to the compiler for types with a\n+constant size known at compile-time. This trait is automatically implemented\n+for types as needed by the compiler, and it is currently disallowed to\n+explicitly implement it for a type."}, {"sha": "6d34c35f9cbb652caf4e9579c713d22ad8293148", "filename": "src/librustc_error_codes/error_codes/E0323.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0323.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,45 @@\n+An associated const was implemented when another trait item was expected.\n+Erroneous code example:\n+\n+```compile_fail,E0323\n+trait Foo {\n+    type N;\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    const N : u32 = 0;\n+    // error: item `N` is an associated const, which doesn't match its\n+    //        trait `<Bar as Foo>`\n+}\n+```\n+\n+Please verify that the associated const wasn't misspelled and the correct trait\n+was implemented. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    type N;\n+}\n+\n+impl Foo for Bar {\n+    type N = u32; // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+}\n+\n+impl Foo for Bar {\n+    const N : u32 = 0; // ok!\n+}\n+```"}, {"sha": "b8c9e596990c1e0907b7a09b7a15ce80841bce1d", "filename": "src/librustc_error_codes/error_codes/E0324.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0324.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,37 @@\n+A method was implemented when another trait item was expected. Erroneous\n+code example:\n+\n+```compile_fail,E0324\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+\n+    fn M();\n+}\n+\n+impl Foo for Bar {\n+    fn N() {}\n+    // error: item `N` is an associated method, which doesn't match its\n+    //        trait `<Bar as Foo>`\n+}\n+```\n+\n+To fix this error, please verify that the method name wasn't misspelled and\n+verify that you are indeed implementing the correct trait items. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+\n+    fn M();\n+}\n+\n+impl Foo for Bar {\n+    const N : u32 = 0;\n+\n+    fn M() {} // ok!\n+}\n+```"}, {"sha": "f685b92cbf0644ce833bb2e80b8130da1c86e4bb", "filename": "src/librustc_error_codes/error_codes/E0325.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0325.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,45 @@\n+An associated type was implemented when another trait item was expected.\n+Erroneous code example:\n+\n+```compile_fail,E0325\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+}\n+\n+impl Foo for Bar {\n+    type N = u32;\n+    // error: item `N` is an associated type, which doesn't match its\n+    //        trait `<Bar as Foo>`\n+}\n+```\n+\n+Please verify that the associated type name wasn't misspelled and your\n+implementation corresponds to the trait definition. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    type N;\n+}\n+\n+impl Foo for Bar {\n+    type N = u32; // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    const N : u32;\n+}\n+\n+impl Foo for Bar {\n+    const N : u32 = 0; // ok!\n+}\n+```"}, {"sha": "0702d00c2de55119cb272b822f3f8d9116f206f2", "filename": "src/librustc_error_codes/error_codes/E0326.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0326.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+The types of any associated constants in a trait implementation must match the\n+types in the trait definition. This error indicates that there was a mismatch.\n+\n+Here's an example of this error:\n+\n+```compile_fail,E0326\n+trait Foo {\n+    const BAR: bool;\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    const BAR: u32 = 5; // error, expected bool, found u32\n+}\n+```"}, {"sha": "83909235455655ff2ff1e6499043ebaee8212a65", "filename": "src/librustc_error_codes/error_codes/E0328.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0328.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0328.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0328.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+The Unsize trait should not be implemented directly. All implementations of\n+Unsize are provided automatically by the compiler.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0328\n+#![feature(unsize)]\n+\n+use std::marker::Unsize;\n+\n+pub struct MyType;\n+\n+impl<T> Unsize<T> for MyType {}\n+```\n+\n+If you are defining your own smart pointer type and would like to enable\n+conversion from a sized to an unsized type with the\n+[DST coercion system][RFC 982], use [`CoerceUnsized`] instead.\n+\n+```\n+#![feature(coerce_unsized)]\n+\n+use std::ops::CoerceUnsized;\n+\n+pub struct MyType<T: ?Sized> {\n+    field_with_unsized_type: T,\n+}\n+\n+impl<T, U> CoerceUnsized<MyType<U>> for MyType<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+[RFC 982]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n+[`CoerceUnsized`]: https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"}, {"sha": "37d84a1a89bfe1881919a03f804980903477e1dc", "filename": "src/librustc_error_codes/error_codes/E0329.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0329.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0329.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0329.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,40 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An attempt was made to access an associated constant through either a generic\n+type parameter or `Self`. This is not supported yet. An example causing this\n+error is shown below:\n+\n+```\n+trait Foo {\n+    const BAR: f64;\n+}\n+\n+struct MyStruct;\n+\n+impl Foo for MyStruct {\n+    const BAR: f64 = 0f64;\n+}\n+\n+fn get_bar_bad<F: Foo>(t: F) -> f64 {\n+    F::BAR\n+}\n+```\n+\n+Currently, the value of `BAR` for a particular type can only be accessed\n+through a concrete type, as shown below:\n+\n+```\n+trait Foo {\n+    const BAR: f64;\n+}\n+\n+struct MyStruct;\n+\n+impl Foo for MyStruct {\n+    const BAR: f64 = 0f64;\n+}\n+\n+fn get_bar_good() -> f64 {\n+    <MyStruct as Foo>::BAR\n+}\n+```"}, {"sha": "0cca8f58b17cfa2cfd799de245356cc47974807c", "filename": "src/librustc_error_codes/error_codes/E0364.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0364.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+Private items cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a type or value that was not itself public.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+mod foo {\n+    const X: u32 = 1;\n+}\n+\n+pub use foo::X;\n+\n+fn main() {}\n+```\n+\n+The solution to this problem is to ensure that the items that you are\n+re-exporting are themselves marked with `pub`:\n+\n+```\n+mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo::X;\n+\n+fn main() {}\n+```\n+\n+See the 'Use Declarations' section of the reference for more information on\n+this topic:\n+\n+https://doc.rust-lang.org/reference.html#use-declarations"}, {"sha": "8f90d949e303799d81e5d9180836487d4f4c9c6a", "filename": "src/librustc_error_codes/error_codes/E0365.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0365.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+Private modules cannot be publicly re-exported. This error indicates that you\n+attempted to `pub use` a module that was not itself public.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0365\n+mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo as foo2;\n+\n+fn main() {}\n+```\n+\n+The solution to this problem is to ensure that the module that you are\n+re-exporting is itself marked with `pub`:\n+\n+```\n+pub mod foo {\n+    pub const X: u32 = 1;\n+}\n+\n+pub use foo as foo2;\n+\n+fn main() {}\n+```\n+\n+See the 'Use Declarations' section of the reference for more information\n+on this topic:\n+\n+https://doc.rust-lang.org/reference.html#use-declarations"}, {"sha": "e6f8e61893b7b1425e7efa34b3ad9fd61f27de9e", "filename": "src/librustc_error_codes/error_codes/E0366.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0366.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0366.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0366.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,30 @@\n+An attempt was made to implement `Drop` on a concrete specialization of a\n+generic type. An example is shown below:\n+\n+```compile_fail,E0366\n+struct Foo<T> {\n+    t: T\n+}\n+\n+impl Drop for Foo<u32> {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+This code is not legal: it is not possible to specialize `Drop` to a subset of\n+implementations of a generic type. One workaround for this is to wrap the\n+generic type, as shown below:\n+\n+```\n+struct Foo<T> {\n+    t: T\n+}\n+\n+struct Bar {\n+    t: Foo<u32>\n+}\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {}\n+}\n+```"}, {"sha": "7d661b2f0338863a32f3fbdb91ea39fa10ec4632", "filename": "src/librustc_error_codes/error_codes/E0367.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0367.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,35 @@\n+An attempt was made to implement `Drop` on a specialization of a generic type.\n+An example is shown below:\n+\n+```compile_fail,E0367\n+trait Foo{}\n+\n+struct MyStruct<T> {\n+    t: T\n+}\n+\n+impl<T: Foo> Drop for MyStruct<T> {\n+    fn drop(&mut self) {}\n+}\n+```\n+\n+This code is not legal: it is not possible to specialize `Drop` to a subset of\n+implementations of a generic type. In order for this code to work, `MyStruct`\n+must also require that `T` implements `Foo`. Alternatively, another option is\n+to wrap the generic type in another that specializes appropriately:\n+\n+```\n+trait Foo{}\n+\n+struct MyStruct<T> {\n+    t: T\n+}\n+\n+struct MyStructWrapper<T: Foo> {\n+    t: MyStruct<T>\n+}\n+\n+impl <T: Foo> Drop for MyStructWrapper<T> {\n+    fn drop(&mut self) {}\n+}\n+```"}, {"sha": "0bb283258c463b769b01b36bf7a1a69e8f3ab985", "filename": "src/librustc_error_codes/error_codes/E0368.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0368.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,47 @@\n+This error indicates that a binary assignment operator like `+=` or `^=` was\n+applied to a type that doesn't support it. For example:\n+\n+```compile_fail,E0368\n+let mut x = 12f32; // error: binary operation `<<` cannot be applied to\n+                   //        type `f32`\n+\n+x <<= 2;\n+```\n+\n+To fix this error, please check that this type implements this binary\n+operation. Example:\n+\n+```\n+let mut x = 12u32; // the `u32` type does implement the `ShlAssign` trait\n+\n+x <<= 2; // ok!\n+```\n+\n+It is also possible to overload most operators for your own type by\n+implementing the `[OP]Assign` traits from `std::ops`.\n+\n+Another problem you might be facing is this: suppose you've overloaded the `+`\n+operator for some type `Foo` by implementing the `std::ops::Add` trait for\n+`Foo`, but you find that using `+=` does not work, as in this example:\n+\n+```compile_fail,E0368\n+use std::ops::Add;\n+\n+struct Foo(u32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, rhs: Foo) -> Foo {\n+        Foo(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Foo = Foo(5);\n+    x += Foo(7); // error, `+= cannot be applied to the type `Foo`\n+}\n+```\n+\n+This is because `AddAssign` is not automatically implemented, so you need to\n+manually implement it for your type."}, {"sha": "08db342428c23e3b0dbd3c7d3995dd83202a1f2d", "filename": "src/librustc_error_codes/error_codes/E0369.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0369.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+A binary operation was attempted on a type which doesn't support it.\n+Erroneous code example:\n+\n+```compile_fail,E0369\n+let x = 12f32; // error: binary operation `<<` cannot be applied to\n+               //        type `f32`\n+\n+x << 2;\n+```\n+\n+To fix this error, please check that this type implements this binary\n+operation. Example:\n+\n+```\n+let x = 12u32; // the `u32` type does implement it:\n+               // https://doc.rust-lang.org/stable/std/ops/trait.Shl.html\n+\n+x << 2; // ok!\n+```\n+\n+It is also possible to overload most operators for your own type by\n+implementing traits from `std::ops`.\n+\n+String concatenation appends the string on the right to the string on the\n+left and may require reallocation. This requires ownership of the string\n+on the left. If something should be added to a string literal, move the\n+literal to the heap by allocating it with `to_owned()` like in\n+`\"Your text\".to_owned()`.\n+"}, {"sha": "a3d280fc6dccc3b2f207cee58b7eecebaace8f6e", "filename": "src/librustc_error_codes/error_codes/E0370.md", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0370.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,33 @@\n+The maximum value of an enum was reached, so it cannot be automatically\n+set in the next enum value. Erroneous code example:\n+\n+```compile_fail,E0370\n+#[repr(i64)]\n+enum Foo {\n+    X = 0x7fffffffffffffff,\n+    Y, // error: enum discriminant overflowed on value after\n+       //        9223372036854775807: i64; set explicitly via\n+       //        Y = -9223372036854775808 if that is desired outcome\n+}\n+```\n+\n+To fix this, please set manually the next enum value or put the enum variant\n+with the maximum value at the end of the enum. Examples:\n+\n+```\n+#[repr(i64)]\n+enum Foo {\n+    X = 0x7fffffffffffffff,\n+    Y = 0, // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+#[repr(i64)]\n+enum Foo {\n+    Y = 0, // ok!\n+    X = 0x7fffffffffffffff,\n+}\n+```"}, {"sha": "9363cddb1dd476b02a87e81a937c976b13d3def9", "filename": "src/librustc_error_codes/error_codes/E0371.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0371.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,17 @@\n+When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\n+definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n+`Trait1` for `Trait2`. This is because `Trait2` already implements `Trait1` by\n+definition, so it is not useful to do this.\n+\n+Example:\n+\n+```compile_fail,E0371\n+trait Foo { fn foo(&self) { } }\n+trait Bar: Foo { }\n+trait Baz: Bar { }\n+\n+impl Bar for Baz { } // error, `Baz` implements `Bar` by definition\n+impl Foo for Baz { } // error, `Baz` implements `Bar` which implements `Foo`\n+impl Baz for Baz { } // error, `Baz` (trivially) implements `Baz`\n+impl Baz for Bar { } // Note: This is OK\n+```"}, {"sha": "47e3a48f0317247a653dd707c1b4bc49b8134ff8", "filename": "src/librustc_error_codes/error_codes/E0373.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0373.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0373.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0373.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,48 @@\n+This error occurs when an attempt is made to use data captured by a closure,\n+when that data may no longer exist. It's most commonly seen when attempting to\n+return a closure:\n+\n+```compile_fail,E0373\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(|y| x + y)\n+}\n+```\n+\n+Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n+closed-over data by reference. This means that once `foo()` returns, `x` no\n+longer exists. An attempt to access `x` within the closure would thus be\n+unsafe.\n+\n+Another situation where this might be encountered is when spawning threads:\n+\n+```compile_fail,E0373\n+fn foo() {\n+    let x = 0u32;\n+    let y = 1u32;\n+\n+    let thr = std::thread::spawn(|| {\n+        x + y\n+    });\n+}\n+```\n+\n+Since our new thread runs in parallel, the stack frame containing `x` and `y`\n+may well have disappeared by the time we try to use them. Even if we call\n+`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n+stack frame won't disappear), we will not succeed: the compiler cannot prove\n+that this behaviour is safe, and so won't let us do it.\n+\n+The solution to this problem is usually to switch to using a `move` closure.\n+This approach moves (or copies, where possible) data into the closure, rather\n+than taking references to it. For example:\n+\n+```\n+fn foo() -> Box<Fn(u32) -> u32> {\n+    let x = 0u32;\n+    Box::new(move |y| x + y)\n+}\n+```\n+\n+Now that the closure has its own copy of the data, there's no need to worry\n+about safety."}, {"sha": "0e1a4bf8099a047b9c91dd933919c1a8a1955be0", "filename": "src/librustc_error_codes/error_codes/E0374.md", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0374.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0374.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0374.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,55 @@\n+A struct without a field containing an unsized type cannot implement\n+`CoerceUnsized`. An [unsized type][1] is any type that the compiler\n+doesn't know the length or alignment of at compile time. Any struct\n+containing an unsized type is also unsized.\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0374\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+}\n+\n+// error: Struct `Foo` has no unsized fields that need `CoerceUnsized`.\n+impl<T, U> CoerceUnsized<Foo<U>> for Foo<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+`CoerceUnsized` is used to coerce one struct containing an unsized type\n+into another struct containing a different unsized type. If the struct\n+doesn't have any fields of unsized types then you don't need explicit\n+coercion to get the types you want. To fix this you can either\n+not try to implement `CoerceUnsized` or you can add a field that is\n+unsized to the struct.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+// We don't need to impl `CoerceUnsized` here.\n+struct Foo {\n+    a: i32,\n+}\n+\n+// We add the unsized type field to the struct.\n+struct Bar<T: ?Sized> {\n+    a: i32,\n+    b: T,\n+}\n+\n+// The struct has an unsized field so we can implement\n+// `CoerceUnsized` for it.\n+impl<T, U> CoerceUnsized<Bar<U>> for Bar<T>\n+    where T: CoerceUnsized<U> {}\n+```\n+\n+Note that `CoerceUnsized` is mainly used by smart pointers like `Box`, `Rc`\n+and `Arc` to be able to mark that they can coerce unsized types that they\n+are pointing at."}, {"sha": "31fcd85cb079f6d60e23a523f933e52b83130557", "filename": "src/librustc_error_codes/error_codes/E0375.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0375.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0375.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0375.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,52 @@\n+A struct with more than one field containing an unsized type cannot implement\n+`CoerceUnsized`. This only occurs when you are trying to coerce one of the\n+types in your struct to another type in the struct. In this case we try to\n+impl `CoerceUnsized` from `T` to `U` which are both types that the struct\n+takes. An [unsized type][1] is any type that the compiler doesn't know the\n+length or alignment of at compile time. Any struct containing an unsized type\n+is also unsized.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0375\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized, U: ?Sized> {\n+    a: i32,\n+    b: T,\n+    c: U,\n+}\n+\n+// error: Struct `Foo` has more than one unsized field.\n+impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\n+```\n+\n+`CoerceUnsized` only allows for coercion from a structure with a single\n+unsized type field to another struct with a single unsized type field.\n+In fact Rust only allows for a struct to have one unsized type in a struct\n+and that unsized type must be the last field in the struct. So having two\n+unsized types in a single struct is not allowed by the compiler. To fix this\n+use only one field containing an unsized type in the struct and then use\n+multiple structs to manage each unsized type field you need.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: i32,\n+    b: T,\n+}\n+\n+impl <T, U> CoerceUnsized<Foo<U>> for Foo<T>\n+    where T: CoerceUnsized<U> {}\n+\n+fn coerce_foo<T: CoerceUnsized<U>, U>(t: T) -> Foo<U> {\n+    Foo { a: 12i32, b: t } // we use coercion to get the `Foo<U>` type we need\n+}\n+```\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait"}, {"sha": "b028aab45831f7612b12923ab28e0ffc9f834b8c", "filename": "src/librustc_error_codes/error_codes/E0376.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0376.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0376.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0376.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,45 @@\n+The type you are trying to impl `CoerceUnsized` for is not a struct.\n+`CoerceUnsized` can only be implemented for a struct. Unsized types are\n+already able to be coerced without an implementation of `CoerceUnsized`\n+whereas a struct containing an unsized type needs to know the unsized type\n+field it's containing is able to be coerced. An [unsized type][1]\n+is any type that the compiler doesn't know the length or alignment of at\n+compile time. Any struct containing an unsized type is also unsized.\n+\n+[1]: https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0376\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T: ?Sized> {\n+    a: T,\n+}\n+\n+// error: The type `U` is not a struct\n+impl<T, U> CoerceUnsized<U> for Foo<T> {}\n+```\n+\n+The `CoerceUnsized` trait takes a struct type. Make sure the type you are\n+providing to `CoerceUnsized` is a struct with only the last field containing an\n+unsized type.\n+\n+Example:\n+\n+```\n+#![feature(coerce_unsized)]\n+use std::ops::CoerceUnsized;\n+\n+struct Foo<T> {\n+    a: T,\n+}\n+\n+// The `Foo<U>` is a struct so `CoerceUnsized` can be implemented\n+impl<T, U> CoerceUnsized<Foo<U>> for Foo<T> where T: CoerceUnsized<U> {}\n+```\n+\n+Note that in Rust, structs can only contain an unsized type if the field\n+containing the unsized type is the last and only unsized type field in the\n+struct."}, {"sha": "311483c8900beaf3fb8652aa759af94e1db74d35", "filename": "src/librustc_error_codes/error_codes/E0378.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0378.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,57 @@\n+The `DispatchFromDyn` trait currently can only be implemented for\n+builtin pointer types and structs that are newtype wrappers around them\n+\u2014 that is, the struct must have only one field (except for`PhantomData`),\n+and that field must itself implement `DispatchFromDyn`.\n+\n+Examples:\n+\n+```\n+#![feature(dispatch_from_dyn, unsize)]\n+use std::{\n+    marker::Unsize,\n+    ops::DispatchFromDyn,\n+};\n+\n+struct Ptr<T: ?Sized>(*const T);\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T>\n+where\n+    T: Unsize<U>,\n+{}\n+```\n+\n+```\n+#![feature(dispatch_from_dyn)]\n+use std::{\n+    ops::DispatchFromDyn,\n+    marker::PhantomData,\n+};\n+\n+struct Wrapper<T> {\n+    ptr: T,\n+    _phantom: PhantomData<()>,\n+}\n+\n+impl<T, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```\n+\n+Example of illegal `DispatchFromDyn` implementation\n+(illegal because of extra field)\n+\n+```compile-fail,E0378\n+#![feature(dispatch_from_dyn)]\n+use std::ops::DispatchFromDyn;\n+\n+struct WrapperExtraField<T> {\n+    ptr: T,\n+    extra_stuff: i32,\n+}\n+\n+impl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```"}, {"sha": "3503da6ac2f7893958f957878da3d43f1d8e3f83", "filename": "src/librustc_error_codes/error_codes/E0379.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0379.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0379.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0379.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,4 @@\n+Trait methods cannot be declared `const` by design. For more information, see\n+[RFC 911].\n+\n+[RFC 911]: https://github.com/rust-lang/rfcs/pull/911"}, {"sha": "fe5de56933963183276a7b03aa5a2fdc95744e28", "filename": "src/librustc_error_codes/error_codes/E0380.md", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0380.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0380.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0380.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,4 @@\n+Auto traits cannot have methods or associated items.\n+For more information see the [opt-in builtin traits RFC][RFC 19].\n+\n+[RFC 19]: https://github.com/rust-lang/rfcs/blob/master/text/0019-opt-in-builtin-traits.md"}, {"sha": "976780099255f2de359812ac04eae381db2a7c7c", "filename": "src/librustc_error_codes/error_codes/E0381.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0381.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0381.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0381.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+It is not allowed to use or capture an uninitialized variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0381\n+fn main() {\n+    let x: i32;\n+    let y = x; // error, use of possibly-uninitialized variable\n+}\n+```\n+\n+To fix this, ensure that any declared variables are initialized before being\n+used. Example:\n+\n+```\n+fn main() {\n+    let x: i32 = 0;\n+    let y = x; // ok!\n+}\n+```"}, {"sha": "1592eac2ec5fb73f790e0caba00d3f7366414f20", "filename": "src/librustc_error_codes/error_codes/E0382.md", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0382.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,110 @@\n+This error occurs when an attempt is made to use a variable after its contents\n+have been moved elsewhere.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0382\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = MyStruct{ s: 5u32 };\n+    let y = x;\n+    x.s = 6;\n+    println!(\"{}\", x.s);\n+}\n+```\n+\n+Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n+of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n+of workarounds like `Rc`, a value cannot be owned by more than one variable.\n+\n+Sometimes we don't need to move the value. Using a reference, we can let another\n+function borrow the value without changing its ownership. In the example below,\n+we don't actually have to move our string to `calculate_length`, we can give it\n+a reference to it with `&` instead.\n+\n+```\n+fn main() {\n+    let s1 = String::from(\"hello\");\n+\n+    let len = calculate_length(&s1);\n+\n+    println!(\"The length of '{}' is {}.\", s1, len);\n+}\n+\n+fn calculate_length(s: &String) -> usize {\n+    s.len()\n+}\n+```\n+\n+A mutable reference can be created with `&mut`.\n+\n+Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n+can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n+affect the original variable.\n+\n+Most types in the standard library are marked `Clone`. The example below\n+demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n+copied to `s2`. Then the first character of `s1` is removed, without affecting\n+`s2`. \"any many\" is printed to the console.\n+\n+```\n+fn main() {\n+    let mut s1 = String::from(\"many\");\n+    let s2 = s1.clone();\n+    s1.remove(0);\n+    println!(\"{} {}\", s1, s2);\n+}\n+```\n+\n+If we control the definition of a type, we can implement `Clone` on it ourselves\n+with `#[derive(Clone)]`.\n+\n+Some types have no ownership semantics at all and are trivial to duplicate. An\n+example is `i32` and the other number types. We don't have to call `.clone()` to\n+clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n+cloning is more convenient in this case. We can mark our own types `Copy` if\n+all their members also are marked `Copy`.\n+\n+In the example below, we implement a `Point` type. Because it only stores two\n+integers, we opt-out of ownership semantics with `Copy`. Then we can\n+`let p2 = p1` without `p1` being moved.\n+\n+```\n+#[derive(Copy, Clone)]\n+struct Point { x: i32, y: i32 }\n+\n+fn main() {\n+    let mut p1 = Point{ x: -1, y: 2 };\n+    let p2 = p1;\n+    p1.x = 1;\n+    println!(\"p1: {}, {}\", p1.x, p1.y);\n+    println!(\"p2: {}, {}\", p2.x, p2.y);\n+}\n+```\n+\n+Alternatively, if we don't control the struct's definition, or mutable shared\n+ownership is truly required, we can use `Rc` and `RefCell`:\n+\n+```\n+use std::cell::RefCell;\n+use std::rc::Rc;\n+\n+struct MyStruct { s: u32 }\n+\n+fn main() {\n+    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n+    let y = x.clone();\n+    x.borrow_mut().s = 6;\n+    println!(\"{}\", x.borrow().s);\n+}\n+```\n+\n+With this approach, x and y share ownership of the data via the `Rc` (reference\n+count type). `RefCell` essentially performs runtime borrow checking: ensuring\n+that at most one writer or multiple readers can access the data at any one time.\n+\n+If you wish to learn more about ownership in Rust, start with the chapter in the\n+Book:\n+\n+https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html"}, {"sha": "fd2b0b08fb007239d8e805caacc28c593b561958", "filename": "src/librustc_error_codes/error_codes/E0383.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0383.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0383.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0383.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to partially reinitialize a\n+structure that is currently uninitialized.\n+\n+For example, this can happen when a drop has taken place:\n+\n+```compile_fail\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x); // `x` is now uninitialized\n+x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n+```\n+\n+This error can be fixed by fully reinitializing the structure in question:\n+\n+```\n+struct Foo {\n+    a: u32,\n+}\n+impl Drop for Foo {\n+    fn drop(&mut self) { /* ... */ }\n+}\n+\n+let mut x = Foo { a: 1 };\n+drop(x);\n+x = Foo { a: 2 };\n+```"}, {"sha": "7c7ee744a8c89c692e4ac148af44a356566e1b23", "filename": "src/librustc_error_codes/error_codes/E0384.md", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0384.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0384.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0384.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,20 @@\n+This error occurs when an attempt is made to reassign an immutable variable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0384\n+fn main() {\n+    let x = 3;\n+    x = 5; // error, reassignment of immutable variable\n+}\n+```\n+\n+By default, variables in Rust are immutable. To fix this error, add the keyword\n+`mut` after the keyword `let` when declaring the variable. For example:\n+\n+```\n+fn main() {\n+    let mut x = 3;\n+    x = 5;\n+}\n+```"}, {"sha": "de3b468b6e4acc3d74f40c08d67c4154af70a311", "filename": "src/librustc_error_codes/error_codes/E0386.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0386.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0386.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0386.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,31 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to mutate the target of a mutable\n+reference stored inside an immutable container.\n+\n+For example, this can happen when storing a `&mut` inside an immutable `Box`:\n+\n+```\n+let mut x: i64 = 1;\n+let y: Box<_> = Box::new(&mut x);\n+**y = 2; // error, cannot assign to data in an immutable container\n+```\n+\n+This error can be fixed by making the container mutable:\n+\n+```\n+let mut x: i64 = 1;\n+let mut y: Box<_> = Box::new(&mut x);\n+**y = 2;\n+```\n+\n+It can also be fixed by using a type with interior mutability, such as `Cell`\n+or `RefCell`:\n+\n+```\n+use std::cell::Cell;\n+\n+let x: i64 = 1;\n+let y: Box<Cell<_>> = Box::new(Cell::new(x));\n+y.set(2);\n+```"}, {"sha": "3a5facfdd25109c8b16e6a844cf8a2ce2ec8c3d4", "filename": "src/librustc_error_codes/error_codes/E0387.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0387.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,57 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to mutate or mutably reference data\n+that a closure has captured immutably.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+// Accepts a function or a closure that captures its environment immutably.\n+// Closures passed to foo will not be able to mutate their closed-over state.\n+fn foo<F: Fn()>(f: F) { }\n+\n+// Attempts to mutate closed-over data. Error message reads:\n+// `cannot assign to data in a captured outer variable...`\n+fn mutable() {\n+    let mut x = 0u32;\n+    foo(|| x = 2);\n+}\n+\n+// Attempts to take a mutable reference to closed-over data.  Error message\n+// reads: `cannot borrow data mutably in a captured outer variable...`\n+fn mut_addr() {\n+    let mut x = 0u32;\n+    foo(|| { let y = &mut x; });\n+}\n+```\n+\n+The problem here is that foo is defined as accepting a parameter of type `Fn`.\n+Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n+they capture their context immutably.\n+\n+If the definition of `foo` is under your control, the simplest solution is to\n+capture the data mutably. This can be done by defining `foo` to take FnMut\n+rather than Fn:\n+\n+```\n+fn foo<F: FnMut()>(f: F) { }\n+```\n+\n+Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n+interior mutability through a shared reference. Our example's `mutable`\n+function could be redefined as below:\n+\n+```\n+use std::cell::Cell;\n+\n+fn foo<F: Fn()>(f: F) { }\n+\n+fn mutable() {\n+    let x = Cell::new(0u32);\n+    foo(|| x.set(2));\n+}\n+```\n+\n+You can read more about cell types in the API documentation:\n+\n+https://doc.rust-lang.org/std/cell/"}, {"sha": "512fb42e6ecb5f8684d2a5a4d26382b4b5143b1d", "filename": "src/librustc_error_codes/error_codes/E0388.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0388.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0388.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0388.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1 @@\n+#### Note: this error code is no longer emitted by the compiler."}, {"sha": "9f064e44c820902ade4810905f20b1cfaa3c02f6", "filename": "src/librustc_error_codes/error_codes/E0389.md", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0389.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0389.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0389.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,63 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+An attempt was made to mutate data using a non-mutable reference. This\n+commonly occurs when attempting to assign to a non-mutable reference of a\n+mutable reference (`&(&mut T)`).\n+\n+Erroneous code example:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+    let fancy_ref = &(&mut fancy);\n+    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n+immutable reference to a value borrows it immutably. There can be multiple\n+references of type `&(&mut T)` that point to the same value, so they must be\n+immutable to prevent multiple mutable references to the same value.\n+\n+To fix this, either remove the outer reference:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut fancy;\n+    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```\n+\n+Or make the outer reference mutable:\n+\n+```\n+struct FancyNum {\n+    num: u8\n+}\n+\n+fn main() {\n+    let mut fancy = FancyNum{ num: 5 };\n+\n+    let fancy_ref = &mut (&mut fancy);\n+    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n+\n+    fancy_ref.num = 6; // No error!\n+\n+    println!(\"{}\", fancy_ref.num);\n+}\n+```"}, {"sha": "9d05740d6f5ab1be7a8720580c32c9f296c4f157", "filename": "src/librustc_error_codes/error_codes/E0390.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0390.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0390.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0390.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+You tried to implement methods for a primitive type. Erroneous code example:\n+\n+```compile_fail,E0390\n+struct Foo {\n+    x: i32\n+}\n+\n+impl *mut Foo {}\n+// error: only a single inherent implementation marked with\n+//        `#[lang = \"mut_ptr\"]` is allowed for the `*mut T` primitive\n+```\n+\n+This isn't allowed, but using a trait to implement a method is a good solution.\n+Example:\n+\n+```\n+struct Foo {\n+    x: i32\n+}\n+\n+trait Bar {\n+    fn bar();\n+}\n+\n+impl Bar for *mut Foo {\n+    fn bar() {} // ok!\n+}\n+```"}, {"sha": "5db9ad16d08f700f5e590c2d6938fd1dcbbc820b", "filename": "src/librustc_error_codes/error_codes/E0391.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0391.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0391.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0391.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+This error indicates that some types or traits depend on each other\n+and therefore cannot be constructed.\n+\n+The following example contains a circular dependency between two traits:\n+\n+```compile_fail,E0391\n+trait FirstTrait : SecondTrait {\n+\n+}\n+\n+trait SecondTrait : FirstTrait {\n+\n+}\n+```"}, {"sha": "1d93e904e37fc8b694d08f3e64d5085bc9d2c460", "filename": "src/librustc_error_codes/error_codes/E0392.md", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0392.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0392.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0392.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,57 @@\n+This error indicates that a type or lifetime parameter has been declared\n+but not actually used. Here is an example that demonstrates the error:\n+\n+```compile_fail,E0392\n+enum Foo<T> {\n+    Bar,\n+}\n+```\n+\n+If the type parameter was included by mistake, this error can be fixed\n+by simply removing the type parameter, as shown below:\n+\n+```\n+enum Foo {\n+    Bar,\n+}\n+```\n+\n+Alternatively, if the type parameter was intentionally inserted, it must be\n+used. A simple fix is shown below:\n+\n+```\n+enum Foo<T> {\n+    Bar(T),\n+}\n+```\n+\n+This error may also commonly be found when working with unsafe code. For\n+example, when using raw pointers one may wish to specify the lifetime for\n+which the pointed-at data is valid. An initial attempt (below) causes this\n+error:\n+\n+```compile_fail,E0392\n+struct Foo<'a, T> {\n+    x: *const T,\n+}\n+```\n+\n+We want to express the constraint that Foo should not outlive `'a`, because\n+the data pointed to by `T` is only valid for that lifetime. The problem is\n+that there are no actual uses of `'a`. It's possible to work around this\n+by adding a PhantomData type to the struct, using it to tell the compiler\n+to act as if the struct contained a borrowed reference `&'a T`:\n+\n+```\n+use std::marker::PhantomData;\n+\n+struct Foo<'a, T: 'a> {\n+    x: *const T,\n+    phantom: PhantomData<&'a T>\n+}\n+```\n+\n+[PhantomData] can also be used to express information about unused type\n+parameters.\n+\n+[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html"}, {"sha": "7cce99401cf0c13144681e0b2a40bb3cf9ecb409", "filename": "src/librustc_error_codes/error_codes/E0393.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0393.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+A type parameter which references `Self` in its default value was not specified.\n+Example of erroneous code:\n+\n+```compile_fail,E0393\n+trait A<T=Self> {}\n+\n+fn together_we_will_rule_the_galaxy(son: &A) {}\n+// error: the type parameter `T` must be explicitly specified in an\n+//        object type because its default value `Self` references the\n+//        type `Self`\n+```\n+\n+A trait object is defined over a single, fully-defined trait. With a regular\n+default parameter, this parameter can just be substituted in. However, if the\n+default parameter is `Self`, the trait changes for each concrete type; i.e.\n+`i32` will be expected to implement `A<i32>`, `bool` will be expected to\n+implement `A<bool>`, etc... These types will not share an implementation of a\n+fully-defined trait; instead they share implementations of a trait with\n+different parameters substituted in for each implementation. This is\n+irreconcilable with what we need to make a trait object work, and is thus\n+disallowed. Making the trait concrete by explicitly specifying the value of the\n+defaulted parameter will fix this issue. Fixed example:\n+\n+```\n+trait A<T=Self> {}\n+\n+fn together_we_will_rule_the_galaxy(son: &A<i32>) {} // Ok!\n+```"}, {"sha": "75d86979e3c877332c798b61c7acdeda8b38da08", "filename": "src/librustc_error_codes/error_codes/E0398.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0398.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0398.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0398.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,35 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+In Rust 1.3, the default object lifetime bounds are expected to change, as\n+described in [RFC 1156]. You are getting a warning because the compiler\n+thinks it is possible that this change will cause a compilation error in your\n+code. It is possible, though unlikely, that this is a false alarm.\n+\n+The heart of the change is that where `&'a Box<SomeTrait>` used to default to\n+`&'a Box<SomeTrait+'a>`, it now defaults to `&'a Box<SomeTrait+'static>` (here,\n+`SomeTrait` is the name of some trait type). Note that the only types which are\n+affected are references to boxes, like `&Box<SomeTrait>` or\n+`&[Box<SomeTrait>]`. More common types like `&SomeTrait` or `Box<SomeTrait>`\n+are unaffected.\n+\n+To silence this warning, edit your code to use an explicit bound. Most of the\n+time, this means that you will want to change the signature of a function that\n+you are calling. For example, if the error is reported on a call like `foo(x)`,\n+and `foo` is defined as follows:\n+\n+```\n+# trait SomeTrait {}\n+fn foo(arg: &Box<SomeTrait>) { /* ... */ }\n+```\n+\n+You might change it to:\n+\n+```\n+# trait SomeTrait {}\n+fn foo<'a>(arg: &'a Box<SomeTrait+'a>) { /* ... */ }\n+```\n+\n+This explicitly states that you expect the trait object `SomeTrait` to contain\n+references (with a maximum lifetime of `'a`).\n+\n+[RFC 1156]: https://github.com/rust-lang/rfcs/blob/master/text/1156-adjust-default-object-bounds.md"}, {"sha": "71482c3ca64c8cdf3410dcc562407d00851d1078", "filename": "src/librustc_error_codes/error_codes/E0399.md", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0399.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,35 @@\n+You implemented a trait, overriding one or more of its associated types but did\n+not reimplement its default methods.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0399\n+#![feature(associated_type_defaults)]\n+\n+pub trait Foo {\n+    type Assoc = u8;\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for i32 {\n+    // error - the following trait items need to be reimplemented as\n+    //         `Assoc` was overridden: `bar`\n+    type Assoc = i32;\n+}\n+```\n+\n+To fix this, add an implementation for each default method from the trait:\n+\n+```\n+#![feature(associated_type_defaults)]\n+\n+pub trait Foo {\n+    type Assoc = u8;\n+    fn bar(&self) {}\n+}\n+\n+impl Foo for i32 {\n+    type Assoc = i32;\n+    fn bar(&self) {} // ok!\n+}\n+```"}, {"sha": "4c93053d5f8b6210f0c40f6cf38a67a212f08b24", "filename": "src/librustc_error_codes/error_codes/E0401.md", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0401.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0401.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0401.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,106 @@\n+Inner items do not inherit type or const parameters from the functions\n+they are embedded in.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    fn bar(y: T) { // T is defined in the \"outer\" function\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+Nor will this:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    type MaybeT = Option<T>;\n+    // ...\n+}\n+```\n+\n+Or this:\n+\n+```compile_fail,E0401\n+fn foo<T>(x: T) {\n+    struct Foo {\n+        x: T,\n+    }\n+    // ...\n+}\n+```\n+\n+Items inside functions are basically just like top-level items, except\n+that they can only be used from the function they are in.\n+\n+There are a couple of solutions for this.\n+\n+If the item is a function, you may use a closure:\n+\n+```\n+fn foo<T>(x: T) {\n+    let bar = |y: T| { // explicit type annotation may not be necessary\n+        // ..\n+    };\n+    bar(x);\n+}\n+```\n+\n+For a generic item, you can copy over the parameters:\n+\n+```\n+fn foo<T>(x: T) {\n+    fn bar<T>(y: T) {\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+```\n+fn foo<T>(x: T) {\n+    type MaybeT<T> = Option<T>;\n+}\n+```\n+\n+Be sure to copy over any bounds as well:\n+\n+```\n+fn foo<T: Copy>(x: T) {\n+    fn bar<T: Copy>(y: T) {\n+        // ..\n+    }\n+    bar(x);\n+}\n+```\n+\n+```\n+fn foo<T: Copy>(x: T) {\n+    struct Foo<T: Copy> {\n+        x: T,\n+    }\n+}\n+```\n+\n+This may require additional type hints in the function body.\n+\n+In case the item is a function inside an `impl`, defining a private helper\n+function might be easier:\n+\n+```\n+# struct Foo<T>(T);\n+impl<T> Foo<T> {\n+    pub fn foo(&self, x: T) {\n+        self.bar(x);\n+    }\n+\n+    fn bar(&self, y: T) {\n+        // ..\n+    }\n+}\n+```\n+\n+For default impls in traits, the private helper solution won't work, however\n+closures or copying the parameters should still work."}, {"sha": "5f4a40ce92e675ab7b6b66a53f8b0150aacb7f20", "filename": "src/librustc_error_codes/error_codes/E0403.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0403.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0403.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0403.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,25 @@\n+Some type parameters have the same name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0403\n+fn f<T, T>(s: T, u: T) {} // error: the name `T` is already used for a generic\n+                          //        parameter in this item's generic parameters\n+```\n+\n+Please verify that none of the type parameters are misspelled, and rename any\n+clashing parameters. Example:\n+\n+```\n+fn f<T, Y>(s: T, u: Y) {} // ok!\n+```\n+\n+Type parameters in an associated item also cannot shadow parameters from the\n+containing item:\n+\n+```compile_fail,E0403\n+trait Foo<T> {\n+    fn do_something(&self) -> T;\n+    fn do_something_else<T: Clone>(&self, bar: T);\n+}\n+```"}, {"sha": "861a50bfd8c574c0dd29531640ec3e395a69d4b6", "filename": "src/librustc_error_codes/error_codes/E0404.md", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0404.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,44 @@\n+You tried to use something which is not a trait in a trait position, such as\n+a bound or `impl`.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+struct Bar;\n+\n+impl Foo for Bar {} // error: `Foo` is not a trait\n+```\n+\n+Another erroneous code example:\n+\n+```compile_fail,E0404\n+struct Foo;\n+\n+fn bar<T: Foo>(t: T) {} // error: `Foo` is not a trait\n+```\n+\n+Please verify that you didn't misspell the trait's name or otherwise use the\n+wrong identifier. Example:\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+struct Bar;\n+\n+impl Foo for Bar { // ok!\n+    // functions implementation\n+}\n+```\n+\n+or\n+\n+```\n+trait Foo {\n+    // some functions\n+}\n+\n+fn bar<T: Foo>(t: T) {} // ok!\n+```\n+"}, {"sha": "ff1e8c0be8803cadfe63ba525d7ffe0332a5c802", "filename": "src/librustc_error_codes/error_codes/E0405.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0405.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0405.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0405.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+The code refers to a trait that is not in scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0405\n+struct Foo;\n+\n+impl SomeTrait for Foo {} // error: trait `SomeTrait` is not in scope\n+```\n+\n+Please verify that the name of the trait wasn't misspelled and ensure that it\n+was imported. Example:\n+\n+```\n+# #[cfg(for_demonstration_only)]\n+// solution 1:\n+use some_file::SomeTrait;\n+\n+// solution 2:\n+trait SomeTrait {\n+    // some functions\n+}\n+\n+struct Foo;\n+\n+impl SomeTrait for Foo { // ok!\n+    // implements functions\n+}\n+```"}, {"sha": "fa26c77a1b0c4269852e26e7db544697cecf9bce", "filename": "src/librustc_error_codes/error_codes/E0407.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0407.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0407.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0407.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,52 @@\n+A definition of a method not in the implemented trait was given in a trait\n+implementation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0407\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // error: method `b` is not a member of trait `Foo`\n+}\n+```\n+\n+Please verify you didn't misspell the method name and you used the correct\n+trait. First example:\n+\n+```\n+trait Foo {\n+    fn a();\n+    fn b();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+    fn b() {} // ok!\n+}\n+```\n+\n+Second example:\n+\n+```\n+trait Foo {\n+    fn a();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn a() {}\n+}\n+\n+impl Bar {\n+    fn b() {}\n+}\n+```"}, {"sha": "3acdbb740a37980ebe53633bc7a5c329b02690ab", "filename": "src/librustc_error_codes/error_codes/E0408.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0408.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0408.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0408.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,41 @@\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0408\n+match x {\n+    Some(y) | None => { /* use y */ } // error: variable `y` from pattern #1 is\n+                                      //        not bound in pattern #2\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound to the contents of the `Some` and can be used within the\n+block corresponding to the match arm. However, in case `x` is `None`, we have\n+not specified what `y` is, and the block will use a nonexistent variable.\n+\n+To fix this error, either split into multiple match arms:\n+\n+```\n+let x = Some(1);\n+match x {\n+    Some(y) => { /* use y */ }\n+    None => { /* ... */ }\n+}\n+```\n+\n+or, bind the variable to a field of the same type in all sub-patterns of the\n+or pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, y) | (y, 0) => { /* use y */}\n+    _ => {}\n+}\n+```\n+\n+In this example, if `x` matches the pattern `(0, _)`, the second field is set\n+to `y`. If it matches `(_, 0)`, the first field is set to `y`; so in all\n+cases `y` is set to some value."}, {"sha": "53eb0fd0573ffcec8b25bfed23fb6b4b502eabfe", "filename": "src/librustc_error_codes/error_codes/E0409.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0409.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0409.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0409.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,38 @@\n+An \"or\" pattern was used where the variable bindings are not consistently bound\n+across patterns.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0409\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (y, 0) => { /* use y */} // error: variable `y` is bound with\n+                                          //        different mode in pattern #2\n+                                          //        than in pattern #1\n+    _ => ()\n+}\n+```\n+\n+Here, `y` is bound by-value in one case and by-reference in the other.\n+\n+To fix this error, just use the same mode in both cases.\n+Generally using `ref` or `ref mut` where not already used will fix this:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (0, ref y) | (ref y, 0) => { /* use y */}\n+    _ => ()\n+}\n+```\n+\n+Alternatively, split the pattern:\n+\n+```\n+let x = (0, 2);\n+match x {\n+    (y, 0) => { /* use y */ }\n+    (0, ref y) => { /* use y */}\n+    _ => ()\n+}\n+```"}, {"sha": "d82171533ae51c6bf1e3b88b9d7f423196fd81af", "filename": "src/librustc_error_codes/error_codes/E0411.md", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0411.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0411.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0411.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,56 @@\n+The `Self` keyword was used outside an impl, trait, or type definition.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0411\n+<Self>::foo; // error: use of `Self` outside of an impl, trait, or type\n+             // definition\n+```\n+\n+The `Self` keyword represents the current type, which explains why it can only\n+be used inside an impl, trait, or type definition. It gives access to the\n+associated items of a type:\n+\n+```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Baz : Foo {\n+    fn bar() -> Self::Bar; // like this\n+}\n+```\n+\n+However, be careful when two types have a common associated type:\n+\n+```compile_fail\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n+trait Baz : Foo + Foo2 {\n+    fn bar() -> Self::Bar;\n+    // error: ambiguous associated type `Bar` in bounds of `Self`\n+}\n+```\n+\n+This problem can be solved by specifying from which trait we want to use the\n+`Bar` type:\n+\n+```\n+trait Foo {\n+    type Bar;\n+}\n+\n+trait Foo2 {\n+    type Bar;\n+}\n+\n+trait Baz : Foo + Foo2 {\n+    fn bar() -> <Self as Foo>::Bar; // ok!\n+}\n+```"}, {"sha": "60a09610d86f6bb639d705032f2df9b72f888d99", "filename": "src/librustc_error_codes/error_codes/E0412.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0412.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0412.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0412.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,64 @@\n+The type name used is not in scope.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0412\n+impl Something {} // error: type name `Something` is not in scope\n+\n+// or:\n+\n+trait Foo {\n+    fn bar(N); // error: type name `N` is not in scope\n+}\n+\n+// or:\n+\n+fn foo(x: T) {} // type name `T` is not in scope\n+```\n+\n+To fix this error, please verify you didn't misspell the type name, you did\n+declare it or imported it into the scope. Examples:\n+\n+```\n+struct Something;\n+\n+impl Something {} // ok!\n+\n+// or:\n+\n+trait Foo {\n+    type N;\n+\n+    fn bar(_: Self::N); // ok!\n+}\n+\n+// or:\n+\n+fn foo<T>(x: T) {} // ok!\n+```\n+\n+Another case that causes this error is when a type is imported into a parent\n+module. To fix this, you can follow the suggestion and use File directly or\n+`use super::File;` which will import the types from the parent namespace. An\n+example that causes this error is below:\n+\n+```compile_fail,E0412\n+use std::fs::File;\n+\n+mod foo {\n+    fn some_function(f: File) {}\n+}\n+```\n+\n+```\n+use std::fs::File;\n+\n+mod foo {\n+    // either\n+    use super::File;\n+    // or\n+    // use std::fs::File;\n+    fn foo(f: File) {}\n+}\n+# fn main() {} // don't insert it for us; that'll break imports\n+```"}, {"sha": "97d733a7b2dd76869ca65b5a2aab9f67bf3acb33", "filename": "src/librustc_error_codes/error_codes/E0415.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0415.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0415.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0415.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+More than one function parameter have the same name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0415\n+fn foo(f: i32, f: i32) {} // error: identifier `f` is bound more than\n+                          //        once in this parameter list\n+```\n+\n+Please verify you didn't misspell parameters' name. Example:\n+\n+```\n+fn foo(f: i32, g: i32) {} // ok!\n+```"}, {"sha": "7bc316dafc5fb3061a37f2524da890e3c6b6a0ec", "filename": "src/librustc_error_codes/error_codes/E0416.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0416.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0416.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0416.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+An identifier is bound more than once in a pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0416\n+match (1, 2) {\n+    (x, x) => {} // error: identifier `x` is bound more than once in the\n+                 //        same pattern\n+}\n+```\n+\n+Please verify you didn't misspell identifiers' name. Example:\n+\n+```\n+match (1, 2) {\n+    (x, y) => {} // ok!\n+}\n+```\n+\n+Or maybe did you mean to unify? Consider using a guard:\n+\n+```\n+# let (A, B, C) = (1, 2, 3);\n+match (A, B, C) {\n+    (x, x2, see) if x == x2 => { /* A and B are equal, do one thing */ }\n+    (y, z, see) => { /* A and B unequal; do another thing */ }\n+}\n+```"}, {"sha": "a91ea6a9e22f607ca58e6314ab5a6ad54743260f", "filename": "src/librustc_error_codes/error_codes/E0422.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0422.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0422.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0422.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+You are trying to use an identifier that is either undefined or not a struct.\n+Erroneous code example:\n+\n+```compile_fail,E0422\n+fn main () {\n+    let x = Foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `Foo` is undefined, so it inherently isn't anything, and\n+definitely not a struct.\n+\n+```compile_fail\n+fn main () {\n+    let foo = 1;\n+    let x = foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `foo` is defined, but is not a struct, so Rust can't use it as\n+one."}, {"sha": "6a7c31f5e0d43095622831a26c18e24dcec4827d", "filename": "src/librustc_error_codes/error_codes/E0423.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0423.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0423.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0423.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,47 @@\n+An identifier was used like a function name or a value was expected and the\n+identifier exists but it belongs to a different namespace.\n+\n+For (an erroneous) example, here a `struct` variant name were used as a\n+function:\n+\n+```compile_fail,E0423\n+struct Foo { a: bool };\n+\n+let f = Foo();\n+// error: expected function, tuple struct or tuple variant, found `Foo`\n+// `Foo` is a struct name, but this expression uses it like a function name\n+```\n+\n+Please verify you didn't misspell the name of what you actually wanted to use\n+here. Example:\n+\n+```\n+fn Foo() -> u32 { 0 }\n+\n+let f = Foo(); // ok!\n+```\n+\n+It is common to forget the trailing `!` on macro invocations, which would also\n+yield this error:\n+\n+```compile_fail,E0423\n+println(\"\");\n+// error: expected function, tuple struct or tuple variant,\n+// found macro `println`\n+// did you mean `println!(...)`? (notice the trailing `!`)\n+```\n+\n+Another case where this error is emitted is when a value is expected, but\n+something else is found:\n+\n+```compile_fail,E0423\n+pub mod a {\n+    pub const I: i32 = 1;\n+}\n+\n+fn h1() -> i32 {\n+    a.I\n+    //~^ ERROR expected value, found module `a`\n+    // did you mean `a::I`?\n+}\n+```"}, {"sha": "a9f6f579b4275856925cc28c4af28fcca3d2d0d0", "filename": "src/librustc_error_codes/error_codes/E0424.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0424.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0424.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0424.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,40 @@\n+The `self` keyword was used inside of an associated function without a \"`self`\n+receiver\" parameter.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0424\n+struct Foo;\n+\n+impl Foo {\n+    // `bar` is a method, because it has a receiver parameter.\n+    fn bar(&self) {}\n+\n+    // `foo` is not a method, because it has no receiver parameter.\n+    fn foo() {\n+        self.bar(); // error: `self` value is a keyword only available in\n+                    //        methods with a `self` parameter\n+    }\n+}\n+```\n+\n+The `self` keyword can only be used inside methods, which are associated\n+functions (functions defined inside of a `trait` or `impl` block) that have a\n+`self` receiver as its first parameter, like `self`, `&self`, `&mut self` or\n+`self: &mut Pin<Self>` (this last one is an example of an [\"abitrary `self`\n+type\"](https://github.com/rust-lang/rust/issues/44874)).\n+\n+Check if the associated function's parameter list should have contained a `self`\n+receiver for it to be a method, and add it if so. Example:\n+\n+```\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(&self) {}\n+\n+    fn foo(self) { // `foo` is now a method.\n+        self.bar(); // ok!\n+    }\n+}\n+```"}, {"sha": "13e71b850657992df0d9b420f9cc31d946731d15", "filename": "src/librustc_error_codes/error_codes/E0425.md", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0425.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0425.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0425.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,60 @@\n+An unresolved name was used.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0425\n+something_that_doesnt_exist::foo;\n+// error: unresolved name `something_that_doesnt_exist::foo`\n+\n+// or:\n+\n+trait Foo {\n+    fn bar() {\n+        Self; // error: unresolved name `Self`\n+    }\n+}\n+\n+// or:\n+\n+let x = unknown_variable;  // error: unresolved name `unknown_variable`\n+```\n+\n+Please verify that the name wasn't misspelled and ensure that the\n+identifier being referred to is valid for the given situation. Example:\n+\n+```\n+enum something_that_does_exist {\n+    Foo,\n+}\n+```\n+\n+Or:\n+\n+```\n+mod something_that_does_exist {\n+    pub static foo : i32 = 0i32;\n+}\n+\n+something_that_does_exist::foo; // ok!\n+```\n+\n+Or:\n+\n+```\n+let unknown_variable = 12u32;\n+let x = unknown_variable; // ok!\n+```\n+\n+If the item is not defined in the current module, it must be imported using a\n+`use` statement, like so:\n+\n+```\n+# mod foo { pub fn bar() {} }\n+# fn main() {\n+use foo::bar;\n+bar();\n+# }\n+```\n+\n+If the item you are importing is not defined in some super-module of the\n+current module, then it must also be declared as public (e.g., `pub fn`)."}, {"sha": "15e7fb04738353ca95225555566ea5e1d9c5adc0", "filename": "src/librustc_error_codes/error_codes/E0426.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0426.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0426.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0426.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,17 @@\n+An undeclared label was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0426\n+loop {\n+    break 'a; // error: use of undeclared label `'a`\n+}\n+```\n+\n+Please verify you spelt or declare the label correctly. Example:\n+\n+```\n+'a: loop {\n+    break 'a; // ok!\n+}\n+```"}, {"sha": "38db0b4bcf96d28ae517dd01c80a0c3e8b9d94f0", "filename": "src/librustc_error_codes/error_codes/E0428.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0428.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0428.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0428.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+A type or module has been defined more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0428\n+struct Bar;\n+struct Bar; // error: duplicate definition of value `Bar`\n+```\n+\n+Please verify you didn't misspell the type/module's name or remove/rename the\n+duplicated one. Example:\n+\n+```\n+struct Bar;\n+struct Bar2; // ok!\n+```"}, {"sha": "8c5fd8624fdeaccc746814df6e6f201d74455a4e", "filename": "src/librustc_error_codes/error_codes/E0429.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0429.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0429.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0429.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+The `self` keyword cannot appear alone as the last segment in a `use`\n+declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0429\n+use std::fmt::self; // error: `self` imports are only allowed within a { } list\n+```\n+\n+To use a namespace itself in addition to some of its members, `self` may appear\n+as part of a brace-enclosed list of imports:\n+\n+```\n+use std::fmt::{self, Debug};\n+```\n+\n+If you only want to import the namespace, do so directly:\n+\n+```\n+use std::fmt;\n+```"}, {"sha": "8cca0f21e5943c97a6115ab661e3fde69cdad78a", "filename": "src/librustc_error_codes/error_codes/E0430.md", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0430.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0430.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0430.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,18 @@\n+The `self` import appears more than once in the list.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0430\n+use something::{self, self}; // error: `self` import can only appear once in\n+                             //        the list\n+```\n+\n+Please verify you didn't misspell the import name or remove the duplicated\n+`self` import. Example:\n+\n+```\n+# mod something {}\n+# fn main() {\n+use something::{self}; // ok!\n+# }\n+```"}, {"sha": "1b70f5f1d7b7609ca09b91270c0accacf8ac24b6", "filename": "src/librustc_error_codes/error_codes/E0431.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0431.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0431.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0431.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,11 @@\n+An invalid `self` import was made.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0431\n+use {self}; // error: `self` import can only appear in an import list with a\n+            //        non-empty prefix\n+```\n+\n+You cannot import the current module into itself, please remove this import\n+or verify you didn't misspell it."}, {"sha": "b562a85b785ff37ec3bb5e3756cd191e83a7d4ca", "filename": "src/librustc_error_codes/error_codes/E0432.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0432.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0432.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0432.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+An import was unresolved.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0432\n+use something::Foo; // error: unresolved import `something::Foo`.\n+```\n+\n+Paths in `use` statements are relative to the crate root. To import items\n+relative to the current and parent modules, use the `self::` and `super::`\n+prefixes, respectively. Also verify that you didn't misspell the import\n+name and that the import exists in the module from where you tried to\n+import it. Example:\n+\n+```\n+use self::something::Foo; // ok!\n+\n+mod something {\n+    pub struct Foo;\n+}\n+# fn main() {}\n+```\n+\n+Or, if you tried to use a module from an external crate, you may have missed\n+the `extern crate` declaration (which is usually placed in the crate root):\n+\n+```\n+extern crate core; // Required to use the `core` crate\n+\n+use core::any;\n+# fn main() {}\n+```"}, {"sha": "f9e333e8ccd00f001637fc0319978b917f82b194", "filename": "src/librustc_error_codes/error_codes/E0433.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0433.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0433.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0433.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,17 @@\n+An undeclared type or module was used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0433\n+let map = HashMap::new();\n+// error: failed to resolve: use of undeclared type or module `HashMap`\n+```\n+\n+Please verify you didn't misspell the type/module's name or that you didn't\n+forget to import it:\n+\n+\n+```\n+use std::collections::HashMap; // HashMap has been imported.\n+let map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n+```"}, {"sha": "e093f0796da5e6aae062b1fe926e4a1ed6099365", "filename": "src/librustc_error_codes/error_codes/E0434.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0434.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0434.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0434.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,42 @@\n+This error indicates that a variable usage inside an inner function is invalid\n+because the variable comes from a dynamic environment. Inner functions do not\n+have access to their containing environment.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0434\n+fn foo() {\n+    let y = 5;\n+    fn bar() -> u32 {\n+        y // error: can't capture dynamic environment in a fn item; use the\n+          //        || { ... } closure form instead.\n+    }\n+}\n+```\n+\n+Functions do not capture local variables. To fix this error, you can replace the\n+function with a closure:\n+\n+```\n+fn foo() {\n+    let y = 5;\n+    let bar = || {\n+        y\n+    };\n+}\n+```\n+\n+or replace the captured variable with a constant or a static item:\n+\n+```\n+fn foo() {\n+    static mut X: u32 = 4;\n+    const Y: u32 = 5;\n+    fn bar() -> u32 {\n+        unsafe {\n+            X = 3;\n+        }\n+        Y\n+    }\n+}\n+```"}, {"sha": "424e5ce1e2e5b99917ea4648b14a8e1dbe5eae56", "filename": "src/librustc_error_codes/error_codes/E0435.md", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0435.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0435.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0435.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,21 @@\n+A non-constant value was used in a constant expression.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0435\n+let foo = 42;\n+let a: [u8; foo]; // error: attempt to use a non-constant value in a constant\n+```\n+\n+To fix this error, please replace the value with a constant. Example:\n+\n+```\n+let a: [u8; 42]; // ok!\n+```\n+\n+Or:\n+\n+```\n+const FOO: usize = 42;\n+let a: [u8; FOO]; // ok!\n+```"}, {"sha": "b1afd9e96033712013af5842784d682e15b1029f", "filename": "src/librustc_error_codes/error_codes/E0436.md", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0436.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,47 @@\n+The functional record update syntax is only allowed for structs. (Struct-like\n+enum variants don't qualify, for example.)\n+\n+Erroneous code example:\n+\n+```compile_fail,E0436\n+enum PublicationFrequency {\n+    Weekly,\n+    SemiMonthly { days: (u8, u8), annual_special: bool },\n+}\n+\n+fn one_up_competitor(competitor_frequency: PublicationFrequency)\n+                     -> PublicationFrequency {\n+    match competitor_frequency {\n+        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n+            days: (1, 15), annual_special: false\n+        },\n+        c @ PublicationFrequency::SemiMonthly{ .. } =>\n+            PublicationFrequency::SemiMonthly {\n+                annual_special: true, ..c // error: functional record update\n+                                          //        syntax requires a struct\n+        }\n+    }\n+}\n+```\n+\n+Rewrite the expression without functional record update syntax:\n+\n+```\n+enum PublicationFrequency {\n+    Weekly,\n+    SemiMonthly { days: (u8, u8), annual_special: bool },\n+}\n+\n+fn one_up_competitor(competitor_frequency: PublicationFrequency)\n+                     -> PublicationFrequency {\n+    match competitor_frequency {\n+        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n+            days: (1, 15), annual_special: false\n+        },\n+        PublicationFrequency::SemiMonthly{ days, .. } =>\n+            PublicationFrequency::SemiMonthly {\n+                days, annual_special: true // ok!\n+        }\n+    }\n+}\n+```"}, {"sha": "834cf33dbc7f0790b53bac15456d8a898ae4664e", "filename": "src/librustc_error_codes/error_codes/E0437.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0437.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+Trait implementations can only implement associated types that are members of\n+the trait in question. This error indicates that you attempted to implement\n+an associated type whose name does not match the name of any associated type\n+in the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0437\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    type Bar = bool;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated type:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```"}, {"sha": "cb141a5d24aeddda718ea69528e7c4dd4393008e", "filename": "src/librustc_error_codes/error_codes/E0438.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0438.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+Trait implementations can only implement associated constants that are\n+members of the trait in question. This error indicates that you\n+attempted to implement an associated constant whose name does not\n+match the name of any associated constant in the trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0438\n+trait Foo {}\n+\n+impl Foo for i32 {\n+    const BAR: bool = true;\n+}\n+```\n+\n+The solution to this problem is to remove the extraneous associated constant:\n+\n+```\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+```"}, {"sha": "e6da2117ac5f2b64a468fabab81c81bb5534ad23", "filename": "src/librustc_error_codes/error_codes/E0439.md", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0439.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,22 @@\n+The length of the platform-intrinsic function `simd_shuffle`\n+wasn't specified. Erroneous code example:\n+\n+```compile_fail,E0439\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_shuffle<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n+    // error: invalid `simd_shuffle`, needs length: `simd_shuffle`\n+}\n+```\n+\n+The `simd_shuffle` function needs the length of the array passed as\n+last parameter in its name. Example:\n+\n+```\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_shuffle8<A,B>(a: A, b: A, c: [u32; 8]) -> B;\n+}\n+```"}, {"sha": "9cc62b2ba6d0afb88ebf021181d93ca672267c6d", "filename": "src/librustc_error_codes/error_codes/E0445.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0445.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0445.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0445.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+A private trait was used on a public type parameter bound.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0445\n+#![deny(private_in_public)]\n+\n+trait Foo {\n+    fn dummy(&self) { }\n+}\n+\n+pub trait Bar : Foo {} // error: private trait in public interface\n+pub struct Bar2<T: Foo>(pub T); // same error\n+pub fn foo<T: Foo> (t: T) {} // same error\n+```\n+\n+To solve this error, please ensure that the trait is also public. The trait\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`. Example:\n+\n+```\n+pub trait Foo { // we set the Foo trait public\n+    fn dummy(&self) { }\n+}\n+\n+pub trait Bar : Foo {} // ok!\n+pub struct Bar2<T: Foo>(pub T); // ok!\n+pub fn foo<T: Foo> (t: T) {} // ok!\n+```"}, {"sha": "d0144478dbfe0c617c7d00a7e54500adb0c90a3c", "filename": "src/librustc_error_codes/error_codes/E0446.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0446.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,30 @@\n+A private type was used in a public type signature.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0446\n+#![deny(private_in_public)]\n+\n+mod Foo {\n+    struct Bar(u32);\n+\n+    pub fn bar() -> Bar { // error: private type in public interface\n+        Bar(0)\n+    }\n+}\n+```\n+\n+To solve this error, please ensure that the type is also public. The type\n+can be made inaccessible if necessary by placing it into a private inner\n+module, but it still has to be marked with `pub`.\n+Example:\n+\n+```\n+mod Foo {\n+    pub struct Bar(u32); // we set the Bar type public\n+\n+    pub fn bar() -> Bar { // ok!\n+        Bar(0)\n+    }\n+}\n+```"}, {"sha": "af8cd8d6d5202ebd748c03660fe02cfbc24703e2", "filename": "src/librustc_error_codes/error_codes/E0447.md", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0447.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0447.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0447.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,15 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+The `pub` keyword was used inside a function.\n+\n+Erroneous code example:\n+\n+```\n+fn foo() {\n+    pub struct Bar; // error: visibility has no effect inside functions\n+}\n+```\n+\n+Since we cannot access items defined inside a function, the visibility of its\n+items does not impact outer code. So using the `pub` keyword in this context\n+is invalid."}, {"sha": "ba096f9e984ae73ef9bdf19737d7dfab469926a8", "filename": "src/librustc_error_codes/error_codes/E0448.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0448.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0448.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0448.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+The `pub` keyword was used inside a public enum.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+pub enum Foo {\n+    pub Bar, // error: unnecessary `pub` visibility\n+}\n+```\n+\n+Since the enum is already public, adding `pub` on one its elements is\n+unnecessary. Example:\n+\n+```compile_fail\n+enum Foo {\n+    pub Bar, // not ok!\n+}\n+```\n+\n+This is the correct syntax:\n+\n+```\n+pub enum Foo {\n+    Bar, // ok!\n+}\n+```"}, {"sha": "a3eb51961d32e3a649b3ad11a5b14427cfed7b4c", "filename": "src/librustc_error_codes/error_codes/E0449.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0449.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0449.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0449.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,37 @@\n+A visibility qualifier was used when it was unnecessary. Erroneous code\n+examples:\n+\n+```compile_fail,E0449\n+struct Bar;\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+pub impl Bar {} // error: unnecessary visibility qualifier\n+\n+pub impl Foo for Bar { // error: unnecessary visibility qualifier\n+    pub fn foo() {} // error: unnecessary visibility qualifier\n+}\n+```\n+\n+To fix this error, please remove the visibility qualifier when it is not\n+required. Example:\n+\n+```\n+struct Bar;\n+\n+trait Foo {\n+    fn foo();\n+}\n+\n+// Directly implemented methods share the visibility of the type itself,\n+// so `pub` is unnecessary here\n+impl Bar {}\n+\n+// Trait methods share the visibility of the trait, so `pub` is\n+// unnecessary in either case\n+impl Foo for Bar {\n+    fn foo() {}\n+}\n+```"}, {"sha": "821073fe16eaeef0821a4a0a0c4948f0ddde3bd5", "filename": "src/librustc_error_codes/error_codes/E0451.md", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0451.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0451.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0451.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,48 @@\n+A struct constructor with private fields was invoked.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0451\n+mod Bar {\n+    pub struct Foo {\n+        pub a: isize,\n+        b: isize,\n+    }\n+}\n+\n+let f = Bar::Foo{ a: 0, b: 0 }; // error: field `b` of struct `Bar::Foo`\n+                                //        is private\n+```\n+\n+To fix this error, please ensure that all the fields of the struct are public,\n+or implement a function for easy instantiation. Examples:\n+\n+```\n+mod Bar {\n+    pub struct Foo {\n+        pub a: isize,\n+        pub b: isize, // we set `b` field public\n+    }\n+}\n+\n+let f = Bar::Foo{ a: 0, b: 0 }; // ok!\n+```\n+\n+Or:\n+\n+```\n+mod Bar {\n+    pub struct Foo {\n+        pub a: isize,\n+        b: isize, // still private\n+    }\n+\n+    impl Foo {\n+        pub fn new() -> Foo { // we create a method to instantiate `Foo`\n+            Foo { a: 0, b: 0 }\n+        }\n+    }\n+}\n+\n+let f = Bar::Foo::new(); // ok!\n+```"}, {"sha": "be3d573e10d2d9f4857f8860b622bb64d1ee87d9", "filename": "src/librustc_error_codes/error_codes/E0452.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+An invalid lint attribute has been given. Erroneous code example:\n+\n+```compile_fail,E0452\n+#![allow(foo = \"\")] // error: malformed lint attribute\n+```\n+\n+Lint attributes only accept a list of identifiers (where each identifier is a\n+lint name). Ensure the attribute is of this form:\n+\n+```\n+#![allow(foo)] // ok!\n+// or:\n+#![allow(foo, foo2)] // ok!\n+```"}, {"sha": "11789db8f365a0465ffd46cf4e393380ce223b04", "filename": "src/librustc_error_codes/error_codes/E0453.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0453.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0453.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0453.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,42 @@\n+A lint check attribute was overruled by a `forbid` directive set as an\n+attribute on an enclosing scope, or on the command line with the `-F` option.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0453\n+#![forbid(non_snake_case)]\n+\n+#[allow(non_snake_case)]\n+fn main() {\n+    let MyNumber = 2; // error: allow(non_snake_case) overruled by outer\n+                      //        forbid(non_snake_case)\n+}\n+```\n+\n+The `forbid` lint setting, like `deny`, turns the corresponding compiler\n+warning into a hard error. Unlike `deny`, `forbid` prevents itself from being\n+overridden by inner attributes.\n+\n+If you're sure you want to override the lint check, you can change `forbid` to\n+`deny` (or use `-D` instead of `-F` if the `forbid` setting was given as a\n+command-line option) to allow the inner lint check attribute:\n+\n+```\n+#![deny(non_snake_case)]\n+\n+#[allow(non_snake_case)]\n+fn main() {\n+    let MyNumber = 2; // ok!\n+}\n+```\n+\n+Otherwise, edit the code to pass the lint check, and remove the overruled\n+attribute:\n+\n+```\n+#![forbid(non_snake_case)]\n+\n+fn main() {\n+    let my_number = 2;\n+}\n+```"}, {"sha": "d33148850816f60694bf5f459c743d79e6702959", "filename": "src/librustc_error_codes/error_codes/E0454.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0454.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+A link name was given with an empty name. Erroneous code example:\n+\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n+#[link(name = \"\")] extern {}\n+// error: `#[link(name = \"\")]` given with empty name\n+```\n+\n+The rust compiler cannot link to an external library if you don't give it its\n+name. Example:\n+\n+```no_run\n+#[link(name = \"some_lib\")] extern {} // ok!\n+```"}, {"sha": "a642528dee2258ca9a61537e3c2558384ddbd673", "filename": "src/librustc_error_codes/error_codes/E0455.md", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0455.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,19 @@\n+Linking with `kind=framework` is only supported when targeting macOS,\n+as frameworks are specific to that operating system.\n+\n+Erroneous code example:\n+\n+```ignore (should-compile_fail-but-cannot-doctest-conditionally-without-macos)\n+#[link(name = \"FooCoreServices\", kind = \"framework\")] extern {}\n+// OS used to compile is Linux for example\n+```\n+\n+To solve this error you can use conditional compilation:\n+\n+```\n+#[cfg_attr(target=\"macos\", link(name = \"FooCoreServices\", kind = \"framework\"))]\n+extern {}\n+```\n+\n+See more:\n+https://doc.rust-lang.org/reference/attributes.html#conditional-compilation"}, {"sha": "e6baeb8f69229221f8a497026c9fc5ef2e16570c", "filename": "src/librustc_error_codes/error_codes/E0458.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0458.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+An unknown \"kind\" was specified for a link attribute. Erroneous code example:\n+\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n+#[link(kind = \"wonderful_unicorn\")] extern {}\n+// error: unknown kind: `wonderful_unicorn`\n+```\n+\n+Please specify a valid \"kind\" value, from one of the following:\n+\n+* static\n+* dylib\n+* framework\n+"}, {"sha": "663bc322ee65d6000acffc31e59f4f3bf4afb369", "filename": "src/librustc_error_codes/error_codes/E0459.md", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0459.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,13 @@\n+A link was used without a name parameter. Erroneous code example:\n+\n+```ignore (cannot-test-this-because-rustdoc-stops-compile-fail-before-codegen)\n+#[link(kind = \"dylib\")] extern {}\n+// error: `#[link(...)]` specified without `name = \"foo\"`\n+```\n+\n+Please add the name parameter to allow the rust compiler to find the library\n+you want. Example:\n+\n+```no_run\n+#[link(kind = \"dylib\", name = \"some_lib\")] extern {} // ok!\n+```"}, {"sha": "41add698cdc9041d6474250f7c25ca46d1259259", "filename": "src/librustc_error_codes/error_codes/E0463.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0463.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0463.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0463.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,11 @@\n+A plugin/crate was declared but cannot be found. Erroneous code example:\n+\n+```compile_fail,E0463\n+#![feature(plugin)]\n+#![plugin(cookie_monster)] // error: can't find crate for `cookie_monster`\n+extern crate cake_is_a_lie; // error: can't find crate for `cake_is_a_lie`\n+```\n+\n+You need to link your code to the relevant crate in order to be able to use it\n+(through Cargo or the `-L` option of rustc example). Plugins are crates as\n+well, and you link to them the same way."}, {"sha": "443b7bae1345e5fdae42cf0787b63137bf73a2e6", "filename": "src/librustc_error_codes/error_codes/E0466.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0466.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+Macro import declarations were malformed.\n+\n+Erroneous code examples:\n+\n+```compile_fail,E0466\n+#[macro_use(a_macro(another_macro))] // error: invalid import declaration\n+extern crate core as some_crate;\n+\n+#[macro_use(i_want = \"some_macros\")] // error: invalid import declaration\n+extern crate core as another_crate;\n+```\n+\n+This is a syntax error at the level of attribute declarations. The proper\n+syntax for macro imports is the following:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+// In some_crate:\n+#[macro_export]\n+macro_rules! get_tacos {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! get_pimientos {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(get_tacos, get_pimientos)] // It imports `get_tacos` and\n+extern crate some_crate;               // `get_pimientos` macros from some_crate\n+```\n+\n+If you would like to import all exported macros, write `macro_use` with no\n+arguments."}, {"sha": "73e3ebb949ac0da13e0386e9a48e70867ef0f826", "filename": "src/librustc_error_codes/error_codes/E0468.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0468.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,27 @@\n+A non-root module attempts to import macros from another crate.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0468\n+mod foo {\n+    #[macro_use(debug_assert)]  // error: must be at crate root to import\n+    extern crate core;          //        macros from another crate\n+    fn run_macro() { debug_assert!(true); }\n+}\n+```\n+\n+Only `extern crate` imports at the crate root level are allowed to import\n+macros.\n+\n+Either move the macro import to crate root or do without the foreign macros.\n+This will work:\n+\n+```\n+#[macro_use(debug_assert)]\n+extern crate core;\n+\n+mod foo {\n+    fn run_macro() { debug_assert!(true); }\n+}\n+# fn main() {}\n+```"}, {"sha": "22db976aac2decad576ed3d1766640955823fe7f", "filename": "src/librustc_error_codes/error_codes/E0469.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0469.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0469.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0469.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,39 @@\n+A macro listed for import was not found.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0469\n+#[macro_use(drink, be_merry)] // error: imported macro not found\n+extern crate alloc;\n+\n+fn main() {\n+    // ...\n+}\n+```\n+\n+Either the listed macro is not contained in the imported crate, or it is not\n+exported from the given crate.\n+\n+This could be caused by a typo. Did you misspell the macro's name?\n+\n+Double-check the names of the macros listed for import, and that the crate\n+in question exports them.\n+\n+A working version would be:\n+\n+```ignore (cannot-doctest-multicrate-project)\n+// In some_crate crate:\n+#[macro_export]\n+macro_rules! eat {\n+    ...\n+}\n+\n+#[macro_export]\n+macro_rules! drink {\n+    ...\n+}\n+\n+// In your crate:\n+#[macro_use(eat, drink)]\n+extern crate some_crate; //ok!\n+```"}, {"sha": "6634d9b6e63b418f572621b03ad39cae3d6f5eab", "filename": "src/librustc_error_codes/error_codes/E0478.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0478.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+A lifetime bound was not satisfied.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0478\n+// Check that the explicit lifetime bound (`'SnowWhite`, in this example) must\n+// outlive all the superbounds from the trait (`'kiss`, in this example).\n+\n+trait Wedding<'t>: 't { }\n+\n+struct Prince<'kiss, 'SnowWhite> {\n+    child: Box<Wedding<'kiss> + 'SnowWhite>,\n+    // error: lifetime bound not satisfied\n+}\n+```\n+\n+In this example, the `'SnowWhite` lifetime is supposed to outlive the `'kiss`\n+lifetime but the declaration of the `Prince` struct doesn't enforce it. To fix\n+this issue, you need to specify it:\n+\n+```\n+trait Wedding<'t>: 't { }\n+\n+struct Prince<'kiss, 'SnowWhite: 'kiss> { // You say here that 'kiss must live\n+                                          // longer than 'SnowWhite.\n+    child: Box<Wedding<'kiss> + 'SnowWhite>, // And now it's all good!\n+}\n+```"}, {"sha": "1ccaf71257b8b47e21c81082b08abea73abac758", "filename": "src/librustc_error_codes/error_codes/E0491.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0491.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0491.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0491.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+A reference has a longer lifetime than the data it references.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0491\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T {\n+    type Output = &'a T; // compile error E0491\n+}\n+```\n+\n+Here, the problem is that a reference type like `&'a T` is only valid\n+if all the data in T outlives the lifetime `'a`. But this impl as written\n+is applicable to any lifetime `'a` and any type `T` -- we have no guarantee\n+that `T` outlives `'a`. To fix this, you can add a where clause like\n+`where T: 'a`.\n+\n+```\n+trait SomeTrait<'a> {\n+    type Output;\n+}\n+\n+impl<'a, T> SomeTrait<'a> for T\n+where\n+    T: 'a,\n+{\n+    type Output = &'a T; // compile error E0491\n+}\n+```"}, {"sha": "1caa59999ae1e384cb7ed77fb629c9272c9ba672", "filename": "src/librustc_error_codes/error_codes/E0492.md", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0492.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0492.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0492.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,71 @@\n+A borrow of a constant containing interior mutability was attempted.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0492\n+use std::sync::atomic::AtomicUsize;\n+\n+const A: AtomicUsize = AtomicUsize::new(0);\n+static B: &'static AtomicUsize = &A;\n+// error: cannot borrow a constant which may contain interior mutability,\n+//        create a static instead\n+```\n+\n+A `const` represents a constant value that should never change. If one takes\n+a `&` reference to the constant, then one is taking a pointer to some memory\n+location containing the value. Normally this is perfectly fine: most values\n+can't be changed via a shared `&` pointer, but interior mutability would allow\n+it. That is, a constant value could be mutated. On the other hand, a `static` is\n+explicitly a single memory location, which can be mutated at will.\n+\n+So, in order to solve this error, either use statics which are `Sync`:\n+\n+```\n+use std::sync::atomic::AtomicUsize;\n+\n+static A: AtomicUsize = AtomicUsize::new(0);\n+static B: &'static AtomicUsize = &A; // ok!\n+```\n+\n+You can also have this error while using a cell type:\n+\n+```compile_fail,E0492\n+use std::cell::Cell;\n+\n+const A: Cell<usize> = Cell::new(1);\n+const B: &Cell<usize> = &A;\n+// error: cannot borrow a constant which may contain interior mutability,\n+//        create a static instead\n+\n+// or:\n+struct C { a: Cell<usize> }\n+\n+const D: C = C { a: Cell::new(1) };\n+const E: &Cell<usize> = &D.a; // error\n+\n+// or:\n+const F: &C = &D; // error\n+```\n+\n+This is because cell types do operations that are not thread-safe. Due to this,\n+they don't implement Sync and thus can't be placed in statics.\n+\n+However, if you still wish to use these types, you can achieve this by an unsafe\n+wrapper:\n+\n+```\n+use std::cell::Cell;\n+use std::marker::Sync;\n+\n+struct NotThreadSafe<T> {\n+    value: Cell<T>,\n+}\n+\n+unsafe impl<T> Sync for NotThreadSafe<T> {}\n+\n+static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n+static B: &'static NotThreadSafe<usize> = &A; // ok!\n+```\n+\n+Remember this solution is unsafe! You will have to ensure that accesses to the\n+cell are synchronized."}, {"sha": "90a0cbce623d0473230e147388f95127260ccb81", "filename": "src/librustc_error_codes/error_codes/E0493.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0493.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,42 @@\n+A type with a `Drop` implementation was destructured when trying to initialize\n+a static item.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0493\n+enum DropType {\n+    A,\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Foo {\n+    field1: DropType,\n+}\n+\n+static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n+```\n+\n+The problem here is that if the given type or one of its fields implements the\n+`Drop` trait, this `Drop` implementation cannot be called during the static\n+type initialization which might cause a memory leak. To prevent this issue,\n+you need to instantiate all the static type's fields by hand.\n+\n+```\n+enum DropType {\n+    A,\n+}\n+\n+impl Drop for DropType {\n+    fn drop(&mut self) {}\n+}\n+\n+struct Foo {\n+    field1: DropType,\n+}\n+\n+static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n+                                               // by hand.\n+```"}, {"sha": "f956237b80bc343bb94ff27f20e266dff879e3de", "filename": "src/librustc_error_codes/error_codes/E0495.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0495.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0495.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0495.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,38 @@\n+A lifetime cannot be determined in the given situation.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0495\n+fn transmute_lifetime<'a, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // error!\n+        ((u,),) => u,\n+    }\n+}\n+\n+let y = Box::new((42,));\n+let x = transmute_lifetime(&y);\n+```\n+\n+In this code, you have two ways to solve this issue:\n+ 1. Enforce that `'a` lives at least as long as `'b`.\n+ 2. Use the same lifetime requirement for both input and output values.\n+\n+So for the first solution, you can do it by replacing `'a` with `'a: 'b`:\n+\n+```\n+fn transmute_lifetime<'a: 'b, 'b, T>(t: &'a (T,)) -> &'b T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```\n+\n+In the second you can do it by simply removing `'b` so they both use `'a`:\n+\n+```\n+fn transmute_lifetime<'a, T>(t: &'a (T,)) -> &'a T {\n+    match (&t,) { // ok!\n+        ((u,),) => u,\n+    }\n+}\n+```"}, {"sha": "83d65cd3e09ae561a3b36de2afcdbcf889d60045", "filename": "src/librustc_error_codes/error_codes/E0496.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0496.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0496.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0496.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,31 @@\n+A lifetime name is shadowing another lifetime name.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0496\n+struct Foo<'a> {\n+    a: &'a i32,\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn f<'a>(x: &'a i32) { // error: lifetime name `'a` shadows a lifetime\n+                           //        name that is already in scope\n+    }\n+}\n+```\n+\n+Please change the name of one of the lifetimes to remove this error. Example:\n+\n+```\n+struct Foo<'a> {\n+    a: &'a i32,\n+}\n+\n+impl<'a> Foo<'a> {\n+    fn f<'b>(x: &'b i32) { // ok!\n+    }\n+}\n+\n+fn main() {\n+}\n+```"}, {"sha": "ef2882415d24a9c2894be2abfe6b698742bae20a", "filename": "src/librustc_error_codes/error_codes/E0497.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0497.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0497.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0497.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+A stability attribute was used outside of the standard library.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+#[stable] // error: stability attributes may not be used outside of the\n+          //        standard library\n+fn foo() {}\n+```\n+\n+It is not possible to use stability attributes outside of the standard library.\n+Also, for now, it is not possible to write deprecation messages either."}, {"sha": "370ceef530bd270efa05da8a3c14fa22502d31a1", "filename": "src/librustc_error_codes/error_codes/E0499.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0499.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,30 @@\n+A variable was borrowed as mutable more than once.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0499\n+let mut i = 0;\n+let mut x = &mut i;\n+let mut a = &mut i;\n+x;\n+// error: cannot borrow `i` as mutable more than once at a time\n+```\n+\n+Please note that in rust, you can either have many immutable references, or one\n+mutable reference. Take a look at\n+https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more\n+information. Example:\n+\n+\n+```\n+let mut i = 0;\n+let mut x = &mut i; // ok!\n+\n+// or:\n+let mut i = 0;\n+let a = &i; // ok!\n+let b = &i; // still ok!\n+let c = &i; // still ok!\n+b;\n+a;\n+```"}, {"sha": "fde31d2c745b4c8aa3a28ec1bfbfddcda42587f0", "filename": "src/librustc_error_codes/error_codes/E0500.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0500.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0500.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0500.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,41 @@\n+A borrowed variable was used by a closure.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0500\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let nights_watch = &jon_snow;\n+    let starks = || {\n+        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n+                       //        but it is already borrowed\n+    };\n+    println!(\"{}\", nights_watch);\n+}\n+```\n+\n+In here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\n+cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n+you can create the closure after the borrow has ended:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let nights_watch = &jon_snow;\n+    println!(\"{}\", nights_watch);\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+}\n+```\n+\n+Or, if the type implements the `Clone` trait, you can clone it between\n+closures:\n+\n+```\n+fn you_know_nothing(jon_snow: &mut i32) {\n+    let mut jon_copy = jon_snow.clone();\n+    let starks = || {\n+        *jon_snow = 3;\n+    };\n+    println!(\"{}\", jon_copy);\n+}\n+```"}, {"sha": "95e0dfd40015f90a7798420a40105f076f9540d0", "filename": "src/librustc_error_codes/error_codes/E0501.md", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0501.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,76 @@\n+This error indicates that a mutable variable is being used while it is still\n+captured by a closure. Because the closure has borrowed the variable, it is not\n+available for use until the closure goes out of scope.\n+\n+Note that a capture will either move or borrow a variable, but in this\n+situation, the closure is borrowing the variable. Take a look at\n+http://rustbyexample.com/fn/closures/capture.html for more information about\n+capturing.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0501\n+fn inside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn outside_closure(x: &mut i32) {\n+    // Actions which require unique access\n+}\n+\n+fn foo(a: &mut i32) {\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n+                        //        closure requires unique access.\n+    bar();\n+}\n+```\n+\n+To fix this error, you can finish using the closure before using the captured\n+variable:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    bar();\n+    // borrow on `a` ends.\n+    outside_closure(a); // ok!\n+}\n+```\n+\n+Or you can pass the variable as a parameter to the closure:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    let mut bar = |s: &mut i32| {\n+        inside_closure(s)\n+    };\n+    outside_closure(a);\n+    bar(a);\n+}\n+```\n+\n+It may be possible to define the closure later:\n+\n+```\n+fn inside_closure(x: &mut i32) {}\n+fn outside_closure(x: &mut i32) {}\n+\n+fn foo(a: &mut i32) {\n+    outside_closure(a);\n+    let mut bar = || {\n+        inside_closure(a)\n+    };\n+    bar();\n+}\n+```"}, {"sha": "69220259e3d7d5896e7d9105b6c0d63b86625bf4", "filename": "src/librustc_error_codes/error_codes/E0502.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0502.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,29 @@\n+This error indicates that you are trying to borrow a variable as mutable when it\n+has already been borrowed as immutable.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0502\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    let ref y = a; // a is borrowed as immutable.\n+    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n+            //        as immutable\n+    println!(\"{}\", y);\n+}\n+```\n+\n+To fix this error, ensure that you don't have any other references to the\n+variable before trying to access it mutably:\n+\n+```\n+fn bar(x: &mut i32) {}\n+fn foo(a: &mut i32) {\n+    bar(a);\n+    let ref y = a; // ok!\n+    println!(\"{}\", y);\n+}\n+```\n+\n+For more information on the rust ownership system, take a look at\n+https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html."}, {"sha": "c683619e3d03f45532101dd6d1eb8c233db798e0", "filename": "src/librustc_error_codes/error_codes/E0503.md", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0503.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,52 @@\n+A value was used after it was mutably borrowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0503\n+fn main() {\n+    let mut value = 3;\n+    // Create a mutable borrow of `value`.\n+    let borrow = &mut value;\n+    let _sum = value + 1; // error: cannot use `value` because\n+                          //        it was mutably borrowed\n+    println!(\"{}\", borrow);\n+}\n+```\n+\n+In this example, `value` is mutably borrowed by `borrow` and cannot be\n+used to calculate `sum`. This is not possible because this would violate\n+Rust's mutability rules.\n+\n+You can fix this error by finishing using the borrow before the next use of\n+the value:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    let borrow = &mut value;\n+    println!(\"{}\", borrow);\n+    // The block has ended and with it the borrow.\n+    // You can now use `value` again.\n+    let _sum = value + 1;\n+}\n+```\n+\n+Or by cloning `value` before borrowing it:\n+\n+```\n+fn main() {\n+    let mut value = 3;\n+    // We clone `value`, creating a copy.\n+    let value_cloned = value.clone();\n+    // The mutable borrow is a reference to `value` and\n+    // not to `value_cloned`...\n+    let borrow = &mut value;\n+    // ... which means we can still use `value_cloned`,\n+    let _sum = value_cloned + 1;\n+    // even though the borrow only ends here.\n+    println!(\"{}\", borrow);\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}, {"sha": "bcbd00a8690a454c486e7afe549e2749823626a2", "filename": "src/librustc_error_codes/error_codes/E0504.md", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0504.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0504.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0504.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,103 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error occurs when an attempt is made to move a borrowed variable into a\n+closure.\n+\n+Erroneous code example:\n+\n+```compile_fail\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        println!(\"child function: {}\", fancy_num.num);\n+        // error: cannot move `fancy_num` into closure because it is borrowed\n+    };\n+\n+    x();\n+    println!(\"main function: {}\", fancy_ref.num);\n+}\n+```\n+\n+Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n+the closure `x`. There is no way to move a value into a closure while it is\n+borrowed, as that would invalidate the borrow.\n+\n+If the closure can't outlive the value being moved, try using a reference\n+rather than moving:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+\n+    let x = move || {\n+        // fancy_ref is usable here because it doesn't move `fancy_num`\n+        println!(\"child function: {}\", fancy_ref.num);\n+    };\n+\n+    x();\n+\n+    println!(\"main function: {}\", fancy_num.num);\n+}\n+```\n+\n+If the value has to be borrowed and then moved, try limiting the lifetime of\n+the borrow using a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"main function: {}\", fancy_ref.num);\n+        // `fancy_ref` goes out of scope here\n+    }\n+\n+    let x = move || {\n+        // `fancy_num` can be moved now (no more references exist)\n+        println!(\"child function: {}\", fancy_num.num);\n+    };\n+\n+    x();\n+}\n+```\n+\n+If the lifetime of a reference isn't enough, such as in the case of threading,\n+consider using an `Arc` to create a reference-counted value:\n+\n+```\n+use std::sync::Arc;\n+use std::thread;\n+\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n+    let fancy_ref2 = fancy_ref1.clone();\n+\n+    let x = thread::spawn(move || {\n+        // `fancy_ref1` can be moved and has a `'static` lifetime\n+        println!(\"child thread: {}\", fancy_ref1.num);\n+    });\n+\n+    x.join().expect(\"child thread should finish\");\n+    println!(\"main thread: {}\", fancy_ref2.num);\n+}\n+```"}, {"sha": "14baa01cb50a04fcbbc17e4345284a42db07593c", "filename": "src/librustc_error_codes/error_codes/E0505.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0505.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,85 @@\n+A value was moved out while it was still borrowed.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0505\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    let _ref_to_val: &Value = &x;\n+    eat(x);\n+    borrow(_ref_to_val);\n+}\n+```\n+\n+Here, the function `eat` takes ownership of `x`. However,\n+`x` cannot be moved because the borrow to `_ref_to_val`\n+needs to last till the function `borrow`.\n+To fix that you can do a few different things:\n+\n+* Try to avoid moving the variable.\n+* Release borrow before move.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: &Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+\n+    let ref_to_val: &Value = &x;\n+    eat(&x); // pass by reference, if it's possible\n+    borrow(ref_to_val);\n+}\n+```\n+\n+Or:\n+\n+```\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+\n+    let ref_to_val: &Value = &x;\n+    borrow(ref_to_val);\n+    // ref_to_val is no longer used.\n+    eat(x);\n+}\n+```\n+\n+Or:\n+\n+```\n+#[derive(Clone, Copy)] // implement Copy trait\n+struct Value {}\n+\n+fn borrow(val: &Value) {}\n+\n+fn eat(val: Value) {}\n+\n+fn main() {\n+    let x = Value{};\n+    let ref_to_val: &Value = &x;\n+    eat(x); // it will be copied here.\n+    borrow(ref_to_val);\n+}\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}, {"sha": "9b8e316487203331d18e4d3a4e7db5ca4c72e901", "filename": "src/librustc_error_codes/error_codes/E0506.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0506.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,81 @@\n+This error occurs when an attempt is made to assign to a borrowed value.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0506\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let fancy_ref = &fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+    // error: cannot assign to `fancy_num` because it is borrowed\n+\n+    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n+}\n+```\n+\n+Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n+be assigned to a new value as it would invalidate the reference.\n+\n+Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+    let moved_num = fancy_num;\n+    fancy_num = FancyNum { num: 6 };\n+\n+    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n+}\n+```\n+\n+If the value has to be borrowed, try limiting the lifetime of the borrow using\n+a scoped block:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    {\n+        let fancy_ref = &fancy_num;\n+        println!(\"Ref: {}\", fancy_ref.num);\n+    }\n+\n+    // Works because `fancy_ref` is no longer in scope\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+```\n+\n+Or by moving the reference into a function:\n+\n+```\n+struct FancyNum {\n+    num: u8,\n+}\n+\n+fn main() {\n+    let mut fancy_num = FancyNum { num: 5 };\n+\n+    print_fancy_ref(&fancy_num);\n+\n+    // Works because function borrow has ended\n+    fancy_num = FancyNum { num: 6 };\n+    println!(\"Num: {}\", fancy_num.num);\n+}\n+\n+fn print_fancy_ref(fancy_ref: &FancyNum){\n+    println!(\"Ref: {}\", fancy_ref.num);\n+}\n+```"}, {"sha": "89a6fb47377c4bfb529f3c749d8340cfccaad411", "filename": "src/librustc_error_codes/error_codes/E0507.md", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0507.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,131 @@\n+You tried to move out of a value which was borrowed.\n+\n+This can also happen when using a type implementing `Fn` or `FnMut`, as neither\n+allows moving out of them (they usually represent closures which can be called\n+more than once). Much of the text following applies equally well to non-`FnOnce`\n+closure bodies.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0507\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n+}\n+```\n+\n+Here, the `nothing_is_true` method takes the ownership of `self`. However,\n+`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n+which is a borrow of the content owned by the `RefCell`. To fix this error,\n+you have three choices:\n+\n+* Try to avoid moving the variable.\n+* Somehow reclaim the ownership.\n+* Implement the `Copy` trait on the type.\n+\n+Examples:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(&self) {} // First case, we don't take ownership\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+    let x = x.into_inner(); // we get back ownership\n+\n+    x.nothing_is_true(); // ok!\n+}\n+```\n+\n+Or:\n+\n+```\n+use std::cell::RefCell;\n+\n+#[derive(Clone, Copy)] // we implement the Copy trait\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+fn main() {\n+    let x = RefCell::new(TheDarkKnight);\n+\n+    x.borrow().nothing_is_true(); // ok!\n+}\n+```\n+\n+Moving a member out of a mutably borrowed struct will also cause E0507 error:\n+\n+```compile_fail,E0507\n+struct TheDarkKnight;\n+\n+impl TheDarkKnight {\n+    fn nothing_is_true(self) {}\n+}\n+\n+struct Batcave {\n+    knight: TheDarkKnight\n+}\n+\n+fn main() {\n+    let mut cave = Batcave {\n+        knight: TheDarkKnight\n+    };\n+    let borrowed = &mut cave;\n+\n+    borrowed.knight.nothing_is_true(); // E0507\n+}\n+```\n+\n+It is fine only if you put something back. `mem::replace` can be used for that:\n+\n+```\n+# struct TheDarkKnight;\n+# impl TheDarkKnight { fn nothing_is_true(self) {} }\n+# struct Batcave { knight: TheDarkKnight }\n+use std::mem;\n+\n+let mut cave = Batcave {\n+    knight: TheDarkKnight\n+};\n+let borrowed = &mut cave;\n+\n+mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n+```\n+\n+You can find more information about borrowing in the rust-book:\n+http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}, {"sha": "33572fca6a3e8a308243444de3e7c32007f5230f", "filename": "src/librustc_error_codes/error_codes/E0508.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0508.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0508.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0508.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,41 @@\n+A value was moved out of a non-copy fixed-size array.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0508\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n+                           //        a non-copy fixed-size array\n+}\n+```\n+\n+The first element was moved out of the array, but this is not\n+possible because `NonCopy` does not implement the `Copy` trait.\n+\n+Consider borrowing the element instead of moving it:\n+\n+```\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n+}\n+```\n+\n+Alternatively, if your type implements `Clone` and you need to own the value,\n+consider borrowing and then cloning:\n+\n+```\n+#[derive(Clone)]\n+struct NonCopy;\n+\n+fn main() {\n+    let array = [NonCopy; 1];\n+    // Now you can clone the array element.\n+    let _value = array[0].clone();\n+}\n+```"}, {"sha": "9cbd7d695aab9623f10822ddb389bd530503af0f", "filename": "src/librustc_error_codes/error_codes/E0509.md", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0509.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0509.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0509.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,92 @@\n+This error occurs when an attempt is made to move out of a value whose type\n+implements the `Drop` trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0509\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let fancy_field = drop_struct.fancy; // Error E0509\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Here, we tried to move a field out of a struct of type `DropStruct` which\n+implements the `Drop` trait. However, a struct cannot be dropped if one or\n+more of its fields have been moved.\n+\n+Structs implementing the `Drop` trait have an implicit destructor that gets\n+called when they go out of scope. This destructor may use the fields of the\n+struct, so moving out of the struct could make it impossible to run the\n+destructor. Therefore, we must think of all values whose type implements the\n+`Drop` trait as single units whose fields cannot be moved.\n+\n+This error can be fixed by creating a reference to the fields of a struct,\n+enum, or tuple using the `ref` keyword:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+struct DropStruct {\n+    fancy: FancyNum\n+}\n+\n+impl Drop for DropStruct {\n+    fn drop(&mut self) {\n+        // Destruct DropStruct, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n+    let ref fancy_field = drop_struct.fancy; // No more errors!\n+    println!(\"Fancy: {}\", fancy_field.num);\n+    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n+}\n+```\n+\n+Note that this technique can also be used in the arms of a match expression:\n+\n+```\n+struct FancyNum {\n+    num: usize\n+}\n+\n+enum DropEnum {\n+    Fancy(FancyNum)\n+}\n+\n+impl Drop for DropEnum {\n+    fn drop(&mut self) {\n+        // Destruct DropEnum, possibly using FancyNum\n+    }\n+}\n+\n+fn main() {\n+    // Creates and enum of type `DropEnum`, which implements `Drop`\n+    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n+    match drop_enum {\n+        // Creates a reference to the inside of `DropEnum::Fancy`\n+        DropEnum::Fancy(ref fancy_field) => // No error!\n+            println!(\"It was fancy-- {}!\", fancy_field.num),\n+    }\n+    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n+}\n+```"}, {"sha": "d5be417888b547ea63e236ddb209546dc1fc3aef", "filename": "src/librustc_error_codes/error_codes/E0510.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0510.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+Cannot mutate place in this match guard.\n+\n+When matching on a variable it cannot be mutated in the match guards, as this\n+could cause the match to be non-exhaustive:\n+\n+```compile_fail,E0510\n+let mut x = Some(0);\n+match x {\n+    None => (),\n+    Some(_) if { x = None; false } => (),\n+    Some(v) => (), // No longer matches\n+}\n+```\n+\n+Here executing `x = None` would modify the value being matched and require us\n+to go \"back in time\" to the `None` arm."}, {"sha": "2d6ff8241e69232754927cac33b4515d2b936170", "filename": "src/librustc_error_codes/error_codes/E0511.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0511.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+Invalid monomorphization of an intrinsic function was used. Erroneous code\n+example:\n+\n+```ignore (error-emitted-at-codegen-which-cannot-be-handled-by-compile_fail)\n+#![feature(platform_intrinsics)]\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+fn main() {\n+    unsafe { simd_add(0, 1); }\n+    // error: invalid monomorphization of `simd_add` intrinsic\n+}\n+```\n+\n+The generic type has to be a SIMD type. Example:\n+\n+```\n+#![feature(repr_simd)]\n+#![feature(platform_intrinsics)]\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+struct i32x2(i32, i32);\n+\n+extern \"platform-intrinsic\" {\n+    fn simd_add<T>(a: T, b: T) -> T;\n+}\n+\n+unsafe { simd_add(i32x2(0, 0), i32x2(1, 2)); } // ok!\n+```"}, {"sha": "c13c0511c757590e6c86a6a60539b59736e51f83", "filename": "src/librustc_error_codes/error_codes/E0512.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0512.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0512.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0512.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+Transmute with two differently sized types was attempted. Erroneous code\n+example:\n+\n+```compile_fail,E0512\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0u16)); }\n+    // error: cannot transmute between types of different sizes,\n+    //        or dependently-sized types\n+}\n+```\n+\n+Please use types with same size or use the expected type directly. Example:\n+\n+```\n+fn takes_u8(_: u8) {}\n+\n+fn main() {\n+    unsafe { takes_u8(::std::mem::transmute(0i8)); } // ok!\n+    // or:\n+    unsafe { takes_u8(0u8); } // ok!\n+}\n+```"}, {"sha": "9580b6f92acd1bd77188397cbf62bc29576ff0d0", "filename": "src/librustc_error_codes/error_codes/E0515.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0515.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0515.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0515.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,37 @@\n+Cannot return value that references local variable\n+\n+Local variables, function parameters and temporaries are all dropped before the\n+end of the function body. So a reference to them cannot be returned.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0515\n+fn get_dangling_reference() -> &'static i32 {\n+    let x = 0;\n+    &x\n+}\n+```\n+\n+```compile_fail,E0515\n+use std::slice::Iter;\n+fn get_dangling_iterator<'a>() -> Iter<'a, i32> {\n+    let v = vec![1, 2, 3];\n+    v.iter()\n+}\n+```\n+\n+Consider returning an owned value instead:\n+\n+```\n+use std::vec::IntoIter;\n+\n+fn get_integer() -> i32 {\n+    let x = 0;\n+    x\n+}\n+\n+fn get_owned_iterator() -> IntoIter<i32> {\n+    let v = vec![1, 2, 3];\n+    v.into_iter()\n+}\n+```"}, {"sha": "815d7609013000871982c87017c99201feaee833", "filename": "src/librustc_error_codes/error_codes/E0516.md", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0516.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0516.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0516.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,16 @@\n+The `typeof` keyword is currently reserved but unimplemented.\n+Erroneous code example:\n+\n+```compile_fail,E0516\n+fn main() {\n+    let x: typeof(92) = 92;\n+}\n+```\n+\n+Try using type inference instead. Example:\n+\n+```\n+fn main() {\n+    let x = 92;\n+}\n+```"}, {"sha": "f738d33560a02bd47d1f79348118e5ef54468ba8", "filename": "src/librustc_error_codes/error_codes/E0517.md", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0517.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0517.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0517.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,45 @@\n+This error indicates that a `#[repr(..)]` attribute was placed on an\n+unsupported item.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0517\n+#[repr(C)]\n+type Foo = u8;\n+\n+#[repr(packed)]\n+enum Foo {Bar, Baz}\n+\n+#[repr(u8)]\n+struct Foo {bar: bool, baz: bool}\n+\n+#[repr(C)]\n+impl Foo {\n+    // ...\n+}\n+```\n+\n+* The `#[repr(C)]` attribute can only be placed on structs and enums.\n+* The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs.\n+* The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums.\n+\n+These attributes do not work on typedefs, since typedefs are just aliases.\n+\n+Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n+discriminant size for enums with no data fields on any of the variants, e.g.\n+`enum Color {Red, Blue, Green}`, effectively setting the size of the enum to\n+the size of the provided type. Such an enum can be cast to a value of the same\n+type as well. In short, `#[repr(u8)]` makes the enum behave like an integer\n+with a constrained set of allowed values.\n+\n+Only field-less enums can be cast to numerical primitives, so this attribute\n+will not apply to structs.\n+\n+`#[repr(packed)]` reduces padding to make the struct size smaller. The\n+representation of enums isn't strictly defined in Rust, and this attribute\n+won't work on enums.\n+\n+`#[repr(simd)]` will give a struct consisting of a homogeneous series of machine\n+types (i.e., `u8`, `i32`, etc) a representation that permits vectorization via\n+SIMD. This doesn't make much sense for enums since they don't consist of a\n+single list of data."}, {"sha": "1af9a3735fe1a67c2f04e96e8174938101ec043f", "filename": "src/librustc_error_codes/error_codes/E0518.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0518.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0518.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0518.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,23 @@\n+This error indicates that an `#[inline(..)]` attribute was incorrectly placed\n+on something other than a function or method.\n+\n+Examples of erroneous code:\n+\n+```compile_fail,E0518\n+#[inline(always)]\n+struct Foo;\n+\n+#[inline(never)]\n+impl Foo {\n+    // ...\n+}\n+```\n+\n+`#[inline]` hints the compiler whether or not to attempt to inline a method or\n+function. By default, the compiler does a pretty good job of figuring this out\n+itself, but if you feel the need for annotations, `#[inline(always)]` and\n+`#[inline(never)]` can override or force the compiler's decision.\n+\n+If you wish to apply this attribute to all methods in an impl, manually annotate\n+each method; it is not possible to annotate the entire impl with an `#[inline]`\n+attribute."}, {"sha": "e8a2b4da080546abcf9ee5255ce06bb5d535d118", "filename": "src/librustc_error_codes/error_codes/E0520.md", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0520.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0520.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0520.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,59 @@\n+A non-default implementation was already made on this type so it cannot be\n+specialized further. Erroneous code example:\n+\n+```compile_fail,E0520\n+#![feature(specialization)]\n+\n+trait SpaceLlama {\n+    fn fly(&self);\n+}\n+\n+// applies to all T\n+impl<T> SpaceLlama for T {\n+    default fn fly(&self) {}\n+}\n+\n+// non-default impl\n+// applies to all `Clone` T and overrides the previous impl\n+impl<T: Clone> SpaceLlama for T {\n+    fn fly(&self) {}\n+}\n+\n+// since `i32` is clone, this conflicts with the previous implementation\n+impl SpaceLlama for i32 {\n+    default fn fly(&self) {}\n+    // error: item `fly` is provided by an `impl` that specializes\n+    //        another, but the item in the parent `impl` is not marked\n+    //        `default` and so it cannot be specialized.\n+}\n+```\n+\n+Specialization only allows you to override `default` functions in\n+implementations.\n+\n+To fix this error, you need to mark all the parent implementations as default.\n+Example:\n+\n+```\n+#![feature(specialization)]\n+\n+trait SpaceLlama {\n+    fn fly(&self);\n+}\n+\n+// applies to all T\n+impl<T> SpaceLlama for T {\n+    default fn fly(&self) {} // This is a parent implementation.\n+}\n+\n+// applies to all `Clone` T; overrides the previous impl\n+impl<T: Clone> SpaceLlama for T {\n+    default fn fly(&self) {} // This is a parent implementation but was\n+                             // previously not a default one, causing the error\n+}\n+\n+// applies to i32, overrides the previous two impls\n+impl SpaceLlama for i32 {\n+    fn fly(&self) {} // And now that's ok!\n+}\n+```"}, {"sha": "e4756c384c495ffc02fc3e0972e7dbed1f47ab69", "filename": "src/librustc_error_codes/error_codes/E0522.md", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0522.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,14 @@\n+The lang attribute is intended for marking special items that are built-in to\n+Rust itself. This includes special traits (like `Copy` and `Sized`) that affect\n+how the compiler behaves, as well as special functions that may be automatically\n+invoked (such as the handler for out-of-bounds accesses when indexing a slice).\n+Erroneous code example:\n+\n+```compile_fail,E0522\n+#![feature(lang_items)]\n+\n+#[lang = \"cookie\"]\n+fn cookie() -> ! { // error: definition of an unknown language item: `cookie`\n+    loop {}\n+}\n+```"}, {"sha": "bab241b5a9510db11148d74bcbe599503524c914", "filename": "src/librustc_error_codes/error_codes/E0524.md", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0524.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0524.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0524.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,60 @@\n+A variable which requires unique access is being used in more than one closure\n+at the same time.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0524\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    let mut c1 = || set(x);\n+    let mut c2 = || set(x); // error!\n+\n+    c2();\n+    c1();\n+}\n+```\n+\n+To solve this issue, multiple solutions are available. First, is it required\n+for this variable to be used in more than one closure at a time? If it is the\n+case, use reference counted types such as `Rc` (or `Arc` if it runs\n+concurrently):\n+\n+```\n+use std::rc::Rc;\n+use std::cell::RefCell;\n+\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    let x = Rc::new(RefCell::new(x));\n+    let y = Rc::clone(&x);\n+    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\n+    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\n+\n+    c2();\n+    c1();\n+}\n+```\n+\n+If not, just run closures one at a time:\n+\n+```\n+fn set(x: &mut isize) {\n+    *x += 4;\n+}\n+\n+fn dragoooon(x: &mut isize) {\n+    { // This block isn't necessary since non-lexical lifetimes, it's just to\n+      // make it more clear.\n+        let mut c1 = || set(&mut *x);\n+        c1();\n+    } // `c1` has been dropped here so we're free to use `x` again!\n+    let mut c2 = || set(&mut *x);\n+    c2();\n+}\n+```"}, {"sha": "95e5f362bdea69136ab928da36ff26b39e17d8b3", "filename": "src/librustc_error_codes/error_codes/E0525.md", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0525.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,40 @@\n+A closure was used but didn't implement the expected trait.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0525\n+struct X;\n+\n+fn foo<T>(_: T) {}\n+fn bar<T: Fn(u32)>(_: T) {}\n+\n+fn main() {\n+    let x = X;\n+    let closure = |_| foo(x); // error: expected a closure that implements\n+                              //        the `Fn` trait, but this closure only\n+                              //        implements `FnOnce`\n+    bar(closure);\n+}\n+```\n+\n+In the example above, `closure` is an `FnOnce` closure whereas the `bar`\n+function expected an `Fn` closure. In this case, it's simple to fix the issue,\n+you just have to implement `Copy` and `Clone` traits on `struct X` and it'll\n+be ok:\n+\n+```\n+#[derive(Clone, Copy)] // We implement `Clone` and `Copy` traits.\n+struct X;\n+\n+fn foo<T>(_: T) {}\n+fn bar<T: Fn(u32)>(_: T) {}\n+\n+fn main() {\n+    let x = X;\n+    let closure = |_| foo(x);\n+    bar(closure); // ok!\n+}\n+```\n+\n+To understand better how closures work in Rust, read:\n+https://doc.rust-lang.org/book/ch13-01-closures.html"}, {"sha": "4bff39dc770e0ec4c30ec45b7ff4d1703e2c3f18", "filename": "src/librustc_error_codes/error_codes/E0527.md", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0527.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,28 @@\n+The number of elements in an array or slice pattern differed from the number of\n+elements in the array being matched.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0527\n+let r = &[1, 2, 3, 4];\n+match r {\n+    &[a, b] => { // error: pattern requires 2 elements but array\n+                 //        has 4\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\n+Ensure that the pattern is consistent with the size of the matched\n+array. Additional elements can be matched with `..`:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4];\n+match r {\n+    &[a, b, ..] => { // ok!\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```"}, {"sha": "4b6ea2469919cd61b28b650e5e1e6c2782e66cb3", "filename": "src/librustc_error_codes/error_codes/E0528.md", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0528.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,31 @@\n+An array or slice pattern required more elements than were present in the\n+matched array.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0528\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2];\n+match r {\n+    &[a, b, c, rest @ ..] => { // error: pattern requires at least 3\n+                               //        elements but array has 2\n+        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n+    }\n+}\n+```\n+\n+Ensure that the matched array has at least as many elements as the pattern\n+requires. You can match an arbitrary number of remaining elements with `..`:\n+\n+```\n+#![feature(slice_patterns)]\n+\n+let r = &[1, 2, 3, 4, 5];\n+match r {\n+    &[a, b, c, rest @ ..] => { // ok!\n+        // prints `a=1, b=2, c=3 rest=[4, 5]`\n+        println!(\"a={}, b={}, c={} rest={:?}\", a, b, c, rest);\n+    }\n+}\n+```"}, {"sha": "013f438ba93cde59eb74ca04a560f69f50d691bf", "filename": "src/librustc_error_codes/error_codes/E0529.md", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0529.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0529.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0529.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,24 @@\n+An array or slice pattern was matched against some other type.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0529\n+let r: f32 = 1.0;\n+match r {\n+    [a, b] => { // error: expected an array or slice, found `f32`\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```\n+\n+Ensure that the pattern and the expression being matched on are of consistent\n+types:\n+\n+```\n+let r = [1.0, 2.0];\n+match r {\n+    [a, b] => { // ok!\n+        println!(\"a={}, b={}\", a, b);\n+    }\n+}\n+```"}, {"sha": "502f674fc1d21829aafc608c85d85635262fccb0", "filename": "src/librustc_error_codes/error_codes/E0530.md", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0530.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0530.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0530.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,32 @@\n+A binding shadowed something it shouldn't.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0530\n+static TEST: i32 = 0;\n+\n+let r: (i32, i32) = (0, 0);\n+match r {\n+    TEST => {} // error: match bindings cannot shadow statics\n+}\n+```\n+\n+To fix this error, just change the binding's name in order to avoid shadowing\n+one of the following:\n+\n+* struct name\n+* struct/enum variant\n+* static\n+* const\n+* associated const\n+\n+Fixed example:\n+\n+```\n+static TEST: i32 = 0;\n+\n+let r: (i32, i32) = (0, 0);\n+match r {\n+    something => {} // ok!\n+}\n+```"}, {"sha": "2814046fbddd765982b340555a29c952946086b1", "filename": "src/librustc_error_codes/error_codes/E0531.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0531.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0531.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0531.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,42 @@\n+An unknown tuple struct/variant has been used.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0531\n+let Type(x) = Type(12); // error!\n+match Bar(12) {\n+    Bar(x) => {} // error!\n+    _ => {}\n+}\n+```\n+\n+In most cases, it's either a forgotten import or a typo. However, let's look at\n+how you can have such a type:\n+\n+```edition2018\n+struct Type(u32); // this is a tuple struct\n+\n+enum Foo {\n+    Bar(u32), // this is a tuple variant\n+}\n+\n+use Foo::*; // To use Foo's variant directly, we need to import them in\n+            // the scope.\n+```\n+\n+Either way, it should work fine with our previous code:\n+\n+```edition2018\n+struct Type(u32);\n+\n+enum Foo {\n+    Bar(u32),\n+}\n+use Foo::*;\n+\n+let Type(x) = Type(12); // ok!\n+match Type(12) {\n+    Type(x) => {} // ok!\n+    _ => {}\n+}\n+```"}, {"sha": "6fb315a371655984d7d5bfb00a8bf856b0520079", "filename": "src/librustc_error_codes/error_codes/E0532.md", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0532.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0532.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0532.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,38 @@\n+Pattern arm did not match expected kind.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0532\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        // error: expected unit struct, unit variant or constant, found tuple\n+        //        variant `State::Failed`\n+        State::Failed => println!(\"Failed\"),\n+        _ => ()\n+    }\n+}\n+```\n+\n+To fix this error, ensure the match arm kind is the same as the expression\n+matched.\n+\n+Fixed example:\n+\n+```\n+enum State {\n+    Succeeded,\n+    Failed(String),\n+}\n+\n+fn print_on_failure(state: &State) {\n+    match *state {\n+        State::Failed(ref msg) => println!(\"Failed with {}\", msg),\n+        _ => ()\n+    }\n+}\n+```"}, {"sha": "279d728caae93ff6a5eb0ba8ec6b8f80bf478c07", "filename": "src/librustc_error_codes/error_codes/E0533.md", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0533.md", "raw_url": "https://github.com/rust-lang/rust/raw/82cf3a4486bc882207a09bf0d9e2dea4632781aa/src%2Flibrustc_error_codes%2Ferror_codes%2FE0533.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0533.md?ref=82cf3a4486bc882207a09bf0d9e2dea4632781aa", "patch": "@@ -0,0 +1,34 @@\n+An item which isn't a unit struct, a variant, nor a constant has been used as a\n+match pattern.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0533\n+struct Tortoise;\n+\n+impl Tortoise {\n+    fn turtle(&self) -> u32 { 0 }\n+}\n+\n+match 0u32 {\n+    Tortoise::turtle => {} // Error!\n+    _ => {}\n+}\n+if let Tortoise::turtle = 0u32 {} // Same error!\n+```\n+\n+If you want to match against a value returned by a method, you need to bind the\n+value first:\n+\n+```\n+struct Tortoise;\n+\n+impl Tortoise {\n+    fn turtle(&self) -> u32 { 0 }\n+}\n+\n+match 0u32 {\n+    x if x == Tortoise.turtle() => {} // Bound into `x` then we compare it!\n+    _ => {}\n+}\n+```"}]}