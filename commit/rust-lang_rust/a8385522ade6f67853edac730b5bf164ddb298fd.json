{"sha": "a8385522ade6f67853edac730b5bf164ddb298fd", "node_id": "C_kwDOAAsO6NoAKGE4Mzg1NTIyYWRlNmY2Nzg1M2VkYWM3MzBiNWJmMTY0ZGRiMjk4ZmQ", "commit": {"author": {"name": "Jubilee", "email": "46493976+workingjubilee@users.noreply.github.com", "date": "2021-12-03T01:41:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-03T01:41:30Z"}, "message": "Merge portable-simd#195 - portable-simd:trait-ops\n\nGeneric `core::ops` for `Simd<T, _>`\r\n\r\nIn order to maintain type soundness, we need to be sure we only implement an operation for `Simd<T, _> where T: SimdElement`... and also valid for that operation in general. While we could do this purely parametrically, it is more sound to implement the operators directly for the base scalar type arguments and then use type parameters to extend the operators to the \"higher order\" operations.\r\n\r\nThis implements that strategy and cleans up `simd::ops` into a few submodules:\r\n- assign.rs: `core::ops::*Assign`\r\n- deref.rs:  `core::ops` impls which \"deref\" borrowed versions of the arguments\r\n- unary.rs: encloses the logic for unary operators on `Simd`, as unary ops are much simpler\r\n\r\nThis is possible since everything need not be nested in a single maze of macros anymore. The result simplifies the logic and allows reasoning about what operators are valid based on the expressed trait bounds, and also reduces the size of the trait implementation output in rustdoc, for a huge win of 4 MB off the size of `struct.Simd.html`! This addresses a common user complaint, as the original was over 5.5 MB and capable of crashing browsers!\r\n\r\nThis also carries a fix for a type-inference-related breakage, by removing the autosplatting (vector + scalar binop) impls, as unfortunately the presence of autosplatting was capable of busting type inference. We will likely need to see results from a Crater run before we can understand how to re-land autosplatting.", "tree": {"sha": "da2af55c983fbd25b167fd2322a9bc9d8c430536", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da2af55c983fbd25b167fd2322a9bc9d8c430536"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8385522ade6f67853edac730b5bf164ddb298fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhqXXKCRBK7hj4Ov3rIwAAUl8IAKj3FhgGRpwKNuuDNlP+EWse\nPrXBlvvTr7OpdpX1I4B6vUyw4H/jUEUSh+OiYP+ikIuxOq7DFAB5KEuyZOr7kBWx\nX9d2VeXypMTSUN9nUsc6NEO5cLiSRTnnnYkpsU9lrbQylgROR8L+9C2j9cMpVfYZ\nb+Zwk1pM6+59AO7AaGPZYW2W6uM5me2tx0INSjjt+G6r5HCynYlSbxQ4pRwGW+3Q\nftR6J30Q3y84mj7jBBuxUAA5SS3HuZ9NahFcc7SvgavY7h/M12bmUIhLjd6m3QhD\nmpnOSCHqymoVfeQPYHY2++bOL6yKEAOZxRBIETmoFPK118OMkzn28RlOb14jLu8=\n=D8ZV\n-----END PGP SIGNATURE-----\n", "payload": "tree da2af55c983fbd25b167fd2322a9bc9d8c430536\nparent b2dac7124b2aa3951c7f564015d66f0fff6488aa\nparent 8003b043233213c6f984837d7618f92a6181a875\nauthor Jubilee <46493976+workingjubilee@users.noreply.github.com> 1638495690 -0800\ncommitter GitHub <noreply@github.com> 1638495690 -0800\n\nMerge portable-simd#195 - portable-simd:trait-ops\n\nGeneric `core::ops` for `Simd<T, _>`\r\n\r\nIn order to maintain type soundness, we need to be sure we only implement an operation for `Simd<T, _> where T: SimdElement`... and also valid for that operation in general. While we could do this purely parametrically, it is more sound to implement the operators directly for the base scalar type arguments and then use type parameters to extend the operators to the \"higher order\" operations.\r\n\r\nThis implements that strategy and cleans up `simd::ops` into a few submodules:\r\n- assign.rs: `core::ops::*Assign`\r\n- deref.rs:  `core::ops` impls which \"deref\" borrowed versions of the arguments\r\n- unary.rs: encloses the logic for unary operators on `Simd`, as unary ops are much simpler\r\n\r\nThis is possible since everything need not be nested in a single maze of macros anymore. The result simplifies the logic and allows reasoning about what operators are valid based on the expressed trait bounds, and also reduces the size of the trait implementation output in rustdoc, for a huge win of 4 MB off the size of `struct.Simd.html`! This addresses a common user complaint, as the original was over 5.5 MB and capable of crashing browsers!\r\n\r\nThis also carries a fix for a type-inference-related breakage, by removing the autosplatting (vector + scalar binop) impls, as unfortunately the presence of autosplatting was capable of busting type inference. We will likely need to see results from a Crater run before we can understand how to re-land autosplatting."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8385522ade6f67853edac730b5bf164ddb298fd", "html_url": "https://github.com/rust-lang/rust/commit/a8385522ade6f67853edac730b5bf164ddb298fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8385522ade6f67853edac730b5bf164ddb298fd/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2dac7124b2aa3951c7f564015d66f0fff6488aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2dac7124b2aa3951c7f564015d66f0fff6488aa", "html_url": "https://github.com/rust-lang/rust/commit/b2dac7124b2aa3951c7f564015d66f0fff6488aa"}, {"sha": "8003b043233213c6f984837d7618f92a6181a875", "url": "https://api.github.com/repos/rust-lang/rust/commits/8003b043233213c6f984837d7618f92a6181a875", "html_url": "https://github.com/rust-lang/rust/commit/8003b043233213c6f984837d7618f92a6181a875"}], "stats": {"total": 836, "additions": 377, "deletions": 459}, "files": [{"sha": "43280feebbd67cdd14ed33a08b579881118d3aa2", "filename": "crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -97,7 +97,7 @@ mod nbody {\n         let sun = &mut sun[0];\n         for body in rest {\n             let m_ratio = body.mass / SOLAR_MASS;\n-            sun.v -= body.v * m_ratio;\n+            sun.v -= body.v * Simd::splat(m_ratio);\n         }\n     }\n \n@@ -143,14 +143,14 @@ mod nbody {\n         let mut i = 0;\n         for j in 0..N_BODIES {\n             for k in j + 1..N_BODIES {\n-                let f = r[i] * mag[i];\n-                bodies[j].v -= f * bodies[k].mass;\n-                bodies[k].v += f * bodies[j].mass;\n+                let f = r[i] * Simd::splat(mag[i]);\n+                bodies[j].v -= f * Simd::splat(bodies[k].mass);\n+                bodies[k].v += f * Simd::splat(bodies[j].mass);\n                 i += 1\n             }\n         }\n         for body in bodies {\n-            body.x += dt * body.v\n+            body.x += Simd::splat(dt) * body.v\n         }\n     }\n "}, {"sha": "7435b6df9186098a4e1ce5c3b4f8b61ae0a8316b", "filename": "crates/core_simd/src/math.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmath.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -17,7 +17,7 @@ macro_rules! impl_uint_arith {\n             /// let max = Simd::splat(MAX);\n             /// let unsat = x + max;\n             /// let sat = x.saturating_add(max);\n-            /// assert_eq!(x - 1, unsat);\n+            /// assert_eq!(unsat, Simd::from_array([1, 0, MAX, MAX - 1]));\n             /// assert_eq!(sat, max);\n             /// ```\n             #[inline]\n@@ -37,7 +37,7 @@ macro_rules! impl_uint_arith {\n             /// let max = Simd::splat(MAX);\n             /// let unsat = x - max;\n             /// let sat = x.saturating_sub(max);\n-            /// assert_eq!(unsat, x + 1);\n+            /// assert_eq!(unsat, Simd::from_array([3, 2, 1, 0]));\n             /// assert_eq!(sat, Simd::splat(0));\n             #[inline]\n             pub fn saturating_sub(self, second: Self) -> Self {\n@@ -105,7 +105,7 @@ macro_rules! impl_int_arith {\n             #[inline]\n             pub fn abs(self) -> Self {\n                 const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> SHR;\n+                let m = self >> Simd::splat(SHR);\n                 (self^m) - m\n             }\n \n@@ -128,7 +128,7 @@ macro_rules! impl_int_arith {\n             pub fn saturating_abs(self) -> Self {\n                 // arith shift for -1 or 0 mask based on sign bit, giving 2s complement\n                 const SHR: $ty = <$ty>::BITS as $ty - 1;\n-                let m = self >> SHR;\n+                let m = self >> Simd::splat(SHR);\n                 (self^m).saturating_sub(m)\n             }\n "}, {"sha": "3582c57870b9e83f0420642dc67865d6ed08ec8a", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 19, "deletions": 400, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -1,5 +1,13 @@\n use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::ops::{Add, Mul};\n+use core::ops::{BitAnd, BitOr, BitXor};\n+use core::ops::{Div, Rem, Sub};\n+use core::ops::{Shl, Shr};\n+\n+mod assign;\n+mod deref;\n+mod unary;\n \n impl<I, T, const LANES: usize> core::ops::Index<I> for Simd<T, LANES>\n where\n@@ -57,166 +65,44 @@ macro_rules! impl_ref_ops {\n             $(#[$attrs])*\n             fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n         }\n-\n-        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n-                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for &'_ $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: $rhs) -> Self::Output {\n-                core::ops::$trait::$fn(*$self_tok, $rhs_arg)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for &'_ $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait<$rhs>>::Output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: &$rhs) -> Self::Output {\n-                core::ops::$trait::$fn(*$self_tok, *$rhs_arg)\n-            }\n-        }\n     };\n-\n-    // binary assignment op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            $(#[$attrs:meta])*\n-            fn $fn:ident(&mut $self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) $body:tt\n-        }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            $(#[$attrs])*\n-            fn $fn(&mut $self_tok, $rhs_arg: $rhs_arg_ty) $body\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait<&'_ $rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            $(#[$attrs])*\n-            fn $fn(&mut $self_tok, $rhs_arg: &$rhs_arg_ty) {\n-                core::ops::$trait::$fn($self_tok, *$rhs_arg)\n-            }\n-        }\n-    };\n-\n-    // unary op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            type Output = $output:ty;\n-            fn $fn:ident($self_tok:ident) -> Self::Output $body:tt\n-        }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = $output;\n-            fn $fn($self_tok) -> Self::Output $body\n-        }\n-\n-        impl<const $lanes: usize> core::ops::$trait for &'_ $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = <$type as core::ops::$trait>::Output;\n-            fn $fn($self_tok) -> Self::Output {\n-                core::ops::$trait::$fn(*$self_tok)\n-            }\n-        }\n-    }\n }\n \n /// Automatically implements operators over vectors and scalars for a particular vector.\n macro_rules! impl_op {\n     { impl Add for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Add::add, AddAssign::add_assign, simd_add }\n+        impl_op! { @binary $scalar, Add::add, simd_add }\n     };\n     { impl Sub for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Sub::sub, SubAssign::sub_assign, simd_sub }\n+        impl_op! { @binary $scalar, Sub::sub, simd_sub }\n     };\n     { impl Mul for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Mul::mul, MulAssign::mul_assign, simd_mul }\n+        impl_op! { @binary $scalar, Mul::mul, simd_mul }\n     };\n     { impl Div for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Div::div, DivAssign::div_assign, simd_div }\n+        impl_op! { @binary $scalar, Div::div, simd_div }\n     };\n     { impl Rem for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Rem::rem, RemAssign::rem_assign, simd_rem }\n+        impl_op! { @binary $scalar, Rem::rem, simd_rem }\n     };\n     { impl Shl for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shl::shl, ShlAssign::shl_assign, simd_shl }\n+        impl_op! { @binary $scalar, Shl::shl, simd_shl }\n     };\n     { impl Shr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shr::shr, ShrAssign::shr_assign, simd_shr }\n+        impl_op! { @binary $scalar, Shr::shr, simd_shr }\n     };\n     { impl BitAnd for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitAnd::bitand, BitAndAssign::bitand_assign, simd_and }\n+        impl_op! { @binary $scalar, BitAnd::bitand, simd_and }\n     };\n     { impl BitOr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitOr::bitor, BitOrAssign::bitor_assign, simd_or }\n+        impl_op! { @binary $scalar, BitOr::bitor, simd_or }\n     };\n     { impl BitXor for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitXor::bitxor, BitXorAssign::bitxor_assign, simd_xor }\n-    };\n-\n-    { impl Not for $scalar:ty } => {\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Not for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-                fn not(self) -> Self::Output {\n-                    self ^ Self::splat(!<$scalar>::default())\n-                }\n-            }\n-        }\n-    };\n-\n-    { impl Neg for $scalar:ty } => {\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::Neg for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-                fn neg(self) -> Self::Output {\n-                    unsafe { intrinsics::simd_neg(self) }\n-                }\n-            }\n-        }\n+        impl_op! { @binary $scalar, BitXor::bitxor, simd_xor }\n     };\n \n     // generic binary op with assignment when output is `Self`\n-    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $assign_trait:ident :: $assign_trait_fn:ident, $intrinsic:ident } => {\n+    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $intrinsic:ident } => {\n         impl_ref_ops! {\n             impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n             where\n@@ -232,60 +118,6 @@ macro_rules! impl_op {\n                 }\n             }\n         }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<$scalar> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n-\n-                #[inline]\n-                fn $trait_fn(self, rhs: $scalar) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(self, Self::splat(rhs))\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Simd<$scalar, LANES>> for $scalar\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Simd<$scalar, LANES>;\n-\n-                #[inline]\n-                fn $trait_fn(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                    core::ops::$trait::$trait_fn(Simd::splat(self), rhs)\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<Self> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: Self) {\n-                    unsafe {\n-                        *self = intrinsics::$intrinsic(*self, rhs);\n-                    }\n-                }\n-            }\n-        }\n-\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$assign_trait<$scalar> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                #[inline]\n-                fn $assign_trait_fn(&mut self, rhs: $scalar) {\n-                    core::ops::$assign_trait::$assign_trait_fn(self, Self::splat(rhs));\n-                }\n-            }\n-        }\n     };\n }\n \n@@ -298,7 +130,6 @@ macro_rules! impl_float_ops {\n             impl_op! { impl Mul for $scalar }\n             impl_op! { impl Div for $scalar }\n             impl_op! { impl Rem for $scalar }\n-            impl_op! { impl Neg for $scalar }\n         )*\n     };\n }\n@@ -313,7 +144,6 @@ macro_rules! impl_unsigned_int_ops {\n             impl_op! { impl BitAnd for $scalar }\n             impl_op! { impl BitOr  for $scalar }\n             impl_op! { impl BitXor for $scalar }\n-            impl_op! { impl Not for $scalar }\n \n             // Integers panic on divide by 0\n             impl_ref_ops! {\n@@ -344,67 +174,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn div(self, rhs: $scalar) -> Self::Output {\n-                        if rhs == 0 {\n-                            panic!(\"attempt to divide by zero\");\n-                        }\n-                        if <$scalar>::MIN != 0 &&\n-                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                            rhs == -1 as _ {\n-                                panic!(\"attempt to divide with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_div(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<Simd<$scalar, LANES>> for $scalar\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Simd<$scalar, LANES>;\n-\n-                    #[inline]\n-                    fn div(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                        Simd::splat(self) / rhs\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::DivAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn div_assign(&mut self, rhs: Self) {\n-                        *self = *self / rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::DivAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn div_assign(&mut self, rhs: $scalar) {\n-                        *self = *self / rhs;\n-                    }\n-                }\n-            }\n-\n             // remainder panics on zero divisor\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n@@ -434,67 +203,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: $scalar) -> Self::Output {\n-                        if rhs == 0 {\n-                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                        }\n-                        if <$scalar>::MIN != 0 &&\n-                            self.as_array().iter().any(|x| *x == <$scalar>::MIN) &&\n-                            rhs == -1 as _ {\n-                                panic!(\"attempt to calculate the remainder with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_rem(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<Simd<$scalar, LANES>> for $scalar\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Simd<$scalar, LANES>;\n-\n-                    #[inline]\n-                    fn rem(self, rhs: Simd<$scalar, LANES>) -> Self::Output {\n-                        Simd::splat(self) % rhs\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::RemAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn rem_assign(&mut self, rhs: Self) {\n-                        *self = *self % rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::RemAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn rem_assign(&mut self, rhs: $scalar) {\n-                        *self = *self % rhs;\n-                    }\n-                }\n-            }\n-\n             // shifts panic on overflow\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n@@ -518,49 +226,6 @@ macro_rules! impl_unsigned_int_ops {\n                 }\n             }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shl<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn shl(self, rhs: $scalar) -> Self::Output {\n-                        if invalid_shift_rhs(rhs) {\n-                            panic!(\"attempt to shift left with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_shl(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShlAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shl_assign(&mut self, rhs: Self) {\n-                        *self = *self << rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShlAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shl_assign(&mut self, rhs: $scalar) {\n-                        *self = *self << rhs;\n-                    }\n-                }\n-            }\n-\n             impl_ref_ops! {\n                 impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n                 where\n@@ -582,49 +247,6 @@ macro_rules! impl_unsigned_int_ops {\n                     }\n                 }\n             }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shr<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n-\n-                    #[inline]\n-                    fn shr(self, rhs: $scalar) -> Self::Output {\n-                        if invalid_shift_rhs(rhs) {\n-                            panic!(\"attempt to shift with overflow\");\n-                        }\n-                        let rhs = Self::splat(rhs);\n-                        unsafe { intrinsics::simd_shr(self, rhs) }\n-                    }\n-                }\n-            }\n-\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShrAssign<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shr_assign(&mut self, rhs: Self) {\n-                        *self = *self >> rhs;\n-                    }\n-                }\n-            }\n-\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::ShrAssign<$scalar> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    #[inline]\n-                    fn shr_assign(&mut self, rhs: $scalar) {\n-                        *self = *self >> rhs;\n-                    }\n-                }\n-            }\n         )*\n     };\n }\n@@ -633,9 +255,6 @@ macro_rules! impl_unsigned_int_ops {\n macro_rules! impl_signed_int_ops {\n     { $($scalar:ty),* } => {\n         impl_unsigned_int_ops! { $($scalar),* }\n-        $( // scalar\n-            impl_op! { impl Neg for $scalar }\n-        )*\n     };\n }\n "}, {"sha": "d2b48614fc96671296ac0a3380ec8232ee3dbb8f", "filename": "crates/core_simd/src/ops/assign.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops%2Fassign.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -0,0 +1,124 @@\n+//! Assignment operators\n+use super::*;\n+use core::ops::{AddAssign, MulAssign}; // commutative binary op-assignment\n+use core::ops::{BitAndAssign, BitOrAssign, BitXorAssign}; // commutative bit binary op-assignment\n+use core::ops::{DivAssign, RemAssign, SubAssign}; // non-commutative binary op-assignment\n+use core::ops::{ShlAssign, ShrAssign}; // non-commutative bit binary op-assignment\n+\n+// Arithmetic\n+\n+macro_rules! assign_ops {\n+    ($(impl<T, U, const LANES: usize> $assignTrait:ident<U> for Simd<T, LANES>\n+        where\n+            Self: $trait:ident,\n+        {\n+            fn $assign_call:ident(rhs: U) {\n+                $call:ident\n+            }\n+        })*) => {\n+        $(impl<T, U, const LANES: usize> $assignTrait<U> for Simd<T, LANES>\n+        where\n+            Self: $trait<U, Output = Self>,\n+            T: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            #[inline]\n+            fn $assign_call(&mut self, rhs: U) {\n+                *self = self.$call(rhs);\n+            }\n+        })*\n+    }\n+}\n+\n+assign_ops! {\n+    // Arithmetic\n+    impl<T, U, const LANES: usize> AddAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Add,\n+    {\n+        fn add_assign(rhs: U) {\n+            add\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> MulAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Mul,\n+    {\n+        fn mul_assign(rhs: U) {\n+            mul\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> SubAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Sub,\n+    {\n+        fn sub_assign(rhs: U) {\n+            sub\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> DivAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Div,\n+    {\n+        fn div_assign(rhs: U) {\n+            div\n+        }\n+    }\n+    impl<T, U, const LANES: usize> RemAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Rem,\n+    {\n+        fn rem_assign(rhs: U) {\n+            rem\n+        }\n+    }\n+\n+    // Bitops\n+    impl<T, U, const LANES: usize> BitAndAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitAnd,\n+    {\n+        fn bitand_assign(rhs: U) {\n+            bitand\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> BitOrAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitOr,\n+    {\n+        fn bitor_assign(rhs: U) {\n+            bitor\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> BitXorAssign<U> for Simd<T, LANES>\n+    where\n+        Self: BitXor,\n+    {\n+        fn bitxor_assign(rhs: U) {\n+            bitxor\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> ShlAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Shl,\n+    {\n+        fn shl_assign(rhs: U) {\n+            shl\n+        }\n+    }\n+\n+    impl<T, U, const LANES: usize> ShrAssign<U> for Simd<T, LANES>\n+    where\n+        Self: Shr,\n+    {\n+        fn shr_assign(rhs: U) {\n+            shr\n+        }\n+    }\n+}"}, {"sha": "9883a74c92d678cfff70473623468168772d6112", "filename": "crates/core_simd/src/ops/deref.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops%2Fderef.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -0,0 +1,124 @@\n+//! This module hacks in \"implicit deref\" for Simd's operators.\n+//! Ideally, Rust would take care of this itself,\n+//! and method calls usually handle the LHS implicitly.\n+//! But this is not the case with arithmetic ops.\n+use super::*;\n+\n+macro_rules! deref_lhs {\n+    (impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        }) => {\n+        impl<T, const LANES: usize> $trait<$simd> for &$simd\n+        where\n+            T: SimdElement,\n+            $simd: $trait<$simd, Output = $simd>,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Simd<T, LANES>;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+            fn $call(self, rhs: $simd) -> Self::Output {\n+                (*self).$call(rhs)\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! deref_rhs {\n+    (impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        }) => {\n+        impl<T, const LANES: usize> $trait<&$simd> for $simd\n+        where\n+            T: SimdElement,\n+            $simd: $trait<$simd, Output = $simd>,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Simd<T, LANES>;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+            fn $call(self, rhs: &$simd) -> Self::Output {\n+                self.$call(*rhs)\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! deref_ops {\n+    ($(impl<T, const LANES: usize> $trait:ident for $simd:ty {\n+            fn $call:ident\n+        })*) => {\n+        $(\n+            deref_rhs! {\n+                impl<T, const LANES: usize> $trait for $simd {\n+                    fn $call\n+                }\n+            }\n+            deref_lhs! {\n+                impl<T, const LANES: usize> $trait for $simd {\n+                    fn $call\n+                }\n+            }\n+            impl<'lhs, 'rhs, T, const LANES: usize> $trait<&'rhs $simd> for &'lhs $simd\n+            where\n+                T: SimdElement,\n+                $simd: $trait<$simd, Output = $simd>,\n+                LaneCount<LANES>: SupportedLaneCount,\n+            {\n+                type Output = $simd;\n+\n+                #[inline]\n+                #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+                fn $call(self, rhs: &$simd) -> Self::Output {\n+                    (*self).$call(*rhs)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+deref_ops! {\n+    // Arithmetic\n+    impl<T, const LANES: usize> Add for Simd<T, LANES> {\n+        fn add\n+    }\n+\n+    impl<T, const LANES: usize> Mul for Simd<T, LANES> {\n+        fn mul\n+    }\n+\n+    impl<T, const LANES: usize> Sub for Simd<T, LANES> {\n+        fn sub\n+    }\n+\n+    impl<T, const LANES: usize> Div for Simd<T, LANES> {\n+        fn div\n+    }\n+\n+    impl<T, const LANES: usize> Rem for Simd<T, LANES> {\n+        fn rem\n+    }\n+\n+    // Bitops\n+    impl<T, const LANES: usize> BitAnd for Simd<T, LANES> {\n+        fn bitand\n+    }\n+\n+    impl<T, const LANES: usize> BitOr for Simd<T, LANES> {\n+        fn bitor\n+    }\n+\n+    impl<T, const LANES: usize> BitXor for Simd<T, LANES> {\n+        fn bitxor\n+    }\n+\n+    impl<T, const LANES: usize> Shl for Simd<T, LANES> {\n+        fn shl\n+    }\n+\n+    impl<T, const LANES: usize> Shr for Simd<T, LANES> {\n+        fn shr\n+    }\n+}"}, {"sha": "4ebea560fc65fa51e3d7f0594506e03a0c27adfa", "filename": "crates/core_simd/src/ops/unary.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops%2Funary.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -0,0 +1,77 @@\n+use crate::simd::intrinsics;\n+use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n+use core::ops::{Neg, Not}; // unary ops\n+\n+macro_rules! neg {\n+    ($(impl<const LANES: usize> Neg for Simd<$scalar:ty, LANES>)*) => {\n+        $(impl<const LANES: usize> Neg for Simd<$scalar, LANES>\n+        where\n+            $scalar: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Self;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the input\"]\n+            fn neg(self) -> Self::Output {\n+                unsafe { intrinsics::simd_neg(self) }\n+            }\n+        })*\n+    }\n+}\n+\n+neg! {\n+    impl<const LANES: usize> Neg for Simd<f32, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<f64, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i8, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i16, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i32, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<i64, LANES>\n+\n+    impl<const LANES: usize> Neg for Simd<isize, LANES>\n+}\n+\n+macro_rules! not {\n+    ($(impl<const LANES: usize> Not for Simd<$scalar:ty, LANES>)*) => {\n+        $(impl<const LANES: usize> Not for Simd<$scalar, LANES>\n+        where\n+            $scalar: SimdElement,\n+            LaneCount<LANES>: SupportedLaneCount,\n+        {\n+            type Output = Self;\n+\n+            #[inline]\n+            #[must_use = \"operator returns a new vector without mutating the input\"]\n+            fn not(self) -> Self::Output {\n+                self ^ (Simd::splat(!(0 as $scalar)))\n+            }\n+        })*\n+    }\n+}\n+\n+not! {\n+    impl<const LANES: usize> Not for Simd<i8, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<i16, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<i32, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<i64, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<isize, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u8, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u16, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u32, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<u64, LANES>\n+\n+    impl<const LANES: usize> Not for Simd<usize, LANES>\n+}"}, {"sha": "c668d9a6eaee35785e7eb84b7bc5a01f7d317bc8", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -23,7 +23,7 @@ where\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n-            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+            mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n     }\n }\n@@ -49,7 +49,7 @@ where\n     pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n             let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n-            mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n+            mem::transmute_copy(&{ x + (addend * Simd::splat(mem::size_of::<T>())) })\n         }\n     }\n }"}, {"sha": "9359da16ee5c7c1a647666598d093697daceeb1f", "filename": "crates/core_simd/tests/autoderef.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Ftests%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Ftests%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fautoderef.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -0,0 +1,22 @@\n+// Test that we handle all our \"auto-deref\" cases correctly.\n+#![feature(portable_simd)]\n+use core_simd::f32x4;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn deref() {\n+    let x = f32x4::splat(1.0);\n+    let y = f32x4::splat(2.0);\n+    let a = &x;\n+    let b = &y;\n+    assert_eq!(f32x4::splat(3.0), x + y);\n+    assert_eq!(f32x4::splat(3.0), x + b);\n+    assert_eq!(f32x4::splat(3.0), a + y);\n+    assert_eq!(f32x4::splat(3.0), a + b);\n+}"}, {"sha": "43ddde4c55e0162db189c5c4270a31695f69f021", "filename": "crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8385522ade6f67853edac730b5bf164ddb298fd/crates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=a8385522ade6f67853edac730b5bf164ddb298fd", "patch": "@@ -38,37 +38,13 @@ macro_rules! impl_binary_op_test {\n                     );\n                 }\n \n-                fn scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n-\n-                fn scalar_lhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n-\n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|_, _| true,\n                     );\n                 }\n-\n-                fn assign_scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n-                        &$scalar_fn,\n-                        &|_, _| true,\n-                    );\n-                }\n             }\n         }\n     };\n@@ -99,37 +75,13 @@ macro_rules! impl_binary_checked_op_test {\n                     );\n                 }\n \n-                fn scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &<Simd<$scalar, LANES> as core::ops::$trait<$scalar>>::$fn,\n-                        &$scalar_fn,\n-                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n-                    );\n-                }\n-\n-                fn scalar_lhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_lhs_elementwise(\n-                        &<$scalar as core::ops::$trait<Simd<$scalar, LANES>>>::$fn,\n-                        &$scalar_fn,\n-                        &|x, y| y.iter().all(|y| $check_fn(x, *y)),\n-                    );\n-                }\n-\n                 fn assign<const LANES: usize>() {\n                     test_helpers::test_binary_elementwise(\n                         &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign>::$fn_assign(&mut a, b); a },\n                         &$scalar_fn,\n                         &|x, y| x.iter().zip(y.iter()).all(|(x, y)| $check_fn(*x, *y)),\n                     )\n                 }\n-\n-                fn assign_scalar_rhs<const LANES: usize>() {\n-                    test_helpers::test_binary_scalar_rhs_elementwise(\n-                        &|mut a, b| { <Simd<$scalar, LANES> as core::ops::$trait_assign<$scalar>>::$fn_assign(&mut a, b); a },\n-                        &$scalar_fn,\n-                        &|x, y| x.iter().all(|x| $check_fn(*x, y)),\n-                    )\n-                }\n             }\n         }\n     };"}]}