{"sha": "af199f2edb0e5a85af7fdd2b8b85173f0928b512", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMTk5ZjJlZGIwZTVhODVhZjdmZGQyYjhiODUxNzNmMDkyOGI1MTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T01:09:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-07-07T01:09:59Z"}, "message": "tutorial: Expand the section on datatypes", "tree": {"sha": "b38da5be0df31660fdbb2a9eaabc538de889ed76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b38da5be0df31660fdbb2a9eaabc538de889ed76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af199f2edb0e5a85af7fdd2b8b85173f0928b512", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af199f2edb0e5a85af7fdd2b8b85173f0928b512", "html_url": "https://github.com/rust-lang/rust/commit/af199f2edb0e5a85af7fdd2b8b85173f0928b512", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af199f2edb0e5a85af7fdd2b8b85173f0928b512/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad05996223d488f6b3ec904868d3424e8ef7ba30", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad05996223d488f6b3ec904868d3424e8ef7ba30", "html_url": "https://github.com/rust-lang/rust/commit/ad05996223d488f6b3ec904868d3424e8ef7ba30"}], "stats": {"total": 88, "additions": 61, "deletions": 27}, "files": [{"sha": "301ca6cf5ccfa476f7f78c25a559270b6bf0f084", "filename": "doc/tutorial.md", "status": "modified", "additions": 61, "deletions": 27, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/af199f2edb0e5a85af7fdd2b8b85173f0928b512/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/af199f2edb0e5a85af7fdd2b8b85173f0928b512/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=af199f2edb0e5a85af7fdd2b8b85173f0928b512", "patch": "@@ -1252,17 +1252,32 @@ fn contains(v: ~[int], elt: int) -> bool {\n \n # Datatypes\n \n-Rust datatypes are, by default, immutable. The core datatypes of Rust\n-are structural records and 'enums' (tagged unions, algebraic data\n-types).\n+The core datatypes of Rust are structural records, enums (tagged\n+unions, algebraic data types), and classes. They are immutable\n+by default.\n \n ~~~~\n type point = {x: float, y: float};\n+\n enum shape {\n     circle(point, float),\n     rectangle(point, point)\n }\n-let my_shape = circle({x: 0.0, y: 0.0}, 10.0);\n+\n+class drawing {\n+    let mut shapes: [shape];\n+\n+    new() {\n+        self.shapes = [];\n+    }\n+\n+    fn add_shape(new_shape: shape) {\n+        self.shapes += [new_shape];\n+    }\n+}\n+\n+let my_drawing = drawing();\n+my_drawing.add_shape(circle({x: 0.0, y: 0.0}, 10.0));\n ~~~~\n \n ## Records\n@@ -1271,12 +1286,10 @@ Rust record types are written `{field1: T1, field2: T2 [, ...]}`,\n where `T1`, `T2`, ... denote types.  Record literals are written in\n the same way, but with expressions instead of types. They are quite\n similar to C structs, and even laid out the same way in memory (so you\n-can read from a Rust struct in C, and vice-versa).\n-\n-The dot operator is used to access record fields (`mypoint.x`).\n+can read from a Rust struct in C, and vice-versa). The dot operator is\n+used to access record fields (`mypoint.x`).\n \n-Fields that you want to mutate must be explicitly marked as such. For\n-example...\n+Fields that you want to mutate must be explicitly marked `mut`.\n \n ~~~~\n type stack = {content: ~[int], mut head: uint};\n@@ -1286,16 +1299,16 @@ With such a type, you can do `mystack.head += 1u`. If `mut` were\n omitted from the type, such an assignment would result in a type\n error.\n \n-To 'update' an immutable record, you use functional record update\n-syntax, by ending a record literal with the keyword `with`:\n+To create a new record based on the value of an existing record\n+you construct it using the `with` keyword:\n \n ~~~~\n let oldpoint = {x: 10f, y: 20f};\n let newpoint = {x: 0f with oldpoint};\n assert newpoint == {x: 0f, y: 20f};\n ~~~~\n \n-This will create a new struct, copying all the fields from `oldpoint`\n+This will create a new record, copying all the fields from `oldpoint`\n into it, except for the ones that are explicitly set in the literal.\n \n Rust record types are *structural*. This means that `{x: float, y:\n@@ -1329,8 +1342,8 @@ the fields of a record, a record pattern may end with `, _` (as in\n \n ## Enums\n \n-Enums are datatypes that have several different representations. For\n-example, the type shown earlier:\n+Enums are datatypes that have several alternate representations. For\n+example, consider the type shown earlier:\n \n ~~~~\n # type point = {x: float, y: float};\n@@ -1352,7 +1365,7 @@ which can be used to construct values of the type (taking arguments of\n the specified types). So `circle({x: 0f, y: 0f}, 10f)` is the way to\n create a new circle.\n \n-Enum variants do not have to have parameters. This, for example, is\n+Enum variants need not have type parameters. This, for example, is\n equivalent to a C enum:\n \n ~~~~\n@@ -1448,8 +1461,8 @@ fn point_from_direction(dir: direction) -> point {\n \n Tuples in Rust behave exactly like records, except that their fields\n do not have names (and can thus not be accessed with dot notation).\n-Tuples can have any arity except for 0 or 1 (though you may see nil,\n-`()`, as the empty tuple if you like).\n+Tuples can have any arity except for 0 or 1 (though you may consider\n+nil, `()`, as the empty tuple if you like).\n \n ~~~~\n let mytup: (int, int, float) = (10, 20, 30.0);\n@@ -1472,11 +1485,15 @@ allocating memory and going through a pointer. But for big records, or\n records with mutable fields, it can be useful to have a single copy on\n the heap, and refer to that through a pointer.\n \n-Rust supports several types of pointers. The simplest is the unsafe\n-pointer, written `*T`, which is a completely unchecked pointer type\n-only used in unsafe code (and thus, in typical Rust code, very\n-rarely). The safe pointer types are `@T` for shared, reference-counted\n-boxes, and `~T`, for uniquely-owned pointers.\n+Rust supports several types of pointers. The safe pointer types are\n+`@T` for shared boxes allocated on the local heap, `~T`, for\n+uniquely-owned boxes allocated on the exchange heap, and `&T`, for\n+borrowed pointers, which may point to any memory, and whose lifetimes\n+are governed by the call stack.\n+\n+Rust also has an unsafe pointer, written `*T`, which is a completely\n+unchecked pointer type only used in unsafe code (and thus, in typical\n+Rust code, very rarely).\n \n All pointer types can be dereferenced with the `*` unary operator.\n \n@@ -1496,20 +1513,32 @@ let y = x; // Copy the pointer, increase refcount\n // When x and y go out of scope, refcount goes to 0, box is freed\n ~~~~\n \n-***Note:*** We may in the future switch to garbage collection, rather\n+***Note:*** We will in the future switch to garbage collection, rather\n than reference counting, for shared boxes.\n \n Shared boxes never cross task boundaries.\n \n ### Unique boxes\n \n-In contrast to shared boxes, unique boxes are not reference counted.\n-Instead, it is statically guaranteed that only a single owner of the\n-box exists at any time.\n+In contrast to shared boxes, unique boxes have a single owner and thus\n+two unique boxes may not refer to the same memory. All unique boxes\n+across all tasks are allocated on a single _exchange heap_, where\n+their uniquely owned nature allows them to be passed between tasks.\n+\n+Because unique boxes are uniquely owned, copying them involves allocating\n+a new unique box and duplicating the contents. Copying unique boxes\n+is expensive so the compiler will complain if you do.\n \n ~~~~\n let x = ~10;\n-let y <- x;\n+let y = x; // error: copying a non-implicitly copyable type\n+~~~~\n+\n+If you really want to copy a unique box you must say so explicitly.\n+\n+~~~~\n+let x = ~10;\n+let y = copy x;\n ~~~~\n \n This is where the 'move' (`<-`) operator comes in. It is similar to\n@@ -1518,6 +1547,11 @@ from `x` to `y`, without violating the constraint that it only has a\n single owner (if you used assignment instead of the move operator, the\n box would, in principle, be copied).\n \n+~~~~\n+let x = ~10;\n+let y <- x;\n+~~~~\n+\n Unique boxes, when they do not contain any shared boxes, can be sent\n to other tasks. The sending task will give up ownership of the box,\n and won't be able to access it afterwards. The receiving task will"}]}