{"sha": "7d82152b21579df144b4a5272e699e24cafb5b97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkODIxNTJiMjE1NzlkZjE0NGI0YTUyNzJlNjk5ZTI0Y2FmYjViOTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-01T10:31:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T10:31:39Z"}, "message": "Merge #5163\n\n5163: Refactor parser tests a bit r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "78b54055f2f5394ce4b75bbaf6f97bad466710ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78b54055f2f5394ce4b75bbaf6f97bad466710ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d82152b21579df144b4a5272e699e24cafb5b97", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/GYLCRBK7hj4Ov3rIwAAdHIIAECPZUIDvJbB9EJ1yetIMjfl\nmfqYy1V1RTXyEnwzSQZiW2GH5bXUyG3Dkk1LwrSWexRWe2BiF6T8a1jikMIr+iqd\nrzMnRsFg72ajCSOojYuGHKlzN3QpPceohypXf3n4UPqv2aPjueOhG1WENUtu0tiM\nGlysxefnFncmxx24/JIEFe8d4l0ILL051vbGx3J30Ff5y4QV3Bpuq+fpAjI5GJNP\ncHvDm0Ql/jFYpFc2NzYZYP7X2pJaGYqki2Ca8GFV88hZ6FvrqvOzZw/JUjNx0n50\nwo1zP6kgGKfL4Q6Ei0nAxf7nT2a8eB/cQG0GkORqQKxFpEuFcVpWqGkRixAa9uw=\n=/SwP\n-----END PGP SIGNATURE-----\n", "payload": "tree 78b54055f2f5394ce4b75bbaf6f97bad466710ae\nparent a9db3d53a0997010f8d3f9c9b14636bef3754f8b\nparent 991850bc3c2ff34fe8b3e63815067307d8d90db6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593599499 +0000\ncommitter GitHub <noreply@github.com> 1593599499 +0000\n\nMerge #5163\n\n5163: Refactor parser tests a bit r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d82152b21579df144b4a5272e699e24cafb5b97", "html_url": "https://github.com/rust-lang/rust/commit/7d82152b21579df144b4a5272e699e24cafb5b97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d82152b21579df144b4a5272e699e24cafb5b97/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9db3d53a0997010f8d3f9c9b14636bef3754f8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9db3d53a0997010f8d3f9c9b14636bef3754f8b", "html_url": "https://github.com/rust-lang/rust/commit/a9db3d53a0997010f8d3f9c9b14636bef3754f8b"}, {"sha": "991850bc3c2ff34fe8b3e63815067307d8d90db6", "url": "https://api.github.com/repos/rust-lang/rust/commits/991850bc3c2ff34fe8b3e63815067307d8d90db6", "html_url": "https://github.com/rust-lang/rust/commit/991850bc3c2ff34fe8b3e63815067307d8d90db6"}], "stats": {"total": 210, "additions": 106, "deletions": 104}, "files": [{"sha": "7b4232497ef9ee431c0e484b4417b4ea712d7f7c", "filename": "crates/ra_syntax/src/tests.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7d82152b21579df144b4a5272e699e24cafb5b97/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d82152b21579df144b4a5272e699e24cafb5b97/crates%2Fra_syntax%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftests.rs?ref=7d82152b21579df144b4a5272e699e24cafb5b97", "patch": "@@ -1,9 +1,11 @@\n use std::{\n+    env,\n     fmt::Write,\n+    fs,\n     path::{Component, Path, PathBuf},\n };\n \n-use test_utils::{collect_rust_files, dir_tests, project_dir, read_text};\n+use test_utils::{assert_eq_text, project_dir};\n \n use crate::{fuzz, tokenize, SourceFile, SyntaxError, TextRange, TextSize, Token};\n \n@@ -200,3 +202,99 @@ where\n         }\n     });\n }\n+\n+/// Calls callback `f` with input code and file paths for each `.rs` file in `test_data_dir`\n+/// subdirectories defined by `paths`.\n+///\n+/// If the content of the matching output file differs from the output of `f()`\n+/// the test will fail.\n+///\n+/// If there is no matching output file it will be created and filled with the\n+/// output of `f()`, but the test will fail.\n+fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], outfile_extension: &str, f: F)\n+where\n+    F: Fn(&str, &Path) -> String,\n+{\n+    for (path, input_code) in collect_rust_files(test_data_dir, paths) {\n+        let actual = f(&input_code, &path);\n+        let path = path.with_extension(outfile_extension);\n+        if !path.exists() {\n+            println!(\"\\nfile: {}\", path.display());\n+            println!(\"No .txt file with expected result, creating...\\n\");\n+            println!(\"{}\\n{}\", input_code, actual);\n+            fs::write(&path, &actual).unwrap();\n+            panic!(\"No expected result\");\n+        }\n+        let expected = read_text(&path);\n+        assert_equal_text(&expected, &actual, &path);\n+    }\n+}\n+\n+/// Collects all `.rs` files from `dir` subdirectories defined by `paths`.\n+fn collect_rust_files(root_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n+    paths\n+        .iter()\n+        .flat_map(|path| {\n+            let path = root_dir.to_owned().join(path);\n+            rust_files_in_dir(&path).into_iter()\n+        })\n+        .map(|path| {\n+            let text = read_text(&path);\n+            (path, text)\n+        })\n+        .collect()\n+}\n+\n+/// Collects paths to all `.rs` files from `dir` in a sorted `Vec<PathBuf>`.\n+fn rust_files_in_dir(dir: &Path) -> Vec<PathBuf> {\n+    let mut acc = Vec::new();\n+    for file in fs::read_dir(&dir).unwrap() {\n+        let file = file.unwrap();\n+        let path = file.path();\n+        if path.extension().unwrap_or_default() == \"rs\" {\n+            acc.push(path);\n+        }\n+    }\n+    acc.sort();\n+    acc\n+}\n+\n+/// Asserts that `expected` and `actual` strings are equal. If they differ only\n+/// in trailing or leading whitespace the test won't fail and\n+/// the contents of `actual` will be written to the file located at `path`.\n+fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n+    if expected == actual {\n+        return;\n+    }\n+    let dir = project_dir();\n+    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n+    if expected.trim() == actual.trim() {\n+        println!(\"whitespace difference, rewriting\");\n+        println!(\"file: {}\\n\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    if env::var(\"UPDATE_EXPECT\").is_ok() {\n+        println!(\"rewriting {}\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n+}\n+\n+/// Read file and normalize newlines.\n+///\n+/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n+///\n+/// ```\n+/// let s = \"\n+/// \";\n+/// assert_eq!(s.as_bytes(), &[10]);\n+/// ```\n+///\n+/// so this should always be correct.\n+fn read_text(path: &Path) -> String {\n+    fs::read_to_string(path)\n+        .unwrap_or_else(|_| panic!(\"File at {:?} should be valid\", path))\n+        .replace(\"\\r\\n\", \"\\n\")\n+}"}, {"sha": "fba5f42810d6baccb3b8fc835d77419ed0dbbdc6", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 5, "deletions": 101, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7d82152b21579df144b4a5272e699e24cafb5b97/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d82152b21579df144b4a5272e699e24cafb5b97/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=7d82152b21579df144b4a5272e699e24cafb5b97", "patch": "@@ -13,7 +13,7 @@ mod fixture;\n use std::{\n     convert::{TryFrom, TryInto},\n     env, fs,\n-    path::{Path, PathBuf},\n+    path::PathBuf,\n };\n \n use serde_json::Value;\n@@ -299,85 +299,6 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n     }\n }\n \n-/// Calls callback `f` with input code and file paths for each `.rs` file in `test_data_dir`\n-/// subdirectories defined by `paths`.\n-///\n-/// If the content of the matching output file differs from the output of `f()`\n-/// the test will fail.\n-///\n-/// If there is no matching output file it will be created and filled with the\n-/// output of `f()`, but the test will fail.\n-pub fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], outfile_extension: &str, f: F)\n-where\n-    F: Fn(&str, &Path) -> String,\n-{\n-    for (path, input_code) in collect_rust_files(test_data_dir, paths) {\n-        let actual = f(&input_code, &path);\n-        let path = path.with_extension(outfile_extension);\n-        if !path.exists() {\n-            println!(\"\\nfile: {}\", path.display());\n-            println!(\"No .txt file with expected result, creating...\\n\");\n-            println!(\"{}\\n{}\", input_code, actual);\n-            fs::write(&path, &actual).unwrap();\n-            panic!(\"No expected result\");\n-        }\n-        let expected = read_text(&path);\n-        assert_equal_text(&expected, &actual, &path);\n-    }\n-}\n-\n-/// Collects all `.rs` files from `dir` subdirectories defined by `paths`.\n-pub fn collect_rust_files(root_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n-    paths\n-        .iter()\n-        .flat_map(|path| {\n-            let path = root_dir.to_owned().join(path);\n-            rust_files_in_dir(&path).into_iter()\n-        })\n-        .map(|path| {\n-            let text = read_text(&path);\n-            (path, text)\n-        })\n-        .collect()\n-}\n-\n-/// Collects paths to all `.rs` files from `dir` in a sorted `Vec<PathBuf>`.\n-fn rust_files_in_dir(dir: &Path) -> Vec<PathBuf> {\n-    let mut acc = Vec::new();\n-    for file in fs::read_dir(&dir).unwrap() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if path.extension().unwrap_or_default() == \"rs\" {\n-            acc.push(path);\n-        }\n-    }\n-    acc.sort();\n-    acc\n-}\n-\n-/// Returns the path to the root directory of `rust-analyzer` project.\n-pub fn project_dir() -> PathBuf {\n-    let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n-}\n-\n-/// Read file and normalize newlines.\n-///\n-/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n-///\n-/// ```\n-/// let s = \"\n-/// \";\n-/// assert_eq!(s.as_bytes(), &[10]);\n-/// ```\n-///\n-/// so this should always be correct.\n-pub fn read_text(path: &Path) -> String {\n-    fs::read_to_string(path)\n-        .unwrap_or_else(|_| panic!(\"File at {:?} should be valid\", path))\n-        .replace(\"\\r\\n\", \"\\n\")\n-}\n-\n /// Returns `false` if slow tests should not run, otherwise returns `true` and\n /// also creates a file at `./target/.slow_tests_cookie` which serves as a flag\n /// that slow tests did run.\n@@ -392,25 +313,8 @@ pub fn skip_slow_tests() -> bool {\n     should_skip\n }\n \n-/// Asserts that `expected` and `actual` strings are equal. If they differ only\n-/// in trailing or leading whitespace the test won't fail and\n-/// the contents of `actual` will be written to the file located at `path`.\n-fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n-    if expected == actual {\n-        return;\n-    }\n-    let dir = project_dir();\n-    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n-    if expected.trim() == actual.trim() {\n-        println!(\"whitespace difference, rewriting\");\n-        println!(\"file: {}\\n\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    if env::var(\"UPDATE_EXPECTATIONS\").is_ok() {\n-        println!(\"rewriting {}\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n+/// Returns the path to the root directory of `rust-analyzer` project.\n+pub fn project_dir() -> PathBuf {\n+    let dir = env!(\"CARGO_MANIFEST_DIR\");\n+    PathBuf::from(dir).parent().unwrap().parent().unwrap().to_owned()\n }"}, {"sha": "f87462400473135e14c03cf4f10896f1c492b1ac", "filename": "docs/dev/README.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7d82152b21579df144b4a5272e699e24cafb5b97/docs%2Fdev%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7d82152b21579df144b4a5272e699e24cafb5b97/docs%2Fdev%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2FREADME.md?ref=7d82152b21579df144b4a5272e699e24cafb5b97", "patch": "@@ -361,10 +361,10 @@ There are two kinds of tests:\n The purpose of inline tests is not to achieve full coverage by test cases, but to explain to the reader of the code what each particular `if` and `match` is responsible for.\n If you are tempted to add a large inline test, it might be a good idea to leave only the simplest example in place, and move the test to a manual `parser/ok` test.\n \n-To update test data, run with `UPDATE_EXPECTATIONS` variable:\n+To update test data, run with `UPDATE_EXPECT` variable:\n \n ```bash\n-env UPDATE_EXPECTATIONS=1 cargo qt\n+env UPDATE_EXPECT=1 cargo qt\n ```\n \n After adding a new inline test you need to run `cargo xtest codegen` and also update the test data as described above."}]}