{"sha": "096309e6dc4378e175e524e963332d1a3830ed63", "node_id": "C_kwDOAAsO6NoAKDA5NjMwOWU2ZGM0Mzc4ZTE3NWU1MjRlOTYzMzMyZDFhMzgzMGVkNjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T21:56:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-24T21:56:17Z"}, "message": "Auto merge of #111919 - matthiaskrgr:rollup-8qcdp0q, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #111121 (Work around `rust-analyzer` false-positive type errors)\n - #111759 (Leverage the interval property to precompute borrow kill points.)\n - #111841 (Run AST validation on match guards correctly)\n - #111862 (Split out opaque collection from from `type_of`)\n - #111863 (Don't skip mir typeck if body has errors)\n - #111903 (Migrate GUI colors test to original CSS color format)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0efcfd614f5003df236d749c926e69a084883de8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0efcfd614f5003df236d749c926e69a084883de8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/096309e6dc4378e175e524e963332d1a3830ed63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/096309e6dc4378e175e524e963332d1a3830ed63", "html_url": "https://github.com/rust-lang/rust/commit/096309e6dc4378e175e524e963332d1a3830ed63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/096309e6dc4378e175e524e963332d1a3830ed63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c373194cb6d882dc455a588bcc29c92a96b50252", "url": "https://api.github.com/repos/rust-lang/rust/commits/c373194cb6d882dc455a588bcc29c92a96b50252", "html_url": "https://github.com/rust-lang/rust/commit/c373194cb6d882dc455a588bcc29c92a96b50252"}, {"sha": "0cc987fae2e4f39edb3dfe3384f03cf22824f41a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cc987fae2e4f39edb3dfe3384f03cf22824f41a", "html_url": "https://github.com/rust-lang/rust/commit/0cc987fae2e4f39edb3dfe3384f03cf22824f41a"}], "stats": {"total": 1089, "additions": 661, "deletions": 428}, "files": [{"sha": "3a210dc34f60a41999c68aaf1b4ad4555794c523", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -736,11 +736,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         this.visit_expr(&arm.body);\n                         this.visit_pat(&arm.pat);\n                         walk_list!(this, visit_attribute, &arm.attrs);\n-                        if let Some(guard) = &arm.guard && let ExprKind::Let(_, guard_expr, _) = &guard.kind {\n+                        if let Some(guard) = &arm.guard {\n                             this.with_let_management(None, |this, _| {\n-                                this.visit_expr(guard_expr)\n+                                this.visit_expr(guard)\n                             });\n-                            return;\n                         }\n                     }\n                 }"}, {"sha": "68ef790ac26f8fe0af263023379660a2e2c85064", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -156,10 +156,10 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n         &mut self,\n         borrow_index: BorrowIndex,\n         borrow_region: RegionVid,\n-        location: Location,\n+        first_location: Location,\n     ) {\n         // We visit one BB at a time. The complication is that we may start in the\n-        // middle of the first BB visited (the one containing `location`), in which\n+        // middle of the first BB visited (the one containing `first_location`), in which\n         // case we may have to later on process the first part of that BB if there\n         // is a path back to its start.\n \n@@ -168,61 +168,58 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n         // `visited` once they are added to `stack`, before they are actually\n         // processed, because this avoids the need to look them up again on\n         // completion.\n-        self.visited.insert(location.block);\n+        self.visited.insert(first_location.block);\n \n-        let mut first_lo = location.statement_index;\n-        let first_hi = self.body[location.block].statements.len();\n+        let first_block = first_location.block;\n+        let mut first_lo = first_location.statement_index;\n+        let first_hi = self.body[first_block].statements.len();\n \n-        self.visit_stack.push(StackEntry { bb: location.block, lo: first_lo, hi: first_hi });\n+        self.visit_stack.push(StackEntry { bb: first_block, lo: first_lo, hi: first_hi });\n \n-        while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n-            // If we process the first part of the first basic block (i.e. we encounter that block\n-            // for the second time), we no longer have to visit its successors again.\n-            let mut finished_early = bb == location.block && hi != first_hi;\n-            for i in lo..=hi {\n-                let location = Location { block: bb, statement_index: i };\n+        'preorder: while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n+            if let Some(kill_stmt) =\n+                self.regioncx.first_non_contained_inclusive(borrow_region, bb, lo, hi)\n+            {\n+                let kill_location = Location { block: bb, statement_index: kill_stmt };\n                 // If region does not contain a point at the location, then add to list and skip\n                 // successor locations.\n-                if !self.regioncx.region_contains(borrow_region, location) {\n-                    debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-                    self.borrows_out_of_scope_at_location\n-                        .entry(location)\n-                        .or_default()\n-                        .push(borrow_index);\n-                    finished_early = true;\n-                    break;\n-                }\n+                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, kill_location);\n+                self.borrows_out_of_scope_at_location\n+                    .entry(kill_location)\n+                    .or_default()\n+                    .push(borrow_index);\n+                continue 'preorder;\n             }\n \n-            if !finished_early {\n-                // Add successor BBs to the work list, if necessary.\n-                let bb_data = &self.body[bb];\n-                debug_assert!(hi == bb_data.statements.len());\n-                for succ_bb in bb_data.terminator().successors() {\n-                    if !self.visited.insert(succ_bb) {\n-                        if succ_bb == location.block && first_lo > 0 {\n-                            // `succ_bb` has been seen before. If it wasn't\n-                            // fully processed, add its first part to `stack`\n-                            // for processing.\n-                            self.visit_stack.push(StackEntry {\n-                                bb: succ_bb,\n-                                lo: 0,\n-                                hi: first_lo - 1,\n-                            });\n-\n-                            // And update this entry with 0, to represent the\n-                            // whole BB being processed.\n-                            first_lo = 0;\n-                        }\n-                    } else {\n-                        // succ_bb hasn't been seen before. Add it to\n-                        // `stack` for processing.\n-                        self.visit_stack.push(StackEntry {\n-                            bb: succ_bb,\n-                            lo: 0,\n-                            hi: self.body[succ_bb].statements.len(),\n-                        });\n+            // If we process the first part of the first basic block (i.e. we encounter that block\n+            // for the second time), we no longer have to visit its successors again.\n+            if bb == first_block && hi != first_hi {\n+                continue;\n+            }\n+\n+            // Add successor BBs to the work list, if necessary.\n+            let bb_data = &self.body[bb];\n+            debug_assert!(hi == bb_data.statements.len());\n+            for succ_bb in bb_data.terminator().successors() {\n+                if !self.visited.insert(succ_bb) {\n+                    if succ_bb == first_block && first_lo > 0 {\n+                        // `succ_bb` has been seen before. If it wasn't\n+                        // fully processed, add its first part to `stack`\n+                        // for processing.\n+                        self.visit_stack.push(StackEntry { bb: succ_bb, lo: 0, hi: first_lo - 1 });\n+\n+                        // And update this entry with 0, to represent the\n+                        // whole BB being processed.\n+                        first_lo = 0;\n                     }\n+                } else {\n+                    // succ_bb hasn't been seen before. Add it to\n+                    // `stack` for processing.\n+                    self.visit_stack.push(StackEntry {\n+                        bb: succ_bb,\n+                        lo: 0,\n+                        hi: self.body[succ_bb].statements.len(),\n+                    });\n                 }\n             }\n         }"}, {"sha": "3be06a94bc0b83cbf31c36f96699a80ea84182fd", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    BasicBlock, Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n     ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n     TerminatorKind,\n };\n@@ -598,6 +598,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.contains(scc, p)\n     }\n \n+    /// Returns the lowest statement index in `start..=end` which is not contained by `r`.\n+    ///\n+    /// Panics if called before `solve()` executes.\n+    pub(crate) fn first_non_contained_inclusive(\n+        &self,\n+        r: RegionVid,\n+        block: BasicBlock,\n+        start: usize,\n+        end: usize,\n+    ) -> Option<usize> {\n+        let scc = self.constraint_sccs.scc(r);\n+        self.scc_values.first_non_contained_inclusive(scc, block, start, end)\n+    }\n+\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n         let scc = self.constraint_sccs.scc(r);"}, {"sha": "60ddf9ebaea96b732d96274c58abf59fb8dd8fab", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -283,6 +283,22 @@ impl<N: Idx> RegionValues<N> {\n         elem.contained_in_row(self, r)\n     }\n \n+    /// Returns the lowest statement index in `start..=end` which is not contained by `r`.\n+    pub(crate) fn first_non_contained_inclusive(\n+        &self,\n+        r: N,\n+        block: BasicBlock,\n+        start: usize,\n+        end: usize,\n+    ) -> Option<usize> {\n+        let row = self.points.row(r)?;\n+        let block = self.elements.entry_point(block);\n+        let start = block.plus(start);\n+        let end = block.plus(end);\n+        let first_unset = row.first_unset_in(start..=end)?;\n+        Some(first_unset.index() - block.index())\n+    }\n+\n     /// `self[to] |= values[from]`, essentially: that is, take all the\n     /// elements for the region `from` from `values` and add them to\n     /// the region `to` in `self`."}, {"sha": "b42d5c3d18c97795b4f707018afe2961f5521680", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -183,17 +183,10 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &mut borrowck_context,\n     );\n \n-    let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, promoted);\n-        verifier.visit_body(&body);\n-        verifier.errors_reported\n-    };\n-\n-    if !errors_reported {\n-        // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(body);\n-    }\n+    let mut verifier = TypeVerifier::new(&mut checker, promoted);\n+    verifier.visit_body(&body);\n \n+    checker.typeck_mir(body);\n     checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n     checker.check_signature_annotation(&body);\n \n@@ -294,7 +287,6 @@ struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     promoted: &'b IndexSlice<Promoted, Body<'tcx>>,\n     last_span: Span,\n-    errors_reported: bool,\n }\n \n impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n@@ -383,13 +375,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         };\n                     };\n \n-                    if !self.errors_reported {\n-                        let promoted_body = &self.promoted[promoted];\n-                        self.sanitize_promoted(promoted_body, location);\n+                    let promoted_body = &self.promoted[promoted];\n+                    self.sanitize_promoted(promoted_body, location);\n \n-                        let promoted_ty = promoted_body.return_ty();\n-                        check_err(self, promoted_body, ty, promoted_ty);\n-                    }\n+                    let promoted_ty = promoted_body.return_ty();\n+                    check_err(self, promoted_body, ty, promoted_ty);\n                 } else {\n                     self.cx.ascribe_user_type(\n                         constant.literal.ty(),\n@@ -483,9 +473,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         for local_decl in &body.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }\n-        if self.errors_reported {\n-            return;\n-        }\n         self.super_body(body);\n     }\n }\n@@ -495,7 +482,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n         promoted: &'b IndexSlice<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n+        TypeVerifier { promoted, last_span: cx.body.span, cx }\n     }\n \n     fn body(&self) -> &Body<'tcx> {\n@@ -529,7 +516,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n                 if let Err(guar) = place_ty.ty.error_reported() {\n-                    assert!(self.errors_reported);\n                     return PlaceTy::from_ty(self.tcx().ty_error(guar));\n                 }\n             }\n@@ -593,10 +579,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         self.visit_body(&promoted_body);\n \n-        if !self.errors_reported {\n-            // if verifier failed, don't do further checks to avoid ICEs\n-            self.cx.typeck_mir(promoted_body);\n-        }\n+        self.cx.typeck_mir(promoted_body);\n \n         self.cx.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n@@ -762,7 +745,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     }\n \n     fn error(&mut self) -> Ty<'tcx> {\n-        self.errors_reported = true;\n         self.tcx().ty_error_misc()\n     }\n "}, {"sha": "8e082d3c5328b786faf1e5d07767072b278d9503", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 305, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -1,10 +1,7 @@\n use rustc_errors::{Applicability, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::intravisit;\n-use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{HirId, Node};\n-use rustc_middle::hir::nested_filter;\n+use rustc_hir::HirId;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n@@ -14,7 +11,8 @@ use rustc_span::{Span, DUMMY_SP};\n \n use super::ItemCtxt;\n use super::{bad_placeholder, is_suggestable_infer_ty};\n-use crate::errors::UnconstrainedOpaqueType;\n+\n+mod opaque;\n \n fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n     use hir::*;\n@@ -429,7 +427,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin: hir::OpaqueTyOrigin::TyAlias { .. },\n                     ..\n-                }) => find_opaque_ty_constraints_for_tait(tcx, def_id),\n+                }) => opaque::find_opaque_ty_constraints_for_tait(tcx, def_id),\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin:\n@@ -443,7 +441,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                             \"tried to get type of this RPITIT with no definition\"\n                         );\n                     }\n-                    find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n+                    opaque::find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n                 }\n                 ItemKind::Trait(..)\n                 | ItemKind::TraitAlias(..)\n@@ -502,304 +500,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n     ty::EarlyBinder(output)\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n-/// laid for \"higher-order pattern unification\".\n-/// This ensures that inference is tractable.\n-/// In particular, definitions of opaque types can only use other generics as arguments,\n-/// and they cannot repeat an argument. Example:\n-///\n-/// ```ignore (illustrative)\n-/// type Foo<A, B> = impl Bar<A, B>;\n-///\n-/// // Okay -- `Foo` is applied to two distinct, generic types.\n-/// fn a<T, U>() -> Foo<T, U> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to `T` twice.\n-/// fn b<T>() -> Foo<T, T> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to a non-generic type.\n-/// fn b<T>() -> Foo<T, u32> { .. }\n-/// ```\n-///\n-fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    struct ConstraintLocator<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        /// def_id of the opaque type whose defining uses are being checked\n-        def_id: LocalDefId,\n-\n-        /// as we walk the defining uses, we are checking that all of them\n-        /// define the same hidden type. This variable is set to `Some`\n-        /// with the first type that we find, and then later types are\n-        /// checked against it (we also carry the span of that first\n-        /// type).\n-        found: Option<ty::OpaqueHiddenType<'tcx>>,\n-\n-        /// In the presence of dead code, typeck may figure out a hidden type\n-        /// while borrowck will not. We collect these cases here and check at\n-        /// the end that we actually found a type that matches (modulo regions).\n-        typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n-    }\n-\n-    impl ConstraintLocator<'_> {\n-        #[instrument(skip(self), level = \"debug\")]\n-        fn check(&mut self, item_def_id: LocalDefId) {\n-            // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_results(item_def_id) {\n-                debug!(\"no constraint: no typeck results\");\n-                return;\n-            }\n-            // Calling `mir_borrowck` can lead to cycle errors through\n-            // const-checking, avoid calling it if we don't have to.\n-            // ```rust\n-            // type Foo = impl Fn() -> usize; // when computing type for this\n-            // const fn bar() -> Foo {\n-            //     || 0usize\n-            // }\n-            // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n-            // // because we again need to reveal `Foo` so we can check whether the\n-            // // constant does not contain interior mutability.\n-            // ```\n-            let tables = self.tcx.typeck(item_def_id);\n-            if let Some(guar) = tables.tainted_by_errors {\n-                self.found =\n-                    Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n-                return;\n-            }\n-            let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n-                debug!(\"no constraints in typeck results\");\n-                return;\n-            };\n-            if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-                self.typeck_types.push(typeck_hidden_ty);\n-            }\n-\n-            // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n-            debug!(?concrete_opaque_types);\n-            if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n-                debug!(?concrete_type, \"found constraint\");\n-                if let Some(prev) = &mut self.found {\n-                    if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        let guar =\n-                            prev.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n-                        prev.ty = self.tcx.ty_error(guar);\n-                    }\n-                } else {\n-                    self.found = Some(concrete_type);\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n-        type NestedFilter = nested_filter::All;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(closure) = ex.kind {\n-                self.check(closure.def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            self.check(it.owner_id.def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n-\n-    debug!(?scope);\n-\n-    if scope == hir::CRATE_HIR_ID {\n-        tcx.hir().walk_toplevel_module(&mut locator);\n-    } else {\n-        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n-        match tcx.hir().get(scope) {\n-            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n-            // This allows our visitor to process the defining item itself, causing\n-            // it to pick up any 'sibling' defining uses.\n-            //\n-            // For example, this code:\n-            // ```\n-            // fn foo() {\n-            //     type Blah = impl Debug;\n-            //     let my_closure = || -> Blah { true };\n-            // }\n-            // ```\n-            //\n-            // requires us to explicitly process `foo()` in order\n-            // to notice the defining usage of `Blah`.\n-            Node::Item(it) => locator.visit_item(it),\n-            Node::ImplItem(it) => locator.visit_impl_item(it),\n-            Node::TraitItem(it) => locator.visit_trait_item(it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    let Some(hidden) = locator.found else {\n-        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n-            span: tcx.def_span(def_id),\n-            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n-            what: match tcx.hir().get(scope) {\n-                _ if scope == hir::CRATE_HIR_ID => \"module\",\n-                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n-                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n-                _ => \"item\",\n-            },\n-        });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n-            }\n-        }\n-    }\n-\n-    hidden.ty\n-}\n-\n-fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n-    def_id: LocalDefId,\n-    owner_def_id: LocalDefId,\n-) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    struct ConstraintChecker<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        /// def_id of the opaque type whose defining uses are being checked\n-        def_id: LocalDefId,\n-\n-        found: ty::OpaqueHiddenType<'tcx>,\n-    }\n-\n-    impl ConstraintChecker<'_> {\n-        #[instrument(skip(self), level = \"debug\")]\n-        fn check(&self, def_id: LocalDefId) {\n-            // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n-            debug!(?concrete_opaque_types);\n-            for (&def_id, &concrete_type) in concrete_opaque_types {\n-                if def_id != self.def_id {\n-                    // Ignore constraints for other opaque types.\n-                    continue;\n-                }\n-\n-                debug!(?concrete_type, \"found constraint\");\n-\n-                if concrete_type.ty != self.found.ty\n-                    && !(concrete_type, self.found).references_error()\n-                {\n-                    self.found.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintChecker<'tcx> {\n-        type NestedFilter = nested_filter::OnlyBodies;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(closure) = ex.kind {\n-                self.check(closure.def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            self.check(it.owner_id.def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n-\n-    if let Some(concrete) = concrete {\n-        let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n-        debug!(?scope);\n-        let mut locator = ConstraintChecker { def_id, tcx, found: concrete };\n-\n-        match tcx.hir().get(scope) {\n-            Node::Item(it) => intravisit::walk_item(&mut locator, it),\n-            Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n-            Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n-            // Some error in the\n-            // owner fn prevented us from populating\n-            // the `concrete_opaque_types` table.\n-            tcx.ty_error(guar)\n-        } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n-                // We failed to resolve the opaque type or it\n-                // resolves to itself. We interpret this as the\n-                // no values of the hidden type ever being constructed,\n-                // so we can just make the hidden type be `!`.\n-                // For backwards compatibility reasons, we fall back to\n-                // `()` until we the diverging default is changed.\n-                tcx.mk_diverging_default()\n-            })\n-        }\n-    })\n-}\n-\n fn infer_placeholder_type<'a>(\n     tcx: TyCtxt<'a>,\n     def_id: LocalDefId,"}, {"sha": "f7c5b44678f72f0877ceab58f1175f72e1f5c29b", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -0,0 +1,298 @@\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{self as hir, Expr, ImplItem, Item, Node, TraitItem};\n+use rustc_middle::hir::nested_filter;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::errors::UnconstrainedOpaqueType;\n+\n+/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n+/// laid for \"higher-order pattern unification\".\n+/// This ensures that inference is tractable.\n+/// In particular, definitions of opaque types can only use other generics as arguments,\n+/// and they cannot repeat an argument. Example:\n+///\n+/// ```ignore (illustrative)\n+/// type Foo<A, B> = impl Bar<A, B>;\n+///\n+/// // Okay -- `Foo` is applied to two distinct, generic types.\n+/// fn a<T, U>() -> Foo<T, U> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to `T` twice.\n+/// fn b<T>() -> Foo<T, T> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to a non-generic type.\n+/// fn b<T>() -> Foo<T, u32> { .. }\n+/// ```\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n+    let mut locator = TaitConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n+\n+    debug!(?scope);\n+\n+    if scope == hir::CRATE_HIR_ID {\n+        tcx.hir().walk_toplevel_module(&mut locator);\n+    } else {\n+        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n+        match tcx.hir().get(scope) {\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     type Blah = impl Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(it) => locator.visit_item(it),\n+            Node::ImplItem(it) => locator.visit_impl_item(it),\n+            Node::TraitItem(it) => locator.visit_trait_item(it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    let Some(hidden) = locator.found else {\n+        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n+            span: tcx.def_span(def_id),\n+            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+            what: match tcx.hir().get(scope) {\n+                _ if scope == hir::CRATE_HIR_ID => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n+                _ => \"item\",\n+            },\n+        });\n+        return tcx.ty_error(reported);\n+    };\n+\n+    // Only check against typeck if we didn't already error\n+    if !hidden.ty.references_error() {\n+        for concrete_type in locator.typeck_types {\n+            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                && !(concrete_type, hidden).references_error()\n+            {\n+                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+            }\n+        }\n+    }\n+\n+    hidden.ty\n+}\n+\n+struct TaitConstraintLocator<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    /// def_id of the opaque type whose defining uses are being checked\n+    def_id: LocalDefId,\n+\n+    /// as we walk the defining uses, we are checking that all of them\n+    /// define the same hidden type. This variable is set to `Some`\n+    /// with the first type that we find, and then later types are\n+    /// checked against it (we also carry the span of that first\n+    /// type).\n+    found: Option<ty::OpaqueHiddenType<'tcx>>,\n+\n+    /// In the presence of dead code, typeck may figure out a hidden type\n+    /// while borrowck will not. We collect these cases here and check at\n+    /// the end that we actually found a type that matches (modulo regions).\n+    typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n+}\n+\n+impl TaitConstraintLocator<'_> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn check(&mut self, item_def_id: LocalDefId) {\n+        // Don't try to check items that cannot possibly constrain the type.\n+        if !self.tcx.has_typeck_results(item_def_id) {\n+            debug!(\"no constraint: no typeck results\");\n+            return;\n+        }\n+        // Calling `mir_borrowck` can lead to cycle errors through\n+        // const-checking, avoid calling it if we don't have to.\n+        // ```rust\n+        // type Foo = impl Fn() -> usize; // when computing type for this\n+        // const fn bar() -> Foo {\n+        //     || 0usize\n+        // }\n+        // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n+        // // because we again need to reveal `Foo` so we can check whether the\n+        // // constant does not contain interior mutability.\n+        // ```\n+        let tables = self.tcx.typeck(item_def_id);\n+        if let Some(guar) = tables.tainted_by_errors {\n+            self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n+            return;\n+        }\n+        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+            debug!(\"no constraints in typeck results\");\n+            return;\n+        };\n+        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n+            self.typeck_types.push(typeck_hidden_ty);\n+        }\n+\n+        // Use borrowck to get the type with unerased regions.\n+        let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n+        debug!(?concrete_opaque_types);\n+        if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n+            debug!(?concrete_type, \"found constraint\");\n+            if let Some(prev) = &mut self.found {\n+                if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                    let guar = prev.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n+                    prev.ty = self.tcx.ty_error(guar);\n+                }\n+            } else {\n+                self.found = Some(concrete_type);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Closure(closure) = ex.kind {\n+            self.check(closure.def_id);\n+        }\n+        intravisit::walk_expr(self, ex);\n+    }\n+    fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_item(self, it);\n+        }\n+    }\n+    fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_impl_item(self, it);\n+        }\n+    }\n+    fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        self.check(it.owner_id.def_id);\n+        intravisit::walk_trait_item(self, it);\n+    }\n+}\n+\n+pub(super) fn find_opaque_ty_constraints_for_rpit(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    owner_def_id: LocalDefId,\n+) -> Ty<'_> {\n+    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+\n+    if let Some(concrete) = concrete {\n+        let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n+        debug!(?scope);\n+        let mut locator = RpitConstraintChecker { def_id, tcx, found: concrete };\n+\n+        match tcx.hir().get(scope) {\n+            Node::Item(it) => intravisit::walk_item(&mut locator, it),\n+            Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n+            Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n+        let table = tcx.typeck(owner_def_id);\n+        if let Some(guar) = table.tainted_by_errors {\n+            // Some error in the\n+            // owner fn prevented us from populating\n+            // the `concrete_opaque_types` table.\n+            tcx.ty_error(guar)\n+        } else {\n+            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+                // We failed to resolve the opaque type or it\n+                // resolves to itself. We interpret this as the\n+                // no values of the hidden type ever being constructed,\n+                // so we can just make the hidden type be `!`.\n+                // For backwards compatibility reasons, we fall back to\n+                // `()` until we the diverging default is changed.\n+                tcx.mk_diverging_default()\n+            })\n+        }\n+    })\n+}\n+\n+struct RpitConstraintChecker<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    /// def_id of the opaque type whose defining uses are being checked\n+    def_id: LocalDefId,\n+\n+    found: ty::OpaqueHiddenType<'tcx>,\n+}\n+\n+impl RpitConstraintChecker<'_> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn check(&self, def_id: LocalDefId) {\n+        // Use borrowck to get the type with unerased regions.\n+        let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n+        debug!(?concrete_opaque_types);\n+        for (&def_id, &concrete_type) in concrete_opaque_types {\n+            if def_id != self.def_id {\n+                // Ignore constraints for other opaque types.\n+                continue;\n+            }\n+\n+            debug!(?concrete_type, \"found constraint\");\n+\n+            if concrete_type.ty != self.found.ty && !(concrete_type, self.found).references_error()\n+            {\n+                self.found.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for RpitConstraintChecker<'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Closure(closure) = ex.kind {\n+            self.check(closure.def_id);\n+        }\n+        intravisit::walk_expr(self, ex);\n+    }\n+    fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_item(self, it);\n+        }\n+    }\n+    fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_impl_item(self, it);\n+        }\n+    }\n+    fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        self.check(it.owner_id.def_id);\n+        intravisit::walk_trait_item(self, it);\n+    }\n+}"}, {"sha": "9199a78c326a1fb301062c37e42107c1a143a215", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -181,6 +181,30 @@ impl<I: Idx> IntervalSet<I> {\n         self.map.is_empty()\n     }\n \n+    /// Equivalent to `range.iter().find(|i| !self.contains(i))`.\n+    pub fn first_unset_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n+        let start = inclusive_start(range.clone());\n+        let Some(end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return None;\n+        };\n+        if start > end {\n+            return None;\n+        }\n+        let Some(last) = self.map.partition_point(|r| r.0 <= start).checked_sub(1) else {\n+            // All ranges in the map start after the new range's end\n+            return Some(I::new(start as usize));\n+        };\n+        let (_, prev_end) = self.map[last];\n+        if start > prev_end {\n+            Some(I::new(start as usize))\n+        } else if prev_end < end {\n+            Some(I::new(prev_end as usize + 1))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Returns the maximum (last) element present in the set from `range`.\n     pub fn last_set_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n         let start = inclusive_start(range.clone());"}, {"sha": "744111edb84e4992f1cf85853258f849495d00ab", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -118,15 +118,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let category = Category::of(&expr.kind).unwrap();\n         debug!(?category, ?expr.kind);\n         match category {\n-            Category::Constant if let NeedsTemporary::No = needs_temporary || !expr.ty.needs_drop(this.tcx, this.param_env) => {\n+            Category::Constant\n+                if matches!(needs_temporary, NeedsTemporary::No)\n+                    || !expr.ty.needs_drop(this.tcx, this.param_env) =>\n+            {\n                 let constant = this.as_constant(expr);\n                 block.and(Operand::Constant(Box::new(constant)))\n             }\n             Category::Constant | Category::Place | Category::Rvalue(..) => {\n                 let operand = unpack!(block = this.as_temp(block, scope, expr, Mutability::Mut));\n                 // Overwrite temp local info if we have something more interesting to record.\n                 if !matches!(local_info, LocalInfo::Boring) {\n-                    let decl_info = this.local_decls[operand].local_info.as_mut().assert_crate_local();\n+                    let decl_info =\n+                        this.local_decls[operand].local_info.as_mut().assert_crate_local();\n                     if let LocalInfo::Boring | LocalInfo::BlockTailTemp(_) = **decl_info {\n                         **decl_info = local_info;\n                     }"}, {"sha": "6a3d42511ac1bbce6eb2a3cdad5b76e28235f435", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -639,7 +639,7 @@ pub(super) fn dump_coverage_spanview<'tcx>(\n     let def_id = mir_source.def_id();\n \n     let span_viewables = span_viewables(tcx, mir_body, basic_coverage_blocks, &coverage_spans);\n-    let mut file = create_dump_file(tcx, \"html\", false, pass_name, &0, mir_body)\n+    let mut file = create_dump_file(tcx, \"html\", false, pass_name, &0i32, mir_body)\n         .expect(\"Unexpected error creating MIR spanview HTML file\");\n     let crate_name = tcx.crate_name(def_id.krate);\n     let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n@@ -740,7 +740,7 @@ pub(super) fn dump_coverage_graphviz<'tcx>(\n                 .join(\"\\n  \")\n         ));\n     }\n-    let mut file = create_dump_file(tcx, \"dot\", false, pass_name, &0, mir_body)\n+    let mut file = create_dump_file(tcx, \"dot\", false, pass_name, &0i32, mir_body)\n         .expect(\"Unexpected error creating BasicCoverageBlock graphviz DOT file\");\n     graphviz_writer\n         .write_graphviz(tcx, &mut file)"}, {"sha": "bb3d2aaa3dca079102af63fdbf1b2266eb25f6e3", "filename": "tests/rustdoc-gui/stab-badge.goml", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Frustdoc-gui%2Fstab-badge.goml", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Frustdoc-gui%2Fstab-badge.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fstab-badge.goml?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -26,16 +26,16 @@ define-function: (\n \n call-function: (\"check-badge\", {\n     \"theme\": \"ayu\",\n-    \"color\": \"rgb(197, 197, 197)\",\n-    \"background\": \"rgb(49, 69, 89)\",\n+    \"color\": \"#c5c5c5\",\n+    \"background\": \"#314559\",\n })\n call-function: (\"check-badge\", {\n     \"theme\": \"dark\",\n-    \"color\": \"rgb(221, 221, 221)\",\n-    \"background\": \"rgb(49, 69, 89)\",\n+    \"color\": \"#ddd\",\n+    \"background\": \"#314559\",\n })\n call-function: (\"check-badge\", {\n     \"theme\": \"light\",\n-    \"color\": \"rgb(0, 0, 0)\",\n-    \"background\": \"rgb(255, 245, 214)\",\n+    \"color\": \"black\",\n+    \"background\": \"#fff5d6\",\n })"}, {"sha": "3beb20f0a376bf4fd2b4d2ee91d40b91c92864c9", "filename": "tests/ui/rfc-2294-if-let-guard/feature-gate.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -10,10 +10,12 @@ fn _if_let_guard() {\n         () if (let 0 = 1) => {}\n         //~^ ERROR `let` expressions in this position are unstable\n         //~| ERROR expected expression, found `let` statement\n+        //~| ERROR `let` expressions are not supported here\n \n         () if (((let 0 = 1))) => {}\n         //~^ ERROR `let` expressions in this position are unstable\n         //~| ERROR expected expression, found `let` statement\n+        //~| ERROR `let` expressions are not supported here\n \n         () if true && let 0 = 1 => {}\n         //~^ ERROR `if let` guards are experimental\n@@ -26,16 +28,20 @@ fn _if_let_guard() {\n         () if (let 0 = 1) && true => {}\n         //~^ ERROR `let` expressions in this position are unstable\n         //~| ERROR expected expression, found `let` statement\n+        //~| ERROR `let` expressions are not supported here\n \n         () if true && (let 0 = 1) => {}\n         //~^ ERROR `let` expressions in this position are unstable\n         //~| ERROR expected expression, found `let` statement\n+        //~| ERROR `let` expressions are not supported here\n \n         () if (let 0 = 1) && (let 0 = 1) => {}\n         //~^ ERROR `let` expressions in this position are unstable\n         //~| ERROR `let` expressions in this position are unstable\n         //~| ERROR expected expression, found `let` statement\n         //~| ERROR expected expression, found `let` statement\n+        //~| ERROR `let` expressions are not supported here\n+        //~| ERROR `let` expressions are not supported here\n \n         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n         //~^ ERROR `if let` guards are experimental\n@@ -47,6 +53,10 @@ fn _if_let_guard() {\n         //~| ERROR expected expression, found `let` statement\n         //~| ERROR expected expression, found `let` statement\n         //~| ERROR expected expression, found `let` statement\n+        //~| ERROR `let` expressions are not supported here\n+        //~| ERROR `let` expressions are not supported here\n+        //~| ERROR `let` expressions are not supported here\n+\n \n         () if let Range { start: _, end: _ } = (true..true) && false => {}\n         //~^ ERROR `if let` guards are experimental\n@@ -68,9 +78,11 @@ fn _macros() {\n     use_expr!((let 0 = 1 && 0 == 0));\n     //~^ ERROR `let` expressions in this position are unstable\n     //~| ERROR expected expression, found `let` statement\n+    //~| ERROR `let` expressions are not supported here\n     use_expr!((let 0 = 1));\n     //~^ ERROR `let` expressions in this position are unstable\n     //~| ERROR expected expression, found `let` statement\n+    //~| ERROR `let` expressions are not supported here\n     match () {\n         #[cfg(FALSE)]\n         () if let 0 = 1 => {}"}, {"sha": "dc182ce464a09043b468109039aca2da762b2da4", "filename": "tests/ui/rfc-2294-if-let-guard/feature-gate.stderr", "status": "modified", "additions": 176, "deletions": 33, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2294-if-let-guard%2Ffeature-gate.stderr?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -5,67 +5,67 @@ LL |         () if (let 0 = 1) => {}\n    |                ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:14:18\n+  --> $DIR/feature-gate.rs:15:18\n    |\n LL |         () if (((let 0 = 1))) => {}\n    |                  ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:26:16\n+  --> $DIR/feature-gate.rs:28:16\n    |\n LL |         () if (let 0 = 1) && true => {}\n    |                ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:30:24\n+  --> $DIR/feature-gate.rs:33:24\n    |\n LL |         () if true && (let 0 = 1) => {}\n    |                        ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:34:16\n+  --> $DIR/feature-gate.rs:38:16\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:34:31\n+  --> $DIR/feature-gate.rs:38:31\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                               ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:40:42\n+  --> $DIR/feature-gate.rs:46:42\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                          ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:40:55\n+  --> $DIR/feature-gate.rs:46:55\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                       ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:40:68\n+  --> $DIR/feature-gate.rs:46:68\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                                    ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:68:16\n+  --> $DIR/feature-gate.rs:78:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^\n \n error: expected expression, found `let` statement\n-  --> $DIR/feature-gate.rs:71:16\n+  --> $DIR/feature-gate.rs:82:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^\n \n error: no rules expected the token `let`\n-  --> $DIR/feature-gate.rs:80:15\n+  --> $DIR/feature-gate.rs:92:15\n    |\n LL |     macro_rules! use_expr {\n    |     --------------------- when calling this macro\n@@ -74,11 +74,154 @@ LL |     use_expr!(let 0 = 1);\n    |               ^^^ no rules expected this token in macro call\n    |\n note: while trying to match meta-variable `$e:expr`\n-  --> $DIR/feature-gate.rs:61:10\n+  --> $DIR/feature-gate.rs:71:10\n    |\n LL |         ($e:expr) => {\n    |          ^^^^^^^\n \n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:10:16\n+   |\n+LL |         () if (let 0 = 1) => {}\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:10:16\n+   |\n+LL |         () if (let 0 = 1) => {}\n+   |                ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:15:18\n+   |\n+LL |         () if (((let 0 = 1))) => {}\n+   |                  ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:15:18\n+   |\n+LL |         () if (((let 0 = 1))) => {}\n+   |                  ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:28:16\n+   |\n+LL |         () if (let 0 = 1) && true => {}\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:28:16\n+   |\n+LL |         () if (let 0 = 1) && true => {}\n+   |                ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:33:24\n+   |\n+LL |         () if true && (let 0 = 1) => {}\n+   |                        ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:33:24\n+   |\n+LL |         () if true && (let 0 = 1) => {}\n+   |                        ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:38:16\n+   |\n+LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:38:16\n+   |\n+LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n+   |                ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:38:31\n+   |\n+LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n+   |                               ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:38:31\n+   |\n+LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n+   |                               ^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:46:42\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |                                          ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:46:42\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:46:55\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |                                                       ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:46:42\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:46:68\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |                                                                    ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:46:42\n+   |\n+LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:78:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:78:16\n+   |\n+LL |     use_expr!((let 0 = 1 && 0 == 0));\n+   |                ^^^^^^^^^^^^^^^^^^^\n+\n+error: `let` expressions are not supported here\n+  --> $DIR/feature-gate.rs:82:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `let`s wrapped in parentheses are not supported in a context with let chains\n+  --> $DIR/feature-gate.rs:82:16\n+   |\n+LL |     use_expr!((let 0 = 1));\n+   |                ^^^^^^^^^\n+\n error[E0658]: `if let` guards are experimental\n   --> $DIR/feature-gate.rs:7:12\n    |\n@@ -90,7 +233,7 @@ LL |         () if let 0 = 1 => {}\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:18:12\n+  --> $DIR/feature-gate.rs:20:12\n    |\n LL |         () if true && let 0 = 1 => {}\n    |            ^^^^^^^^^^^^^^^^^^^^\n@@ -100,7 +243,7 @@ LL |         () if true && let 0 = 1 => {}\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:22:12\n+  --> $DIR/feature-gate.rs:24:12\n    |\n LL |         () if let 0 = 1 && true => {}\n    |            ^^^^^^^^^^^^^^^^^^^^\n@@ -110,7 +253,7 @@ LL |         () if let 0 = 1 && true => {}\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:40:12\n+  --> $DIR/feature-gate.rs:46:12\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -120,7 +263,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:51:12\n+  --> $DIR/feature-gate.rs:61:12\n    |\n LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -130,7 +273,7 @@ LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    = help: you can write `if matches!(<expr>, <pattern>)` instead of `if let <pattern> = <expr>`\n \n error[E0658]: `if let` guards are experimental\n-  --> $DIR/feature-gate.rs:76:12\n+  --> $DIR/feature-gate.rs:88:12\n    |\n LL |         () if let 0 = 1 => {}\n    |            ^^^^^^^^^^^^\n@@ -149,7 +292,7 @@ LL |         () if (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:14:18\n+  --> $DIR/feature-gate.rs:15:18\n    |\n LL |         () if (((let 0 = 1))) => {}\n    |                  ^^^^^^^^^\n@@ -158,7 +301,7 @@ LL |         () if (((let 0 = 1))) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:18:23\n+  --> $DIR/feature-gate.rs:20:23\n    |\n LL |         () if true && let 0 = 1 => {}\n    |                       ^^^^^^^^^\n@@ -167,7 +310,7 @@ LL |         () if true && let 0 = 1 => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:22:15\n+  --> $DIR/feature-gate.rs:24:15\n    |\n LL |         () if let 0 = 1 && true => {}\n    |               ^^^^^^^^^\n@@ -176,7 +319,7 @@ LL |         () if let 0 = 1 && true => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:26:16\n+  --> $DIR/feature-gate.rs:28:16\n    |\n LL |         () if (let 0 = 1) && true => {}\n    |                ^^^^^^^^^\n@@ -185,7 +328,7 @@ LL |         () if (let 0 = 1) && true => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:30:24\n+  --> $DIR/feature-gate.rs:33:24\n    |\n LL |         () if true && (let 0 = 1) => {}\n    |                        ^^^^^^^^^\n@@ -194,7 +337,7 @@ LL |         () if true && (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:34:16\n+  --> $DIR/feature-gate.rs:38:16\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                ^^^^^^^^^\n@@ -203,7 +346,7 @@ LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:34:31\n+  --> $DIR/feature-gate.rs:38:31\n    |\n LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    |                               ^^^^^^^^^\n@@ -212,7 +355,7 @@ LL |         () if (let 0 = 1) && (let 0 = 1) => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:40:15\n+  --> $DIR/feature-gate.rs:46:15\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |               ^^^^^^^^^\n@@ -221,7 +364,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:40:28\n+  --> $DIR/feature-gate.rs:46:28\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                            ^^^^^^^^^\n@@ -230,7 +373,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:40:42\n+  --> $DIR/feature-gate.rs:46:42\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                          ^^^^^^^^^\n@@ -239,7 +382,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:40:55\n+  --> $DIR/feature-gate.rs:46:55\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                       ^^^^^^^^^\n@@ -248,7 +391,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:40:68\n+  --> $DIR/feature-gate.rs:46:68\n    |\n LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 = 5) => {}\n    |                                                                    ^^^^^^^^^\n@@ -257,7 +400,7 @@ LL |         () if let 0 = 1 && let 1 = 2 && (let 2 = 3 && let 3 = 4 && let 4 =\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:51:15\n+  --> $DIR/feature-gate.rs:61:15\n    |\n LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -266,7 +409,7 @@ LL |         () if let Range { start: _, end: _ } = (true..true) && false => {}\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:68:16\n+  --> $DIR/feature-gate.rs:78:16\n    |\n LL |     use_expr!((let 0 = 1 && 0 == 0));\n    |                ^^^^^^^^^\n@@ -275,14 +418,14 @@ LL |     use_expr!((let 0 = 1 && 0 == 0));\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n error[E0658]: `let` expressions in this position are unstable\n-  --> $DIR/feature-gate.rs:71:16\n+  --> $DIR/feature-gate.rs:82:16\n    |\n LL |     use_expr!((let 0 = 1));\n    |                ^^^^^^^^^\n    |\n    = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n    = help: add `#![feature(let_chains)]` to the crate attributes to enable\n \n-error: aborting due to 34 previous errors\n+error: aborting due to 45 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "e6dee2a1d061313535965d66a68afae66300a2d0", "filename": "tests/ui/rfc-2497-if-let-chains/ast-validate-guards.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2497-if-let-chains%2Fast-validate-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2497-if-let-chains%2Fast-validate-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2497-if-let-chains%2Fast-validate-guards.rs?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -0,0 +1,23 @@\n+#![feature(let_chains)]\n+\n+fn let_or_guard(x: Result<Option<i32>, ()>) {\n+    match x {\n+        Ok(opt) if let Some(4) = opt || false  => {}\n+        //~^ ERROR `let` expressions are not supported here\n+        _ => {}\n+    }\n+}\n+\n+fn hiding_unsafe_mod(x: Result<Option<i32>, ()>) {\n+    match x {\n+        Ok(opt)\n+            if {\n+                unsafe mod a {};\n+                //~^ ERROR module cannot be declared unsafe\n+                false\n+            } => {}\n+        _ => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "26850998cc4efead168be1b93859738380a7538f", "filename": "tests/ui/rfc-2497-if-let-chains/ast-validate-guards.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2497-if-let-chains%2Fast-validate-guards.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/096309e6dc4378e175e524e963332d1a3830ed63/tests%2Fui%2Frfc-2497-if-let-chains%2Fast-validate-guards.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2497-if-let-chains%2Fast-validate-guards.stderr?ref=096309e6dc4378e175e524e963332d1a3830ed63", "patch": "@@ -0,0 +1,21 @@\n+error: `let` expressions are not supported here\n+  --> $DIR/ast-validate-guards.rs:5:20\n+   |\n+LL |         Ok(opt) if let Some(4) = opt || false  => {}\n+   |                    ^^^^^^^^^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if` and `while` expressions\n+note: `||` operators are not supported in let chain expressions\n+  --> $DIR/ast-validate-guards.rs:5:38\n+   |\n+LL |         Ok(opt) if let Some(4) = opt || false  => {}\n+   |                                      ^^\n+\n+error: module cannot be declared unsafe\n+  --> $DIR/ast-validate-guards.rs:15:17\n+   |\n+LL |                 unsafe mod a {};\n+   |                 ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}