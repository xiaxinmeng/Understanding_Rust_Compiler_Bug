{"sha": "13f5fca0f2c72b8af256f052b51bd636b6932c8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZjVmY2EwZjJjNzJiOGFmMjU2ZjA1MmI1MWJkNjM2YjY5MzJjOGE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-02-26T19:20:53Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-03-04T18:30:22Z"}, "message": "privacy: change def_privacy so that it checks for visiblity instead of nameability", "tree": {"sha": "fce66f04740ab2399b1f5c1a57adc859a12dbad8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fce66f04740ab2399b1f5c1a57adc859a12dbad8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13f5fca0f2c72b8af256f052b51bd636b6932c8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13f5fca0f2c72b8af256f052b51bd636b6932c8a", "html_url": "https://github.com/rust-lang/rust/commit/13f5fca0f2c72b8af256f052b51bd636b6932c8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13f5fca0f2c72b8af256f052b51bd636b6932c8a/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c97524bef9e59a80875110b402b3fc8c139d4d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/c97524bef9e59a80875110b402b3fc8c139d4d64", "html_url": "https://github.com/rust-lang/rust/commit/c97524bef9e59a80875110b402b3fc8c139d4d64"}], "stats": {"total": 106, "additions": 38, "deletions": 68}, "files": [{"sha": "226539b8e804a864a1a09b5fa1125d1510bf5bef", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 38, "deletions": 68, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/13f5fca0f2c72b8af256f052b51bd636b6932c8a/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13f5fca0f2c72b8af256f052b51bd636b6932c8a/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=13f5fca0f2c72b8af256f052b51bd636b6932c8a", "patch": "@@ -492,11 +492,6 @@ enum FieldName {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    // used when debugging\n-    fn nodestr(&self, id: ast::NodeId) -> String {\n-        self.tcx.map.node_to_string(id).to_string()\n-    }\n-\n     // Determines whether the given definition is public from the point of view\n     // of the current item.\n     fn def_privacy(&self, did: DefId) -> PrivacyResult {\n@@ -604,75 +599,50 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             return Allowable;\n         }\n \n-        // We now know that there is at least one private member between the\n-        // destination and the root.\n-        let mut closest_private_id = node_id;\n-        loop {\n-            debug!(\"privacy - examining {}\", self.nodestr(closest_private_id));\n-            let vis = match self.tcx.map.find(closest_private_id) {\n-                // If this item is a method, then we know for sure that it's an\n-                // actual method and not a static method. The reason for this is\n-                // that these cases are only hit in the ExprMethodCall\n-                // expression, and ExprCall will have its path checked later\n-                // (the path of the trait/impl) if it's a static method.\n-                //\n-                // With this information, then we can completely ignore all\n-                // trait methods. The privacy violation would be if the trait\n-                // couldn't get imported, not if the method couldn't be used\n-                // (all trait methods are public).\n-                //\n-                // However, if this is an impl method, then we dictate this\n-                // decision solely based on the privacy of the method\n-                // invocation.\n-                // FIXME(#10573) is this the right behavior? Why not consider\n-                //               where the method was defined?\n-                Some(ast_map::NodeImplItem(ii)) => {\n-                    match ii.node {\n-                        hir::ImplItemKind::Const(..) |\n-                        hir::ImplItemKind::Method(..) => {\n-                            let imp = self.tcx.map\n-                                          .get_parent_did(closest_private_id);\n-                            match self.tcx.impl_trait_ref(imp) {\n-                                Some(..) => return Allowable,\n-                                _ if ii.vis == hir::Public => {\n-                                    return Allowable\n-                                }\n-                                _ => ii.vis\n-                            }\n+        let vis = match self.tcx.map.find(node_id) {\n+            // If this item is a method, then we know for sure that it's an\n+            // actual method and not a static method. The reason for this is\n+            // that these cases are only hit in the ExprMethodCall\n+            // expression, and ExprCall will have its path checked later\n+            // (the path of the trait/impl) if it's a static method.\n+            //\n+            // With this information, then we can completely ignore all\n+            // trait methods. The privacy violation would be if the trait\n+            // couldn't get imported, not if the method couldn't be used\n+            // (all trait methods are public).\n+            //\n+            // However, if this is an impl method, then we dictate this\n+            // decision solely based on the privacy of the method\n+            // invocation.\n+            Some(ast_map::NodeImplItem(ii)) => {\n+                match ii.node {\n+                    hir::ImplItemKind::Const(..) |\n+                    hir::ImplItemKind::Method(..) => {\n+                        let imp = self.tcx.map.get_parent_did(node_id);\n+                        match self.tcx.impl_trait_ref(imp) {\n+                            Some(..) => hir::Public,\n+                            _ => ii.vis\n                         }\n-                        hir::ImplItemKind::Type(_) => return Allowable,\n                     }\n+                    hir::ImplItemKind::Type(_) => hir::Public,\n                 }\n-                Some(ast_map::NodeTraitItem(_)) => {\n-                    return Allowable;\n-                }\n+            }\n+            Some(ast_map::NodeTraitItem(_)) => hir::Public,\n \n-                // This is not a method call, extract the visibility as one\n-                // would normally look at it\n-                Some(ast_map::NodeItem(it)) => it.vis,\n-                Some(ast_map::NodeForeignItem(_)) => {\n-                    self.tcx.map.get_foreign_vis(closest_private_id)\n-                }\n-                Some(ast_map::NodeVariant(..)) => {\n-                    hir::Public // need to move up a level (to the enum)\n-                }\n-                _ => hir::Public,\n-            };\n-            if vis != hir::Public { break }\n-            // if we've reached the root, then everything was allowable and this\n-            // access is public.\n-            if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = *self.parents.get(&closest_private_id).unwrap();\n-\n-            // If we reached the top, then we were public all the way down and\n-            // we can allow this access.\n-            if closest_private_id == ast::DUMMY_NODE_ID { return Allowable }\n-        }\n-        debug!(\"privacy - closest priv {}\", self.nodestr(closest_private_id));\n-        if self.private_accessible(closest_private_id) {\n+            // This is not a method call, extract the visibility as one\n+            // would normally look at it\n+            Some(ast_map::NodeItem(it)) => it.vis,\n+            Some(ast_map::NodeForeignItem(_)) => {\n+                self.tcx.map.get_foreign_vis(node_id)\n+            }\n+            _ => hir::Public,\n+        };\n+        if vis == hir::Public { return Allowable }\n+\n+        if self.private_accessible(node_id) {\n             Allowable\n         } else {\n-            DisallowedBy(closest_private_id)\n+            DisallowedBy(node_id)\n         }\n     }\n "}]}