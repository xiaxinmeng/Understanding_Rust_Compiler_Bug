{"sha": "5a0248068c693c64f74623e9a6f7504b900df8a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMDI0ODA2OGM2OTNjNjRmNzQ2MjNlOWE2Zjc1MDRiOTAwZGY4YTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-30T16:02:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-30T16:02:18Z"}, "message": "Auto merge of #38014 - jseyfried:refactor_path_resolution, r=nrc\n\nresolve: refactor path resolution\n\nThis is a pure refactoring, modulo minor diagnostics improvements.\nr? @nrc", "tree": {"sha": "89bf738c84fe13745dbba0c188e18d57ea511e34", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89bf738c84fe13745dbba0c188e18d57ea511e34"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a0248068c693c64f74623e9a6f7504b900df8a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0248068c693c64f74623e9a6f7504b900df8a6", "html_url": "https://github.com/rust-lang/rust/commit/5a0248068c693c64f74623e9a6f7504b900df8a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a0248068c693c64f74623e9a6f7504b900df8a6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5db4826410b4ffcc0e4cb45566a0411a0858b6bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5db4826410b4ffcc0e4cb45566a0411a0858b6bf", "html_url": "https://github.com/rust-lang/rust/commit/5db4826410b4ffcc0e4cb45566a0411a0858b6bf"}, {"sha": "c871637e4374a7c59d39a70487a7ac46d3efa89a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c871637e4374a7c59d39a70487a7ac46d3efa89a", "html_url": "https://github.com/rust-lang/rust/commit/c871637e4374a7c59d39a70487a7ac46d3efa89a"}], "stats": {"total": 1267, "additions": 446, "deletions": 821}, "files": [{"sha": "615738277bf5cb73b732b2358810fa394f73b3be", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 27, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -82,14 +82,11 @@ pub struct LoweringContext<'a> {\n \n pub trait Resolver {\n     // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool);\n+    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n-    // Record the resolution of a path or binding generated by the lowerer when expanding.\n-    fn record_resolution(&mut self, id: NodeId, def: Def);\n-\n     // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     // This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n@@ -372,12 +369,7 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            let ty = self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)));\n-\n-            // Associate that innermost path type with the base Def.\n-            self.resolver.record_resolution(ty.id, resolution.base_def);\n-\n-            ty\n+            self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)))\n         };\n \n         // Anything after the base path are associated \"extensions\",\n@@ -1979,10 +1971,8 @@ impl<'a> LoweringContext<'a> {\n             def: def,\n             segments: hir_vec![hir::PathSegment::from_name(id)],\n         })));\n-        let expr = self.expr(span, expr_path, ThinVec::new());\n-        self.resolver.record_resolution(expr.id, def);\n \n-        expr\n+        self.expr(span, expr_path, ThinVec::new())\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n@@ -1995,10 +1985,7 @@ impl<'a> LoweringContext<'a> {\n                      attrs: ThinVec<Attribute>)\n                      -> hir::Expr {\n         let path = self.std_path(span, components, true);\n-        let def = path.def;\n-        let expr = self.expr(span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs);\n-        self.resolver.record_resolution(expr.id, def);\n-        expr\n+        self.expr(span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs)\n     }\n \n     fn expr_match(&mut self,\n@@ -2025,11 +2012,8 @@ impl<'a> LoweringContext<'a> {\n                        e: Option<P<hir::Expr>>,\n                        attrs: ThinVec<Attribute>) -> hir::Expr {\n         let path = self.std_path(span, components, false);\n-        let def = path.def;\n         let qpath = hir::QPath::Resolved(None, P(path));\n-        let expr = self.expr(span, hir::ExprStruct(qpath, fields, e), attrs);\n-        self.resolver.record_resolution(expr.id, def);\n-        expr\n+        self.expr(span, hir::ExprStruct(qpath, fields, e), attrs)\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n@@ -2098,16 +2082,13 @@ impl<'a> LoweringContext<'a> {\n                     subpats: hir::HirVec<P<hir::Pat>>)\n                     -> P<hir::Pat> {\n         let path = self.std_path(span, components, true);\n-        let def = path.def;\n         let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n             hir::PatKind::Path(qpath)\n         } else {\n             hir::PatKind::TupleStruct(qpath, subpats, None)\n         };\n-        let pat = self.pat(span, pt);\n-        self.resolver.record_resolution(pat.id, def);\n-        pat\n+        self.pat(span, pt)\n     }\n \n     fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n@@ -2124,7 +2105,6 @@ impl<'a> LoweringContext<'a> {\n             let def_index = defs.create_def_with_parent(parent_def, id, def_path_data);\n             DefId::local(def_index)\n         };\n-        self.resolver.record_resolution(id, Def::Local(def_id));\n \n         P(hir::Pat {\n             id: id,\n@@ -2168,7 +2148,7 @@ impl<'a> LoweringContext<'a> {\n             segments: segments.into(),\n         };\n \n-        self.resolver.resolve_generated_global_path(&mut path, is_value);\n+        self.resolver.resolve_hir_path(&mut path, is_value);\n         path\n     }\n "}, {"sha": "bee79103b41853b6b5191b296342477dad323212", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -10,7 +10,6 @@\n \n use rustc::hir;\n use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n-use rustc::hir::def::DefMap;\n use rustc::hir::lowering::lower_crate;\n use rustc_data_structures::blake2b::Blake2bHasher;\n use rustc_data_structures::fmt_wrap::FmtWrap;\n@@ -63,7 +62,6 @@ use derive_registrar;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub def_map: DefMap,\n     pub freevars: FreevarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n@@ -794,7 +792,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n             hir_ty_to_ty: NodeMap(),\n         },\n         resolutions: Resolutions {\n-            def_map: resolver.def_map,\n             freevars: resolver.freevars,\n             trait_map: resolver.trait_map,\n             maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,"}, {"sha": "d90a49213d141444d39442468ac0b59873e4941f", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -18,7 +18,6 @@ use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Resolver, Module, ModuleS, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n-use ResolveResult::Success;\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::middle::cstore::LoadedMacro;\n@@ -583,7 +582,7 @@ impl<'b> Resolver<'b> {\n         } else {\n             for (name, span) in legacy_imports.imports {\n                 let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n-                if let Success(binding) = result {\n+                if let Ok(binding) = result {\n                     self.legacy_import_macro(name, binding, span, allow_shadowing);\n                 } else {\n                     span_err!(self.session, span, E0469, \"imported macro not found\");\n@@ -595,7 +594,7 @@ impl<'b> Resolver<'b> {\n             self.used_crates.insert(krate);\n             self.session.cstore.export_macros(krate);\n             let result = self.resolve_name_in_module(module, name, MacroNS, false, None);\n-            if let Success(binding) = result {\n+            if let Ok(binding) = result {\n                 self.macro_exports.push(Export { name: name, def: binding.def() });\n             } else {\n                 span_err!(self.session, span, E0470, \"reexported macro not found\");"}, {"sha": "e1200149dcc41c6c9563fe189bb8100cab8191a5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 385, "deletions": 715, "changes": 1100, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -35,12 +35,9 @@ extern crate arena;\n extern crate rustc;\n \n use self::Namespace::*;\n-use self::ResolveResult::*;\n use self::FallbackSuggestion::*;\n use self::TypeParameters::*;\n use self::RibKind::*;\n-use self::UseLexicalScopeFlag::*;\n-use self::ModulePrefixResult::*;\n \n use rustc::hir::map::{Definitions, DefCollector};\n use rustc::hir::{self, PrimTy, TyBool, TyChar, TyFloat, TyInt, TyUint, TyStr};\n@@ -57,6 +54,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::Determinacy::{Determined, Undetermined};\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -191,10 +189,6 @@ fn resolve_struct_error<'b, 'a: 'b, 'c>(resolver: &'b Resolver<'a>,\n                                         span: syntax_pos::Span,\n                                         resolution_error: ResolutionError<'c>)\n                                         -> DiagnosticBuilder<'a> {\n-    if !resolver.emit_errors {\n-        return resolver.session.diagnostic().struct_dummy();\n-    }\n-\n     match resolution_error {\n         ResolutionError::TypeParametersFromOuterFunction => {\n             let mut err = struct_span_err!(resolver.session,\n@@ -584,13 +578,10 @@ impl<'a> Visitor for Resolver<'a> {\n         self.resolve_type(ty);\n     }\n     fn visit_poly_trait_ref(&mut self, tref: &ast::PolyTraitRef, m: &ast::TraitBoundModifier) {\n-        match self.resolve_trait_reference(tref.trait_ref.ref_id, &tref.trait_ref.path, 0, None) {\n-            Ok(def) => self.record_def(tref.trait_ref.ref_id, def),\n-            Err(_) => {\n-                // error already reported\n-                self.record_def(tref.trait_ref.ref_id, err_path_resolution())\n-            }\n-        }\n+        let ast::Path { ref segments, span, global } = tref.trait_ref.path;\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+        let def = self.resolve_trait_reference(&path, global, None, span);\n+        self.record_def(tref.trait_ref.ref_id, def);\n         visit::walk_poly_trait_ref(self, tref, m);\n     }\n     fn visit_variant(&mut self,\n@@ -676,22 +667,6 @@ impl<'a> Visitor for Resolver<'a> {\n \n pub type ErrorMessage = Option<(Span, String)>;\n \n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum ResolveResult<T> {\n-    Failed(ErrorMessage), // Failed to resolve the name, optional helpful error message.\n-    Indeterminate, // Couldn't determine due to unresolved globs.\n-    Success(T), // Successfully resolved the import.\n-}\n-\n-impl<T> ResolveResult<T> {\n-    fn success(self) -> Option<T> {\n-        match self {\n-            Success(t) => Some(t),\n-            _ => None,\n-        }\n-    }\n-}\n-\n enum FallbackSuggestion {\n     NoSuggestion,\n     Field,\n@@ -741,17 +716,6 @@ enum RibKind<'a> {\n     MacroDefinition(Mark),\n }\n \n-#[derive(Copy, Clone)]\n-enum UseLexicalScopeFlag {\n-    DontUseLexicalScope,\n-    UseLexicalScope,\n-}\n-\n-enum ModulePrefixResult<'a> {\n-    NoPrefixFound,\n-    PrefixFound(Module<'a>, usize),\n-}\n-\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n@@ -769,33 +733,18 @@ impl<'a> Rib<'a> {\n }\n \n /// A definition along with the index of the rib it was found on\n+#[derive(Copy, Clone)]\n struct LocalDef {\n     ribs: Option<(Namespace, usize)>,\n     def: Def,\n }\n \n-impl LocalDef {\n-    fn from_def(def: Def) -> Self {\n-        LocalDef {\n-            ribs: None,\n-            def: def,\n-        }\n-    }\n-}\n-\n enum LexicalScopeBinding<'a> {\n     Item(&'a NameBinding<'a>),\n-    LocalDef(LocalDef),\n+    Def(Def),\n }\n \n impl<'a> LexicalScopeBinding<'a> {\n-    fn local_def(self) -> LocalDef {\n-        match self {\n-            LexicalScopeBinding::LocalDef(local_def) => local_def,\n-            LexicalScopeBinding::Item(binding) => LocalDef::from_def(binding.def()),\n-        }\n-    }\n-\n     fn item(self) -> Option<&'a NameBinding<'a>> {\n         match self {\n             LexicalScopeBinding::Item(binding) => Some(binding),\n@@ -804,6 +753,21 @@ impl<'a> LexicalScopeBinding<'a> {\n     }\n }\n \n+#[derive(Copy, Clone)]\n+enum PathScope {\n+    Global,\n+    Lexical,\n+    Import,\n+}\n+\n+#[derive(Clone)]\n+enum PathResult<'a> {\n+    Module(Module<'a>),\n+    NonModule(PathResolution),\n+    Indeterminate,\n+    Failed(String, bool /* is the error from the last segment? */),\n+}\n+\n enum ModuleKind {\n     Block(NodeId),\n     Def(Def, Name),\n@@ -944,13 +908,11 @@ struct AmbiguityError<'a> {\n }\n \n impl<'a> NameBinding<'a> {\n-    fn module(&self) -> Result<Module<'a>, bool /* true if an error has already been reported */> {\n+    fn module(&self) -> Option<Module<'a>> {\n         match self.kind {\n-            NameBindingKind::Module(module) => Ok(module),\n+            NameBindingKind::Module(module) => Some(module),\n             NameBindingKind::Import { binding, .. } => binding.module(),\n-            NameBindingKind::Def(Def::Err) => Err(true),\n-            NameBindingKind::Def(_) => Err(false),\n-            NameBindingKind::Ambiguity { ..  } => Err(false),\n+            _ => None,\n         }\n     }\n \n@@ -1088,7 +1050,7 @@ pub struct Resolver<'a> {\n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n-    pub def_map: DefMap,\n+    def_map: DefMap,\n     pub freevars: FreevarMap,\n     freevars_seen: NodeMap<NodeMap<usize>>,\n     pub export_map: ExportMap,\n@@ -1111,11 +1073,6 @@ pub struct Resolver<'a> {\n     module_map: NodeMap<Module<'a>>,\n     extern_crate_roots: FxHashMap<(CrateNum, bool /* MacrosOnly? */), Module<'a>>,\n \n-    // Whether or not to print error messages. Can be set to true\n-    // when getting additional info for error message suggestions,\n-    // so as to avoid printing duplicate errors\n-    emit_errors: bool,\n-\n     pub make_glob_map: bool,\n     // Maps imports to the names of items actually imported (this actually maps\n     // all imports, but only glob imports are actually interesting).\n@@ -1201,23 +1158,23 @@ impl<'a> ty::NodeIdTree for Resolver<'a> {\n }\n \n impl<'a> hir::lowering::Resolver for Resolver<'a> {\n-    fn resolve_generated_global_path(&mut self, path: &mut hir::Path, is_value: bool) {\n+    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool) {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n-        match self.resolve_crate_relative_path(path.span, &path.segments, namespace) {\n-            Ok(binding) => path.def = binding.def(),\n-            Err(true) => {}\n-            Err(false) => {\n-                let path_name = &format!(\"{}\", path);\n-                let error =\n-                    ResolutionError::UnresolvedName {\n-                        path: path_name,\n-                        message: \"\",\n-                        context: UnresolvedNameContext::Other,\n-                        is_static_method: false,\n-                        is_field: false,\n-                        def: Def::Err,\n-                    };\n-                resolve_error(self, path.span, error);\n+        let hir::Path { ref segments, span, global, ref mut def } = *path;\n+        let path: Vec<_> = segments.iter().map(|seg| Ident::with_empty_ctxt(seg.name)).collect();\n+        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+        match self.resolve_path(&path, scope, Some(namespace), Some(span)) {\n+            PathResult::Module(module) => *def = module.def().unwrap(),\n+            PathResult::NonModule(path_res) if path_res.depth == 0 => *def = path_res.base_def,\n+            PathResult::NonModule(..) => match self.resolve_path(&path, scope, None, Some(span)) {\n+                PathResult::Failed(msg, _) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                }\n+                _ => {}\n+            },\n+            PathResult::Indeterminate => unreachable!(),\n+            PathResult::Failed(msg, _) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n             }\n         }\n     }\n@@ -1226,31 +1183,11 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         self.def_map.get(&id).cloned()\n     }\n \n-    fn record_resolution(&mut self, id: NodeId, def: Def) {\n-        self.def_map.insert(id, PathResolution::new(def));\n-    }\n-\n     fn definitions(&mut self) -> &mut Definitions {\n         &mut self.definitions\n     }\n }\n \n-trait Named {\n-    fn ident(&self) -> Ident;\n-}\n-\n-impl Named for ast::PathSegment {\n-    fn ident(&self) -> Ident {\n-        self.identifier\n-    }\n-}\n-\n-impl Named for hir::PathSegment {\n-    fn ident(&self) -> Ident {\n-        Ident::with_empty_ctxt(self.name)\n-    }\n-}\n-\n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n                krate: &Crate,\n@@ -1312,7 +1249,6 @@ impl<'a> Resolver<'a> {\n             module_map: module_map,\n             extern_crate_roots: FxHashMap(),\n \n-            emit_errors: true,\n             make_glob_map: make_glob_map == MakeGlobMap::Yes,\n             glob_map: NodeMap(),\n \n@@ -1390,7 +1326,7 @@ impl<'a> Resolver<'a> {\n     fn record_use(&mut self, name: Name, ns: Namespace, binding: &'a NameBinding<'a>, span: Span)\n                   -> bool /* true if an error was reported */ {\n         // track extern crates for unused_extern_crate lint\n-        if let Some(DefId { krate, .. }) = binding.module().ok().and_then(ModuleS::def_id) {\n+        if let Some(DefId { krate, .. }) = binding.module().and_then(ModuleS::def_id) {\n             self.used_crates.insert(krate);\n         }\n \n@@ -1418,163 +1354,6 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn expect_module(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Option<Span>)\n-                     -> ResolveResult<Module<'a>> {\n-        match binding.module() {\n-            Ok(module) => Success(module),\n-            Err(true) => Failed(None),\n-            Err(false) => {\n-                let msg = format!(\"Not a module `{}`\", name);\n-                Failed(span.map(|span| (span, msg)))\n-            }\n-        }\n-    }\n-\n-    /// Resolves the given module path from the given root `search_module`.\n-    fn resolve_module_path_from_root(&mut self,\n-                                     mut search_module: Module<'a>,\n-                                     module_path: &[Ident],\n-                                     index: usize,\n-                                     span: Option<Span>)\n-                                     -> ResolveResult<Module<'a>> {\n-        fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n-                                       -> Option<Module<'a>> {\n-            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n-                Success(binding) if binding.is_extern_crate() => Some(module),\n-                _ => if let (&ModuleKind::Def(..), Some(parent)) = (&module.kind, module.parent) {\n-                    search_parent_externals(this, needle, parent)\n-                } else {\n-                    None\n-                },\n-            }\n-        }\n-\n-        let mut index = index;\n-        let module_path_len = module_path.len();\n-\n-        // Resolve the module part of the path. This does not involve looking\n-        // upward though scope chains; we simply resolve names directly in\n-        // modules as we go.\n-        while index < module_path_len {\n-            let name = module_path[index].name;\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n-                Failed(_) => {\n-                    let module_name = module_to_string(search_module);\n-                    let msg = if \"???\" == &module_name {\n-                        let current_module = self.current_module;\n-                        match search_parent_externals(self, name, current_module) {\n-                            Some(module) => {\n-                                let path_str = names_to_string(module_path);\n-                                let target_mod_str = module_to_string(&module);\n-                                let current_mod_str = module_to_string(current_module);\n-\n-                                let prefix = if target_mod_str == current_mod_str {\n-                                    \"self::\".to_string()\n-                                } else {\n-                                    format!(\"{}::\", target_mod_str)\n-                                };\n-\n-                                format!(\"Did you mean `{}{}`?\", prefix, path_str)\n-                            }\n-                            None => format!(\"Maybe a missing `extern crate {};`?\", name),\n-                        }\n-                    } else {\n-                        format!(\"Could not find `{}` in `{}`\", name, module_name)\n-                    };\n-\n-                    return Failed(span.map(|span| (span, msg)));\n-                }\n-                Indeterminate => {\n-                    debug!(\"(resolving module path for import) module resolution is \\\n-                            indeterminate: {}\",\n-                           name);\n-                    return Indeterminate;\n-                }\n-                Success(binding) => {\n-                    // Check to see whether there are type bindings, and, if\n-                    // so, whether there is a module within.\n-                    match self.expect_module(name, binding, span) {\n-                        Success(module) => search_module = module,\n-                        result @ _ => return result,\n-                    }\n-                }\n-            }\n-\n-            index += 1;\n-        }\n-\n-        return Success(search_module);\n-    }\n-\n-    /// Attempts to resolve the module part of an import directive or path\n-    /// rooted at the given module.\n-    fn resolve_module_path(&mut self,\n-                           module_path: &[Ident],\n-                           use_lexical_scope: UseLexicalScopeFlag,\n-                           span: Option<Span>)\n-                           -> ResolveResult<Module<'a>> {\n-        if module_path.len() == 0 {\n-            return Success(self.graph_root) // Use the crate root\n-        }\n-\n-        debug!(\"(resolving module path for import) processing `{}` rooted at `{}`\",\n-               names_to_string(module_path),\n-               module_to_string(self.current_module));\n-\n-        // Resolve the module prefix, if any.\n-        let module_prefix_result = self.resolve_module_prefix(module_path, span);\n-\n-        let search_module;\n-        let start_index;\n-        match module_prefix_result {\n-            Failed(err) => return Failed(err),\n-            Indeterminate => {\n-                debug!(\"(resolving module path for import) indeterminate; bailing\");\n-                return Indeterminate;\n-            }\n-            Success(NoPrefixFound) => {\n-                // There was no prefix, so we're considering the first element\n-                // of the path. How we handle this depends on whether we were\n-                // instructed to use lexical scope or not.\n-                match use_lexical_scope {\n-                    DontUseLexicalScope => {\n-                        // This is a crate-relative path. We will start the\n-                        // resolution process at index zero.\n-                        search_module = self.graph_root;\n-                        start_index = 0;\n-                    }\n-                    UseLexicalScope => {\n-                        // This is not a crate-relative path. We resolve the\n-                        // first component of the path in the current lexical\n-                        // scope and then proceed to resolve below that.\n-                        let ident = module_path[0];\n-                        let lexical_binding =\n-                            self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n-                        if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n-                            match self.expect_module(ident.name, binding, span) {\n-                                Success(containing_module) => {\n-                                    search_module = containing_module;\n-                                    start_index = 1;\n-                                }\n-                                result @ _ => return result,\n-                            }\n-                        } else {\n-                            let msg =\n-                                format!(\"Use of undeclared type or module `{}`\", ident.name);\n-                            return Failed(span.map(|span| (span, msg)));\n-                        }\n-                    }\n-                }\n-            }\n-            Success(PrefixFound(ref containing_module, index)) => {\n-                search_module = containing_module;\n-                start_index = index;\n-            }\n-        }\n-\n-        self.resolve_module_path_from_root(search_module, module_path, start_index, span)\n-    }\n-\n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n     /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n     /// `ident` in the first scope that defines it (or None if no scopes define it).\n@@ -1605,24 +1384,25 @@ impl<'a> Resolver<'a> {\n         for i in (0 .. self.ribs[ns].len()).rev() {\n             if let Some(def) = self.ribs[ns][i].bindings.get(&ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n-                return Some(LexicalScopeBinding::LocalDef(LocalDef {\n-                    ribs: Some((ns, i)),\n-                    def: def,\n+                return Some(LexicalScopeBinding::Def(if let Some(span) = record_used {\n+                    self.adjust_local_def(LocalDef { ribs: Some((ns, i)), def: def }, span)\n+                } else {\n+                    def\n                 }));\n             }\n \n             if let ModuleRibKind(module) = self.ribs[ns][i].kind {\n                 let name = ident.name;\n                 let item = self.resolve_name_in_module(module, name, ns, false, record_used);\n-                if let Success(binding) = item {\n+                if let Ok(binding) = item {\n                     // The ident resolves to an item.\n                     return Some(LexicalScopeBinding::Item(binding));\n                 }\n \n                 if let ModuleKind::Block(..) = module.kind { // We can see through blocks\n                 } else if !module.no_implicit_prelude {\n                     return self.prelude.and_then(|prelude| {\n-                        self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                        self.resolve_name_in_module(prelude, name, ns, false, None).ok()\n                     }).map(LexicalScopeBinding::Item)\n                 } else {\n                     return None;\n@@ -1642,45 +1422,6 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n-    /// (b) some chain of `super::`.\n-    /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Ident], span: Option<Span>)\n-                             -> ResolveResult<ModulePrefixResult<'a>> {\n-        if module_path[0].name == \"$crate\" {\n-            return Success(PrefixFound(self.resolve_crate_var(module_path[0].ctxt), 1));\n-        }\n-\n-        // Start at the current module if we see `self` or `super`, or at the\n-        // top of the crate otherwise.\n-        let mut i = match &*module_path[0].name.as_str() {\n-            \"self\" => 1,\n-            \"super\" => 0,\n-            _ => return Success(NoPrefixFound),\n-        };\n-\n-        let mut containing_module =\n-            self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n-\n-        // Now loop through all the `super`s we find.\n-        while i < module_path.len() && module_path[i].name == \"super\" {\n-            debug!(\"(resolving module prefix) resolving `super` at {}\",\n-                   module_to_string(&containing_module));\n-            if let Some(parent) = containing_module.parent {\n-                containing_module = self.module_map[&parent.normal_ancestor_id.unwrap()];\n-                i += 1;\n-            } else {\n-                let msg = \"There are too many initial `super`s.\".into();\n-                return Failed(span.map(|span| (span, msg)));\n-            }\n-        }\n-\n-        debug!(\"(resolving module prefix) finished resolving prefix at {}\",\n-               module_to_string(&containing_module));\n-\n-        return Success(PrefixFound(containing_module, i));\n-    }\n-\n     fn resolve_crate_var(&mut self, mut crate_var_ctxt: SyntaxContext) -> Module<'a> {\n         while crate_var_ctxt.source().0 != SyntaxContext::empty() {\n             crate_var_ctxt = crate_var_ctxt.source().0;\n@@ -1839,24 +1580,32 @@ impl<'a> Resolver<'a> {\n             ItemKind::Use(ref view_path) => {\n                 match view_path.node {\n                     ast::ViewPathList(ref prefix, ref items) => {\n+                        let path: Vec<_> =\n+                            prefix.segments.iter().map(|seg| seg.identifier).collect();\n                         // Resolve prefix of an import with empty braces (issue #28388)\n                         if items.is_empty() && !prefix.segments.is_empty() {\n-                            match self.resolve_crate_relative_path(prefix.span,\n-                                                                   &prefix.segments,\n-                                                                   TypeNS) {\n-                                Ok(binding) => {\n-                                    let def = binding.def();\n-                                    self.record_def(item.id, PathResolution::new(def));\n-                                }\n-                                Err(true) => self.record_def(item.id, err_path_resolution()),\n-                                Err(false) => {\n-                                    resolve_error(self,\n-                                                  prefix.span,\n-                                                  ResolutionError::FailedToResolve(\n-                                                      &path_names_to_string(prefix, 0)));\n-                                    self.record_def(item.id, err_path_resolution());\n+                            let (scope, span) = (PathScope::Import, prefix.span);\n+                            // FIXME(#38012) This should be a module path, not anything in TypeNS.\n+                            let result =\n+                                self.resolve_path(&path, scope, Some(TypeNS), Some(span));\n+                            let (def, msg) = match result {\n+                                PathResult::Module(module) => (module.def().unwrap(), None),\n+                                PathResult::NonModule(res) if res.depth == 0 =>\n+                                    (res.base_def, None),\n+                                PathResult::NonModule(_) => {\n+                                    // Resolve a module path for better errors\n+                                    match self.resolve_path(&path, scope, None, Some(span)) {\n+                                        PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n+                                        _ => unreachable!(),\n+                                    }\n                                 }\n+                                PathResult::Indeterminate => unreachable!(),\n+                                PathResult::Failed(msg, _) => (Def::Err, Some(msg)),\n+                            };\n+                            if let Some(msg) = msg {\n+                                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                             }\n+                            self.record_def(item.id, PathResolution::new(def));\n                         }\n                     }\n                     _ => {}\n@@ -1931,64 +1680,53 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_trait_reference(&mut self,\n-                               id: NodeId,\n-                               trait_path: &Path,\n-                               path_depth: usize,\n-                               generics: Option<&Generics>)\n-                               -> Result<PathResolution, ()> {\n-        self.resolve_path(id, trait_path, path_depth, TypeNS).and_then(|path_res| {\n-            match path_res.base_def {\n-                Def::Trait(_) => {\n-                    debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n-                    return Ok(path_res);\n-                }\n-                Def::Err => return Err(true),\n-                _ => {}\n+                               path: &[Ident],\n+                               global: bool,\n+                               generics: Option<&Generics>,\n+                               span: Span)\n+                               -> PathResolution {\n+        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+        let def = match self.resolve_path(path, scope, None, Some(span)) {\n+            PathResult::Module(module) => Some(module.def().unwrap()),\n+            PathResult::NonModule(..) => return err_path_resolution(),\n+            PathResult::Failed(msg, false) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                return err_path_resolution();\n+            }\n+            _ => match self.resolve_path(path, scope, Some(TypeNS), None) {\n+                PathResult::NonModule(path_resolution) => Some(path_resolution.base_def),\n+                _ => None,\n+            },\n+        };\n+\n+        if let Some(def) = def {\n+            if let Def::Trait(_) = def {\n+                return PathResolution::new(def);\n             }\n \n-            let mut err = resolve_struct_error(self, trait_path.span, {\n-                ResolutionError::IsNotATrait(&path_names_to_string(trait_path, path_depth),\n-                                             path_res.base_def.kind_name())\n+            let mut err = resolve_struct_error(self, span, {\n+                ResolutionError::IsNotATrait(&names_to_string(path), def.kind_name())\n             });\n             if let Some(generics) = generics {\n-                if let Some(span) = generics.span_for_name(\n-                    &path_names_to_string(trait_path, path_depth)) {\n-\n+                if let Some(span) = generics.span_for_name(&names_to_string(path)) {\n                     err.span_label(span, &\"type parameter defined here\");\n                 }\n             }\n \n             // If it's a typedef, give a note\n-            if let Def::TyAlias(..) = path_res.base_def {\n+            if let Def::TyAlias(..) = def {\n                 err.note(&format!(\"type aliases cannot be used for traits\"));\n             }\n             err.emit();\n-            Err(true)\n-        }).map_err(|error_reported| {\n-            if error_reported { return }\n-\n+        } else {\n             // find possible candidates\n-            let trait_name = trait_path.segments.last().unwrap().identifier.name;\n-            let candidates =\n-                self.lookup_candidates(\n-                    trait_name,\n-                    TypeNS,\n-                    |def| match def {\n-                        Def::Trait(_) => true,\n-                        _             => false,\n-                    },\n-                );\n-\n-            // create error object\n-            let name = &path_names_to_string(trait_path, path_depth);\n-            let error =\n-                ResolutionError::UndeclaredTraitName(\n-                    name,\n-                    candidates,\n-                );\n+            let is_trait = |def| match def { Def::Trait(_) => true, _ => false };\n+            let candidates = self.lookup_candidates(path.last().unwrap().name, TypeNS, is_trait);\n \n-            resolve_error(self, trait_path.span, error);\n-        })\n+            let path = names_to_string(path);\n+            resolve_error(self, span, ResolutionError::UndeclaredTraitName(&path, candidates));\n+        }\n+        err_path_resolution()\n     }\n \n     fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n@@ -2011,16 +1749,14 @@ impl<'a> Resolver<'a> {\n         let mut new_val = None;\n         let mut new_id = None;\n         if let Some(trait_ref) = opt_trait_ref {\n-            if let Ok(path_res) = self.resolve_trait_reference(trait_ref.ref_id,\n-                                                               &trait_ref.path,\n-                                                               0,\n-                                                               generics) {\n-                assert!(path_res.depth == 0);\n-                self.record_def(trait_ref.ref_id, path_res);\n+            let ast::Path { ref segments, span, global } = trait_ref.path;\n+            let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+            let path_res = self.resolve_trait_reference(&path, global, generics, span);\n+            assert!(path_res.depth == 0);\n+            self.record_def(trait_ref.ref_id, path_res);\n+            if path_res.base_def != Def::Err {\n                 new_val = Some((path_res.base_def.def_id(), trait_ref.clone()));\n                 new_id = Some(path_res.base_def.def_id());\n-            } else {\n-                self.record_def(trait_ref.ref_id, err_path_resolution());\n             }\n             visit::walk_trait_ref(self, trait_ref);\n         }\n@@ -2254,79 +1990,52 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_type(&mut self, ty: &Ty) {\n-        match ty.node {\n-            TyKind::Path(ref maybe_qself, ref path) => {\n-                // This is a path in the type namespace. Walk through scopes\n-                // looking for it.\n-                if let Some(def) = self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(),\n-                                                                    path, TypeNS) {\n-                    match def.base_def {\n-                        Def::Mod(..) if def.depth == 0 => {\n-                            self.session.span_err(path.span, \"expected type, found module\");\n-                            self.record_def(ty.id, err_path_resolution());\n-                        }\n-                        _ => {\n-                            // Write the result into the def map.\n-                            debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n-                                   path_names_to_string(path, 0), ty.id, def);\n-                            self.record_def(ty.id, def);\n-                        }\n+        if let TyKind::Path(ref maybe_qself, ref path) = ty.node {\n+            // This is a path in the type namespace. Walk through scopes looking for it.\n+            if let Some(def) =\n+                    self.resolve_possibly_assoc_item(ty.id, maybe_qself.as_ref(), path, TypeNS) {\n+                match def.base_def {\n+                    Def::Mod(..) if def.depth == 0 => {\n+                        self.session.span_err(path.span, \"expected type, found module\");\n+                        self.record_def(ty.id, err_path_resolution());\n                     }\n-                } else {\n-                    self.record_def(ty.id, err_path_resolution());\n-\n-                    // Keep reporting some errors even if they're ignored above.\n-                    if let Err(true) = self.resolve_path(ty.id, path, 0, TypeNS) {\n-                        // `resolve_path` already reported the error\n-                    } else {\n-                        let kind = if maybe_qself.is_some() {\n-                            \"associated type\"\n-                        } else {\n-                            \"type name\"\n-                        };\n-\n-                        let is_invalid_self_type_name = path.segments.len() > 0 &&\n-                                                        maybe_qself.is_none() &&\n-                                                        path.segments[0].identifier.name ==\n-                                                        keywords::SelfType.name();\n-                        if is_invalid_self_type_name {\n-                            resolve_error(self,\n-                                          ty.span,\n-                                          ResolutionError::SelfUsedOutsideImplOrTrait);\n-                        } else {\n-                            let segment = path.segments.last();\n-                            let segment = segment.expect(\"missing name in path\");\n-                            let type_name = segment.identifier.name;\n-\n-                            let candidates =\n-                                self.lookup_candidates(\n-                                    type_name,\n-                                    TypeNS,\n-                                    |def| match def {\n-                                        Def::Trait(_) |\n-                                        Def::Enum(_) |\n-                                        Def::Struct(_) |\n-                                        Def::Union(_) |\n-                                        Def::TyAlias(_) => true,\n-                                        _               => false,\n-                                    },\n-                                );\n-\n-                            // create error object\n-                            let name = &path_names_to_string(path, 0);\n-                            let error =\n-                                ResolutionError::UseOfUndeclared(\n-                                    kind,\n-                                    name,\n-                                    candidates,\n-                                );\n+                    _ => {\n+                        // Write the result into the def map.\n+                        debug!(\"(resolving type) writing resolution for `{}` (id {}) = {:?}\",\n+                               path_names_to_string(path, 0), ty.id, def);\n+                        self.record_def(ty.id, def);\n+                   }\n+                }\n+            } else {\n+                self.record_def(ty.id, err_path_resolution());\n+                // Keep reporting some errors even if they're ignored above.\n+                let kind = if maybe_qself.is_some() { \"associated type\" } else { \"type name\" };\n+                let is_invalid_self_type_name = {\n+                    path.segments.len() > 0 &&\n+                    maybe_qself.is_none() &&\n+                    path.segments[0].identifier.name == keywords::SelfType.name()\n+                };\n \n-                            resolve_error(self, ty.span, error);\n+                if is_invalid_self_type_name {\n+                    resolve_error(self, ty.span, ResolutionError::SelfUsedOutsideImplOrTrait);\n+                } else {\n+                    let type_name = path.segments.last().unwrap().identifier.name;\n+                    let candidates = self.lookup_candidates(type_name, TypeNS, |def| {\n+                        match def {\n+                            Def::Trait(_) |\n+                            Def::Enum(_) |\n+                            Def::Struct(_) |\n+                            Def::Union(_) |\n+                            Def::TyAlias(_) => true,\n+                            _ => false,\n                         }\n-                    }\n+                    });\n+\n+                    let name = &path_names_to_string(path, 0);\n+                    let error = ResolutionError::UseOfUndeclared(kind, name, candidates);\n+                    resolve_error(self, ty.span, error);\n                 }\n             }\n-            _ => {}\n         }\n         // Resolve embedded types.\n         visit::walk_ty(self, ty);\n@@ -2420,13 +2129,8 @@ impl<'a> Resolver<'a> {\n                 resolution\n             }\n         } else {\n-            if let Err(false) = self.resolve_path(pat_id, path, 0, namespace) {\n-                resolve_error(\n-                    self,\n-                    path.span,\n-                    ResolutionError::PatPathUnresolved(expected_what, path)\n-                );\n-            }\n+            let error = ResolutionError::PatPathUnresolved(expected_what, path);\n+            resolve_error(self, path.span, error);\n             err_path_resolution()\n         };\n \n@@ -2538,79 +2242,32 @@ impl<'a> Resolver<'a> {\n                                    id: NodeId,\n                                    maybe_qself: Option<&QSelf>,\n                                    path: &Path,\n-                                   namespace: Namespace)\n+                                   ns: Namespace)\n                                    -> Option<PathResolution> {\n-        let max_assoc_types;\n-\n-        match maybe_qself {\n-            Some(qself) => {\n-                if qself.position == 0 {\n-                    // FIXME: Create some fake resolution that can't possibly be a type.\n-                    return Some(PathResolution {\n-                        base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n-                        depth: path.segments.len(),\n-                    });\n-                }\n-                max_assoc_types = path.segments.len() - qself.position;\n-                // Make sure the trait is valid.\n-                let _ = self.resolve_trait_reference(id, path, max_assoc_types, None);\n-            }\n-            None => {\n-                max_assoc_types = path.segments.len();\n-            }\n-        }\n-\n-        let mut resolution = self.with_no_errors(|this| {\n-            this.resolve_path(id, path, 0, namespace).ok()\n-        });\n-        for depth in 1..max_assoc_types {\n-            if resolution.is_some() {\n-                break;\n+        let ast::Path { ref segments, global, span } = *path;\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+        let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+\n+        if let Some(qself) = maybe_qself {\n+            if qself.position == 0 {\n+                // FIXME: Create some fake resolution that can't possibly be a type.\n+                return Some(PathResolution {\n+                    base_def: Def::Mod(self.definitions.local_def_id(ast::CRATE_NODE_ID)),\n+                    depth: path.len(),\n+                });\n             }\n-            self.with_no_errors(|this| {\n-                let partial_resolution = this.resolve_path(id, path, depth, TypeNS).ok();\n-                if let Some(Def::Mod(..)) = partial_resolution.map(|r| r.base_def) {\n-                    // Modules cannot have associated items\n-                } else {\n-                    resolution = partial_resolution;\n-                }\n-            });\n-        }\n-        resolution\n-    }\n-\n-    /// Skips `path_depth` trailing segments, which is also reflected in the\n-    /// returned value. See `hir::def::PathResolution` for more info.\n-    fn resolve_path(&mut self, id: NodeId, path: &Path, path_depth: usize, namespace: Namespace)\n-                    -> Result<PathResolution, bool /* true if an error was reported */ > {\n-        debug!(\"resolve_path(id={:?} path={:?}, path_depth={:?})\", id, path, path_depth);\n-\n-        let span = path.span;\n-        let segments = &path.segments[..path.segments.len() - path_depth];\n-\n-        let mk_res = |def| PathResolution { base_def: def, depth: path_depth };\n-\n-        if path.global {\n-            let binding = self.resolve_crate_relative_path(span, segments, namespace);\n-            return binding.map(|binding| mk_res(binding.def()));\n+            // Make sure the trait is valid.\n+            self.resolve_trait_reference(&path[..qself.position], global, None, span);\n         }\n \n-        // Try to find a path to an item in a module.\n-        let last_ident = segments.last().unwrap().identifier;\n-        // Resolve a single identifier with fallback to primitive types\n-        let resolve_identifier_with_fallback = |this: &mut Self, record_used| {\n-            let def = this.resolve_identifier(last_ident, namespace, record_used);\n-            match def {\n-                None | Some(LocalDef{def: Def::Mod(..), ..}) if namespace == TypeNS =>\n-                    this.primitive_type_table\n-                        .primitive_types\n-                        .get(&last_ident.name)\n-                        .map_or(def, |prim_ty| Some(LocalDef::from_def(Def::PrimTy(*prim_ty)))),\n-                _ => def\n+        let result = match self.resolve_path(&path, scope, Some(ns), Some(span)) {\n+            PathResult::NonModule(path_res) => match path_res.base_def {\n+                Def::Trait(..) if maybe_qself.is_some() => return None,\n+                _ => path_res,\n+            },\n+            PathResult::Module(module) if !module.is_normal() => {\n+                PathResolution::new(module.def().unwrap())\n             }\n-        };\n-\n-        if segments.len() == 1 {\n             // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n             // don't report an error right away, but try to fallback to a primitive type.\n             // So, we are still able to successfully resolve something like\n@@ -2623,43 +2280,140 @@ impl<'a> Resolver<'a> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let def = resolve_identifier_with_fallback(self, Some(span)).ok_or(false);\n-            return def.and_then(|def| self.adjust_local_def(def, span).ok_or(true)).map(mk_res);\n+            _ if self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n+                PathResolution {\n+                    base_def: Def::PrimTy(self.primitive_type_table.primitive_types[&path[0].name]),\n+                    depth: segments.len() - 1,\n+                }\n+            }\n+            PathResult::Module(module) => PathResolution::new(module.def().unwrap()),\n+            PathResult::Failed(msg, false) => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n+                err_path_resolution()\n+            }\n+            _ => return None,\n+        };\n+\n+        if path.len() == 1 || result.base_def == Def::Err {\n+            return Some(result);\n         }\n \n-        let unqualified_def = resolve_identifier_with_fallback(self, None);\n-        let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n-        match (qualified_binding, unqualified_def) {\n-            (Ok(binding), Some(ref ud)) if binding.def() == ud.def &&\n-                                           segments[0].identifier.name != \"$crate\" => {\n-                self.session\n-                    .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n-                              id,\n-                              span,\n-                              \"unnecessary qualification\".to_string());\n+        let unqualified_result = {\n+            match self.resolve_path(&[*path.last().unwrap()], PathScope::Lexical, Some(ns), None) {\n+                PathResult::NonModule(path_res) => path_res.base_def,\n+                PathResult::Module(module) => module.def().unwrap(),\n+                _ => return Some(result),\n             }\n-            _ => {}\n+        };\n+        if result.base_def == unqualified_result && path[0].name != \"$crate\" {\n+            let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n+            self.session.add_lint(lint, id, span, \"unnecessary qualification\".to_string());\n         }\n \n-        qualified_binding.map(|binding| mk_res(binding.def()))\n+        Some(result)\n     }\n \n-    // Resolve a single identifier\n-    fn resolve_identifier(&mut self,\n-                          identifier: Ident,\n-                          namespace: Namespace,\n-                          record_used: Option<Span>)\n-                          -> Option<LocalDef> {\n-        if identifier.name == keywords::Invalid.name() {\n-            return None;\n+    fn resolve_path(&mut self,\n+                    path: &[Ident],\n+                    scope: PathScope,\n+                    opt_ns: Option<Namespace>, // `None` indicates a module path\n+                    record_used: Option<Span>)\n+                    -> PathResult<'a> {\n+        let (mut module, allow_self) = match scope {\n+            PathScope::Lexical => (None, true),\n+            PathScope::Import => (Some(self.graph_root), true),\n+            PathScope::Global => (Some(self.graph_root), false),\n+        };\n+        let mut allow_super = allow_self;\n+\n+        for (i, &ident) in path.iter().enumerate() {\n+            let is_last = i == path.len() - 1;\n+            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+\n+            if i == 0 && allow_self && ns == TypeNS && ident.name == keywords::SelfValue.name() {\n+                module = Some(self.module_map[&self.current_module.normal_ancestor_id.unwrap()]);\n+                continue\n+            } else if i == 0 && allow_self && ns == TypeNS && ident.name == \"$crate\" {\n+                module = Some(self.resolve_crate_var(ident.ctxt));\n+                continue\n+            } else if allow_super && ns == TypeNS && ident.name == keywords::Super.name() {\n+                let current_module = if i == 0 { self.current_module } else { module.unwrap() };\n+                let self_module = self.module_map[&current_module.normal_ancestor_id.unwrap()];\n+                if let Some(parent) = self_module.parent {\n+                    module = Some(self.module_map[&parent.normal_ancestor_id.unwrap()]);\n+                    continue\n+                } else {\n+                    let msg = \"There are too many initial `super`s.\".to_string();\n+                    return PathResult::Failed(msg, false);\n+                }\n+            }\n+            allow_super = false;\n+\n+            let binding = if let Some(module) = module {\n+                self.resolve_name_in_module(module, ident.name, ns, false, record_used)\n+            } else {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, record_used) {\n+                    Some(LexicalScopeBinding::Item(binding)) => Ok(binding),\n+                    Some(LexicalScopeBinding::Def(def)) if opt_ns.is_some() => {\n+                        return PathResult::NonModule(PathResolution {\n+                            base_def: def,\n+                            depth: path.len() - 1,\n+                        });\n+                    }\n+                    _ => Err(if record_used.is_some() { Determined } else { Undetermined }),\n+                }\n+            };\n+\n+            match binding {\n+                Ok(binding) => {\n+                    if let Some(next_module) = binding.module() {\n+                        module = Some(next_module);\n+                    } else if binding.def() == Def::Err {\n+                        return PathResult::NonModule(err_path_resolution());\n+                    } else if opt_ns.is_some() {\n+                        return PathResult::NonModule(PathResolution {\n+                            base_def: binding.def(),\n+                            depth: path.len() - i - 1,\n+                        });\n+                    } else {\n+                        return PathResult::Failed(format!(\"Not a module `{}`\", ident), is_last);\n+                    }\n+                }\n+                Err(Undetermined) => return PathResult::Indeterminate,\n+                Err(Determined) => {\n+                    if let Some(module) = module {\n+                        if opt_ns.is_some() && !module.is_normal() {\n+                            return PathResult::NonModule(PathResolution {\n+                                base_def: module.def().unwrap(),\n+                                depth: path.len() - i,\n+                            });\n+                        }\n+                    }\n+                    let msg = if module.and_then(ModuleS::def) == self.graph_root.def() {\n+                        let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n+                        let mut candidates =\n+                            self.lookup_candidates(ident.name, TypeNS, is_mod).candidates;\n+                        candidates.sort_by_key(|path| (path.segments.len(), path.to_string()));\n+                        if let Some(candidate) = candidates.get(0) {\n+                            format!(\"Did you mean `{}`?\", candidate)\n+                        } else {\n+                            format!(\"Maybe a missing `extern crate {};`?\", ident)\n+                        }\n+                    } else if i == 0 {\n+                        format!(\"Use of undeclared type or module `{}`\", ident)\n+                    } else {\n+                        format!(\"Could not find `{}` in `{}`\", ident, path[i - 1])\n+                    };\n+                    return PathResult::Failed(msg, is_last);\n+                }\n+            }\n         }\n \n-        self.resolve_ident_in_lexical_scope(identifier, namespace, record_used)\n-            .map(LexicalScopeBinding::local_def)\n+        PathResult::Module(module.unwrap())\n     }\n \n     // Resolve a local definition, potentially adjusting for closures.\n-    fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Option<Def> {\n+    fn adjust_local_def(&mut self, local_def: LocalDef, span: Span) -> Def {\n         let ribs = match local_def.ribs {\n             Some((ns, i)) => &self.ribs[ns][i + 1..],\n             None => &[] as &[_],\n@@ -2705,14 +2459,14 @@ impl<'a> Resolver<'a> {\n                             resolve_error(self,\n                                           span,\n                                           ResolutionError::CannotCaptureDynamicEnvironmentInFnItem);\n-                            return None;\n+                            return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n                             resolve_error(self,\n                                           span,\n                                           ResolutionError::AttemptToUseNonConstantValueInConstant);\n-                            return None;\n+                            return Def::Err;\n                         }\n                     }\n                 }\n@@ -2731,82 +2485,19 @@ impl<'a> Resolver<'a> {\n                             resolve_error(self,\n                                           span,\n                                           ResolutionError::TypeParametersFromOuterFunction);\n-                            return None;\n+                            return Def::Err;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n                             resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n-                            return None;\n+                            return Def::Err;\n                         }\n                     }\n                 }\n             }\n             _ => {}\n         }\n-        return Some(def);\n-    }\n-\n-    // resolve a \"module-relative\" path, e.g. a::b::c\n-    fn resolve_module_relative_path(&mut self,\n-                                    span: Span,\n-                                    segments: &[ast::PathSegment],\n-                                    namespace: Namespace)\n-                                    -> Result<&'a NameBinding<'a>,\n-                                              bool /* true if an error was reported */> {\n-        let module_path =\n-            segments.split_last().unwrap().1.iter().map(|ps| ps.identifier).collect::<Vec<_>>();\n-\n-        let module = match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n-            Failed(err) => {\n-                if let Some((span, msg)) = err {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                return Err(true);\n-            }\n-            Indeterminate => return Err(false),\n-            Success(module) => module,\n-        };\n-\n-        let name = segments.last().unwrap().identifier.name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n-        result.success().ok_or(false)\n-    }\n-\n-    /// Invariant: This must be called only during main resolution, not during\n-    /// import resolution.\n-    fn resolve_crate_relative_path<T>(&mut self, span: Span, segments: &[T], namespace: Namespace)\n-                                      -> Result<&'a NameBinding<'a>,\n-                                                bool /* true if an error was reported */>\n-        where T: Named,\n-    {\n-        let module_path = segments.split_last().unwrap().1.iter().map(T::ident).collect::<Vec<_>>();\n-        let root = self.graph_root;\n-\n-        let module = match self.resolve_module_path_from_root(root, &module_path, 0, Some(span)) {\n-            Failed(err) => {\n-                if let Some((span, msg)) = err {\n-                    resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                return Err(true);\n-            }\n-\n-            Indeterminate => return Err(false),\n-\n-            Success(module) => module,\n-        };\n-\n-        let name = segments.last().unwrap().ident().name;\n-        let result = self.resolve_name_in_module(module, name, namespace, false, Some(span));\n-        result.success().ok_or(false)\n-    }\n-\n-    fn with_no_errors<T, F>(&mut self, f: F) -> T\n-        where F: FnOnce(&mut Resolver) -> T\n-    {\n-        self.emit_errors = false;\n-        let rs = f(self);\n-        self.emit_errors = true;\n-        rs\n+        return def;\n     }\n \n     // Calls `f` with a `Resolver` whose current lexical scope is `module`'s lexical scope,\n@@ -2932,11 +2623,7 @@ impl<'a> Resolver<'a> {\n \n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n-                        if self.emit_errors {\n-                            err.help(&msg);\n-                        } else {\n-                            err.span_help(expr.span, &msg);\n-                        }\n+                        err.help(&msg);\n                         err.emit();\n                         self.record_def(expr.id, err_path_resolution());\n                     } else {\n@@ -2957,109 +2644,94 @@ impl<'a> Resolver<'a> {\n                 } else {\n                     // Be helpful if the name refers to a struct\n                     let path_name = path_names_to_string(path, 0);\n-                    let type_res = self.with_no_errors(|this| {\n-                        this.resolve_path(expr.id, path, 0, TypeNS)\n-                    });\n+                    let ast::Path { ref segments, global, .. } = *path;\n+                    let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n+                    let scope = if global { PathScope::Global } else { PathScope::Lexical };\n+                    let type_res = match self.resolve_path(&path, scope, Some(TypeNS), None) {\n+                        PathResult::NonModule(type_res) => Some(type_res),\n+                        _ => None,\n+                    };\n \n                     self.record_def(expr.id, err_path_resolution());\n \n-                    if let Ok(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n+                    if let Some(Def::Struct(..)) = type_res.map(|r| r.base_def) {\n                         let error_variant =\n                             ResolutionError::StructVariantUsedAsFunction(&path_name);\n                         let mut err = resolve_struct_error(self, expr.span, error_variant);\n \n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n \n-                        if self.emit_errors {\n-                            err.help(&msg);\n-                        } else {\n-                            err.span_help(expr.span, &msg);\n-                        }\n+                        err.help(&msg);\n                         err.emit();\n                     } else {\n                         // Keep reporting some errors even if they're ignored above.\n-                        if let Err(true) = self.resolve_path(expr.id, path, 0, ValueNS) {\n-                            // `resolve_path` already reported the error\n+                        let mut method_scope = false;\n+                        let mut is_static = false;\n+                        self.ribs[ValueNS].iter().rev().all(|rib| {\n+                            method_scope = match rib.kind {\n+                                MethodRibKind(is_static_) => {\n+                                    is_static = is_static_;\n+                                    true\n+                                }\n+                                ItemRibKind | ConstantItemRibKind => false,\n+                                _ => return true, // Keep advancing\n+                            };\n+                            false // Stop advancing\n+                        });\n+\n+                        if method_scope && keywords::SelfValue.name() == &*path_name {\n+                            let error = ResolutionError::SelfNotAvailableInStaticMethod;\n+                            resolve_error(self, expr.span, error);\n                         } else {\n-                            let mut method_scope = false;\n-                            let mut is_static = false;\n-                            self.ribs[ValueNS].iter().rev().all(|rib| {\n-                                method_scope = match rib.kind {\n-                                    MethodRibKind(is_static_) => {\n-                                        is_static = is_static_;\n-                                        true\n-                                    }\n-                                    ItemRibKind | ConstantItemRibKind => false,\n-                                    _ => return true, // Keep advancing\n-                                };\n-                                false // Stop advancing\n-                            });\n+                            let fallback =\n+                                self.find_fallback_in_self_type(path.last().unwrap().name);\n+                            let (mut msg, is_field) = match fallback {\n+                                NoSuggestion => {\n+                                    // limit search to 5 to reduce the number\n+                                    // of stupid suggestions\n+                                    (match self.find_best_match(&path_name) {\n+                                        SuggestionType::Macro(s) => {\n+                                            format!(\"the macro `{}`\", s)\n+                                        }\n+                                        SuggestionType::Function(s) => format!(\"`{}`\", s),\n+                                        SuggestionType::NotFound => \"\".to_string(),\n+                                    }, false)\n+                                }\n+                                Field => {\n+                                    (if is_static && method_scope {\n+                                        \"\".to_string()\n+                                    } else {\n+                                        format!(\"`self.{}`\", path_name)\n+                                    }, true)\n+                                }\n+                                TraitItem => (format!(\"to call `self.{}`\", path_name), false),\n+                                TraitMethod(path_str) =>\n+                                    (format!(\"to call `{}::{}`\", path_str, path_name), false),\n+                            };\n \n-                            if method_scope && keywords::SelfValue.name() == &*path_name {\n-                                resolve_error(self,\n-                                              expr.span,\n-                                              ResolutionError::SelfNotAvailableInStaticMethod);\n+                            let mut context = UnresolvedNameContext::Other;\n+                            let mut def = Def::Err;\n+                            if !msg.is_empty() {\n+                                msg = format!(\"did you mean {}?\", msg);\n                             } else {\n-                                let last_name = path.segments.last().unwrap().identifier.name;\n-                                let (mut msg, is_field) =\n-                                    match self.find_fallback_in_self_type(last_name) {\n-                                    NoSuggestion => {\n-                                        // limit search to 5 to reduce the number\n-                                        // of stupid suggestions\n-                                        (match self.find_best_match(&path_name) {\n-                                            SuggestionType::Macro(s) => {\n-                                                format!(\"the macro `{}`\", s)\n-                                            }\n-                                            SuggestionType::Function(s) => format!(\"`{}`\", s),\n-                                            SuggestionType::NotFound => \"\".to_string(),\n-                                        }, false)\n-                                    }\n-                                    Field => {\n-                                        (if is_static && method_scope {\n-                                            \"\".to_string()\n-                                        } else {\n-                                            format!(\"`self.{}`\", path_name)\n-                                        }, true)\n-                                    }\n-                                    TraitItem => (format!(\"to call `self.{}`\", path_name), false),\n-                                    TraitMethod(path_str) =>\n-                                        (format!(\"to call `{}::{}`\", path_str, path_name), false),\n-                                };\n-\n-                                let mut context =  UnresolvedNameContext::Other;\n-                                let mut def = Def::Err;\n-                                if !msg.is_empty() {\n-                                    msg = format!(\"did you mean {}?\", msg);\n-                                } else {\n-                                    // we display a help message if this is a module\n-                                    let name_path: Vec<_> =\n-                                        path.segments.iter().map(|seg| seg.identifier).collect();\n-\n-                                    match self.resolve_module_path(&name_path[..],\n-                                                                   UseLexicalScope,\n-                                                                   Some(expr.span)) {\n-                                        Success(e) => {\n-                                            if let Some(def_type) = e.def() {\n-                                                def = def_type;\n-                                            }\n-                                            context = UnresolvedNameContext::PathIsMod(parent);\n-                                        },\n-                                        _ => {},\n-                                    };\n+                                // we display a help message if this is a module\n+                                if let PathResult::Module(module) =\n+                                        self.resolve_path(&path, scope, None, None) {\n+                                    def = module.def().unwrap();\n+                                    context = UnresolvedNameContext::PathIsMod(parent);\n                                 }\n-\n-                                resolve_error(self,\n-                                              expr.span,\n-                                              ResolutionError::UnresolvedName {\n-                                                  path: &path_name,\n-                                                  message: &msg,\n-                                                  context: context,\n-                                                  is_static_method: method_scope && is_static,\n-                                                  is_field: is_field,\n-                                                  def: def,\n-                                              });\n                             }\n+\n+                            let error = ResolutionError::UnresolvedName {\n+                                path: &path_name,\n+                                message: &msg,\n+                                context: context,\n+                                is_static_method: method_scope && is_static,\n+                                is_field: is_field,\n+                                def: def,\n+                            };\n+                            resolve_error(self, expr.span, error);\n                         }\n                     }\n                 }\n@@ -3285,7 +2957,7 @@ impl<'a> Resolver<'a> {\n                         segms.push(segment);\n                         let path = Path {\n                             span: span,\n-                            global: true,\n+                            global: false,\n                             segments: segms,\n                         };\n                         // the entity is accessible in the following cases:\n@@ -3302,7 +2974,7 @@ impl<'a> Resolver<'a> {\n                 }\n \n                 // collect submodules to explore\n-                if let Ok(module) = name_binding.module() {\n+                if let Some(module) = name_binding.module() {\n                     // form the path\n                     let mut path_segments = path_segments.clone();\n                     path_segments.push(PathSegment {\n@@ -3335,34 +3007,32 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn resolve_visibility(&mut self, vis: &ast::Visibility) -> ty::Visibility {\n-        let (path, id) = match *vis {\n+        let (segments, span, id) = match *vis {\n             ast::Visibility::Public => return ty::Visibility::Public,\n             ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n-            ast::Visibility::Restricted { ref path, id } => (path, id),\n+            ast::Visibility::Restricted { ref path, id } => (&path.segments, path.span, id),\n             ast::Visibility::Inherited => {\n                 return ty::Visibility::Restricted(self.current_module.normal_ancestor_id.unwrap());\n             }\n         };\n \n-        let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier).collect();\n+        let path: Vec<_> = segments.iter().map(|seg| seg.identifier).collect();\n         let mut path_resolution = err_path_resolution();\n-        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n-            Success(module) => {\n+        let vis = match self.resolve_path(&path, PathScope::Import, None, Some(span)) {\n+            PathResult::Module(module) => {\n                 path_resolution = PathResolution::new(module.def().unwrap());\n                 ty::Visibility::Restricted(module.normal_ancestor_id.unwrap())\n             }\n-            Indeterminate => unreachable!(),\n-            Failed(err) => {\n-                if let Some((span, msg)) = err {\n-                    self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n-                }\n+            PathResult::Failed(msg, _) => {\n+                self.session.span_err(span, &format!(\"failed to resolve module path. {}\", msg));\n                 ty::Visibility::Public\n             }\n+            _ => ty::Visibility::Public,\n         };\n         self.def_map.insert(id, path_resolution);\n         if !self.is_accessible(vis) {\n             let msg = format!(\"visibilities can only be restricted to ancestor modules\");\n-            self.session.span_err(path.span, &msg);\n+            self.session.span_err(span, &msg);\n         }\n         vis\n     }\n@@ -3465,8 +3135,8 @@ impl<'a> Resolver<'a> {\n                 (ValueNS, _) => \"a value\",\n                 (MacroNS, _) => \"a macro\",\n                 (TypeNS, _) if old_binding.is_extern_crate() => \"an extern crate\",\n-                (TypeNS, Ok(module)) if module.is_normal() => \"a module\",\n-                (TypeNS, Ok(module)) if module.is_trait() => \"a trait\",\n+                (TypeNS, Some(module)) if module.is_normal() => \"a module\",\n+                (TypeNS, Some(module)) if module.is_trait() => \"a trait\",\n                 (TypeNS, _) => \"a type\",\n             };\n             format!(\"{} named `{}` has already been {} in this {}\","}, {"sha": "3b34a60c585255616791a1d0f9d6ed290ddda5af", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -10,7 +10,6 @@\n \n use {Module, ModuleKind, NameBinding, NameBindingKind, Resolver, AmbiguityError};\n use Namespace::{self, MacroNS};\n-use ResolveResult::{Success, Indeterminate, Failed};\n use build_reduced_graph::BuildReducedGraphVisitor;\n use resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex};\n@@ -254,7 +253,7 @@ impl<'a> Resolver<'a> {\n             // Since expanded macros may not shadow the lexical scope (enforced below),\n             // we can ignore unresolved invocations (indicated by the penultimate argument).\n             match self.resolve_name_in_module(module, name, ns, true, record_used) {\n-                Success(binding) => {\n+                Ok(binding) => {\n                     let span = match record_used {\n                         Some(span) => span,\n                         None => return Some(binding),\n@@ -270,8 +269,8 @@ impl<'a> Resolver<'a> {\n                         potential_expanded_shadower = Some(binding);\n                     }\n                 },\n-                Indeterminate => return None,\n-                Failed(..) => {}\n+                Err(Determinacy::Undetermined) => return None,\n+                Err(Determinacy::Determined) => {}\n             }\n \n             match module.kind {"}, {"sha": "2a803d72fd1bdb720a6bc0390303a46e3faeaafd", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 48, "deletions": 68, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -12,11 +12,8 @@ use self::ImportDirectiveSubclass::*;\n \n use {Module, PerNS};\n use Namespace::{self, TypeNS, MacroNS};\n-use {NameBinding, NameBindingKind, PrivacyError, ToNameBinding};\n-use ResolveResult;\n-use ResolveResult::*;\n+use {NameBinding, NameBindingKind, PathResult, PathScope, PrivacyError, ToNameBinding};\n use Resolver;\n-use UseLexicalScopeFlag::DontUseLexicalScope;\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n \n@@ -27,6 +24,7 @@ use rustc::hir::def::*;\n use syntax::ast::{Ident, NodeId, Name};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::hygiene::Mark;\n+use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n@@ -142,32 +140,32 @@ impl<'a> Resolver<'a> {\n                                   ns: Namespace,\n                                   ignore_unresolved_invocations: bool,\n                                   record_used: Option<Span>)\n-                                  -> ResolveResult<&'a NameBinding<'a>> {\n+                                  -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.populate_module_if_necessary(module);\n \n         let resolution = self.resolution(module, name, ns);\n         let resolution = match resolution.borrow_state() {\n             ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n-            _ => return Failed(None), // This happens when there is a cycle of imports\n+            _ => return Err(Determined), // This happens when there is a cycle of imports\n         };\n \n         if let Some(span) = record_used {\n             if let Some(binding) = resolution.binding {\n                 if self.record_use(name, ns, binding, span) {\n-                    return Success(self.dummy_binding);\n+                    return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n                     self.privacy_errors.push(PrivacyError(span, name, binding));\n                 }\n             }\n \n-            return resolution.binding.map(Success).unwrap_or(Failed(None));\n+            return resolution.binding.ok_or(Determined);\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n             // `extern crate` are always usable for backwards compatability, see issue #37020.\n             let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n-            if usable { Success(binding) } else { Failed(None) }\n+            if usable { Ok(binding) } else { Err(Determined) }\n         };\n \n         // Items and single imports are not shadowable.\n@@ -179,19 +177,19 @@ impl<'a> Resolver<'a> {\n \n         // Check if a single import can still define the name.\n         match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Indeterminate,\n+            SingleImports::AtLeastOne => return Err(Undetermined),\n             SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n                 let module = match directive.imported_module.get() {\n                     Some(module) => module,\n-                    None => return Indeterminate,\n+                    None => return Err(Undetermined),\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     _ => unreachable!(),\n                 };\n                 match self.resolve_name_in_module(module, name, ns, false, None) {\n-                    Failed(_) => {}\n-                    _ => return Indeterminate,\n+                    Err(Determined) => {}\n+                    _ => return Err(Undetermined),\n                 }\n             }\n             SingleImports::MaybeOne(_) | SingleImports::None => {},\n@@ -204,24 +202,24 @@ impl<'a> Resolver<'a> {\n             Some(binding) if no_unresolved_invocations || ns == MacroNS =>\n                 return check_usable(self, binding),\n             None if no_unresolved_invocations => {}\n-            _ => return Indeterminate,\n+            _ => return Err(Undetermined),\n         }\n \n         // Check if the globs are determined\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n                 if let Some(module) = directive.imported_module.get() {\n                     let result = self.resolve_name_in_module(module, name, ns, false, None);\n-                    if let Indeterminate = result {\n-                        return Indeterminate;\n+                    if let Err(Undetermined) = result {\n+                        return Err(Undetermined);\n                     }\n                 } else {\n-                    return Indeterminate;\n+                    return Err(Undetermined);\n                 }\n             }\n         }\n \n-        Failed(None)\n+        Err(Determined)\n     }\n \n     // Add an import directive to the current module.\n@@ -421,9 +419,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             prev_num_indeterminates = self.indeterminate_imports.len();\n             for import in mem::replace(&mut self.indeterminate_imports, Vec::new()) {\n                 match self.resolve_import(&import) {\n-                    Failed(_) => self.determined_imports.push(import),\n-                    Indeterminate => self.indeterminate_imports.push(import),\n-                    Success(()) => self.determined_imports.push(import),\n+                    true => self.determined_imports.push(import),\n+                    false => self.indeterminate_imports.push(import),\n                 }\n             }\n         }\n@@ -437,19 +434,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let mut errors = false;\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Failed(err) = self.finalize_import(import) {\n+            if let Some(err) = self.finalize_import(import) {\n                 errors = true;\n-                let (span, help) = match err {\n-                    Some((span, msg)) => (span, msg),\n-                    None => continue,\n-                };\n \n                 // If the error is a single failed import then create a \"fake\" import\n                 // resolution for it so that later resolve stages won't complain.\n                 self.import_dummy_binding(import);\n                 let path = import_path_to_string(&import.module_path, &import.subclass);\n-                let error = ResolutionError::UnresolvedImport(Some((&path, &help)));\n-                resolve_error(self.resolver, span, error);\n+                let error = ResolutionError::UnresolvedImport(Some((&path, &err)));\n+                resolve_error(self.resolver, import.span, error);\n             }\n         }\n \n@@ -463,12 +456,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n \n-    /// Attempts to resolve the given import. The return value indicates\n-    /// failure if we're certain the name does not exist, indeterminate if we\n-    /// don't know whether the name exists at the moment due to other\n-    /// currently-unresolved imports, or success if we know the name exists.\n+    /// Attempts to resolve the given import, returning true if its resolution is determined.\n     /// If successful, the resolved bindings are written into the module.\n-    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n+    fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n@@ -482,14 +472,13 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will not define any names\n             // while resolving its module path.\n             directive.vis.set(ty::Visibility::PrivateExternal);\n-            let result =\n-                self.resolve_module_path(&directive.module_path, DontUseLexicalScope, None);\n+            let result = self.resolve_path(&directive.module_path, PathScope::Import, None, None);\n             directive.vis.set(vis);\n \n             match result {\n-                Success(module) => module,\n-                Indeterminate => return Indeterminate,\n-                Failed(err) => return Failed(err),\n+                PathResult::Module(module) => module,\n+                PathResult::Indeterminate => return false,\n+                _ => return true,\n             }\n         };\n \n@@ -498,21 +487,15 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             SingleImport { source, target, ref result } => (source, target, result),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n-                return Success(());\n+                return true;\n             }\n             _ => unreachable!(),\n         };\n \n         let mut indeterminate = false;\n         self.per_ns(|this, ns| {\n             if let Err(Undetermined) = result[ns].get() {\n-                result[ns].set({\n-                    match this.resolve_name_in_module(module, source, ns, false, None) {\n-                        Success(binding) => Ok(binding),\n-                        Indeterminate => Err(Undetermined),\n-                        Failed(_) => Err(Determined),\n-                    }\n-                });\n+                result[ns].set(this.resolve_name_in_module(module, source, ns, false, None));\n             } else {\n                 return\n             };\n@@ -544,38 +527,35 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         });\n \n-        if indeterminate { Indeterminate } else { Success(()) }\n+        !indeterminate\n     }\n \n-    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n+    // If appropriate, returns an error to report.\n+    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<String> {\n         self.current_module = directive.parent;\n \n         let ImportDirective { ref module_path, span, .. } = *directive;\n-        let module_result = self.resolve_module_path(&module_path, DontUseLexicalScope, Some(span));\n+        let module_result = self.resolve_path(&module_path, PathScope::Import, None, Some(span));\n         let module = match module_result {\n-            Success(module) => module,\n-            Indeterminate => return Indeterminate,\n-            Failed(err) => {\n-                let self_module = self.module_map[&self.current_module.normal_ancestor_id.unwrap()];\n-\n-                let resolve_from_self_result = self.resolve_module_path_from_root(\n-                    &self_module, &module_path, 0, Some(span));\n-\n-                return if let Success(_) = resolve_from_self_result {\n-                    let msg = format!(\"Did you mean `self::{}`?\", &names_to_string(module_path));\n-                    Failed(Some((span, msg)))\n+            PathResult::Module(module) => module,\n+            PathResult::Failed(msg, _) => {\n+                let mut path = vec![keywords::SelfValue.ident()];\n+                path.extend(module_path);\n+                let result = self.resolve_path(&path, PathScope::Import, None, None);\n+                return if let PathResult::Module(..) = result {\n+                    Some(format!(\"Did you mean `self::{}`?\", &names_to_string(module_path)))\n                 } else {\n-                    Failed(err)\n+                    Some(msg)\n                 };\n             },\n+            _ => return None,\n         };\n \n         let (name, result) = match directive.subclass {\n             SingleImport { source, ref result, .. } => (source, result),\n             GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n                 // Importing a module into itself is not allowed.\n-                let msg = \"Cannot glob-import a module into itself.\".into();\n-                return Failed(Some((directive.span, msg)));\n+                return Some(\"Cannot glob-import a module into itself.\".to_string());\n             }\n             GlobImport { is_prelude, ref max_vis } => {\n                 if !is_prelude &&\n@@ -584,7 +564,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     let msg = \"A non-empty glob must import something with the glob's visibility\";\n                     self.session.span_err(directive.span, msg);\n                 }\n-                return Success(());\n+                return None;\n             }\n             _ => unreachable!(),\n         };\n@@ -604,7 +584,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| {\n                 match this.resolve_name_in_module(module, name, ns, false, Some(span)) {\n-                    Success(_) => all_ns_failed = false,\n+                    Ok(_) => all_ns_failed = false,\n                     _ => {}\n                 }\n             });\n@@ -629,11 +609,11 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 } else {\n                     format!(\"no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n                 };\n-                Failed(Some((directive.span, msg)))\n+                Some(msg)\n             } else {\n                 // `resolve_name_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n-                Success(())\n+                None\n             }\n         }\n \n@@ -682,7 +662,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         });\n \n         debug!(\"(resolving single import) successfully resolved import\");\n-        return Success(());\n+        None\n     }\n \n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {"}, {"sha": "bee05cd53133af19aea1d9816c2e1df2e6d0d3d7", "filename": "src/test/compile-fail/issue-28388-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a0248068c693c64f74623e9a6f7504b900df8a6/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28388-1.rs?ref=5a0248068c693c64f74623e9a6f7504b900df8a6", "patch": "@@ -10,6 +10,6 @@\n \n // Prefix in imports with empty braces should be resolved and checked privacy, stability, etc.\n \n-use foo::{}; //~ ERROR failed to resolve. foo\n+use foo::{}; //~ ERROR failed to resolve. Maybe a missing `extern crate foo;`?\n \n fn main() {}"}]}