{"sha": "d5b6c046de79bf357683d9db191ed6a97c24187c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1YjZjMDQ2ZGU3OWJmMzU3NjgzZDlkYjE5MWVkNmE5N2MyNDE4N2M=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-11T00:43:36Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2017-03-28T17:38:55Z"}, "message": "Add missing markdown tags", "tree": {"sha": "3c60116a9cd20e1bd13ab915dfacc4f40da817c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c60116a9cd20e1bd13ab915dfacc4f40da817c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5b6c046de79bf357683d9db191ed6a97c24187c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5b6c046de79bf357683d9db191ed6a97c24187c", "html_url": "https://github.com/rust-lang/rust/commit/d5b6c046de79bf357683d9db191ed6a97c24187c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5b6c046de79bf357683d9db191ed6a97c24187c/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6baea23bad46050e8f0840713c9d13a40edaf68", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6baea23bad46050e8f0840713c9d13a40edaf68", "html_url": "https://github.com/rust-lang/rust/commit/f6baea23bad46050e8f0840713c9d13a40edaf68"}], "stats": {"total": 402, "additions": 251, "deletions": 151}, "files": [{"sha": "e8c95c4a21c3fafc56bc94b904a8504b1895ec3f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 239, "deletions": 142, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d5b6c046de79bf357683d9db191ed6a97c24187c", "patch": "@@ -26,13 +26,10 @@\n \n #![allow(non_camel_case_types)]\n \n-//use libc;\n use std::ascii::AsciiExt;\n use std::cell::RefCell;\n use std::default::Default;\n-//use std::ffi::CString;\n use std::fmt::{self, Write};\n-//use std::slice;\n use std::str;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::codemap::Span;\n@@ -45,11 +42,33 @@ use test;\n \n use pulldown_cmark::{self, Event, Parser, Tag};\n \n+#[derive(Copy, Clone)]\n+pub enum MarkdownOutputStyle {\n+    Compact,\n+    Fancy,\n+}\n+\n+impl MarkdownOutputStyle {\n+    pub fn is_compact(&self) -> bool {\n+        match *self {\n+            MarkdownOutputStyle::Compact => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_fancy(&self) -> bool {\n+        match *self {\n+            MarkdownOutputStyle::Fancy => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A unit struct which has the `fmt::Display` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n // The second parameter is whether we need a shorter version or not.\n-pub struct Markdown<'a>(pub &'a str, pub bool);\n+pub struct Markdown<'a>(pub &'a str, pub MarkdownOutputStyle);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n pub struct MarkdownWithToc<'a>(pub &'a str);\n@@ -85,25 +104,19 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n     RefCell::new(None)\n });\n \n-\n pub fn render(w: &mut fmt::Formatter,\n               s: &str,\n               print_toc: bool,\n-              shorter: bool) -> fmt::Result {\n+              shorter: MarkdownOutputStyle) -> fmt::Result {\n     fn block(parser: &mut Parser, buffer: &mut String, lang: &str) {\n         let mut origtext = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::CodeBlock(_)) => break,\n-                    Event::Text(ref s) => {\n-                        origtext.push_str(s);\n-                    }\n-                    _ => {}\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::CodeBlock(_)) => break,\n+                Event::Text(ref s) => {\n+                    origtext.push_str(s);\n                 }\n-            } else {\n-                break\n+                _ => {}\n             }\n         }\n         let origtext = origtext.trim_left();\n@@ -176,20 +189,19 @@ pub fn render(w: &mut fmt::Formatter,\n     fn header(parser: &mut Parser, level: i32, toc_builder: &mut Option<TocBuilder>,\n               buffer: &mut String) {\n         let mut ret = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::Header(_)) => break,\n-                    Event::Text(ref s) => {\n-                        ret.push_str(s);\n-                    }\n-                    _ => {}\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Header(_)) => break,\n+                Event::Text(ref s) => {\n+                    ret.push_str(s);\n                 }\n-            } else {\n-                break\n+                Event::SoftBreak | Event::HardBreak if !ret.is_empty() => {\n+                    ret.push(' ');\n+                }\n+                _ => {}\n             }\n         }\n+        ret = ret.trim_right().to_owned();\n \n         let id = ret.clone();\n         // Discard '<em>', '<code>' tags and some escaped characters,\n@@ -226,169 +238,242 @@ pub fn render(w: &mut fmt::Formatter,\n \n     fn codespan(parser: &mut Parser, buffer: &mut String) {\n         let mut content = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::Code) => break,\n-                    Event::Text(ref s) => {\n-                        content.push_str(s);\n-                    }\n-                    _ => {}\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Code) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n                 }\n-            } else {\n-                break\n+                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n+                    content.push(' ');\n+                }\n+                _ => {}\n             }\n         }\n-        buffer.push_str(&format!(\"<code>{}</code>\", Escape(&collapse_whitespace(&content))));\n+        buffer.push_str(&format!(\"<code>{}</code>\", Escape(&collapse_whitespace(content.trim_right()))));\n     }\n \n-    fn link(parser: &mut Parser, buffer: &mut String, url: &str, mut title: String) {\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::Link(_, _)) => break,\n-                    Event::Text(ref s) => {\n-                        title.push_str(s);\n-                    }\n-                    _ => {}\n+    fn link(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: MarkdownOutputStyle, url: &str, mut title: String) {\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Link(_, _)) => break,\n+                Event::Text(ref s) => {\n+                    title.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak if !title.is_empty() => {\n+                    title.push(' ');\n+                }\n+                x => {\n+                    looper(parser, &mut title, Some(x), toc_builder, shorter);\n                 }\n-            } else {\n-                break\n             }\n         }\n         buffer.push_str(&format!(\"<a href=\\\"{}\\\">{}</a>\", url, title));\n     }\n \n     fn paragraph(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-                 shorter: bool) {\n+                 shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::Paragraph) => break,\n-                    Event::Text(ref s) => {\n-                        content.push_str(s);\n-                    }\n-                    x => {\n-                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                    }\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Paragraph) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n+                    content.push(' ');\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n                 }\n-            } else {\n-                break\n             }\n         }\n-        buffer.push_str(&format!(\"<p>{}</p>\", content));\n+        buffer.push_str(&format!(\"<p>{}</p>\", content.trim_right()));\n     }\n \n     fn cell(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: bool) {\n+            shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::TableHead) |\n-                        Event::End(Tag::Table(_)) |\n-                        Event::End(Tag::TableRow) |\n-                        Event::End(Tag::TableCell) => break,\n-                    Event::Text(ref s) => {\n-                        content.push_str(s);\n-                    }\n-                    x => {\n-                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                    }\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::TableHead) |\n+                    Event::End(Tag::Table(_)) |\n+                    Event::End(Tag::TableRow) |\n+                    Event::End(Tag::TableCell) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak => {\n+                    content.push(' ');\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n                 }\n-            } else {\n-                break\n             }\n         }\n         buffer.push_str(&format!(\"<td>{}</td>\", content.trim()));\n     }\n \n     fn row(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-           shorter: bool) {\n+           shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::TableHead) |\n-                        Event::End(Tag::Table(_)) |\n-                        Event::End(Tag::TableRow) => break,\n-                    Event::Start(Tag::TableCell) => {\n-                        cell(parser, &mut content, toc_builder, shorter);\n-                    }\n-                    x => {\n-                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                    }\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::TableHead) |\n+                    Event::End(Tag::Table(_)) |\n+                    Event::End(Tag::TableRow) => break,\n+                Event::Start(Tag::TableCell) => {\n+                    cell(parser, &mut content, toc_builder, shorter);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n                 }\n-            } else {\n-                break\n             }\n         }\n         buffer.push_str(&format!(\"<tr>{}</tr>\", content));\n     }\n \n     fn head(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-            shorter: bool) {\n+            shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n-                    Event::Start(Tag::TableCell) => {\n-                        cell(parser, &mut content, toc_builder, shorter);\n-                    }\n-                    x => {\n-                        looper(parser, &mut content, Some(x), toc_builder, shorter);\n-                    }\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::TableHead) | Event::End(Tag::Table(_)) => break,\n+                Event::Start(Tag::TableCell) => {\n+                    cell(parser, &mut content, toc_builder, shorter);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n                 }\n-            } else {\n-                break\n             }\n         }\n-        if content.is_empty() {\n-            return\n+        if !content.is_empty() {\n+            buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n         }\n-        buffer.push_str(&format!(\"<thead><tr>{}</tr></thead>\", content.replace(\"td>\", \"th>\")));\n     }\n \n     fn table(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n-             shorter: bool) {\n+             shorter: MarkdownOutputStyle) {\n         let mut content = String::new();\n         let mut rows = String::new();\n-        loop {\n-            let event = parser.next();\n-            if let Some(event) = event {\n-                match event {\n-                    Event::End(Tag::Table(_)) => break,\n-                    Event::Start(Tag::TableHead) => {\n-                        head(parser, &mut content, toc_builder, shorter);\n-                    }\n-                    Event::Start(Tag::TableRow) => {\n-                        row(parser, &mut rows, toc_builder, shorter);\n-                    }\n-                    _ => {}\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Table(_)) => break,\n+                Event::Start(Tag::TableHead) => {\n+                    head(parser, &mut content, toc_builder, shorter);\n                 }\n-            } else {\n-                break\n+                Event::Start(Tag::TableRow) => {\n+                    row(parser, &mut rows, toc_builder, shorter);\n+                }\n+                _ => {}\n             }\n         }\n         buffer.push_str(&format!(\"<table>{}{}</table>\",\n                                  content,\n-                                 if shorter || rows.is_empty() {\n+                                 if shorter.is_compact() || rows.is_empty() {\n                                      String::new()\n                                  } else {\n                                      format!(\"<tbody>{}</tbody>\", rows)\n                                  }));\n     }\n \n+    fn blockquote(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                  shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::BlockQuote) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n+                    content.push(' ');\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<blockquote>{}</blockquote>\", content.trim_right()));\n+    }\n+\n+    fn list_item(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                 shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Item) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<li>{}</li>\", content));\n+    }\n+\n+    fn list(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+            shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::List(_)) => break,\n+                Event::Start(Tag::Item) => {\n+                    list_item(parser, &mut content, toc_builder, shorter);\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<ul>{}</ul>\", content));\n+    }\n+\n+    fn emphasis(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+                shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Emphasis) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n+                    content.push(' ');\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<em>{}</em>\", content));\n+    }\n+\n+    fn strong(parser: &mut Parser, buffer: &mut String, toc_builder: &mut Option<TocBuilder>,\n+              shorter: MarkdownOutputStyle) {\n+        let mut content = String::new();\n+        while let Some(event) = parser.next() {\n+            match event {\n+                Event::End(Tag::Strong) => break,\n+                Event::Text(ref s) => {\n+                    content.push_str(s);\n+                }\n+                Event::SoftBreak | Event::HardBreak if !content.is_empty() => {\n+                    content.push(' ');\n+                }\n+                x => {\n+                    looper(parser, &mut content, Some(x), toc_builder, shorter);\n+                }\n+            }\n+        }\n+        buffer.push_str(&format!(\"<strong>{}</strong>\", content));\n+    }\n+\n     fn looper<'a>(parser: &'a mut Parser, buffer: &mut String, next_event: Option<Event<'a>>,\n-                  toc_builder: &mut Option<TocBuilder>, shorter: bool) -> bool {\n+                  toc_builder: &mut Option<TocBuilder>, shorter: MarkdownOutputStyle) -> bool {\n         if let Some(event) = next_event {\n             match event {\n                 Event::Start(Tag::CodeBlock(lang)) => {\n@@ -404,14 +489,26 @@ pub fn render(w: &mut fmt::Formatter,\n                     paragraph(parser, buffer, toc_builder, shorter);\n                 }\n                 Event::Start(Tag::Link(ref url, ref t)) => {\n-                    link(parser, buffer, url, t.as_ref().to_owned());\n+                    link(parser, buffer, toc_builder, shorter, url, t.as_ref().to_owned());\n                 }\n                 Event::Start(Tag::Table(_)) => {\n                     table(parser, buffer, toc_builder, shorter);\n                 }\n+                Event::Start(Tag::BlockQuote) => {\n+                    blockquote(parser, buffer, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::List(_)) => {\n+                    list(parser, buffer, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::Emphasis) => {\n+                    emphasis(parser, buffer, toc_builder, shorter);\n+                }\n+                Event::Start(Tag::Strong) => {\n+                    strong(parser, buffer, toc_builder, shorter);\n+                }\n                 _ => {}\n             }\n-            shorter == false\n+            shorter.is_fancy()\n         } else {\n             false\n         }\n@@ -594,7 +691,7 @@ impl<'a> fmt::Display for Markdown<'a> {\n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n-        render(fmt, md, true, false)\n+        render(fmt, md, true, MarkdownOutputStyle::Fancy)\n     }\n }\n \n@@ -603,7 +700,7 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n         let MarkdownHtml(md) = *self;\n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n-        render(fmt, md, false, false)\n+        render(fmt, md, false, MarkdownOutputStyle::Fancy)\n     }\n }\n \n@@ -660,7 +757,7 @@ pub fn plain_summary_line(md: &str) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml};\n+    use super::{LangString, Markdown, MarkdownHtml, MarkdownOutputStyle};\n     use super::plain_summary_line;\n     use html::render::reset_ids;\n \n@@ -700,14 +797,14 @@ mod tests {\n     #[test]\n     fn issue_17736() {\n         let markdown = \"# title\";\n-        format!(\"{}\", Markdown(markdown));\n+        format!(\"{}\", Markdown(markdown, MarkdownOutputStyle::Fancy));\n         reset_ids(true);\n     }\n \n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input));\n+            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n             assert_eq!(output, expect);\n             reset_ids(true);\n         }\n@@ -729,7 +826,7 @@ mod tests {\n     #[test]\n     fn test_header_ids_multiple_blocks() {\n         fn t(input: &str, expect: &str) {\n-            let output = format!(\"{}\", Markdown(input));\n+            let output = format!(\"{}\", Markdown(input, MarkdownOutputStyle::Fancy));\n             assert_eq!(output, expect);\n         }\n "}, {"sha": "1fa348a1be4c448191f937ae6fd7a1c390039f0b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d5b6c046de79bf357683d9db191ed6a97c24187c", "patch": "@@ -72,7 +72,7 @@ use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownOutputStyle};\n use html::{highlight, layout};\n \n /// A pair of name and its optional document.\n@@ -1650,7 +1650,8 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n         } else {\n             format!(\"{}\", &plain_summary_line(Some(s)))\n         };\n-        write!(w, \"<div class='docblock'>{}</div>\", Markdown(&markdown, false))?;\n+        write!(w, \"<div class='docblock'>{}</div>\",\n+               Markdown(&markdown, MarkdownOutputStyle::Fancy))?;\n     }\n     Ok(())\n }\n@@ -1683,7 +1684,8 @@ fn get_doc_value(item: &clean::Item) -> Option<&str> {\n fn document_full(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n     if let Some(s) = get_doc_value(item) {\n         write!(w, \"<div class='docblock'>{}</div>\",\n-               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s), false))?;\n+               Markdown(&format!(\"{}{}\", md_render_assoc_item(item), s),\n+                                 MarkdownOutputStyle::Fancy))?;\n     }\n     Ok(())\n }\n@@ -1871,7 +1873,8 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                        </tr>\",\n                        name = *myitem.name.as_ref().unwrap(),\n                        stab_docs = stab_docs,\n-                       docs = shorter(Some(&Markdown(doc_value, true).to_string())),\n+                       docs = shorter(Some(&Markdown(doc_value,\n+                                                     MarkdownOutputStyle::Compact).to_string())),\n                        class = myitem.type_(),\n                        stab = myitem.stability_class().unwrap_or(\"\".to_string()),\n                        unsafety_flag = unsafety_flag,\n@@ -2901,7 +2904,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         write!(w, \"</span>\")?;\n         write!(w, \"</h3>\\n\")?;\n         if let Some(ref dox) = i.impl_item.doc_value() {\n-            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, false))?;\n+            write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox, MarkdownOutputStyle::Fancy))?;\n         }\n     }\n "}, {"sha": "d29e98f8fe105bbefa67f4aecaaefbbfa5386d33", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=d5b6c046de79bf357683d9db191ed6a97c24187c", "patch": "@@ -25,7 +25,7 @@ use externalfiles::{ExternalHtml, LoadStringError, load_string};\n use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n+use html::markdown::{Markdown, MarkdownWithToc, MarkdownOutputStyle, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `%`.\n@@ -94,7 +94,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n     let rendered = if include_toc {\n         format!(\"{}\", MarkdownWithToc(text))\n     } else {\n-        format!(\"{}\", Markdown(text, false))\n+        format!(\"{}\", Markdown(text, MarkdownOutputStyle::Fancy))\n     };\n \n     let err = write!("}, {"sha": "1d4f2c60d544f6ea05366167e93ba0aed74bc959", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5b6c046de79bf357683d9db191ed6a97c24187c/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=d5b6c046de79bf357683d9db191ed6a97c24187c", "patch": "@@ -24,7 +24,7 @@ use std::path::PathBuf;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, MarkdownOutputStyle, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -100,7 +100,7 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, false))?,\n+            Some(ref desc) => write!(output, \"{}\", Markdown(desc, MarkdownOutputStyle::Fancy))?,\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}