{"sha": "893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5M2JiZWE1NzY1YTNlOWE2YTE1ODFjN2Y4Y2MxZmMwMmEyY2M3YWU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-20T23:16:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-02-24T02:39:11Z"}, "message": "Minor renaming to help my comprehension.", "tree": {"sha": "db27428997a69c687a05d111e6dd0ee4635cc001", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db27428997a69c687a05d111e6dd0ee4635cc001"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae", "html_url": "https://github.com/rust-lang/rust/commit/893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "050b8bfdf86fcb1daa1404411cb51fc4a46a1206", "url": "https://api.github.com/repos/rust-lang/rust/commits/050b8bfdf86fcb1daa1404411cb51fc4a46a1206", "html_url": "https://github.com/rust-lang/rust/commit/050b8bfdf86fcb1daa1404411cb51fc4a46a1206"}], "stats": {"total": 82, "additions": 44, "deletions": 38}, "files": [{"sha": "94220ccd743330bb8f2d1f044c3d66a39d23a9fe", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=893bbea5765a3e9a6a1581c7f8cc1fc02a2cc7ae", "patch": "@@ -146,12 +146,15 @@ type env =\n // since export restrictions should only be applied for the former.\n enum dir { inside, outside, }\n \n-// There are two types of ns_value enum: \"definitely a enum\";\n-// and \"any value\". This is so that lookup can behave differently\n-// when looking up a variable name that's not yet in scope to check\n-// if it's already bound to a enum.\n-enum namespace { ns_val(ns_value_type), ns_type, ns_module, }\n-enum ns_value_type { ns_an_enum, ns_any_value, }\n+// There are two types of ns_value enum: \"definitely a enum\"; and \"enum or\n+// other value\". This is so that lookup can behave differently when looking up\n+// a variable name that's not yet in scope to check if it's already bound to a\n+// enum.\n+enum namespace { ns_val(enumness), ns_type, ns_module, }\n+enum enumness {\n+    definite_enum,\n+    value_or_enum\n+}\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -372,7 +375,7 @@ fn check_unused_imports(e: @env) {\n \n fn resolve_capture_item(e: @env, sc: scopes, &&cap_item: @ast::capture_item) {\n     let dcur = lookup_in_scope_strict(\n-        *e, sc, cap_item.span, cap_item.name, ns_val(ns_any_value));\n+        *e, sc, cap_item.span, cap_item.name, ns_val(value_or_enum));\n     maybe_insert(e, cap_item.id, dcur);\n }\n \n@@ -409,7 +412,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           ast::expr_path(p) {\n             maybe_insert(e, exp.id,\n                          lookup_path_strict(*e, sc, exp.span, p.node,\n-                                            ns_val(ns_any_value)));\n+                                            ns_val(value_or_enum)));\n           }\n           ast::expr_fn(_, _, _, cap_clause) {\n             let rci = bind resolve_capture_item(e, sc, _);\n@@ -446,14 +449,14 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id, sc: scopes,\n                    _v: vt<scopes>) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc,\n-                         sp, p.node, ns_val(ns_any_value)));\n+                         sp, p.node, ns_val(value_or_enum)));\n     }\n     fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_enum(p, _) {\n             alt lookup_path_strict(*e, sc, p.span, p.node,\n-                                           ns_val(ns_any_value)) {\n+                                           ns_val(value_or_enum)) {\n               some(fnd@ast::def_variant(_,_)) {\n                 e.def_map.insert(pat.id, fnd);\n               }\n@@ -468,7 +471,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n            variable a refers to a nullary enum. */\n           ast::pat_ident(p, none) {\n               alt lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n-                                    ns_val(ns_an_enum)) {\n+                                    ns_val(definite_enum)) {\n                 some(fnd@ast::def_variant(_,_)) {\n                     e.def_map.insert(pat.id, fnd);\n                 }\n@@ -624,11 +627,11 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n     // a single identifier unambiguous (does the pattern \"foo\" refer\n     // to enum foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n-      pat_ident(an_ident, _) {\n-          // Be sure to pass ns_an_enum to lookup_in_scope so that\n+      pat_ident(an_ident,_) {\n+          // Be sure to pass definite_enum to lookup_in_scope so that\n           // if this is a name that's being shadowed, we don't die\n           alt lookup_in_scope(*e, sc, loc.span,\n-                 path_to_ident(an_ident), ns_val(ns_an_enum)) {\n+                 path_to_ident(an_ident), ns_val(definite_enum)) {\n               some(ast::def_variant(enum_id,variant_id)) {\n                   // Declaration shadows a enum that's in scope.\n                   // That's an error.\n@@ -676,7 +679,7 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n \n fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n     alt lookup_path_strict(*e, sc, c.span, c.node.path.node,\n-                           ns_val(ns_any_value)) {\n+                           ns_val(value_or_enum)) {\n        some(d@ast::def_fn(_,ast::pure_fn)) {\n          e.def_map.insert(c.node.id, d);\n        }\n@@ -694,7 +697,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: fn(namespace) -> option<def>,\n                 impls: [@_impl]) {\n-        let val = lookup(ns_val(ns_any_value)), typ = lookup(ns_type),\n+        let val = lookup(ns_val(value_or_enum)), typ = lookup(ns_type),\n             md = lookup(ns_module);\n         if is_none(val) && is_none(typ) && is_none(md) &&\n            vec::len(impls) == 0u {\n@@ -806,8 +809,8 @@ fn ns_name(ns: namespace) -> str {\n       ns_type { \"typename\" }\n       ns_val(v) {\n           alt (v) {\n-              ns_any_value { \"name\" }\n-              ns_an_enum    { \"enum\" }\n+              value_or_enum { \"name\" }\n+              definite_enum    { \"enum\" }\n           }\n       }\n       ns_module { \"modulename\" }\n@@ -1007,11 +1010,11 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                   if ns == ns_type {\n                     ret lookup_in_ty_params(e, name, tps);\n                   }\n-                  if ns == ns_val(ns_any_value) && name == it.ident {\n+                  if ns == ns_val(value_or_enum) && name == it.ident {\n                       ret some(ast::def_fn(local_def(ctor_id),\n                                            ast::impure_fn));\n                   }\n-                  if ns == ns_val(ns_any_value) {\n+                  if ns == ns_val(value_or_enum) {\n                           ret lookup_in_class(local_def(it.id),\n                                               members, name);\n                   }\n@@ -1022,7 +1025,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             }\n           }\n           scope_method(id, tps) {\n-            if (name == \"self\" && ns == ns_val(ns_any_value)) {\n+            if (name == \"self\" && ns == ns_val(value_or_enum)) {\n                 ret some(ast::def_self(local_def(id)));\n             } else if ns == ns_type {\n                 ret lookup_in_ty_params(e, name, tps);\n@@ -1044,7 +1047,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             ret lookup_in_fn(e, name, decl, ty_params, ns);\n           }\n           scope_loop(local) {\n-            if ns == ns_val(ns_any_value) {\n+            if ns == ns_val(value_or_enum) {\n                 alt lookup_in_pat(e, name, local.node.pat) {\n                   some(did) { ret some(ast::def_binding(did)); }\n                   _ { }\n@@ -1055,7 +1058,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n             ret lookup_in_block(e, name, sp, b.node, *pos, *loc, ns);\n           }\n           scope_arm(a) {\n-            if ns == ns_val(ns_any_value) {\n+            if ns == ns_val(value_or_enum) {\n                 alt lookup_in_pat(e, name, a.pats[0]) {\n                   some(did) { ret some(ast::def_binding(did)); }\n                   _ { ret none; }\n@@ -1089,7 +1092,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                             /* If we were looking for a enum, at this point\n                                we know it's bound to a non-enum value, and\n                                we can return none instead of failing */\n-                            ns_an_enum { ret none; }\n+                            definite_enum { ret none; }\n                             _ { \"attempted dynamic environment-capture\" }\n                           }\n                       }\n@@ -1150,7 +1153,7 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ty_params: [ast::ty_param],\n                 ns: namespace) -> option<def> {\n     alt ns {\n-      ns_val(ns_any_value) {\n+      ns_val(value_or_enum) {\n         for a: ast::arg in decl.inputs {\n             if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(local_def(a.id), a.mode));\n@@ -1202,7 +1205,7 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                     while j > 0u {\n                         j -= 1u;\n                         let loc = locs[j];\n-                        if ns == ns_val(ns_any_value)\n+                        if ns == ns_val(value_or_enum)\n                                      && (i < pos || j < loc_pos) {\n                             alt lookup_in_pat(e, name, loc.node.pat) {\n                               some(did) {\n@@ -1292,11 +1295,11 @@ fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n     alt i.node {\n       ast::item_const(_, _) {\n-        if ns == ns_val(ns_any_value) {\n+        if ns == ns_val(value_or_enum) {\n             ret some(ast::def_const(local_def(i.id))); }\n       }\n       ast::item_fn(decl, _, _) {\n-        if ns == ns_val(ns_any_value) {\n+        if ns == ns_val(value_or_enum) {\n             ret some(ast::def_fn(local_def(i.id), decl.purity));\n         }\n       }\n@@ -1311,7 +1314,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option<def> {\n       }\n       ast::item_res(_, _, _, _, ctor_id) {\n         alt ns {\n-          ns_val(ns_any_value) {\n+          ns_val(value_or_enum) {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n           }\n           ns_type { ret some(ast::def_ty(local_def(i.id))); }\n@@ -1470,7 +1473,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n     if vec::len(matches) == 0u {\n         ret none;\n         }\n-    else if vec::len(matches) == 1u || ns == ns_val(ns_an_enum) {\n+    else if vec::len(matches) == 1u || ns == ns_val(definite_enum) {\n         ret some(matches[0].def);\n     } else {\n         for match: glob_imp_def in matches {\n@@ -1489,8 +1492,11 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, glob_resolving(sp));\n         // kludge\n-        let val_ns = if wanted_ns == ns_val(ns_an_enum) { ns_val(ns_an_enum) }\n-                     else { ns_val(ns_any_value) };\n+        let val_ns = if wanted_ns == ns_val(definite_enum) {\n+            ns_val(definite_enum)\n+        } else {\n+            ns_val(value_or_enum)\n+        };\n         let globs = info.glob_imports;\n         let val = lookup_in_globs(e, globs, sp, id, val_ns, dr);\n         let typ = lookup_in_globs(e, globs, sp, id, ns_type, dr);\n@@ -1532,7 +1538,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       mie_native_item(native_item) {\n         alt native_item.node {\n           ast::native_item_fn(decl, _) {\n-            if ns == ns_val(ns_any_value) {\n+            if ns == ns_val(value_or_enum) {\n                 ret some(ast::def_fn(local_def(native_item.id),\n                                      decl.purity));\n             }\n@@ -1655,12 +1661,12 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n // External lookups\n fn ns_for_def(d: def) -> namespace {\n     alt d {\n-      ast::def_variant(_, _) { ns_val(ns_an_enum) }\n+      ast::def_variant(_, _) { ns_val(definite_enum) }\n       ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_) |\n       ast::def_upvar(_, _, _) |  ast::def_self(_) |\n       ast::def_class_field(_,_) | ast::def_class_method(_,_)\n-          { ns_val(ns_any_value) }\n+          { ns_val(value_or_enum) }\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_ty_param(_, _) | ast::def_prim_ty(_) | ast::def_class(_)\n@@ -1672,7 +1678,7 @@ fn ns_for_def(d: def) -> namespace {\n // a enum\n fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n     alt actual {\n-      ns_val(ns_an_enum) {\n+      ns_val(definite_enum) {\n         alt wanted {\n           ns_val(_) { true }\n           _ { false }\n@@ -1720,7 +1726,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n     while true {\n         alt entries {\n           cons(entry, rest) {\n-            if !is_none(lookup_in_mie(e, entry, ns_val(ns_any_value))) {\n+            if !is_none(lookup_in_mie(e, entry, ns_val(value_or_enum))) {\n                 if saw_value {\n                     dup(e, mie_span(entry), \"\", name);\n                 } else { saw_value = true; }\n@@ -1921,7 +1927,7 @@ fn check_exports(e: @env) {\n         let lookup =\n             bind lookup_glob_in_mod(*e, info, sp, ident, _, inside);\n         let (m, v, t) = (lookup(ns_module),\n-                         lookup(ns_val(ns_any_value)),\n+                         lookup(ns_val(value_or_enum)),\n                          lookup(ns_type));\n         let full_path = path + ident;\n         maybe_add_reexport(e, full_path, m);"}]}