{"sha": "82374ad9bd73178947348206bc7ed463b5a8a982", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyMzc0YWQ5YmQ3MzE3ODk0NzM0ODIwNmJjN2VkNDYzYjVhOGE5ODI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-19T13:51:08Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-11-19T13:51:08Z"}, "message": "comments and slight refactoring", "tree": {"sha": "89e382a36711d036d9983f51997b899435fba40b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89e382a36711d036d9983f51997b899435fba40b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82374ad9bd73178947348206bc7ed463b5a8a982", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82374ad9bd73178947348206bc7ed463b5a8a982", "html_url": "https://github.com/rust-lang/rust/commit/82374ad9bd73178947348206bc7ed463b5a8a982", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82374ad9bd73178947348206bc7ed463b5a8a982/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80f9484c8680e54a31916d6410a5eea2ddb1e237", "url": "https://api.github.com/repos/rust-lang/rust/commits/80f9484c8680e54a31916d6410a5eea2ddb1e237", "html_url": "https://github.com/rust-lang/rust/commit/80f9484c8680e54a31916d6410a5eea2ddb1e237"}], "stats": {"total": 138, "additions": 67, "deletions": 71}, "files": [{"sha": "093065aab2c0af6e4b2ec11c1c2320058fe2bfdd", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82374ad9bd73178947348206bc7ed463b5a8a982/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/82374ad9bd73178947348206bc7ed463b5a8a982/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=82374ad9bd73178947348206bc7ed463b5a8a982", "patch": "@@ -1 +1 @@\n-8831d766ace89bc74714918a7d9fbd3ca5ec946a\n+3e525e3f6d9e85d54fa4c49b52df85aa0c990100"}, {"sha": "20f21cfc255c70d8131d6e9070b5e52bee10d6d3", "filename": "src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=82374ad9bd73178947348206bc7ed463b5a8a982", "patch": "@@ -53,6 +53,7 @@ fn resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> InterpResult<'tc\n \n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n \n+    /// Gets an instance for a path.\n     fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n         Ok(ty::Instance::mono(self.eval_context_ref().tcx.tcx, resolve_did(self.eval_context_ref().tcx.tcx, path)?))\n     }"}, {"sha": "cb658170357167566b24a59feabbff02a0e0a7fe", "filename": "src/machine.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=82374ad9bd73178947348206bc7ed463b5a8a982", "patch": "@@ -25,10 +25,11 @@ pub const NUM_CPUS: u64 = 1;\n pub struct FrameData<'tcx> {\n     /// Extra data for Stacked Borrows.\n     pub call_id: stacked_borrows::CallId,\n-    /// If this is Some(), then this is a special 'catch unwind'\n-    /// frame. When this frame is popped during unwinding a panic,\n-    /// we stop unwinding, and use the `CatchUnwindData` to\n-    /// store the panic payload and continue execution in the parent frame.\n+\n+    /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of the closure\n+    /// called by `__rustc_maybe_catch_panic`). When this frame is popped during unwinding a panic,\n+    /// we stop unwinding, use the `CatchUnwindData` to\n+    /// store the panic payload, and continue execution in the parent frame.\n     pub catch_panic: Option<CatchUnwindData<'tcx>>,\n }\n "}, {"sha": "3a95ffd78e31a76d414321a4d7e59018ffa25ca6", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=82374ad9bd73178947348206bc7ed463b5a8a982", "patch": "@@ -130,27 +130,21 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // First: functions that diverge.\n         match link_name {\n-            // Note that this matches calls to the *foreign* item \"__rust_start_panic\" -\n-            // that is, calls `extern \"Rust\" { fn __rust_start_panic(...) }`\n-            // We forward this to the underlying *implementation* in \"libpanic_unwind\"\n+            // Note that this matches calls to the *foreign* item `__rust_start_panic* -\n+            // that is, calls to `extern \"Rust\" { fn __rust_start_panic(...) }`.\n+            // We forward this to the underlying *implementation* in \"libpanic_unwind\".\n             \"__rust_start_panic\" => {\n                 let start_panic_instance = this.resolve_path(&[\"panic_unwind\", \"__rust_start_panic\"])?;\n                 return Ok(Some(this.load_mir(start_panic_instance.def, None)?));\n             }\n-\n-            // During a normal (non-Miri) compilation,\n-            // this gets resolved to the '#[panic_handler]` function at link time,\n-            // which corresponds to the function with the `#[panic_handler]` attribute.\n-            //\n-            // Since we're interpreting mir, we forward it to the implementation of `panic_impl`\n-            //\n-            // This is used by libcore to forward panics to the actual\n-            // panic impl\n+            // Similarly, we forward calls to the `panic_impl` foreign item to its implementation.\n+            // The implementation is provided by the function with the `#[panic_handler]` attribute.\n             \"panic_impl\" => {\n                 let panic_impl_id = this.tcx.lang_items().panic_impl().unwrap();\n                 let panic_impl_instance = ty::Instance::mono(*this.tcx, panic_impl_id);\n                 return Ok(Some(this.load_mir(panic_impl_instance.def, None)?));\n             }\n+\n             \"exit\" | \"ExitProcess\" => {\n                 // it's really u32 for ExitProcess, but we have to put it into the `Exit` error variant anyway\n                 let code = this.read_scalar(args[0])?.to_i32()?;"}, {"sha": "5e1f3cff1c77cecaf358efb10221009eb2c227e1", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=82374ad9bd73178947348206bc7ed463b5a8a982", "patch": "@@ -45,7 +45,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Handle non-diverging intrinsics\n         // The intrinsic itself cannot diverge (otherwise, we would have handled it above),\n-        // so if we got here without a return place... (can happen e.g., for transmute returning `!`)\n+        // so if we got here without a return place that's UB (can happen e.g., for transmute returning `!`).\n         let dest = match dest {\n             Some(dest) => dest,\n             None => throw_ub!(Unreachable)"}, {"sha": "9c5c32491915bfcf50595b35d03ae5e62049cc36", "filename": "src/shims/panic.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82374ad9bd73178947348206bc7ed463b5a8a982/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=82374ad9bd73178947348206bc7ed463b5a8a982", "patch": "@@ -1,33 +1,42 @@\n+//! Panic runtime for Miri.\n+//!\n+//! The core pieces of the runtime are:\n+//! - An implementation of `__rust_maybe_catch_panic` that pushes the invoked stack frame with\n+//!   some extra metadata derived from the panic-catching arguments of `__rust_maybe_catch_panic`.\n+//! - A hack in `libpanic_unwind` that calls the `miri_start_panic` intrinsic instead of the\n+//!   target-native panic runtime. (This lives in the rustc repo.)\n+//! - An implementation of `miri_start_panic` that stores its argument (the panic payload), and then\n+//!   immediately returns, but on the *unwind* edge (not the normal return edge), thus initiating unwinding.\n+//! - A hook executed each time a frame is popped, such that if the frame pushed by `__rust_maybe_catch_panic`\n+//!   gets popped *during unwinding*, we take the panic payload and store it according to the extra\n+//!   metadata we remembered when pushing said frame.\n+\n use rustc::mir;\n use crate::*;\n use super::machine::FrameData;\n use rustc_target::spec::PanicStrategy;\n use crate::rustc_target::abi::LayoutOf;\n \n /// Holds all of the relevant data for a call to\n-/// __rust_maybe_catch_panic\n+/// `__rust_maybe_catch_panic`.\n ///\n /// If a panic occurs, we update this data with\n-/// the information from the panic site\n+/// the information from the panic site.\n #[derive(Debug)]\n pub struct CatchUnwindData<'tcx> {\n-    /// The 'data' argument passed to `__rust_maybe_catch_panic`\n-    pub data: Pointer<Tag>,\n-    /// The `data_ptr` argument passed to `__rust_maybe_catch_panic`\n+    /// The dereferenced `data_ptr` argument passed to `__rust_maybe_catch_panic`.\n     pub data_place: MPlaceTy<'tcx, Tag>,\n-    /// The `vtable_ptr` argument passed to `__rust_maybe_catch_panic`\n+    /// The dereferenced `vtable_ptr` argument passed to `__rust_maybe_catch_panic`.\n     pub vtable_place: MPlaceTy<'tcx, Tag>,\n-    /// The `dest` from the original call to `__rust_maybe_catch_panic`\n+    /// The `dest` from the original call to `__rust_maybe_catch_panic`.\n     pub dest: PlaceTy<'tcx, Tag>,\n-    /// The `ret` from the original call to `__rust_maybe_catch_panic`\n-    pub ret: mir::BasicBlock,\n }\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n \n     /// Handles the special \"miri_start_panic\" intrinsic, which is called\n-    /// by libpanic_unwind to delegate the actual unwinding process to Miri\n+    /// by libpanic_unwind to delegate the actual unwinding process to Miri.\n     #[inline(always)]\n     fn handle_miri_start_panic(\n         &mut self,\n@@ -44,14 +53,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"the evaluated program panicked\");\n         }\n \n-        // Get the raw pointer stored in arg[0]\n+        // Get the raw pointer stored in arg[0] (the panic payload).\n         let scalar = this.read_immediate(args[0])?;\n+        assert!(this.machine.panic_payload.is_none(), \"the panic runtime should avoid double-panics\");\n         this.machine.panic_payload = Some(scalar);\n \n-        // Jump to the unwind block to begin unwinding\n-        // We don't use 'goto_block' - if `unwind` is None,\n-        // we'll end up immediately returning out of the\n-        // function during the next step() call\n+        // Jump to the unwind block to begin unwinding.\n+        // We don't use `goto_block` as that is just meant for normal returns.\n         let next_frame = this.frame_mut();\n         next_frame.block = unwind;\n         next_frame.stmt = 0;\n@@ -74,16 +82,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         //     data_ptr: *mut usize,\n         //     vtable_ptr: *mut usize,\n         // ) -> u32\n+\n+        // Get all the arguments.\n         let f = this.read_scalar(args[0])?.not_undef()?;\n-        let data = this.read_scalar(args[1])?.not_undef()?;\n+        let f_arg = this.read_scalar(args[1])?.not_undef()?;\n         let data_place = this.deref_operand(args[2])?;\n         let vtable_place = this.deref_operand(args[3])?;\n+\n+        // Now we make a function call, and pass `f_arg` as first and only argument.\n         let f_instance = this.memory.get_fn(f)?.as_instance()?;\n-        this.write_null(dest)?;\n         trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n-\n-\n-        // Now we make a function call.\n         // TODO: consider making this reusable? `InterpCx::step` does something similar\n         // for the TLS destructors, and of course `eval_main`.\n         let mir = this.load_mir(f_instance.def, None)?;\n@@ -98,32 +106,30 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n         )?;\n \n+        let mut args = this.frame().body.args_iter();\n+        // First argument.\n+        let arg_local = args\n+            .next()\n+            .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n+        let arg_dest = this.local_place(arg_local)?;\n+        this.write_scalar(f_arg, arg_dest)?;\n+        // No more arguments.\n+        args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n+\n+        // We ourselves will return `0`, eventually (will be overwritten if we catch a panic).\n+        this.write_null(dest)?;\n+\n         // In unwind mode, we tag this frame with some extra data.\n         // This lets `handle_stack_pop` (below) know that we should stop unwinding\n         // when we pop this frame.\n         if this.tcx.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n             this.frame_mut().extra.catch_panic = Some(CatchUnwindData {\n-                data: data.to_ptr()?,\n                 data_place,\n                 vtable_place,\n                 dest,\n-                ret,\n             })\n         }\n \n-        let mut args = this.frame().body.args_iter();\n-\n-        let arg_local = args\n-            .next()\n-            .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n-        let arg_dest = this.local_place(arg_local)?;\n-        this.write_scalar(data, arg_dest)?;\n-\n-        args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n-\n-        // We ourselves will return `0`, eventually (because we will not return if we paniced).\n-        this.write_null(dest)?;\n-\n         return Ok(());\n     }\n \n@@ -140,33 +146,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // We only care about `catch_panic` if we're unwinding - if we're doing a normal\n         // return, then we don't need to do anything special.\n         let res = if let (true, Some(unwind_data)) = (unwinding, extra.catch_panic.take()) {\n-            // We've just popped the frame that was immediately above\n-            // the frame which originally called `__rust_maybe_catch_panic`\n-            trace!(\"unwinding: found catch_panic frame: {:?}\", this.frame().span);\n+            // We've just popped a frame that was pushed by `__rust_maybe_catch_panic`,\n+            // and we are unwinding, so we should catch that.\n+            trace!(\"unwinding: found catch_panic frame during unwinding: {:?}\", this.frame().span);\n \n-            // `panic_payload` now holds a  '*mut (dyn Any + Send)',\n+            // `panic_payload` now holds a `*mut (dyn Any + Send)`,\n             // provided by the `miri_start_panic` intrinsic.\n             // We want to split this into its consituient parts -\n-            // the data and vtable pointers - and store them back\n-            // into the panic handler frame\n-            let real_ret = this.machine.panic_payload.take().unwrap();\n-\n-            let payload = this.ref_to_mplace(real_ret)?;\n+            // the data and vtable pointers - and store them according to\n+            // `unwind_data`, i.e., we store them where `__rust_maybe_catch_panic`\n+            // was told to put them.\n+            let payload = this.machine.panic_payload.take().unwrap();\n+            let payload = this.ref_to_mplace(payload)?;\n             let payload_data_place = payload.ptr;\n             let payload_vtable_place = payload.meta.expect(\"Expected fat pointer\");\n \n-\n-            let data_place = unwind_data.data_place;\n-            let vtable_place = unwind_data.vtable_place;\n-            let dest = unwind_data.dest;\n-\n-            // Here, we write to the pointers provided to the call\n-            // to '__rust_maybe_catch_panic`.\n-            this.write_scalar(payload_data_place, data_place.into())?;\n-            this.write_scalar(payload_vtable_place, vtable_place.into())?;\n+            this.write_scalar(payload_data_place, unwind_data.data_place.into())?;\n+            this.write_scalar(payload_vtable_place, unwind_data.vtable_place.into())?;\n \n             // We set the return value of `__rust_maybe_catch_panic` to 1,\n             // since there was a panic.\n+            let dest = unwind_data.dest;\n             this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n \n             StackPopInfo::StopUnwinding"}]}