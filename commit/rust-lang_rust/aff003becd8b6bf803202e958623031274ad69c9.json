{"sha": "aff003becd8b6bf803202e958623031274ad69c9", "node_id": "C_kwDOAAsO6NoAKGFmZjAwM2JlY2Q4YjZiZjgwMzIwMmU5NTg2MjMwMzEyNzRhZDY5Yzk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T22:56:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T22:56:59Z"}, "message": "Auto merge of #99798 - JulianKnodt:ac1, r=BoxyUwU\n\nAdd `ConstKind::Expr`\n\nStarting to implement `ty::ConstKind::Abstract`, most of the match cases are stubbed out, some I was unsure what to add, others I didn't want to add until a more complete implementation was ready.\n\nr? `@lcnr`", "tree": {"sha": "26a46a71d7be91ad4390a531a1d8fcda33718ba1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26a46a71d7be91ad4390a531a1d8fcda33718ba1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aff003becd8b6bf803202e958623031274ad69c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aff003becd8b6bf803202e958623031274ad69c9", "html_url": "https://github.com/rust-lang/rust/commit/aff003becd8b6bf803202e958623031274ad69c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aff003becd8b6bf803202e958623031274ad69c9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8681d4cffcd23bbe619984ab62772a91827a40dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8681d4cffcd23bbe619984ab62772a91827a40dc", "html_url": "https://github.com/rust-lang/rust/commit/8681d4cffcd23bbe619984ab62772a91827a40dc"}, {"sha": "d0209db15776a47ee0893385f218521b9a105cd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0209db15776a47ee0893385f218521b9a105cd8", "html_url": "https://github.com/rust-lang/rust/commit/d0209db15776a47ee0893385f218521b9a105cd8"}], "stats": {"total": 1614, "additions": 802, "deletions": 812}, "files": [{"sha": "221e359d24ab8d517a1d98ed60de780bdea9c468", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -561,6 +561,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ty::ConstKind::Param(_) | ty::ConstKind::Placeholder(..) => {\n                 throw_inval!(TooGeneric)\n             }\n+            // FIXME(generic_const_exprs): `ConstKind::Expr` should be able to be evaluated\n+            ty::ConstKind::Expr(_) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(reported) => {\n                 throw_inval!(AlreadyReported(reported))\n             }"}, {"sha": "27a94ec5e30e105cea6c5fe923344c0086d758e2", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -248,6 +248,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n             ty::ConstKind::Param(_)\n             | ty::ConstKind::Value(_)\n             | ty::ConstKind::Unevaluated(..)\n+            | ty::ConstKind::Expr(..)\n             | ty::ConstKind::Error(_) => ct.super_fold_with(self),\n         }\n     }"}, {"sha": "67feb83faace6aff7357fad2323423934da28be8", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -23,7 +23,6 @@ use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKin\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::select;\n-use rustc_middle::ty::abstract_const::{AbstractConst, FailureKind};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BoundVarReplacerDelegate;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -713,32 +712,6 @@ impl<'tcx> InferCtxt<'tcx> {\n         TypeErrCtxt { infcx: self, typeck_results: None, fallback_has_occurred: false }\n     }\n \n-    /// calls `tcx.try_unify_abstract_consts` after\n-    /// canonicalizing the consts.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn try_unify_abstract_consts(\n-        &self,\n-        a: ty::UnevaluatedConst<'tcx>,\n-        b: ty::UnevaluatedConst<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        // Reject any attempt to unify two unevaluated constants that contain inference\n-        // variables, since inference variables in queries lead to ICEs.\n-        if a.substs.has_non_region_infer()\n-            || b.substs.has_non_region_infer()\n-            || param_env.has_non_region_infer()\n-        {\n-            debug!(\"a or b or param_env contain infer vars in its substs -> cannot unify\");\n-            return false;\n-        }\n-\n-        let param_env_and = param_env.and((a, b));\n-        let erased = self.tcx.erase_regions(param_env_and);\n-        debug!(\"after erase_regions: {:?}\", erased);\n-\n-        self.tcx.try_unify_abstract_consts(erased)\n-    }\n-\n     pub fn is_in_snapshot(&self) -> bool {\n         self.in_snapshot.get()\n     }\n@@ -1646,34 +1619,33 @@ impl<'tcx> InferCtxt<'tcx> {\n \n         // Postpone the evaluation of constants whose substs depend on inference\n         // variables\n+        let tcx = self.tcx;\n         if substs.has_non_region_infer() {\n-            let ac = AbstractConst::new(self.tcx, unevaluated);\n-            match ac {\n-                Ok(None) => {\n-                    substs = InternalSubsts::identity_for_item(self.tcx, unevaluated.def.did);\n-                    param_env = self.tcx.param_env(unevaluated.def.did);\n-                }\n-                Ok(Some(ct)) => {\n-                    if ct.unify_failure_kind(self.tcx) == FailureKind::Concrete {\n-                        substs = replace_param_and_infer_substs_with_placeholder(self.tcx, substs);\n-                    } else {\n-                        return Err(ErrorHandled::TooGeneric);\n-                    }\n+            if let Some(ct) = tcx.bound_abstract_const(unevaluated.def)? {\n+                let ct = tcx.expand_abstract_consts(ct.subst(tcx, substs));\n+                if let Err(e) = ct.error_reported() {\n+                    return Err(ErrorHandled::Reported(e));\n+                } else if ct.has_non_region_infer() || ct.has_non_region_param() {\n+                    return Err(ErrorHandled::TooGeneric);\n+                } else {\n+                    substs = replace_param_and_infer_substs_with_placeholder(tcx, substs);\n                 }\n-                Err(guar) => return Err(ErrorHandled::Reported(guar)),\n+            } else {\n+                substs = InternalSubsts::identity_for_item(tcx, unevaluated.def.did);\n+                param_env = tcx.param_env(unevaluated.def.did);\n             }\n         }\n \n-        let param_env_erased = self.tcx.erase_regions(param_env);\n-        let substs_erased = self.tcx.erase_regions(substs);\n+        let param_env_erased = tcx.erase_regions(param_env);\n+        let substs_erased = tcx.erase_regions(substs);\n         debug!(?param_env_erased);\n         debug!(?substs_erased);\n \n         let unevaluated = ty::UnevaluatedConst { def: unevaluated.def, substs: substs_erased };\n \n         // The return value is the evaluated value which doesn't contain any reference to inference\n         // variables, thus we don't need to substitute back the original values.\n-        self.tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n+        tcx.const_eval_resolve_for_typeck(param_env_erased, unevaluated, span)\n     }\n \n     /// `ty_or_const_infer_var_changed` is equivalent to one of these two:"}, {"sha": "3fae6694add0a02766b5594514d594ac7bda3715", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -644,12 +644,6 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for Symbol {\n     }\n }\n \n-impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n-        ty::codec::RefDecodable::decode(d)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Self {\n         ty::codec::RefDecodable::decode(d)"}, {"sha": "c51b8f96c715191cd96d648c267d88b0793995dd", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -366,7 +366,7 @@ define_tables! {\n     mir_for_ctfe: Table<DefIndex, LazyValue<mir::Body<'static>>>,\n     promoted_mir: Table<DefIndex, LazyValue<IndexVec<mir::Promoted, mir::Body<'static>>>>,\n     // FIXME(compiler-errors): Why isn't this a LazyArray?\n-    thir_abstract_const: Table<DefIndex, LazyValue<&'static [ty::abstract_const::Node<'static>]>>,\n+    thir_abstract_const: Table<DefIndex, LazyValue<ty::Const<'static>>>,\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,"}, {"sha": "1cac656674d697a407dcb858cfe7967338c533e1", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -476,6 +476,7 @@ impl<'tcx> Visitor<'tcx> for ExtraComments<'tcx> {\n                     // These variants shouldn't exist in the MIR.\n                     ty::ConstKind::Placeholder(_)\n                     | ty::ConstKind::Infer(_)\n+                    | ty::ConstKind::Expr(_)\n                     | ty::ConstKind::Bound(..) => bug!(\"unexpected MIR constant: {:?}\", literal),\n                 },\n                 ConstantKind::Unevaluated(uv, _) => {"}, {"sha": "f2030b91b9b65e679cfe1b12d16b5d888c00381b", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1185,15 +1185,17 @@ pub enum NullOp {\n     AlignOf,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeFoldable, TypeVisitable)]\n pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n     /// The `-` operator for negation\n     Neg,\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, TyEncodable, TyDecodable, Hash, HashStable)]\n+#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Ord, Eq, Hash)]\n+#[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n pub enum BinOp {\n     /// The `+` operator (addition)\n     Add,"}, {"sha": "0705b4cff53ad788c76c95a8654eac8bfbc8575a", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -16,9 +16,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     UserTypeAnnotationIndex,\n     BorrowKind,\n     CastKind,\n-    BinOp,\n     NullOp,\n-    UnOp,\n     hir::Movability,\n     BasicBlock,\n     SwitchTargets,"}, {"sha": "36cdb50958caaa1ffbfee0f6982ed45efca3585e", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -400,7 +400,7 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const(\n         key: DefId\n-    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         desc {\n             |tcx| \"building an abstract representation for `{}`\", tcx.def_path_str(key),\n         }\n@@ -409,23 +409,14 @@ rustc_queries! {\n     /// Try to build an abstract representation of the given constant.\n     query thir_abstract_const_of_const_arg(\n         key: (LocalDefId, DefId)\n-    ) -> Result<Option<&'tcx [ty::abstract_const::Node<'tcx>]>, ErrorGuaranteed> {\n+    ) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n         desc {\n             |tcx|\n             \"building an abstract representation for the const argument `{}`\",\n             tcx.def_path_str(key.0.to_def_id()),\n         }\n     }\n \n-    query try_unify_abstract_consts(key:\n-        ty::ParamEnvAnd<'tcx, (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>\n-    )>) -> bool {\n-        desc {\n-            |tcx| \"trying to unify the generic constants `{}` and `{}`\",\n-            tcx.def_path_str(key.value.0.def.did), tcx.def_path_str(key.value.1.def.did)\n-        }\n-    }\n-\n     query mir_drops_elaborated_and_const_checked(\n         key: ty::WithOptConstParam<LocalDefId>\n     ) -> &'tcx Steal<mir::Body<'tcx>> {"}, {"sha": "5de758ad9babd04d53a6da306b0bfbf001f01492", "filename": "compiler/rustc_middle/src/ty/abstract_const.rs", "status": "modified", "additions": 45, "deletions": 155, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fabstract_const.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1,115 +1,20 @@\n //! A subset of a mir body used for const evaluatability checking.\n-use crate::mir;\n-use crate::ty::visit::TypeVisitable;\n-use crate::ty::{self, EarlyBinder, SubstsRef, Ty, TyCtxt};\n+use crate::ty::{\n+    self, Const, EarlyBinder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitable,\n+};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n-use std::cmp;\n-use std::ops::ControlFlow;\n \n-rustc_index::newtype_index! {\n-    /// An index into an `AbstractConst`.\n-    pub struct NodeId {\n-        derive [HashStable]\n-        DEBUG_FORMAT = \"n{}\",\n-    }\n-}\n-\n-/// A tree representing an anonymous constant.\n-///\n-/// This is only able to represent a subset of `MIR`,\n-/// and should not leak any information about desugarings.\n-#[derive(Debug, Clone, Copy)]\n-pub struct AbstractConst<'tcx> {\n-    // FIXME: Consider adding something like `IndexSlice`\n-    // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n-}\n-\n-impl<'tcx> AbstractConst<'tcx> {\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        uv: ty::UnevaluatedConst<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        let inner = tcx.thir_abstract_const_opt_const_arg(uv.def)?;\n-        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs: tcx.erase_regions(uv.substs) }))\n-    }\n-\n-    pub fn from_const(\n-        tcx: TyCtxt<'tcx>,\n-        ct: ty::Const<'tcx>,\n-    ) -> Result<Option<AbstractConst<'tcx>>, ErrorGuaranteed> {\n-        match ct.kind() {\n-            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv),\n-            ty::ConstKind::Error(reported) => Err(reported),\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n-        AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n-    }\n-\n-    #[inline]\n-    pub fn root(self, tcx: TyCtxt<'tcx>) -> Node<'tcx> {\n-        let node = self.inner.last().copied().unwrap();\n-        match node {\n-            Node::Leaf(leaf) => Node::Leaf(EarlyBinder(leaf).subst(tcx, self.substs)),\n-            Node::Cast(kind, operand, ty) => {\n-                Node::Cast(kind, operand, EarlyBinder(ty).subst(tcx, self.substs))\n-            }\n-            // Don't perform substitution on the following as they can't directly contain generic params\n-            Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => node,\n-        }\n-    }\n-\n-    pub fn unify_failure_kind(self, tcx: TyCtxt<'tcx>) -> FailureKind {\n-        let mut failure_kind = FailureKind::Concrete;\n-        walk_abstract_const::<!, _>(tcx, self, |node| {\n-            match node.root(tcx) {\n-                Node::Leaf(leaf) => {\n-                    if leaf.has_non_region_infer() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if leaf.has_non_region_param() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-                }\n-                Node::Cast(_, _, ty) => {\n-                    if ty.has_non_region_infer() {\n-                        failure_kind = FailureKind::MentionsInfer;\n-                    } else if ty.has_non_region_param() {\n-                        failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n-                    }\n-                }\n-                Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {}\n-            }\n-            ControlFlow::CONTINUE\n-        });\n-        failure_kind\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n+#[derive(Hash, Debug, Clone, Copy, Ord, PartialOrd, PartialEq, Eq)]\n+#[derive(TyDecodable, TyEncodable, HashStable, TypeVisitable, TypeFoldable)]\n pub enum CastKind {\n     /// thir::ExprKind::As\n     As,\n     /// thir::ExprKind::Use\n     Use,\n }\n \n-/// A node of an `AbstractConst`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n-pub enum Node<'tcx> {\n-    Leaf(ty::Const<'tcx>),\n-    Binop(mir::BinOp, NodeId, NodeId),\n-    UnaryOp(mir::UnOp, NodeId),\n-    FunctionCall(NodeId, &'tcx [NodeId]),\n-    Cast(CastKind, NodeId, Ty<'tcx>),\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, TyEncodable, TyDecodable)]\n pub enum NotConstEvaluatable {\n     Error(ErrorGuaranteed),\n@@ -127,68 +32,53 @@ TrivialTypeTraversalAndLiftImpls! {\n     NotConstEvaluatable,\n }\n \n+pub type BoundAbstractConst<'tcx> = Result<Option<EarlyBinder<ty::Const<'tcx>>>, ErrorGuaranteed>;\n+\n impl<'tcx> TyCtxt<'tcx> {\n-    #[inline]\n-    pub fn thir_abstract_const_opt_const_arg(\n+    /// Returns a const without substs applied\n+    pub fn bound_abstract_const(\n         self,\n-        def: ty::WithOptConstParam<DefId>,\n-    ) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n-        if let Some((did, param_did)) = def.as_const_arg() {\n+        uv: ty::WithOptConstParam<DefId>,\n+    ) -> BoundAbstractConst<'tcx> {\n+        let ac = if let Some((did, param_did)) = uv.as_const_arg() {\n             self.thir_abstract_const_of_const_arg((did, param_did))\n         } else {\n-            self.thir_abstract_const(def.did)\n-        }\n+            self.thir_abstract_const(uv.did)\n+        };\n+        Ok(ac?.map(|ac| EarlyBinder(ac)))\n     }\n-}\n \n-#[instrument(skip(tcx, f), level = \"debug\")]\n-pub fn walk_abstract_const<'tcx, R, F>(\n-    tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n-    mut f: F,\n-) -> ControlFlow<R>\n-where\n-    F: FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-{\n-    #[instrument(skip(tcx, f), level = \"debug\")]\n-    fn recurse<'tcx, R>(\n-        tcx: TyCtxt<'tcx>,\n-        ct: AbstractConst<'tcx>,\n-        f: &mut dyn FnMut(AbstractConst<'tcx>) -> ControlFlow<R>,\n-    ) -> ControlFlow<R> {\n-        f(ct)?;\n-        let root = ct.root(tcx);\n-        debug!(?root);\n-        match root {\n-            Node::Leaf(_) => ControlFlow::CONTINUE,\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f)?;\n-                recurse(tcx, ct.subtree(r), f)\n+    pub fn expand_abstract_consts<T: TypeFoldable<'tcx>>(self, ac: T) -> T {\n+        struct Expander<'tcx> {\n+            tcx: TyCtxt<'tcx>,\n+        }\n+\n+        impl<'tcx> TypeFolder<'tcx> for Expander<'tcx> {\n+            fn tcx(&self) -> TyCtxt<'tcx> {\n+                self.tcx\n             }\n-            Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f)?;\n-                args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if ty.has_type_flags(ty::TypeFlags::HAS_CT_PROJECTION) {\n+                    ty.super_fold_with(self)\n+                } else {\n+                    ty\n+                }\n+            }\n+            fn fold_const(&mut self, c: Const<'tcx>) -> Const<'tcx> {\n+                let ct = match c.kind() {\n+                    ty::ConstKind::Unevaluated(uv) => match self.tcx.bound_abstract_const(uv.def) {\n+                        Err(e) => self.tcx.const_error_with_guaranteed(c.ty(), e),\n+                        Ok(Some(bac)) => {\n+                            let substs = self.tcx.erase_regions(uv.substs);\n+                            bac.subst(self.tcx, substs)\n+                        }\n+                        Ok(None) => c,\n+                    },\n+                    _ => c,\n+                };\n+                ct.super_fold_with(self)\n             }\n-            Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n         }\n+        ac.fold_with(&mut Expander { tcx: self })\n     }\n-\n-    recurse(tcx, ct, &mut f)\n-}\n-\n-// We were unable to unify the abstract constant with\n-// a constant found in the caller bounds, there are\n-// now three possible cases here.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub enum FailureKind {\n-    /// The abstract const still references an inference\n-    /// variable, in this case we return `TooGeneric`.\n-    MentionsInfer,\n-    /// The abstract const references a generic parameter,\n-    /// this means that we emit an error here.\n-    MentionsParam,\n-    /// The substs are concrete enough that we can simply\n-    /// try and evaluate the given constant.\n-    Concrete,\n }"}, {"sha": "b22b3961f34ea9a93aa61a0831e88b1089beabcf", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -346,33 +346,22 @@ impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n }\n \n impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [ty::abstract_const::Node<'tcx>]\n-{\n-    fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().arena.alloc_from_iter(\n-            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n-        )\n-    }\n-}\n-\n-impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for [ty::abstract_const::NodeId]\n+    for ty::List<ty::BoundVariableKind>\n {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n-        decoder.interner().arena.alloc_from_iter(\n-            (0..decoder.read_usize()).map(|_| Decodable::decode(decoder)).collect::<Vec<_>>(),\n+        let len = decoder.read_usize();\n+        decoder.interner().mk_bound_variable_kinds(\n+            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n         )\n     }\n }\n \n-impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D>\n-    for ty::List<ty::BoundVariableKind>\n-{\n+impl<'tcx, D: TyDecoder<I = TyCtxt<'tcx>>> RefDecodable<'tcx, D> for ty::List<ty::Const<'tcx>> {\n     fn decode(decoder: &mut D) -> &'tcx Self {\n         let len = decoder.read_usize();\n-        decoder.interner().mk_bound_variable_kinds(\n-            (0..len).map::<ty::BoundVariableKind, _>(|_| Decodable::decode(decoder)),\n-        )\n+        decoder\n+            .interner()\n+            .mk_const_list((0..len).map::<ty::Const<'tcx>, _>(|_| Decodable::decode(decoder)))\n     }\n }\n "}, {"sha": "de63dae8a3df6455eb311d18c3eef5b717535591", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1,10 +1,12 @@\n use std::convert::TryInto;\n \n+use super::Const;\n use crate::mir;\n use crate::mir::interpret::{AllocId, ConstValue, Scalar};\n+use crate::ty::abstract_const::CastKind;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n use crate::ty::ParamEnv;\n-use crate::ty::{self, TyCtxt, TypeVisitable};\n+use crate::ty::{self, List, Ty, TyCtxt, TypeVisitable};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n@@ -70,8 +72,23 @@ pub enum ConstKind<'tcx> {\n     /// A placeholder for a const which could not be computed; this is\n     /// propagated to avoid useless error messages.\n     Error(ErrorGuaranteed),\n+\n+    /// Expr which contains an expression which has partially evaluated items.\n+    Expr(Expr<'tcx>),\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(HashStable, TyEncodable, TyDecodable, TypeVisitable, TypeFoldable)]\n+pub enum Expr<'tcx> {\n+    Binop(mir::BinOp, Const<'tcx>, Const<'tcx>),\n+    UnOp(mir::UnOp, Const<'tcx>),\n+    FunctionCall(Const<'tcx>, &'tcx List<Const<'tcx>>),\n+    Cast(CastKind, Const<'tcx>, Ty<'tcx>),\n }\n \n+#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n+static_assert_size!(Expr<'_>, 24);\n+\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(ConstKind<'_>, 32);\n "}, {"sha": "fbbf3f312e791e0e9925b3b4a2354fd0ecb92732", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -137,6 +137,7 @@ pub struct CtxtInterners<'tcx> {\n     // Specifically use a speedy hash algorithm for these hash sets, since\n     // they're accessed quite often.\n     type_: InternedSet<'tcx, WithStableHash<TyS<'tcx>>>,\n+    const_lists: InternedSet<'tcx, List<ty::Const<'tcx>>>,\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind<'tcx>>,\n@@ -157,6 +158,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         CtxtInterners {\n             arena,\n             type_: Default::default(),\n+            const_lists: Default::default(),\n             substs: Default::default(),\n             region: Default::default(),\n             poly_existential_predicates: Default::default(),\n@@ -2261,6 +2263,7 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n+    const_lists: _intern_const_list(Const<'tcx>),\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n@@ -2716,6 +2719,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    pub fn mk_const_list<I: InternAs<ty::Const<'tcx>, &'tcx List<ty::Const<'tcx>>>>(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_const_list(xs))\n+    }\n+\n+    pub fn intern_const_list(self, cs: &[ty::Const<'tcx>]) -> &'tcx List<ty::Const<'tcx>> {\n+        if cs.is_empty() { List::empty() } else { self._intern_const_list(cs) }\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx List<Ty<'tcx>> {\n         if ts.is_empty() {\n             List::empty()"}, {"sha": "c9c09c93a3e1c470a9e94b68d6e8d2c7086f575c", "filename": "compiler/rustc_middle/src/ty/fast_reject.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffast_reject.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -356,7 +356,10 @@ impl DeepRejectCtxt {\n \n     pub fn consts_may_unify(self, obligation_ct: ty::Const<'_>, impl_ct: ty::Const<'_>) -> bool {\n         match impl_ct.kind() {\n-            ty::ConstKind::Param(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+            ty::ConstKind::Expr(_)\n+            | ty::ConstKind::Param(_)\n+            | ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Error(_) => {\n                 return true;\n             }\n             ty::ConstKind::Value(_) => {}\n@@ -374,7 +377,9 @@ impl DeepRejectCtxt {\n \n             // As we don't necessarily eagerly evaluate constants,\n             // they might unify with any value.\n-            ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => true,\n+            ty::ConstKind::Expr(_) | ty::ConstKind::Unevaluated(_) | ty::ConstKind::Error(_) => {\n+                true\n+            }\n             ty::ConstKind::Value(obl) => match k {\n                 ty::ConstKind::Value(imp) => obl == imp,\n                 _ => true,"}, {"sha": "1e9fe779b76464c4afcf00ae19b71aad1cc0ec6a", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -313,6 +313,26 @@ impl FlagComputation {\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Value(_) => {}\n+            ty::ConstKind::Expr(e) => {\n+                use ty::Expr;\n+                match e {\n+                    Expr::Binop(_, l, r) => {\n+                        self.add_const(l);\n+                        self.add_const(r);\n+                    }\n+                    Expr::UnOp(_, v) => self.add_const(v),\n+                    Expr::FunctionCall(f, args) => {\n+                        self.add_const(f);\n+                        for arg in args {\n+                            self.add_const(arg);\n+                        }\n+                    }\n+                    Expr::Cast(_, c, t) => {\n+                        self.add_ty(t);\n+                        self.add_const(c);\n+                    }\n+                }\n+            }\n             ty::ConstKind::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n         }\n     }"}, {"sha": "e7dc2b36fafe9be8f6541dafefde1ba5e19b66c4", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -77,7 +77,7 @@ pub use self::closure::{\n     CAPTURE_STRUCT_LOCAL,\n };\n pub use self::consts::{\n-    Const, ConstInt, ConstKind, ConstS, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n+    Const, ConstInt, ConstKind, ConstS, Expr, InferConst, ScalarInt, UnevaluatedConst, ValTree,\n };\n pub use self::context::{\n     tls, CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations,"}, {"sha": "b2bcf0e29cd9d7578219c412eb249e2f9359e3bc", "filename": "compiler/rustc_middle/src/ty/parameterized.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fparameterized.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -4,7 +4,6 @@ use rustc_index::vec::{Idx, IndexVec};\n \n use crate::middle::exported_symbols::ExportedSymbol;\n use crate::mir::Body;\n-use crate::ty::abstract_const::Node;\n use crate::ty::{\n     self, Const, FnSig, GeneratorDiagnosticData, GenericPredicates, Predicate, TraitRef, Ty,\n };\n@@ -124,6 +123,5 @@ parameterized_over_tcx! {\n     Predicate,\n     GeneratorDiagnosticData,\n     Body,\n-    Node,\n     ExportedSymbol,\n }"}, {"sha": "d5e196b2e9faa5b25b142a22d9aade0cb65d0d3a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1253,6 +1253,9 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n+            // FIXME(generic_const_exprs):\n+            // write out some legible representation of an abstract const?\n+            ty::ConstKind::Expr(_) => p!(\"[Const Expr]\"),\n             ty::ConstKind::Error(_) => p!(\"[const error]\"),\n         };\n         Ok(self)"}, {"sha": "e6340040e9c196f024131024d3b257c1ca290e85", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -5,7 +5,7 @@\n //! subtyping, type equality, etc.\n \n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::{self, ImplSubject, Term, TermKind, Ty, TyCtxt, TypeFoldable};\n+use crate::ty::{self, Expr, ImplSubject, Term, TermKind, Ty, TyCtxt, TypeFoldable};\n use crate::ty::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_hir as ast;\n use rustc_hir::def_id::DefId;\n@@ -613,7 +613,10 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     if a_ty != b_ty {\n         relation.tcx().sess.delay_span_bug(\n             DUMMY_SP,\n-            &format!(\"cannot relate constants of different types: {} != {}\", a_ty, b_ty),\n+            &format!(\n+                \"cannot relate constants ({:?}, {:?}) of different types: {} != {}\",\n+                a, b, a_ty, b_ty\n+            ),\n         );\n     }\n \n@@ -623,11 +626,16 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n     // an unnormalized (i.e. unevaluated) const in the param-env.\n     // FIXME(generic_const_exprs): Once we always lazily unify unevaluated constants\n     // these `eval` calls can be removed.\n-    if !relation.tcx().features().generic_const_exprs {\n+    if !tcx.features().generic_const_exprs {\n         a = a.eval(tcx, relation.param_env());\n         b = b.eval(tcx, relation.param_env());\n     }\n \n+    if tcx.features().generic_const_exprs {\n+        a = tcx.expand_abstract_consts(a);\n+        b = tcx.expand_abstract_consts(b);\n+    }\n+\n     // Currently, the values that can be unified are primitive types,\n     // and those that derive both `PartialEq` and `Eq`, corresponding\n     // to structural-match types.\n@@ -644,16 +652,11 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Placeholder(p1), ty::ConstKind::Placeholder(p2)) => p1 == p2,\n         (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n \n-        (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n-            if tcx.features().generic_const_exprs =>\n-        {\n-            tcx.try_unify_abstract_consts(relation.param_env().and((au, bu)))\n-        }\n-\n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`\n         // and is the better alternative to waiting until `generic_const_exprs` can\n         // be stabilized.\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu)) if au.def == bu.def => {\n+            assert_eq!(a.ty(), b.ty());\n             let substs = relation.relate_with_variance(\n                 ty::Variance::Invariant,\n                 ty::VarianceDiagInfo::default(),\n@@ -665,6 +668,50 @@ pub fn super_relate_consts<'tcx, R: TypeRelation<'tcx>>(\n                 a.ty(),\n             ));\n         }\n+        // Before calling relate on exprs, it is necessary to ensure that the nested consts\n+        // have identical types.\n+        (ty::ConstKind::Expr(ae), ty::ConstKind::Expr(be)) => {\n+            let r = relation;\n+\n+            // FIXME(generic_const_exprs): is it possible to relate two consts which are not identical\n+            // exprs? Should we care about that?\n+            let expr = match (ae, be) {\n+                (Expr::Binop(a_op, al, ar), Expr::Binop(b_op, bl, br))\n+                    if a_op == b_op && al.ty() == bl.ty() && ar.ty() == br.ty() =>\n+                {\n+                    Expr::Binop(a_op, r.consts(al, bl)?, r.consts(ar, br)?)\n+                }\n+                (Expr::UnOp(a_op, av), Expr::UnOp(b_op, bv))\n+                    if a_op == b_op && av.ty() == bv.ty() =>\n+                {\n+                    Expr::UnOp(a_op, r.consts(av, bv)?)\n+                }\n+                (Expr::Cast(ak, av, at), Expr::Cast(bk, bv, bt))\n+                    if ak == bk && av.ty() == bv.ty() =>\n+                {\n+                    Expr::Cast(ak, r.consts(av, bv)?, r.tys(at, bt)?)\n+                }\n+                (Expr::FunctionCall(af, aa), Expr::FunctionCall(bf, ba))\n+                    if aa.len() == ba.len()\n+                        && af.ty() == bf.ty()\n+                        && aa\n+                            .iter()\n+                            .zip(ba.iter())\n+                            .all(|(a_arg, b_arg)| a_arg.ty() == b_arg.ty()) =>\n+                {\n+                    let func = r.consts(af, bf)?;\n+                    let mut related_args = Vec::with_capacity(aa.len());\n+                    for (a_arg, b_arg) in aa.iter().zip(ba.iter()) {\n+                        related_args.push(r.consts(a_arg, b_arg)?);\n+                    }\n+                    let related_args = tcx.mk_const_list(related_args.iter());\n+                    Expr::FunctionCall(func, related_args)\n+                }\n+                _ => return Err(TypeError::ConstMismatch(expected_found(r, a, b))),\n+            };\n+            let kind = ty::ConstKind::Expr(expr);\n+            return Ok(tcx.mk_const(kind, a.ty()));\n+        }\n         _ => false,\n     };\n     if is_match { Ok(a) } else { Err(TypeError::ConstMismatch(expected_found(relation, a, b))) }"}, {"sha": "9f70b4f1ffd25291592894531cab301143c473bb", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -601,6 +601,12 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::PolyExistentialPredicate<'t\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Const<'tcx>> {\n+    fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n+        ty::util::fold_list(self, folder, |tcx, v| tcx.mk_const_list(v.iter()))\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ProjectionKind> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_projs(v))"}, {"sha": "4fab5abe909d40c39042aee829a86bff88e51f7b", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -214,6 +214,24 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Value(_)\n                 | ty::ConstKind::Error(_) => {}\n \n+                ty::ConstKind::Expr(expr) => match expr {\n+                    ty::Expr::UnOp(_, v) => push_inner(stack, v.into()),\n+                    ty::Expr::Binop(_, l, r) => {\n+                        push_inner(stack, r.into());\n+                        push_inner(stack, l.into())\n+                    }\n+                    ty::Expr::FunctionCall(func, args) => {\n+                        for a in args.iter().rev() {\n+                            push_inner(stack, a.into());\n+                        }\n+                        push_inner(stack, func.into());\n+                    }\n+                    ty::Expr::Cast(_, c, t) => {\n+                        push_inner(stack, t.into());\n+                        push_inner(stack, c.into());\n+                    }\n+                },\n+\n                 ty::ConstKind::Unevaluated(ct) => {\n                     stack.extend(ct.substs.iter().rev());\n                 }"}, {"sha": "f2177a7c28332432c41eae1ce32fd81409a454f8", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -3,6 +3,7 @@\n #![feature(control_flow_enum)]\n #![feature(rustc_private)]\n #![feature(try_blocks)]\n+#![feature(let_chains)]\n #![recursion_limit = \"256\"]\n #![deny(rustc::untranslatable_diagnostic)]\n #![deny(rustc::diagnostic_outside_of_impl)]\n@@ -25,7 +26,6 @@ use rustc_middle::bug;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::privacy::{EffectiveVisibilities, Level};\n use rustc_middle::span_bug;\n-use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst, Node as ACNode};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, Const, DefIdTree, GenericParamDefKind};\n@@ -288,19 +288,8 @@ where\n     }\n \n     fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        self.visit_ty(c.ty())?;\n         let tcx = self.def_id_visitor.tcx();\n-        if let Ok(Some(ct)) = AbstractConst::from_const(tcx, c) {\n-            walk_abstract_const(tcx, ct, |node| match node.root(tcx) {\n-                ACNode::Leaf(leaf) => self.visit_const(leaf),\n-                ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n-                ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n-                    ControlFlow::CONTINUE\n-                }\n-            })\n-        } else {\n-            ControlFlow::CONTINUE\n-        }\n+        tcx.expand_abstract_consts(c).super_visit_with(self)\n     }\n }\n "}, {"sha": "c61d2a9c2d0c6f713407c4af0f31bd055054f415", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -812,12 +812,6 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>>\n     }\n }\n \n-impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [ty::abstract_const::Node<'tcx>] {\n-    fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n-        RefDecodable::decode(d)\n-    }\n-}\n-\n impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for &'tcx [(ty::Predicate<'tcx>, Span)] {\n     fn decode(d: &mut CacheDecoder<'a, 'tcx>) -> Self {\n         RefDecodable::decode(d)"}, {"sha": "b6378af7ba09c5693fa621282b2f3dc6b7f2351b", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -575,6 +575,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             // a path), even for it we still need to encode a placeholder, as\n             // the path could refer back to e.g. an `impl` using the constant.\n             ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Expr(_)\n             | ty::ConstKind::Param(_)\n             | ty::ConstKind::Infer(_)\n             | ty::ConstKind::Bound(..)"}, {"sha": "e9e65336299e45770425b46122890cd0cc75f0bf", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 107, "deletions": 197, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -8,152 +8,18 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `thir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def::DefKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::ty::abstract_const::{\n-    walk_abstract_const, AbstractConst, FailureKind, Node, NotConstEvaluatable,\n-};\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n-use rustc_span::Span;\n-\n-use std::iter;\n-use std::ops::ControlFlow;\n-\n-pub struct ConstUnifyCtxt<'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'tcx> ConstUnifyCtxt<'tcx> {\n-    // Substitutes generics repeatedly to allow AbstractConsts to unify where a\n-    // ConstKind::Unevaluated could be turned into an AbstractConst that would unify e.g.\n-    // Param(N) should unify with Param(T), substs: [Unevaluated(\"T2\", [Unevaluated(\"T3\", [Param(N)])])]\n-    #[inline]\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn try_replace_substs_in_root(\n-        &self,\n-        mut abstr_const: AbstractConst<'tcx>,\n-    ) -> Option<AbstractConst<'tcx>> {\n-        while let Node::Leaf(ct) = abstr_const.root(self.tcx) {\n-            match AbstractConst::from_const(self.tcx, ct) {\n-                Ok(Some(act)) => abstr_const = act,\n-                Ok(None) => break,\n-                Err(_) => return None,\n-            }\n-        }\n-\n-        Some(abstr_const)\n-    }\n-\n-    /// Tries to unify two abstract constants using structural equality.\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub fn try_unify(&self, a: AbstractConst<'tcx>, b: AbstractConst<'tcx>) -> bool {\n-        let a = if let Some(a) = self.try_replace_substs_in_root(a) {\n-            a\n-        } else {\n-            return true;\n-        };\n-\n-        let b = if let Some(b) = self.try_replace_substs_in_root(b) {\n-            b\n-        } else {\n-            return true;\n-        };\n \n-        let a_root = a.root(self.tcx);\n-        let b_root = b.root(self.tcx);\n-        debug!(?a_root, ?b_root);\n-\n-        match (a_root, b_root) {\n-            (Node::Leaf(a_ct), Node::Leaf(b_ct)) => {\n-                let a_ct = a_ct.eval(self.tcx, self.param_env);\n-                debug!(\"a_ct evaluated: {:?}\", a_ct);\n-                let b_ct = b_ct.eval(self.tcx, self.param_env);\n-                debug!(\"b_ct evaluated: {:?}\", b_ct);\n-\n-                if a_ct.ty() != b_ct.ty() {\n-                    return false;\n-                }\n-\n-                match (a_ct.kind(), b_ct.kind()) {\n-                    // We can just unify errors with everything to reduce the amount of\n-                    // emitted errors here.\n-                    (ty::ConstKind::Error(_), _) | (_, ty::ConstKind::Error(_)) => true,\n-                    (ty::ConstKind::Param(a_param), ty::ConstKind::Param(b_param)) => {\n-                        a_param == b_param\n-                    }\n-                    (ty::ConstKind::Value(a_val), ty::ConstKind::Value(b_val)) => a_val == b_val,\n-                    // If we have `fn a<const N: usize>() -> [u8; N + 1]` and `fn b<const M: usize>() -> [u8; 1 + M]`\n-                    // we do not want to use `assert_eq!(a(), b())` to infer that `N` and `M` have to be `1`. This\n-                    // means that we only allow inference variables if they are equal.\n-                    (ty::ConstKind::Infer(a_val), ty::ConstKind::Infer(b_val)) => a_val == b_val,\n-                    // We expand generic anonymous constants at the start of this function, so this\n-                    // branch should only be taking when dealing with associated constants, at\n-                    // which point directly comparing them seems like the desired behavior.\n-                    //\n-                    // FIXME(generic_const_exprs): This isn't actually the case.\n-                    // We also take this branch for concrete anonymous constants and\n-                    // expand generic anonymous constants with concrete substs.\n-                    (ty::ConstKind::Unevaluated(a_uv), ty::ConstKind::Unevaluated(b_uv)) => {\n-                        a_uv == b_uv\n-                    }\n-                    // FIXME(generic_const_exprs): We may want to either actually try\n-                    // to evaluate `a_ct` and `b_ct` if they are fully concrete or something like\n-                    // this, for now we just return false here.\n-                    _ => false,\n-                }\n-            }\n-            (Node::Binop(a_op, al, ar), Node::Binop(b_op, bl, br)) if a_op == b_op => {\n-                self.try_unify(a.subtree(al), b.subtree(bl))\n-                    && self.try_unify(a.subtree(ar), b.subtree(br))\n-            }\n-            (Node::UnaryOp(a_op, av), Node::UnaryOp(b_op, bv)) if a_op == b_op => {\n-                self.try_unify(a.subtree(av), b.subtree(bv))\n-            }\n-            (Node::FunctionCall(a_f, a_args), Node::FunctionCall(b_f, b_args))\n-                if a_args.len() == b_args.len() =>\n-            {\n-                self.try_unify(a.subtree(a_f), b.subtree(b_f))\n-                    && iter::zip(a_args, b_args)\n-                        .all(|(&an, &bn)| self.try_unify(a.subtree(an), b.subtree(bn)))\n-            }\n-            (Node::Cast(a_kind, a_operand, a_ty), Node::Cast(b_kind, b_operand, b_ty))\n-                if (a_ty == b_ty) && (a_kind == b_kind) =>\n-            {\n-                self.try_unify(a.subtree(a_operand), b.subtree(b_operand))\n-            }\n-            // use this over `_ => false` to make adding variants to `Node` less error prone\n-            (Node::Cast(..), _)\n-            | (Node::FunctionCall(..), _)\n-            | (Node::UnaryOp(..), _)\n-            | (Node::Binop(..), _)\n-            | (Node::Leaf(..), _) => false,\n-        }\n-    }\n-}\n+use rustc_middle::traits::ObligationCause;\n+use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n+use rustc_middle::ty::{self, TyCtxt, TypeVisitable, TypeVisitor};\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-pub fn try_unify_abstract_consts<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    (a, b): (ty::UnevaluatedConst<'tcx>, ty::UnevaluatedConst<'tcx>),\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> bool {\n-    (|| {\n-        if let Some(a) = AbstractConst::new(tcx, a)? {\n-            if let Some(b) = AbstractConst::new(tcx, b)? {\n-                let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n-                return Ok(const_unify_ctxt.try_unify(a, b));\n-            }\n-        }\n+use rustc_span::Span;\n+use std::ops::ControlFlow;\n \n-        Ok(false)\n-    })()\n-    .unwrap_or_else(|_: ErrorGuaranteed| true)\n-    // FIXME(generic_const_exprs): We should instead have this\n-    // method return the resulting `ty::Const` and return `ConstKind::Error`\n-    // on `ErrorGuaranteed`.\n-}\n+use crate::traits::ObligationCtxt;\n \n /// Check if a given constant can be evaluated.\n #[instrument(skip(infcx), level = \"debug\")]\n@@ -166,6 +32,8 @@ pub fn is_const_evaluatable<'tcx>(\n     let tcx = infcx.tcx;\n     let uv = match ct.kind() {\n         ty::ConstKind::Unevaluated(uv) => uv,\n+        // FIXME(generic_const_exprs): this seems wrong but I couldn't find a way to get this to trigger\n+        ty::ConstKind::Expr(_) => bug!(\"unexpected expr in `is_const_evaluatable: {ct:?}\"),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)\n         | ty::ConstKind::Placeholder(_)\n@@ -175,21 +43,25 @@ pub fn is_const_evaluatable<'tcx>(\n     };\n \n     if tcx.features().generic_const_exprs {\n-        if let Some(ct) = AbstractConst::new(tcx, uv)? {\n-            if satisfied_from_param_env(tcx, ct, param_env)? {\n+        let ct = tcx.expand_abstract_consts(ct);\n+\n+        let is_anon_ct = if let ty::ConstKind::Unevaluated(uv) = ct.kind() {\n+            tcx.def_kind(uv.def.did) == DefKind::AnonConst\n+        } else {\n+            false\n+        };\n+\n+        if !is_anon_ct {\n+            if satisfied_from_param_env(tcx, infcx, ct, param_env) {\n                 return Ok(());\n             }\n-            match ct.unify_failure_kind(tcx) {\n-                FailureKind::MentionsInfer => {\n-                    return Err(NotConstEvaluatable::MentionsInfer);\n-                }\n-                FailureKind::MentionsParam => {\n-                    return Err(NotConstEvaluatable::MentionsParam);\n-                }\n-                // returned below\n-                FailureKind::Concrete => {}\n+            if ct.has_non_region_infer() {\n+                return Err(NotConstEvaluatable::MentionsInfer);\n+            } else if ct.has_non_region_param() {\n+                return Err(NotConstEvaluatable::MentionsParam);\n             }\n         }\n+\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n         match concrete {\n             Err(ErrorHandled::TooGeneric) => Err(NotConstEvaluatable::Error(\n@@ -211,28 +83,33 @@ pub fn is_const_evaluatable<'tcx>(\n         //\n         // See #74595 for more details about this.\n         let concrete = infcx.const_eval_resolve(param_env, uv, Some(span));\n-\n         match concrete {\n-          // If we're evaluating a foreign constant, under a nightly compiler without generic\n-          // const exprs, AND it would've passed if that expression had been evaluated with\n-          // generic const exprs, then suggest using generic const exprs.\n-          Err(_) if tcx.sess.is_nightly_build()\n-            && let Ok(Some(ct)) = AbstractConst::new(tcx, uv)\n-            && satisfied_from_param_env(tcx, ct, param_env) == Ok(true) => {\n-              tcx.sess\n-                  .struct_span_fatal(\n-                      // Slightly better span than just using `span` alone\n-                      if span == rustc_span::DUMMY_SP { tcx.def_span(uv.def.did) } else { span },\n-                      \"failed to evaluate generic const expression\",\n-                  )\n-                  .note(\"the crate this constant originates from uses `#![feature(generic_const_exprs)]`\")\n-                  .span_suggestion_verbose(\n-                      rustc_span::DUMMY_SP,\n-                      \"consider enabling this feature\",\n-                      \"#![feature(generic_const_exprs)]\\n\",\n-                      rustc_errors::Applicability::MaybeIncorrect,\n-                  )\n-                  .emit()\n+            // If we're evaluating a generic foreign constant, under a nightly compiler while\n+            // the current crate does not enable `feature(generic_const_exprs)`, abort\n+            // compilation with a useful error.\n+            Err(_)\n+                if tcx.sess.is_nightly_build()\n+                    && satisfied_from_param_env(\n+                        tcx,\n+                        infcx,\n+                        tcx.expand_abstract_consts(ct),\n+                        param_env,\n+                    ) =>\n+            {\n+                tcx.sess\n+                    .struct_span_fatal(\n+                        // Slightly better span than just using `span` alone\n+                        if span == rustc_span::DUMMY_SP { tcx.def_span(uv.def.did) } else { span },\n+                        \"failed to evaluate generic const expression\",\n+                    )\n+                    .note(\"the crate this constant originates from uses `#![feature(generic_const_exprs)]`\")\n+                    .span_suggestion_verbose(\n+                        rustc_span::DUMMY_SP,\n+                        \"consider enabling this feature\",\n+                        \"#![feature(generic_const_exprs)]\\n\",\n+                        rustc_errors::Applicability::MaybeIncorrect,\n+                    )\n+                    .emit()\n             }\n \n             Err(ErrorHandled::TooGeneric) => {\n@@ -241,49 +118,82 @@ pub fn is_const_evaluatable<'tcx>(\n                 } else if uv.has_non_region_param() {\n                     NotConstEvaluatable::MentionsParam\n                 } else {\n-                    let guar = infcx.tcx.sess.delay_span_bug(span, format!(\"Missing value for constant, but no error reported?\"));\n+                    let guar = infcx.tcx.sess.delay_span_bug(\n+                        span,\n+                        format!(\"Missing value for constant, but no error reported?\"),\n+                    );\n                     NotConstEvaluatable::Error(guar)\n                 };\n \n                 Err(err)\n-            },\n+            }\n             Err(ErrorHandled::Reported(e)) => Err(NotConstEvaluatable::Error(e)),\n             Ok(_) => Ok(()),\n         }\n     }\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n+#[instrument(skip(infcx, tcx), level = \"debug\")]\n fn satisfied_from_param_env<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    ct: AbstractConst<'tcx>,\n+    infcx: &InferCtxt<'tcx>,\n+    ct: ty::Const<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> Result<bool, NotConstEvaluatable> {\n+) -> bool {\n+    // Try to unify with each subtree in the AbstractConst to allow for\n+    // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n+    // predicate for `(N + 1) * 2`\n+    struct Visitor<'a, 'tcx> {\n+        ct: ty::Const<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+\n+        infcx: &'a InferCtxt<'tcx>,\n+    }\n+    impl<'a, 'tcx> TypeVisitor<'tcx> for Visitor<'a, 'tcx> {\n+        type BreakTy = ();\n+        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let Ok(()) = self.infcx.commit_if_ok(|_| {\n+                let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+                if let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c.ty(), self.ct.ty())\n+                    && let Ok(()) = ocx.eq(&ObligationCause::dummy(), self.param_env, c, self.ct)\n+                    && ocx.select_all_or_error().is_empty()\n+                {\n+                    Ok(())\n+                } else {\n+                    Err(())\n+                }\n+            }) {\n+                ControlFlow::BREAK\n+            } else if let ty::ConstKind::Expr(e) = c.kind() {\n+                e.visit_with(self)\n+            } else {\n+                // FIXME(generic_const_exprs): This doesn't recurse into `<T as Trait<U>>::ASSOC`'s substs.\n+                // This is currently unobservable as `<T as Trait<{ U + 1 }>>::ASSOC` creates an anon const\n+                // with its own `ConstEvaluatable` bound in the param env which we will visit separately.\n+                //\n+                // If we start allowing directly writing `ConstKind::Expr` without an intermediate anon const\n+                // this will be incorrect. It might be worth investigating making `predicates_of` elaborate\n+                // all of the `ConstEvaluatable` bounds rather than having a visitor here.\n+                ControlFlow::CONTINUE\n+            }\n+        }\n+    }\n+\n     for pred in param_env.caller_bounds() {\n         match pred.kind().skip_binder() {\n-            ty::PredicateKind::ConstEvaluatable(uv) => {\n-                if let Some(b_ct) = AbstractConst::from_const(tcx, uv)? {\n-                    let const_unify_ctxt = ConstUnifyCtxt { tcx, param_env };\n-\n-                    // Try to unify with each subtree in the AbstractConst to allow for\n-                    // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n-                    // predicate for `(N + 1) * 2`\n-                    let result = walk_abstract_const(tcx, b_ct, |b_ct| {\n-                        match const_unify_ctxt.try_unify(ct, b_ct) {\n-                            true => ControlFlow::BREAK,\n-                            false => ControlFlow::CONTINUE,\n-                        }\n-                    });\n-\n-                    if let ControlFlow::Break(()) = result {\n-                        debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n-                        return Ok(true);\n-                    }\n+            ty::PredicateKind::ConstEvaluatable(ce) => {\n+                let b_ct = tcx.expand_abstract_consts(ce);\n+                let mut v = Visitor { ct, infcx, param_env };\n+                let result = b_ct.visit_with(&mut v);\n+\n+                if let ControlFlow::Break(()) = result {\n+                    debug!(\"is_const_evaluatable: abstract_const ~~> ok\");\n+                    return true;\n                 }\n             }\n             _ => {} // don't care\n         }\n     }\n \n-    Ok(false)\n+    false\n }"}, {"sha": "80ee363d72f62cc5d568d13042451172a5de9d78", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -455,20 +455,47 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n+                    let tcx = self.selcx.tcx();\n                     assert!(\n-                        self.selcx.tcx().features().generic_const_exprs,\n+                        tcx.features().generic_const_exprs,\n                         \"`ConstEquate` without a feature gate: {c1:?} {c2:?}\",\n                     );\n-                    debug!(?c1, ?c2, \"equating consts\");\n                     // FIXME: we probably should only try to unify abstract constants\n                     // if the constants depend on generic parameters.\n                     //\n                     // Let's just see where this breaks :shrug:\n-                    if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n-                        (c1.kind(), c2.kind())\n                     {\n-                        if infcx.try_unify_abstract_consts(a, b, obligation.param_env) {\n-                            return ProcessResult::Changed(vec![]);\n+                        let c1 = tcx.expand_abstract_consts(c1);\n+                        let c2 = tcx.expand_abstract_consts(c2);\n+                        debug!(\"equating consts:\\nc1= {:?}\\nc2= {:?}\", c1, c2);\n+\n+                        use rustc_hir::def::DefKind;\n+                        use ty::ConstKind::Unevaluated;\n+                        match (c1.kind(), c2.kind()) {\n+                            (Unevaluated(a), Unevaluated(b))\n+                                if a.def.did == b.def.did\n+                                    && tcx.def_kind(a.def.did) == DefKind::AssocConst =>\n+                            {\n+                                if let Ok(new_obligations) = infcx\n+                                    .at(&obligation.cause, obligation.param_env)\n+                                    .trace(c1, c2)\n+                                    .eq(a.substs, b.substs)\n+                                {\n+                                    return ProcessResult::Changed(mk_pending(\n+                                        new_obligations.into_obligations(),\n+                                    ));\n+                                }\n+                            }\n+                            (_, Unevaluated(_)) | (Unevaluated(_), _) => (),\n+                            (_, _) => {\n+                                if let Ok(new_obligations) =\n+                                    infcx.at(&obligation.cause, obligation.param_env).eq(c1, c2)\n+                                {\n+                                    return ProcessResult::Changed(mk_pending(\n+                                        new_obligations.into_obligations(),\n+                                    ));\n+                                }\n+                            }\n                         }\n                     }\n \n@@ -508,7 +535,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n-                                Ok(_) => ProcessResult::Changed(vec![]),\n+                                Ok(inf_ok) => {\n+                                    ProcessResult::Changed(mk_pending(inf_ok.into_obligations()))\n+                                }\n                                 Err(err) => ProcessResult::Error(\n                                     FulfillmentErrorCode::CodeConstEquateError(\n                                         ExpectedFound::new(true, c1, c2),"}, {"sha": "5285cfa674669091a6f775a18d943895d5a781d2", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -932,10 +932,6 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n         is_impossible_method,\n-        try_unify_abstract_consts: |tcx, param_env_and| {\n-            let (param_env, (a, b)) = param_env_and.into_parts();\n-            const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)\n-        },\n         ..*providers\n     };\n }"}, {"sha": "a45749fe48cd48a5d625deb3d7e146ec942984e8", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -17,11 +17,10 @@ use hir::def::DefKind;\n use rustc_errors::{DelayDm, FatalError, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty::abstract_const::{walk_abstract_const, AbstractConst};\n+use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{\n     self, EarlyBinder, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n };\n-use rustc_middle::ty::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{Predicate, ToPredicate};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n@@ -837,23 +836,9 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n         }\n \n         fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            // Constants can only influence object safety if they reference `Self`.\n+            // Constants can only influence object safety if they are generic and reference `Self`.\n             // This is only possible for unevaluated constants, so we walk these here.\n-            //\n-            // If `AbstractConst::from_const` returned an error we already failed compilation\n-            // so we don't have to emit an additional error here.\n-            use rustc_middle::ty::abstract_const::Node;\n-            if let Ok(Some(ct)) = AbstractConst::from_const(self.tcx, ct) {\n-                walk_abstract_const(self.tcx, ct, |node| match node.root(self.tcx) {\n-                    Node::Leaf(leaf) => self.visit_const(leaf),\n-                    Node::Cast(_, _, ty) => self.visit_ty(ty),\n-                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n-                        ControlFlow::CONTINUE\n-                    }\n-                })\n-            } else {\n-                ct.super_visit_with(self)\n-            }\n+            self.tcx.expand_abstract_consts(ct).super_visit_with(self)\n         }\n     }\n "}, {"sha": "6e8706897bfae785d2d27103645593145a0bb753", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -657,21 +657,62 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n+                    let tcx = self.tcx();\n                     assert!(\n-                        self.tcx().features().generic_const_exprs,\n+                        tcx.features().generic_const_exprs,\n                         \"`ConstEquate` without a feature gate: {c1:?} {c2:?}\",\n                     );\n-                    debug!(?c1, ?c2, \"evaluate_predicate_recursively: equating consts\");\n \n-                    // FIXME: we probably should only try to unify abstract constants\n-                    // if the constants depend on generic parameters.\n-                    //\n-                    // Let's just see where this breaks :shrug:\n-                    if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n-                        (c1.kind(), c2.kind())\n                     {\n-                        if self.infcx.try_unify_abstract_consts(a, b, obligation.param_env) {\n-                            return Ok(EvaluatedToOk);\n+                        let c1 = tcx.expand_abstract_consts(c1);\n+                        let c2 = tcx.expand_abstract_consts(c2);\n+                        debug!(\n+                            \"evalaute_predicate_recursively: equating consts:\\nc1= {:?}\\nc2= {:?}\",\n+                            c1, c2\n+                        );\n+\n+                        use rustc_hir::def::DefKind;\n+                        use ty::ConstKind::Unevaluated;\n+                        match (c1.kind(), c2.kind()) {\n+                            (Unevaluated(a), Unevaluated(b))\n+                                if a.def.did == b.def.did\n+                                    && tcx.def_kind(a.def.did) == DefKind::AssocConst =>\n+                            {\n+                                if let Ok(new_obligations) = self\n+                                    .infcx\n+                                    .at(&obligation.cause, obligation.param_env)\n+                                    .trace(c1, c2)\n+                                    .eq(a.substs, b.substs)\n+                                {\n+                                    let mut obligations = new_obligations.obligations;\n+                                    self.add_depth(\n+                                        obligations.iter_mut(),\n+                                        obligation.recursion_depth,\n+                                    );\n+                                    return self.evaluate_predicates_recursively(\n+                                        previous_stack,\n+                                        obligations.into_iter(),\n+                                    );\n+                                }\n+                            }\n+                            (_, Unevaluated(_)) | (Unevaluated(_), _) => (),\n+                            (_, _) => {\n+                                if let Ok(new_obligations) = self\n+                                    .infcx\n+                                    .at(&obligation.cause, obligation.param_env)\n+                                    .eq(c1, c2)\n+                                {\n+                                    let mut obligations = new_obligations.obligations;\n+                                    self.add_depth(\n+                                        obligations.iter_mut(),\n+                                        obligation.recursion_depth,\n+                                    );\n+                                    return self.evaluate_predicates_recursively(\n+                                        previous_stack,\n+                                        obligations.into_iter(),\n+                                    );\n+                                }\n+                            }\n                         }\n                     }\n \n@@ -698,7 +739,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 .at(&obligation.cause, obligation.param_env)\n                                 .eq(c1, c2)\n                             {\n-                                Ok(_) => Ok(EvaluatedToOk),\n+                                Ok(inf_ok) => self.evaluate_predicates_recursively(\n+                                    previous_stack,\n+                                    inf_ok.into_obligations(),\n+                                ),\n                                 Err(_) => Ok(EvaluatedToErr),\n                             }\n                         }"}, {"sha": "0855d6d19736f15d91a39eb63d2bd17724005916", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -476,6 +476,11 @@ impl<'tcx> WfPredicates<'tcx> {\n                                 ty::Binder::dummy(ty::PredicateKind::WellFormed(ct.into())),\n                             ));\n                         }\n+                        // FIXME(generic_const_exprs): This seems wrong but I could not find a way to get this to trigger\n+                        ty::ConstKind::Expr(_) => {\n+                            bug!(\"checking wfness of `ConstKind::Expr` is unsupported\")\n+                        }\n+\n                         ty::ConstKind::Error(_)\n                         | ty::ConstKind::Param(_)\n                         | ty::ConstKind::Bound(..)"}, {"sha": "2b7018bc9c3009c654cc06d453b671a95ed115b8", "filename": "compiler/rustc_ty_utils/src/consts.rs", "status": "modified", "additions": 256, "deletions": 296, "changes": 552, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fconsts.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1,10 +1,11 @@\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::vec::IndexVec;\n use rustc_middle::mir::interpret::{LitToConstError, LitToConstInput};\n-use rustc_middle::ty::abstract_const::{CastKind, Node, NodeId};\n-use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n+use rustc_middle::thir::visit;\n+use rustc_middle::thir::visit::Visitor;\n+use rustc_middle::ty::abstract_const::CastKind;\n+use rustc_middle::ty::{self, ConstKind, Expr, TyCtxt, TypeVisitable};\n use rustc_middle::{mir, thir};\n use rustc_span::Span;\n use rustc_target::abi::VariantIdx;\n@@ -76,334 +77,286 @@ pub(crate) fn destructure_const<'tcx>(\n     ty::DestructuredConst { variant, fields }\n }\n \n-pub struct AbstractConstBuilder<'a, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    body_id: thir::ExprId,\n-    body: &'a thir::Thir<'tcx>,\n-    /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n-}\n-\n-impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n-    fn root_span(&self) -> Span {\n-        self.body.exprs[self.body_id].span\n-    }\n-\n-    fn error(&mut self, sub: GenericConstantTooComplexSub) -> Result<!, ErrorGuaranteed> {\n-        let reported = self.tcx.sess.emit_err(GenericConstantTooComplex {\n-            span: self.root_span(),\n-            maybe_supported: None,\n-            sub,\n-        });\n-\n-        Err(reported)\n+/// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n+fn check_binop(op: mir::BinOp) -> bool {\n+    use mir::BinOp::*;\n+    match op {\n+        Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le | Ne\n+        | Ge | Gt => true,\n+        Offset => false,\n     }\n+}\n \n-    fn maybe_supported_error(\n-        &mut self,\n-        sub: GenericConstantTooComplexSub,\n-    ) -> Result<!, ErrorGuaranteed> {\n-        let reported = self.tcx.sess.emit_err(GenericConstantTooComplex {\n-            span: self.root_span(),\n-            maybe_supported: Some(()),\n-            sub,\n-        });\n-\n-        Err(reported)\n+/// While we currently allow all unary operations, we still want to explicitly guard against\n+/// future changes here.\n+fn check_unop(op: mir::UnOp) -> bool {\n+    use mir::UnOp::*;\n+    match op {\n+        Not | Neg => true,\n     }\n+}\n \n-    #[instrument(skip(tcx, body, body_id), level = \"debug\")]\n-    pub fn new(\n-        tcx: TyCtxt<'tcx>,\n-        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n-    ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorGuaranteed> {\n-        let builder = AbstractConstBuilder { tcx, body_id, body, nodes: IndexVec::new() };\n-\n-        struct IsThirPolymorphic<'a, 'tcx> {\n-            is_poly: bool,\n-            thir: &'a thir::Thir<'tcx>,\n+fn recurse_build<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    body: &thir::Thir<'tcx>,\n+    node: thir::ExprId,\n+    root_span: Span,\n+) -> Result<ty::Const<'tcx>, ErrorGuaranteed> {\n+    use thir::ExprKind;\n+    let node = &body.exprs[node];\n+\n+    let maybe_supported_error = |a| maybe_supported_error(tcx, a, root_span);\n+    let error = |a| error(tcx, a, root_span);\n+\n+    Ok(match &node.kind {\n+        // I dont know if handling of these 3 is correct\n+        &ExprKind::Scope { value, .. } => recurse_build(tcx, body, value, root_span)?,\n+        &ExprKind::PlaceTypeAscription { source, .. }\n+        | &ExprKind::ValueTypeAscription { source, .. } => {\n+            recurse_build(tcx, body, source, root_span)?\n         }\n-\n-        use crate::rustc_middle::thir::visit::Visitor;\n-        use thir::visit;\n-\n-        impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n-            fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n-                if expr.ty.has_non_region_param() {\n-                    return true;\n+        &ExprKind::Literal { lit, neg } => {\n+            let sp = node.span;\n+            match tcx.at(sp).lit_to_const(LitToConstInput { lit: &lit.node, ty: node.ty, neg }) {\n+                Ok(c) => c,\n+                Err(LitToConstError::Reported(guar)) => {\n+                    tcx.const_error_with_guaranteed(node.ty, guar)\n                 }\n-\n-                match expr.kind {\n-                    thir::ExprKind::NamedConst { substs, .. } => substs.has_non_region_param(),\n-                    thir::ExprKind::ConstParam { .. } => true,\n-                    thir::ExprKind::Repeat { value, count } => {\n-                        self.visit_expr(&self.thir()[value]);\n-                        count.has_non_region_param()\n-                    }\n-                    _ => false,\n+                Err(LitToConstError::TypeError) => {\n+                    bug!(\"encountered type error in lit_to_const\")\n                 }\n             }\n+        }\n+        &ExprKind::NonHirLiteral { lit, user_ty: _ } => {\n+            let val = ty::ValTree::from_scalar_int(lit);\n+            ty::Const::from_value(tcx, val, node.ty)\n+        }\n+        &ExprKind::ZstLiteral { user_ty: _ } => {\n+            let val = ty::ValTree::zst();\n+            ty::Const::from_value(tcx, val, node.ty)\n+        }\n+        &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n+            let uneval = ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+            tcx.mk_const(ty::ConstKind::Unevaluated(uneval), node.ty)\n+        }\n+        ExprKind::ConstParam { param, .. } => tcx.mk_const(ty::ConstKind::Param(*param), node.ty),\n \n-            fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n-                if pat.ty.has_non_region_param() {\n-                    return true;\n-                }\n+        ExprKind::Call { fun, args, .. } => {\n+            let fun = recurse_build(tcx, body, *fun, root_span)?;\n \n-                match pat.kind {\n-                    thir::PatKind::Constant { value } => value.has_non_region_param(),\n-                    thir::PatKind::Range(box thir::PatRange { lo, hi, .. }) => {\n-                        lo.has_non_region_param() || hi.has_non_region_param()\n-                    }\n-                    _ => false,\n-                }\n+            let mut new_args = Vec::<ty::Const<'tcx>>::with_capacity(args.len());\n+            for &id in args.iter() {\n+                new_args.push(recurse_build(tcx, body, id, root_span)?);\n             }\n+            let new_args = tcx.mk_const_list(new_args.iter());\n+            tcx.mk_const(ConstKind::Expr(Expr::FunctionCall(fun, new_args)), node.ty)\n         }\n-\n-        impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n-            fn thir(&self) -> &'a thir::Thir<'tcx> {\n-                &self.thir\n-            }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n-                self.is_poly |= self.expr_is_poly(expr);\n-                if !self.is_poly {\n-                    visit::walk_expr(self, expr)\n-                }\n+        &ExprKind::Binary { op, lhs, rhs } if check_binop(op) => {\n+            let lhs = recurse_build(tcx, body, lhs, root_span)?;\n+            let rhs = recurse_build(tcx, body, rhs, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::Binop(op, lhs, rhs)), node.ty)\n+        }\n+        &ExprKind::Unary { op, arg } if check_unop(op) => {\n+            let arg = recurse_build(tcx, body, arg, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::UnOp(op, arg)), node.ty)\n+        }\n+        // This is necessary so that the following compiles:\n+        //\n+        // ```\n+        // fn foo<const N: usize>(a: [(); N + 1]) {\n+        //     bar::<{ N + 1 }>();\n+        // }\n+        // ```\n+        ExprKind::Block { block } => {\n+            if let thir::Block { stmts: box [], expr: Some(e), .. } = &body.blocks[*block] {\n+                recurse_build(tcx, body, *e, root_span)?\n+            } else {\n+                maybe_supported_error(GenericConstantTooComplexSub::BlockNotSupported(node.span))?\n             }\n-\n-            #[instrument(skip(self), level = \"debug\")]\n-            fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n-                self.is_poly |= self.pat_is_poly(pat);\n-                if !self.is_poly {\n-                    visit::walk_pat(self, pat);\n-                }\n+        }\n+        // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n+        // \"coercion cast\" i.e. using a coercion or is a no-op.\n+        // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n+        &ExprKind::Use { source } => {\n+            let arg = recurse_build(tcx, body, source, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::Cast(CastKind::Use, arg, node.ty)), node.ty)\n+        }\n+        &ExprKind::Cast { source } => {\n+            let arg = recurse_build(tcx, body, source, root_span)?;\n+            tcx.mk_const(ConstKind::Expr(Expr::Cast(CastKind::As, arg, node.ty)), node.ty)\n+        }\n+        ExprKind::Borrow { arg, .. } => {\n+            let arg_node = &body.exprs[*arg];\n+\n+            // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n+            // expressions.\n+            // FIXME(generic_const_exprs): Verify/explain why this is sound\n+            if let ExprKind::Deref { arg } = arg_node.kind {\n+                recurse_build(tcx, body, arg, root_span)?\n+            } else {\n+                maybe_supported_error(GenericConstantTooComplexSub::BorrowNotSupported(node.span))?\n             }\n         }\n-\n-        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n-        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n-        debug!(\"AbstractConstBuilder: is_poly={}\", is_poly_vis.is_poly);\n-        if !is_poly_vis.is_poly {\n-            return Ok(None);\n+        // FIXME(generic_const_exprs): We may want to support these.\n+        ExprKind::AddressOf { .. } | ExprKind::Deref { .. } => maybe_supported_error(\n+            GenericConstantTooComplexSub::AddressAndDerefNotSupported(node.span),\n+        )?,\n+        ExprKind::Repeat { .. } | ExprKind::Array { .. } => {\n+            maybe_supported_error(GenericConstantTooComplexSub::ArrayNotSupported(node.span))?\n         }\n+        ExprKind::NeverToAny { .. } => {\n+            maybe_supported_error(GenericConstantTooComplexSub::NeverToAnyNotSupported(node.span))?\n+        }\n+        ExprKind::Tuple { .. } => {\n+            maybe_supported_error(GenericConstantTooComplexSub::TupleNotSupported(node.span))?\n+        }\n+        ExprKind::Index { .. } => {\n+            maybe_supported_error(GenericConstantTooComplexSub::IndexNotSupported(node.span))?\n+        }\n+        ExprKind::Field { .. } => {\n+            maybe_supported_error(GenericConstantTooComplexSub::FieldNotSupported(node.span))?\n+        }\n+        ExprKind::ConstBlock { .. } => {\n+            maybe_supported_error(GenericConstantTooComplexSub::ConstBlockNotSupported(node.span))?\n+        }\n+        ExprKind::Adt(_) => {\n+            maybe_supported_error(GenericConstantTooComplexSub::AdtNotSupported(node.span))?\n+        }\n+        // dont know if this is correct\n+        ExprKind::Pointer { .. } => {\n+            error(GenericConstantTooComplexSub::PointerNotSupported(node.span))?\n+        }\n+        ExprKind::Yield { .. } => {\n+            error(GenericConstantTooComplexSub::YieldNotSupported(node.span))?\n+        }\n+        ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => {\n+            error(GenericConstantTooComplexSub::LoopNotSupported(node.span))?\n+        }\n+        ExprKind::Box { .. } => error(GenericConstantTooComplexSub::BoxNotSupported(node.span))?,\n \n-        Ok(Some(builder))\n-    }\n-\n-    /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n-    fn check_binop(op: mir::BinOp) -> bool {\n-        use mir::BinOp::*;\n-        match op {\n-            Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr | Eq | Lt | Le\n-            | Ne | Ge | Gt => true,\n-            Offset => false,\n+        ExprKind::Unary { .. } => unreachable!(),\n+        // we handle valid unary/binary ops above\n+        ExprKind::Binary { .. } => {\n+            error(GenericConstantTooComplexSub::BinaryNotSupported(node.span))?\n+        }\n+        ExprKind::LogicalOp { .. } => {\n+            error(GenericConstantTooComplexSub::LogicalOpNotSupported(node.span))?\n+        }\n+        ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n+            error(GenericConstantTooComplexSub::AssignNotSupported(node.span))?\n+        }\n+        ExprKind::Closure { .. } | ExprKind::Return { .. } => {\n+            error(GenericConstantTooComplexSub::ClosureAndReturnNotSupported(node.span))?\n+        }\n+        // let expressions imply control flow\n+        ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } => {\n+            error(GenericConstantTooComplexSub::ControlFlowNotSupported(node.span))?\n+        }\n+        ExprKind::InlineAsm { .. } => {\n+            error(GenericConstantTooComplexSub::InlineAsmNotSupported(node.span))?\n         }\n-    }\n \n-    /// While we currently allow all unary operations, we still want to explicitly guard against\n-    /// future changes here.\n-    fn check_unop(op: mir::UnOp) -> bool {\n-        use mir::UnOp::*;\n-        match op {\n-            Not | Neg => true,\n+        // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n+        ExprKind::VarRef { .. }\n+        | ExprKind::UpvarRef { .. }\n+        | ExprKind::StaticRef { .. }\n+        | ExprKind::ThreadLocalRef(_) => {\n+            error(GenericConstantTooComplexSub::OperationNotSupported(node.span))?\n         }\n-    }\n+    })\n+}\n \n-    /// Builds the abstract const by walking the thir and bailing out when\n-    /// encountering an unsupported operation.\n-    pub fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorGuaranteed> {\n-        debug!(\"AbstractConstBuilder::build: body={:?}\", &*self.body);\n-        self.recurse_build(self.body_id)?;\n+struct IsThirPolymorphic<'a, 'tcx> {\n+    is_poly: bool,\n+    thir: &'a thir::Thir<'tcx>,\n+}\n \n-        Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter()))\n-    }\n+fn error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sub: GenericConstantTooComplexSub,\n+    root_span: Span,\n+) -> Result<!, ErrorGuaranteed> {\n+    let reported = tcx.sess.emit_err(GenericConstantTooComplex {\n+        span: root_span,\n+        maybe_supported: None,\n+        sub,\n+    });\n+\n+    Err(reported)\n+}\n \n-    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorGuaranteed> {\n-        use thir::ExprKind;\n-        let node = &self.body.exprs[node];\n-        Ok(match &node.kind {\n-            // I dont know if handling of these 3 is correct\n-            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n-            &ExprKind::PlaceTypeAscription { source, .. }\n-            | &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n-            &ExprKind::Literal { lit, neg } => {\n-                let sp = node.span;\n-                let constant = match self.tcx.at(sp).lit_to_const(LitToConstInput {\n-                    lit: &lit.node,\n-                    ty: node.ty,\n-                    neg,\n-                }) {\n-                    Ok(c) => c,\n-                    Err(LitToConstError::Reported(guar)) => {\n-                        self.tcx.const_error_with_guaranteed(node.ty, guar)\n-                    }\n-                    Err(LitToConstError::TypeError) => {\n-                        bug!(\"encountered type error in lit_to_const\")\n-                    }\n-                };\n-\n-                self.nodes.push(Node::Leaf(constant))\n-            }\n-            &ExprKind::NonHirLiteral { lit, user_ty: _ } => {\n-                let val = ty::ValTree::from_scalar_int(lit);\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::ZstLiteral { user_ty: _ } => {\n-                let val = ty::ValTree::zst();\n-                self.nodes.push(Node::Leaf(ty::Const::from_value(self.tcx, val, node.ty)))\n-            }\n-            &ExprKind::NamedConst { def_id, substs, user_ty: _ } => {\n-                let uneval =\n-                    ty::UnevaluatedConst::new(ty::WithOptConstParam::unknown(def_id), substs);\n+fn maybe_supported_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    sub: GenericConstantTooComplexSub,\n+    root_span: Span,\n+) -> Result<!, ErrorGuaranteed> {\n+    let reported = tcx.sess.emit_err(GenericConstantTooComplex {\n+        span: root_span,\n+        maybe_supported: Some(()),\n+        sub,\n+    });\n+\n+    Err(reported)\n+}\n \n-                let constant = self.tcx.mk_const(ty::ConstKind::Unevaluated(uneval), node.ty);\n+impl<'a, 'tcx> IsThirPolymorphic<'a, 'tcx> {\n+    fn expr_is_poly(&mut self, expr: &thir::Expr<'tcx>) -> bool {\n+        if expr.ty.has_non_region_param() {\n+            return true;\n+        }\n \n-                self.nodes.push(Node::Leaf(constant))\n+        match expr.kind {\n+            thir::ExprKind::NamedConst { substs, .. } => substs.has_non_region_param(),\n+            thir::ExprKind::ConstParam { .. } => true,\n+            thir::ExprKind::Repeat { value, count } => {\n+                self.visit_expr(&self.thir()[value]);\n+                count.has_non_region_param()\n             }\n+            _ => false,\n+        }\n+    }\n+    fn pat_is_poly(&mut self, pat: &thir::Pat<'tcx>) -> bool {\n+        if pat.ty.has_non_region_param() {\n+            return true;\n+        }\n \n-            ExprKind::ConstParam { param, .. } => {\n-                let const_param = self.tcx.mk_const(ty::ConstKind::Param(*param), node.ty);\n-                self.nodes.push(Node::Leaf(const_param))\n+        match pat.kind {\n+            thir::PatKind::Constant { value } => value.has_non_region_param(),\n+            thir::PatKind::Range(box thir::PatRange { lo, hi, .. }) => {\n+                lo.has_non_region_param() || hi.has_non_region_param()\n             }\n+            _ => false,\n+        }\n+    }\n+}\n \n-            ExprKind::Call { fun, args, .. } => {\n-                let fun = self.recurse_build(*fun)?;\n-\n-                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n-                for &id in args.iter() {\n-                    new_args.push(self.recurse_build(id)?);\n-                }\n-                let new_args = self.tcx.arena.alloc_slice(&new_args);\n-                self.nodes.push(Node::FunctionCall(fun, new_args))\n-            }\n-            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n-                let lhs = self.recurse_build(lhs)?;\n-                let rhs = self.recurse_build(rhs)?;\n-                self.nodes.push(Node::Binop(op, lhs, rhs))\n-            }\n-            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n-                let arg = self.recurse_build(arg)?;\n-                self.nodes.push(Node::UnaryOp(op, arg))\n-            }\n-            // This is necessary so that the following compiles:\n-            //\n-            // ```\n-            // fn foo<const N: usize>(a: [(); N + 1]) {\n-            //     bar::<{ N + 1 }>();\n-            // }\n-            // ```\n-            ExprKind::Block { block } => {\n-                if let thir::Block { stmts: box [], expr: Some(e), .. } = &self.body.blocks[*block]\n-                {\n-                    self.recurse_build(*e)?\n-                } else {\n-                    self.maybe_supported_error(GenericConstantTooComplexSub::BlockNotSupported(\n-                        node.span,\n-                    ))?\n-                }\n-            }\n-            // `ExprKind::Use` happens when a `hir::ExprKind::Cast` is a\n-            // \"coercion cast\" i.e. using a coercion or is a no-op.\n-            // This is important so that `N as usize as usize` doesnt unify with `N as usize`. (untested)\n-            &ExprKind::Use { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(CastKind::Use, arg, node.ty))\n-            }\n-            &ExprKind::Cast { source } => {\n-                let arg = self.recurse_build(source)?;\n-                self.nodes.push(Node::Cast(CastKind::As, arg, node.ty))\n-            }\n-            ExprKind::Borrow { arg, .. } => {\n-                let arg_node = &self.body.exprs[*arg];\n-\n-                // Skip reborrows for now until we allow Deref/Borrow/AddressOf\n-                // expressions.\n-                // FIXME(generic_const_exprs): Verify/explain why this is sound\n-                if let ExprKind::Deref { arg } = arg_node.kind {\n-                    self.recurse_build(arg)?\n-                } else {\n-                    self.maybe_supported_error(GenericConstantTooComplexSub::BorrowNotSupported(\n-                        node.span,\n-                    ))?\n-                }\n-            }\n-            // FIXME(generic_const_exprs): We may want to support these.\n-            ExprKind::AddressOf { .. } | ExprKind::Deref { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::AddressAndDerefNotSupported(node.span),\n-            )?,\n-            ExprKind::Repeat { .. } | ExprKind::Array { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::ArrayNotSupported(node.span),\n-            )?,\n-            ExprKind::NeverToAny { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::NeverToAnyNotSupported(node.span),\n-            )?,\n-            ExprKind::Tuple { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::TupleNotSupported(node.span),\n-            )?,\n-            ExprKind::Index { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::IndexNotSupported(node.span),\n-            )?,\n-            ExprKind::Field { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::FieldNotSupported(node.span),\n-            )?,\n-            ExprKind::ConstBlock { .. } => self.maybe_supported_error(\n-                GenericConstantTooComplexSub::ConstBlockNotSupported(node.span),\n-            )?,\n-            ExprKind::Adt(_) => self\n-                .maybe_supported_error(GenericConstantTooComplexSub::AdtNotSupported(node.span))?,\n-            // dont know if this is correct\n-            ExprKind::Pointer { .. } => {\n-                self.error(GenericConstantTooComplexSub::PointerNotSupported(node.span))?\n-            }\n-            ExprKind::Yield { .. } => {\n-                self.error(GenericConstantTooComplexSub::YieldNotSupported(node.span))?\n-            }\n-            ExprKind::Continue { .. } | ExprKind::Break { .. } | ExprKind::Loop { .. } => {\n-                self.error(GenericConstantTooComplexSub::LoopNotSupported(node.span))?\n-            }\n-            ExprKind::Box { .. } => {\n-                self.error(GenericConstantTooComplexSub::BoxNotSupported(node.span))?\n-            }\n+impl<'a, 'tcx> visit::Visitor<'a, 'tcx> for IsThirPolymorphic<'a, 'tcx> {\n+    fn thir(&self) -> &'a thir::Thir<'tcx> {\n+        &self.thir\n+    }\n \n-            ExprKind::Unary { .. } => unreachable!(),\n-            // we handle valid unary/binary ops above\n-            ExprKind::Binary { .. } => {\n-                self.error(GenericConstantTooComplexSub::BinaryNotSupported(node.span))?\n-            }\n-            ExprKind::LogicalOp { .. } => {\n-                self.error(GenericConstantTooComplexSub::LogicalOpNotSupported(node.span))?\n-            }\n-            ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n-                self.error(GenericConstantTooComplexSub::AssignNotSupported(node.span))?\n-            }\n-            ExprKind::Closure { .. } | ExprKind::Return { .. } => {\n-                self.error(GenericConstantTooComplexSub::ClosureAndReturnNotSupported(node.span))?\n-            }\n-            // let expressions imply control flow\n-            ExprKind::Match { .. } | ExprKind::If { .. } | ExprKind::Let { .. } => {\n-                self.error(GenericConstantTooComplexSub::ControlFlowNotSupported(node.span))?\n-            }\n-            ExprKind::InlineAsm { .. } => {\n-                self.error(GenericConstantTooComplexSub::InlineAsmNotSupported(node.span))?\n-            }\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_expr(&mut self, expr: &thir::Expr<'tcx>) {\n+        self.is_poly |= self.expr_is_poly(expr);\n+        if !self.is_poly {\n+            visit::walk_expr(self, expr)\n+        }\n+    }\n \n-            // we dont permit let stmts so `VarRef` and `UpvarRef` cant happen\n-            ExprKind::VarRef { .. }\n-            | ExprKind::UpvarRef { .. }\n-            | ExprKind::StaticRef { .. }\n-            | ExprKind::ThreadLocalRef(_) => {\n-                self.error(GenericConstantTooComplexSub::OperationNotSupported(node.span))?\n-            }\n-        })\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn visit_pat(&mut self, pat: &thir::Pat<'tcx>) {\n+        self.is_poly |= self.pat_is_poly(pat);\n+        if !self.is_poly {\n+            visit::walk_pat(self, pat);\n+        }\n     }\n }\n \n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n pub fn thir_abstract_const<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def: ty::WithOptConstParam<LocalDefId>,\n-) -> Result<Option<&'tcx [Node<'tcx>]>, ErrorGuaranteed> {\n+) -> Result<Option<ty::Const<'tcx>>, ErrorGuaranteed> {\n     if tcx.features().generic_const_exprs {\n         match tcx.def_kind(def.did) {\n             // FIXME(generic_const_exprs): We currently only do this for anonymous constants,\n@@ -416,10 +369,17 @@ pub fn thir_abstract_const<'tcx>(\n         }\n \n         let body = tcx.thir_body(def)?;\n+        let (body, body_id) = (&*body.0.borrow(), body.1);\n+\n+        let mut is_poly_vis = IsThirPolymorphic { is_poly: false, thir: body };\n+        visit::walk_expr(&mut is_poly_vis, &body[body_id]);\n+        if !is_poly_vis.is_poly {\n+            return Ok(None);\n+        }\n+\n+        let root_span = body.exprs[body_id].span;\n \n-        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n-            .map(AbstractConstBuilder::build)\n-            .transpose()\n+        Some(recurse_build(tcx, body, body_id, root_span)).transpose()\n     } else {\n         Ok(None)\n     }"}, {"sha": "e8f89cb1aa2ca0b350115161ac48746b1f337852", "filename": "src/test/ui/const-generics/generic_const_exprs/assoc_const_unification/const_equate_assoc_consts.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fconst_equate_assoc_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fconst_equate_assoc_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fconst_equate_assoc_consts.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait Trait {\n+    const ASSOC: usize;\n+}\n+impl<T> Trait for T {\n+    const ASSOC: usize = std::mem::size_of::<T>();\n+}\n+\n+struct Foo<T: Trait>([u8; T::ASSOC])\n+where\n+    [(); T::ASSOC]:;\n+\n+fn bar<T: Trait>()\n+where\n+    [(); T::ASSOC]:,\n+{\n+    let _: Foo<T> = Foo::<_>(make());\n+}\n+\n+fn make() -> ! {\n+    todo!()\n+}\n+\n+fn main() {}"}, {"sha": "c8f7553da7982ef03efcadceaadf78a0199b7377", "filename": "src/test/ui/const-generics/generic_const_exprs/assoc_const_unification/doesnt_unify_evaluatable.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdoesnt_unify_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdoesnt_unify_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdoesnt_unify_evaluatable.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -0,0 +1,15 @@\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait Trait {\n+    const ASSOC: usize;\n+}\n+\n+fn foo<T: Trait, U: Trait>() where [(); U::ASSOC]:, {\n+    bar::<{ T::ASSOC }>();\n+    //~^ ERROR: unconstrained generic constant\n+}\n+\n+fn bar<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "e4a0cabe57284ce657ff907fdf527589a991348d", "filename": "src/test/ui/const-generics/generic_const_exprs/assoc_const_unification/doesnt_unify_evaluatable.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdoesnt_unify_evaluatable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdoesnt_unify_evaluatable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdoesnt_unify_evaluatable.stderr?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -0,0 +1,10 @@\n+error: unconstrained generic constant\n+  --> $DIR/doesnt_unify_evaluatable.rs:9:11\n+   |\n+LL |     bar::<{ T::ASSOC }>();\n+   |           ^^^^^^^^^^^^\n+   |\n+   = help: try adding a `where` bound using this expression: `where [(); { T::ASSOC }]:`\n+\n+error: aborting due to previous error\n+"}, {"sha": "274caa1e99312482039b4d2d76873b4f6c75f6be", "filename": "src/test/ui/const-generics/generic_const_exprs/assoc_const_unification/dropck_unifies_assoc_consts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdropck_unifies_assoc_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdropck_unifies_assoc_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Fdropck_unifies_assoc_consts.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait Trait {\n+    const ASSOC: usize;\n+}\n+\n+struct Foo<T: Trait>(T)\n+where\n+    [(); T::ASSOC]:;\n+\n+impl<T: Trait> Drop for Foo<T>\n+where\n+    [(); T::ASSOC]:,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "6597b9f2b3fe3fa36fcba9420aa09e84bca0c5ba", "filename": "src/test/ui/const-generics/generic_const_exprs/assoc_const_unification/unifies_evaluatable.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Funifies_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Funifies_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fassoc_const_unification%2Funifies_evaluatable.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+trait Trait {\n+    const ASSOC: usize;\n+}\n+\n+fn foo<T: Trait, U: Trait>() where [(); T::ASSOC]:, {\n+    bar::<{ T::ASSOC }>();\n+}\n+\n+fn bar<const N: usize>() -> [(); N] {\n+    [(); N]\n+}\n+\n+fn main() {}"}, {"sha": "39d658be67d402935d318106d61777fe4622a66d", "filename": "src/test/ui/const-generics/invariant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finvariant.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -24,7 +24,8 @@ where\n fn covariant(\n     v: &'static Foo<for<'a> fn(&'a ())>\n ) -> &'static Foo<fn(&'static ())> {\n-    v //~ ERROR mismatched types\n+    v\n+    //~^ ERROR mismatched types\n }\n \n fn main() {"}, {"sha": "d7b2b006c2aeaefdb3944a148e4bf1091084b064", "filename": "src/test/ui/const-generics/issues/issue-83765.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-83765.stderr?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1,15 +1,15 @@\n-error[E0391]: cycle detected when resolving instance `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>::DIM`\n+error[E0391]: cycle detected when resolving instance `<LazyUpdim<'_, T, <T as TensorDimension>::DIM, DIM> as TensorDimension>::DIM`\n   --> $DIR/issue-83765.rs:5:5\n    |\n LL |     const DIM: usize;\n    |     ^^^^^^^^^^^^^^^^\n    |\n-note: ...which requires computing candidate for `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>`...\n+note: ...which requires computing candidate for `<LazyUpdim<'_, T, <T as TensorDimension>::DIM, DIM> as TensorDimension>`...\n   --> $DIR/issue-83765.rs:4:1\n    |\n LL | trait TensorDimension {\n    | ^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which again requires resolving instance `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>::DIM`, completing the cycle\n+   = note: ...which again requires resolving instance `<LazyUpdim<'_, T, <T as TensorDimension>::DIM, DIM> as TensorDimension>::DIM`, completing the cycle\n note: cycle used when computing candidate for `<LazyUpdim<'_, T, { T::DIM }, DIM> as TensorDimension>`\n   --> $DIR/issue-83765.rs:4:1\n    |"}, {"sha": "4908fb29692ccfd211e4ac4bf1a83ee05311fac2", "filename": "src/test/ui/const-generics/issues/issue-85031-2.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.rs?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -1,13 +1,17 @@\n-// revisions: cfail\n+// check-pass\n+// known-bug\n+\n+// This should not compile, as the compiler should not know\n+// `A - 0` is satisfied `?x - 0` if `?x` is inferred to `A`.\n #![allow(incomplete_features)]\n #![feature(generic_const_exprs)]\n \n pub struct Ref<'a>(&'a i32);\n \n impl<'a> Ref<'a> {\n     pub fn foo<const A: usize>() -> [(); A - 0] {\n+        //~^ WARN function cannot\n         Self::foo()\n-        //~^ error: type annotations needed\n     }\n }\n ", "previous_filename": "src/test/incremental/const-generics/try_unify_abstract_const_regression_tests/issue-85031-2.rs"}, {"sha": "fc690576875209fd5c91ecaf96252dc43dfab39f", "filename": "src/test/ui/const-generics/issues/issue-85031-2.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aff003becd8b6bf803202e958623031274ad69c9/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-85031-2.stderr?ref=aff003becd8b6bf803202e958623031274ad69c9", "patch": "@@ -0,0 +1,14 @@\n+warning: function cannot return without recursing\n+  --> $DIR/issue-85031-2.rs:12:5\n+   |\n+LL |     pub fn foo<const A: usize>() -> [(); A - 0] {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+LL |\n+LL |         Self::foo()\n+   |         ----------- recursive call site\n+   |\n+   = help: a `loop` may express intention better if this is on purpose\n+   = note: `#[warn(unconditional_recursion)]` on by default\n+\n+warning: 1 warning emitted\n+"}]}