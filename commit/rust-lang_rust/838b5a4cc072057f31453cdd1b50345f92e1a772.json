{"sha": "838b5a4cc072057f31453cdd1b50345f92e1a772", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzOGI1YTRjYzA3MjA1N2YzMTQ1M2NkZDFiNTAzNDVmOTJlMWE3NzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-26T08:51:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-26T08:51:35Z"}, "message": "auto merge of #11762 : alexcrichton/rust/guard_pages, r=alexcrichton\n\nRebasing of the previous PRs, I believe I've found the problems.", "tree": {"sha": "258378080663b299b5be8b2ac9a3b0cda9ad609a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/258378080663b299b5be8b2ac9a3b0cda9ad609a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/838b5a4cc072057f31453cdd1b50345f92e1a772", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/838b5a4cc072057f31453cdd1b50345f92e1a772", "html_url": "https://github.com/rust-lang/rust/commit/838b5a4cc072057f31453cdd1b50345f92e1a772", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/838b5a4cc072057f31453cdd1b50345f92e1a772/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e36032e9e1aac2ca428f3e17b5524b6c8fe9418c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e36032e9e1aac2ca428f3e17b5524b6c8fe9418c", "html_url": "https://github.com/rust-lang/rust/commit/e36032e9e1aac2ca428f3e17b5524b6c8fe9418c"}, {"sha": "8c43ce6d943e31db4590009960abdf6d74cc02e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c43ce6d943e31db4590009960abdf6d74cc02e4", "html_url": "https://github.com/rust-lang/rust/commit/8c43ce6d943e31db4590009960abdf6d74cc02e4"}], "stats": {"total": 391, "additions": 284, "deletions": 107}, "files": [{"sha": "4e626b3bec77800dbc8f06d188b80759d2b540ca", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -12,10 +12,9 @@ use std::libc::c_void;\n use std::uint;\n use std::cast::{transmute, transmute_mut_unsafe,\n                 transmute_region, transmute_mut_region};\n+use stack::Stack;\n use std::unstable::stack;\n \n-use stack::StackSegment;\n-\n // FIXME #7761: Registers is boxed so that it is 16-byte aligned, for storing\n // SSE regs.  It would be marginally better not to do this. In C++ we\n // use an attribute on a struct.\n@@ -41,7 +40,7 @@ impl Context {\n     }\n \n     /// Create a new context that will resume execution by running proc()\n-    pub fn new(start: proc(), stack: &mut StackSegment) -> Context {\n+    pub fn new(start: proc(), stack: &mut Stack) -> Context {\n         // The C-ABI function that is the task entry point\n         //\n         // Note that this function is a little sketchy. We're taking a\n@@ -79,6 +78,7 @@ impl Context {\n         // be passed to the spawn function.  Another unfortunate\n         // allocation\n         let start = ~start;\n+\n         initialize_call_frame(&mut *regs,\n                               task_start_wrapper as *c_void,\n                               unsafe { transmute(&*start) },"}, {"sha": "c001d40a2465dccb08d65b1e04c370a5afc1edc4", "filename": "src/libgreen/coroutine.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibgreen%2Fcoroutine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibgreen%2Fcoroutine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcoroutine.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -14,7 +14,7 @@\n use std::rt::env;\n \n use context::Context;\n-use stack::{StackPool, StackSegment};\n+use stack::{StackPool, Stack};\n \n /// A coroutine is nothing more than a (register context, stack) pair.\n pub struct Coroutine {\n@@ -24,7 +24,7 @@ pub struct Coroutine {\n     ///\n     /// Servo needs this to be public in order to tell SpiderMonkey\n     /// about the stack bounds.\n-    current_stack_segment: StackSegment,\n+    current_stack_segment: Stack,\n \n     /// Always valid if the task is alive and not running.\n     saved_context: Context\n@@ -39,7 +39,7 @@ impl Coroutine {\n             Some(size) => size,\n             None => env::min_stack()\n         };\n-        let mut stack = stack_pool.take_segment(stack_size);\n+        let mut stack = stack_pool.take_stack(stack_size);\n         let initial_context = Context::new(start, &mut stack);\n         Coroutine {\n             current_stack_segment: stack,\n@@ -49,14 +49,14 @@ impl Coroutine {\n \n     pub fn empty() -> Coroutine {\n         Coroutine {\n-            current_stack_segment: StackSegment::new(0),\n+            current_stack_segment: unsafe { Stack::dummy_stack() },\n             saved_context: Context::empty()\n         }\n     }\n \n     /// Destroy coroutine and try to reuse std::stack segment.\n     pub fn recycle(self, stack_pool: &mut StackPool) {\n         let Coroutine { current_stack_segment, .. } = self;\n-        stack_pool.give_segment(current_stack_segment);\n+        stack_pool.give_stack(current_stack_segment);\n     }\n }"}, {"sha": "bc2c199b83ffdd2626858ae2a415dd60f7e921d8", "filename": "src/libgreen/stack.rs", "status": "modified", "additions": 112, "deletions": 29, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibgreen%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibgreen%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fstack.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -8,46 +8,113 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n-use std::libc::{c_uint, uintptr_t};\n+use std::rt::env::max_cached_stacks;\n+use std::os::{errno, page_size, MemoryMap, MapReadable, MapWritable,\n+              MapNonStandardFlags, MapVirtual};\n+use std::libc;\n \n-pub struct StackSegment {\n-    priv buf: ~[u8],\n-    priv valgrind_id: c_uint\n+/// A task's stack. The name \"Stack\" is a vestige of segmented stacks.\n+pub struct Stack {\n+    priv buf: MemoryMap,\n+    priv min_size: uint,\n+    priv valgrind_id: libc::c_uint,\n }\n \n-impl StackSegment {\n-    pub fn new(size: uint) -> StackSegment {\n-        unsafe {\n-            // Crate a block of uninitialized values\n-            let mut stack = vec::with_capacity(size);\n-            stack.set_len(size);\n+// Try to use MAP_STACK on platforms that support it (it's what we're doing\n+// anyway), but some platforms don't support it at all. For example, it appears\n+// that there's a bug in freebsd that MAP_STACK implies MAP_FIXED (so it always\n+// fails): http://lists.freebsd.org/pipermail/freebsd-bugs/2011-July/044840.html\n+#[cfg(not(windows), not(target_os = \"freebsd\"))]\n+static STACK_FLAGS: libc::c_int = libc::MAP_STACK | libc::MAP_PRIVATE |\n+                                  libc::MAP_ANON;\n+#[cfg(target_os = \"freebsd\")]\n+static STACK_FLAGS: libc::c_int = libc::MAP_PRIVATE | libc::MAP_ANON;\n+#[cfg(windows)]\n+static STACK_FLAGS: libc::c_int = 0;\n \n-            let mut stk = StackSegment {\n-                buf: stack,\n-                valgrind_id: 0\n-            };\n+impl Stack {\n+    /// Allocate a new stack of `size`. If size = 0, this will fail. Use\n+    /// `dummy_stack` if you want a zero-sized stack.\n+    pub fn new(size: uint) -> Stack {\n+        // Map in a stack. Eventually we might be able to handle stack\n+        // allocation failure, which would fail to spawn the task. But there's\n+        // not many sensible things to do on OOM.  Failure seems fine (and is\n+        // what the old stack allocation did).\n+        let stack = match MemoryMap::new(size, [MapReadable, MapWritable,\n+                                         MapNonStandardFlags(STACK_FLAGS)]) {\n+            Ok(map) => map,\n+            Err(e) => fail!(\"mmap for stack of size {} failed: {}\", size, e)\n+        };\n \n-            // XXX: Using the FFI to call a C macro. Slow\n-            stk.valgrind_id = rust_valgrind_stack_register(stk.start(), stk.end());\n-            return stk;\n+        // Change the last page to be inaccessible. This is to provide safety;\n+        // when an FFI function overflows it will (hopefully) hit this guard\n+        // page. It isn't guaranteed, but that's why FFI is unsafe. buf.data is\n+        // guaranteed to be aligned properly.\n+        if !protect_last_page(&stack) {\n+            fail!(\"Could not memory-protect guard page. stack={:?}, errno={}\",\n+                  stack, errno());\n+        }\n+\n+        let mut stk = Stack {\n+            buf: stack,\n+            min_size: size,\n+            valgrind_id: 0\n+        };\n+\n+        // XXX: Using the FFI to call a C macro. Slow\n+        stk.valgrind_id = unsafe {\n+            rust_valgrind_stack_register(stk.start(), stk.end())\n+        };\n+        return stk;\n+    }\n+\n+    /// Create a 0-length stack which starts (and ends) at 0.\n+    pub unsafe fn dummy_stack() -> Stack {\n+        Stack {\n+            buf: MemoryMap { data: 0 as *mut u8, len: 0, kind: MapVirtual },\n+            min_size: 0,\n+            valgrind_id: 0\n         }\n     }\n \n     /// Point to the low end of the allocated stack\n     pub fn start(&self) -> *uint {\n-        self.buf.as_ptr() as *uint\n+        self.buf.data as *uint\n     }\n \n-    /// Point one word beyond the high end of the allocated stack\n+    /// Point one uint beyond the high end of the allocated stack\n     pub fn end(&self) -> *uint {\n         unsafe {\n-            self.buf.as_ptr().offset(self.buf.len() as int) as *uint\n+            self.buf.data.offset(self.buf.len as int) as *uint\n         }\n     }\n }\n \n-impl Drop for StackSegment {\n+#[cfg(unix)]\n+fn protect_last_page(stack: &MemoryMap) -> bool {\n+    unsafe {\n+        // This may seem backwards: the start of the segment is the last page?\n+        // Yes! The stack grows from higher addresses (the end of the allocated\n+        // block) to lower addresses (the start of the allocated block).\n+        let last_page = stack.data as *libc::c_void;\n+        libc::mprotect(last_page, page_size() as libc::size_t,\n+                       libc::PROT_NONE) != -1\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn protect_last_page(stack: &MemoryMap) -> bool {\n+    unsafe {\n+        // see above\n+        let last_page = stack.data as *mut libc::c_void;\n+        let mut old_prot: libc::DWORD = 0;\n+        libc::VirtualProtect(last_page, page_size() as libc::SIZE_T,\n+                             libc::PAGE_NOACCESS,\n+                             &mut old_prot as libc::LPDWORD) != 0\n+    }\n+}\n+\n+impl Drop for Stack {\n     fn drop(&mut self) {\n         unsafe {\n             // XXX: Using the FFI to call a C macro. Slow\n@@ -56,20 +123,36 @@ impl Drop for StackSegment {\n     }\n }\n \n-pub struct StackPool(());\n+pub struct StackPool {\n+    // Ideally this would be some datastructure that preserved ordering on\n+    // Stack.min_size.\n+    priv stacks: ~[Stack],\n+}\n \n impl StackPool {\n-    pub fn new() -> StackPool { StackPool(()) }\n+    pub fn new() -> StackPool {\n+        StackPool {\n+            stacks: ~[],\n+        }\n+    }\n \n-    pub fn take_segment(&self, min_size: uint) -> StackSegment {\n-        StackSegment::new(min_size)\n+    pub fn take_stack(&mut self, min_size: uint) -> Stack {\n+        // Ideally this would be a binary search\n+        match self.stacks.iter().position(|s| s.min_size < min_size) {\n+            Some(idx) => self.stacks.swap_remove(idx),\n+            None      => Stack::new(min_size)\n+        }\n     }\n \n-    pub fn give_segment(&self, _stack: StackSegment) {\n+    pub fn give_stack(&mut self, stack: Stack) {\n+        if self.stacks.len() <= max_cached_stacks() {\n+            self.stacks.push(stack)\n+        }\n     }\n }\n \n extern {\n-    fn rust_valgrind_stack_register(start: *uintptr_t, end: *uintptr_t) -> c_uint;\n-    fn rust_valgrind_stack_deregister(id: c_uint);\n+    fn rust_valgrind_stack_register(start: *libc::uintptr_t,\n+                                    end: *libc::uintptr_t) -> libc::c_uint;\n+    fn rust_valgrind_stack_deregister(id: libc::c_uint);\n }"}, {"sha": "d5f185880fad6e193b30c3df9b30fb16a357e38c", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -2863,6 +2863,7 @@ pub mod consts {\n             pub static MAP_PRIVATE : c_int = 0x0002;\n             pub static MAP_FIXED : c_int = 0x0010;\n             pub static MAP_ANON : c_int = 0x1000;\n+            pub static MAP_STACK : c_int = 0;\n \n             pub static MAP_FAILED : *c_void = -1 as *c_void;\n "}, {"sha": "457d58ae464050f85bd42253435df62836f919cd", "filename": "src/libstd/os.rs", "status": "modified", "additions": 118, "deletions": 66, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -33,13 +33,13 @@ use container::Container;\n #[cfg(target_os = \"macos\")]\n use iter::range;\n use libc;\n-use libc::{c_char, c_void, c_int, size_t};\n+use libc::{c_char, c_void, c_int};\n use option::{Some, None};\n use os;\n use prelude::*;\n use ptr;\n use str;\n-use to_str;\n+use fmt;\n use unstable::finally::Finally;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n \n@@ -59,7 +59,7 @@ pub fn getcwd() -> Path {\n \n     let mut buf = [0 as c_char, ..BUF_BYTES];\n     unsafe {\n-        if libc::getcwd(buf.as_mut_ptr(), buf.len() as size_t).is_null() {\n+        if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n             fail!()\n         }\n         Path::new(CString::new(buf.as_ptr(), false))\n@@ -350,14 +350,16 @@ pub fn self_exe_name() -> Option<Path> {\n             let mib = ~[CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n-            let mut sz: size_t = 0;\n+            let mut sz: libc::size_t = 0;\n             let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                             ptr::mut_null(), &mut sz, ptr::null(), 0u as size_t);\n+                             ptr::mut_null(), &mut sz, ptr::null(),\n+                             0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n             let err = sysctl(mib.as_ptr(), mib.len() as ::libc::c_uint,\n-                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(), 0u as size_t);\n+                             v.as_mut_ptr() as *mut c_void, &mut sz, ptr::null(),\n+                             0u as libc::size_t);\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             v.set_len(sz as uint - 1); // chop off trailing NUL\n@@ -593,12 +595,12 @@ pub fn last_os_error() -> ~str {\n         #[cfg(target_os = \"macos\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n+        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n                       -> c_int {\n             #[nolink]\n             extern {\n-                fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t)\n-                              -> c_int;\n+                fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                              buflen: libc::size_t) -> c_int;\n             }\n             unsafe {\n                 strerror_r(errnum, buf, buflen)\n@@ -609,12 +611,13 @@ pub fn last_os_error() -> ~str {\n         // and requires macros to instead use the POSIX compliant variant.\n         // So we just use __xpg_strerror_r which is always POSIX compliant\n         #[cfg(target_os = \"linux\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: size_t) -> c_int {\n+        fn strerror_r(errnum: c_int, buf: *mut c_char,\n+                      buflen: libc::size_t) -> c_int {\n             #[nolink]\n             extern {\n                 fn __xpg_strerror_r(errnum: c_int,\n                                     buf: *mut c_char,\n-                                    buflen: size_t)\n+                                    buflen: libc::size_t)\n                                     -> c_int;\n             }\n             unsafe {\n@@ -626,7 +629,7 @@ pub fn last_os_error() -> ~str {\n \n         let p = buf.as_mut_ptr();\n         unsafe {\n-            if strerror_r(errno() as c_int, p, buf.len() as size_t) < 0 {\n+            if strerror_r(errno() as c_int, p, buf.len() as libc::size_t) < 0 {\n                 fail!(\"strerror_r failure\");\n             }\n \n@@ -829,13 +832,14 @@ pub fn page_size() -> uint {\n     }\n }\n \n-/// A memory mapped file or chunk of memory. This is a very system-specific interface to the OS's\n-/// memory mapping facilities (`mmap` on POSIX, `VirtualAlloc`/`CreateFileMapping` on win32). It\n-/// makes no attempt at abstracting platform differences, besides in error values returned. Consider\n+/// A memory mapped file or chunk of memory. This is a very system-specific\n+/// interface to the OS's memory mapping facilities (`mmap` on POSIX,\n+/// `VirtualAlloc`/`CreateFileMapping` on win32). It makes no attempt at\n+/// abstracting platform differences, besides in error values returned. Consider\n /// yourself warned.\n ///\n-/// The memory map is released (unmapped) when the destructor is run, so don't let it leave scope by\n-/// accident if you want it to stick around.\n+/// The memory map is released (unmapped) when the destructor is run, so don't\n+/// let it leave scope by accident if you want it to stick around.\n pub struct MemoryMap {\n     /// Pointer to the memory created or modified by this map.\n     data: *mut u8,\n@@ -847,11 +851,12 @@ pub struct MemoryMap {\n \n /// Type of memory map\n pub enum MemoryMapKind {\n-    /// Memory-mapped file. On Windows, the inner pointer is a handle to the mapping, and\n-    /// corresponds to `CreateFileMapping`. Elsewhere, it is null.\n+    /// Virtual memory map. Usually used to change the permissions of a given\n+    /// chunk of memory.  Corresponds to `VirtualAlloc` on Windows.\n     MapFile(*u8),\n-    /// Virtual memory map. Usually used to change the permissions of a given chunk of memory.\n-    /// Corresponds to `VirtualAlloc` on Windows.\n+    /// Virtual memory map. Usually used to change the permissions of a given\n+    /// chunk of memory, or for allocation. Corresponds to `VirtualAlloc` on\n+    /// Windows.\n     MapVirtual\n }\n \n@@ -863,81 +868,119 @@ pub enum MapOption {\n     MapWritable,\n     /// The memory should be executable\n     MapExecutable,\n-    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on POSIX.\n+    /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on\n+    /// POSIX.\n     MapAddr(*u8),\n     /// Create a memory mapping for a file with a given fd.\n     MapFd(c_int),\n-    /// When using `MapFd`, the start of the map is `uint` bytes from the start of the file.\n-    MapOffset(uint)\n+    /// When using `MapFd`, the start of the map is `uint` bytes from the start\n+    /// of the file.\n+    MapOffset(uint),\n+    /// On POSIX, this can be used to specify the default flags passed to\n+    /// `mmap`. By default it uses `MAP_PRIVATE` and, if not using `MapFd`,\n+    /// `MAP_ANON`. This will override both of those. This is platform-specific\n+    /// (the exact values used) and ignored on Windows.\n+    MapNonStandardFlags(c_int),\n }\n \n /// Possible errors when creating a map.\n pub enum MapError {\n     /// ## The following are POSIX-specific\n     ///\n-    /// fd was not open for reading or, if using `MapWritable`, was not open for writing.\n+    /// fd was not open for reading or, if using `MapWritable`, was not open for\n+    /// writing.\n     ErrFdNotAvail,\n     /// fd was not valid\n     ErrInvalidFd,\n-    /// Either the address given by `MapAddr` or offset given by `MapOffset` was not a multiple of\n-    /// `MemoryMap::granularity` (unaligned to page size).\n+    /// Either the address given by `MapAddr` or offset given by `MapOffset` was\n+    /// not a multiple of `MemoryMap::granularity` (unaligned to page size).\n     ErrUnaligned,\n     /// With `MapFd`, the fd does not support mapping.\n     ErrNoMapSupport,\n-    /// If using `MapAddr`, the address + `min_len` was outside of the process's address space. If\n-    /// using `MapFd`, the target of the fd didn't have enough resources to fulfill the request.\n+    /// If using `MapAddr`, the address + `min_len` was outside of the process's\n+    /// address space. If using `MapFd`, the target of the fd didn't have enough\n+    /// resources to fulfill the request.\n     ErrNoMem,\n+    /// A zero-length map was requested. This is invalid according to\n+    /// [POSIX](http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html).\n+    /// Not all platforms obey this, but this wrapper does.\n+    ErrZeroLength,\n     /// Unrecognized error. The inner value is the unrecognized errno.\n     ErrUnknown(int),\n     /// ## The following are win32-specific\n     ///\n-    /// Unsupported combination of protection flags (`MapReadable`/`MapWritable`/`MapExecutable`).\n+    /// Unsupported combination of protection flags\n+    /// (`MapReadable`/`MapWritable`/`MapExecutable`).\n     ErrUnsupProt,\n-    /// When using `MapFd`, `MapOffset` was given (Windows does not support this at all)\n+    /// When using `MapFd`, `MapOffset` was given (Windows does not support this\n+    /// at all)\n     ErrUnsupOffset,\n     /// When using `MapFd`, there was already a mapping to the file.\n     ErrAlreadyExists,\n-    /// Unrecognized error from `VirtualAlloc`. The inner value is the return value of GetLastError.\n+    /// Unrecognized error from `VirtualAlloc`. The inner value is the return\n+    /// value of GetLastError.\n     ErrVirtualAlloc(uint),\n-    /// Unrecognized error from `CreateFileMapping`. The inner value is the return value of\n-    /// `GetLastError`.\n+    /// Unrecognized error from `CreateFileMapping`. The inner value is the\n+    /// return value of `GetLastError`.\n     ErrCreateFileMappingW(uint),\n-    /// Unrecognized error from `MapViewOfFile`. The inner value is the return value of\n-    /// `GetLastError`.\n+    /// Unrecognized error from `MapViewOfFile`. The inner value is the return\n+    /// value of `GetLastError`.\n     ErrMapViewOfFile(uint)\n }\n \n-impl to_str::ToStr for MapError {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ErrFdNotAvail => ~\"fd not available for reading or writing\",\n-            ErrInvalidFd => ~\"Invalid fd\",\n-            ErrUnaligned => ~\"Unaligned address, invalid flags, \\\n-                              negative length or unaligned offset\",\n-            ErrNoMapSupport=> ~\"File doesn't support mapping\",\n-            ErrNoMem => ~\"Invalid address, or not enough available memory\",\n-            ErrUnknown(code) => format!(\"Unknown error={}\", code),\n-            ErrUnsupProt => ~\"Protection mode unsupported\",\n-            ErrUnsupOffset => ~\"Offset in virtual memory mode is unsupported\",\n-            ErrAlreadyExists => ~\"File mapping for specified file already exists\",\n-            ErrVirtualAlloc(code) => format!(\"VirtualAlloc failure={}\", code),\n-            ErrCreateFileMappingW(code) => format!(\"CreateFileMappingW failure={}\", code),\n-            ErrMapViewOfFile(code) => format!(\"MapViewOfFile failure={}\", code)\n-        }\n+impl fmt::Default for MapError {\n+    fn fmt(val: &MapError, out: &mut fmt::Formatter) {\n+        let str = match *val {\n+            ErrFdNotAvail => \"fd not available for reading or writing\",\n+            ErrInvalidFd => \"Invalid fd\",\n+            ErrUnaligned => {\n+                \"Unaligned address, invalid flags, negative length or \\\n+                 unaligned offset\"\n+            }\n+            ErrNoMapSupport=> \"File doesn't support mapping\",\n+            ErrNoMem => \"Invalid address, or not enough available memory\",\n+            ErrUnsupProt => \"Protection mode unsupported\",\n+            ErrUnsupOffset => \"Offset in virtual memory mode is unsupported\",\n+            ErrAlreadyExists => \"File mapping for specified file already exists\",\n+            ErrZeroLength => \"Zero-length mapping not allowed\",\n+            ErrUnknown(code) => {\n+                write!(out.buf, \"Unknown error = {}\", code);\n+                return\n+            },\n+            ErrVirtualAlloc(code) => {\n+                write!(out.buf, \"VirtualAlloc failure = {}\", code);\n+                return\n+            },\n+            ErrCreateFileMappingW(code) => {\n+                format!(\"CreateFileMappingW failure = {}\", code);\n+                return\n+            },\n+            ErrMapViewOfFile(code) => {\n+                write!(out.buf, \"MapViewOfFile failure = {}\", code);\n+                return\n+            }\n+        };\n+        write!(out.buf, \"{}\", str);\n     }\n }\n \n #[cfg(unix)]\n impl MemoryMap {\n-    /// Create a new mapping with the given `options`, at least `min_len` bytes long.\n+    /// Create a new mapping with the given `options`, at least `min_len` bytes\n+    /// long. `min_len` must be greater than zero; see the note on\n+    /// `ErrZeroLength`.\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::off_t;\n \n+        if min_len == 0 {\n+            return Err(ErrZeroLength)\n+        }\n         let mut addr: *u8 = ptr::null();\n         let mut prot = 0;\n         let mut flags = libc::MAP_PRIVATE;\n         let mut fd = -1;\n         let mut offset = 0;\n+        let mut custom_flags = false;\n         let len = round_up(min_len, page_size());\n \n         for &o in options.iter() {\n@@ -953,13 +996,15 @@ impl MemoryMap {\n                     flags |= libc::MAP_FILE;\n                     fd = fd_;\n                 },\n-                MapOffset(offset_) => { offset = offset_ as off_t; }\n+                MapOffset(offset_) => { offset = offset_ as off_t; },\n+                MapNonStandardFlags(f) => { custom_flags = true; flags = f },\n             }\n         }\n-        if fd == -1 { flags |= libc::MAP_ANON; }\n+        if fd == -1 && !custom_flags { flags |= libc::MAP_ANON; }\n \n         let r = unsafe {\n-            libc::mmap(addr as *c_void, len as size_t, prot, flags, fd, offset)\n+            libc::mmap(addr as *c_void, len as libc::size_t, prot, flags, fd,\n+                       offset)\n         };\n         if r.equiv(&libc::MAP_FAILED) {\n             Err(match errno() as c_int {\n@@ -983,7 +1028,8 @@ impl MemoryMap {\n         }\n     }\n \n-    /// Granularity that the offset or address must be for `MapOffset` and `MapAddr` respectively.\n+    /// Granularity that the offset or address must be for `MapOffset` and\n+    /// `MapAddr` respectively.\n     pub fn granularity() -> uint {\n         page_size()\n     }\n@@ -993,6 +1039,8 @@ impl MemoryMap {\n impl Drop for MemoryMap {\n     /// Unmap the mapping. Fails the task if `munmap` fails.\n     fn drop(&mut self) {\n+        if self.len == 0 { /* workaround for dummy_stack */ return; }\n+\n         unsafe {\n             match libc::munmap(self.data as *c_void, self.len as libc::size_t) {\n                 0 => (),\n@@ -1027,7 +1075,11 @@ impl MemoryMap {\n                 MapExecutable => { executable = true; }\n                 MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n                 MapFd(fd_) => { fd = fd_; },\n-                MapOffset(offset_) => { offset = offset_; }\n+                MapOffset(offset_) => { offset = offset_; },\n+                MapNonStandardFlags(f) => {\n+                    info!(\"MemoryMap::new: MapNonStandardFlags used on \\\n+                           Windows: {}\", f)\n+                }\n             }\n         }\n \n@@ -1113,18 +1165,18 @@ impl MemoryMap {\n \n #[cfg(windows)]\n impl Drop for MemoryMap {\n-    /// Unmap the mapping. Fails the task if any of `VirtualFree`, `UnmapViewOfFile`, or\n-    /// `CloseHandle` fail.\n+    /// Unmap the mapping. Fails the task if any of `VirtualFree`,\n+    /// `UnmapViewOfFile`, or `CloseHandle` fail.\n     fn drop(&mut self) {\n         use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n         use libc::consts::os::extra::FALSE;\n+        if self.len == 0 { return }\n \n         unsafe {\n             match self.kind {\n                 MapVirtual => {\n-                    if libc::VirtualFree(self.data as *mut c_void,\n-                                         self.len as size_t,\n-                                         libc::MEM_RELEASE) == FALSE {\n+                    if libc::VirtualFree(self.data as *mut c_void, 0,\n+                                         libc::MEM_RELEASE) == 0 {\n                         error!(\"VirtualFree failed: {}\", errno());\n                     }\n                 },\n@@ -1429,7 +1481,7 @@ mod tests {\n             os::MapWritable\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(msg.to_str())\n+            Err(msg) => fail!(\"{}\", msg)\n         };\n         assert!(chunk.len >= 16);\n \n@@ -1479,7 +1531,7 @@ mod tests {\n             MapOffset(size / 2)\n         ]) {\n             Ok(chunk) => chunk,\n-            Err(msg) => fail!(msg.to_str())\n+            Err(msg) => fail!(\"{}\", msg)\n         };\n         assert!(chunk.len > 0);\n "}, {"sha": "729e377e1af31797ad4fbae8418f6e7dc18fe5f4", "filename": "src/libstd/rt/env.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibstd%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Flibstd%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fenv.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -10,26 +10,33 @@\n \n //! Runtime environment settings\n \n-use from_str::FromStr;\n+use from_str::from_str;\n use option::{Some, None};\n use os;\n \n // Note that these are all accessed without any synchronization.\n // They are expected to be initialized once then left alone.\n \n static mut MIN_STACK: uint = 2 * 1024 * 1024;\n+/// This default corresponds to 20M of cache per scheduler (at the default size).\n+static mut MAX_CACHED_STACKS: uint = 10;\n static mut DEBUG_BORROW: bool = false;\n static mut POISON_ON_FREE: bool = false;\n \n pub fn init() {\n     unsafe {\n         match os::getenv(\"RUST_MIN_STACK\") {\n-            Some(s) => match FromStr::from_str(s) {\n+            Some(s) => match from_str(s) {\n                 Some(i) => MIN_STACK = i,\n                 None => ()\n             },\n             None => ()\n         }\n+        match os::getenv(\"RUST_MAX_CACHED_STACKS\") {\n+            Some(max) => MAX_CACHED_STACKS = from_str(max).expect(\"expected positive integer in \\\n+                                                                   RUST_MAX_CACHED_STACKS\"),\n+            None => ()\n+        }\n         match os::getenv(\"RUST_DEBUG_BORROW\") {\n             Some(_) => DEBUG_BORROW = true,\n             None => ()\n@@ -45,6 +52,10 @@ pub fn min_stack() -> uint {\n     unsafe { MIN_STACK }\n }\n \n+pub fn max_cached_stacks() -> uint {\n+    unsafe { MAX_CACHED_STACKS }\n+}\n+\n pub fn debug_borrow() -> bool {\n     unsafe { DEBUG_BORROW }\n }"}, {"sha": "900796efe33d37e8dd4ffad8f829cdae0faf2fc9", "filename": "src/test/bench/silly-test-spawn.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Useful smoketest for scheduler performance.\n+fn main() {\n+    for _ in range(1, 100_000) {\n+        do spawn { }\n+    }\n+}"}, {"sha": "75485a7fb9ecb12a1fdfe10515058b2ea380f000", "filename": "src/test/bench/spawnone.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Ftest%2Fbench%2Fspawnone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Ftest%2Fbench%2Fspawnone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fspawnone.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Useful for checking syscall usage of baseline scheduler usage\n+fn main() {\n+    do spawn { }\n+}"}, {"sha": "e9a9ed194749d5d770bf4755c5b83b7de2c671d2", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/838b5a4cc072057f31453cdd1b50345f92e1a772/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=838b5a4cc072057f31453cdd1b50345f92e1a772", "patch": "@@ -56,7 +56,7 @@ fn main() {\n         args\n     };\n \n-    let children = from_str::<uint>(args[1]).get();\n+    let children = from_str::<uint>(args[1]).unwrap();\n     let (wait_port, wait_chan) = stream();\n     do task::spawn {\n         calc(children, &wait_chan);\n@@ -66,5 +66,5 @@ fn main() {\n     let (sum_port, sum_chan) = stream::<int>();\n     start_chan.send(sum_chan);\n     let sum = sum_port.recv();\n-    error!(\"How many tasks? %d tasks.\", sum);\n+    error!(\"How many tasks? {} tasks.\", sum);\n }"}]}