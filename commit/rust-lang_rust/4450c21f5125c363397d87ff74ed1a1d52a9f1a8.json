{"sha": "4450c21f5125c363397d87ff74ed1a1d52a9f1a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NTBjMjFmNTEyNWMzNjMzOTdkODdmZjc0ZWQxYTFkNTJhOWYxYTg=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-01T18:14:52Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-16T16:10:31Z"}, "message": "Keep track of spans in format strings", "tree": {"sha": "544db390e539e80a38bb46bdd702014eefeade14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/544db390e539e80a38bb46bdd702014eefeade14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4450c21f5125c363397d87ff74ed1a1d52a9f1a8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmBQ2H4ACgkQ2lnoZDo37QaCWQEAqwIr3l7icU7VpcbDGSzQcB/Y\ns1ygpAw/6IAliVtmIpgBAJJHdIZSqG9D3XAOY/LnaKvdOYYgNx8ckrLaczdZZUoG\n=oDSi\n-----END PGP SIGNATURE-----", "payload": "tree 544db390e539e80a38bb46bdd702014eefeade14\nparent 5b3e61d62fef8a486bf42bf80b450c116189f3ef\nauthor Jason Newcomb <jsnewcomb@pm.me> 1614622492 -0500\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1615911031 -0400\n\nKeep track of spans in format strings\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4450c21f5125c363397d87ff74ed1a1d52a9f1a8", "html_url": "https://github.com/rust-lang/rust/commit/4450c21f5125c363397d87ff74ed1a1d52a9f1a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4450c21f5125c363397d87ff74ed1a1d52a9f1a8/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b3e61d62fef8a486bf42bf80b450c116189f3ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b3e61d62fef8a486bf42bf80b450c116189f3ef", "html_url": "https://github.com/rust-lang/rust/commit/5b3e61d62fef8a486bf42bf80b450c116189f3ef"}], "stats": {"total": 238, "additions": 148, "deletions": 90}, "files": [{"sha": "b5470c3bc70407b50135f87f5efb2c1450f5d23b", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 148, "deletions": 90, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/4450c21f5125c363397d87ff74ed1a1d52a9f1a8/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4450c21f5125c363397d87ff74ed1a1d52a9f1a8/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=4450c21f5125c363397d87ff74ed1a1d52a9f1a8", "patch": "@@ -2,18 +2,18 @@ use std::borrow::Cow;\n use std::ops::Range;\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet_with_applicability;\n-use if_chain::if_chain;\n-use rustc_ast::ast::{Expr, ExprKind, ImplKind, Item, ItemKind, LitKind, MacCall, StrLit, StrStyle};\n+use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n+use rustc_ast::ast::{Expr, ExprKind, ImplKind, Item, ItemKind, LitKind, MacCall, Path, StrLit, StrStyle};\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_errors::Applicability;\n use rustc_lexer::unescape::{self, EscapeError};\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_parse::parser;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::kw;\n-use rustc_span::{sym, BytePos, Span};\n+use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::{sym, BytePos, Span, DUMMY_SP};\n+use smallvec::SmallVec;\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `println!(\"\")` to\n@@ -354,7 +354,117 @@ fn newline_span(fmtstr: &StrLit) -> Span {\n     sp.with_lo(newline_sp_hi - newline_sp_len).with_hi(newline_sp_hi)\n }\n \n+/// Stores a list of replacement spans for each argument, but only if all the replacements used an\n+/// empty format string.\n+#[derive(Default)]\n+struct SimpleFormatArgs {\n+    unnamed: Vec<SmallVec<[Span; 1]>>,\n+    named: Vec<(Symbol, SmallVec<[Span; 1]>)>,\n+}\n+impl SimpleFormatArgs {\n+    fn get_unnamed(&self) -> impl Iterator<Item = &[Span]> {\n+        self.unnamed.iter().map(|x| match x.as_slice() {\n+            // Ignore the dummy span added from out of order format arguments.\n+            [DUMMY_SP] => &[],\n+            x => x,\n+        })\n+    }\n+\n+    fn get_named(&self, n: &Path) -> &[Span] {\n+        self.named.iter().find(|x| *n == x.0).map_or(&[], |x| x.1.as_slice())\n+    }\n+\n+    fn push(&mut self, arg: rustc_parse_format::Argument<'_>, span: Span) {\n+        use rustc_parse_format::{\n+            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec,\n+        };\n+\n+        const SIMPLE: FormatSpec<'_> = FormatSpec {\n+            fill: None,\n+            align: AlignUnknown,\n+            flags: 0,\n+            precision: CountImplied,\n+            precision_span: None,\n+            width: CountImplied,\n+            width_span: None,\n+            ty: \"\",\n+            ty_span: None,\n+        };\n+\n+        match arg.position {\n+            ArgumentIs(n) | ArgumentImplicitlyIs(n) => {\n+                if self.unnamed.len() <= n {\n+                    // Use a dummy span to mark all unseen arguments.\n+                    self.unnamed.resize_with(n, || SmallVec::from([DUMMY_SP]));\n+                    if arg.format == SIMPLE {\n+                        self.unnamed.push(SmallVec::from([span]));\n+                    } else {\n+                        self.unnamed.push(SmallVec::new());\n+                    }\n+                } else {\n+                    let args = &mut self.unnamed[n];\n+                    match (args.as_mut_slice(), arg.format == SIMPLE) {\n+                        // A non-empty format string has been seen already.\n+                        ([], _) => (),\n+                        // Replace the dummy span, if it exists.\n+                        ([dummy @ DUMMY_SP], true) => *dummy = span,\n+                        ([_, ..], true) => args.push(span),\n+                        ([_, ..], false) => *args = SmallVec::new(),\n+                    }\n+                }\n+            },\n+            ArgumentNamed(n) => {\n+                if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n+                    match x.1.as_slice() {\n+                        // A non-empty format string has been seen already.\n+                        [] => (),\n+                        [_, ..] if arg.format == SIMPLE => x.1.push(span),\n+                        [_, ..] => x.1 = SmallVec::new(),\n+                    }\n+                } else if arg.format == SIMPLE {\n+                    self.named.push((n, SmallVec::from([span])));\n+                } else {\n+                    self.named.push((n, SmallVec::new()));\n+                }\n+            },\n+        };\n+    }\n+}\n+\n impl Write {\n+    /// Parses a format string into a collection of spans for each argument. This only keeps track\n+    /// of empty format arguments. Will also lint usages of debug format strings outside of debug\n+    /// impls.\n+    fn parse_fmt_string(&self, cx: &EarlyContext<'_>, str: &StrLit) -> Option<SimpleFormatArgs> {\n+        use rustc_parse_format::{ParseMode, Parser, Piece};\n+\n+        let str_sym = str.symbol.as_str();\n+        let style = match str.style {\n+            StrStyle::Cooked => None,\n+            StrStyle::Raw(n) => Some(n as usize),\n+        };\n+\n+        let mut parser = Parser::new(&str_sym, style, snippet_opt(cx, str.span), false, ParseMode::Format);\n+        let mut args = SimpleFormatArgs::default();\n+\n+        while let Some(arg) = parser.next() {\n+            let arg = match arg {\n+                Piece::String(_) => continue,\n+                Piece::NextArgument(arg) => arg,\n+            };\n+            let span = parser.arg_places.last().map_or(DUMMY_SP, |&x| str.span.from_inner(x));\n+\n+            if !self.in_debug_impl && arg.format.ty == \"?\" {\n+                // FIXME: modify rustc's fmt string parser to give us the current span\n+                span_lint(cx, USE_DEBUG, str.span, \"use of `Debug`-based formatting\");\n+            }\n+\n+            args.push(arg, span);\n+        }\n+\n+        parser.errors.is_empty().then(move || args)\n+    }\n+\n     /// Checks the arguments of `print[ln]!` and `write[ln]!` calls. It will return a tuple of two\n     /// `Option`s. The first `Option` of the tuple is the macro's format string. It includes\n     /// the contents of the string, whether it's a raw string, and the span of the literal in the\n@@ -376,57 +486,31 @@ impl Write {\n     /// ```\n     #[allow(clippy::too_many_lines)]\n     fn check_tts<'a>(&self, cx: &EarlyContext<'a>, tts: TokenStream, is_write: bool) -> (Option<StrLit>, Option<Expr>) {\n-        use rustc_parse_format::{\n-            AlignUnknown, ArgumentImplicitlyIs, ArgumentIs, ArgumentNamed, CountImplied, FormatSpec, ParseMode, Parser,\n-            Piece,\n-        };\n-\n         let mut parser = parser::Parser::new(&cx.sess.parse_sess, tts, false, None);\n-        let mut expr: Option<Expr> = None;\n-        if is_write {\n-            expr = match parser.parse_expr().map_err(|mut err| err.cancel()) {\n-                Ok(p) => Some(p.into_inner()),\n-                Err(_) => return (None, None),\n-            };\n-            // might be `writeln!(foo)`\n-            if parser.expect(&token::Comma).map_err(|mut err| err.cancel()).is_err() {\n-                return (None, expr);\n+        let expr = if is_write {\n+            match parser.parse_expr().map(|e| e.into_inner()).map_err(|mut e| e.cancel()) {\n+                // write!(e, ...)\n+                Ok(p) if parser.eat(&token::Comma) => Some(p),\n+                // write!(e) or error\n+                e => return (None, e.ok()),\n             }\n-        }\n+        } else {\n+            None\n+        };\n \n         let fmtstr = match parser.parse_str_lit() {\n             Ok(fmtstr) => fmtstr,\n             Err(_) => return (None, expr),\n         };\n-        let tmp = fmtstr.symbol.as_str();\n-        let mut args = vec![];\n-        let mut fmt_parser = Parser::new(&tmp, None, None, false, ParseMode::Format);\n-        while let Some(piece) = fmt_parser.next() {\n-            if !fmt_parser.errors.is_empty() {\n-                return (None, expr);\n-            }\n-            if let Piece::NextArgument(arg) = piece {\n-                if !self.in_debug_impl && arg.format.ty == \"?\" {\n-                    // FIXME: modify rustc's fmt string parser to give us the current span\n-                    span_lint(cx, USE_DEBUG, parser.prev_token.span, \"use of `Debug`-based formatting\");\n-                }\n-                args.push(arg);\n-            }\n-        }\n+\n+        let args = match self.parse_fmt_string(cx, &fmtstr) {\n+            Some(args) => args,\n+            None => return (Some(fmtstr), expr),\n+        };\n+\n         let lint = if is_write { WRITE_LITERAL } else { PRINT_LITERAL };\n-        let mut idx = 0;\n+        let mut unnamed_args = args.get_unnamed();\n         loop {\n-            const SIMPLE: FormatSpec<'_> = FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                precision_span: None,\n-                width: CountImplied,\n-                width_span: None,\n-                ty: \"\",\n-                ty_span: None,\n-            };\n             if !parser.eat(&token::Comma) {\n                 return (Some(fmtstr), expr);\n             }\n@@ -435,52 +519,26 @@ impl Write {\n             } else {\n                 return (Some(fmtstr), None);\n             };\n-            match &token_expr.kind {\n+            let (fmt_spans, span) = match &token_expr.kind {\n                 ExprKind::Lit(lit) if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..)) => {\n-                    let mut all_simple = true;\n-                    let mut seen = false;\n-                    for arg in &args {\n-                        match arg.position {\n-                            ArgumentImplicitlyIs(n) | ArgumentIs(n) => {\n-                                if n == idx {\n-                                    all_simple &= arg.format == SIMPLE;\n-                                    seen = true;\n-                                }\n-                            },\n-                            ArgumentNamed(_) => {},\n-                        }\n-                    }\n-                    if all_simple && seen {\n-                        span_lint(cx, lint, token_expr.span, \"literal with an empty format string\");\n-                    }\n-                    idx += 1;\n+                    (unnamed_args.next().unwrap_or(&[]), token_expr.span)\n                 },\n-                ExprKind::Assign(lhs, rhs, _) => {\n-                    if_chain! {\n-                        if let ExprKind::Lit(ref lit) = rhs.kind;\n-                        if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..));\n-                        if let ExprKind::Path(_, p) = &lhs.kind;\n-                        then {\n-                            let mut all_simple = true;\n-                            let mut seen = false;\n-                            for arg in &args {\n-                                match arg.position {\n-                                    ArgumentImplicitlyIs(_) | ArgumentIs(_) => {},\n-                                    ArgumentNamed(name) => {\n-                                        if *p == name {\n-                                            seen = true;\n-                                            all_simple &= arg.format == SIMPLE;\n-                                        }\n-                                    },\n-                                }\n-                            }\n-                            if all_simple && seen {\n-                                span_lint(cx, lint, rhs.span, \"literal with an empty format string\");\n-                            }\n-                        }\n-                    }\n+                ExprKind::Assign(lhs, rhs, _) => match (&lhs.kind, &rhs.kind) {\n+                    (ExprKind::Path(_, p), ExprKind::Lit(lit))\n+                        if !matches!(lit.kind, LitKind::Int(..) | LitKind::Float(..)) =>\n+                    {\n+                        (args.get_named(p), rhs.span)\n+                    },\n+                    _ => continue,\n                 },\n-                _ => idx += 1,\n+                _ => {\n+                    unnamed_args.next();\n+                    continue;\n+                },\n+            };\n+\n+            if !fmt_spans.is_empty() {\n+                span_lint(cx, lint, span, \"literal with an empty format string\");\n             }\n         }\n     }"}]}