{"sha": "6df54c47a7ac0a0788d68c12198f1369b559b93e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZjU0YzQ3YTdhYzBhMDc4OGQ2OGMxMjE5OGYxMzY5YjU1OWI5M2U=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-03T10:11:24Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-10-03T10:11:24Z"}, "message": "Use read_scalar_at_offset in futex_wait instead of memory.get_raw.", "tree": {"sha": "508a723080f089431853af52c930285f4e1ebaa5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/508a723080f089431853af52c930285f4e1ebaa5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6df54c47a7ac0a0788d68c12198f1369b559b93e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6df54c47a7ac0a0788d68c12198f1369b559b93e", "html_url": "https://github.com/rust-lang/rust/commit/6df54c47a7ac0a0788d68c12198f1369b559b93e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6df54c47a7ac0a0788d68c12198f1369b559b93e/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5880e7d809d20246ce160710ebf7160e4d0c56c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5880e7d809d20246ce160710ebf7160e4d0c56c1", "html_url": "https://github.com/rust-lang/rust/commit/5880e7d809d20246ce160710ebf7160e4d0c56c1"}], "stats": {"total": 29, "additions": 14, "deletions": 15}, "files": [{"sha": "cc09b33ba68426fba55d9b0fecb145a29c54b465", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6df54c47a7ac0a0788d68c12198f1369b559b93e/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6df54c47a7ac0a0788d68c12198f1369b559b93e/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=6df54c47a7ac0a0788d68c12198f1369b559b93e", "patch": "@@ -24,17 +24,14 @@ pub fn futex<'tcx>(\n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    //\n-    // `addr` is used to identify the mutex, but note that not all futex\n-    // operations actually read from this addres or even require this address\n-    // to exist. Also, the type of `addr` is not consistent. The API requires\n-    // it to be a 4-byte aligned pointer, and will use the 4 bytes at the given\n-    // address as an (atomic) i32. It's not uncommon for `addr` to be passed as\n-    // another type than `*mut i32`, such as `*const AtomicI32`.\n-    let addr = this.force_ptr(this.read_scalar(args[1])?.check_init()?)?;\n+    let addr = this.read_immediate(args[1])?;\n     let op = this.read_scalar(args[2])?.to_i32()?;\n     let val = this.read_scalar(args[3])?.to_i32()?;\n \n+    // The raw pointer value is used to identify the mutex.\n+    // Not all mutex operations actually read from this address or even require this address to exist.\n+    let futex_ptr = this.force_ptr(addr.to_scalar()?)?;\n+\n     let thread = this.get_active_thread();\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n@@ -73,14 +70,16 @@ pub fn futex<'tcx>(\n                 })\n             };\n             // Check the pointer for alignment and validity.\n-            // Atomic operations are only available for fully aligned values.\n-            this.memory.check_ptr_access(addr.into(), Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n-            // Read an `i32` through the pointer, regardless of any wrapper types (e.g. `AtomicI32`).\n-            let futex_val = this.memory.get_raw(addr.alloc_id)?.read_scalar(this, addr, Size::from_bytes(4))?.to_i32()?;\n+            // The API requires `addr` to be a 4-byte aligned pointer, and will\n+            // use the 4 bytes at the given address as an (atomic) i32.\n+            this.memory.check_ptr_access(addr.to_scalar()?, Size::from_bytes(4), Align::from_bytes(4).unwrap())?;\n+            // Read an `i32` through the pointer, regardless of any wrapper types.\n+            // It's not uncommon for `addr` to be passed as another type than `*mut i32`, such as `*const AtomicI32`.\n+            let futex_val = this.read_scalar_at_offset(addr.into(), 0, this.machine.layouts.i32)?.to_i32()?;\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(addr, thread);\n+                this.futex_wait(futex_ptr, thread);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n@@ -91,7 +90,7 @@ pub fn futex<'tcx>(\n                         timeout_time,\n                         Box::new(move |this| {\n                             this.unblock_thread(thread);\n-                            this.futex_remove_waiter(addr, thread);\n+                            this.futex_remove_waiter(futex_ptr, thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n                             this.set_last_error(etimedout)?;\n                             this.write_scalar(Scalar::from_machine_isize(-1, this), dest)?;\n@@ -114,7 +113,7 @@ pub fn futex<'tcx>(\n         op if op == futex_wake => {\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(addr) {\n+                if let Some(thread) = this.futex_wake(futex_ptr) {\n                     this.unblock_thread(thread);\n                     this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;"}]}