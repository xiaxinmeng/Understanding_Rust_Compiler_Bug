{"sha": "04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0ZjVmZTVhMDg5ODhkMmI4ODI5ZjZhM2NjYzE2YjhkZDE5Njc1Yjg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:29Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-09-19T17:00:29Z"}, "message": "rollup merge of #17338 : nick29581/variants-namespace", "tree": {"sha": "a4f520414bd92e1ed6f2bc939a189116b938e1e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4f520414bd92e1ed6f2bc939a189116b938e1e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "html_url": "https://github.com/rust-lang/rust/commit/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ee3586b5d75497af25e77756be8f629d711aaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/81ee3586b5d75497af25e77756be8f629d711aaf", "html_url": "https://github.com/rust-lang/rust/commit/81ee3586b5d75497af25e77756be8f629d711aaf"}, {"sha": "ce0907e46e8e1aa23ee39f69e4f628f68bfbb0d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce0907e46e8e1aa23ee39f69e4f628f68bfbb0d7", "html_url": "https://github.com/rust-lang/rust/commit/ce0907e46e8e1aa23ee39f69e4f628f68bfbb0d7"}], "stats": {"total": 946, "additions": 489, "deletions": 457}, "files": [{"sha": "a12d403603fe89df557ff4b063a40d266490cde3", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -872,7 +872,7 @@ mod tests {\n \n     use {Mutable, MutableSeq};\n     use str;\n-    use str::{Str, StrSlice, Owned, Slice};\n+    use str::{Str, StrSlice, Owned};\n     use super::String;\n     use vec::Vec;\n \n@@ -898,10 +898,10 @@ mod tests {\n     #[test]\n     fn test_from_utf8_lossy() {\n         let xs = b\"hello\";\n-        assert_eq!(String::from_utf8_lossy(xs), Slice(\"hello\"));\n+        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"hello\"));\n \n         let xs = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes();\n-        assert_eq!(String::from_utf8_lossy(xs), Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n+        assert_eq!(String::from_utf8_lossy(xs), str::Slice(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\"));\n \n         let xs = b\"Hello\\xC2 There\\xFF Goodbye\";\n         assert_eq!(String::from_utf8_lossy(xs),"}, {"sha": "a9f34e1195ce622ec57f0ad52006130c785e4032", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -23,6 +23,7 @@\n \n use std::char;\n use std::str;\n+use std::string;\n \n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n@@ -32,7 +33,7 @@ pub enum Piece<'a> {\n     String(&'a str),\n     /// This describes that formatting should process the next argument (as\n     /// specified inside) for emission.\n-    Argument(Argument<'a>),\n+    NextArgument(Argument<'a>),\n }\n \n /// Representation of an argument specification.\n@@ -129,7 +130,7 @@ pub struct Parser<'a> {\n     input: &'a str,\n     cur: str::CharOffsets<'a>,\n     /// Error messages accumulated during parsing\n-    pub errors: Vec<String>,\n+    pub errors: Vec<string::String>,\n }\n \n impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n@@ -140,7 +141,7 @@ impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n                 if self.consume('{') {\n                     Some(String(self.string(pos + 1)))\n                 } else {\n-                    let ret = Some(Argument(self.argument()));\n+                    let ret = Some(NextArgument(self.argument()));\n                     self.must_consume('}');\n                     ret\n                 }\n@@ -469,28 +470,28 @@ mod tests {\n \n     #[test]\n     fn format_nothing() {\n-        same(\"{}\", [Argument(Argument {\n+        same(\"{}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_position() {\n-        same(\"{3}\", [Argument(Argument {\n+        same(\"{3}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n-        same(\"{3:}\", [Argument(Argument {\n+        same(\"{3:}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: fmtdflt(),\n         })]);\n     }\n     #[test]\n     fn format_type() {\n-        same(\"{3:a}\", [Argument(Argument {\n+        same(\"{3:a}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -504,7 +505,7 @@ mod tests {\n     }\n     #[test]\n     fn format_align_fill() {\n-        same(\"{3:>}\", [Argument(Argument {\n+        same(\"{3:>}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n@@ -515,7 +516,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{3:0<}\", [Argument(Argument {\n+        same(\"{3:0<}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('0'),\n@@ -526,7 +527,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{3:*<abcd}\", [Argument(Argument {\n+        same(\"{3:*<abcd}\", [NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('*'),\n@@ -540,7 +541,7 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n-        same(\"{:10s}\", [Argument(Argument {\n+        same(\"{:10s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -551,7 +552,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:10$.10s}\", [Argument(Argument {\n+        same(\"{:10$.10s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -562,7 +563,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:.*s}\", [Argument(Argument {\n+        same(\"{:.*s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -573,7 +574,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:.10$s}\", [Argument(Argument {\n+        same(\"{:.10$s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -584,7 +585,7 @@ mod tests {\n                 ty: \"s\",\n             },\n         })]);\n-        same(\"{:a$.b$s}\", [Argument(Argument {\n+        same(\"{:a$.b$s}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -598,7 +599,7 @@ mod tests {\n     }\n     #[test]\n     fn format_flags() {\n-        same(\"{:-}\", [Argument(Argument {\n+        same(\"{:-}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -609,7 +610,7 @@ mod tests {\n                 ty: \"\",\n             },\n         })]);\n-        same(\"{:+#}\", [Argument(Argument {\n+        same(\"{:+#}\", [NextArgument(Argument {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n@@ -623,7 +624,7 @@ mod tests {\n     }\n     #[test]\n     fn format_mixture() {\n-        same(\"abcd {3:a} efg\", [String(\"abcd \"), Argument(Argument {\n+        same(\"abcd {3:a} efg\", [String(\"abcd \"), NextArgument(Argument {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,"}, {"sha": "8418e741167e8bac5391cee7188ae2c51b991a72", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -37,7 +37,7 @@ pub fn ntohs(u: u16) -> u16 {\n }\n \n enum InAddr {\n-    InAddr(libc::in_addr),\n+    In4Addr(libc::in_addr),\n     In6Addr(libc::in6_addr),\n }\n \n@@ -48,7 +48,7 @@ fn ip_to_inaddr(ip: rtio::IpAddr) -> InAddr {\n                      (b as u32 << 16) |\n                      (c as u32 <<  8) |\n                      (d as u32 <<  0);\n-            InAddr(libc::in_addr {\n+            In4Addr(libc::in_addr {\n                 s_addr: Int::from_be(ip)\n             })\n         }\n@@ -74,7 +74,7 @@ fn addr_to_sockaddr(addr: rtio::SocketAddr,\n                     -> libc::socklen_t {\n     unsafe {\n         let len = match ip_to_inaddr(addr.ip) {\n-            InAddr(inaddr) => {\n+            In4Addr(inaddr) => {\n                 let storage = storage as *mut _ as *mut libc::sockaddr_in;\n                 (*storage).sin_family = libc::AF_INET as libc::sa_family_t;\n                 (*storage).sin_port = htons(addr.port);\n@@ -723,7 +723,7 @@ impl UdpSocket {\n     pub fn set_membership(&mut self, addr: rtio::IpAddr,\n                           opt: libc::c_int) -> IoResult<()> {\n         match ip_to_inaddr(addr) {\n-            InAddr(addr) => {\n+            In4Addr(addr) => {\n                 let mreq = libc::ip_mreq {\n                     imr_multiaddr: addr,\n                     // interface == INADDR_ANY"}, {"sha": "efa3402073f2eff827a091aae9f24487b3f50a8e", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -618,7 +618,7 @@ impl ToBigUint for BigInt {\n     fn to_biguint(&self) -> Option<BigUint> {\n         if self.sign == Plus {\n             Some(self.data.clone())\n-        } else if self.sign == Zero {\n+        } else if self.sign == NoSign {\n             Some(Zero::zero())\n         } else {\n             None\n@@ -838,15 +838,15 @@ fn get_radix_base(radix: uint) -> (DoubleBigDigit, uint) {\n \n /// A Sign is a `BigInt`'s composing element.\n #[deriving(PartialEq, PartialOrd, Eq, Ord, Clone, Show)]\n-pub enum Sign { Minus, Zero, Plus }\n+pub enum Sign { Minus, NoSign, Plus }\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n     #[inline]\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n-          Zero  => Zero,\n+          NoSign  => NoSign,\n           Plus  => Minus\n         }\n     }\n@@ -882,7 +882,7 @@ impl Ord for BigInt {\n         if scmp != Equal { return scmp; }\n \n         match self.sign {\n-            Zero  => Equal,\n+            NoSign  => Equal,\n             Plus  => self.data.cmp(&other.data),\n             Minus => other.data.cmp(&self.data),\n         }\n@@ -933,11 +933,11 @@ impl Shr<uint, BigInt> for BigInt {\n impl Zero for BigInt {\n     #[inline]\n     fn zero() -> BigInt {\n-        BigInt::from_biguint(Zero, Zero::zero())\n+        BigInt::from_biguint(NoSign, Zero::zero())\n     }\n \n     #[inline]\n-    fn is_zero(&self) -> bool { self.sign == Zero }\n+    fn is_zero(&self) -> bool { self.sign == NoSign }\n }\n \n impl One for BigInt {\n@@ -951,7 +951,7 @@ impl Signed for BigInt {\n     #[inline]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n-            Plus | Zero => self.clone(),\n+            Plus | NoSign => self.clone(),\n             Minus => BigInt::from_biguint(Plus, self.data.clone())\n         }\n     }\n@@ -966,7 +966,7 @@ impl Signed for BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n             Minus => BigInt::from_biguint(Minus, One::one()),\n-            Zero  => Zero::zero(),\n+            NoSign  => Zero::zero(),\n         }\n     }\n \n@@ -981,8 +981,8 @@ impl Add<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)      => other.clone(),\n-            (_,    Zero)   => self.clone(),\n+            (NoSign, _)      => other.clone(),\n+            (_,    NoSign)   => self.clone(),\n             (Plus, Plus)   => BigInt::from_biguint(Plus, self.data + other.data),\n             (Plus, Minus)  => self - (-*other),\n             (Minus, Plus)  => other - (-*self),\n@@ -995,8 +995,8 @@ impl Sub<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)    => -other,\n-            (_,    Zero) => self.clone(),\n+            (NoSign, _)    => -other,\n+            (_,    NoSign) => self.clone(),\n             (Plus, Plus) => match self.data.cmp(&other.data) {\n                 Less    => BigInt::from_biguint(Minus, other.data - self.data),\n                 Greater => BigInt::from_biguint(Plus, self.data - other.data),\n@@ -1013,7 +1013,7 @@ impl Mul<BigInt, BigInt> for BigInt {\n     #[inline]\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n-            (Zero, _)     | (_,     Zero)  => Zero::zero(),\n+            (NoSign, _)     | (_,     NoSign)  => Zero::zero(),\n             (Plus, Plus)  | (Minus, Minus) => {\n                 BigInt::from_biguint(Plus, self.data * other.data)\n             },\n@@ -1087,9 +1087,9 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let r = BigInt::from_biguint(Plus, r_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n-            (Plus, Minus) | (Zero, Minus) => (-d,  r),\n+            (_,    NoSign)   => fail!(),\n+            (Plus, Plus)  | (NoSign, Plus)  => ( d,  r),\n+            (Plus, Minus) | (NoSign, Minus) => (-d,  r),\n             (Minus, Plus)                 => (-d, -r),\n             (Minus, Minus)                => ( d, -r)\n         }\n@@ -1113,9 +1113,9 @@ impl Integer for BigInt {\n         let d = BigInt::from_biguint(Plus, d_ui);\n         let m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n-            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n+            (_,    NoSign)   => fail!(),\n+            (Plus, Plus)  | (NoSign, Plus)  => (d, m),\n+            (Plus, Minus) | (NoSign, Minus) => if m.is_zero() {\n                 (-d, Zero::zero())\n             } else {\n                 (-d - One::one(), m + *other)\n@@ -1166,7 +1166,7 @@ impl ToPrimitive for BigInt {\n     fn to_i64(&self) -> Option<i64> {\n         match self.sign {\n             Plus  => self.data.to_i64(),\n-            Zero  => Some(0),\n+            NoSign  => Some(0),\n             Minus => {\n                 self.data.to_u64().and_then(|n| {\n                     let m: u64 = 1 << 63;\n@@ -1186,7 +1186,7 @@ impl ToPrimitive for BigInt {\n     fn to_u64(&self) -> Option<u64> {\n         match self.sign {\n             Plus => self.data.to_u64(),\n-            Zero => Some(0),\n+            NoSign => Some(0),\n             Minus => None\n         }\n     }\n@@ -1272,7 +1272,7 @@ impl ToStrRadix for BigInt {\n     fn to_str_radix(&self, radix: uint) -> String {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n-            Zero  => \"0\".to_string(),\n+            NoSign  => \"0\".to_string(),\n             Minus => format!(\"-{}\", self.data.to_str_radix(radix)),\n         }\n     }\n@@ -1334,7 +1334,7 @@ impl<R: Rng> RandBigInt for R {\n             if self.gen() {\n                 return self.gen_bigint(bit_size);\n             } else {\n-                Zero\n+                NoSign\n             }\n         } else if self.gen() {\n             Plus\n@@ -1385,8 +1385,8 @@ impl BigInt {\n     /// The digits are be in base 2^32.\n     #[inline]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n-        if sign == Zero || data.is_zero() {\n-            return BigInt { sign: Zero, data: Zero::zero() };\n+        if sign == NoSign || data.is_zero() {\n+            return BigInt { sign: NoSign, data: Zero::zero() };\n         }\n         BigInt { sign: sign, data: data }\n     }\n@@ -1415,7 +1415,7 @@ impl BigInt {\n     pub fn to_biguint(&self) -> Option<BigUint> {\n         match self.sign {\n             Plus => Some(self.data.clone()),\n-            Zero => Some(Zero::zero()),\n+            NoSign => Some(Zero::zero()),\n             Minus => None\n         }\n     }\n@@ -2288,7 +2288,7 @@ mod biguint_tests {\n mod bigint_tests {\n     use Integer;\n     use super::{BigDigit, BigUint, ToBigUint};\n-    use super::{Sign, Minus, Zero, Plus, BigInt, RandBigInt, ToBigInt};\n+    use super::{Sign, Minus, NoSign, Plus, BigInt, RandBigInt, ToBigInt};\n \n     use std::cmp::{Less, Equal, Greater};\n     use std::i64;\n@@ -2307,9 +2307,9 @@ mod bigint_tests {\n             assert_eq!(inp, ans);\n         }\n         check(Plus, 1, Plus, 1);\n-        check(Plus, 0, Zero, 0);\n+        check(Plus, 0, NoSign, 0);\n         check(Minus, 1, Minus, 1);\n-        check(Zero, 1, Zero, 0);\n+        check(NoSign, 1, NoSign, 0);\n     }\n \n     #[test]\n@@ -2357,8 +2357,8 @@ mod bigint_tests {\n \n     #[test]\n     fn test_hash() {\n-        let a = BigInt::new(Zero, vec!());\n-        let b = BigInt::new(Zero, vec!(0));\n+        let a = BigInt::new(NoSign, vec!());\n+        let b = BigInt::new(NoSign, vec!(0));\n         let c = BigInt::new(Plus, vec!(1));\n         let d = BigInt::new(Plus, vec!(1,0,0,0,0,0));\n         let e = BigInt::new(Plus, vec!(0,0,0,0,0,1));"}, {"sha": "c4b517c525963a62024ced88446a139c533eec60", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -16,7 +16,7 @@ use std::cmp;\n use parse;\n use parse::{\n     Flags, FLAG_EMPTY,\n-    Nothing, Literal, Dot, Class, Begin, End, WordBoundary, Capture, Cat, Alt,\n+    Nothing, Literal, Dot, AstClass, Begin, End, WordBoundary, Capture, Cat, Alt,\n     Rep,\n     ZeroOne, ZeroMore, OneMore,\n };\n@@ -148,7 +148,7 @@ impl<'r> Compiler<'r> {\n             Nothing => {},\n             Literal(c, flags) => self.push(OneChar(c, flags)),\n             Dot(nl) => self.push(Any(nl)),\n-            Class(ranges, flags) =>\n+            AstClass(ranges, flags) =>\n                 self.push(CharClass(ranges, flags)),\n             Begin(flags) => self.push(EmptyBegin(flags)),\n             End(flags) => self.push(EmptyEnd(flags)),"}, {"sha": "9ff65fe3e2ad79a1b9a6fe31ee50b5d09a8c4c1e", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -425,7 +425,7 @@ pub mod native {\n         FLAG_EMPTY, FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL,\n         FLAG_SWAP_GREED, FLAG_NEGATED,\n     };\n-    pub use re::{Dynamic, Native};\n+    pub use re::{Dynamic, ExDynamic, Native, ExNative};\n     pub use vm::{\n         MatchKind, Exists, Location, Submatches,\n         StepState, StepMatchEarlyReturn, StepMatch, StepContinue,"}, {"sha": "ad60829c088003fc746337ab45681b1ec920affd", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -53,7 +53,7 @@ pub enum Ast {\n     Nothing,\n     Literal(char, Flags),\n     Dot(Flags),\n-    Class(Vec<(char, char)>, Flags),\n+    AstClass(Vec<(char, char)>, Flags),\n     Begin(Flags),\n     End(Flags),\n     WordBoundary(Flags),\n@@ -101,7 +101,7 @@ impl Greed {\n /// state.\n #[deriving(Show)]\n enum BuildAst {\n-    Ast(Ast),\n+    Expr(Ast),\n     Paren(Flags, uint, String), // '('\n     Bar, // '|'\n }\n@@ -152,7 +152,7 @@ impl BuildAst {\n \n     fn unwrap(self) -> Result<Ast, Error> {\n         match self {\n-            Ast(x) => Ok(x),\n+            Expr(x) => Ok(x),\n             _ => fail!(\"Tried to unwrap non-AST item: {}\", self),\n         }\n     }\n@@ -311,7 +311,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn push(&mut self, ast: Ast) {\n-        self.stack.push(Ast(ast))\n+        self.stack.push(Expr(ast))\n     }\n \n     fn push_repeater(&mut self, c: char) -> Result<(), Error> {\n@@ -388,8 +388,8 @@ impl<'a> Parser<'a> {\n             match c {\n                 '[' =>\n                     match self.try_parse_ascii() {\n-                        Some(Class(asciis, flags)) => {\n-                            alts.push(Class(asciis, flags ^ negated));\n+                        Some(AstClass(asciis, flags)) => {\n+                            alts.push(AstClass(asciis, flags ^ negated));\n                             continue\n                         }\n                         Some(ast) =>\n@@ -399,8 +399,8 @@ impl<'a> Parser<'a> {\n                     },\n                 '\\\\' => {\n                     match try!(self.parse_escape()) {\n-                        Class(asciis, flags) => {\n-                            alts.push(Class(asciis, flags ^ negated));\n+                        AstClass(asciis, flags) => {\n+                            alts.push(AstClass(asciis, flags ^ negated));\n                             continue\n                         }\n                         Literal(c2, _) => c = c2, // process below\n@@ -417,7 +417,7 @@ impl<'a> Parser<'a> {\n                 ']' => {\n                     if ranges.len() > 0 {\n                         let flags = negated | (self.flags & FLAG_NOCASE);\n-                        let mut ast = Class(combine_ranges(ranges), flags);\n+                        let mut ast = AstClass(combine_ranges(ranges), flags);\n                         for alt in alts.into_iter() {\n                             ast = Alt(box alt, box ast)\n                         }\n@@ -485,7 +485,7 @@ impl<'a> Parser<'a> {\n             Some(ranges) => {\n                 self.chari = closer;\n                 let flags = negated | (self.flags & FLAG_NOCASE);\n-                Some(Class(combine_ranges(ranges), flags))\n+                Some(AstClass(combine_ranges(ranges), flags))\n             }\n         }\n     }\n@@ -611,7 +611,7 @@ impl<'a> Parser<'a> {\n                 let ranges = perl_unicode_class(c);\n                 let mut flags = self.flags & FLAG_NOCASE;\n                 if c.is_uppercase() { flags |= FLAG_NEGATED }\n-                Ok(Class(ranges, flags))\n+                Ok(AstClass(ranges, flags))\n             }\n             _ => {\n                 self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\",\n@@ -655,7 +655,7 @@ impl<'a> Parser<'a> {\n                                         name).as_slice())\n             }\n             Some(ranges) => {\n-                Ok(Class(ranges, negated | (self.flags & FLAG_NOCASE)))\n+                Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n             }\n         }\n     }\n@@ -888,7 +888,7 @@ impl<'a> Parser<'a> {\n         while i > from {\n             i = i - 1;\n             match self.stack.pop().unwrap() {\n-                Ast(x) => combined = mk(x, combined),\n+                Expr(x) => combined = mk(x, combined),\n                 _ => {},\n             }\n         }"}, {"sha": "c2578d227ee384839d806da04f1e9de374134a17", "filename": "src/libregex/re.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -110,22 +110,22 @@ pub enum Regex {\n     // See the comments for the `program` module in `lib.rs` for a more\n     // detailed explanation for what `regex!` requires.\n     #[doc(hidden)]\n-    Dynamic(Dynamic),\n+    Dynamic(ExDynamic),\n     #[doc(hidden)]\n-    Native(Native),\n+    Native(ExNative),\n }\n \n #[deriving(Clone)]\n #[doc(hidden)]\n-pub struct Dynamic {\n+pub struct ExDynamic {\n     original: String,\n     names: Vec<Option<String>>,\n     #[doc(hidden)]\n     pub prog: Program\n }\n \n #[doc(hidden)]\n-pub struct Native {\n+pub struct ExNative {\n     #[doc(hidden)]\n     pub original: &'static str,\n     #[doc(hidden)]\n@@ -134,8 +134,8 @@ pub struct Native {\n     pub prog: fn(MatchKind, &str, uint, uint) -> Vec<Option<uint>>\n }\n \n-impl Clone for Native {\n-    fn clone(&self) -> Native { *self }\n+impl Clone for ExNative {\n+    fn clone(&self) -> ExNative { *self }\n }\n \n impl fmt::Show for Regex {\n@@ -156,7 +156,7 @@ impl Regex {\n     pub fn new(re: &str) -> Result<Regex, parse::Error> {\n         let ast = try!(parse::parse(re));\n         let (prog, names) = Program::new(ast);\n-        Ok(Dynamic(Dynamic {\n+        Ok(Dynamic(ExDynamic {\n             original: re.to_string(),\n             names: names,\n             prog: prog,\n@@ -510,8 +510,8 @@ impl Regex {\n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(Dynamic { ref original, .. }) => original.as_slice(),\n-            Native(Native { ref original, .. }) => original.as_slice(),\n+            Dynamic(ExDynamic { ref original, .. }) => original.as_slice(),\n+            Native(ExNative { ref original, .. }) => original.as_slice(),\n         }\n     }\n \n@@ -915,8 +915,8 @@ fn exec(re: &Regex, which: MatchKind, input: &str) -> CaptureLocs {\n fn exec_slice(re: &Regex, which: MatchKind,\n               input: &str, s: uint, e: uint) -> CaptureLocs {\n     match *re {\n-        Dynamic(Dynamic { ref prog, .. }) => vm::run(which, prog, input, s, e),\n-        Native(Native { prog, .. }) => prog(which, input, s, e),\n+        Dynamic(ExDynamic { ref prog, .. }) => vm::run(which, prog, input, s, e),\n+        Native(ExNative { prog, .. }) => prog(which, input, s, e),\n     }\n }\n "}, {"sha": "ae6dd2a4d70a78b8d3053ea44b836a4c6c4fc150", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -42,7 +42,7 @@ use regex::Regex;\n use regex::native::{\n     OneChar, CharClass, Any, Save, Jump, Split,\n     Match, EmptyBegin, EmptyEnd, EmptyWordBoundary,\n-    Program, Dynamic, Native,\n+    Program, Dynamic, ExDynamic, Native,\n     FLAG_NOCASE, FLAG_MULTI, FLAG_DOTNL, FLAG_NEGATED,\n };\n \n@@ -91,7 +91,7 @@ fn native(cx: &mut ExtCtxt, sp: codemap::Span, tts: &[ast::TokenTree])\n         }\n     };\n     let prog = match re {\n-        Dynamic(Dynamic { ref prog, .. }) => prog.clone(),\n+        Dynamic(ExDynamic { ref prog, .. }) => prog.clone(),\n         Native(_) => unreachable!(),\n     };\n \n@@ -322,7 +322,7 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     }\n }\n \n-::regex::native::Native(::regex::native::Native {\n+::regex::native::Native(::regex::native::ExNative {\n     original: $regex,\n     names: CAP_NAMES,\n     prog: exec,"}, {"sha": "123131f0c2107402b67ee265de4b801942681df5", "filename": "src/librustc/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fwrite.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -11,7 +11,7 @@\n use back::lto;\n use back::link::{get_cc_prog, remove};\n use driver::driver::{CrateTranslation, ModuleTranslation, OutputFilenames};\n-use driver::config::{NoDebugInfo, Passes, AllPasses};\n+use driver::config::{NoDebugInfo, Passes, SomePasses, AllPasses};\n use driver::session::Session;\n use driver::config;\n use llvm;\n@@ -341,7 +341,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n             let pass_name = pass_name.as_str().expect(\"got a non-UTF8 pass name from LLVM\");\n             let enabled = match cgcx.remark {\n                 AllPasses => true,\n-                Passes(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n+                SomePasses(ref v) => v.iter().any(|s| s.as_slice() == pass_name),\n             };\n \n             if enabled {\n@@ -482,14 +482,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         if config.emit_asm {\n             let path = output_names.with_extension(format!(\"{}.s\", name_extra).as_slice());\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFile);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n             let path = output_names.with_extension(format!(\"{}.o\", name_extra).as_slice());\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFile);\n+                write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n         }\n     });"}, {"sha": "72e2d244ad333091c4f1e540108a9477f6a6e1be", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -237,14 +237,14 @@ pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n \n #[deriving(Clone)]\n pub enum Passes {\n-    Passes(Vec<String>),\n+    SomePasses(Vec<String>),\n     AllPasses,\n }\n \n impl Passes {\n     pub fn is_empty(&self) -> bool {\n         match *self {\n-            Passes(ref v) => v.is_empty(),\n+            SomePasses(ref v) => v.is_empty(),\n             AllPasses => false,\n         }\n     }\n@@ -276,7 +276,7 @@ macro_rules! cgoptions(\n         &[ $( (stringify!($opt), cgsetters::$opt, $desc) ),* ];\n \n     mod cgsetters {\n-        use super::{CodegenOptions, Passes, AllPasses};\n+        use super::{CodegenOptions, Passes, SomePasses, AllPasses};\n \n         $(\n             pub fn $opt(cg: &mut CodegenOptions, v: Option<&str>) -> bool {\n@@ -335,7 +335,7 @@ macro_rules! cgoptions(\n                 v => {\n                     let mut passes = vec!();\n                     if parse_list(&mut passes, v) {\n-                        *slot = Passes(passes);\n+                        *slot = SomePasses(passes);\n                         true\n                     } else {\n                         false\n@@ -389,7 +389,7 @@ cgoptions!(\n          \"extra data to put in each output filename\"),\n     codegen_units: uint = (1, parse_uint,\n         \"divide crate into N units to optimize in parallel\"),\n-    remark: Passes = (Passes(Vec::new()), parse_passes,\n+    remark: Passes = (SomePasses(Vec::new()), parse_passes,\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n )\n "}, {"sha": "588e275455afe5d9e2d345b150dcf778d488f050", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -1296,7 +1296,7 @@ impl LintPass for UnnecessaryAllocation {\n         match cx.tcx.adjustments.borrow().find(&e.id) {\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n+                    ty::AdjustDerefRef(ty::AutoDerefRef { ref autoref, .. }) => {\n                         match (allocation, autoref) {\n                             (VectorAllocation, &Some(ty::AutoPtr(_, _, None))) => {\n                                 cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n@@ -1511,12 +1511,12 @@ impl LintPass for Stability {\n                             typeck::MethodStaticUnboxedClosure(def_id) => {\n                                 def_id\n                             }\n-                            typeck::MethodParam(typeck::MethodParam {\n+                            typeck::MethodTypeParam(typeck::MethodParam {\n                                 trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 ..\n                             }) |\n-                            typeck::MethodObject(typeck::MethodObject {\n+                            typeck::MethodTraitObject(typeck::MethodObject {\n                                 trait_ref: ref trait_ref,\n                                 method_num: index,\n                                 .."}, {"sha": "acb4f1be85ca2c799ff592e473f2b682e38dbbf2", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -641,17 +641,17 @@ impl tr for MethodOrigin {\n             typeck::MethodStaticUnboxedClosure(did) => {\n                 typeck::MethodStaticUnboxedClosure(did.tr(dcx))\n             }\n-            typeck::MethodParam(ref mp) => {\n-                typeck::MethodParam(\n+            typeck::MethodTypeParam(ref mp) => {\n+                typeck::MethodTypeParam(\n                     typeck::MethodParam {\n                         // def-id is already translated when we read it out\n                         trait_ref: mp.trait_ref.clone(),\n                         method_num: mp.method_num,\n                     }\n                 )\n             }\n-            typeck::MethodObject(ref mo) => {\n-                typeck::MethodObject(\n+            typeck::MethodTraitObject(ref mo) => {\n+                typeck::MethodTraitObject(\n                     typeck::MethodObject {\n                         trait_ref: mo.trait_ref.clone(),\n                         .. *mo\n@@ -957,8 +957,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                     })\n                 }\n \n-                typeck::MethodParam(ref p) => {\n-                    this.emit_enum_variant(\"MethodParam\", 2, 1, |this| {\n+                typeck::MethodTypeParam(ref p) => {\n+                    this.emit_enum_variant(\"MethodTypeParam\", 2, 1, |this| {\n                         this.emit_struct(\"MethodParam\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n                                 Ok(this.emit_trait_ref(ecx, &*p.trait_ref))\n@@ -971,8 +971,8 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                     })\n                 }\n \n-                typeck::MethodObject(ref o) => {\n-                    this.emit_enum_variant(\"MethodObject\", 3, 1, |this| {\n+                typeck::MethodTraitObject(ref o) => {\n+                    this.emit_enum_variant(\"MethodTraitObject\", 3, 1, |this| {\n                         this.emit_struct(\"MethodObject\", 2, |this| {\n                             try!(this.emit_struct_field(\"trait_ref\", 0, |this| {\n                                 Ok(this.emit_trait_ref(ecx, &*o.trait_ref))\n@@ -1067,13 +1067,13 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n \n         self.emit_enum(\"AutoAdjustment\", |this| {\n             match *adj {\n-                ty::AutoAddEnv(store) => {\n+                ty::AdjustAddEnv(store) => {\n                     this.emit_enum_variant(\"AutoAddEnv\", 0, 1, |this| {\n                         this.emit_enum_variant_arg(0, |this| store.encode(this))\n                     })\n                 }\n \n-                ty::AutoDerefRef(ref auto_deref_ref) => {\n+                ty::AdjustDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n                         this.emit_enum_variant_arg(0,\n                             |this| Ok(this.emit_auto_deref_ref(ecx, auto_deref_ref)))\n@@ -1369,7 +1369,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     })\n                 }\n             }\n-            ty::AutoDerefRef(ref adj) => {\n+            ty::AdjustDerefRef(ref adj) => {\n                 assert!(!ty::adjust_is_object(adjustment));\n                 for autoderef in range(0, adj.autoderefs) {\n                     let method_call = MethodCall::autoderef(id, autoderef);\n@@ -1500,7 +1500,7 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n     {\n         self.read_enum(\"MethodOrigin\", |this| {\n             let variants = [\"MethodStatic\", \"MethodStaticUnboxedClosure\",\n-                            \"MethodParam\", \"MethodObject\"];\n+                            \"MethodTypeParam\", \"MethodTraitObject\"];\n             this.read_enum_variant(variants, |this, i| {\n                 Ok(match i {\n                     0 => {\n@@ -1514,8 +1514,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     }\n \n                     2 => {\n-                        this.read_struct(\"MethodParam\", 2, |this| {\n-                            Ok(typeck::MethodParam(\n+                        this.read_struct(\"MethodTypeParam\", 2, |this| {\n+                            Ok(typeck::MethodTypeParam(\n                                 typeck::MethodParam {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n@@ -1532,8 +1532,8 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     }\n \n                     3 => {\n-                        this.read_struct(\"MethodObject\", 2, |this| {\n-                            Ok(typeck::MethodObject(\n+                        this.read_struct(\"MethodTraitObject\", 2, |this| {\n+                            Ok(typeck::MethodTraitObject(\n                                 typeck::MethodObject {\n                                     trait_ref: {\n                                         this.read_struct_field(\"trait_ref\", 0, |this| {\n@@ -1680,14 +1680,14 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         let store: ty::TraitStore =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n \n-                        ty::AutoAddEnv(store.tr(dcx))\n+                        ty::AdjustAddEnv(store.tr(dcx))\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n                             this.read_enum_variant_arg(0,\n                                 |this| Ok(this.read_auto_deref_ref(dcx))).unwrap();\n \n-                        ty::AutoDerefRef(auto_deref_ref)\n+                        ty::AdjustDerefRef(auto_deref_ref)\n                     }\n                     _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n                 })"}, {"sha": "e1e37b3d371a5461b47999c7f0fa7c3d817b6be6", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -424,12 +424,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                adj: &ty::AutoAdjustment)\n                                -> mc::cmt {\n         let r = match *adj {\n-            ty::AutoDerefRef(\n+            ty::AdjustDerefRef(\n                 ty::AutoDerefRef {\n                     autoderefs: autoderefs, ..}) => {\n                 self.mc().cat_expr_autoderefd(expr, autoderefs)\n             }\n-            ty::AutoAddEnv(..) => {\n+            ty::AdjustAddEnv(..) => {\n                 // no autoderefs\n                 self.mc().cat_expr_unadjusted(expr)\n             }"}, {"sha": "345b8c8837253cb5e38893560b96aca3fc729bf4", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -101,12 +101,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         }\n                     }\n                     typeck::MethodStaticUnboxedClosure(_) => {}\n-                    typeck::MethodParam(typeck::MethodParam {\n+                    typeck::MethodTypeParam(typeck::MethodParam {\n                         trait_ref: ref trait_ref,\n                         method_num: index,\n                         ..\n                     }) |\n-                    typeck::MethodObject(typeck::MethodObject {\n+                    typeck::MethodTraitObject(typeck::MethodObject {\n                         trait_ref: ref trait_ref,\n                         method_num: index,\n                         .."}, {"sha": "0b4f661a16ab2c75c0eaaf2f3ae32f179da6eebf", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -19,7 +19,8 @@ use middle::def;\n use middle::mem_categorization::Typer;\n use middle::pat_util;\n use middle::ty;\n-use middle::typeck::{MethodCall, MethodObject, MethodOrigin, MethodParam};\n+use middle::typeck::{MethodCall, MethodObject, MethodTraitObject};\n+use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure};\n use middle::typeck;\n use util::ppaux::Repr;\n@@ -177,8 +178,8 @@ impl OverloadedCallType {\n             MethodStaticUnboxedClosure(def_id) => {\n                 OverloadedCallType::from_unboxed_closure(tcx, def_id)\n             }\n-            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n-            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+            MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 OverloadedCallType::from_trait_id(tcx, trait_ref.def_id)\n             }\n         }\n@@ -684,15 +685,15 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,TYPER> {\n             None => { }\n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoAddEnv(..) => {\n+                    ty::AdjustAddEnv(..) => {\n                         // Creating a closure consumes the input and stores it\n                         // into the resulting rvalue.\n                         debug!(\"walk_adjustment(AutoAddEnv)\");\n                         let cmt_unadjusted =\n                             return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                         self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                     }\n-                    ty::AutoDerefRef(ty::AutoDerefRef {\n+                    ty::AdjustDerefRef(ty::AutoDerefRef {\n                         autoref: ref opt_autoref,\n                         autoderefs: n\n                     }) => {"}, {"sha": "4a5b2e01463ad93aaa070cc14480c68caec2bd7a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -272,6 +272,7 @@ pub fn check_expr(cx: &mut Context, e: &Expr) {\n \n     visit::walk_expr(cx, e);\n }\n+\n fn check_ty(cx: &mut Context, aty: &Ty) {\n     match aty.node {\n         TyPath(_, _, id) => {"}, {"sha": "b6893a6a3b41925100f5f110eba322e79c146e41", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -115,6 +115,7 @@ use std::mem::transmute;\n use std::rc::Rc;\n use std::str;\n use std::uint;\n+use syntax::ast;\n use syntax::ast::*;\n use syntax::codemap::{BytePos, original_sp, Span};\n use syntax::parse::token::special_idents;\n@@ -182,7 +183,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n                 b: &'v Block, s: Span, n: NodeId) {\n         visit_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local) { visit_local(self, l); }\n+    fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n     fn visit_arm(&mut self, a: &Arm) { visit_arm(self, a); }\n }\n@@ -345,7 +346,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, n: NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &ast::Local) {\n         check_local(self, l);\n     }\n     fn visit_expr(&mut self, ex: &Expr) {\n@@ -407,7 +408,7 @@ fn visit_fn(ir: &mut IrMaps,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(ir: &mut IrMaps, local: &Local) {\n+fn visit_local(ir: &mut IrMaps, local: &ast::Local) {\n     pat_util::pat_bindings(&ir.tcx.def_map, &*local.pat, |_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n@@ -903,7 +904,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_local(&mut self, local: &Local, succ: LiveNode)\n+    fn propagate_through_local(&mut self, local: &ast::Local, succ: LiveNode)\n                                -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n@@ -1398,7 +1399,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: &Local) {\n+fn check_local(this: &mut Liveness, local: &ast::Local) {\n     match local.init {\n         Some(_) => {\n             this.warn_about_unused_or_dead_vars_in_pat(&*local.pat);"}, {"sha": "6350fa6a5068713dbb52c748b40caeba8738456a", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -404,14 +404,14 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n \n             Some(adjustment) => {\n                 match *adjustment {\n-                    ty::AutoAddEnv(..) => {\n+                    ty::AdjustAddEnv(..) => {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n                         let expr_ty = if_ok!(self.expr_ty_adjusted(expr));\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(\n+                    ty::AdjustDerefRef(\n                         ty::AutoDerefRef {\n                             autoref: Some(_), ..}) => {\n                         // Equivalent to &*expr or something similar.\n@@ -420,7 +420,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                         Ok(self.cat_rvalue_node(expr.id(), expr.span(), expr_ty))\n                     }\n \n-                    ty::AutoDerefRef(\n+                    ty::AdjustDerefRef(\n                         ty::AutoDerefRef {\n                             autoref: None, autoderefs: autoderefs}) => {\n                         // Equivalent to *expr or something similar."}, {"sha": "36778e7cfc32c91dd4e0189e5f2df3b06730f57a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -19,8 +19,8 @@ use middle::def;\n use lint;\n use middle::resolve;\n use middle::ty;\n-use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n+use middle::typeck::{MethodCall, MethodMap, MethodOrigin, MethodParam, MethodTypeParam};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use util::nodemap::{NodeMap, NodeSet};\n \n use syntax::ast;\n@@ -829,8 +829,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             MethodStaticUnboxedClosure(_) => {}\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n-            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+            MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 self.report_error(self.ensure_public(span, trait_ref.def_id,\n                                                      None, \"source trait\"));\n             }"}, {"sha": "11ea84c75d39f7b9888db2c65406506fc73fae10", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -29,7 +29,7 @@ use syntax::ast::{ExprPath, ExprProc, ExprStruct, ExprUnboxedFn, FnDecl};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemEnum, ItemFn, ItemForeignMod};\n use syntax::ast::{ItemImpl, ItemMac, ItemMod, ItemStatic, ItemStruct};\n-use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local, Method};\n+use syntax::ast::{ItemTrait, ItemTy, LOCAL_CRATE, Local};\n use syntax::ast::{MethodImplItem, Mod, Name, NamedField, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path, PathListIdent, PathListMod};\n@@ -1529,33 +1529,31 @@ impl<'a> Resolver<'a> {\n     }\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n-    // type and/or value namespaces.\n+    // type and value namespaces.\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n                                        parent: ReducedGraphParent,\n                                        is_public: bool) {\n         let ident = variant.node.name;\n-\n-        match variant.node.kind {\n-            TupleVariantKind(_) => {\n-                let child = self.add_child(ident, parent, ForbidDuplicateValues, variant.span);\n-                child.define_value(DefVariant(item_id,\n-                                              local_def(variant.node.id), false),\n-                                   variant.span, is_public);\n-            }\n+        let is_exported = match variant.node.kind {\n+            TupleVariantKind(_) => false,\n             StructVariantKind(_) => {\n-                let child = self.add_child(ident, parent,\n-                                           ForbidDuplicateTypesAndValues,\n-                                           variant.span);\n-                child.define_type(DefVariant(item_id,\n-                                             local_def(variant.node.id), true),\n-                                  variant.span, is_public);\n-\n                 // Not adding fields for variants as they are not accessed with a self receiver\n                 self.structs.insert(local_def(variant.node.id), Vec::new());\n+                true\n             }\n-        }\n+        };\n+\n+        let child = self.add_child(ident, parent,\n+                                   ForbidDuplicateTypesAndValues,\n+                                   variant.span);\n+        child.define_value(DefVariant(item_id,\n+                                      local_def(variant.node.id), is_exported),\n+                           variant.span, is_public);\n+        child.define_type(DefVariant(item_id,\n+                                     local_def(variant.node.id), is_exported),\n+                          variant.span, is_public);\n     }\n \n     /// Constructs the reduced graph for one 'view item'. View items consist\n@@ -4513,7 +4511,7 @@ impl<'a> Resolver<'a> {\n     // to be NormalRibKind?\n     fn resolve_method(&mut self,\n                       rib_kind: RibKind,\n-                      method: &Method) {\n+                      method: &ast::Method) {\n         let method_generics = method.pe_generics();\n         let type_parameters = HasTypeParameters(method_generics,\n                                                 FnSpace,"}, {"sha": "0f4ed202ec20750c9b80030fd92db4b841d4d188", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -895,14 +895,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 };\n                 (Some(def_id), decl_id)\n             }\n-            typeck::MethodParam(ref mp) => {\n+            typeck::MethodTypeParam(ref mp) => {\n                 // method invoked on a type parameter\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n                                                 mp.trait_ref.def_id,\n                                                 mp.method_num);\n                 (None, Some(trait_item.def_id()))\n             }\n-            typeck::MethodObject(ref mo) => {\n+            typeck::MethodTraitObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n                                                 mo.trait_ref.def_id,"}, {"sha": "e7b1053b3589ef77398a72cb34d5d41c57a7f531", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -13,10 +13,10 @@ use middle::typeck::infer::{InferCtxt, skolemize};\n use util::nodemap::DefIdMap;\n use util::ppaux::Repr;\n \n-use super::Ambiguity;\n+use super::CodeAmbiguity;\n use super::Obligation;\n use super::FulfillmentError;\n-use super::SelectionError;\n+use super::CodeSelectionError;\n use super::select::SelectionContext;\n use super::Unimplemented;\n \n@@ -78,7 +78,7 @@ impl FulfillmentContext {\n         let errors: Vec<FulfillmentError> =\n             self.trait_obligations\n             .iter()\n-            .map(|o| FulfillmentError::new((*o).clone(), Ambiguity))\n+            .map(|o| FulfillmentError::new((*o).clone(), CodeAmbiguity))\n             .collect();\n \n         if errors.is_empty() {\n@@ -129,7 +129,7 @@ impl FulfillmentContext {\n \n                         errors.push(FulfillmentError::new(\n                             (*obligation).clone(),\n-                            SelectionError(selection_err)));\n+                            CodeSelectionError(selection_err)));\n                         false\n                     }\n                 }\n@@ -237,7 +237,7 @@ impl FulfillmentContext {\n             errors.push(\n                 FulfillmentError::new(\n                     (*obligation).clone(),\n-                    SelectionError(Unimplemented)));\n+                    CodeSelectionError(Unimplemented)));\n         }\n \n         if errors.is_empty() {"}, {"sha": "dde733a6a3ec163e8963c63777f44326fc8ad809", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -97,8 +97,8 @@ pub struct FulfillmentError {\n \n #[deriving(Clone)]\n pub enum FulfillmentErrorCode {\n-    SelectionError(SelectionError),\n-    Ambiguity,\n+    CodeSelectionError(SelectionError),\n+    CodeAmbiguity,\n }\n \n /**\n@@ -110,7 +110,7 @@ pub enum FulfillmentErrorCode {\n  *   to inconclusive type inference.\n  * - `Err(e)`: error `e` occurred\n  */\n-pub type SelectionResult<T> = Result<Option<T>,SelectionError>;\n+pub type SelectionResult<T> = Result<Option<T>, SelectionError>;\n \n #[deriving(PartialEq,Eq,Show)]\n pub enum EvaluationResult {\n@@ -157,12 +157,12 @@ pub enum EvaluationResult {\n  *\n  * ### The type parameter `N`\n  *\n- * See explanation on `VtableImpl`.\n+ * See explanation on `VtableImplData`.\n  */\n #[deriving(Show,Clone)]\n pub enum Vtable<N> {\n     /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImpl<N>),\n+    VtableImpl(VtableImplData<N>),\n \n     /// Vtable automatically generated for an unboxed closure. The def\n     /// ID is the ID of the closure expression. This is a `VtableImpl`\n@@ -172,7 +172,7 @@ pub enum Vtable<N> {\n \n     /// Successful resolution to an obligation provided by the caller\n     /// for some type parameter.\n-    VtableParam(VtableParam),\n+    VtableParam(VtableParamData),\n \n     /// Successful resolution for a builtin trait.\n     VtableBuiltin,\n@@ -191,7 +191,7 @@ pub enum Vtable<N> {\n  * impl, and nested obligations are satisfied later.\n  */\n #[deriving(Clone)]\n-pub struct VtableImpl<N> {\n+pub struct VtableImplData<N> {\n     pub impl_def_id: ast::DefId,\n     pub substs: subst::Substs,\n     pub nested: subst::VecPerParamSpace<N>\n@@ -203,7 +203,7 @@ pub struct VtableImpl<N> {\n  * on an instance of `T`, the vtable would be of type `VtableParam`.\n  */\n #[deriving(Clone)]\n-pub struct VtableParam {\n+pub struct VtableParamData {\n     // In the above example, this would `Eq`\n     pub bound: Rc<ty::TraitRef>,\n }\n@@ -274,7 +274,7 @@ pub fn select_inherent_impl(infcx: &InferCtxt,\n                             cause: ObligationCause,\n                             impl_def_id: ast::DefId,\n                             self_ty: ty::t)\n-                            -> SelectionResult<VtableImpl<Obligation>>\n+                            -> SelectionResult<VtableImplData<Obligation>>\n {\n     /*!\n      * Matches the self type of the inherent impl `impl_def_id`\n@@ -398,21 +398,21 @@ impl<N> Vtable<N> {\n     }\n }\n \n-impl<N> VtableImpl<N> {\n+impl<N> VtableImplData<N> {\n     pub fn map_nested<M>(&self,\n                          op: |&N| -> M)\n-                         -> VtableImpl<M>\n+                         -> VtableImplData<M>\n     {\n-        VtableImpl {\n+        VtableImplData {\n             impl_def_id: self.impl_def_id,\n             substs: self.substs.clone(),\n             nested: self.nested.map(op)\n         }\n     }\n \n-    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImpl<M> {\n-        let VtableImpl { impl_def_id, substs, nested } = self;\n-        VtableImpl {\n+    pub fn map_move_nested<M>(self, op: |N| -> M) -> VtableImplData<M> {\n+        let VtableImplData { impl_def_id, substs, nested } = self;\n+        VtableImplData {\n             impl_def_id: impl_def_id,\n             substs: substs,\n             nested: nested.map_move(op)"}, {"sha": "e475dc6063d5d768bdad107eb95301a15ec944a5", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -18,6 +18,7 @@ use super::{SelectionError, Unimplemented, Overflow,\n use super::{Selection};\n use super::{SelectionResult};\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableUnboxedClosure};\n+use super::{VtableImplData, VtableParamData};\n use super::{util};\n \n use middle::subst::{Subst, Substs, VecPerParamSpace};\n@@ -82,7 +83,7 @@ enum MatchResult<T> {\n enum Candidate {\n     MatchedBuiltinCandidate,\n     AmbiguousBuiltinCandidate,\n-    MatchedParamCandidate(VtableParam),\n+    MatchedParamCandidate(VtableParamData),\n     AmbiguousParamCandidate,\n     Impl(ImplCandidate),\n     MatchedUnboxedClosureCandidate(/* closure */ ast::DefId)\n@@ -142,7 +143,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                 impl_def_id: ast::DefId,\n                                 obligation_cause: ObligationCause,\n                                 obligation_self_ty: ty::t)\n-                                -> SelectionResult<VtableImpl<Obligation>>\n+                                -> SelectionResult<VtableImplData<Obligation>>\n     {\n         debug!(\"select_inherent_impl(impl_def_id={}, obligation_self_ty={})\",\n                impl_def_id.repr(self.tcx()),\n@@ -597,8 +598,8 @@ v         */\n \n     fn confirm_param_candidate(&self,\n                                obligation: &Obligation,\n-                               param: VtableParam)\n-                               -> Result<VtableParam,SelectionError>\n+                               param: VtableParamData)\n+                               -> Result<VtableParamData,SelectionError>\n     {\n         debug!(\"confirm_param_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -613,7 +614,7 @@ v         */\n     fn confirm_impl_candidate(&self,\n                               obligation: &Obligation,\n                               impl_def_id: ast::DefId)\n-                              -> Result<VtableImpl<Obligation>,SelectionError>\n+                              -> Result<VtableImplData<Obligation>,SelectionError>\n     {\n         debug!(\"confirm_impl_candidate({},{})\",\n                obligation.repr(self.tcx()),\n@@ -642,7 +643,7 @@ v         */\n                                        obligation_cause: ObligationCause,\n                                        obligation_self_ty: ty::t,\n                                        obligation_recursion_depth: uint)\n-                                       -> Result<VtableImpl<Obligation>,\n+                                       -> Result<VtableImplData<Obligation>,\n                                                  SelectionError>\n     {\n         let substs = match self.match_impl_self_types(impl_def_id,\n@@ -663,7 +664,7 @@ v         */\n                                   obligation_recursion_depth,\n                                   impl_def_id,\n                                   &substs);\n-        let vtable_impl = VtableImpl { impl_def_id: impl_def_id,\n+        let vtable_impl = VtableImplData { impl_def_id: impl_def_id,\n                                        substs: substs,\n                                        nested: impl_obligations };\n "}, {"sha": "c48b125ac355d6e5df30ff62bb22094172038cfa", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -19,7 +19,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::Repr;\n \n-use super::{Obligation, ObligationCause, VtableImpl, VtableParam};\n+use super::{Obligation, ObligationCause, VtableImpl, VtableParam, VtableParamData, VtableImplData};\n \n ///////////////////////////////////////////////////////////////////////////\n // Supertrait iterator\n@@ -137,13 +137,13 @@ pub fn fresh_substs_for_impl(infcx: &InferCtxt,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<N> fmt::Show for VtableImpl<N> {\n+impl<N> fmt::Show for VtableImplData<N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({})\", self.impl_def_id)\n     }\n }\n \n-impl fmt::Show for VtableParam {\n+impl fmt::Show for VtableParamData {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableParam(...)\")\n     }\n@@ -239,7 +239,7 @@ pub fn obligation_for_builtin_bound(\n pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n                                                caller_bound: Rc<ty::TraitRef>,\n                                                test: |ast::DefId| -> bool)\n-                                               -> Option<VtableParam>\n+                                               -> Option<VtableParamData>\n {\n     /*!\n      * Starting from a caller obligation `caller_bound` (which has\n@@ -252,7 +252,7 @@ pub fn search_trait_and_supertraits_from_bound(tcx: &ty::ctxt,\n \n     for bound in transitive_bounds(tcx, &[caller_bound]) {\n         if test(bound.def_id) {\n-            let vtable_param = VtableParam { bound: bound };\n+            let vtable_param = VtableParamData { bound: bound };\n             return Some(vtable_param);\n         }\n     }\n@@ -287,7 +287,7 @@ impl<N:Repr> Repr for super::Vtable<N> {\n     }\n }\n \n-impl<N:Repr> Repr for super::VtableImpl<N> {\n+impl<N:Repr> Repr for super::VtableImplData<N> {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"VtableImpl(impl_def_id={}, substs={}, nested={})\",\n                 self.impl_def_id.repr(tcx),\n@@ -296,7 +296,7 @@ impl<N:Repr> Repr for super::VtableImpl<N> {\n     }\n }\n \n-impl Repr for super::VtableParam {\n+impl Repr for super::VtableParamData {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         format!(\"VtableParam(bound={})\",\n                 self.bound.repr(tcx))\n@@ -331,17 +331,17 @@ impl Repr for super::FulfillmentError {\n impl Repr for super::FulfillmentErrorCode {\n     fn repr(&self, tcx: &ty::ctxt) -> String {\n         match *self {\n-            super::SelectionError(ref o) => o.repr(tcx),\n-            super::Ambiguity => format!(\"Ambiguity\")\n+            super::CodeSelectionError(ref o) => o.repr(tcx),\n+            super::CodeAmbiguity => format!(\"Ambiguity\")\n         }\n     }\n }\n \n impl fmt::Show for super::FulfillmentErrorCode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            super::SelectionError(ref e) => write!(f, \"{}\", e),\n-            super::Ambiguity => write!(f, \"Ambiguity\")\n+            super::CodeSelectionError(ref e) => write!(f, \"{}\", e),\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\")\n         }\n     }\n }"}, {"sha": "d39fe4a1e700306551513c542c6be122bfa4d739", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -207,7 +207,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n         None => { }\n         Some(adj) => {\n             match adj {\n-                ty::AutoAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n+                ty::AdjustAddEnv(ty::RegionTraitStore(ty::ReStatic, _)) => {\n                     let def = ty::resolve_expr(cx.tcx(), e);\n                     let wrapper = closure::get_wrapper_for_bare_fn(cx,\n                                                                    ety_adjusted,\n@@ -216,13 +216,13 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                                                                    is_local);\n                     llconst = C_struct(cx, [wrapper, C_null(Type::i8p(cx))], false)\n                 }\n-                ty::AutoAddEnv(store) => {\n+                ty::AdjustAddEnv(store) => {\n                     cx.sess()\n                       .span_bug(e.span,\n                                 format!(\"unexpected static function: {:?}\",\n                                         store).as_slice())\n                 }\n-                ty::AutoDerefRef(ref adj) => {\n+                ty::AdjustDerefRef(ref adj) => {\n                     let mut ty = ety;\n                     // Save the last autoderef in case we can avoid it.\n                     if adj.autoderefs > 0 {"}, {"sha": "1980d67fc47146cb577f081af9acf12c6acff6dd", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -664,7 +664,7 @@ pub struct FunctionDebugContext {\n }\n \n enum FunctionDebugContextRepr {\n-    FunctionDebugContext(Box<FunctionDebugContextData>),\n+    DebugInfo(Box<FunctionDebugContextData>),\n     DebugInfoDisabled,\n     FunctionWithoutDebugInfo,\n }\n@@ -675,7 +675,7 @@ impl FunctionDebugContext {\n                    span: Span)\n                    -> &'a FunctionDebugContextData {\n         match self.repr {\n-            FunctionDebugContext(box ref data) => data,\n+            DebugInfo(box ref data) => data,\n             DebugInfoDisabled => {\n                 cx.sess().span_bug(span,\n                                    FunctionDebugContext::debuginfo_disabled_message());\n@@ -1044,7 +1044,7 @@ pub fn set_source_location(fcx: &FunctionContext,\n             set_debug_location(fcx.ccx, UnknownLocation);\n             return;\n         }\n-        FunctionDebugContext(box ref function_debug_context) => {\n+        DebugInfo(box ref function_debug_context) => {\n             let cx = fcx.ccx;\n \n             debug!(\"set_source_location: {}\", cx.sess().codemap().span_to_string(span));\n@@ -1082,7 +1082,7 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n /// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n     match fcx.debug_context.repr {\n-        FunctionDebugContext(box ref data) => {\n+        DebugInfo(box ref data) => {\n             data.source_locations_enabled.set(true)\n         },\n         _ => { /* safe to ignore */ }\n@@ -1291,7 +1291,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                        fn_metadata,\n                        &mut *fn_debug_context.scope_map.borrow_mut());\n \n-    return FunctionDebugContext { repr: FunctionDebugContext(fn_debug_context) };\n+    return FunctionDebugContext { repr: DebugInfo(fn_debug_context) };\n \n     fn get_function_signature(cx: &CrateContext,\n                               fn_ast_id: ast::NodeId,\n@@ -3134,7 +3134,7 @@ fn DIB(cx: &CrateContext) -> DIBuilderRef {\n \n fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n     match fcx.debug_context.repr {\n-        FunctionDebugContext(_) => false,\n+        DebugInfo(_) => false,\n         _ => true\n     }\n }"}, {"sha": "75c28477414a92309395079ece1abe56f3a61d05", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -64,7 +64,7 @@ use middle::trans::inline;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n-use middle::ty::{AutoDerefRef, AutoAddEnv, AutoUnsafe};\n+use middle::ty::{AdjustDerefRef, AdjustAddEnv, AutoUnsafe};\n use middle::ty::{AutoPtr};\n use middle::ty;\n use middle::typeck;\n@@ -189,10 +189,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"unadjusted datum for expr {}: {}\",\n            expr.id, datum.to_string(bcx.ccx()));\n     match adjustment {\n-        AutoAddEnv(..) => {\n+        AdjustAddEnv(..) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n-        AutoDerefRef(ref adj) => {\n+        AdjustDerefRef(ref adj) => {\n             let (autoderefs, use_autoref) = match adj.autoref {\n                 // Extracting a value from a box counts as a deref, but if we are\n                 // just converting Box<[T, ..n]> to Box<[T]> we aren't really doing"}, {"sha": "844ee0a60c67279336fc4b27b9969ffcb30e45bc", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -131,7 +131,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n-        typeck::MethodParam(typeck::MethodParam {\n+        typeck::MethodTypeParam(typeck::MethodParam {\n             trait_ref: ref trait_ref,\n             method_num: method_num\n         }) => {\n@@ -147,7 +147,7 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                        method_num, origin)\n         }\n \n-        typeck::MethodObject(ref mt) => {\n+        typeck::MethodTraitObject(ref mt) => {\n             let self_expr = match self_expr {\n                 Some(self_expr) => self_expr,\n                 None => {\n@@ -243,7 +243,7 @@ pub fn trans_static_method_callee(bcx: Block,\n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:\n     match vtbl {\n-        traits::VtableImpl(traits::VtableImpl {\n+        traits::VtableImpl(traits::VtableImplData {\n             impl_def_id: impl_did,\n             substs: impl_substs,\n             nested: _ }) =>\n@@ -562,7 +562,7 @@ pub fn get_vtable(bcx: Block,\n                                         trait_ref.clone());\n         match vtable {\n             traits::VtableImpl(\n-                traits::VtableImpl {\n+                traits::VtableImplData {\n                     impl_def_id: id,\n                     substs: substs,\n                     nested: _ }) => {"}, {"sha": "33ade80afd3cf12c25b73cc5ad830fd11c055b7e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -277,8 +277,8 @@ pub enum Variance {\n \n #[deriving(Clone)]\n pub enum AutoAdjustment {\n-    AutoAddEnv(ty::TraitStore),\n-    AutoDerefRef(AutoDerefRef)\n+    AdjustAddEnv(ty::TraitStore),\n+    AdjustDerefRef(AutoDerefRef)\n }\n \n #[deriving(Clone, PartialEq)]\n@@ -350,7 +350,7 @@ fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n // returns the region of the borrowed reference.\n pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n     match adj {\n-        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n             let (b, _, r) = autoref_object_region(autoref);\n             if b {\n                 r\n@@ -365,7 +365,7 @@ pub fn adjusted_object_region(adj: &AutoAdjustment) -> Option<Region> {\n // Returns true if there is a trait cast at the bottom of the adjustment.\n pub fn adjust_is_object(adj: &AutoAdjustment) -> bool {\n     match adj {\n-        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n             let (b, _, _) = autoref_object_region(autoref);\n             b\n         }\n@@ -407,7 +407,7 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n     }\n \n     match adj {\n-        &AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n+        &AdjustDerefRef(AutoDerefRef{autoref: Some(ref autoref), ..}) => {\n             type_of_autoref(cx, autoref)\n         }\n         _ => None\n@@ -3423,7 +3423,7 @@ pub fn adjust_ty(cx: &ctxt,\n     return match adjustment {\n         Some(adjustment) => {\n             match *adjustment {\n-                AutoAddEnv(store) => {\n+                AdjustAddEnv(store) => {\n                     match ty::get(unadjusted_ty).sty {\n                         ty::ty_bare_fn(ref b) => {\n                             let bounds = ty::ExistentialBounds {\n@@ -3449,7 +3449,7 @@ pub fn adjust_ty(cx: &ctxt,\n                     }\n                 }\n \n-                AutoDerefRef(ref adj) => {\n+                AdjustDerefRef(ref adj) => {\n                     let mut adjusted_ty = unadjusted_ty;\n \n                     if !ty::type_is_error(adjusted_ty) {\n@@ -3582,12 +3582,12 @@ pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n                               .trait_did(typer.tcx());\n             lookup_trait_def(typer.tcx(), def_id).generics.types.clone()\n         }\n-        typeck::MethodParam(typeck::MethodParam{\n+        typeck::MethodTypeParam(typeck::MethodParam{\n             trait_ref: ref trait_ref,\n             method_num: n_mth,\n             ..\n         }) |\n-        typeck::MethodObject(typeck::MethodObject{\n+        typeck::MethodTraitObject(typeck::MethodObject{\n                 trait_ref: ref trait_ref,\n                 method_num: n_mth,\n                 .."}, {"sha": "2e964c457bf29782d276dd506f7f433f90c38e09", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -353,9 +353,9 @@ impl TypeFoldable for traits::Obligation {\n     }\n }\n \n-impl<N:TypeFoldable> TypeFoldable for traits::VtableImpl<N> {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImpl<N> {\n-        traits::VtableImpl {\n+impl<N:TypeFoldable> TypeFoldable for traits::VtableImplData<N> {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableImplData<N> {\n+        traits::VtableImplData {\n             impl_def_id: self.impl_def_id,\n             substs: self.substs.fold_with(folder),\n             nested: self.nested.fold_with(folder),\n@@ -374,9 +374,9 @@ impl<N:TypeFoldable> TypeFoldable for traits::Vtable<N> {\n     }\n }\n \n-impl TypeFoldable for traits::VtableParam {\n-    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParam {\n-        traits::VtableParam {\n+impl TypeFoldable for traits::VtableParamData {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableParamData {\n+        traits::VtableParamData {\n             bound: self.bound.fold_with(folder),\n         }\n     }"}, {"sha": "7d28a63d93578823b35cd4d1c4a8339477734523", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -90,8 +90,8 @@ use middle::typeck::check::{FnCtxt, PreferMutLvalue, impl_self_ty};\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::MethodCallee;\n-use middle::typeck::{MethodOrigin, MethodParam};\n-use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject};\n+use middle::typeck::{MethodOrigin, MethodParam, MethodTypeParam};\n+use middle::typeck::{MethodStatic, MethodStaticUnboxedClosure, MethodObject, MethodTraitObject};\n use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use middle::typeck::TypeAndSubsts;\n use util::common::indenter;\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_match_condition: RcvrMatchesIfObject(did),\n                     rcvr_substs: new_trait_ref.substs.clone(),\n                     method_ty: Rc::new(m),\n-                    origin: MethodObject(MethodObject {\n+                    origin: MethodTraitObject(MethodObject {\n                         trait_ref: new_trait_ref,\n                         object_trait_id: did,\n                         method_num: method_num,\n@@ -702,7 +702,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     rcvr_match_condition: condition,\n                     rcvr_substs: trait_ref.substs.clone(),\n                     method_ty: m,\n-                    origin: MethodParam(MethodParam {\n+                    origin: MethodTypeParam(MethodParam {\n                         trait_ref: trait_ref,\n                         method_num: method_num,\n                     })\n@@ -874,7 +874,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n         }\n \n         let (self_ty, auto_deref_ref) = self.consider_reborrow(self_ty, autoderefs);\n-        let adjustment = Some((self.self_expr.unwrap().id, ty::AutoDerefRef(auto_deref_ref)));\n+        let adjustment = Some((self.self_expr.unwrap().id, ty::AdjustDerefRef(auto_deref_ref)));\n \n         match self.search_for_method(self_ty) {\n             None => None,\n@@ -1159,7 +1159,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                             self.fcx.write_adjustment(\n                                 self_expr_id,\n                                 self.span,\n-                                ty::AutoDerefRef(ty::AutoDerefRef {\n+                                ty::AdjustDerefRef(ty::AutoDerefRef {\n                                     autoderefs: autoderefs,\n                                     autoref: Some(kind(region, *mutbl))\n                                 }));\n@@ -1245,7 +1245,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                        candidate_a.repr(self.tcx()),\n                        candidate_b.repr(self.tcx()));\n                 match (&candidate_a.origin, &candidate_b.origin) {\n-                    (&MethodParam(ref p1), &MethodParam(ref p2)) => {\n+                    (&MethodTypeParam(ref p1), &MethodTypeParam(ref p2)) => {\n                         let same_trait =\n                             p1.trait_ref.def_id == p2.trait_ref.def_id;\n                         let same_method =\n@@ -1330,7 +1330,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         let fn_sig = &bare_fn_ty.sig;\n         let inputs = match candidate.origin {\n-            MethodObject(..) => {\n+            MethodTraitObject(..) => {\n                 // For annoying reasons, we've already handled the\n                 // substitution of self for object calls.\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n@@ -1403,11 +1403,11 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n \n         match candidate.origin {\n             MethodStatic(..) |\n-            MethodParam(..) |\n+            MethodTypeParam(..) |\n             MethodStaticUnboxedClosure(..) => {\n                 return; // not a call to a trait instance\n             }\n-            MethodObject(..) => {}\n+            MethodTraitObject(..) => {}\n         }\n \n         match candidate.method_ty.explicit_self {\n@@ -1463,8 +1463,8 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStaticUnboxedClosure(_) => bad = false,\n             // FIXME: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n-            MethodParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n-            MethodObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n+            MethodTypeParam(MethodParam { trait_ref: ref trait_ref, .. }) |\n+            MethodTraitObject(MethodObject { trait_ref: ref trait_ref, .. }) => {\n                 bad = self.tcx().destructor_for_type.borrow()\n                           .contains_key(&trait_ref.def_id);\n             }\n@@ -1612,10 +1612,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n             MethodStaticUnboxedClosure(did) => {\n                 self.report_static_candidate(idx, did)\n             }\n-            MethodParam(ref mp) => {\n+            MethodTypeParam(ref mp) => {\n                 self.report_param_candidate(idx, mp.trait_ref.def_id)\n             }\n-            MethodObject(ref mo) => {\n+            MethodTraitObject(ref mo) => {\n                 self.report_trait_candidate(idx, mo.trait_ref.def_id)\n             }\n         }"}, {"sha": "a8b2e0bbff257c2d929a099401b550382dd68769", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -1702,7 +1702,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.write_adjustment(\n             node_id,\n             span,\n-            ty::AutoDerefRef(ty::AutoDerefRef {\n+            ty::AdjustDerefRef(ty::AutoDerefRef {\n                 autoderefs: derefs,\n                 autoref: None })\n         );\n@@ -1728,8 +1728,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        span: Span,\n                                        adj: &ty::AutoAdjustment) {\n         match *adj {\n-            ty::AutoAddEnv(..) => { }\n-            ty::AutoDerefRef(ref d_r) => {\n+            ty::AdjustAddEnv(..) => { }\n+            ty::AdjustDerefRef(ref d_r) => {\n                 match d_r.autoref {\n                     Some(ref a_r) => {\n                         self.register_autoref_obligations(span, a_r);"}, {"sha": "d0791191c0fc090ae4672b8591be939206aa51fa", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -590,7 +590,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n     for &adjustment in rcx.fcx.inh.adjustments.borrow().find(&expr.id).iter() {\n         debug!(\"adjustment={:?}\", adjustment);\n         match *adjustment {\n-            ty::AutoDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n+            ty::AdjustDerefRef(ty::AutoDerefRef {autoderefs, autoref: ref opt_autoref}) => {\n                 let expr_ty = rcx.resolve_node_type(expr.id);\n                 constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n                 for autoref in opt_autoref.iter() {"}, {"sha": "0022efd845e30f1d88765f000f3f03b9124b6f3a", "filename": "src/librustc/middle/typeck/check/vtable2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable2.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -13,7 +13,7 @@ use middle::traits;\n use middle::traits::{SelectionError, Overflow,\n                      OutputTypeParameterMismatch, Unimplemented};\n use middle::traits::{Obligation, obligation_for_builtin_bound};\n-use middle::traits::{FulfillmentError, Ambiguity};\n+use middle::traits::{FulfillmentError, CodeSelectionError, CodeAmbiguity};\n use middle::traits::{ObligationCause};\n use middle::ty;\n use middle::typeck::check::{FnCtxt,\n@@ -244,10 +244,10 @@ pub fn report_fulfillment_errors(fcx: &FnCtxt,\n pub fn report_fulfillment_error(fcx: &FnCtxt,\n                                 error: &FulfillmentError) {\n     match error.code {\n-        SelectionError(ref e) => {\n+        CodeSelectionError(ref e) => {\n             report_selection_error(fcx, &error.obligation, e);\n         }\n-        Ambiguity => {\n+        CodeAmbiguity => {\n             maybe_report_ambiguity(fcx, &error.obligation);\n         }\n     }"}, {"sha": "e2a04116f9008f2b82ceae2b742f8aec83643b50", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -282,7 +282,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             Some(adjustment) => {\n                 let adj_object = ty::adjust_is_object(&adjustment);\n                 let resolved_adjustment = match adjustment {\n-                    ty::AutoAddEnv(store) => {\n+                    ty::AdjustAddEnv(store) => {\n                         // FIXME(eddyb) #2190 Allow only statically resolved\n                         // bare functions to coerce to a closure to avoid\n                         // constructing (slower) indirect call wrappers.\n@@ -298,10 +298,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             }\n                         }\n \n-                        ty::AutoAddEnv(self.resolve(&store, reason))\n+                        ty::AdjustAddEnv(self.resolve(&store, reason))\n                     }\n \n-                    ty::AutoDerefRef(adj) => {\n+                    ty::AdjustDerefRef(adj) => {\n                         for autoderef in range(0, adj.autoderefs) {\n                             let method_call = MethodCall::autoderef(id, autoderef);\n                             self.visit_method_map_entry(reason, method_call);\n@@ -312,7 +312,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                             self.visit_method_map_entry(reason, method_call);\n                         }\n \n-                        ty::AutoDerefRef(ty::AutoDerefRef {\n+                        ty::AdjustDerefRef(ty::AutoDerefRef {\n                             autoderefs: adj.autoderefs,\n                             autoref: self.resolve(&adj.autoref, reason),\n                         })"}, {"sha": "7f9f569c37ea2f72c2b90ca7c13fc5f4467cb0e1", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::subst;\n-use middle::ty::{AutoPtr, AutoDerefRef, AutoUnsize, AutoUnsafe};\n+use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n@@ -270,7 +270,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                      mt {ty: inner_ty, mutbl: mutbl_b});\n         try!(sub.tys(a_borrowed, b));\n \n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AdjustDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(AutoPtr(r_borrow, mutbl_b, None))\n         })))\n@@ -295,7 +295,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 let unsized_ty = ty::mk_slice(self.get_ref().infcx.tcx, r_borrow,\n                                               mt {ty: t_a, mutbl: mutbl_b});\n                 try!(self.get_ref().infcx.try(|| sub.tys(unsized_ty, b)));\n-                Ok(Some(AutoDerefRef(AutoDerefRef {\n+                Ok(Some(AdjustDerefRef(AutoDerefRef {\n                     autoderefs: 0,\n                     autoref: Some(ty::AutoPtr(r_borrow,\n                                               mutbl_b,\n@@ -343,7 +343,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n                                                           Some(box AutoUnsize(kind))))\n@@ -366,7 +366,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n                                                              Some(box AutoUnsize(kind))))\n@@ -384,7 +384,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({:?}))\", kind);\n-                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: 1,\n                                 autoref: Some(ty::AutoUnsizeUniq(kind))\n                             })))\n@@ -537,7 +537,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                     let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n-                    Ok(Some(AutoDerefRef(AutoDerefRef {\n+                    Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,\n                         autoref: Some(mk_adjust())\n                     })))\n@@ -593,7 +593,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 _ => return self.subtype(a, b)\n             };\n \n-            let adj = ty::AutoAddEnv(fn_ty_b.store);\n+            let adj = ty::AdjustAddEnv(fn_ty_b.store);\n             let a_closure = ty::mk_closure(self.get_ref().infcx.tcx,\n                                            ty::ClosureTy {\n                                                 sig: fn_ty_a.sig.clone(),\n@@ -630,7 +630,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n         // regionck knows that the region for `a` must be valid here.\n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n+        Ok(Some(AdjustDerefRef(AutoDerefRef {\n             autoderefs: 1,\n             autoref: Some(ty::AutoUnsafe(mutbl_b, None))\n         })))"}, {"sha": "e93ad056051f5bb3723ffbb4b0f0238a2414c5ea", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -102,10 +102,10 @@ pub enum MethodOrigin {\n     MethodStaticUnboxedClosure(ast::DefId),\n \n     // method invoked on a type parameter with a bounded trait\n-    MethodParam(MethodParam),\n+    MethodTypeParam(MethodParam),\n \n     // method invoked on a trait instance\n-    MethodObject(MethodObject),\n+    MethodTraitObject(MethodObject),\n \n }\n "}, {"sha": "88e6f0ad186c6cd2bed5752bf11e248c8f9a1df0", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -13,7 +13,7 @@\n use lint::{LintPassObject, LintId, Lint};\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, LetSyntaxTT, ItemDecorator, ItemModifier};\n+use syntax::ext::base::{IdentTT, LetSyntaxTT, Decorator, Modifier};\n use syntax::ext::base::{MacroExpanderFn};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -61,8 +61,8 @@ impl Registry {\n         self.syntax_exts.push((name, match extension {\n             NormalTT(ext, _) => NormalTT(ext, Some(self.krate_span)),\n             IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n-            ItemDecorator(ext) => ItemDecorator(ext),\n-            ItemModifier(ext) => ItemModifier(ext),\n+            Decorator(ext) => Decorator(ext),\n+            Modifier(ext) => Modifier(ext),\n             // there's probably a nicer way to signal this:\n             LetSyntaxTT(_, _) => fail!(\"can't register a new LetSyntax!\"),\n         }));"}, {"sha": "5b83f024309bf34acb582b6f0f9cbee42932e5b2", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -962,10 +962,10 @@ impl Repr for typeck::MethodOrigin {\n             &typeck::MethodStaticUnboxedClosure(def_id) => {\n                 format!(\"MethodStaticUnboxedClosure({})\", def_id.repr(tcx))\n             }\n-            &typeck::MethodParam(ref p) => {\n+            &typeck::MethodTypeParam(ref p) => {\n                 p.repr(tcx)\n             }\n-            &typeck::MethodObject(ref p) => {\n+            &typeck::MethodTraitObject(ref p) => {\n                 p.repr(tcx)\n             }\n         }"}, {"sha": "f722a5d260daff870ac284fcd8d6bf357ebbf65c", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -325,11 +325,11 @@ pub enum AtomicOrdering {\n // Consts for the LLVMCodeGenFileType type (in include/llvm/c/TargetMachine.h)\n #[repr(C)]\n pub enum FileType {\n-    AssemblyFile = 0,\n-    ObjectFile = 1\n+    AssemblyFileType = 0,\n+    ObjectFileType = 1\n }\n \n-pub enum Metadata {\n+pub enum MetadataType {\n     MD_dbg = 0,\n     MD_tbaa = 1,\n     MD_prof = 2,"}, {"sha": "b4d44aab239214b1d068c74c6be8fea4efb4a00a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -99,7 +99,7 @@ pub struct Crate {\n     pub name: String,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n-    pub primitives: Vec<Primitive>,\n+    pub primitives: Vec<PrimitiveType>,\n }\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n@@ -147,7 +147,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n                     ModuleItem(ref mut m) => m,\n                     _ => continue,\n                 };\n-                let prim = match Primitive::find(child.attrs.as_slice()) {\n+                let prim = match PrimitiveType::find(child.attrs.as_slice()) {\n                     Some(prim) => prim,\n                     None => continue,\n                 };\n@@ -187,7 +187,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n pub struct ExternalCrate {\n     pub name: String,\n     pub attrs: Vec<Attribute>,\n-    pub primitives: Vec<Primitive>,\n+    pub primitives: Vec<PrimitiveType>,\n }\n \n impl Clean<ExternalCrate> for cstore::crate_metadata {\n@@ -202,7 +202,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n                     _ => return\n                 };\n                 let attrs = inline::load_attrs(cx, tcx, did);\n-                Primitive::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n+                PrimitiveType::find(attrs.as_slice()).map(|prim| primitives.push(prim));\n             })\n         });\n         ExternalCrate {\n@@ -316,7 +316,7 @@ pub enum ItemEnum {\n     /// `static`s from an extern block\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n-    PrimitiveItem(Primitive),\n+    PrimitiveItem(PrimitiveType),\n     AssociatedTypeItem,\n }\n \n@@ -901,7 +901,7 @@ impl Clean<RetStyle> for ast::RetStyle {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct Trait {\n-    pub items: Vec<TraitItem>,\n+    pub items: Vec<TraitMethod>,\n     pub generics: Generics,\n     pub bounds: Vec<TyParamBound>,\n }\n@@ -931,13 +931,13 @@ impl Clean<Type> for ast::TraitRef {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub enum TraitItem {\n+pub enum TraitMethod {\n     RequiredMethod(Item),\n     ProvidedMethod(Item),\n     TypeTraitItem(Item),\n }\n \n-impl TraitItem {\n+impl TraitMethod {\n     pub fn is_req(&self) -> bool {\n         match self {\n             &RequiredMethod(..) => true,\n@@ -959,8 +959,8 @@ impl TraitItem {\n     }\n }\n \n-impl Clean<TraitItem> for ast::TraitItem {\n-    fn clean(&self, cx: &DocContext) -> TraitItem {\n+impl Clean<TraitMethod> for ast::TraitItem {\n+    fn clean(&self, cx: &DocContext) -> TraitMethod {\n         match self {\n             &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n             &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n@@ -970,13 +970,13 @@ impl Clean<TraitItem> for ast::TraitItem {\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n-pub enum ImplItem {\n+pub enum ImplMethod {\n     MethodImplItem(Item),\n     TypeImplItem(Item),\n }\n \n-impl Clean<ImplItem> for ast::ImplItem {\n-    fn clean(&self, cx: &DocContext) -> ImplItem {\n+impl Clean<ImplMethod> for ast::ImplItem {\n+    fn clean(&self, cx: &DocContext) -> ImplMethod {\n         match self {\n             &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n             &ast::TypeImplItem(ref t) => TypeImplItem(t.clean(cx)),\n@@ -1058,7 +1058,7 @@ pub enum Type {\n     /// For references to self\n     Self(ast::DefId),\n     /// Primitives are just the fixed-size numeric types (plus int/uint/float), and char.\n-    Primitive(Primitive),\n+    Primitive(PrimitiveType),\n     Closure(Box<ClosureDecl>),\n     Proc(Box<ClosureDecl>),\n     /// extern \"ABI\" fn\n@@ -1080,7 +1080,7 @@ pub enum Type {\n }\n \n #[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n-pub enum Primitive {\n+pub enum PrimitiveType {\n     Int, I8, I16, I32, I64,\n     Uint, U8, U16, U32, U64,\n     F32, F64,\n@@ -1104,8 +1104,8 @@ pub enum TypeKind {\n     TypeTypedef,\n }\n \n-impl Primitive {\n-    fn from_str(s: &str) -> Option<Primitive> {\n+impl PrimitiveType {\n+    fn from_str(s: &str) -> Option<PrimitiveType> {\n         match s.as_slice() {\n             \"int\" => Some(Int),\n             \"i8\" => Some(I8),\n@@ -1129,7 +1129,7 @@ impl Primitive {\n         }\n     }\n \n-    fn find(attrs: &[Attribute]) -> Option<Primitive> {\n+    fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n         for attr in attrs.iter() {\n             let list = match *attr {\n                 List(ref k, ref l) if k.as_slice() == \"doc\" => l,\n@@ -1141,7 +1141,7 @@ impl Primitive {\n                         if k.as_slice() == \"primitive\" => v.as_slice(),\n                     _ => continue,\n                 };\n-                match Primitive::from_str(value) {\n+                match PrimitiveType::from_str(value) {\n                     Some(p) => return Some(p),\n                     None => {}\n                 }"}, {"sha": "b771473473c115b6be6e2803abf93557450fcd9d", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -40,8 +40,8 @@ pub trait DocFolder {\n                 EnumItem(i)\n             },\n             TraitItem(mut i) => {\n-                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitItem)\n-                        -> Option<TraitItem> {\n+                fn vtrm<T: DocFolder>(this: &mut T, trm: TraitMethod)\n+                        -> Option<TraitMethod> {\n                     match trm {\n                         RequiredMethod(it) => {\n                             match this.fold_item(it) {"}, {"sha": "c807c180e640ee4301f1628501298c964e291b76", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -277,7 +277,7 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n }\n \n fn primitive_link(f: &mut fmt::Formatter,\n-                  prim: clean::Primitive,\n+                  prim: clean::PrimitiveType,\n                   name: &str) -> fmt::Result {\n     let m = cache_key.get().unwrap();\n     let mut needs_termination = false;"}, {"sha": "cf625d4ddfc799ebd06afe33bfb1f004adbbbe4c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -177,7 +177,7 @@ pub struct Cache {\n     pub extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n \n     /// Cache of where documentation for primitives can be found.\n-    pub primitive_locations: HashMap<clean::Primitive, ast::CrateNum>,\n+    pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n \n     /// Set of definitions which have been inlined from external crates.\n     pub inlined: HashSet<ast::DefId>,\n@@ -1637,15 +1637,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                                   _ => false,\n                               }\n                           })\n-                          .collect::<Vec<&clean::TraitItem>>();\n+                          .collect::<Vec<&clean::TraitMethod>>();\n     let provided = t.items.iter()\n                           .filter(|m| {\n                               match **m {\n                                   clean::ProvidedMethod(_) => true,\n                                   _ => false,\n                               }\n                           })\n-                          .collect::<Vec<&clean::TraitItem>>();\n+                          .collect::<Vec<&clean::TraitMethod>>();\n \n     if t.items.len() == 0 {\n         try!(write!(w, \"{{ }}\"));\n@@ -1671,7 +1671,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     // Trait documentation\n     try!(document(w, it));\n \n-    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitItem)\n+    fn trait_item(w: &mut fmt::Formatter, m: &clean::TraitMethod)\n                   -> fmt::Result {\n         try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n                     shortty(m.item()),\n@@ -2180,7 +2180,7 @@ fn item_macro(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n-                  _p: &clean::Primitive) -> fmt::Result {\n+                  _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n     render_methods(w, it)\n }"}, {"sha": "f7d430377230c4ffbac6e706fbecd09b71dbf25c", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -21,7 +21,7 @@ use syntax::attr::{Deprecated, Experimental, Unstable, Stable, Frozen, Locked};\n use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, StructItem, Struct, EnumItem, Enum};\n-use clean::{ImplItem, Impl, Trait, TraitItem, ProvidedMethod, RequiredMethod};\n+use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem};\n \n #[deriving(Zero, Encodable, Decodable, PartialEq, Eq)]\n@@ -128,7 +128,7 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             items: ref trait_items,\n             ..\n         }) => {\n-            fn extract_item<'a>(trait_item: &'a TraitItem) -> &'a Item {\n+            fn extract_item<'a>(trait_item: &'a TraitMethod) -> &'a Item {\n                 match *trait_item {\n                     ProvidedMethod(ref item) |\n                     RequiredMethod(ref item) |"}, {"sha": "ba5a4dc3f2195e6379c860a3545100c2708c1cff", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -67,7 +67,7 @@ use task::{Task, LocalStorage};\n pub type Key<T> = &'static KeyValue<T>;\n \n #[allow(missing_doc)]\n-pub enum KeyValue<T> { Key }\n+pub enum KeyValue<T> { KeyValueKey }\n \n // The task-local-map stores all TLD information for the currently running\n // task. It is stored as an owned pointer into the runtime, and it's only\n@@ -417,7 +417,7 @@ mod tests {\n \n     #[test]\n     fn test_tls_multitask() {\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         my_key.replace(Some(\"parent data\".to_string()));\n         task::spawn(proc() {\n             // TLD shouldn't carry over.\n@@ -435,15 +435,15 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite() {\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         my_key.replace(Some(\"first data\".to_string()));\n         my_key.replace(Some(\"next data\".to_string())); // Shouldn't leak.\n         assert!(my_key.get().unwrap().as_slice() == \"next data\");\n     }\n \n     #[test]\n     fn test_tls_pop() {\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         my_key.replace(Some(\"weasel\".to_string()));\n         assert!(my_key.replace(None).unwrap() == \"weasel\".to_string());\n         // Pop must remove the data from the map.\n@@ -458,17 +458,17 @@ mod tests {\n         // to get recorded as something within a rust stack segment. Then a\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n-        static my_key: Key<String> = &Key;\n+        static my_key: Key<String> = &KeyValueKey;\n         task::spawn(proc() {\n             my_key.replace(Some(\"hax\".to_string()));\n         });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n-        static str_key: Key<String> = &Key;\n-        static box_key: Key<Gc<()>> = &Key;\n-        static int_key: Key<int> = &Key;\n+        static str_key: Key<String> = &KeyValueKey;\n+        static box_key: Key<Gc<()>> = &KeyValueKey;\n+        static int_key: Key<int> = &KeyValueKey;\n         task::spawn(proc() {\n             str_key.replace(Some(\"string data\".to_string()));\n             box_key.replace(Some(box(GC) ()));\n@@ -478,9 +478,9 @@ mod tests {\n \n     #[test]\n     fn test_tls_overwrite_multiple_types() {\n-        static str_key: Key<String> = &Key;\n-        static box_key: Key<Gc<()>> = &Key;\n-        static int_key: Key<int> = &Key;\n+        static str_key: Key<String> = &KeyValueKey;\n+        static box_key: Key<Gc<()>> = &KeyValueKey;\n+        static int_key: Key<int> = &KeyValueKey;\n         task::spawn(proc() {\n             str_key.replace(Some(\"string data\".to_string()));\n             str_key.replace(Some(\"string data 2\".to_string()));\n@@ -497,9 +497,9 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_tls_cleanup_on_failure() {\n-        static str_key: Key<String> = &Key;\n-        static box_key: Key<Gc<()>> = &Key;\n-        static int_key: Key<int> = &Key;\n+        static str_key: Key<String> = &KeyValueKey;\n+        static box_key: Key<Gc<()>> = &KeyValueKey;\n+        static int_key: Key<int> = &KeyValueKey;\n         str_key.replace(Some(\"parent data\".to_string()));\n         box_key.replace(Some(box(GC) ()));\n         task::spawn(proc() {\n@@ -524,7 +524,7 @@ mod tests {\n                 self.tx.send(());\n             }\n         }\n-        static key: Key<Dropper> = &Key;\n+        static key: Key<Dropper> = &KeyValueKey;\n         let _ = task::try(proc() {\n             key.replace(Some(Dropper{ tx: tx }));\n         });\n@@ -535,14 +535,14 @@ mod tests {\n \n     #[test]\n     fn test_static_pointer() {\n-        static key: Key<&'static int> = &Key;\n+        static key: Key<&'static int> = &KeyValueKey;\n         static VALUE: int = 0;\n         key.replace(Some(&VALUE));\n     }\n \n     #[test]\n     fn test_owned() {\n-        static key: Key<Box<int>> = &Key;\n+        static key: Key<Box<int>> = &KeyValueKey;\n         key.replace(Some(box 1));\n \n         {\n@@ -559,11 +559,11 @@ mod tests {\n \n     #[test]\n     fn test_same_key_type() {\n-        static key1: Key<int> = &Key;\n-        static key2: Key<int> = &Key;\n-        static key3: Key<int> = &Key;\n-        static key4: Key<int> = &Key;\n-        static key5: Key<int> = &Key;\n+        static key1: Key<int> = &KeyValueKey;\n+        static key2: Key<int> = &KeyValueKey;\n+        static key3: Key<int> = &KeyValueKey;\n+        static key4: Key<int> = &KeyValueKey;\n+        static key5: Key<int> = &KeyValueKey;\n         key1.replace(Some(1));\n         key2.replace(Some(2));\n         key3.replace(Some(3));\n@@ -580,7 +580,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_nested_get_set1() {\n-        static key: Key<int> = &Key;\n+        static key: Key<int> = &KeyValueKey;\n         assert_eq!(key.replace(Some(4)), None);\n \n         let _k = key.get();\n@@ -602,7 +602,7 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_none(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(None);\n         b.iter(|| {\n@@ -612,7 +612,7 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_some(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(Some(1u));\n         b.iter(|| {\n@@ -622,7 +622,7 @@ mod tests {\n \n     #[bench]\n     fn bench_replace_none_some(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(Some(0u));\n         b.iter(|| {\n@@ -634,7 +634,7 @@ mod tests {\n \n     #[bench]\n     fn bench_100_keys_replace_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..100] = [Key, ..100];\n+        static keys: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));\n@@ -647,7 +647,7 @@ mod tests {\n \n     #[bench]\n     fn bench_1000_keys_replace_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..1000] = [Key, ..1000];\n+        static keys: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));\n@@ -661,7 +661,7 @@ mod tests {\n \n     #[bench]\n     fn bench_get(b: &mut test::Bencher) {\n-        static key: Key<uint> = &Key;\n+        static key: Key<uint> = &KeyValueKey;\n         let _clear = ClearKey(key);\n         key.replace(Some(42));\n         b.iter(|| {\n@@ -671,7 +671,7 @@ mod tests {\n \n     #[bench]\n     fn bench_100_keys_get_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..100] = [Key, ..100];\n+        static keys: [KeyValue<uint>, ..100] = [KeyValueKey, ..100];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));\n@@ -684,7 +684,7 @@ mod tests {\n \n     #[bench]\n     fn bench_1000_keys_get_last(b: &mut test::Bencher) {\n-        static keys: [KeyValue<uint>, ..1000] = [Key, ..1000];\n+        static keys: [KeyValue<uint>, ..1000] = [KeyValueKey, ..1000];\n         let _clear = keys.iter().map(ClearKey).collect::<Vec<ClearKey<uint>>>();\n         for (i, key) in keys.iter().enumerate() {\n             key.replace(Some(i));"}, {"sha": "14274ef9f9b04f09ed76fe2f1c68e885b70bfc19", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 53, "deletions": 52, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -28,7 +28,7 @@ Data types that can be encoded are JavaScript types (see the `Json` enum for mor\n * `Boolean`: equivalent to rust's `bool`\n * `Number`: equivalent to rust's `f64`\n * `String`: equivalent to rust's `String`\n-* `Array`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n+* `List`: equivalent to rust's `Vec<T>`, but also allowing objects of different types in the same\n array\n * `Object`: equivalent to rust's `Treemap<String, json::Json>`\n * `Null`\n@@ -201,7 +201,7 @@ use std::io::MemWriter;\n use std::mem::{swap, transmute};\n use std::num::{FPNaN, FPInfinite};\n use std::str::ScalarValue;\n-use std::string::String;\n+use std::string;\n use std::vec::Vec;\n \n use Encodable;\n@@ -212,15 +212,15 @@ pub enum Json {\n     I64(i64),\n     U64(u64),\n     F64(f64),\n-    String(String),\n+    String(string::String),\n     Boolean(bool),\n-    List(List),\n-    Object(Object),\n+    List(JsonList),\n+    Object(JsonObject),\n     Null,\n }\n \n-pub type List = Vec<Json>;\n-pub type Object = TreeMap<String, Json>;\n+pub type JsonList = Vec<Json>;\n+pub type JsonObject = TreeMap<string::String, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n #[deriving(Clone, PartialEq)]\n@@ -257,10 +257,10 @@ pub type BuilderError = ParserError;\n #[deriving(Clone, PartialEq, Show)]\n pub enum DecoderError {\n     ParseError(ParserError),\n-    ExpectedError(String, String),\n-    MissingFieldError(String),\n-    UnknownVariantError(String),\n-    ApplicationError(String)\n+    ExpectedError(string::String, string::String),\n+    MissingFieldError(string::String),\n+    UnknownVariantError(string::String),\n+    ApplicationError(string::String)\n }\n \n /// Returns a readable error string for a given error code.\n@@ -298,9 +298,9 @@ pub fn decode<T: ::Decodable<Decoder, DecoderError>>(s: &str) -> DecodeResult<T>\n }\n \n /// Shortcut function to encode a `T` into a JSON `String`\n-pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+pub fn encode<'a, T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n     let buff = Encoder::buffer_encode(object);\n-    String::from_utf8(buff).unwrap()\n+    string::String::from_utf8(buff).unwrap()\n }\n \n impl fmt::Show for ErrorCode {\n@@ -375,9 +375,9 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n     }\n }\n \n-fn fmt_number_or_null(v: f64) -> String {\n+fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n-        FPNaN | FPInfinite => String::from_str(\"null\"),\n+        FPNaN | FPInfinite => string::String::from_str(\"null\"),\n         _ => f64::to_str_digits(v, 6u)\n     }\n }\n@@ -411,7 +411,7 @@ impl<'a> Encoder<'a> {\n     ///\n     /// Note: this function is deprecated. Consider using `json::encode` instead.\n     #[deprecated = \"Replaced by `json::encode`\"]\n-    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> String {\n+    pub fn str_encode<T: Encodable<Encoder<'a>, io::IoError>>(object: &T) -> string::String {\n         encode(object)\n     }\n }\n@@ -877,15 +877,15 @@ impl Json {\n     }\n \n     /// Encodes a json value into a string\n-    pub fn to_pretty_str(&self) -> String {\n+    pub fn to_pretty_str(&self) -> string::String {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        String::from_utf8(s.unwrap()).unwrap()\n+        string::String::from_utf8(s.unwrap()).unwrap()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n     /// Otherwise, returns None.\n-    pub fn find<'a>(&'a self, key: &String) -> Option<&'a Json>{\n+    pub fn find<'a>(&'a self, key: &string::String) -> Option<&'a Json>{\n         match self {\n             &Object(ref map) => map.find(key),\n             _ => None\n@@ -895,7 +895,7 @@ impl Json {\n     /// Attempts to get a nested Json Object for each key in `keys`.\n     /// If any key is found not to exist, find_path will return None.\n     /// Otherwise, it will return the Json value associated with the final key.\n-    pub fn find_path<'a>(&'a self, keys: &[&String]) -> Option<&'a Json>{\n+    pub fn find_path<'a>(&'a self, keys: &[&string::String]) -> Option<&'a Json>{\n         let mut target = self;\n         for key in keys.iter() {\n             match target.find(*key) {\n@@ -909,7 +909,7 @@ impl Json {\n     /// If the Json value is an Object, performs a depth-first search until\n     /// a value associated with the provided key is found. If no value is found\n     /// or the Json value is not an Object, returns None.\n-    pub fn search<'a>(&'a self, key: &String) -> Option<&'a Json> {\n+    pub fn search<'a>(&'a self, key: &string::String) -> Option<&'a Json> {\n         match self {\n             &Object(ref map) => {\n                 match map.find(key) {\n@@ -937,7 +937,7 @@ impl Json {\n \n     /// If the Json value is an Object, returns the associated TreeMap.\n     /// Returns None otherwise.\n-    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n+    pub fn as_object<'a>(&'a self) -> Option<&'a JsonObject> {\n         match self {\n             &Object(ref map) => Some(map),\n             _ => None\n@@ -951,7 +951,7 @@ impl Json {\n \n     /// If the Json value is a List, returns the associated vector.\n     /// Returns None otherwise.\n-    pub fn as_list<'a>(&'a self) -> Option<&'a List> {\n+    pub fn as_list<'a>(&'a self) -> Option<&'a JsonList> {\n         match self {\n             &List(ref list) => Some(&*list),\n             _ => None\n@@ -1075,15 +1075,15 @@ pub enum JsonEvent {\n     I64Value(i64),\n     U64Value(u64),\n     F64Value(f64),\n-    StringValue(String),\n+    StringValue(string::String),\n     NullValue,\n     Error(ParserError),\n }\n \n #[deriving(PartialEq, Show)]\n enum ParserState {\n     // Parse a value in a list, true means first element.\n-    ParseList(bool),\n+    ParseArray(bool),\n     // Parse ',' or ']' after an element in a list.\n     ParseListComma,\n     // Parse a key:value in an object, true means first element.\n@@ -1191,7 +1191,7 @@ impl Stack {\n     }\n \n     // Used by Parser to insert Key elements at the top of the stack.\n-    fn push_key(&mut self, key: String) {\n+    fn push_key(&mut self, key: string::String) {\n         self.stack.push(InternalKey(self.str_buffer.len() as u16, key.len() as u16));\n         for c in key.as_bytes().iter() {\n             self.str_buffer.push(*c);\n@@ -1502,9 +1502,9 @@ impl<T: Iterator<char>> Parser<T> {\n         Ok(n)\n     }\n \n-    fn parse_str(&mut self) -> Result<String, ParserError> {\n+    fn parse_str(&mut self) -> Result<string::String, ParserError> {\n         let mut escape = false;\n-        let mut res = String::new();\n+        let mut res = string::String::new();\n \n         loop {\n             self.bump();\n@@ -1574,7 +1574,7 @@ impl<T: Iterator<char>> Parser<T> {\n             // The only paths where the loop can spin a new iteration\n             // are in the cases ParseListComma and ParseObjectComma if ','\n             // is parsed. In these cases the state is set to (respectively)\n-            // ParseList(false) and ParseObject(false), which always return,\n+            // ParseArray(false) and ParseObject(false), which always return,\n             // so there is no risk of getting stuck in an infinite loop.\n             // All other paths return before the end of the loop's iteration.\n             self.parse_whitespace();\n@@ -1583,7 +1583,7 @@ impl<T: Iterator<char>> Parser<T> {\n                 ParseStart => {\n                     return self.parse_start();\n                 }\n-                ParseList(first) => {\n+                ParseArray(first) => {\n                     return self.parse_list(first);\n                 }\n                 ParseListComma => {\n@@ -1615,7 +1615,7 @@ impl<T: Iterator<char>> Parser<T> {\n         let val = self.parse_value();\n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseList(true) }\n+            ListStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseBeforeFinish }\n         };\n@@ -1647,7 +1647,7 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseList(true) }\n+            ListStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseListComma }\n         };\n@@ -1657,7 +1657,7 @@ impl<T: Iterator<char>> Parser<T> {\n     fn parse_list_comma_or_end(&mut self) -> Option<JsonEvent> {\n         if self.ch_is(',') {\n             self.stack.bump_index();\n-            self.state = ParseList(false);\n+            self.state = ParseArray(false);\n             self.bump();\n             return None;\n         } else if self.ch_is(']') {\n@@ -1728,7 +1728,7 @@ impl<T: Iterator<char>> Parser<T> {\n \n         self.state = match val {\n             Error(_) => { ParseFinished }\n-            ListStart => { ParseList(true) }\n+            ListStart => { ParseArray(true) }\n             ObjectStart => { ParseObject(true) }\n             _ => { ParseObjectComma }\n         };\n@@ -1830,7 +1830,7 @@ impl<T: Iterator<char>> Builder<T> {\n             Some(F64Value(n)) => { Ok(F64(n)) }\n             Some(BooleanValue(b)) => { Ok(Boolean(b)) }\n             Some(StringValue(ref mut s)) => {\n-                let mut temp = String::new();\n+                let mut temp = string::String::new();\n                 swap(s, &mut temp);\n                 Ok(String(temp))\n             }\n@@ -2034,7 +2034,7 @@ impl ::Decoder<DecoderError> for Decoder {\n         Err(ExpectedError(\"single character string\".to_string(), format!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> DecodeResult<String> {\n+    fn read_str(&mut self) -> DecodeResult<string::String> {\n         debug!(\"read_str\");\n         expect!(self.pop(), String)\n     }\n@@ -2284,7 +2284,7 @@ impl ToJson for bool {\n     fn to_json(&self) -> Json { Boolean(*self) }\n }\n \n-impl ToJson for String {\n+impl ToJson for string::String {\n     fn to_json(&self) -> Json { String((*self).clone()) }\n }\n \n@@ -2328,7 +2328,7 @@ impl<A: ToJson> ToJson for Vec<A> {\n     fn to_json(&self) -> Json { List(self.iter().map(|elt| elt.to_json()).collect()) }\n }\n \n-impl<A: ToJson> ToJson for TreeMap<String, A> {\n+impl<A: ToJson> ToJson for TreeMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2338,7 +2338,7 @@ impl<A: ToJson> ToJson for TreeMap<String, A> {\n     }\n }\n \n-impl<A: ToJson> ToJson for HashMap<String, A> {\n+impl<A: ToJson> ToJson for HashMap<string::String, A> {\n     fn to_json(&self) -> Json {\n         let mut d = TreeMap::new();\n         for (key, value) in self.iter() {\n@@ -2375,7 +2375,7 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use {Encodable, Decodable};\n-    use super::{Encoder, Decoder, Error, Boolean, I64, U64, F64, List, String, Null,\n+    use super::{List, Encoder, Decoder, Error, Boolean, I64, U64, F64, String, Null,\n                 PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n                 MissingFieldError, UnknownVariantError, DecodeResult, DecoderError,\n                 JsonEvent, Parser, StackElement,\n@@ -2386,6 +2386,7 @@ mod tests {\n                 TrailingCharacters, TrailingComma};\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::TreeMap;\n+    use std::string;\n \n     #[deriving(Decodable, Eq, PartialEq, Show)]\n     struct OptionData {\n@@ -2417,22 +2418,22 @@ mod tests {\n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     enum Animal {\n         Dog,\n-        Frog(String, int)\n+        Frog(string::String, int)\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: Vec<String>,\n+        c: Vec<string::String>,\n     }\n \n     #[deriving(PartialEq, Encodable, Decodable, Show)]\n     struct Outer {\n         inner: Vec<Inner>,\n     }\n \n-    fn mk_object(items: &[(String, Json)]) -> Json {\n+    fn mk_object(items: &[(string::String, Json)]) -> Json {\n         let mut d = TreeMap::new();\n \n         for item in items.iter() {\n@@ -2610,7 +2611,7 @@ mod tests {\n                    from_str(a.to_pretty_str().as_slice()).unwrap());\n     }\n \n-    fn with_str_writer(f: |&mut io::Writer|) -> String {\n+    fn with_str_writer(f: |&mut io::Writer|) -> string::String {\n         use std::io::MemWriter;\n         use std::str;\n \n@@ -2678,7 +2679,7 @@ mod tests {\n \n     #[test]\n     fn test_write_none() {\n-        let value: Option<String> = None;\n+        let value: Option<string::String> = None;\n         let s = with_str_writer(|writer| {\n             let mut encoder = Encoder::new(writer);\n             value.encode(&mut encoder).unwrap();\n@@ -2825,7 +2826,7 @@ mod tests {\n                  (\"\\\"\\\\uAB12\\\"\", \"\\uAB12\")];\n \n         for &(i, o) in s.iter() {\n-            let v: String = super::decode(i).unwrap();\n+            let v: string::String = super::decode(i).unwrap();\n             assert_eq!(v.as_slice(), o);\n         }\n     }\n@@ -2959,10 +2960,10 @@ mod tests {\n \n     #[test]\n     fn test_decode_option() {\n-        let value: Option<String> = super::decode(\"null\").unwrap();\n+        let value: Option<string::String> = super::decode(\"null\").unwrap();\n         assert_eq!(value, None);\n \n-        let value: Option<String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n+        let value: Option<string::String> = super::decode(\"\\\"jodhpurs\\\"\").unwrap();\n         assert_eq!(value, Some(\"jodhpurs\".to_string()));\n     }\n \n@@ -2980,7 +2981,7 @@ mod tests {\n     fn test_decode_map() {\n         let s = \"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\n                   \\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n-        let mut map: TreeMap<String, Animal> = super::decode(s).unwrap();\n+        let mut map: TreeMap<string::String, Animal> = super::decode(s).unwrap();\n \n         assert_eq!(map.pop(&\"a\".to_string()), Some(Dog));\n         assert_eq!(map.pop(&\"b\".to_string()), Some(Frog(\"Henry\".to_string(), 349)));\n@@ -2997,13 +2998,13 @@ mod tests {\n     struct DecodeStruct {\n         x: f64,\n         y: bool,\n-        z: String,\n+        z: string::String,\n         w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {\n         A(f64),\n-        B(String)\n+        B(string::String)\n     }\n     fn check_err<T: Decodable<Decoder, DecoderError>>(to_parse: &'static str,\n                                                       expected: DecoderError) {\n@@ -3709,7 +3710,7 @@ mod tests {\n         });\n     }\n \n-    fn big_json() -> String {\n+    fn big_json() -> string::String {\n         let mut src = \"[\\n\".to_string();\n         for _ in range(0i, 500) {\n             src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\"}, {"sha": "86c03708e4041af204044baa1494bbad99e4bf21", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -304,10 +304,10 @@ macro_rules! println(\n #[macro_export]\n macro_rules! local_data_key(\n     ($name:ident: $ty:ty) => (\n-        static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n+        static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n     (pub $name:ident: $ty:ty) => (\n-        pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::Key;\n+        pub static $name: ::std::local_data::Key<$ty> = &::std::local_data::KeyValueKey;\n     );\n )\n "}, {"sha": "b35a945675761364e600015bba6224871f566dc1", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -299,11 +299,11 @@ pub enum SyntaxExtension {\n     /// based upon it.\n     ///\n     /// `#[deriving(...)]` is an `ItemDecorator`.\n-    ItemDecorator(Box<ItemDecorator + 'static>),\n+    Decorator(Box<ItemDecorator + 'static>),\n \n     /// A syntax extension that is attached to an item and modifies it\n     /// in-place.\n-    ItemModifier(Box<ItemModifier + 'static>),\n+    Modifier(Box<ItemModifier + 'static>),\n \n     /// A normal, function-like syntax extension.\n     ///\n@@ -381,7 +381,7 @@ fn initial_syntax_expander_table() -> SyntaxEnv {\n                             builtin_normal_expander(\n                                     ext::log_syntax::expand_syntax_ext));\n     syntax_expanders.insert(intern(\"deriving\"),\n-                            ItemDecorator(box ext::deriving::expand_meta_deriving));\n+                            Decorator(box ext::deriving::expand_meta_deriving));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(intern(\"quote_tokens\"),"}, {"sha": "e173b93e4680862b781320ad48b959527d1f05e0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -252,7 +252,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n             Some(rc) => match *rc {\n-                ItemDecorator(ref dec) => {\n+                Decorator(ref dec) => {\n                     attr::mark_used(attr);\n \n                     fld.cx.bt_push(ExpnInfo {\n@@ -309,7 +309,7 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n     // partition the attributes into ItemModifiers and others\n     let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n         match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n-            Some(rc) => match *rc { ItemModifier(_) => true, _ => false },\n+            Some(rc) => match *rc { Modifier(_) => true, _ => false },\n             _ => false\n         }\n     });\n@@ -328,7 +328,7 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n \n         match fld.cx.syntax_env.find(&intern(mname.get())) {\n             Some(rc) => match *rc {\n-                ItemModifier(ref mac) => {\n+                Modifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,"}, {"sha": "b760c893a106c88608770a2e6f64616f4666a268", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -19,17 +19,18 @@ use parse::token;\n use ptr::P;\n \n use std::collections::HashMap;\n+use std::string;\n \n #[deriving(PartialEq)]\n enum ArgumentType {\n-    Known(String),\n+    Known(string::String),\n     Unsigned,\n     String,\n }\n \n enum Position {\n     Exact(uint),\n-    Named(String),\n+    Named(string::String),\n }\n \n struct Context<'a, 'b:'a> {\n@@ -44,12 +45,12 @@ struct Context<'a, 'b:'a> {\n     /// Note that we keep a side-array of the ordering of the named arguments\n     /// found to be sure that we can translate them in the same order that they\n     /// were declared in.\n-    names: HashMap<String, P<ast::Expr>>,\n-    name_types: HashMap<String, ArgumentType>,\n-    name_ordering: Vec<String>,\n+    names: HashMap<string::String, P<ast::Expr>>,\n+    name_types: HashMap<string::String, ArgumentType>,\n+    name_ordering: Vec<string::String>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n-    literal: String,\n+    literal: string::String,\n \n     /// Collection of the compiled `rt::Argument` structures\n     pieces: Vec<P<ast::Expr>>,\n@@ -58,7 +59,7 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, uint>,\n+    name_positions: HashMap<string::String, uint>,\n     method_statics: Vec<P<ast::Item>>,\n \n     /// Updated as arguments are consumed or methods are entered\n@@ -81,10 +82,10 @@ pub enum Invocation {\n ///           named arguments))\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, allow_method: bool,\n               tts: &[ast::TokenTree])\n-    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n-                            HashMap<String, P<ast::Expr>>)>) {\n+    -> (Invocation, Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<string::String>,\n+                            HashMap<string::String, P<ast::Expr>>)>) {\n     let mut args = Vec::new();\n-    let mut names = HashMap::<String, P<ast::Expr>>::new();\n+    let mut names = HashMap::<string::String, P<ast::Expr>>::new();\n     let mut order = Vec::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n@@ -167,7 +168,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n             parse::String(..) => {}\n-            parse::Argument(ref arg) => {\n+            parse::NextArgument(ref arg) => {\n                 // width/precision first, if they have implicit positional\n                 // parameters it makes more sense to consume them first.\n                 self.verify_count(arg.format.width);\n@@ -222,7 +223,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn describe_num_args(&self) -> String {\n+    fn describe_num_args(&self) -> string::String {\n         match self.args.len() {\n             0 => \"no arguments given\".to_string(),\n             1 => \"there is 1 argument\".to_string(),\n@@ -391,7 +392,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 self.literal.push_str(s);\n                 None\n             }\n-            parse::Argument(ref arg) => {\n+            parse::NextArgument(ref arg) => {\n                 // Translate the position\n                 let pos = match arg.position {\n                     // These two have a direct mapping\n@@ -747,8 +748,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     invocation: Invocation,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<String>,\n-                                    names: HashMap<String, P<ast::Expr>>)\n+                                    name_ordering: Vec<string::String>,\n+                                    names: HashMap<string::String, P<ast::Expr>>)\n                                     -> P<ast::Expr> {\n     let arg_types = Vec::from_fn(args.len(), |_| None);\n     let mut cx = Context {\n@@ -761,7 +762,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         name_ordering: name_ordering,\n         nest_level: 0,\n         next_arg: 0,\n-        literal: String::new(),\n+        literal: string::String::new(),\n         pieces: Vec::new(),\n         str_pieces: Vec::new(),\n         all_pieces_simple: true,"}, {"sha": "f1fdc71b9c6f5672d619369fac16372773b631f8", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -60,7 +60,7 @@\n //! avoid combining it with other lines and making matters even worse.\n \n use std::io;\n-use std::string::String;\n+use std::string;\n \n #[deriving(Clone, PartialEq)]\n pub enum Breaks {\n@@ -82,7 +82,7 @@ pub struct BeginToken {\n \n #[deriving(Clone)]\n pub enum Token {\n-    String(String, int),\n+    String(string::String, int),\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n@@ -107,7 +107,7 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(t: Token) -> String {\n+pub fn tok_str(t: Token) -> string::String {\n     match t {\n         String(s, len) => return format!(\"STR({},{})\", s, len),\n         Break(_) => return \"BREAK\".to_string(),\n@@ -122,12 +122,12 @@ pub fn buf_str(toks: Vec<Token>,\n                left: uint,\n                right: uint,\n                lim: uint)\n-               -> String {\n+               -> string::String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = String::from_str(\"[\");\n+    let mut s = string::String::from_str(\"[\");\n     while i != right && l != 0u {\n         l -= 1u;\n         if i != left {"}, {"sha": "93f773f430d409b75aca60667ced2e5b5c331367", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -41,7 +41,7 @@ enum FormatState {\n #[allow(missing_doc)]\n #[deriving(Clone)]\n pub enum Param {\n-    String(String),\n+    Words(String),\n     Number(int)\n }\n \n@@ -140,8 +140,8 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables)\n                     '{' => state = IntConstant(0),\n                     'l' => if stack.len() > 0 {\n                         match stack.pop().unwrap() {\n-                            String(s) => stack.push(Number(s.len() as int)),\n-                            _         => return Err(\"a non-str was used with %l\".to_string())\n+                            Words(s) => stack.push(Number(s.len() as int)),\n+                            _        => return Err(\"a non-str was used with %l\".to_string())\n                         }\n                     } else { return Err(\"stack is empty\".to_string()) },\n                     '+' => if stack.len() > 1 {\n@@ -543,7 +543,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n             }\n             s\n         }\n-        String(s) => {\n+        Words(s) => {\n             match op {\n                 FormatString => {\n                     let mut s = Vec::from_slice(s.as_bytes());\n@@ -575,7 +575,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n \n #[cfg(test)]\n mod test {\n-    use super::{expand,String,Variables,Number};\n+    use super::{expand,Words,Variables,Number};\n     use std::result::Ok;\n \n     #[test]\n@@ -611,7 +611,7 @@ mod test {\n             assert!(res.is_err(),\n                     \"Op {} succeeded incorrectly with 0 stack entries\", *cap);\n             let p = if *cap == \"%s\" || *cap == \"%l\" {\n-                String(\"foo\".to_string())\n+                Words(\"foo\".to_string())\n             } else {\n                 Number(97)\n             };\n@@ -689,12 +689,12 @@ mod test {\n         let mut varstruct = Variables::new();\n         let vars = &mut varstruct;\n         assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n-                          [String(\"foo\".to_string()),\n-                           String(\"foo\".to_string()),\n-                           String(\"f\".to_string()),\n-                           String(\"foo\".to_string())], vars),\n+                          [Words(\"foo\".to_string()),\n+                           Words(\"foo\".to_string()),\n+                           Words(\"f\".to_string()),\n+                           Words(\"foo\".to_string())], vars),\n                    Ok(\"foofoo ffo\".bytes().collect()));\n-        assert_eq!(expand(b\"%p1%:-4.2s\", [String(\"foo\".to_string())], vars),\n+        assert_eq!(expand(b\"%p1%:-4.2s\", [Words(\"foo\".to_string())], vars),\n                    Ok(\"fo  \".bytes().collect()));\n \n         assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", [Number(1)], vars),"}, {"sha": "befd33fca4eebf6bfb1c58a9da9c40f456b211a3", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -35,7 +35,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_macro(\"identity\", expand_identity);\n     reg.register_syntax_extension(\n         token::intern(\"into_foo\"),\n-        ItemModifier(box expand_into_foo));\n+        Modifier(box expand_into_foo));\n }\n \n fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])"}, {"sha": "6487c704765b352b1454c480461e8e122a3bce80", "filename": "src/test/auxiliary/xcrate_unit_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fxcrate_unit_struct.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -15,7 +15,7 @@\n pub struct Struct;\n \n pub enum Unit {\n-    Unit,\n+    UnitVariant,\n     Argument(Struct)\n }\n "}, {"sha": "bf80626793d6d18cea6fe803e88a9381c5804182", "filename": "src/test/compile-fail/enum-variant-type-2.rs", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-variant-type-2.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum y { x }\n+// Test that enum variants are not actually types.\n \n-enum x {}\n+enum Foo {\n+    Bar\n+}\n \n-pub fn main() {}\n+fn foo(x: Bar) {} //~ERROR found value name used as a type\n+\n+fn main() {}", "previous_filename": "src/test/run-pass/issue-3186.rs"}, {"sha": "93d44f96c8aa0578f4cf7f436c2a871ec6fa4085", "filename": "src/test/compile-fail/enum-variant-type.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fenum-variant-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fenum-variant-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-variant-type.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that enum variants are in the type namespace.\n+\n+enum Foo {\n+    Foo //~ERROR duplicate definition of type or module `Foo`\n+}\n+\n+enum Bar {\n+    Baz\n+}\n+\n+trait Baz {} //~ERROR duplicate definition of type or module `Baz`\n+\n+pub fn main() {}"}, {"sha": "d2d7d800470fe8a22cd3e8734055cc4a65e13238", "filename": "src/test/compile-fail/issue-3008-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-1.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo(bar) }\n+enum foo { foo_(bar) }\n enum bar { bar_none, bar_some(bar) }\n //~^ ERROR illegal recursive enum type; wrap the inner value in a box to make it representable\n "}, {"sha": "1e8f81a05e7f9c51ba67ceb903c68f3f09bb1e33", "filename": "src/test/compile-fail/issue-3008-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3008-2.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum foo { foo(bar) }\n+enum foo { foo_(bar) }\n struct bar { x: bar }\n //~^ ERROR illegal recursive struct type; wrap the inner value in a box to make it representable\n //~^^ ERROR this type cannot be instantiated without an instance of itself"}, {"sha": "c99ec5187b00ffcac8e507396cc0f203c942f306", "filename": "src/test/compile-fail/recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fcompile-fail%2Frecursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum Nil {Nil}\n+enum Nil {NilValue}\n struct Cons<T> {head:int, tail:T}\n trait Dot {fn dot(&self, other:Self) -> int;}\n impl Dot for Nil {\n@@ -29,6 +29,6 @@ fn test<T:Dot> (n:int, i:int, first:T, second:T) ->int {\n   }\n }\n pub fn main() {\n-  let n = test(1, 0, Nil, Nil);\n+  let n = test(1, 0, NilValue, NilValue);\n   println!(\"{}\", n);\n }"}, {"sha": "29a3b965251ec36422a2bc5c487152523e586f57", "filename": "src/test/pretty/tag-blank-lines.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fpretty%2Ftag-blank-lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Fpretty%2Ftag-blank-lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ftag-blank-lines.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -11,8 +11,8 @@\n // pp-exact\n \n enum foo {\n-    foo, // a foo.\n-    bar,\n+    bar, // a bar.\n+    baz,\n }\n \n fn main() { }"}, {"sha": "9a5a8e7c38f81be52786510ddccca6455c495693", "filename": "src/test/run-fail/issue-2444.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-fail%2Fissue-2444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-2444.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -12,7 +12,7 @@\n \n use std::sync::Arc;\n \n-enum e<T> { e(Arc<T>) }\n+enum e<T> { ee(Arc<T>) }\n \n fn foo() -> e<int> {fail!();}\n "}, {"sha": "8192566da19656c5c22f59232fc1bf646efbcc1a", "filename": "src/test/run-pass/borrowck-univariant-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-univariant-enum.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -13,7 +13,7 @@ use std::cell::Cell;\n use std::gc::GC;\n \n enum newtype {\n-    newtype(int)\n+    newvar(int)\n }\n \n pub fn main() {\n@@ -22,9 +22,9 @@ pub fn main() {\n     // specially.\n \n     let x = box(GC) Cell::new(5);\n-    let y = box(GC) Cell::new(newtype(3));\n+    let y = box(GC) Cell::new(newvar(3));\n     let z = match y.get() {\n-      newtype(b) => {\n+      newvar(b) => {\n         x.set(x.get() + 1);\n         x.get() * b\n       }"}, {"sha": "44a3517cc758aab551c9f82259cf64b8cccb23e2", "filename": "src/test/run-pass/coerce-to-closure-and-proc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-to-closure-and-proc.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -17,7 +17,7 @@ struct Foo<T>(T);\n \n #[deriving(PartialEq, Show)]\n enum Bar<T> {\n-    Bar(T)\n+    Baz(T)\n }\n \n pub fn main() {\n@@ -33,11 +33,11 @@ pub fn main() {\n     let f: proc(int) -> Foo<int> = Foo;\n     assert_eq!(f(5), Foo(5));\n \n-    let f: |int| -> Bar<int> = Bar;\n-    assert_eq!(f(5), Bar(5));\n+    let f: |int| -> Bar<int> = Baz;\n+    assert_eq!(f(5), Baz(5));\n \n-    let f: proc(int) -> Bar<int> = Bar;\n-    assert_eq!(f(5), Bar(5));\n+    let f: proc(int) -> Bar<int> = Baz;\n+    assert_eq!(f(5), Baz(5));\n \n     let f: |int| -> Option<int> = Some;\n     assert_eq!(f(5), Some(5));"}, {"sha": "b160fa34c91b6a6a790882c4c37b2f096ef4baaa", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -22,7 +22,7 @@ enum object {\n     int_value(i64),\n }\n \n-fn lookup(table: json::Object, key: String, default: String) -> String\n+fn lookup(table: json::JsonObject, key: String, default: String) -> String\n {\n     match table.find(&key.to_string()) {\n         option::Some(&json::String(ref s)) => {"}, {"sha": "75f6a2faa80552558cd9630a2061ed76782eddf4", "filename": "src/test/run-pass/issue-3874.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fissue-3874.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3874.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum PureCounter { PureCounter(uint) }\n+enum PureCounter { PureCounterVariant(uint) }\n \n fn each(thing: PureCounter, blk: |v: &uint|) {\n-    let PureCounter(ref x) = thing;\n+    let PureCounterVariant(ref x) = thing;\n     blk(x);\n }\n "}, {"sha": "6eb0a4dad1b6aa0928c7d6016604d3dbda154721", "filename": "src/test/run-pass/match-arm-statics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-arm-statics.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -88,10 +88,10 @@ fn issue_14576() {\n }\n \n fn issue_13731() {\n-    enum A { A(()) }\n-    static B: A = A(());\n+    enum A { AA(()) }\n+    static B: A = AA(());\n \n-    match A(()) {\n+    match AA(()) {\n         B => ()\n     }\n }"}, {"sha": "e032a5e4156c36240b84364b30ee04c6f970557c", "filename": "src/test/run-pass/tag-align-shape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-shape.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -11,7 +11,7 @@\n extern crate debug;\n \n enum a_tag {\n-    a_tag(u64)\n+    a_tag_var(u64)\n }\n \n struct t_rec {\n@@ -20,8 +20,8 @@ struct t_rec {\n }\n \n pub fn main() {\n-    let x = t_rec {c8: 22u8, t: a_tag(44u64)};\n+    let x = t_rec {c8: 22u8, t: a_tag_var(44u64)};\n     let y = format!(\"{:?}\", x);\n     println!(\"y = {}\", y);\n-    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag(44u64)}\".to_string());\n+    assert_eq!(y, \"t_rec{c8: 22u8, t: a_tag_var(44u64)}\".to_string());\n }"}, {"sha": "398a0939d97d7ce9827df24cf36f787fe8ed3700", "filename": "src/test/run-pass/tag-align-u64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-align-u64.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -14,7 +14,7 @@\n use std::mem;\n \n enum Tag {\n-    Tag(u64)\n+    TagInner(u64)\n }\n \n struct Rec {\n@@ -23,7 +23,7 @@ struct Rec {\n }\n \n fn mk_rec() -> Rec {\n-    return Rec { c8:0u8, t:Tag(0u64) };\n+    return Rec { c8:0u8, t:TagInner(0u64) };\n }\n \n fn is_8_byte_aligned(u: &Tag) -> bool {"}, {"sha": "9ba4b707268a07b756f98cd6d539616ed997b423", "filename": "src/test/run-pass/xcrate-unit-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxcrate-unit-struct.rs?ref=04f5fe5a08988d2b8829f6a3ccc16b8dd19675b8", "patch": "@@ -12,7 +12,7 @@\n extern crate xcrate_unit_struct;\n \n static s1: xcrate_unit_struct::Struct = xcrate_unit_struct::Struct;\n-static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::Unit;\n+static s2: xcrate_unit_struct::Unit = xcrate_unit_struct::UnitVariant;\n static s3: xcrate_unit_struct::Unit =\n                 xcrate_unit_struct::Argument(xcrate_unit_struct::Struct);\n static s4: xcrate_unit_struct::Unit = xcrate_unit_struct::Argument(s1);\n@@ -22,7 +22,7 @@ fn f2(_: xcrate_unit_struct::Unit) {}\n \n pub fn main() {\n     f1(xcrate_unit_struct::Struct);\n-    f2(xcrate_unit_struct::Unit);\n+    f2(xcrate_unit_struct::UnitVariant);\n     f2(xcrate_unit_struct::Argument(xcrate_unit_struct::Struct));\n \n     f1(s1);"}]}