{"sha": "21d5bedd5f7564d62096e485f2fcb6a8956f1dec", "node_id": "C_kwDOAAsO6NoAKDIxZDViZWRkNWY3NTY0ZDYyMDk2ZTQ4NWYyZmNiNmE4OTU2ZjFkZWM", "commit": {"author": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-03-10T16:49:44Z"}, "committer": {"name": "IQuant", "email": "quant3234@gmail.com", "date": "2023-04-04T15:50:07Z"}, "message": "Extract suggest_specify_actual_length into a separate function", "tree": {"sha": "f33a71aaadf51e24b56266002bb3b9a21462376d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f33a71aaadf51e24b56266002bb3b9a21462376d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21d5bedd5f7564d62096e485f2fcb6a8956f1dec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21d5bedd5f7564d62096e485f2fcb6a8956f1dec", "html_url": "https://github.com/rust-lang/rust/commit/21d5bedd5f7564d62096e485f2fcb6a8956f1dec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21d5bedd5f7564d62096e485f2fcb6a8956f1dec/comments", "author": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "committer": {"login": "IntQuant", "id": 25219447, "node_id": "MDQ6VXNlcjI1MjE5NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/25219447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/IntQuant", "html_url": "https://github.com/IntQuant", "followers_url": "https://api.github.com/users/IntQuant/followers", "following_url": "https://api.github.com/users/IntQuant/following{/other_user}", "gists_url": "https://api.github.com/users/IntQuant/gists{/gist_id}", "starred_url": "https://api.github.com/users/IntQuant/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/IntQuant/subscriptions", "organizations_url": "https://api.github.com/users/IntQuant/orgs", "repos_url": "https://api.github.com/users/IntQuant/repos", "events_url": "https://api.github.com/users/IntQuant/events{/privacy}", "received_events_url": "https://api.github.com/users/IntQuant/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a05cd85adf99445a9064a0bbc71b507fcb3856e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a05cd85adf99445a9064a0bbc71b507fcb3856e", "html_url": "https://github.com/rust-lang/rust/commit/6a05cd85adf99445a9064a0bbc71b507fcb3856e"}], "stats": {"total": 120, "additions": 61, "deletions": 59}, "files": [{"sha": "3bb4e1c6b2996008326f974a36b3975141e32e22", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/21d5bedd5f7564d62096e485f2fcb6a8956f1dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d5bedd5f7564d62096e485f2fcb6a8956f1dec/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=21d5bedd5f7564d62096e485f2fcb6a8956f1dec", "patch": "@@ -1976,65 +1976,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 (ty::Bool, ty::Tuple(list)) => if list.len() == 0 {\n                     suggestions.extend(self.suggest_let_for_letchains(&trace.cause, span));\n                 }\n-                (ty::Array(_, _), ty::Array(_, _)) => 'block: {\n-                    let hir = self.tcx.hir();\n-                    let TypeError::FixedArraySize(sz) = terr else {\n-                        break 'block;\n-                    };\n-                    let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n-                        Some(hir::Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Fn(_, _, body_id),\n-                            ..\n-                        })) => {\n-                            let body = hir.body(*body_id);\n-                            struct LetVisitor<'v> {\n-                                span: Span,\n-                                result: Option<&'v hir::Ty<'v>>,\n-                            }\n-                            impl<'v> Visitor<'v> for LetVisitor<'v> {\n-                                fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n-                                    if self.result.is_some() {\n-                                        return;\n-                                    }\n-                                    // Find a local statement where the initializer has\n-                                    // the same span as the error and the type is specified.\n-                                    if let hir::Stmt {\n-                                        kind: hir::StmtKind::Local(hir::Local {\n-                                            init: Some(hir::Expr {\n-                                                span: init_span,\n-                                                ..\n-                                            }),\n-                                            ty: Some(array_ty),\n-                                            ..\n-                                        }),\n-                                        ..\n-                                    } = s\n-                                    && init_span == &self.span {\n-                                        self.result = Some(*array_ty);\n-                                    }\n-                                }\n-                            }\n-                            let mut visitor = LetVisitor {span, result: None};\n-                            visitor.visit_body(body);\n-                            visitor.result.map(|r| &r.peel_refs().kind)\n-                        }\n-                        Some(hir::Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Const(ty, _),\n-                            ..\n-                        })) => {\n-                            Some(&ty.peel_refs().kind)\n-                        }\n-                        _ => None\n-                    };\n-\n-                    if let Some(tykind) = tykind\n-                        && let hir::TyKind::Array(_, length) = tykind\n-                        && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n-                        && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n-                    {\n-                        suggestions.push(TypeErrorAdditionalDiags::ConsiderSpecifyingLength { span, length: sz.found });\n-                    }\n-                }\n+                (ty::Array(_, _), ty::Array(_, _)) => suggestions.extend(self.specify_actual_length(terr, trace, span)),\n                 _ => {}\n             }\n         }\n@@ -2048,6 +1990,66 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         suggestions\n     }\n \n+    fn specify_actual_length(\n+        &self,\n+        terr: TypeError<'_>,\n+        trace: &TypeTrace<'_>,\n+        span: Span,\n+    ) -> Option<TypeErrorAdditionalDiags> {\n+        let hir = self.tcx.hir();\n+        let TypeError::FixedArraySize(sz) = terr else {\n+            return None;\n+        };\n+        let tykind = match hir.find_by_def_id(trace.cause.body_id) {\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })) => {\n+                let body = hir.body(*body_id);\n+                struct LetVisitor<'v> {\n+                    span: Span,\n+                    result: Option<&'v hir::Ty<'v>>,\n+                }\n+                impl<'v> Visitor<'v> for LetVisitor<'v> {\n+                    fn visit_stmt(&mut self, s: &'v hir::Stmt<'v>) {\n+                        if self.result.is_some() {\n+                            return;\n+                        }\n+                        // Find a local statement where the initializer has\n+                        // the same span as the error and the type is specified.\n+                        if let hir::Stmt {\n+                            kind: hir::StmtKind::Local(hir::Local {\n+                                init: Some(hir::Expr {\n+                                    span: init_span,\n+                                    ..\n+                                }),\n+                                ty: Some(array_ty),\n+                                ..\n+                            }),\n+                            ..\n+                        } = s\n+                        && init_span == &self.span {\n+                            self.result = Some(*array_ty);\n+                        }\n+                    }\n+                }\n+                let mut visitor = LetVisitor { span, result: None };\n+                visitor.visit_body(body);\n+                visitor.result.map(|r| &r.peel_refs().kind)\n+            }\n+            Some(hir::Node::Item(hir::Item { kind: hir::ItemKind::Const(ty, _), .. })) => {\n+                Some(&ty.peel_refs().kind)\n+            }\n+            _ => None,\n+        };\n+        if let Some(tykind) = tykind\n+            && let hir::TyKind::Array(_, length) = tykind\n+            && let hir::ArrayLen::Body(hir::AnonConst { hir_id, .. }) = length\n+            && let Some(span) = self.tcx.hir().opt_span(*hir_id)\n+        {\n+            Some(TypeErrorAdditionalDiags::ConsiderSpecifyingLength { span, length: sz.found })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn report_and_explain_type_error(\n         &self,\n         trace: TypeTrace<'tcx>,"}]}