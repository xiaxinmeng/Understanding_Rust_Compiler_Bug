{"sha": "14570df015d1641d1e382c9898e7c6d981b99e97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NTcwZGYwMTVkMTY0MWQxZTM4MmM5ODk4ZTdjNmQ5ODFiOTllOTc=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-10T15:44:43Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-04-16T11:06:23Z"}, "message": "Switch Chalk to recursive solver\n\n + various fixes related to that.", "tree": {"sha": "eb89057f63b5b85c029b2caa6a6cf22a834d67f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb89057f63b5b85c029b2caa6a6cf22a834d67f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14570df015d1641d1e382c9898e7c6d981b99e97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14570df015d1641d1e382c9898e7c6d981b99e97", "html_url": "https://github.com/rust-lang/rust/commit/14570df015d1641d1e382c9898e7c6d981b99e97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14570df015d1641d1e382c9898e7c6d981b99e97/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "364415b7d66bc9d42f21181d7f642e9f911c4711", "url": "https://api.github.com/repos/rust-lang/rust/commits/364415b7d66bc9d42f21181d7f642e9f911c4711", "html_url": "https://github.com/rust-lang/rust/commit/364415b7d66bc9d42f21181d7f642e9f911c4711"}], "stats": {"total": 93, "additions": 53, "deletions": 40}, "files": [{"sha": "1b0f84c5c752eb3b890827dfdf4a3f5994e67090", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=14570df015d1641d1e382c9898e7c6d981b99e97", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     db::HirDatabase,\n     traits::{InEnvironment, Solution},\n     utils::generics,\n-    BoundVar, Canonical, DebruijnIndex, Substs, Ty,\n+    BoundVar, Canonical, DebruijnIndex, Obligation, Substs, TraitRef, Ty,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -66,6 +66,20 @@ fn deref_by_trait(\n     let parameters =\n         Substs::build_for_generics(&generic_params).push(ty.value.value.clone()).build();\n \n+    // Check that the type implements Deref at all\n+    let trait_ref = TraitRef { trait_: deref_trait, substs: parameters.clone() };\n+    let implements_goal = super::Canonical {\n+        num_vars: ty.value.num_vars,\n+        value: InEnvironment {\n+            value: Obligation::Trait(trait_ref),\n+            environment: ty.environment.clone(),\n+        },\n+    };\n+    if db.trait_solve(krate, implements_goal).is_none() {\n+        return None;\n+    }\n+\n+    // Now do the assoc type projection\n     let projection = super::traits::ProjectionPredicate {\n         ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.num_vars)),\n         projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n@@ -91,6 +105,11 @@ fn deref_by_trait(\n             // they're just being 'passed through'. In the 'standard' case where\n             // we have `impl<T> Deref for Foo<T> { Target = T }`, that should be\n             // the case.\n+\n+            // FIXME: if the trait solver decides to truncate the type, these\n+            // assumptions will be broken. We would need to properly introduce\n+            // new variables in that case\n+\n             for i in 1..vars.0.num_vars {\n                 if vars.0.value[i - 1] != Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {"}, {"sha": "5f6cea8d318e13863f8c33d4aff81128ed08783a", "filename": "crates/ra_hir_ty/src/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Funify.rs?ref=14570df015d1641d1e382c9898e7c6d981b99e97", "patch": "@@ -32,6 +32,7 @@ where\n     var_stack: Vec<TypeVarId>,\n }\n \n+#[derive(Debug)]\n pub(super) struct Canonicalized<T> {\n     pub value: Canonical<T>,\n     free_vars: Vec<InferTy>,"}, {"sha": "0e4fd7bfd16041764d00c7490e30dd1a3f769326", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 21, "deletions": 29, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=14570df015d1641d1e382c9898e7c6d981b99e97", "patch": "@@ -349,7 +349,6 @@ trait Trait: SuperTrait {\n \n #[test]\n fn infer_project_associated_type() {\n-    // y, z, a don't yet work because of https://github.com/rust-lang/chalk/issues/234\n     assert_snapshot!(\n         infer(r#\"\n trait Iterable {\n@@ -368,12 +367,12 @@ fn test<T: Iterable>() {\n     [108; 261) '{     ...ter; }': ()\n     [118; 119) 'x': u32\n     [145; 146) '1': u32\n-    [156; 157) 'y': {unknown}\n-    [183; 192) 'no_matter': {unknown}\n-    [202; 203) 'z': {unknown}\n-    [215; 224) 'no_matter': {unknown}\n-    [234; 235) 'a': {unknown}\n-    [249; 258) 'no_matter': {unknown}\n+    [156; 157) 'y': Iterable::Item<T>\n+    [183; 192) 'no_matter': Iterable::Item<T>\n+    [202; 203) 'z': Iterable::Item<T>\n+    [215; 224) 'no_matter': Iterable::Item<T>\n+    [234; 235) 'a': Iterable::Item<T>\n+    [249; 258) 'no_matter': Iterable::Item<T>\n     \"###\n     );\n }\n@@ -433,8 +432,8 @@ fn test<T: Iterable<Item=u32>>() {\n \"#),\n         @r###\"\n     [67; 100) '{     ...own; }': ()\n-    [77; 78) 'y': {unknown}\n-    [90; 97) 'unknown': {unknown}\n+    [77; 78) 'y': u32\n+    [90; 97) 'unknown': u32\n     \"###\n     );\n }\n@@ -549,7 +548,7 @@ impl std::ops::Index<u32> for Bar {\n \n fn test() {\n     let a = Bar;\n-    let b = a[1];\n+    let b = a[1u32];\n     b<|>;\n }\n \n@@ -574,7 +573,7 @@ fn infer_ops_index_autoderef() {\n //- /main.rs crate:main deps:std\n fn test() {\n     let a = &[1u32, 2, 3];\n-    let b = a[1];\n+    let b = a[1u32];\n     b<|>;\n }\n \n@@ -916,11 +915,7 @@ fn test<T: ApplyL>(t: T) {\n }\n \"#,\n     );\n-    // FIXME here Chalk doesn't normalize the type to a placeholder. I think we\n-    // need to add a rule like Normalize(<T as ApplyL>::Out -> ApplyL::Out<T>)\n-    // to the trait env ourselves here; probably Chalk can't do this by itself.\n-    // assert_eq!(t, \"ApplyL::Out<[missing name]>\");\n-    assert_eq!(t, \"{unknown}\");\n+    assert_eq!(t, \"ApplyL::Out<T>\");\n }\n \n #[test]\n@@ -1329,16 +1324,16 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [263; 264) 'y': impl Trait<Type = i64>\n     [290; 398) '{     ...r>); }': ()\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n-    [296; 302) 'get(x)': {unknown}\n+    [296; 302) 'get(x)': u32\n     [300; 301) 'x': T\n-    [308; 312) 'get2': fn get2<{unknown}, T>(T) -> {unknown}\n-    [308; 315) 'get2(x)': {unknown}\n+    [308; 312) 'get2': fn get2<u32, T>(T) -> u32\n+    [308; 315) 'get2(x)': u32\n     [313; 314) 'x': T\n     [321; 324) 'get': fn get<impl Trait<Type = i64>>(impl Trait<Type = i64>) -> <impl Trait<Type = i64> as Trait>::Type\n-    [321; 327) 'get(y)': {unknown}\n+    [321; 327) 'get(y)': i64\n     [325; 326) 'y': impl Trait<Type = i64>\n-    [333; 337) 'get2': fn get2<{unknown}, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> {unknown}\n-    [333; 340) 'get2(y)': {unknown}\n+    [333; 337) 'get2': fn get2<i64, impl Trait<Type = i64>>(impl Trait<Type = i64>) -> i64\n+    [333; 340) 'get2(y)': i64\n     [338; 339) 'y': impl Trait<Type = i64>\n     [346; 349) 'get': fn get<S<u64>>(S<u64>) -> <S<u64> as Trait>::Type\n     [346; 357) 'get(set(S))': u64\n@@ -1402,7 +1397,6 @@ mod iter {\n \n #[test]\n fn projection_eq_within_chalk() {\n-    // std::env::set_var(\"CHALK_DEBUG\", \"1\");\n     assert_snapshot!(\n         infer(r#\"\n trait Trait1 {\n@@ -1422,7 +1416,7 @@ fn test<T: Trait1<Type = u32>>(x: T) {\n     [164; 165) 'x': T\n     [170; 186) '{     ...o(); }': ()\n     [176; 177) 'x': T\n-    [176; 183) 'x.foo()': {unknown}\n+    [176; 183) 'x.foo()': u32\n     \"###\n     );\n }\n@@ -1578,7 +1572,7 @@ fn test<F: FnOnce(u32, u64) -> u128>(f: F) {\n     [150; 151) 'f': F\n     [156; 184) '{     ...2)); }': ()\n     [162; 163) 'f': F\n-    [162; 181) 'f.call...1, 2))': {unknown}\n+    [162; 181) 'f.call...1, 2))': u128\n     [174; 180) '(1, 2)': (u32, u64)\n     [175; 176) '1': u32\n     [178; 179) '2': u64\n@@ -1829,7 +1823,7 @@ impl Trait for S2 {\n \"#,\n     ), @r###\"\n     [54; 58) 'self': &Self\n-    [60; 61) 'x': {unknown}\n+    [60; 61) 'x': Trait::Item<Self>\n     [140; 144) 'self': &S\n     [146; 147) 'x': u32\n     [161; 175) '{ let y = x; }': ()\n@@ -1989,9 +1983,7 @@ fn test<I: Iterator<Item: Iterator<Item = u32>>>() {\n }\n \"#,\n     );\n-    // assert_eq!(t, \"u32\");\n-    // doesn't currently work, Chalk #234\n-    assert_eq!(t, \"{unknown}\");\n+    assert_eq!(t, \"u32\");\n }\n \n #[test]"}, {"sha": "05791a84868fdef628434a2e11d17e772191a6bc", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=14570df015d1641d1e382c9898e7c6d981b99e97", "patch": "@@ -16,10 +16,12 @@ use self::chalk::{from_chalk, Interner, ToChalk};\n pub(crate) mod chalk;\n mod builtin;\n \n-/// This controls the maximum size of types Chalk considers. If we set this too\n-/// high, we can run into slow edge cases; if we set it too low, Chalk won't\n-/// find some solutions.\n-const CHALK_SOLVER_MAX_SIZE: usize = 10;\n+// This controls the maximum size of types Chalk considers. If we set this too\n+// high, we can run into slow edge cases; if we set it too low, Chalk won't\n+// find some solutions.\n+// FIXME this is currently hardcoded in the recursive solver\n+// const CHALK_SOLVER_MAX_SIZE: usize = 10;\n+\n /// This controls how much 'time' we give the Chalk solver before giving up.\n const CHALK_SOLVER_FUEL: i32 = 100;\n \n@@ -30,8 +32,7 @@ struct ChalkContext<'a> {\n }\n \n fn create_chalk_solver() -> chalk_solve::Solver<Interner> {\n-    let solver_choice =\n-        chalk_solve::SolverChoice::SLG { max_size: CHALK_SOLVER_MAX_SIZE, expected_answers: None };\n+    let solver_choice = chalk_solve::SolverChoice::recursive();\n     solver_choice.into_solver()\n }\n "}, {"sha": "60d70d18e89d031612e196e4fc177ef66587daa8", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14570df015d1641d1e382c9898e7c6d981b99e97/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=14570df015d1641d1e382c9898e7c6d981b99e97", "patch": "@@ -511,13 +511,13 @@ impl ToChalk for ProjectionTy {\n }\n \n impl ToChalk for super::ProjectionPredicate {\n-    type Chalk = chalk_ir::Normalize<Interner>;\n+    type Chalk = chalk_ir::AliasEq<Interner>;\n \n-    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Normalize<Interner> {\n-        chalk_ir::Normalize { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n+    fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::AliasEq<Interner> {\n+        chalk_ir::AliasEq { alias: self.projection_ty.to_chalk(db), ty: self.ty.to_chalk(db) }\n     }\n \n-    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::Normalize<Interner>) -> Self {\n+    fn from_chalk(_db: &dyn HirDatabase, _normalize: chalk_ir::AliasEq<Interner>) -> Self {\n         unimplemented!()\n     }\n }"}]}