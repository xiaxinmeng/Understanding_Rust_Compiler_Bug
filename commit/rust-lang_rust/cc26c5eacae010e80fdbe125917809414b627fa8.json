{"sha": "cc26c5eacae010e80fdbe125917809414b627fa8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMjZjNWVhY2FlMDEwZTgwZmRiZTEyNTkxNzgwOTQxNGI2MjdmYTg=", "commit": {"author": {"name": "St\u00e9phane Campinas", "email": "stephane.campinas@gmail.com", "date": "2019-03-24T21:29:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-03-24T21:29:56Z"}, "message": "Merge pull request #3454 from rchaser53/issue-3434\n\nadd new attribute rustfmt::skip::macros", "tree": {"sha": "d97436e56eee19fa66ae637cec039427c64d09ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d97436e56eee19fa66ae637cec039427c64d09ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc26c5eacae010e80fdbe125917809414b627fa8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcl/bUCRBK7hj4Ov3rIwAAdHIIAC4CGV/viHp/BYWLUx/y+VyD\noW5VeIFmFzVfJSPCN4Uj8z/sTaTX3YSnBu8ZmZN4F3FaByvL8Pe9tyyxTFIVBjUX\nNq9UtMu39y3mnbKGrAJBEtu4PpVZNYEPHPXEd0JX48ents57PiYehmccqb/TWNUc\n4jDS0HbF3wTR4YrYIYCX+enkc+80EQTeK4d5B6sheOAqzDl/pTeOh5si+9IbmDAe\nBlK4MDYwXKrSMoRtREA3f28fuTTMn90b89T93nLvoR7YE1rM8gaZ4Jr/iN2aXf/A\nAljB1zJPs0FT6ETdwUgiKQfH2olWzeWYq/Nw2yv+LiMpFBr4GMiCNVqWdkFo+Ys=\n=J81l\n-----END PGP SIGNATURE-----\n", "payload": "tree d97436e56eee19fa66ae637cec039427c64d09ab\nparent b6dac248ec2f5580b2f4deab931efa8992ece40d\nparent 8a905a87780a6898b5fea6b39db7b6fcae8e84cc\nauthor St\u00e9phane Campinas <stephane.campinas@gmail.com> 1553462996 +0100\ncommitter GitHub <noreply@github.com> 1553462996 +0100\n\nMerge pull request #3454 from rchaser53/issue-3434\n\nadd new attribute rustfmt::skip::macros"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc26c5eacae010e80fdbe125917809414b627fa8", "html_url": "https://github.com/rust-lang/rust/commit/cc26c5eacae010e80fdbe125917809414b627fa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc26c5eacae010e80fdbe125917809414b627fa8/comments", "author": {"login": "scampi", "id": 795879, "node_id": "MDQ6VXNlcjc5NTg3OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scampi", "html_url": "https://github.com/scampi", "followers_url": "https://api.github.com/users/scampi/followers", "following_url": "https://api.github.com/users/scampi/following{/other_user}", "gists_url": "https://api.github.com/users/scampi/gists{/gist_id}", "starred_url": "https://api.github.com/users/scampi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scampi/subscriptions", "organizations_url": "https://api.github.com/users/scampi/orgs", "repos_url": "https://api.github.com/users/scampi/repos", "events_url": "https://api.github.com/users/scampi/events{/privacy}", "received_events_url": "https://api.github.com/users/scampi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6dac248ec2f5580b2f4deab931efa8992ece40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6dac248ec2f5580b2f4deab931efa8992ece40d", "html_url": "https://github.com/rust-lang/rust/commit/b6dac248ec2f5580b2f4deab931efa8992ece40d"}, {"sha": "8a905a87780a6898b5fea6b39db7b6fcae8e84cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a905a87780a6898b5fea6b39db7b6fcae8e84cc", "html_url": "https://github.com/rust-lang/rust/commit/8a905a87780a6898b5fea6b39db7b6fcae8e84cc"}], "stats": {"total": 501, "additions": 372, "deletions": 129}, "files": [{"sha": "cc5fb979c527faefad8fa23097826b37302ed989", "filename": "README.md", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -179,6 +179,18 @@ needs to be specified in `rustfmt.toml`, e.g., with `edition = \"2018\"`.\n ## Tips\n \n * For things you do not want rustfmt to mangle, use `#[rustfmt::skip]`\n+* To prevent rustfmt from formatting a macro,\n+  use `#[rustfmt::skip::macros(target_macro_name)]`\n+\n+  Example:\n+\n+    ```rust\n+    #[rustfmt::skip::macros(html)]\n+    fn main() {\n+        let macro_result1 = html! { <div>\n+    Hello</div>\n+        }.to_string();\n+    ```\n * When you run rustfmt, place a file named `rustfmt.toml` or `.rustfmt.toml` in\n   target file directory or its parents to override the default settings of\n   rustfmt. You can generate a file containing the default configuration with"}, {"sha": "545d2fe279f766f0069e7df4e42b04c59b61f4b0", "filename": "src/formatting.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -15,6 +15,7 @@ use syntax::source_map::{FilePathMapping, SourceMap, Span, DUMMY_SP};\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n use crate::issues::BadIssueSeeker;\n+use crate::utils::{count_newlines, get_skip_macro_names};\n use crate::visitor::{FmtVisitor, SnippetProvider};\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n@@ -153,6 +154,10 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             &snippet_provider,\n             self.report.clone(),\n         );\n+        visitor\n+            .skip_macro_names\n+            .borrow_mut()\n+            .append(&mut get_skip_macro_names(&self.krate.attrs));\n \n         // Format inner attributes if available.\n         if !self.krate.attrs.is_empty() && is_root {\n@@ -168,10 +173,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             visitor.format_separate_mod(module, &*source_file);\n         };\n \n-        debug_assert_eq!(\n-            visitor.line_number,\n-            crate::utils::count_newlines(&visitor.buffer)\n-        );\n+        debug_assert_eq!(visitor.line_number, count_newlines(&visitor.buffer));\n \n         // For some reason, the source_map does not include terminating\n         // newlines so we must add one on for each file. This is sad."}, {"sha": "7e465ffdcfe2bc65d765d8ca6a356325dc9e2a11", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -94,7 +94,7 @@ pub enum ErrorKind {\n     /// Used deprecated skip attribute.\n     #[fail(display = \"`rustfmt_skip` is deprecated; use `rustfmt::skip`\")]\n     DeprecatedAttr,\n-    /// Used a rustfmt:: attribute other than skip.\n+    /// Used a rustfmt:: attribute other than skip or skip::macros.\n     #[fail(display = \"invalid attribute\")]\n     BadAttr,\n     /// An io error during reading or writing."}, {"sha": "18df24b45c8cf1a0390ecb86b659e8cd56650608", "filename": "src/macros.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -208,12 +208,21 @@ pub fn rewrite_macro(\n     shape: Shape,\n     position: MacroPosition,\n ) -> Option<String> {\n-    let guard = InsideMacroGuard::inside_macro_context(context);\n-    let result = rewrite_macro_inner(mac, extra_ident, context, shape, position, guard.is_nested);\n-    if result.is_none() {\n-        context.macro_rewrite_failure.replace(true);\n+    let should_skip = context\n+        .skip_macro_names\n+        .borrow()\n+        .contains(&context.snippet(mac.node.path.span).to_owned());\n+    if should_skip {\n+        None\n+    } else {\n+        let guard = InsideMacroGuard::inside_macro_context(context);\n+        let result =\n+            rewrite_macro_inner(mac, extra_ident, context, shape, position, guard.is_nested);\n+        if result.is_none() {\n+            context.macro_rewrite_failure.replace(true);\n+        }\n+        result\n     }\n-    result\n }\n \n fn check_keyword<'a, 'b: 'a>(parser: &'a mut Parser<'b>) -> Option<MacroArg> {"}, {"sha": "c736c2535a616701e1719adf60fd0f2a10d1638c", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -39,6 +39,7 @@ pub struct RewriteContext<'a> {\n     // Used for `format_snippet`\n     pub(crate) macro_rewrite_failure: RefCell<bool>,\n     pub(crate) report: FormatReport,\n+    pub skip_macro_names: RefCell<Vec<String>>,\n }\n \n impl<'a> RewriteContext<'a> {"}, {"sha": "0628094fdeffe2ea41a4668fb3f783f469122aec", "filename": "src/test/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -22,6 +22,7 @@ const SKIP_FILE_WHITE_LIST: &[&str] = &[\n     // We want to make sure that the `skip_children` is correctly working,\n     // so we do not want to test this file directly.\n     \"configs/skip_children/foo/mod.rs\",\n+    \"issue-3434/no_entry.rs\",\n ];\n \n fn is_file_skip(path: &Path) -> bool {"}, {"sha": "743a86276129369270338da5e54e3d75bb58c22f", "filename": "src/utils.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -603,6 +603,26 @@ pub(crate) fn unicode_str_width(s: &str) -> usize {\n     s.width()\n }\n \n+pub fn get_skip_macro_names(attrs: &[ast::Attribute]) -> Vec<String> {\n+    let mut skip_macro_names = vec![];\n+    for attr in attrs {\n+        // syntax::ast::Path is implemented partialEq\n+        // but it is designed for segments.len() == 1\n+        if format!(\"{}\", attr.path) != \"rustfmt::skip::macros\" {\n+            continue;\n+        }\n+\n+        if let Some(list) = attr.meta_item_list() {\n+            for spanned in list {\n+                if let Some(name) = spanned.name() {\n+                    skip_macro_names.push(name.to_string());\n+                }\n+            }\n+        }\n+    }\n+    skip_macro_names\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}, {"sha": "8688c5b7827171df164775dab73682b67fc61ab4", "filename": "src/visitor.rs", "status": "modified", "additions": 150, "deletions": 119, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -20,8 +20,8 @@ use crate::shape::{Indent, Shape};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n use crate::utils::{\n-    self, contains_skip, count_newlines, inner_attributes, mk_sp, ptr_vec_to_ref_vec,\n-    rewrite_ident, stmt_expr, DEPR_SKIP_ANNOTATION,\n+    self, contains_skip, count_newlines, get_skip_macro_names, inner_attributes, mk_sp,\n+    ptr_vec_to_ref_vec, rewrite_ident, stmt_expr, DEPR_SKIP_ANNOTATION,\n };\n use crate::{ErrorKind, FormatReport, FormattingError};\n \n@@ -66,6 +66,7 @@ pub struct FmtVisitor<'a> {\n     pub skipped_range: Vec<(usize, usize)>,\n     pub macro_rewrite_failure: bool,\n     pub(crate) report: FormatReport,\n+    pub skip_macro_names: RefCell<Vec<String>>,\n }\n \n impl<'a> Drop for FmtVisitor<'a> {\n@@ -296,25 +297,32 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         // the AST lumps them all together.\n         let filtered_attrs;\n         let mut attrs = &item.attrs;\n-        match item.node {\n+        let temp_skip_macro_names = self.skip_macro_names.clone();\n+        self.skip_macro_names\n+            .borrow_mut()\n+            .append(&mut get_skip_macro_names(&attrs));\n+\n+        let should_visit_node_again = match item.node {\n             // For use items, skip rewriting attributes. Just check for a skip attribute.\n             ast::ItemKind::Use(..) => {\n                 if contains_skip(attrs) {\n                     self.push_skipped_with_span(attrs.as_slice(), item.span(), item.span());\n-                    return;\n+                    false\n+                } else {\n+                    true\n                 }\n             }\n             // Module is inline, in this case we treat it like any other item.\n             _ if !is_mod_decl(item) => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n                     self.push_skipped_with_span(item.attrs.as_slice(), item.span(), item.span());\n-                    return;\n+                    false\n+                } else {\n+                    true\n                 }\n             }\n             // Module is not inline, but should be skipped.\n-            ast::ItemKind::Mod(..) if contains_skip(&item.attrs) => {\n-                return;\n-            }\n+            ast::ItemKind::Mod(..) if contains_skip(&item.attrs) => false,\n             // Module is not inline and should not be skipped. We want\n             // to process only the attributes in the current file.\n             ast::ItemKind::Mod(..) => {\n@@ -323,121 +331,127 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 // the above case.\n                 assert!(!self.visit_attrs(&filtered_attrs, ast::AttrStyle::Outer));\n                 attrs = &filtered_attrs;\n+                true\n             }\n             _ => {\n                 if self.visit_attrs(&item.attrs, ast::AttrStyle::Outer) {\n                     self.push_skipped_with_span(item.attrs.as_slice(), item.span(), item.span());\n-                    return;\n+                    false\n+                } else {\n+                    true\n                 }\n             }\n-        }\n+        };\n \n-        match item.node {\n-            ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n-            ast::ItemKind::Impl(..) => {\n-                let snippet = self.snippet(item.span);\n-                let where_span_end = snippet\n-                    .find_uncommented(\"{\")\n-                    .map(|x| BytePos(x as u32) + source!(self, item.span).lo());\n-                let block_indent = self.block_indent;\n-                let rw =\n-                    self.with_context(|ctx| format_impl(&ctx, item, block_indent, where_span_end));\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::Trait(..) => {\n-                let block_indent = self.block_indent;\n-                let rw = self.with_context(|ctx| format_trait(&ctx, item, block_indent));\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::TraitAlias(ref generics, ref generic_bounds) => {\n-                let shape = Shape::indented(self.block_indent, self.config);\n-                let rw = format_trait_alias(\n-                    &self.get_context(),\n-                    item.ident,\n-                    &item.vis,\n-                    generics,\n-                    generic_bounds,\n-                    shape,\n-                );\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::ExternCrate(_) => {\n-                let rw = rewrite_extern_crate(&self.get_context(), item);\n-                self.push_rewrite(item.span, rw);\n-            }\n-            ast::ItemKind::Struct(..) | ast::ItemKind::Union(..) => {\n-                self.visit_struct(&StructParts::from_item(item));\n-            }\n-            ast::ItemKind::Enum(ref def, ref generics) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n-                self.last_pos = source!(self, item.span).hi();\n-            }\n-            ast::ItemKind::Mod(ref module) => {\n-                let is_inline = !is_mod_decl(item);\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                self.format_mod(module, &item.vis, item.span, item.ident, attrs, is_inline);\n-            }\n-            ast::ItemKind::Mac(ref mac) => {\n-                self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n-            }\n-            ast::ItemKind::ForeignMod(ref foreign_mod) => {\n-                self.format_missing_with_indent(source!(self, item.span).lo());\n-                self.format_foreign_mod(foreign_mod, item.span);\n-            }\n-            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n-                self.visit_static(&StaticParts::from_item(item));\n-            }\n-            ast::ItemKind::Fn(ref decl, ref fn_header, ref generics, ref body) => {\n-                let inner_attrs = inner_attributes(&item.attrs);\n-                self.visit_fn(\n-                    visit::FnKind::ItemFn(item.ident, fn_header, &item.vis, body),\n-                    generics,\n-                    decl,\n-                    item.span,\n-                    ast::Defaultness::Final,\n-                    Some(&inner_attrs),\n-                )\n-            }\n-            ast::ItemKind::Ty(ref ty, ref generics) => {\n-                let rewrite = rewrite_type_alias(\n-                    &self.get_context(),\n-                    self.block_indent,\n-                    item.ident,\n-                    ty,\n-                    generics,\n-                    &item.vis,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n-            ast::ItemKind::Existential(ref generic_bounds, ref generics) => {\n-                let rewrite = rewrite_existential_type(\n-                    &self.get_context(),\n-                    self.block_indent,\n-                    item.ident,\n-                    generic_bounds,\n-                    generics,\n-                    &item.vis,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n-            ast::ItemKind::GlobalAsm(..) => {\n-                let snippet = Some(self.snippet(item.span).to_owned());\n-                self.push_rewrite(item.span, snippet);\n-            }\n-            ast::ItemKind::MacroDef(ref def) => {\n-                let rewrite = rewrite_macro_def(\n-                    &self.get_context(),\n-                    self.shape(),\n-                    self.block_indent,\n-                    def,\n-                    item.ident,\n-                    &item.vis,\n-                    item.span,\n-                );\n-                self.push_rewrite(item.span, rewrite);\n-            }\n+        if should_visit_node_again {\n+            match item.node {\n+                ast::ItemKind::Use(ref tree) => self.format_import(item, tree),\n+                ast::ItemKind::Impl(..) => {\n+                    let snippet = self.snippet(item.span);\n+                    let where_span_end = snippet\n+                        .find_uncommented(\"{\")\n+                        .map(|x| BytePos(x as u32) + source!(self, item.span).lo());\n+                    let block_indent = self.block_indent;\n+                    let rw = self\n+                        .with_context(|ctx| format_impl(&ctx, item, block_indent, where_span_end));\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::Trait(..) => {\n+                    let block_indent = self.block_indent;\n+                    let rw = self.with_context(|ctx| format_trait(&ctx, item, block_indent));\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::TraitAlias(ref generics, ref generic_bounds) => {\n+                    let shape = Shape::indented(self.block_indent, self.config);\n+                    let rw = format_trait_alias(\n+                        &self.get_context(),\n+                        item.ident,\n+                        &item.vis,\n+                        generics,\n+                        generic_bounds,\n+                        shape,\n+                    );\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::ExternCrate(_) => {\n+                    let rw = rewrite_extern_crate(&self.get_context(), item);\n+                    self.push_rewrite(item.span, rw);\n+                }\n+                ast::ItemKind::Struct(..) | ast::ItemKind::Union(..) => {\n+                    self.visit_struct(&StructParts::from_item(item));\n+                }\n+                ast::ItemKind::Enum(ref def, ref generics) => {\n+                    self.format_missing_with_indent(source!(self, item.span).lo());\n+                    self.visit_enum(item.ident, &item.vis, def, generics, item.span);\n+                    self.last_pos = source!(self, item.span).hi();\n+                }\n+                ast::ItemKind::Mod(ref module) => {\n+                    let is_inline = !is_mod_decl(item);\n+                    self.format_missing_with_indent(source!(self, item.span).lo());\n+                    self.format_mod(module, &item.vis, item.span, item.ident, attrs, is_inline);\n+                }\n+                ast::ItemKind::Mac(ref mac) => {\n+                    self.visit_mac(mac, Some(item.ident), MacroPosition::Item);\n+                }\n+                ast::ItemKind::ForeignMod(ref foreign_mod) => {\n+                    self.format_missing_with_indent(source!(self, item.span).lo());\n+                    self.format_foreign_mod(foreign_mod, item.span);\n+                }\n+                ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => {\n+                    self.visit_static(&StaticParts::from_item(item));\n+                }\n+                ast::ItemKind::Fn(ref decl, ref fn_header, ref generics, ref body) => {\n+                    let inner_attrs = inner_attributes(&item.attrs);\n+                    self.visit_fn(\n+                        visit::FnKind::ItemFn(item.ident, fn_header, &item.vis, body),\n+                        generics,\n+                        decl,\n+                        item.span,\n+                        ast::Defaultness::Final,\n+                        Some(&inner_attrs),\n+                    )\n+                }\n+                ast::ItemKind::Ty(ref ty, ref generics) => {\n+                    let rewrite = rewrite_type_alias(\n+                        &self.get_context(),\n+                        self.block_indent,\n+                        item.ident,\n+                        ty,\n+                        generics,\n+                        &item.vis,\n+                    );\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+                ast::ItemKind::Existential(ref generic_bounds, ref generics) => {\n+                    let rewrite = rewrite_existential_type(\n+                        &self.get_context(),\n+                        self.block_indent,\n+                        item.ident,\n+                        generic_bounds,\n+                        generics,\n+                        &item.vis,\n+                    );\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+                ast::ItemKind::GlobalAsm(..) => {\n+                    let snippet = Some(self.snippet(item.span).to_owned());\n+                    self.push_rewrite(item.span, snippet);\n+                }\n+                ast::ItemKind::MacroDef(ref def) => {\n+                    let rewrite = rewrite_macro_def(\n+                        &self.get_context(),\n+                        self.shape(),\n+                        self.block_indent,\n+                        def,\n+                        item.ident,\n+                        &item.vis,\n+                        item.span,\n+                    );\n+                    self.push_rewrite(item.span, rewrite);\n+                }\n+            };\n         }\n+        self.skip_macro_names = temp_skip_macro_names;\n     }\n \n     pub fn visit_trait_item(&mut self, ti: &ast::TraitItem) {\n@@ -592,6 +606,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             ctx.snippet_provider,\n             ctx.report.clone(),\n         );\n+        visitor\n+            .skip_macro_names\n+            .borrow_mut()\n+            .append(&mut ctx.skip_macro_names.borrow().clone());\n         visitor.set_parent_context(ctx);\n         visitor\n     }\n@@ -616,6 +634,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             skipped_range: vec![],\n             macro_rewrite_failure: false,\n             report,\n+            skip_macro_names: RefCell::new(vec![]),\n         }\n     }\n \n@@ -640,10 +659,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                         ErrorKind::DeprecatedAttr,\n                     )],\n                 );\n-            } else if attr.path.segments[0].ident.to_string() == \"rustfmt\"\n-                && (attr.path.segments.len() == 1\n-                    || attr.path.segments[1].ident.to_string() != \"skip\")\n-            {\n+            } else if self.is_unknown_rustfmt_attr(&attr.path.segments) {\n                 let file_name = self.source_map.span_to_filename(attr.span).into();\n                 self.report.append(\n                     file_name,\n@@ -671,6 +687,20 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         false\n     }\n \n+    fn is_unknown_rustfmt_attr(&self, segments: &[ast::PathSegment]) -> bool {\n+        if segments[0].ident.to_string() != \"rustfmt\" {\n+            return false;\n+        }\n+\n+        match segments.len() {\n+            2 => segments[1].ident.to_string() != \"skip\",\n+            3 => {\n+                segments[1].ident.to_string() != \"skip\" || segments[2].ident.to_string() != \"macros\"\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn walk_mod_items(&mut self, m: &ast::Mod) {\n         self.visit_items_with_reordering(&ptr_vec_to_ref_vec(&m.items));\n     }\n@@ -817,6 +847,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             snippet_provider: self.snippet_provider,\n             macro_rewrite_failure: RefCell::new(false),\n             report: self.report.clone(),\n+            skip_macro_names: self.skip_macro_names.clone(),\n         }\n     }\n }"}, {"sha": "7e396b38388807071baeb53f9cca691e9088daea", "filename": "tests/source/issue-3434/lib.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Fsource%2Fissue-3434%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Fsource%2Fissue-3434%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434%2Flib.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -0,0 +1,57 @@\n+#![rustfmt::skip::macros(skip_macro_mod)]\n+\n+mod no_entry;\n+\n+#[rustfmt::skip::macros(html, skip_macro)]\n+fn main() {\n+    let macro_result1 = html! { <div>\n+this should be skipped</div>\n+    }\n+    .to_string();\n+\n+    let macro_result2 = not_skip_macro! { <div>\n+this should be mangled</div>\n+        }\n+    .to_string();\n+\n+    skip_macro! {\n+this should be skipped\n+};\n+\n+    foo();\n+}\n+\n+fn foo() {\n+    let macro_result1 = html! { <div>\n+this should be mangled</div>\n+            }\n+    .to_string();\n+}\n+\n+fn bar() {\n+    let macro_result1 = skip_macro_mod! { <div>\n+this should be skipped</div>\n+        }\n+    .to_string();\n+}\n+\n+fn visitor_made_from_same_context() {\n+    let pair = (\n+        || {\n+            foo!(<div>\n+this should be mangled</div>\n+            );\n+            skip_macro_mod!(<div>\n+this should be skipped</div>\n+            );\n+        },\n+        || {\n+            foo!(<div>\n+this should be mangled</div>\n+            );\n+            skip_macro_mod!(<div>\n+this should be skipped</div>\n+            );\n+        },\n+    );\n+}"}, {"sha": "0838829fed34893edf0574c7aeaf70a483e3d0ca", "filename": "tests/source/issue-3434/no_entry.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Fsource%2Fissue-3434%2Fno_entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Fsource%2Fissue-3434%2Fno_entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434%2Fno_entry.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -0,0 +1,18 @@\n+#[rustfmt::skip::macros(another_macro)]\n+fn foo() {\n+    another_macro!(\n+This should be skipped.\n+        );\n+}\n+\n+fn bar() {\n+    skip_macro_mod!(\n+This should be skipped.\n+        );\n+}\n+\n+fn baz() {\n+    let macro_result1 = no_skip_macro! { <div>\n+this should be mangled</div>\n+    }.to_string();\n+}"}, {"sha": "1d7d73c523d6228285795d51d58a676e63070ce8", "filename": "tests/source/issue-3434/not_skip_macro.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Fsource%2Fissue-3434%2Fnot_skip_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Fsource%2Fissue-3434%2Fnot_skip_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3434%2Fnot_skip_macro.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -0,0 +1,8 @@\n+#[this::is::not::skip::macros(ouch)]\n+\n+fn main() {\n+    let macro_result1 = ouch! { <div>\n+this should be mangled</div>\n+    }\n+    .to_string();\n+}"}, {"sha": "2fd7aea21c7582ea8b9cc106fd454edfa3cbce68", "filename": "tests/target/issue-3434/lib.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Ftarget%2Fissue-3434%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Ftarget%2Fissue-3434%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434%2Flib.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -0,0 +1,57 @@\n+#![rustfmt::skip::macros(skip_macro_mod)]\n+\n+mod no_entry;\n+\n+#[rustfmt::skip::macros(html, skip_macro)]\n+fn main() {\n+    let macro_result1 = html! { <div>\n+this should be skipped</div>\n+    }\n+    .to_string();\n+\n+    let macro_result2 = not_skip_macro! { <div>\n+    this should be mangled</div>\n+            }\n+    .to_string();\n+\n+    skip_macro! {\n+this should be skipped\n+};\n+\n+    foo();\n+}\n+\n+fn foo() {\n+    let macro_result1 = html! { <div>\n+    this should be mangled</div>\n+                }\n+    .to_string();\n+}\n+\n+fn bar() {\n+    let macro_result1 = skip_macro_mod! { <div>\n+this should be skipped</div>\n+        }\n+    .to_string();\n+}\n+\n+fn visitor_made_from_same_context() {\n+    let pair = (\n+        || {\n+            foo!(<div>\n+            this should be mangled</div>\n+                        );\n+            skip_macro_mod!(<div>\n+this should be skipped</div>\n+            );\n+        },\n+        || {\n+            foo!(<div>\n+            this should be mangled</div>\n+                        );\n+            skip_macro_mod!(<div>\n+this should be skipped</div>\n+            );\n+        },\n+    );\n+}"}, {"sha": "a2ecf2c2f99bdfa56f78f764a1d0b208e7e3f5b4", "filename": "tests/target/issue-3434/no_entry.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Ftarget%2Fissue-3434%2Fno_entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Ftarget%2Fissue-3434%2Fno_entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434%2Fno_entry.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -0,0 +1,19 @@\n+#[rustfmt::skip::macros(another_macro)]\n+fn foo() {\n+    another_macro!(\n+This should be skipped.\n+        );\n+}\n+\n+fn bar() {\n+    skip_macro_mod!(\n+This should be skipped.\n+        );\n+}\n+\n+fn baz() {\n+    let macro_result1 = no_skip_macro! { <div>\n+    this should be mangled</div>\n+        }\n+    .to_string();\n+}"}, {"sha": "c90d09744b281e3a9917e2f38a14084e9b263827", "filename": "tests/target/issue-3434/not_skip_macro.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Ftarget%2Fissue-3434%2Fnot_skip_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc26c5eacae010e80fdbe125917809414b627fa8/tests%2Ftarget%2Fissue-3434%2Fnot_skip_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3434%2Fnot_skip_macro.rs?ref=cc26c5eacae010e80fdbe125917809414b627fa8", "patch": "@@ -0,0 +1,8 @@\n+#[this::is::not::skip::macros(ouch)]\n+\n+fn main() {\n+    let macro_result1 = ouch! { <div>\n+    this should be mangled</div>\n+        }\n+    .to_string();\n+}"}]}