{"sha": "ef998308805748289e46bce394a5d539b12b0118", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOTk4MzA4ODA1NzQ4Mjg5ZTQ2YmNlMzk0YTVkNTM5YjEyYjAxMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-03T08:52:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-03T08:52:57Z"}, "message": "Auto merge of #1816 - Pointerbender:slices-tests, r=RalfJung\n\nregression tests for pointer invalidation in core library slice methods\n\nA fix for a pointer invalidation bug in `<[T]>::copy_within` has [landed](https://github.com/rust-lang/rust/pull/85610) on the Rust master branch. This PR updates the `rust-version` file to the latest master commit hash and adds extra tests to the Miri test suite to ensure that regressions of this type of bug can be detected for various slice methods with the `-Zmiri-track-raw-pointers` flag.\n\nI took the liberty of adding 2 extra  `#![feature]` attributes at the top of `slices.rs`, since there already was one unstable feature. I hope this is okay :smile:\n\nOne thing I noticed when running the entire Miri test suite with `MIRIFLAGS=\"-Zmiri-track-raw-pointers\" ./miri test` is that there are currently failing tests on the master branch:\n\n```\nfailures:\n    [ui] run-pass/align.rs\n    [ui] run-pass/box.rs\n    [ui] run-pass/concurrency/simple.rs\n    [ui] run-pass/libc.rs\n    [ui] run-pass/ptr_int_casts.rs\n    [ui] run-pass/stacked-borrows/int-to-ptr.rs\n\ntest result: FAILED. 199 passed; 6 failed; 1 ignored; 0 measured; 0 filtered out; finished in 12.95s\n```\n\nThese failures were not fixed in this PR and already existed prior to this PR. I haven't investigated these yet, but am interested in helping out if possible!\n\nThanks!", "tree": {"sha": "8683f87b7a2a251353084154a96272dab3245da6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8683f87b7a2a251353084154a96272dab3245da6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef998308805748289e46bce394a5d539b12b0118", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef998308805748289e46bce394a5d539b12b0118", "html_url": "https://github.com/rust-lang/rust/commit/ef998308805748289e46bce394a5d539b12b0118", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef998308805748289e46bce394a5d539b12b0118/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dde0fe6de2941c9ef16bc1e9d91ecf20ac5ee8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dde0fe6de2941c9ef16bc1e9d91ecf20ac5ee8b", "html_url": "https://github.com/rust-lang/rust/commit/5dde0fe6de2941c9ef16bc1e9d91ecf20ac5ee8b"}, {"sha": "e21dae71c8f331cc2c1cd29f90447508fb1caa2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e21dae71c8f331cc2c1cd29f90447508fb1caa2b", "html_url": "https://github.com/rust-lang/rust/commit/e21dae71c8f331cc2c1cd29f90447508fb1caa2b"}], "stats": {"total": 65, "additions": 65, "deletions": 0}, "files": [{"sha": "83d9ff1151889d392fd81fa9de568a77c026da4b", "filename": "tests/run-pass/slices.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ef998308805748289e46bce394a5d539b12b0118/tests%2Frun-pass%2Fslices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef998308805748289e46bce394a5d539b12b0118/tests%2Frun-pass%2Fslices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fslices.rs?ref=ef998308805748289e46bce394a5d539b12b0118", "patch": "@@ -1,4 +1,7 @@\n+// compile-flags: -Zmiri-track-raw-pointers\n #![feature(new_uninit)]\n+#![feature(slice_as_chunks)]\n+#![feature(slice_partition_dedup)]\n \n use std::slice;\n \n@@ -186,8 +189,70 @@ fn uninit_slice() {\n     assert_eq!(values.iter().map(|x| **x).collect::<Vec<_>>(), vec![1, 2, 3])\n }\n \n+/// Regression tests for slice methods in the Rust core library where raw pointers are obtained\n+/// from mutable references.\n+fn test_for_invalidated_pointers() {\n+    let mut buffer = [0usize; 64];\n+    let len = buffer.len();\n+\n+    // These regression tests (indirectly) call every slice method which contains a `buffer.as_mut_ptr()`.\n+    // `<[T]>::as_mut_ptr(&mut self)` takes a mutable reference (tagged Unique), which will invalidate all\n+    // the other pointers that were previously derived from it according to the Stacked Borrows model.\n+    // An example of where this could go wrong is a prior bug inside `<[T]>::copy_within`:\n+    //\n+    //      unsafe {\n+    //          core::ptr::copy(self.as_ptr().add(src_start), self.as_mut_ptr().add(dest), count);\n+    //      }\n+    //\n+    // The arguments to `core::ptr::copy` are evaluated from left to right. `self.as_ptr()` creates\n+    // an immutable reference (which is tagged as `SharedReadOnly` by Stacked Borrows) to the array\n+    // and derives a valid `*const` pointer from it. When jumping to the next argument,\n+    // `self.as_mut_ptr()` creates a mutable reference (tagged as `Unique`) to the array, which\n+    // invalidates the existing `SharedReadOnly` reference and any pointers derived from it.\n+    // The invalidated `*const` pointer (the first argument to `core::ptr::copy`) is then used\n+    // after the fact when `core::ptr::copy` is called, which triggers undefined behavior.\n+\n+    unsafe { assert_eq!(0, *buffer.as_mut_ptr_range().start ); }\n+    // Check that the pointer range is in-bounds, while we're at it\n+    let range = buffer.as_mut_ptr_range();\n+    unsafe { assert_eq!(*range.start, *range.end.sub(len)); }\n+\n+    buffer.reverse();\n+\n+    // Calls `fn as_chunks_unchecked_mut` internally (requires unstable `#![feature(slice_as_chunks)]`):\n+    assert_eq!(2, buffer.as_chunks_mut::<32>().0.len());\n+    for chunk in buffer.as_chunks_mut::<32>().0 {\n+        for elem in chunk {\n+            *elem += 1;\n+        }\n+    }\n+\n+    // Calls `fn split_at_mut_unchecked` internally:\n+    let split_mut = buffer.split_at_mut(32);\n+    assert_eq!(split_mut.0, split_mut.1);\n+\n+    // Calls `fn partition_dedup_by` internally (requires unstable `#![feature(slice_partition_dedup)]`):\n+    let partition_dedup = buffer.partition_dedup();\n+    assert_eq!(1, partition_dedup.0.len());\n+    partition_dedup.0[0] += 1;\n+    for elem in partition_dedup.1 {\n+        *elem += 1;\n+    }\n+\n+    buffer.rotate_left(8);\n+    buffer.rotate_right(16);\n+\n+    buffer.copy_from_slice(&[1usize; 64]);\n+    buffer.swap_with_slice(&mut [2usize; 64]);\n+\n+    assert_eq!(0, unsafe { buffer.align_to_mut::<u8>().1[1] });\n+\n+    buffer.copy_within(1.., 0);\n+}\n+\n fn main() {\n     slice_of_zst();\n     test_iter_ref_consistency();\n     uninit_slice();\n+    test_for_invalidated_pointers();\n }"}]}