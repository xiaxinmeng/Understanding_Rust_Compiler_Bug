{"sha": "23808efd11be2a9f964373bd8d684d98565e58d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzODA4ZWZkMTFiZTJhOWY5NjQzNzNiZDhkNjg0ZDk4NTY1ZTU4ZDA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-06-01T22:31:56Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-06-01T22:31:56Z"}, "message": "syntax: move callee_id into the expr_ variants", "tree": {"sha": "07254eee07e980804e288f37af88415730a4675f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07254eee07e980804e288f37af88415730a4675f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23808efd11be2a9f964373bd8d684d98565e58d0", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23808efd11be2a9f964373bd8d684d98565e58d0", "html_url": "https://github.com/rust-lang/rust/commit/23808efd11be2a9f964373bd8d684d98565e58d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23808efd11be2a9f964373bd8d684d98565e58d0/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "871684376f504dc58b53f5d5cd55ccb7d7f4b2ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/871684376f504dc58b53f5d5cd55ccb7d7f4b2ea", "html_url": "https://github.com/rust-lang/rust/commit/871684376f504dc58b53f5d5cd55ccb7d7f4b2ea"}], "stats": {"total": 626, "additions": 337, "deletions": 289}, "files": [{"sha": "c6410d16c7429d01d6c8d9d56c406698b978e798", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -78,7 +78,6 @@ pub fn common_exprs() -> ~[@ast::expr] {\n     fn dse(e: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: 0,\n-            callee_id: -1,\n             node: e,\n             span: codemap::dummy_sp(),\n         }\n@@ -94,9 +93,9 @@ pub fn common_exprs() -> ~[@ast::expr] {\n      dse(ast::expr_lit(@dsl(ast::lit_nil))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(false)))),\n      dse(ast::expr_lit(@dsl(ast::lit_bool(true)))),\n-     dse(ast::expr_unary(ast::box(ast::m_imm),\n+     dse(ast::expr_unary(-1, ast::box(ast::m_imm),\n                          dse(ast::expr_lit(@dsl(ast::lit_bool(true)))))),\n-     dse(ast::expr_unary(ast::uniq(ast::m_imm),\n+     dse(ast::expr_unary(-1, ast::uniq(ast::m_imm),\n                          dse(ast::expr_lit(@dsl(ast::lit_bool(true))))))\n     ]\n }\n@@ -128,7 +127,7 @@ pub fn safe_to_use_expr(e: @ast::expr, tm: test_mode) -> bool {\n           //ast::expr_cast(_, _) { false }\n \n           // https://github.com/mozilla/rust/issues/1458\n-          ast::expr_call(_, _, _) => { false }\n+          ast::expr_call(*) => { false }\n \n           _ => { true }\n         }"}, {"sha": "8cd8a989352589c255207aa1ce46a1fe7b1c4f56", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -394,14 +394,12 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     let sess = cx.sess;\n     let inner_expr = @ast::expr {\n         id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n         node: ast::expr_vec(descs, ast::m_imm),\n         span: dummy_sp(),\n     };\n \n     @ast::expr {\n         id: sess.next_node_id(),\n-        callee_id: sess.next_node_id(),\n         node: ast::expr_vstore(inner_expr, ast::expr_vstore_slice),\n         span: dummy_sp(),\n     }\n@@ -423,7 +421,6 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n \n     let name_expr = @ast::expr {\n           id: cx.sess.next_node_id(),\n-          callee_id: cx.sess.next_node_id(),\n           node: ast::expr_lit(@name_lit),\n           span: span\n     };\n@@ -432,7 +429,6 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n \n     let fn_expr = @ast::expr {\n         id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n         node: ast::expr_path(fn_path),\n         span: span,\n     };"}, {"sha": "7890e1b9f35bb3170727cdc103dea9d429cf6165", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -707,29 +707,29 @@ fn check_loans_in_expr<'a>(expr: @ast::expr,\n           }\n       }\n       ast::expr_assign(dest, _) |\n-      ast::expr_assign_op(_, dest, _) => {\n+      ast::expr_assign_op(_, _, dest, _) => {\n         this.check_assignment(dest);\n       }\n       ast::expr_call(f, ref args, _) => {\n         this.check_call(expr, Some(f), f.id, f.span, *args);\n       }\n-      ast::expr_method_call(_, _, _, ref args, _) => {\n-        this.check_call(expr, None, expr.callee_id, expr.span, *args);\n+      ast::expr_method_call(callee_id, _, _, _, ref args, _) => {\n+        this.check_call(expr, None, callee_id, expr.span, *args);\n       }\n-      ast::expr_index(_, rval) |\n-      ast::expr_binary(_, _, rval)\n+      ast::expr_index(callee_id, _, rval) |\n+      ast::expr_binary(callee_id, _, _, rval)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n-                        expr.callee_id,\n+                        callee_id,\n                         expr.span,\n                         [rval]);\n       }\n-      ast::expr_unary(*) | ast::expr_index(*)\n+      ast::expr_unary(callee_id, _, _) | ast::expr_index(callee_id, _, _)\n       if this.bccx.method_map.contains_key(&expr.id) => {\n         this.check_call(expr,\n                         None,\n-                        expr.callee_id,\n+                        callee_id,\n                         expr.span,\n                         []);\n       }"}, {"sha": "448f35faa469a029ab57d20b3f3e9c0221e9062e", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -175,7 +175,10 @@ fn gather_loans_in_expr(ex: @ast::expr,\n            ex.id, pprust::expr_to_str(ex, tcx.sess.intr()));\n \n     this.id_range.add(ex.id);\n-    this.id_range.add(ex.callee_id);\n+\n+    for ex.get_callee_id().each |callee_id| {\n+        this.id_range.add(*callee_id);\n+    }\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     for tcx.adjustments.find(&ex.id).each |&adjustments| {\n@@ -201,7 +204,7 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, this, vt);\n       }\n \n-      ast::expr_assign(l, _) | ast::expr_assign_op(_, l, _) => {\n+      ast::expr_assign(l, _) | ast::expr_assign_op(_, _, l, _) => {\n           let l_cmt = this.bccx.cat_expr(l);\n           match opt_loan_path(l_cmt) {\n               Some(l_lp) => {\n@@ -228,8 +231,8 @@ fn gather_loans_in_expr(ex: @ast::expr,\n         visit::visit_expr(ex, this, vt);\n       }\n \n-      ast::expr_index(_, arg) |\n-      ast::expr_binary(_, _, arg)\n+      ast::expr_index(_, _, arg) |\n+      ast::expr_binary(_, _, _, arg)\n       if this.bccx.method_map.contains_key(&ex.id) => {\n           // Arguments in method calls are always passed by ref.\n           //"}, {"sha": "0cffc9c52c22b3c4c189c0a53c190c9618781b64", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -91,14 +91,14 @@ pub fn check_expr(sess: Session,\n                   v: visit::vt<bool>) {\n     if is_const {\n         match e.node {\n-          expr_unary(deref, _) => { }\n-          expr_unary(box(_), _) | expr_unary(uniq(_), _) => {\n+          expr_unary(_, deref, _) => { }\n+          expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) => {\n             sess.span_err(e.span,\n                           \"disallowed operator in constant expression\");\n             return;\n           }\n           expr_lit(@codemap::spanned {node: lit_str(_), _}) => { }\n-          expr_binary(_, _, _) | expr_unary(_, _) => {\n+          expr_binary(*) | expr_unary(*) => {\n             if method_map.contains_key(&e.id) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");"}, {"sha": "7e8e5bffb5705cd3518ddd43aaf11e4d401fe703", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -93,12 +93,12 @@ pub fn classify(e: @expr,\n               }\n \n               ast::expr_copy(inner) |\n-              ast::expr_unary(_, inner) |\n+              ast::expr_unary(_, _, inner) |\n               ast::expr_paren(inner) => {\n                 classify(inner, tcx)\n               }\n \n-              ast::expr_binary(_, a, b) => {\n+              ast::expr_binary(_, _, a, b) => {\n                 join(classify(a, tcx),\n                      classify(b, tcx))\n               }\n@@ -141,7 +141,7 @@ pub fn classify(e: @expr,\n                 classify(base, tcx)\n               }\n \n-              ast::expr_index(base, idx) => {\n+              ast::expr_index(_, base, idx) => {\n                 join(classify(base, tcx),\n                      classify(idx, tcx))\n               }\n@@ -251,7 +251,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n     use middle::ty;\n     fn fromb(b: bool) -> Result<const_val, ~str> { Ok(const_int(b as i64)) }\n     match e.node {\n-      expr_unary(neg, inner) => {\n+      expr_unary(_, neg, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_float(f)) => Ok(const_float(-f)),\n           Ok(const_int(i)) => Ok(const_int(-i)),\n@@ -261,15 +261,15 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n           ref err => (/*bad*/copy *err)\n         }\n       }\n-      expr_unary(not, inner) => {\n+      expr_unary(_, not, inner) => {\n         match eval_const_expr_partial(tcx, inner) {\n           Ok(const_int(i)) => Ok(const_int(!i)),\n           Ok(const_uint(i)) => Ok(const_uint(!i)),\n           Ok(const_bool(b)) => Ok(const_bool(!b)),\n           _ => Err(~\"Not on float or string\")\n         }\n       }\n-      expr_binary(op, a, b) => {\n+      expr_binary(_, op, a, b) => {\n         match (eval_const_expr_partial(tcx, a),\n                eval_const_expr_partial(tcx, b)) {\n           (Ok(const_float(a)), Ok(const_float(b))) => {"}, {"sha": "aedc0e1db5e9dd960ca82f4fe82a60a6d01ab18d", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -639,7 +639,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_assign(l, r) |\n-            ast::expr_assign_op(_, l, r) => {\n+            ast::expr_assign_op(_, _, l, r) => {\n                 self.walk_expr(r, in_out, loop_scopes);\n                 self.walk_expr(l, in_out, loop_scopes);\n             }\n@@ -661,40 +661,40 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::expr_call(f, ref args, _) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+                self.walk_call(f.id, expr.id,\n                                f, *args, in_out, loop_scopes);\n             }\n \n-            ast::expr_method_call(rcvr, _, _, ref args, _) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+            ast::expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n+                self.walk_call(callee_id, expr.id,\n                                rcvr, *args, in_out, loop_scopes);\n             }\n \n-            ast::expr_index(l, r) |\n-            ast::expr_binary(_, l, r) if self.is_method_call(expr) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+            ast::expr_index(callee_id, l, r) |\n+            ast::expr_binary(callee_id, _, l, r) if self.is_method_call(expr) => {\n+                self.walk_call(callee_id, expr.id,\n                                l, [r], in_out, loop_scopes);\n             }\n \n-            ast::expr_unary(_, e) if self.is_method_call(expr) => {\n-                self.walk_call(expr.callee_id, expr.id,\n+            ast::expr_unary(callee_id, _, e) if self.is_method_call(expr) => {\n+                self.walk_call(callee_id, expr.id,\n                                e, [], in_out, loop_scopes);\n             }\n \n             ast::expr_tup(ref exprs) => {\n                 self.walk_exprs(*exprs, in_out, loop_scopes);\n             }\n \n-            ast::expr_binary(op, l, r) if ast_util::lazy_binop(op) => {\n+            ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n                 let temp = reslice(in_out).to_vec();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n \n             ast::expr_log(l, r) |\n-            ast::expr_index(l, r) |\n-            ast::expr_binary(_, l, r) => {\n+            ast::expr_index(_, l, r) |\n+            ast::expr_binary(_, _, l, r) => {\n                 self.walk_exprs([l, r], in_out, loop_scopes);\n             }\n \n@@ -708,7 +708,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             ast::expr_loop_body(e) |\n             ast::expr_do_body(e) |\n             ast::expr_cast(e, _) |\n-            ast::expr_unary(_, e) |\n+            ast::expr_unary(_, _, e) |\n             ast::expr_paren(e) |\n             ast::expr_vstore(e, _) |\n             ast::expr_field(e, _, _) => {"}, {"sha": "895c6cc477f93e3649db0bab1fe8dd18bfb26bb9", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -111,8 +111,8 @@ pub fn check_crate(tcx: ty::ctxt,\n \n         visit_expr: |expr, _, visitor| {\n             match expr.node {\n-                expr_method_call(*) => {\n-                    let base_type = ty::node_id_to_type(tcx, expr.callee_id);\n+                expr_method_call(callee_id, _, _, _, _, _) => {\n+                    let base_type = ty::node_id_to_type(tcx, callee_id);\n                     debug!(\"effect: method call case, base type is %s\",\n                            ppaux::ty_to_str(tcx, base_type));\n                     if type_is_unsafe_function(base_type) {\n@@ -128,7 +128,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         require_unsafe(expr.span, \"call to unsafe function\")\n                     }\n                 }\n-                expr_unary(deref, base) => {\n+                expr_unary(_, deref, base) => {\n                     let base_type = ty::node_id_to_type(tcx, base.id);\n                     debug!(\"effect: unary case, base type is %s\",\n                            ppaux::ty_to_str(tcx, base_type));"}, {"sha": "48983dcadc8b4e1823d1327dc7a504130df01ec7", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -241,10 +241,9 @@ pub fn check_expr(e: @expr, cx: Context, v: visit::vt<Context>) {\n     debug!(\"kind::check_expr(%s)\", expr_to_str(e, cx.tcx.sess.intr()));\n \n     // Handle any kind bounds on type parameters\n-    let type_parameter_id = match e.node {\n-        expr_index(*)|expr_assign_op(*)|\n-        expr_unary(*)|expr_binary(*)|expr_method_call(*) => e.callee_id,\n-        _ => e.id\n+    let type_parameter_id = match e.get_callee_id() {\n+        Some(callee_id) => callee_id,\n+        None => e.id,\n     };\n     for cx.tcx.node_type_substs.find(&type_parameter_id).each |ts| {\n         let type_param_defs = match e.node {"}, {"sha": "703516251dcdc41e12aaec6260230b1b88691ce0", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -675,7 +675,7 @@ fn lint_type_limits() -> visit::vt<@mut Context> {\n     visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, cx: @mut Context, vt| {\n             match e.node {\n-                ast::expr_binary(ref binop, @ref l, @ref r) => {\n+                ast::expr_binary(_, ref binop, @ref l, @ref r) => {\n                     if is_comparison(*binop)\n                         && !check_limits(cx, *binop, l, r) {\n                         cx.span_lint(type_limits, e.span,"}, {"sha": "6e60851ad1430da334486da8de8759299cf03025", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -499,7 +499,7 @@ fn visit_expr(expr: @expr, this: @mut IrMaps, vt: vt<@mut IrMaps>) {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::visit_expr(expr, this, vt);\n       }\n-      expr_binary(op, _, _) if ast_util::lazy_binop(op) => {\n+      expr_binary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::visit_expr(expr, this, vt);\n       }\n@@ -1138,7 +1138,7 @@ impl Liveness {\n             self.propagate_through_expr(r, succ)\n           }\n \n-          expr_assign_op(_, l, r) => {\n+          expr_assign_op(_, _, l, r) => {\n             // see comment on lvalues in\n             // propagate_through_lvalue_components()\n             let succ = self.write_lvalue(l, succ, ACC_WRITE|ACC_READ);\n@@ -1178,11 +1178,10 @@ impl Liveness {\n             self.propagate_through_expr(f, succ)\n           }\n \n-          expr_method_call(rcvr, _, _, ref args, _) => {\n+          expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n             // calling a method with bot return type means that the method\n             // will fail, and hence the successors can be ignored\n-            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx,\n-                                                          expr.callee_id));\n+            let t_ret = ty::ty_fn_ret(ty::node_id_to_type(self.tcx, callee_id));\n             let succ = if ty::type_is_bot(t_ret) {self.s.exit_ln}\n                        else {succ};\n             let succ = self.propagate_through_exprs(*args, succ);\n@@ -1193,7 +1192,7 @@ impl Liveness {\n             self.propagate_through_exprs(*exprs, succ)\n           }\n \n-          expr_binary(op, l, r) if ast_util::lazy_binop(op) => {\n+          expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n             let r_succ = self.propagate_through_expr(r, succ);\n \n             let ln = self.live_node(expr.id, expr.span);\n@@ -1204,8 +1203,8 @@ impl Liveness {\n           }\n \n           expr_log(l, r) |\n-          expr_index(l, r) |\n-          expr_binary(_, l, r) => {\n+          expr_index(_, l, r) |\n+          expr_binary(_, _, l, r) => {\n             self.propagate_through_exprs([l, r], succ)\n           }\n \n@@ -1214,7 +1213,7 @@ impl Liveness {\n           expr_loop_body(e) |\n           expr_do_body(e) |\n           expr_cast(e, _) |\n-          expr_unary(_, e) |\n+          expr_unary(_, _, e) |\n           expr_paren(e) => {\n             self.propagate_through_expr(e, succ)\n           }\n@@ -1456,7 +1455,7 @@ fn check_expr(expr: @expr, this: @Liveness, vt: vt<@Liveness>) {\n         visit::visit_expr(expr, this, vt);\n       }\n \n-      expr_assign_op(_, l, _) => {\n+      expr_assign_op(_, _, l, _) => {\n         this.check_lvalue(l, vt);\n \n         visit::visit_expr(expr, this, vt);"}, {"sha": "f54e1e623ecd961008d818766136f4fe1fc1ad38", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -389,7 +389,7 @@ impl mem_categorization_ctxt {\n \n         let expr_ty = self.expr_ty(expr);\n         match expr.node {\n-          ast::expr_unary(ast::deref, e_base) => {\n+          ast::expr_unary(_, ast::deref, e_base) => {\n             if self.method_map.contains_key(&expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }\n@@ -407,7 +407,7 @@ impl mem_categorization_ctxt {\n             self.cat_field(expr, base_cmt, f_name, self.expr_ty(expr))\n           }\n \n-          ast::expr_index(base, _) => {\n+          ast::expr_index(_, base, _) => {\n             if self.method_map.contains_key(&expr.id) {\n                 return self.cat_rvalue(expr, expr_ty);\n             }"}, {"sha": "caa18b2834fe52c12b616968b91f041ed68333ac", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -310,7 +310,7 @@ impl VisitContext {\n                 }\n             }\n \n-            expr_unary(deref, base) => {       // *base\n+            expr_unary(_, deref, base) => {       // *base\n                 if !self.use_overloaded_operator(\n                     expr, base, [], visitor)\n                 {\n@@ -324,7 +324,7 @@ impl VisitContext {\n                 self.use_expr(base, comp_mode, visitor);\n             }\n \n-            expr_index(lhs, rhs) => {          // lhs[rhs]\n+            expr_index(_, lhs, rhs) => {          // lhs[rhs]\n                 if !self.use_overloaded_operator(\n                     expr, lhs, [rhs], visitor)\n                 {\n@@ -338,11 +338,11 @@ impl VisitContext {\n                 self.use_fn_args(callee.id, *args, visitor);\n             }\n \n-            expr_method_call(callee, _, _, ref args, _) => { // callee.m(args)\n+            expr_method_call(callee_id, rcvr, _, _, ref args, _) => { // callee.m(args)\n                 // Implicit self is equivalent to & mode, but every\n                 // other kind should be + mode.\n-                self.use_receiver(callee, visitor);\n-                self.use_fn_args(expr.callee_id, *args, visitor);\n+                self.use_receiver(rcvr, visitor);\n+                self.use_fn_args(callee_id, *args, visitor);\n             }\n \n             expr_struct(_, ref fields, opt_with) => {\n@@ -444,15 +444,15 @@ impl VisitContext {\n                 self.consume_block(blk, visitor);\n             }\n \n-            expr_unary(_, lhs) => {\n+            expr_unary(_, _, lhs) => {\n                 if !self.use_overloaded_operator(\n                     expr, lhs, [], visitor)\n                 {\n                     self.consume_expr(lhs, visitor);\n                 }\n             }\n \n-            expr_binary(_, lhs, rhs) => {\n+            expr_binary(_, _, lhs, rhs) => {\n                 if !self.use_overloaded_operator(\n                     expr, lhs, [rhs], visitor)\n                 {\n@@ -480,7 +480,7 @@ impl VisitContext {\n                 self.consume_expr(base, visitor);\n             }\n \n-            expr_assign_op(_, lhs, rhs) => {\n+            expr_assign_op(_, _, lhs, rhs) => {\n                 // FIXME(#4712) --- Overloaded operators?\n                 //\n                 // if !self.use_overloaded_operator("}, {"sha": "1e596ee6b3650a7788eb8e033b949d9a3b0d0da6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -432,32 +432,23 @@ pub fn check_crate(tcx: ty::ctxt,\n         visit_expr: |expr, method_map: &method_map, visitor| {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n+                    // Method calls are now a special syntactic form,\n+                    // so `a.b` should always be a field.\n+                    assert!(!method_map.contains_key(&expr.id));\n+\n                     // With type_autoderef, make sure we don't\n                     // allow pointers to violate privacy\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != local_crate ||\n-                           !privileged_items.contains(&(id.node)) => {\n-                            match method_map.find(&expr.id) {\n-                                None => {\n-                                    debug!(\"(privacy checking) checking \\\n-                                            field access\");\n-                                    check_field(expr.span, id, ident);\n-                                }\n-                                Some(ref entry) => {\n-                                    debug!(\"(privacy checking) checking \\\n-                                            impl method\");\n-                                    check_method(expr.span,\n-                                                 &entry.origin,\n-                                                 ident);\n-                                }\n-                            }\n+                        if id.crate != local_crate || !privileged_items.contains(&(id.node)) => {\n+                            debug!(\"(privacy checking) checking field access\");\n+                            check_field(expr.span, id, ident);\n                         }\n                         _ => {}\n                     }\n                 }\n-                expr_method_call(base, ident, _, _, _) => {\n+                expr_method_call(_, base, ident, _, _, _) => {\n                     // Ditto\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n@@ -529,7 +520,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         }\n                     }\n                 }\n-                expr_unary(ast::deref, operand) => {\n+                expr_unary(_, ast::deref, operand) => {\n                     // In *e, we need to check that if e's type is an\n                     // enum type t, then t's first variant is public or\n                     // privileged. (We can assume it has only one variant"}, {"sha": "a1eb0726c3d76adcb253f48caa9e7ee6925aa185", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -4969,67 +4969,71 @@ impl Resolver {\n                                                          expr: @expr) {\n         match expr.node {\n             expr_field(_, ident, _) => {\n+                // FIXME(#6890): Even though you can't treat a method like a\n+                // field, we need to add any trait methods we find that match\n+                // the field name so that we can do some nice error reporting\n+                // later on in typeck.\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n-            expr_method_call(_, ident, _, _, _) => {\n+            expr_method_call(_, _, ident, _, _, _) => {\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n-            expr_binary(add, _, _) | expr_assign_op(add, _, _) => {\n+            expr_binary(_, add, _, _) | expr_assign_op(_, add, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.add_trait());\n             }\n-            expr_binary(subtract, _, _) | expr_assign_op(subtract, _, _) => {\n+            expr_binary(_, subtract, _, _) | expr_assign_op(_, subtract, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.sub_trait());\n             }\n-            expr_binary(mul, _, _) | expr_assign_op(mul, _, _) => {\n+            expr_binary(_, mul, _, _) | expr_assign_op(_, mul, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.mul_trait());\n             }\n-            expr_binary(div, _, _) | expr_assign_op(div, _, _) => {\n+            expr_binary(_, div, _, _) | expr_assign_op(_, div, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.div_trait());\n             }\n-            expr_binary(rem, _, _) | expr_assign_op(rem, _, _) => {\n+            expr_binary(_, rem, _, _) | expr_assign_op(_, rem, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.rem_trait());\n             }\n-            expr_binary(bitxor, _, _) | expr_assign_op(bitxor, _, _) => {\n+            expr_binary(_, bitxor, _, _) | expr_assign_op(_, bitxor, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.bitxor_trait());\n             }\n-            expr_binary(bitand, _, _) | expr_assign_op(bitand, _, _) => {\n+            expr_binary(_, bitand, _, _) | expr_assign_op(_, bitand, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.bitand_trait());\n             }\n-            expr_binary(bitor, _, _) | expr_assign_op(bitor, _, _) => {\n+            expr_binary(_, bitor, _, _) | expr_assign_op(_, bitor, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.bitor_trait());\n             }\n-            expr_binary(shl, _, _) | expr_assign_op(shl, _, _) => {\n+            expr_binary(_, shl, _, _) | expr_assign_op(_, shl, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.shl_trait());\n             }\n-            expr_binary(shr, _, _) | expr_assign_op(shr, _, _) => {\n+            expr_binary(_, shr, _, _) | expr_assign_op(_, shr, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.shr_trait());\n             }\n-            expr_binary(lt, _, _) | expr_binary(le, _, _) |\n-            expr_binary(ge, _, _) | expr_binary(gt, _, _) => {\n+            expr_binary(_, lt, _, _) | expr_binary(_, le, _, _) |\n+            expr_binary(_, ge, _, _) | expr_binary(_, gt, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.ord_trait());\n             }\n-            expr_binary(eq, _, _) | expr_binary(ne, _, _) => {\n+            expr_binary(_, eq, _, _) | expr_binary(_, ne, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.eq_trait());\n             }\n-            expr_unary(neg, _) => {\n+            expr_unary(_, neg, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.neg_trait());\n             }\n-            expr_unary(not, _) => {\n+            expr_unary(_, not, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.not_trait());\n             }"}, {"sha": "767b02d13e2efffab6fe4535c339cd40b83cf02e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -328,6 +328,7 @@ pub fn trans_call(in_cx: block,\n \n pub fn trans_method_call(in_cx: block,\n                          call_ex: @ast::expr,\n+                         callee_id: ast::node_id,\n                          rcvr: @ast::expr,\n                          args: CallArgs,\n                          dest: expr::Dest)\n@@ -339,7 +340,7 @@ pub fn trans_method_call(in_cx: block,\n     trans_call_inner(\n         in_cx,\n         call_ex.info(),\n-        node_id_type(in_cx, call_ex.callee_id),\n+        node_id_type(in_cx, callee_id),\n         expr_ty(in_cx, call_ex),\n         |cx| {\n             match cx.ccx().maps.method_map.find_copy(&call_ex.id) {\n@@ -349,7 +350,7 @@ pub fn trans_method_call(in_cx: block,\n                            origin.repr(in_cx.tcx()));\n \n                     meth::trans_method_callee(cx,\n-                                              call_ex.callee_id,\n+                                              callee_id,\n                                               rcvr,\n                                               origin)\n                 }"}, {"sha": "717cae096f6bcc3a904a3e515cd5c511420003a3", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -611,7 +611,7 @@ pub trait get_node_info {\n impl get_node_info for @ast::expr {\n     fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo {id: self.id,\n-                       callee_id: Some(self.callee_id),\n+                       callee_id: self.get_callee_id(),\n                        span: self.span})\n     }\n }"}, {"sha": "62704fd1eb06ea2fd71c12fc2cba036aba371486", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -251,7 +251,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n         let _icx = cx.insn_ctxt(\"const_expr\");\n         return match e.node {\n           ast::expr_lit(lit) => consts::const_lit(cx, e, *lit),\n-          ast::expr_binary(b, e1, e2) => {\n+          ast::expr_binary(_, b, e1, e2) => {\n             let te1 = const_expr(cx, e1);\n             let te2 = const_expr(cx, e2);\n \n@@ -333,7 +333,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               },\n             };\n           },\n-          ast::expr_unary(u, e) => {\n+          ast::expr_unary(_, u, e) => {\n             let te = const_expr(cx, e);\n             let ty = ty::expr_ty(cx.tcx, e);\n             let is_float = ty::type_is_fp(ty);\n@@ -372,7 +372,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n               }\n           }\n \n-          ast::expr_index(base, index) => {\n+          ast::expr_index(_, base, index) => {\n               let bt = ty::expr_ty_adjusted(cx.tcx, base);\n               let bv = const_expr(cx, base);\n               let iv = match const_eval::eval_const_expr(cx.tcx, index) {"}, {"sha": "90275f9a9c2d2d64f5cbf41615896e2ba26d04b4", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -470,13 +470,13 @@ fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         ast::expr_lit(lit) => {\n             return trans_immediate_lit(bcx, expr, *lit);\n         }\n-        ast::expr_binary(op, lhs, rhs) => {\n+        ast::expr_binary(_, op, lhs, rhs) => {\n             // if overloaded, would be RvalueDpsExpr\n             assert!(!bcx.ccx().maps.method_map.contains_key(&expr.id));\n \n             return trans_binary(bcx, expr, op, lhs, rhs);\n         }\n-        ast::expr_unary(op, x) => {\n+        ast::expr_unary(_, op, x) => {\n             return trans_unary_datum(bcx, expr, op, x);\n         }\n         ast::expr_addr_of(_, x) => {\n@@ -535,8 +535,8 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n             return src_datum.store_to_datum(\n                 bcx, src.id, DROP_EXISTING, dst_datum);\n         }\n-        ast::expr_assign_op(op, dst, src) => {\n-            return trans_assign_op(bcx, expr, op, dst, src);\n+        ast::expr_assign_op(callee_id, op, dst, src) => {\n+            return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n         }\n         ast::expr_paren(a) => {\n             return trans_rvalue_stmt_unadjusted(bcx, a);\n@@ -641,35 +641,39 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n             return callee::trans_call(\n                 bcx, expr, f, callee::ArgExprs(*args), expr.id, dest);\n         }\n-        ast::expr_method_call(rcvr, _, _, ref args, _) => {\n+        ast::expr_method_call(callee_id, rcvr, _, _, ref args, _) => {\n             return callee::trans_method_call(bcx,\n                                              expr,\n+                                             callee_id,\n                                              rcvr,\n                                              callee::ArgExprs(*args),\n                                              dest);\n         }\n-        ast::expr_binary(_, lhs, rhs) => {\n+        ast::expr_binary(callee_id, _, lhs, rhs) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx,\n                                        expr,\n+                                       callee_id,\n                                        lhs,\n                                        ~[rhs],\n                                        expr_ty(bcx, expr),\n                                        dest);\n         }\n-        ast::expr_unary(_, subexpr) => {\n+        ast::expr_unary(callee_id, _, subexpr) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx,\n                                        expr,\n+                                       callee_id,\n                                        subexpr,\n                                        ~[],\n                                        expr_ty(bcx, expr),\n                                        dest);\n         }\n-        ast::expr_index(base, idx) => {\n+        ast::expr_index(callee_id, base, idx) => {\n             // if not overloaded, would be RvalueDatumExpr\n             return trans_overloaded_op(bcx,\n                                        expr,\n+                                       callee_id,\n                                        base,\n                                        ~[idx],\n                                        expr_ty(bcx, expr),\n@@ -687,8 +691,8 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                 }\n             }\n         }\n-        ast::expr_assign_op(op, dst, src) => {\n-            return trans_assign_op(bcx, expr, op, dst, src);\n+        ast::expr_assign_op(callee_id, op, dst, src) => {\n+            return trans_assign_op(bcx, expr, callee_id, op, dst, src);\n         }\n         _ => {\n             bcx.tcx().sess.span_bug(\n@@ -822,10 +826,10 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         ast::expr_field(base, ident, _) => {\n             trans_rec_field(bcx, base, ident)\n         }\n-        ast::expr_index(base, idx) => {\n+        ast::expr_index(_, base, idx) => {\n             trans_index(bcx, expr, base, idx)\n         }\n-        ast::expr_unary(ast::deref, base) => {\n+        ast::expr_unary(_, ast::deref, base) => {\n             let basedatum = unpack_datum!(bcx, trans_to_datum(bcx, base));\n             basedatum.deref(bcx, expr, 0)\n         }\n@@ -1514,20 +1518,21 @@ fn trans_binary(bcx: block,\n \n fn trans_overloaded_op(bcx: block,\n                        expr: @ast::expr,\n+                       callee_id: ast::node_id,\n                        rcvr: @ast::expr,\n                        args: ~[@ast::expr],\n                        ret_ty: ty::t,\n                        dest: Dest)\n                        -> block {\n     let origin = bcx.ccx().maps.method_map.get_copy(&expr.id);\n-    let fty = node_id_type(bcx, expr.callee_id);\n+    let fty = node_id_type(bcx, callee_id);\n     callee::trans_call_inner(bcx,\n                              expr.info(),\n                              fty,\n                              ret_ty,\n                              |bcx| {\n                                 meth::trans_method_callee(bcx,\n-                                                          expr.callee_id,\n+                                                          callee_id,\n                                                           rcvr,\n                                                           origin)\n                              },\n@@ -1652,6 +1657,7 @@ fn trans_imm_cast(bcx: block, expr: @ast::expr,\n \n fn trans_assign_op(bcx: block,\n                    expr: @ast::expr,\n+                   callee_id: ast::node_id,\n                    op: ast::binop,\n                    dst: @ast::expr,\n                    src: @ast::expr) -> block\n@@ -1670,6 +1676,7 @@ fn trans_assign_op(bcx: block,\n         let scratch = scratch_datum(bcx, dst_datum.ty, false);\n         let bcx = trans_overloaded_op(bcx,\n                                       expr,\n+                                      callee_id,\n                                       dst,\n                                       ~[src],\n                                       dst_datum.ty,"}, {"sha": "237ba1f49bbc590c377df3fc95c4abc50c576f35", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -192,17 +192,6 @@ fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n                          expr_to_str(e, cx.tcx.sess.intr())))\n             }\n           }\n-          expr_field(_, _, _) => {\n-            match cx.method_map.find(&e.id) {\n-              Some(&typeck::method_map_entry {\n-                  origin: typeck::method_static(did),\n-                  _\n-                }) => {\n-                traverse_def_id(cx, did);\n-              }\n-              _ => ()\n-            }\n-          }\n           expr_method_call(*) => {\n             match cx.method_map.find(&e.id) {\n               Some(&typeck::method_map_entry {"}, {"sha": "318612bd15bc6c35fe7ccbd8afb3e95d9e70f539", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -273,8 +273,8 @@ pub fn mark_for_method_call(cx: Context, e_id: node_id, callee_id: node_id) {\n pub fn mark_for_expr(cx: Context, e: @expr) {\n     match e.node {\n       expr_vstore(_, _) | expr_vec(_, _) | expr_struct(*) | expr_tup(_) |\n-      expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n-      expr_binary(add, _, _) | expr_copy(_) | expr_repeat(*) => {\n+      expr_unary(_, box(_), _) | expr_unary(_, uniq(_), _) |\n+      expr_binary(_, add, _, _) | expr_copy(_) | expr_repeat(*) => {\n         node_type_needs(cx, use_repr, e.id);\n       }\n       expr_cast(base, _) => {\n@@ -288,7 +288,7 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n             _ => ()\n         }\n       }\n-      expr_binary(op, lhs, _) => {\n+      expr_binary(_, op, lhs, _) => {\n         match op {\n           eq | lt | le | ne | ge | gt => {\n             node_type_needs(cx, use_tydesc, lhs.id)\n@@ -317,16 +317,24 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n               }\n           }\n       }\n-      expr_assign(val, _) | expr_assign_op(_, val, _) |\n+      expr_assign(val, _) | expr_assign_op(_, _, val, _) |\n       expr_ret(Some(val)) => {\n         node_type_needs(cx, use_repr, val.id);\n       }\n-      expr_index(base, _) | expr_field(base, _, _) => {\n+      expr_index(callee_id, base, _) => {\n         // FIXME (#2537): could be more careful and not count fields after\n         // the chosen field.\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n-        mark_for_method_call(cx, e.id, e.callee_id);\n+        mark_for_method_call(cx, e.id, callee_id);\n+      }\n+      expr_field(base, _, _) => {\n+        // Method calls are now a special syntactic form,\n+        // so `a.b` should always be a field.\n+        assert!(!cx.ccx.maps.method_map.contains_key(&e.id));\n+\n+        let base_ty = ty::node_id_to_type(cx.ccx.tcx, base.id);\n+        type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n       }\n       expr_log(_, val) => {\n         node_type_needs(cx, use_tydesc, val.id);\n@@ -336,14 +344,14 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n               type_needs(cx, use_repr, *a);\n           }\n       }\n-      expr_method_call(rcvr, _, _, _, _) => {\n+      expr_method_call(callee_id, rcvr, _, _, _, _) => {\n         let base_ty = ty::node_id_to_type(cx.ccx.tcx, rcvr.id);\n         type_needs(cx, use_repr, ty::type_autoderef(cx.ccx.tcx, base_ty));\n \n-        for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, e.callee_id)).each |a| {\n+        for ty::ty_fn_args(ty::node_id_to_type(cx.ccx.tcx, callee_id)).each |a| {\n             type_needs(cx, use_repr, *a);\n         }\n-        mark_for_method_call(cx, e.id, e.callee_id);\n+        mark_for_method_call(cx, e.id, callee_id);\n       }\n \n       expr_inline_asm(ref ia) => {\n@@ -358,8 +366,8 @@ pub fn mark_for_expr(cx: Context, e: @expr) {\n       expr_paren(e) => mark_for_expr(cx, e),\n \n       expr_match(*) | expr_block(_) | expr_if(*) | expr_while(*) |\n-      expr_break(_) | expr_again(_) | expr_unary(_, _) | expr_lit(_) |\n-      expr_mac(_) | expr_addr_of(_, _) | expr_ret(_) | expr_loop(_, _) |\n+      expr_break(_) | expr_again(_) | expr_unary(*) | expr_lit(_) |\n+      expr_mac(_) | expr_addr_of(*) | expr_ret(_) | expr_loop(*) |\n       expr_loop_body(_) | expr_do_body(_) => ()\n     }\n }"}, {"sha": "506bbd9473a115dde059520c7cd42fa7773d0263", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -3253,7 +3253,7 @@ pub fn expr_kind(tcx: ctxt,\n             }\n         }\n \n-        ast::expr_unary(ast::deref, _) |\n+        ast::expr_unary(_, ast::deref, _) |\n         ast::expr_field(*) |\n         ast::expr_index(*) => {\n             LvalueExpr"}, {"sha": "439ff1f413beda75bae80dfee883e46d530fa5f4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -1310,6 +1310,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @mut FnCtxt,\n+                  callee_id: ast::node_id,\n                   call_expr: @ast::expr,\n                   f: @ast::expr,\n                   args: &[@ast::expr],\n@@ -1326,7 +1327,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // now. Best thing would I think be to just have a separate\n         // \"callee table\" that contains the FnSig and not a general\n         // purpose ty::t\n-        fcx.write_ty(call_expr.callee_id, fn_ty);\n+        fcx.write_ty(callee_id, fn_ty);\n \n         // Extract the function signature from `in_fty`.\n         let fn_sty = structure_of(fcx, f.span, fn_ty);\n@@ -1363,6 +1364,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // Checks a method call.\n     fn check_method_call(fcx: @mut FnCtxt,\n+                         callee_id: ast::node_id,\n                          expr: @ast::expr,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n@@ -1380,7 +1382,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         match method::lookup(fcx,\n                              expr,\n                              rcvr,\n-                             expr.callee_id,\n+                             callee_id,\n                              method_name,\n                              expr_t,\n                              tps,\n@@ -1404,12 +1406,12 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n                 // Add error type for the result\n                 fcx.write_error(expr.id);\n-                fcx.write_error(expr.callee_id);\n+                fcx.write_error(callee_id);\n             }\n         }\n \n         // Call the generic checker.\n-        let fn_ty = fcx.node_ty(expr.callee_id);\n+        let fn_ty = fcx.node_ty(callee_id);\n         let ret_ty = check_method_argument_types(fcx, expr.span,\n                                                  fn_ty, expr, args, sugar,\n                                                  DontDerefArgs);\n@@ -1444,6 +1446,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn lookup_op_method(fcx: @mut FnCtxt,\n+                        callee_id: ast::node_id,\n                         op_ex: @ast::expr,\n                         self_ex: @ast::expr,\n                         self_t: ty::t,\n@@ -1456,10 +1459,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                        )\n                      -> ty::t {\n         match method::lookup(fcx, op_ex, self_ex,\n-                             op_ex.callee_id, opname, self_t, [],\n+                             callee_id, opname, self_t, [],\n                              deref_args, CheckTraitsOnly, autoderef_receiver) {\n             Some(ref origin) => {\n-                let method_ty = fcx.node_ty(op_ex.callee_id);\n+                let method_ty = fcx.node_ty(callee_id);\n                 let method_map = fcx.inh.method_map;\n                 method_map.insert(op_ex.id, *origin);\n                 check_method_argument_types(fcx, op_ex.span,\n@@ -1481,6 +1484,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n     // could be either a expr_binop or an expr_assign_binop\n     fn check_binop(fcx: @mut FnCtxt,\n+                   callee_id: ast::node_id,\n                    expr: @ast::expr,\n                    op: ast::binop,\n                    lhs: @ast::expr,\n@@ -1536,7 +1540,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         }\n \n-        let result_t = check_user_binop(fcx, expr, lhs, lhs_t, op, rhs,\n+        let result_t = check_user_binop(fcx, callee_id, expr, lhs, lhs_t, op, rhs,\n                                        expected_result);\n         fcx.write_ty(expr.id, result_t);\n         if ty::type_is_error(result_t) {\n@@ -1545,6 +1549,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_user_binop(fcx: @mut FnCtxt,\n+                        callee_id: ast::node_id,\n                         ex: @ast::expr,\n                         lhs_expr: @ast::expr,\n                         lhs_resolved_t: ty::t,\n@@ -1561,7 +1566,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                              ast_util::binop_to_str(op), actual)},\n                             lhs_resolved_t, None)\n                 };\n-                return lookup_op_method(fcx, ex, lhs_expr, lhs_resolved_t,\n+                return lookup_op_method(fcx, callee_id, ex, lhs_expr, lhs_resolved_t,\n                                        fcx.tcx().sess.ident_of(*name),\n                                        ~[rhs], DoDerefArgs, DontAutoderefReceiver, if_op_unbound,\n                                        expected_result);\n@@ -1586,6 +1591,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     }\n \n     fn check_user_unop(fcx: @mut FnCtxt,\n+                       callee_id: ast::node_id,\n                        op_str: &str,\n                        mname: &str,\n                        ex: @ast::expr,\n@@ -1594,7 +1600,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                        expected_t: Option<ty::t>)\n                     -> ty::t {\n        lookup_op_method(\n-            fcx, ex, rhs_expr, rhs_t,\n+            fcx, callee_id, ex, rhs_expr, rhs_t,\n             fcx.tcx().sess.ident_of(mname), ~[],\n             DoDerefArgs, DontAutoderefReceiver,\n             || {\n@@ -2221,8 +2227,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let typ = check_lit(fcx, lit);\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_binary(op, lhs, rhs) => {\n-        check_binop(fcx, expr, op, lhs, rhs, expected);\n+      ast::expr_binary(callee_id, op, lhs, rhs) => {\n+        check_binop(fcx, callee_id, expr, op, lhs, rhs, expected);\n         let lhs_ty = fcx.expr_ty(lhs);\n         let rhs_ty = fcx.expr_ty(rhs);\n         if ty::type_is_error(lhs_ty) ||\n@@ -2234,8 +2240,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::expr_assign_op(op, lhs, rhs) => {\n-        check_binop(fcx, expr, op, lhs, rhs, expected);\n+      ast::expr_assign_op(callee_id, op, lhs, rhs) => {\n+        check_binop(fcx, callee_id, expr, op, lhs, rhs, expected);\n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n         demand::suptype(fcx, expr.span, result_t, lhs_t);\n@@ -2248,7 +2254,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(expr.id);\n         }\n       }\n-      ast::expr_unary(unop, oprnd) => {\n+      ast::expr_unary(callee_id, unop, oprnd) => {\n         let exp_inner = do unpack_expected(fcx, expected) |sty| {\n             match unop {\n               ast::box(_) | ast::uniq(_) => match *sty {\n@@ -2307,7 +2313,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::get(oprnd_t).sty == ty::ty_bool) {\n-                        oprnd_t = check_user_unop(fcx,\n+                        oprnd_t = check_user_unop(fcx, callee_id,\n                             \"!\", \"not\", expr, oprnd, oprnd_t,\n                                                   expected);\n                     }\n@@ -2317,7 +2323,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                          oprnd_t);\n                     if !(ty::type_is_integral(oprnd_t) ||\n                          ty::type_is_fp(oprnd_t)) {\n-                        oprnd_t = check_user_unop(fcx,\n+                        oprnd_t = check_user_unop(fcx, callee_id,\n                             \"-\", \"neg\", expr, oprnd, oprnd_t, expected);\n                     }\n                 }\n@@ -2553,7 +2559,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.node.id));\n       }\n       ast::expr_call(f, ref args, sugar) => {\n-          check_call(fcx, expr, f, *args, sugar);\n+          check_call(fcx, expr.id, expr, f, *args, sugar);\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.foldl((false, false),\n              |&(rest_bot, rest_err), a| {\n@@ -2568,8 +2574,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n               fcx.write_bot(id);\n           }\n       }\n-      ast::expr_method_call(rcvr, ident, ref tps, ref args, sugar) => {\n-        check_method_call(fcx, expr, rcvr, ident, *args, *tps, sugar);\n+      ast::expr_method_call(callee_id, rcvr, ident, ref tps, ref args, sugar) => {\n+        check_method_call(fcx, callee_id, expr, rcvr, ident, *args, *tps, sugar);\n         let f_ty = fcx.expr_ty(rcvr);\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n         let (args_bot, args_err) = arg_tys.foldl((false, false),\n@@ -2751,7 +2757,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_field(base, field, ref tys) => {\n         check_field(fcx, expr, base, field, *tys);\n       }\n-      ast::expr_index(base, idx) => {\n+      ast::expr_index(callee_id, base, idx) => {\n           check_expr(fcx, base);\n           check_expr(fcx, idx);\n           let raw_base_t = fcx.expr_ty(base);\n@@ -2785,6 +2791,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                None);\n                       };\n                       let ret_ty = lookup_op_method(fcx,\n+                                                    callee_id,\n                                                     expr,\n                                                     base,\n                                                     resolved,"}, {"sha": "58749b92ddcd485b4da52602266cde3ba64a93ef", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -256,8 +256,8 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n         ast::expr_unary(*) if has_method_map => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n         }\n-        ast::expr_binary(ast::and, lhs, rhs) |\n-        ast::expr_binary(ast::or, lhs, rhs) => {\n+        ast::expr_binary(_, ast::and, lhs, rhs) |\n+        ast::expr_binary(_, ast::or, lhs, rhs) => {\n             tcx.region_maps.record_cleanup_scope(lhs.id);\n             tcx.region_maps.record_cleanup_scope(rhs.id);\n         }\n@@ -306,36 +306,36 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n \n     match expr.node {\n         ast::expr_call(callee, ref args, _) => {\n-            constrain_callee(rcx, expr, callee);\n-            constrain_call(rcx, expr, None, *args, false);\n+            constrain_callee(rcx, callee.id, expr, callee);\n+            constrain_call(rcx, callee.id, expr, None, *args, false);\n         }\n \n-        ast::expr_method_call(arg0, _, _, ref args, _) => {\n-            constrain_call(rcx, expr, Some(arg0), *args, false);\n+        ast::expr_method_call(callee_id, arg0, _, _, ref args, _) => {\n+            constrain_call(rcx, callee_id, expr, Some(arg0), *args, false);\n         }\n \n-        ast::expr_index(lhs, rhs) |\n-        ast::expr_assign_op(_, lhs, rhs) |\n-        ast::expr_binary(_, lhs, rhs) if has_method_map => {\n+        ast::expr_index(callee_id, lhs, rhs) |\n+        ast::expr_assign_op(callee_id, _, lhs, rhs) |\n+        ast::expr_binary(callee_id, _, lhs, rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, expr, Some(lhs), [rhs], true);\n+            constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n         }\n \n-        ast::expr_unary(_, lhs) if has_method_map => {\n+        ast::expr_unary(callee_id, _, lhs) if has_method_map => {\n             // As above.\n-            constrain_call(rcx, expr, Some(lhs), [], true);\n+            constrain_call(rcx, callee_id, expr, Some(lhs), [], true);\n         }\n \n-        ast::expr_unary(ast::deref, base) => {\n+        ast::expr_unary(_, ast::deref, base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let base_ty = rcx.resolve_node_type(base.id);\n             constrain_derefs(rcx, expr, 1, base_ty);\n         }\n \n-        ast::expr_index(vec_expr, _) => {\n+        ast::expr_index(_, vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n             let vec_type = rcx.resolve_expr_type_adjusted(vec_expr);\n             constrain_index(rcx, expr, vec_type);\n@@ -404,14 +404,15 @@ fn visit_expr(expr: @ast::expr, rcx: @mut Rcx, v: rvt) {\n }\n \n fn constrain_callee(rcx: @mut Rcx,\n+                    callee_id: ast::node_id,\n                     call_expr: @ast::expr,\n                     callee_expr: @ast::expr)\n {\n     let tcx = rcx.fcx.tcx();\n \n     let call_region = ty::re_scope(call_expr.id);\n \n-    let callee_ty = rcx.resolve_node_type(call_expr.callee_id);\n+    let callee_ty = rcx.resolve_node_type(callee_id);\n     match ty::get(callee_ty).sty {\n         ty::ty_bare_fn(*) => { }\n         ty::ty_closure(ref closure_ty) => {\n@@ -444,6 +445,7 @@ fn constrain_callee(rcx: @mut Rcx,\n fn constrain_call(rcx: @mut Rcx,\n                   // might be expr_call, expr_method_call, or an overloaded\n                   // operator\n+                  callee_id: ast::node_id,\n                   call_expr: @ast::expr,\n                   receiver: Option<@ast::expr>,\n                   arg_exprs: &[@ast::expr],\n@@ -457,7 +459,7 @@ fn constrain_call(rcx: @mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     debug!(\"constrain_call(call_expr=%s, implicitly_ref_args=%?)\",\n            call_expr.repr(tcx), implicitly_ref_args);\n-    let callee_ty = rcx.resolve_node_type(call_expr.callee_id);\n+    let callee_ty = rcx.resolve_node_type(callee_id);\n     let fn_sig = ty::ty_fn_sig(callee_ty);\n \n     // `callee_region` is the scope representing the time in which the\n@@ -964,14 +966,14 @@ pub mod guarantor {\n \n         debug!(\"guarantor(expr=%s)\", rcx.fcx.expr_to_str(expr));\n         match expr.node {\n-            ast::expr_unary(ast::deref, b) => {\n+            ast::expr_unary(_, ast::deref, b) => {\n                 let cat = categorize(rcx, b);\n                 guarantor_of_deref(&cat)\n             }\n             ast::expr_field(b, _, _) => {\n                 categorize(rcx, b).guarantor\n             }\n-            ast::expr_index(b, _) => {\n+            ast::expr_index(_, b, _) => {\n                 let cat = categorize(rcx, b);\n                 guarantor_of_deref(&cat)\n             }"}, {"sha": "1ef905de0c2b6dd08ea06979c59ba45dbe24471e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -512,19 +512,16 @@ pub fn early_resolve_expr(ex: @ast::expr,\n       }\n \n       // Must resolve bounds on methods with bounded params\n-      ast::expr_binary(*) |\n-      ast::expr_unary(*) | ast::expr_assign_op(*) |\n-      ast::expr_index(*) | ast::expr_method_call(*) => {\n+      ast::expr_binary(callee_id, _, _, _) |\n+      ast::expr_unary(callee_id, _, _) |\n+      ast::expr_assign_op(callee_id, _, _, _) |\n+      ast::expr_index(callee_id, _, _) |\n+      ast::expr_method_call(callee_id, _, _, _, _, _) => {\n         match ty::method_call_type_param_defs(cx.tcx, fcx.inh.method_map, ex.id) {\n           Some(type_param_defs) => {\n             debug!(\"vtable resolution on parameter bounds for method call %s\",\n                    ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n-                let callee_id = match ex.node {\n-                  ast::expr_field(_, _, _) => ex.id,\n-                  _ => ex.callee_id\n-                };\n-\n                 let substs = fcx.node_ty_substs(callee_id);\n                 let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),"}, {"sha": "9c8c83d35c4ee228ae16ae7e4aa3b74e65555794", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -217,10 +217,16 @@ fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n     }\n \n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n+\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n-    resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n+    for e.get_callee_id().each |callee_id| {\n+        resolve_method_map_entry(wbcx.fcx, e.span, *callee_id);\n+    }\n+\n     resolve_vtable_map_entry(wbcx.fcx, e.span, e.id);\n-    resolve_vtable_map_entry(wbcx.fcx, e.span, e.callee_id);\n+    for e.get_callee_id().each |callee_id| {\n+        resolve_vtable_map_entry(wbcx.fcx, e.span, *callee_id);\n+    }\n \n     match e.node {\n         ast::expr_fn_block(ref decl, _) => {\n@@ -229,14 +235,16 @@ fn visit_expr(e: @ast::expr, wbcx: @mut WbCtxt, v: wb_vt) {\n             }\n         }\n \n-        ast::expr_binary(*) | ast::expr_unary(*) | ast::expr_assign_op(*) |\n-        ast::expr_index(*) => {\n-            maybe_resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+        ast::expr_binary(callee_id, _, _, _) |\n+        ast::expr_unary(callee_id, _, _) |\n+        ast::expr_assign_op(callee_id, _, _, _) |\n+        ast::expr_index(callee_id, _, _) => {\n+            maybe_resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n \n-        ast::expr_method_call(*) => {\n+        ast::expr_method_call(callee_id, _, _, _, _, _) => {\n             // We must always have written in a callee ID type for these.\n-            resolve_type_vars_for_node(wbcx, e.span, e.callee_id);\n+            resolve_type_vars_for_node(wbcx, e.span, callee_id);\n         }\n \n         _ => ()"}, {"sha": "4ffa4d0d25e09f790db4d99b0b71e859d2e57990", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -182,7 +182,6 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n           ast::expr_assign_op(*) |\n-          ast::expr_field(*) |\n           ast::expr_unary(*) |\n           ast::expr_binary(*) |\n           ast::expr_index(*) => {"}, {"sha": "dcb4162995888b17afec1bb33ad8e8cd5002a58f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -436,13 +436,23 @@ pub enum blk_check_mode { default_blk, unsafe_blk, }\n #[deriving(Eq, Encodable, Decodable)]\n pub struct expr {\n     id: node_id,\n-    // Extra node ID is only used for index, assign_op, unary, binary, method\n-    // call\n-    callee_id: node_id,\n     node: expr_,\n     span: span,\n }\n \n+pub impl expr {\n+    fn get_callee_id(&self) -> Option<node_id> {\n+        match self.node {\n+            expr_method_call(callee_id, _, _, _, _, _) |\n+            expr_index(callee_id, _, _) |\n+            expr_binary(callee_id, _, _, _) |\n+            expr_assign_op(callee_id, _, _, _) |\n+            expr_unary(callee_id, _, _) => Some(callee_id),\n+            _ => None,\n+        }\n+    }\n+}\n+\n #[deriving(Eq, Encodable, Decodable)]\n pub enum CallSugar {\n     NoSugar,\n@@ -455,10 +465,10 @@ pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(@expr, ident, ~[@Ty], ~[@expr], CallSugar),\n+    expr_method_call(node_id, @expr, ident, ~[@Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n-    expr_binary(binop, @expr, @expr),\n-    expr_unary(unop, @expr),\n+    expr_binary(node_id, binop, @expr, @expr),\n+    expr_unary(node_id, unop, @expr),\n     expr_lit(@lit),\n     expr_cast(@expr, @Ty),\n     expr_if(@expr, blk, Option<@expr>),\n@@ -479,9 +489,9 @@ pub enum expr_ {\n \n     expr_copy(@expr),\n     expr_assign(@expr, @expr),\n-    expr_assign_op(binop, @expr, @expr),\n+    expr_assign_op(node_id, binop, @expr, @expr),\n     expr_field(@expr, ident, ~[@Ty]),\n-    expr_index(@expr, @expr),\n+    expr_index(node_id, @expr, @expr),\n     expr_path(@Path),\n \n     /// The special identifier `self`."}, {"sha": "58769ede961fb7dddb815eeafad461b80066562a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -317,17 +317,9 @@ pub fn map_struct_def(\n \n pub fn map_expr(ex: @expr, cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n     cx.map.insert(ex.id, node_expr(ex));\n-    match ex.node {\n-        // Expressions which are or might be calls:\n-        ast::expr_call(*) |\n-        ast::expr_method_call(*) |\n-        ast::expr_index(*) |\n-        ast::expr_binary(*) |\n-        ast::expr_assign_op(*) |\n-        ast::expr_unary(*) => {\n-            cx.map.insert(ex.callee_id, node_callee_scope(ex));\n-        }\n-        _ => {}\n+    // Expressions which are or might be calls:\n+    for ex.get_callee_id().each |callee_id| {\n+        cx.map.insert(*callee_id, node_callee_scope(ex));\n     }\n     visit::visit_expr(ex, cx, v);\n }"}, {"sha": "eab8c0a12d33c2ceeedfc5a589cc0954d8f88ff5", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -193,7 +193,7 @@ pub fn float_ty_to_str(t: float_ty) -> ~str {\n }\n \n pub fn is_call_expr(e: @expr) -> bool {\n-    match e.node { expr_call(_, _, _) => true, _ => false }\n+    match e.node { expr_call(*) => true, _ => false }\n }\n \n // This makes def_id hashable\n@@ -460,7 +460,9 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n         },\n \n         visit_expr: |e, t, vt| {\n-            vfn(e.callee_id, t);\n+            for e.get_callee_id().each |callee_id| {\n+                vfn(*callee_id, t);\n+            }\n             vfn(e.id, t);\n             visit::visit_expr(e, t, vt);\n         },"}, {"sha": "7f8f2be6f6e1ef62b4a51b5bdfc89ee4702af5d6", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -82,7 +82,6 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n                     let out = @ast::expr {\n                         id: cx.next_id(),\n-                        callee_id: cx.next_id(),\n                         span: out.span,\n                         node: ast::expr_addr_of(ast::m_mutbl, out)\n                     };\n@@ -179,7 +178,6 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n     MRExpr(@ast::expr {\n         id: cx.next_id(),\n-        callee_id: cx.next_id(),\n         node: ast::expr_inline_asm(ast::inline_asm {\n             asm: @asm,\n             clobbers: @cons,"}, {"sha": "c2fa888995ab434d804958462a8fd6ef2189dd36", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -414,7 +414,6 @@ impl AstBuilder for @ExtCtxt {\n     fn expr(&self, span: span, node: ast::expr_) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n-            callee_id: self.next_id(),\n             node: node,\n             span: span,\n         }\n@@ -433,17 +432,15 @@ impl AstBuilder for @ExtCtxt {\n \n     fn expr_binary(&self, sp: span, op: ast::binop,\n                    lhs: @ast::expr, rhs: @ast::expr) -> @ast::expr {\n-        self.next_id(); // see ast_util::op_expr_callee_id\n-        self.expr(sp, ast::expr_binary(op, lhs, rhs))\n+        self.expr(sp, ast::expr_binary(self.next_id(), op, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: span, e: @ast::expr) -> @ast::expr {\n         self.expr_unary(sp, ast::deref, e)\n     }\n     fn expr_unary(&self, sp: span, op: ast::unop, e: @ast::expr)\n         -> @ast::expr {\n-        self.next_id(); // see ast_util::op_expr_callee_id\n-        self.expr(sp, ast::expr_unary(op, e))\n+        self.expr(sp, ast::expr_unary(self.next_id(), op, e))\n     }\n \n     fn expr_copy(&self, sp: span, e: @ast::expr) -> @ast::expr {\n@@ -480,7 +477,7 @@ impl AstBuilder for @ExtCtxt {\n                         ident: ast::ident,\n                         args: ~[@ast::expr]) -> @ast::expr {\n         self.expr(span,\n-                  ast::expr_method_call(expr, ident, ~[], args, ast::NoSugar))\n+                  ast::expr_method_call(self.next_id(), expr, ident, ~[], args, ast::NoSugar))\n     }\n     fn expr_blk(&self, b: ast::blk) -> @ast::expr {\n         self.expr(b.span, ast::expr_block(b))"}, {"sha": "358f4041dd0e2f0c9eff475e85f0695e75c76d9b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -37,7 +37,6 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n     let e = @ast::expr {\n         id: cx.next_id(),\n-        callee_id: cx.next_id(),\n         node: ast::expr_path(\n             @ast::Path {\n                  span: sp,"}, {"sha": "598537c97e871e83a1adaeab70020c4364fc99c2", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -33,7 +33,6 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     //trivial expression\n     MRExpr(@ast::expr {\n         id: cx.next_id(),\n-        callee_id: cx.next_id(),\n         node: ast::expr_lit(@codemap::spanned {\n             node: ast::lit_nil,\n             span: sp"}, {"sha": "5800254eaa4252b96dda8fb7f71a54e940f730ba", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -463,19 +463,31 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 blk\n             )\n         }\n-        expr_method_call(f, i, ref tps, ref args, blk) => {\n+        expr_method_call(callee_id, f, i, ref tps, ref args, blk) => {\n             expr_method_call(\n+                fld.new_id(callee_id),\n                 fld.fold_expr(f),\n                 fld.fold_ident(i),\n                 tps.map(|x| fld.fold_ty(*x)),\n                 fld.map_exprs(|x| fld.fold_expr(x), *args),\n                 blk\n             )\n         }\n-        expr_binary(binop, lhs, rhs) => {\n-            expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n+        expr_binary(callee_id, binop, lhs, rhs) => {\n+            expr_binary(\n+                fld.new_id(callee_id),\n+                binop,\n+                fld.fold_expr(lhs),\n+                fld.fold_expr(rhs)\n+            )\n+        }\n+        expr_unary(callee_id, binop, ohs) => {\n+            expr_unary(\n+                fld.new_id(callee_id),\n+                binop,\n+                fld.fold_expr(ohs)\n+            )\n         }\n-        expr_unary(binop, ohs) => expr_unary(binop, fld.fold_expr(ohs)),\n         expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n         expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n         expr_lit(_) => copy *e,\n@@ -514,17 +526,26 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_assign(el, er) => {\n             expr_assign(fld.fold_expr(el), fld.fold_expr(er))\n         }\n-        expr_assign_op(op, el, er) => {\n-            expr_assign_op(op, fld.fold_expr(el), fld.fold_expr(er))\n+        expr_assign_op(callee_id, op, el, er) => {\n+            expr_assign_op(\n+                fld.new_id(callee_id),\n+                op,\n+                fld.fold_expr(el),\n+                fld.fold_expr(er)\n+            )\n         }\n         expr_field(el, id, ref tys) => {\n             expr_field(\n                 fld.fold_expr(el), fld.fold_ident(id),\n                 tys.map(|x| fld.fold_ty(*x))\n             )\n         }\n-        expr_index(el, er) => {\n-            expr_index(fld.fold_expr(el), fld.fold_expr(er))\n+        expr_index(callee_id, el, er) => {\n+            expr_index(\n+                fld.new_id(callee_id),\n+                fld.fold_expr(el),\n+                fld.fold_expr(er)\n+            )\n         }\n         expr_path(pth) => expr_path(fld.fold_path(pth)),\n         expr_self => expr_self,\n@@ -801,7 +822,6 @@ impl ast_fold for AstFoldFns {\n         let (n, s) = (self.fold_expr)(&x.node, x.span, self as @ast_fold);\n         @expr {\n             id: (self.new_id)(x.id),\n-            callee_id: (self.new_id)(x.callee_id),\n             node: n,\n             span: (self.new_span)(s),\n         }"}, {"sha": "62b36b12f2669bf437e8f0b67f0c5c5034887dab", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -31,8 +31,8 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n       | ast::expr_loop(*)\n       | ast::expr_call(_, _, ast::DoSugar)\n       | ast::expr_call(_, _, ast::ForSugar)\n-      | ast::expr_method_call(_, _, _, _, ast::DoSugar)\n-      | ast::expr_method_call(_, _, _, _, ast::ForSugar) => false,\n+      | ast::expr_method_call(_, _, _, _, _, ast::DoSugar)\n+      | ast::expr_method_call(_, _, _, _, _, ast::ForSugar) => false,\n       _ => true\n     }\n }"}, {"sha": "9c716f5631f7a3d780247091a8b45ee119e3d98c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -385,7 +385,6 @@ mod test {\n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@~\"a\"),\n                    @ast::expr{id:1,\n-                              callee_id:2,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n                                                               idents:~[intern(\"a\")],\n@@ -397,7 +396,6 @@ mod test {\n     #[test] fn path_exprs_2 () {\n         assert_eq!(string_to_expr(@~\"::a::b\"),\n                    @ast::expr{id:1,\n-                               callee_id:2,\n                                node:ast::expr_path(\n                                    @ast::Path {span:sp(0,6),\n                                                global:true,\n@@ -445,10 +443,9 @@ mod test {\n \n     #[test] fn ret_expr() {\n         assert_eq!(string_to_expr(@~\"return d\"),\n-                   @ast::expr{id:3,\n-                              callee_id:4,\n+                   @ast::expr{id:2,\n                               node:ast::expr_ret(\n-                                  Some(@ast::expr{id:1,callee_id:2,\n+                                  Some(@ast::expr{id:1,\n                                                   node:ast::expr_path(\n                                                       @ast::Path{span:sp(7,8),\n                                                                  global:false,\n@@ -465,7 +462,6 @@ mod test {\n                    @spanned{\n                        node: ast::stmt_expr(@ast::expr{\n                            id: 1,\n-                           callee_id: 2,\n                            node: ast::expr_path(\n                                @ast::Path{\n                                    span:sp(0,1),\n@@ -474,7 +470,7 @@ mod test {\n                                    rp:None,\n                                    types: ~[]}),\n                            span: sp(0,1)},\n-                                            3), // fixme\n+                                            2), // fixme\n                        span: sp(0,1)})\n \n     }\n@@ -538,7 +534,7 @@ mod test {\n                   Some(\n                       @ast::item{ident:intern(\"a\"),\n                             attrs:~[],\n-                            id: 10, // fixme\n+                            id: 9, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n                                     is_mutbl: false,\n@@ -583,7 +579,6 @@ mod test {\n                                             stmts: ~[@spanned{\n                                                 node: ast::stmt_semi(@ast::expr{\n                                                     id: 6,\n-                                                    callee_id: 7,\n                                                     node: ast::expr_path(\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n@@ -592,10 +587,10 @@ mod test {\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},\n-                                                                     8), // fixme\n+                                                                     7), // fixme\n                                                 span: sp(17,18)}],\n                                             expr: None,\n-                                            id: 9, // fixme\n+                                            id: 8, // fixme\n                                             rules: ast::default_blk // no idea\n                                         }}),\n                             vis: ast::inherited,"}, {"sha": "f013dfaceba53c6d4faf79a8374bfa0df971cc3e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -926,7 +926,7 @@ impl Parser {\n \n         if minus_present {\n             let minus_hi = self.span.hi;\n-            self.mk_expr(minus_lo, minus_hi, expr_unary(neg, expr))\n+            self.mk_expr(minus_lo, minus_hi, self.mk_unary(neg, expr))\n         } else {\n             expr\n         }\n@@ -1168,16 +1168,47 @@ impl Parser {\n     pub fn mk_expr(&self, lo: BytePos, hi: BytePos, node: expr_) -> @expr {\n         @expr {\n             id: self.get_id(),\n-            callee_id: self.get_id(),\n             node: node,\n             span: mk_sp(lo, hi),\n         }\n     }\n \n+    pub fn mk_unary(&self, unop: ast::unop, expr: @expr) -> ast::expr_ {\n+        expr_unary(self.get_id(), unop, expr)\n+    }\n+\n+    pub fn mk_binary(&self, binop: ast::binop, lhs: @expr, rhs: @expr) -> ast::expr_ {\n+        expr_binary(self.get_id(), binop, lhs, rhs)\n+    }\n+\n+    pub fn mk_call(&self, f: @expr, args: ~[@expr], sugar: CallSugar) -> ast::expr_ {\n+        expr_call(f, args, sugar)\n+    }\n+\n+    pub fn mk_method_call(&self,\n+                      rcvr: @expr,\n+                      ident: ident,\n+                      tps: ~[@Ty],\n+                      args: ~[@expr],\n+                      sugar: CallSugar) -> ast::expr_ {\n+        expr_method_call(self.get_id(), rcvr, ident, tps, args, sugar)\n+    }\n+\n+    pub fn mk_index(&self, expr: @expr, idx: @expr) -> ast::expr_ {\n+        expr_index(self.get_id(), expr, idx)\n+    }\n+\n+    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[@Ty]) -> ast::expr_ {\n+        expr_field(expr, ident, tys)\n+    }\n+\n+    pub fn mk_assign_op(&self, binop: ast::binop, lhs: @expr, rhs: @expr) -> ast::expr_ {\n+        expr_assign_op(self.get_id(), binop, lhs, rhs)\n+    }\n+\n     pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @expr {\n         @expr {\n             id: self.get_id(),\n-            callee_id: self.get_id(),\n             node: expr_mac(codemap::spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n@@ -1192,7 +1223,6 @@ impl Parser {\n \n         @expr {\n             id: self.get_id(),\n-            callee_id: self.get_id(),\n             node: expr_lit(lv_lit),\n             span: *span,\n         }\n@@ -1454,11 +1484,11 @@ impl Parser {\n                             );\n                             hi = self.span.hi;\n \n-                            let nd = expr_method_call(e, i, tys, es, NoSugar);\n+                            let nd = self.mk_method_call(e, i, tys, es, NoSugar);\n                             e = self.mk_expr(lo, hi, nd);\n                         }\n                         _ => {\n-                            e = self.mk_expr(lo, hi, expr_field(e, i, tys));\n+                            e = self.mk_expr(lo, hi, self.mk_field(e, i, tys));\n                         }\n                     }\n                   }\n@@ -1478,7 +1508,7 @@ impl Parser {\n                 );\n                 hi = self.span.hi;\n \n-                let nd = expr_call(e, es, NoSugar);\n+                let nd = self.mk_call(e, es, NoSugar);\n                 e = self.mk_expr(lo, hi, nd);\n               }\n \n@@ -1488,7 +1518,7 @@ impl Parser {\n                 let ix = self.parse_expr();\n                 hi = ix.span.hi;\n                 self.expect(&token::RBRACKET);\n-                e = self.mk_expr(lo, hi, expr_index(e, ix));\n+                e = self.mk_expr(lo, hi, self.mk_index(e, ix));\n               }\n \n               _ => return e\n@@ -1703,21 +1733,21 @@ impl Parser {\n             self.bump();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            ex = expr_unary(not, e);\n+            ex = self.mk_unary(not, e);\n           }\n           token::BINOP(b) => {\n             match b {\n               token::MINUS => {\n                 self.bump();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                ex = expr_unary(neg, e);\n+                ex = self.mk_unary(neg, e);\n               }\n               token::STAR => {\n                 self.bump();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                ex = expr_unary(deref, e);\n+                ex = self.mk_unary(deref, e);\n               }\n               token::AND => {\n                 self.bump();\n@@ -1758,7 +1788,7 @@ impl Parser {\n               expr_vec(*) |\n               expr_lit(@codemap::spanned { node: lit_str(_), span: _}) |\n               expr_repeat(*) if m == m_imm => expr_vstore(e, expr_vstore_box),\n-              _ => expr_unary(box(m), e)\n+              _ => self.mk_unary(box(m), e)\n             };\n           }\n           token::TILDE => {\n@@ -1776,7 +1806,7 @@ impl Parser {\n               expr_lit(@codemap::spanned { node: lit_str(_), span: _}) |\n               expr_repeat(*)\n               if m == m_imm => expr_vstore(e, expr_vstore_uniq),\n-              _ => expr_unary(uniq(m), e)\n+              _ => self.mk_unary(uniq(m), e)\n             };\n           }\n           _ => return self.parse_dot_or_call_expr()\n@@ -1810,7 +1840,7 @@ impl Parser {\n                         let expr = self.parse_prefix_expr();\n                         let rhs = self.parse_more_binops(expr, cur_prec);\n                         let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n-                                               expr_binary(cur_op, lhs, rhs));\n+                                               self.mk_binary(cur_op, lhs, rhs));\n                         self.parse_more_binops(bin, min_prec)\n                     } else {\n                         lhs\n@@ -1860,7 +1890,7 @@ impl Parser {\n                   token::SHR => aop = shr\n               }\n               self.mk_expr(lo, rhs.span.hi,\n-                           expr_assign_op(aop, lhs, rhs))\n+                           self.mk_assign_op(aop, lhs, rhs))\n           }\n           token::LARROW => {\n               self.obsolete(*self.span, ObsoleteBinaryMove);\n@@ -1992,30 +2022,30 @@ impl Parser {\n                 let args = vec::append(copy *args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, ref tps, ref args, NoSugar) => {\n+            expr_method_call(_, f, i, ref tps, ref args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(copy *args, [last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, copy *tps,\n-                                              args, sugar))\n+                             self.mk_method_call(f, i, copy *tps, args, sugar))\n             }\n             expr_field(f, i, ref tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i,\n-                                              copy *tps, ~[last_arg], sugar))\n+                             self.mk_method_call(f, i, copy *tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n                 expr_paren(*) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n-                self.mk_expr(lo.lo, last_arg.span.hi,\n-                             expr_call(e, ~[last_arg], sugar))\n+                self.mk_expr(\n+                    lo.lo,\n+                    last_arg.span.hi,\n+                    self.mk_call(e, ~[last_arg], sugar))\n             }\n             _ => {\n                 // There may be other types of expressions that can\n@@ -2274,7 +2304,6 @@ impl Parser {\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n-                    callee_id: self.get_id(),\n                     node: expr_vstore(e, expr_vstore_box),\n                     span: mk_sp(lo, hi),\n                 };\n@@ -2297,7 +2326,6 @@ impl Parser {\n               }) => {\n                 let vst = @expr {\n                     id: self.get_id(),\n-                    callee_id: self.get_id(),\n                     node: expr_vstore(e, expr_vstore_uniq),\n                     span: mk_sp(lo, hi),\n                 };\n@@ -2320,7 +2348,6 @@ impl Parser {\n                   }) => {\n                       let vst = @expr {\n                           id: self.get_id(),\n-                          callee_id: self.get_id(),\n                           node: expr_vstore(e, expr_vstore_slice),\n                           span: mk_sp(lo, hi)\n                       };"}, {"sha": "7ab38a6ba5f978dd79254875c3cd7f4d2cacd71b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -1164,7 +1164,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, func);\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::expr_method_call(func, ident, ref tys, ref args, sugar) => {\n+      ast::expr_method_call(_, func, ident, ref tys, ref args, sugar) => {\n         let mut base_args = copy *args;\n         let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n@@ -1177,13 +1177,13 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::expr_binary(op, lhs, rhs) => {\n+      ast::expr_binary(_, op, lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word_space(s, ast_util::binop_to_str(op));\n         print_expr(s, rhs);\n       }\n-      ast::expr_unary(op, expr) => {\n+      ast::expr_unary(_, op, expr) => {\n         word(s.s, ast_util::unop_to_str(op));\n         print_expr(s, expr);\n       }\n@@ -1335,7 +1335,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         word_space(s, \"=\");\n         print_expr(s, rhs);\n       }\n-      ast::expr_assign_op(op, lhs, rhs) => {\n+      ast::expr_assign_op(_, op, lhs, rhs) => {\n         print_expr(s, lhs);\n         space(s.s);\n         word(s.s, ast_util::binop_to_str(op));\n@@ -1352,7 +1352,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n             word(s.s, \">\");\n         }\n       }\n-      ast::expr_index(expr, index) => {\n+      ast::expr_index(_, expr, index) => {\n         print_expr(s, expr);\n         word(s.s, \"[\");\n         print_expr(s, index);"}, {"sha": "0cb22737a53a79e7b230f34f068060526964a67e", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23808efd11be2a9f964373bd8d684d98565e58d0/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=23808efd11be2a9f964373bd8d684d98565e58d0", "patch": "@@ -471,16 +471,16 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n             visit_exprs(*args, e, v);\n             (v.visit_expr)(callee, e, v);\n         }\n-        expr_method_call(callee, _, ref tys, ref args, _) => {\n+        expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, e, v);\n             for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n             (v.visit_expr)(callee, e, v);\n         }\n-        expr_binary(_, a, b) => {\n+        expr_binary(_, _, a, b) => {\n             (v.visit_expr)(a, e, v);\n             (v.visit_expr)(b, e, v);\n         }\n-        expr_addr_of(_, x) | expr_unary(_, x) |\n+        expr_addr_of(_, x) | expr_unary(_, _, x) |\n         expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, e, v),\n         expr_lit(_) => (),\n         expr_cast(x, t) => {\n@@ -518,15 +518,15 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n             (v.visit_expr)(a, e, v);\n         }\n         expr_copy(a) => (v.visit_expr)(a, e, v),\n-        expr_assign_op(_, a, b) => {\n+        expr_assign_op(_, _, a, b) => {\n             (v.visit_expr)(b, e, v);\n             (v.visit_expr)(a, e, v);\n         }\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, e, v);\n             for tys.each |tp| { (v.visit_ty)(*tp, e, v); }\n         }\n-        expr_index(a, b) => {\n+        expr_index(_, a, b) => {\n             (v.visit_expr)(a, e, v);\n             (v.visit_expr)(b, e, v);\n         }"}]}