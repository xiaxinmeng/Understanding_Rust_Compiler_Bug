{"sha": "a04054ac3969334d4f907ab751fdd339a1506a2c", "node_id": "C_kwDOAAsO6NoAKGEwNDA1NGFjMzk2OTMzNGQ0ZjkwN2FiNzUxZmRkMzM5YTE1MDZhMmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T13:17:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-15T13:17:27Z"}, "message": "Auto merge of #14156 - Veykril:completion-pod, r=Veykril\n\ninternal: Don't reconstruct ref match completion in to_proto manually\n\ncc https://github.com/rust-lang/rust-analyzer/issues/12571", "tree": {"sha": "4fcaf989d7e5343c1165daaa4d7d390ba29bf0b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4fcaf989d7e5343c1165daaa4d7d390ba29bf0b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a04054ac3969334d4f907ab751fdd339a1506a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a04054ac3969334d4f907ab751fdd339a1506a2c", "html_url": "https://github.com/rust-lang/rust/commit/a04054ac3969334d4f907ab751fdd339a1506a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a04054ac3969334d4f907ab751fdd339a1506a2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "160305b2157c6bafd1633824da182807d4be69aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/160305b2157c6bafd1633824da182807d4be69aa", "html_url": "https://github.com/rust-lang/rust/commit/160305b2157c6bafd1633824da182807d4be69aa"}, {"sha": "23fc596e405c79c4b456642a35fab51b14b5753f", "url": "https://api.github.com/repos/rust-lang/rust/commits/23fc596e405c79c4b456642a35fab51b14b5753f", "html_url": "https://github.com/rust-lang/rust/commit/23fc596e405c79c4b456642a35fab51b14b5753f"}], "stats": {"total": 239, "additions": 112, "deletions": 127}, "files": [{"sha": "9bc1c54a3c6412eb4531a9aa48decadbf2448bf4", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -2,9 +2,10 @@\n \n use std::sync::Arc;\n \n-use crate::tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n use base_db::CrateId;\n+use cfg::CfgOptions;\n use either::Either;\n+\n use hir_expand::{\n     name::{AsName, Name},\n     HirFileId, InFile,\n@@ -24,12 +25,12 @@ use crate::{\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n+    tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree},\n     type_ref::TypeRef,\n     visibility::RawVisibility,\n     EnumId, LocalEnumVariantId, LocalFieldId, LocalModuleId, Lookup, ModuleId, StructId, UnionId,\n     VariantId,\n };\n-use cfg::CfgOptions;\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]"}, {"sha": "ea54068b0f8bf811089e155c078f38a0223b14e8", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -571,28 +571,25 @@ impl<'a> CompletionContext<'a> {\n \n         // try to skip completions on path with invalid colons\n         // this approach works in normal path and inside token tree\n-        match original_token.kind() {\n-            T![:] => {\n-                // return if no prev token before colon\n-                let prev_token = original_token.prev_token()?;\n-\n-                // only has a single colon\n-                if prev_token.kind() != T![:] {\n-                    return None;\n-                }\n+        if original_token.kind() == T![:] {\n+            // return if no prev token before colon\n+            let prev_token = original_token.prev_token()?;\n \n-                // has 3 colon or 2 coloncolon in a row\n-                // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n-                // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n-                if prev_token\n-                    .prev_token()\n-                    .map(|t| t.kind() == T![:] || t.kind() == T![::])\n-                    .unwrap_or(false)\n-                {\n-                    return None;\n-                }\n+            // only has a single colon\n+            if prev_token.kind() != T![:] {\n+                return None;\n+            }\n+\n+            // has 3 colon or 2 coloncolon in a row\n+            // special casing this as per discussion in https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1031845205\n+            // and https://github.com/rust-lang/rust-analyzer/pull/13611#discussion_r1032812751\n+            if prev_token\n+                .prev_token()\n+                .map(|t| t.kind() == T![:] || t.kind() == T![::])\n+                .unwrap_or(false)\n+            {\n+                return None;\n             }\n-            _ => {}\n         }\n \n         let AnalysisResult {"}, {"sha": "db0045aef6e0b23b77b31e3eef799a8e0f83b9ac", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 58, "deletions": 65, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -29,6 +29,7 @@ pub(super) struct AnalysisResult {\n     pub(super) analysis: CompletionAnalysis,\n     pub(super) expected: (Option<Type>, Option<ast::NameOrNameRef>),\n     pub(super) qualifier_ctx: QualifierCtx,\n+    /// the original token of the expanded file\n     pub(super) token: SyntaxToken,\n     pub(super) offset: TextSize,\n }\n@@ -213,15 +214,6 @@ fn analyze(\n     let _p = profile::span(\"CompletionContext::analyze\");\n     let ExpansionResult { original_file, speculative_file, offset, fake_ident_token, derive_ctx } =\n         expansion_result;\n-    let syntax_element = NodeOrToken::Token(fake_ident_token);\n-    if is_in_token_of_for_loop(syntax_element.clone()) {\n-        // for pat $0\n-        // there is nothing to complete here except `in` keyword\n-        // don't bother populating the context\n-        // FIXME: the completion calculations should end up good enough\n-        // such that this special case becomes unnecessary\n-        return None;\n-    }\n \n     // Overwrite the path kind for derives\n     if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n@@ -249,37 +241,35 @@ fn analyze(\n         return None;\n     }\n \n-    let name_like = match find_node_at_offset(&speculative_file, offset) {\n-        Some(it) => it,\n-        None => {\n-            let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n-                CompletionAnalysis::String {\n-                    original,\n-                    expanded: ast::String::cast(self_token.clone()),\n+    let Some(name_like) = find_node_at_offset(&speculative_file, offset) else {\n+        let analysis = if let Some(original) = ast::String::cast(original_token.clone()) {\n+            CompletionAnalysis::String {\n+                original,\n+                expanded: ast::String::cast(self_token.clone()),\n+            }\n+        } else {\n+            // Fix up trailing whitespace problem\n+            // #[attr(foo = $0\n+            let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n+            let p = token.parent()?;\n+            if p.kind() == SyntaxKind::TOKEN_TREE\n+                && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n+            {\n+                let colon_prefix = previous_non_trivia_token(self_token.clone())\n+                    .map_or(false, |it| T![:] == it.kind());\n+                CompletionAnalysis::UnexpandedAttrTT {\n+                    fake_attribute_under_caret: fake_ident_token\n+                        .parent_ancestors()\n+                        .find_map(ast::Attr::cast),\n+                    colon_prefix,\n                 }\n             } else {\n-                // Fix up trailing whitespace problem\n-                // #[attr(foo = $0\n-                let token = syntax::algo::skip_trivia_token(self_token.clone(), Direction::Prev)?;\n-                let p = token.parent()?;\n-                if p.kind() == SyntaxKind::TOKEN_TREE\n-                    && p.ancestors().any(|it| it.kind() == SyntaxKind::META)\n-                {\n-                    let colon_prefix = previous_non_trivia_token(self_token.clone())\n-                        .map_or(false, |it| T![:] == it.kind());\n-                    CompletionAnalysis::UnexpandedAttrTT {\n-                        fake_attribute_under_caret: syntax_element\n-                            .ancestors()\n-                            .find_map(ast::Attr::cast),\n-                        colon_prefix,\n-                    }\n-                } else {\n-                    return None;\n-                }\n-            };\n-            return Some((analysis, (None, None), QualifierCtx::default()));\n-        }\n+                return None;\n+            }\n+        };\n+        return Some((analysis, (None, None), QualifierCtx::default()));\n     };\n+\n     let expected = expected_type_and_name(sema, self_token, &name_like);\n     let mut qual_ctx = QualifierCtx::default();\n     let analysis = match name_like {\n@@ -290,6 +280,22 @@ fn analyze(\n             let parent = name_ref.syntax().parent()?;\n             let (nameref_ctx, qualifier_ctx) =\n                 classify_name_ref(sema, &original_file, name_ref, parent)?;\n+\n+            if let NameRefContext {\n+                kind:\n+                    NameRefKind::Path(PathCompletionCtx { kind: PathKind::Expr { .. }, path, .. }, ..),\n+                ..\n+            } = &nameref_ctx\n+            {\n+                if is_in_token_of_for_loop(path) {\n+                    // for pat $0\n+                    // there is nothing to complete here except `in` keyword\n+                    // don't bother populating the context\n+                    // Ideally this special casing wouldn't be needed, but the parser recovers\n+                    return None;\n+                }\n+            }\n+\n             qual_ctx = qualifier_ctx;\n             CompletionAnalysis::NameRef(nameref_ctx)\n         }\n@@ -323,16 +329,14 @@ fn expected_type_and_name(\n                     ast::FieldExpr(e) => e\n                         .syntax()\n                         .ancestors()\n-                        .map_while(ast::FieldExpr::cast)\n-                        .last()\n-                        .map(|it| it.syntax().clone()),\n+                        .take_while(|it| ast::FieldExpr::can_cast(it.kind()))\n+                        .last(),\n                     ast::PathSegment(e) => e\n                         .syntax()\n                         .ancestors()\n                         .skip(1)\n                         .take_while(|it| ast::Path::can_cast(it.kind()) || ast::PathExpr::can_cast(it.kind()))\n-                        .find_map(ast::PathExpr::cast)\n-                        .map(|it| it.syntax().clone()),\n+                        .find(|it| ast::PathExpr::can_cast(it.kind())),\n                     _ => None\n                 }\n             };\n@@ -1270,40 +1274,29 @@ fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<(ast::Path, bool)> {\n     Some((use_tree.path()?, true))\n }\n \n-pub(crate) fn is_in_token_of_for_loop(element: SyntaxElement) -> bool {\n+fn is_in_token_of_for_loop(path: &ast::Path) -> bool {\n     // oh my ...\n     (|| {\n-        let syntax_token = element.into_token()?;\n-        let range = syntax_token.text_range();\n-        let for_expr = syntax_token.parent_ancestors().find_map(ast::ForExpr::cast)?;\n-\n-        // check if the current token is the `in` token of a for loop\n-        if let Some(token) = for_expr.in_token() {\n-            return Some(syntax_token == token);\n+        let expr = path.syntax().parent().and_then(ast::PathExpr::cast)?;\n+        let for_expr = expr.syntax().parent().and_then(ast::ForExpr::cast)?;\n+        if for_expr.in_token().is_some() {\n+            return Some(false);\n         }\n         let pat = for_expr.pat()?;\n-        if range.end() < pat.syntax().text_range().end() {\n-            // if we are inside or before the pattern we can't be at the `in` token position\n-            return None;\n-        }\n         let next_sibl = next_non_trivia_sibling(pat.syntax().clone().into())?;\n         Some(match next_sibl {\n-            // the loop body is some node, if our token is at the start we are at the `in` position,\n-            // otherwise we could be in a recovered expression, we don't wanna ruin completions there\n-            syntax::NodeOrToken::Node(n) => n.text_range().start() == range.start(),\n-            // the loop body consists of a single token, if we are this we are certainly at the `in` token position\n-            syntax::NodeOrToken::Token(t) => t == syntax_token,\n+            syntax::NodeOrToken::Node(n) => {\n+                n.text_range().start() == path.syntax().text_range().start()\n+            }\n+            syntax::NodeOrToken::Token(t) => {\n+                t.text_range().start() == path.syntax().text_range().start()\n+            }\n         })\n     })()\n     .unwrap_or(false)\n }\n \n-#[test]\n-fn test_for_is_prev2() {\n-    crate::tests::check_pattern_is_applicable(r\"fn __() { for i i$0 }\", is_in_token_of_for_loop);\n-}\n-\n-pub(crate) fn is_in_loop_body(node: &SyntaxNode) -> bool {\n+fn is_in_loop_body(node: &SyntaxNode) -> bool {\n     node.ancestors()\n         .take_while(|it| it.kind() != SyntaxKind::FN && it.kind() != SyntaxKind::CLOSURE_EXPR)\n         .find_map(|it| {"}, {"sha": "e607763560450ae0d417fd8583549acfcdf524b5", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -14,9 +14,9 @@ use crate::{\n     render::{render_path_resolution, RenderContext},\n };\n \n-/// `CompletionItem` describes a single completion variant in the editor pop-up.\n-/// It is basically a POD with various properties. To construct a\n-/// `CompletionItem`, use `new` method and the `Builder` struct.\n+/// `CompletionItem` describes a single completion entity which expands to 1 or more entries in the\n+/// editor pop-up. It is basically a POD with various properties. To construct a\n+/// [`CompletionItem`], use [`Builder::new`] method and the [`Builder`] struct.\n #[derive(Clone)]\n pub struct CompletionItem {\n     /// Label in the completion pop up which identifies completion.\n@@ -396,14 +396,20 @@ impl CompletionItem {\n         self.trigger_call_info\n     }\n \n-    pub fn ref_match(&self) -> Option<(Mutability, TextSize, CompletionRelevance)> {\n+    pub fn ref_match(&self) -> Option<(String, text_edit::Indel, CompletionRelevance)> {\n         // Relevance of the ref match should be the same as the original\n         // match, but with exact type match set because self.ref_match\n         // is only set if there is an exact type match.\n         let mut relevance = self.relevance;\n         relevance.type_match = Some(CompletionRelevanceTypeMatch::Exact);\n \n-        self.ref_match.map(|(mutability, offset)| (mutability, offset, relevance))\n+        self.ref_match.map(|(mutability, offset)| {\n+            (\n+                format!(\"&{}{}\", mutability.as_keyword_for_ref(), self.label()),\n+                text_edit::Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n+                relevance,\n+            )\n+        })\n     }\n \n     pub fn imports_to_add(&self) -> &[LocatedImport] {"}, {"sha": "6fe781114039921d1376418f46a39c561089eed4", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -156,21 +156,23 @@ pub fn completions(\n \n     // prevent `(` from triggering unwanted completion noise\n     if trigger_character == Some('(') {\n-        if let CompletionAnalysis::NameRef(NameRefContext { kind, .. }) = &analysis {\n-            if let NameRefKind::Path(\n-                path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n-            ) = kind\n-            {\n-                completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n-            }\n+        if let CompletionAnalysis::NameRef(NameRefContext {\n+            kind:\n+                NameRefKind::Path(\n+                    path_ctx @ PathCompletionCtx { kind: PathKind::Vis { has_in_token }, .. },\n+                ),\n+            ..\n+        }) = analysis\n+        {\n+            completions::vis::complete_vis_path(&mut completions, ctx, path_ctx, has_in_token);\n         }\n         return Some(completions.into());\n     }\n \n     {\n         let acc = &mut completions;\n \n-        match &analysis {\n+        match analysis {\n             CompletionAnalysis::Name(name_ctx) => completions::complete_name(acc, ctx, name_ctx),\n             CompletionAnalysis::NameRef(name_ref_ctx) => {\n                 completions::complete_name_ref(acc, ctx, name_ref_ctx)"}, {"sha": "47d3e01aa7fcbbf19675f43361c3a14898e12349", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -529,8 +529,7 @@ mod tests {\n                 let relevance = display_relevance(it.relevance());\n                 items.push(format!(\"{tag} {} {relevance}\\n\", it.label()));\n \n-                if let Some((mutability, _offset, relevance)) = it.ref_match() {\n-                    let label = format!(\"&{}{}\", mutability.as_keyword_for_ref(), it.label());\n+                if let Some((label, _indel, relevance)) = it.ref_match() {\n                     let relevance = display_relevance(relevance);\n \n                     items.push(format!(\"{tag} {label} {relevance}\\n\"));"}, {"sha": "578edcbaba35bce58f16b744cfab0e7903f3be50", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -23,15 +23,14 @@ mod type_pos;\n mod use_tree;\n mod visibility;\n \n-use hir::{db::DefDatabase, PrefixKind, Semantics};\n+use hir::{db::DefDatabase, PrefixKind};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n     imports::insert_use::{ImportGranularity, InsertUseConfig},\n     RootDatabase, SnippetCap,\n };\n use itertools::Itertools;\n use stdx::{format_to, trim_indent};\n-use syntax::{AstNode, NodeOrToken, SyntaxElement};\n use test_utils::assert_eq_text;\n \n use crate::{\n@@ -216,15 +215,6 @@ pub(crate) fn check_edit_with_config(\n     assert_eq_text!(&ra_fixture_after, &actual)\n }\n \n-pub(crate) fn check_pattern_is_applicable(code: &str, check: impl FnOnce(SyntaxElement) -> bool) {\n-    let (db, pos) = position(code);\n-\n-    let sema = Semantics::new(&db);\n-    let original_file = sema.parse(pos.file_id);\n-    let token = original_file.syntax().token_at_offset(pos.offset).left_biased().unwrap();\n-    assert!(check(NodeOrToken::Token(token)));\n-}\n-\n pub(crate) fn get_all_items(\n     config: CompletionConfig,\n     code: &str,\n@@ -246,8 +236,9 @@ pub(crate) fn get_all_items(\n }\n \n #[test]\n-fn test_no_completions_required() {\n+fn test_no_completions_in_for_loop_in_kw_pos() {\n     assert_eq!(completion_list(r#\"fn foo() { for i i$0 }\"#), String::new());\n+    assert_eq!(completion_list(r#\"fn foo() { for i in$0 }\"#), String::new());\n }\n \n #[test]"}, {"sha": "bee85cdd13e081805c4e7c3012f5259651b5eac5", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a04054ac3969334d4f907ab751fdd339a1506a2c/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=a04054ac3969334d4f907ab751fdd339a1506a2c", "patch": "@@ -242,15 +242,16 @@ fn completion_item(\n     let text_edit = {\n         let mut text_edit = None;\n         let source_range = item.source_range();\n-        for indel in item.text_edit().iter() {\n+        for indel in item.text_edit() {\n             if indel.delete.contains_range(source_range) {\n+                // Extract this indel as the main edit\n                 text_edit = Some(if indel.delete == source_range {\n                     self::completion_text_edit(line_index, insert_replace_support, indel.clone())\n                 } else {\n                     assert!(source_range.end() == indel.delete.end());\n                     let range1 = TextRange::new(indel.delete.start(), source_range.start());\n                     let range2 = source_range;\n-                    let indel1 = Indel::replace(range1, String::new());\n+                    let indel1 = Indel::delete(range1);\n                     let indel2 = Indel::replace(range2, indel.insert.clone());\n                     additional_text_edits.push(self::text_edit(line_index, indel1));\n                     self::completion_text_edit(line_index, insert_replace_support, indel2)\n@@ -316,18 +317,13 @@ fn completion_item(\n         }\n     }\n \n-    if let Some((mutability, offset, relevance)) = item.ref_match() {\n-        let mut lsp_item_with_ref = lsp_item.clone();\n+    if let Some((label, indel, relevance)) = item.ref_match() {\n+        let mut lsp_item_with_ref = lsp_types::CompletionItem { label, ..lsp_item.clone() };\n+        lsp_item_with_ref\n+            .additional_text_edits\n+            .get_or_insert_with(Default::default)\n+            .push(self::text_edit(line_index, indel));\n         set_score(&mut lsp_item_with_ref, max_relevance, relevance);\n-        lsp_item_with_ref.label =\n-            format!(\"&{}{}\", mutability.as_keyword_for_ref(), lsp_item_with_ref.label);\n-        lsp_item_with_ref.additional_text_edits.get_or_insert_with(Default::default).push(\n-            self::text_edit(\n-                line_index,\n-                Indel::insert(offset, format!(\"&{}\", mutability.as_keyword_for_ref())),\n-            ),\n-        );\n-\n         acc.push(lsp_item_with_ref);\n     };\n "}]}