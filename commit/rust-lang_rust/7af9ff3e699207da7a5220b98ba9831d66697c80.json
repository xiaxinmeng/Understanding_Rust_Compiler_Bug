{"sha": "7af9ff3e699207da7a5220b98ba9831d66697c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdhZjlmZjNlNjk5MjA3ZGE3YTUyMjBiOThiYTk4MzFkNjY2OTdjODA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-19T01:14:51Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-02-02T13:13:07Z"}, "message": "introduce `#![feature(move_ref_pattern)]`", "tree": {"sha": "4b9405bef6a38c6476c7cb3ee29cf7c5812aca1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b9405bef6a38c6476c7cb3ee29cf7c5812aca1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7af9ff3e699207da7a5220b98ba9831d66697c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7af9ff3e699207da7a5220b98ba9831d66697c80", "html_url": "https://github.com/rust-lang/rust/commit/7af9ff3e699207da7a5220b98ba9831d66697c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7af9ff3e699207da7a5220b98ba9831d66697c80/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cef68945722fa593a4a1314f4a2f1ff095aab4f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef68945722fa593a4a1314f4a2f1ff095aab4f4", "html_url": "https://github.com/rust-lang/rust/commit/cef68945722fa593a4a1314f4a2f1ff095aab4f4"}], "stats": {"total": 198, "additions": 125, "deletions": 73}, "files": [{"sha": "82bbae18a9c0b53c5dc5df7e93ba42a8375bb1e6", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=7af9ff3e699207da7a5220b98ba9831d66697c80", "patch": "@@ -186,11 +186,25 @@ impl<'a> DiagnosticBuilder<'a> {\n     /// all, and you just supplied a `Span` to create the diagnostic,\n     /// then the snippet will just include that `Span`, which is\n     /// called the primary span.\n-    pub fn span_label<T: Into<String>>(&mut self, span: Span, label: T) -> &mut Self {\n+    pub fn span_label(&mut self, span: Span, label: impl Into<String>) -> &mut Self {\n         self.0.diagnostic.span_label(span, label);\n         self\n     }\n \n+    /// Labels all the given spans with the provided label.\n+    /// See `span_label` for more information.\n+    pub fn span_labels(\n+        &mut self,\n+        spans: impl IntoIterator<Item = Span>,\n+        label: impl AsRef<str>,\n+    ) -> &mut Self {\n+        let label = label.as_ref();\n+        for span in spans {\n+            self.0.diagnostic.span_label(span, label);\n+        }\n+        self\n+    }\n+\n     forward!(pub fn note_expected_found(\n         &mut self,\n         expected_label: &dyn fmt::Display,"}, {"sha": "e0abf5d4f3c1f5fe7794cb87a871d4e80f7961ee", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=7af9ff3e699207da7a5220b98ba9831d66697c80", "patch": "@@ -538,6 +538,10 @@ declare_features! (\n     /// For example, you can write `x @ Some(y)`.\n     (active, bindings_after_at, \"1.41.0\", Some(65490), None),\n \n+    /// Allows patterns with concurrent by-move and by-ref bindings.\n+    /// For example, you can write `Foo(a, ref b)` where `a` is by-move and `b` is by-ref.\n+    (active, move_ref_pattern, \"1.42.0\", Some(68354), None),\n+\n     /// Allows `impl const Trait for T` syntax.\n     (active, const_trait_impl, \"1.42.0\", Some(67792), None),\n "}, {"sha": "a563864b61b3120adb20ee8e377ced55f20ed1a0", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 105, "deletions": 72, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=7af9ff3e699207da7a5220b98ba9831d66697c80", "patch": "@@ -16,8 +16,7 @@ use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::symbol::sym;\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::{sym, Span};\n use syntax::ast::Mutability;\n \n use std::slice;\n@@ -114,8 +113,10 @@ impl PatCtxt<'_, '_> {\n \n impl<'tcx> MatchVisitor<'_, 'tcx> {\n     fn check_patterns(&mut self, has_guard: bool, pat: &Pat<'_>) {\n-        check_legality_of_move_bindings(self, has_guard, pat);\n-        check_borrow_conflicts_in_at_patterns(self, pat);\n+        if !self.tcx.features().move_ref_pattern {\n+            check_legality_of_move_bindings(self, has_guard, pat);\n+        }\n+        pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         if !self.tcx.features().bindings_after_at {\n             check_legality_of_bindings_in_at_patterns(self, pat);\n         }\n@@ -559,6 +560,11 @@ fn maybe_point_at_variant(ty: Ty<'_>, patterns: &[super::Pat<'_>]) -> Vec<Span>\n     covered\n }\n \n+/// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_>, hir_id: HirId, span: Span) -> bool {\n+    !cx.tables.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env, span)\n+}\n+\n /// Check the legality of legality of by-move bindings.\n fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: bool, pat: &Pat<'_>) {\n     let sess = cx.tcx.sess;\n@@ -589,8 +595,7 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     pat.walk_always(|p| {\n         if let hir::PatKind::Binding(.., sub) = &p.kind {\n             if let Some(ty::BindByValue(_)) = tables.extract_binding_mode(sess, p.hir_id, p.span) {\n-                let pat_ty = tables.node_type(p.hir_id);\n-                if !pat_ty.is_copy_modulo_regions(cx.tcx, cx.param_env, pat.span) {\n+                if is_binding_by_move(cx, p.hir_id, p.span) {\n                     check_move(p, sub.as_deref());\n                 }\n             }\n@@ -599,11 +604,11 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n \n     // Found some bad by-move spans, error!\n     if !by_move_spans.is_empty() {\n-        let mut err = struct_span_err!(\n-            sess,\n-            MultiSpan::from_spans(by_move_spans.clone()),\n-            E0009,\n-            \"cannot bind by-move and by-ref in the same pattern\",\n+        let mut err = feature_err(\n+            &sess.parse_sess,\n+            sym::move_ref_pattern,\n+            by_move_spans.clone(),\n+            \"binding by-move and by-ref in the same pattern is unstable\",\n         );\n         for span in by_ref_spans.iter() {\n             err.span_label(*span, \"by-ref pattern here\");\n@@ -615,81 +620,109 @@ fn check_legality_of_move_bindings(cx: &mut MatchVisitor<'_, '_>, has_guard: boo\n     }\n }\n \n-/// Check that there are no borrow conflicts in `binding @ subpat` patterns.\n+/// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n ///\n /// For example, this would reject:\n /// - `ref x @ Some(ref mut y)`,\n-/// - `ref mut x @ Some(ref y)`\n-/// - `ref mut x @ Some(ref mut y)`.\n+/// - `ref mut x @ Some(ref y)`,\n+/// - `ref mut x @ Some(ref mut y)`,\n+/// - `ref mut? x @ Some(y)`, and\n+/// - `x @ Some(ref mut? y)`.\n ///\n /// This analysis is *not* subsumed by NLL.\n fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_>, pat: &Pat<'_>) {\n-    let tab = cx.tables;\n-    let sess = cx.tcx.sess;\n-    // Get the mutability of `p` if it's by-ref.\n-    let extract_binding_mut = |hir_id, span| match tab.extract_binding_mode(sess, hir_id, span)? {\n-        ty::BindByValue(_) => None,\n-        ty::BindByReference(m) => Some(m),\n+    // Extract `sub` in `binding @ sub`.\n+    let (name, sub) = match &pat.kind {\n+        hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n+        _ => return,\n     };\n-    pat.walk_always(|pat| {\n-        // Extract `sub` in `binding @ sub`.\n-        let (name, sub) = match &pat.kind {\n-            hir::PatKind::Binding(.., name, Some(sub)) => (*name, sub),\n-            _ => return,\n-        };\n+    let binding_span = pat.span.with_hi(name.span.hi());\n \n-        // Extract the mutability.\n-        let mut_outer = match extract_binding_mut(pat.hir_id, pat.span) {\n-            None => return,\n-            Some(m) => m,\n-        };\n+    let tables = cx.tables;\n+    let sess = cx.tcx.sess;\n \n-        // We now have `ref $mut_outer binding @ sub` (semantically).\n-        // Recurse into each binding in `sub` and find mutability conflicts.\n-        let mut conflicts_mut_mut = Vec::new();\n-        let mut conflicts_mut_ref = Vec::new();\n-        sub.each_binding(|_, hir_id, span, _| {\n-            if let Some(mut_inner) = extract_binding_mut(hir_id, span) {\n-                match (mut_outer, mut_inner) {\n-                    (Mutability::Not, Mutability::Not) => {}\n-                    (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push(span),\n-                    _ => conflicts_mut_ref.push(span),\n+    // Get the binding move, extract the mutability if by-ref.\n+    let mut_outer = match tables.extract_binding_mode(sess, pat.hir_id, pat.span) {\n+        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id, pat.span) => {\n+            // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n+            let mut conflicts_ref = Vec::new();\n+            sub.each_binding(|_, hir_id, span, _| {\n+                match tables.extract_binding_mode(sess, hir_id, span) {\n+                    Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id, span) => {\n+                        sess.delay_span_bug(span, \"by-move in subpat unchecked by borrowck\");\n+                    }\n+                    Some(ty::BindByValue(_)) | None => {}\n+                    Some(ty::BindByReference(_)) => conflicts_ref.push(span),\n                 }\n+            });\n+            if !conflicts_ref.is_empty() {\n+                let occurs_because = format!(\n+                    \"move occurs because `{}` has type `{}` which does implement the `Copy` trait\",\n+                    name,\n+                    tables.node_type(pat.hir_id),\n+                );\n+                sess.struct_span_err(pat.span, &format!(\"borrow of moved value: `{}`\", name))\n+                    .span_label(binding_span, \"value moved here\")\n+                    .span_label(binding_span, occurs_because)\n+                    .span_labels(conflicts_ref, \"value borrowed here after move\")\n+                    .emit();\n             }\n-        });\n+            return;\n+        }\n+        Some(ty::BindByValue(_)) | None => return,\n+        Some(ty::BindByReference(m)) => m,\n+    };\n \n-        // Report errors if any.\n-        let binding_span = pat.span.with_hi(name.span.hi());\n-        if !conflicts_mut_mut.is_empty() {\n-            // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n-            let msg = &format!(\"cannot borrow `{}` as mutable more than once at a time\", name);\n-            let mut err = sess.struct_span_err(pat.span, msg);\n-            err.span_label(binding_span, \"first mutable borrow occurs here\");\n-            for sp in conflicts_mut_mut {\n-                err.span_label(sp, \"another mutable borrow occurs here\");\n-            }\n-            for sp in conflicts_mut_ref {\n-                err.span_label(sp, \"also borrowed as immutable here\");\n-            }\n-            err.emit();\n-        } else if !conflicts_mut_ref.is_empty() {\n-            // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n-            let (primary, also) = match mut_outer {\n-                Mutability::Mut => (\"mutable\", \"immutable\"),\n-                Mutability::Not => (\"immutable\", \"mutable\"),\n-            };\n-            let msg = &format!(\n-                \"cannot borrow `{}` as {} because it is also borrowed as {}\",\n-                name, also, primary,\n-            );\n-            let mut err = sess.struct_span_err(pat.span, msg);\n-            err.span_label(binding_span, &format!(\"{} borrow occurs here\", primary));\n-            for sp in conflicts_mut_ref {\n-                err.span_label(sp, &format!(\"{} borrow occurs here\", also));\n-            }\n-            err.emit();\n+    // We now have `ref $mut_outer binding @ sub` (semantically).\n+    // Recurse into each binding in `sub` and find mutability or move conflicts.\n+    let mut conflicts_move = Vec::new();\n+    let mut conflicts_mut_mut = Vec::new();\n+    let mut conflicts_mut_ref = Vec::new();\n+    sub.each_binding(|_, hir_id, span, _| match tables.extract_binding_mode(sess, hir_id, span) {\n+        Some(ty::BindByReference(mut_inner)) => match (mut_outer, mut_inner) {\n+            (Mutability::Not, Mutability::Not) => {} // Both sides are `ref`.\n+            (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push(span), // 2x `ref mut`.\n+            _ => conflicts_mut_ref.push(span),       // `ref` + `ref mut` in either direction.\n+        },\n+        Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id, span) => {\n+            conflicts_move.push(span) // `ref mut?` + by-move conflict.\n         }\n+        Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine.\n     });\n+\n+    // Report errors if any.\n+    if !conflicts_mut_mut.is_empty() {\n+        // Report mutability conflicts for e.g. `ref mut x @ Some(ref mut y)`.\n+        let msg = &format!(\"cannot borrow `{}` as mutable more than once at a time\", name);\n+        sess.struct_span_err(pat.span, msg)\n+            .span_label(binding_span, \"first mutable borrow occurs here\")\n+            .span_labels(conflicts_mut_mut, \"another mutable borrow occurs here\")\n+            .span_labels(conflicts_mut_ref, \"also borrowed as immutable here\")\n+            .span_labels(conflicts_move, \"also moved here\")\n+            .emit();\n+    } else if !conflicts_mut_ref.is_empty() {\n+        // Report mutability conflicts for e.g. `ref x @ Some(ref mut y)` or the converse.\n+        let (primary, also) = match mut_outer {\n+            Mutability::Mut => (\"mutable\", \"immutable\"),\n+            Mutability::Not => (\"immutable\", \"mutable\"),\n+        };\n+        let msg = &format!(\n+            \"cannot borrow `{}` as {} because it is also borrowed as {}\",\n+            name, also, primary,\n+        );\n+        sess.struct_span_err(pat.span, msg)\n+            .span_label(binding_span, format!(\"{} borrow occurs here\", primary))\n+            .span_labels(conflicts_mut_ref, format!(\"{} borrow occurs here\", also))\n+            .span_labels(conflicts_move, \"also moved here\")\n+            .emit();\n+    } else if !conflicts_move.is_empty() {\n+        // Report by-ref and by-move conflicts, e.g. `ref x @ y`.\n+        let msg = &format!(\"cannot move out of `{}` because it is borrowed\", name);\n+        sess.struct_span_err(pat.span, msg)\n+            .span_label(binding_span, format!(\"borrow of `{}` occurs here\", name))\n+            .span_labels(conflicts_move, format!(\"move out of `{}` occurs here\", name))\n+            .emit();\n+    }\n }\n \n /// Forbids bindings in `@` patterns. This used to be is necessary for memory safety,"}, {"sha": "a8cd027831d3173bed06b26b901b3d78e9747c91", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7af9ff3e699207da7a5220b98ba9831d66697c80/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=7af9ff3e699207da7a5220b98ba9831d66697c80", "patch": "@@ -455,6 +455,7 @@ symbols! {\n         module,\n         module_path,\n         more_struct_aliases,\n+        move_ref_pattern,\n         move_val_init,\n         movbe_target_feature,\n         mul_with_overflow,"}]}