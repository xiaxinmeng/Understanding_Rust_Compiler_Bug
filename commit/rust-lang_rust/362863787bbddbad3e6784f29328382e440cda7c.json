{"sha": "362863787bbddbad3e6784f29328382e440cda7c", "node_id": "C_kwDOAAsO6NoAKDM2Mjg2Mzc4N2JiZGRiYWQzZTY3ODRmMjkzMjgzODJlNDQwY2RhN2M", "commit": {"author": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:42:34Z"}, "committer": {"name": "Neven Villani", "email": "vanille@crans.org", "date": "2023-03-16T13:52:46Z"}, "message": "TB: Tree structure", "tree": {"sha": "75e55e53cf67917b48c9e818041a8ea2ed34de84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75e55e53cf67917b48c9e818041a8ea2ed34de84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/362863787bbddbad3e6784f29328382e440cda7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/362863787bbddbad3e6784f29328382e440cda7c", "html_url": "https://github.com/rust-lang/rust/commit/362863787bbddbad3e6784f29328382e440cda7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/362863787bbddbad3e6784f29328382e440cda7c/comments", "author": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Vanille-N", "id": 58042063, "node_id": "MDQ6VXNlcjU4MDQyMDYz", "avatar_url": "https://avatars.githubusercontent.com/u/58042063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Vanille-N", "html_url": "https://github.com/Vanille-N", "followers_url": "https://api.github.com/users/Vanille-N/followers", "following_url": "https://api.github.com/users/Vanille-N/following{/other_user}", "gists_url": "https://api.github.com/users/Vanille-N/gists{/gist_id}", "starred_url": "https://api.github.com/users/Vanille-N/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Vanille-N/subscriptions", "organizations_url": "https://api.github.com/users/Vanille-N/orgs", "repos_url": "https://api.github.com/users/Vanille-N/repos", "events_url": "https://api.github.com/users/Vanille-N/events{/privacy}", "received_events_url": "https://api.github.com/users/Vanille-N/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7104fb6c2b378c124acc4a74e4524ccb031819", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7104fb6c2b378c124acc4a74e4524ccb031819", "html_url": "https://github.com/rust-lang/rust/commit/8c7104fb6c2b378c124acc4a74e4524ccb031819"}], "stats": {"total": 215, "additions": 215, "deletions": 0}, "files": [{"sha": "7a7f71245343b923fac76d84fe6183f46e9ca7e5", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/362863787bbddbad3e6784f29328382e440cda7c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/362863787bbddbad3e6784f29328382e440cda7c/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=362863787bbddbad3e6784f29328382e440cda7c", "patch": "@@ -0,0 +1,215 @@\n+//! In this file we handle the \"Tree\" part of Tree Borrows, i.e. all tree\n+//! traversal functions, optimizations to trim branches, and keeping track of\n+//! the relative position of the access to each node being updated. This of course\n+//! also includes the definition of the tree structure.\n+//!\n+//! Functions here manipulate permissions but are oblivious to them: as\n+//! the internals of `Permission` are private, the update process is a black\n+//! box. All we need to know here are\n+//! - the fact that updates depend only on the old state, the status of protectors,\n+//!   and the relative position of the access;\n+//! - idempotency properties asserted in `perms.rs` (for optimizations)\n+\n+use smallvec::SmallVec;\n+\n+use rustc_const_eval::interpret::InterpResult;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_target::abi::Size;\n+\n+use crate::borrow_tracker::tree_borrows::{\n+    diagnostics::{NodeDebugInfo, TbError, TransitionError},\n+    unimap::{UniEntry, UniIndex, UniKeyMap, UniValMap},\n+    Permission,\n+};\n+use crate::borrow_tracker::{AccessKind, GlobalState, ProtectorKind};\n+use crate::*;\n+\n+/// Data for a single *location*.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(super) struct LocationState {\n+    /// This pointer's current permission\n+    permission: Permission,\n+    /// A location is initialized when it is child accessed for the first time,\n+    /// and it then stays initialized forever.\n+    /// Before initialization we still apply some preemptive transitions on\n+    /// `permission` to know what to do in case it ever gets initialized,\n+    /// but these can never cause any immediate UB. There can however be UB\n+    /// the moment we attempt to initalize (i.e. child-access) because some\n+    /// foreign access done between the creation and the initialization is\n+    /// incompatible with child accesses.\n+    initialized: bool,\n+    /// Strongest foreign access whose effects have already been applied to\n+    /// this node and all its children since the last child access.\n+    /// This is `None` if the most recent access is a child access,\n+    /// `Some(Write)` if at least one foreign write access has been applied\n+    /// since the previous child access, and `Some(Read)` if at least one\n+    /// foreign read and no foreign write have occurred since the last child access.\n+    latest_foreign_access: Option<AccessKind>,\n+}\n+\n+impl LocationState {\n+    /// Default initial state has never been accessed and has been subjected to no\n+    /// foreign access.\n+    fn new(permission: Permission) -> Self {\n+        Self { permission, initialized: false, latest_foreign_access: None }\n+    }\n+\n+    /// Record that this location was accessed through a child pointer by\n+    /// marking it as initialized\n+    fn with_access(mut self) -> Self {\n+        self.initialized = true;\n+        self\n+    }\n+\n+    pub fn is_initialized(&self) -> bool {\n+        self.initialized\n+    }\n+\n+    pub fn permission(&self) -> Permission {\n+        self.permission\n+    }\n+}\n+\n+/// Tree structure with both parents and children since we want to be\n+/// able to traverse the tree efficiently in both directions.\n+#[derive(Clone, Debug)]\n+pub struct Tree {\n+    /// Mapping from tags to keys. The key obtained can then be used in\n+    /// any of the `UniValMap` relative to this allocation, i.e. both the\n+    /// `nodes` and `rperms` of the same `Tree`.\n+    /// The parent-child relationship in `Node` is encoded in terms of these same\n+    /// keys, so traversing the entire tree needs exactly one access to\n+    /// `tag_mapping`.\n+    pub(super) tag_mapping: UniKeyMap<BorTag>,\n+    /// All nodes of this tree.\n+    pub(super) nodes: UniValMap<Node>,\n+    /// Maps a tag and a location to a perm, with possible lazy\n+    /// initialization.\n+    ///\n+    /// NOTE: not all tags registered in `nodes` are necessarily in all\n+    /// ranges of `rperms`, because `rperms` is in part lazily initialized.\n+    /// Just because `nodes.get(key)` is `Some(_)` does not mean you can safely\n+    /// `unwrap` any `perm.get(key)`.\n+    ///\n+    /// We do uphold the fact that `keys(perms)` is a subset of `keys(nodes)`\n+    pub(super) rperms: RangeMap<UniValMap<LocationState>>,\n+    /// The index of the root node.\n+    pub(super) root: UniIndex,\n+}\n+\n+/// A node in the borrow tree. Each node is uniquely identified by a tag via\n+/// the `nodes` map of `Tree`.\n+#[derive(Clone, Debug)]\n+pub(super) struct Node {\n+    /// The tag of this node.\n+    pub tag: BorTag,\n+    /// All tags except the root have a parent tag.\n+    pub parent: Option<UniIndex>,\n+    /// If the pointer was reborrowed, it has children.\n+    // FIXME: bench to compare this to FxHashSet and to other SmallVec sizes\n+    pub children: SmallVec<[UniIndex; 4]>,\n+    /// Either `Reserved` or `Frozen`, the permission this tag will be lazily initialized\n+    /// to on the first access.\n+    default_initial_perm: Permission,\n+    /// Some extra information useful only for debugging purposes\n+    pub debug_info: NodeDebugInfo,\n+}\n+\n+impl Tree {\n+    /// Create a new tree, with only a root pointer.\n+    pub fn new(root_tag: BorTag, size: Size) -> Self {\n+        let root_perm = Permission::new_root();\n+        let mut tag_mapping = UniKeyMap::default();\n+        let root_idx = tag_mapping.insert(root_tag);\n+        let nodes = {\n+            let mut nodes = UniValMap::<Node>::default();\n+            nodes.insert(\n+                root_idx,\n+                Node {\n+                    tag: root_tag,\n+                    parent: None,\n+                    children: SmallVec::default(),\n+                    default_initial_perm: root_perm,\n+                    debug_info: NodeDebugInfo::new(root_tag),\n+                },\n+            );\n+            nodes\n+        };\n+        let rperms = {\n+            let mut perms = UniValMap::default();\n+            perms.insert(root_idx, LocationState::new(root_perm).with_access());\n+            RangeMap::new(size, perms)\n+        };\n+        Self { root: root_idx, nodes, rperms, tag_mapping }\n+    }\n+}\n+\n+impl<'tcx> Tree {\n+    /// Insert a new tag in the tree\n+    pub fn new_child(\n+        &mut self,\n+        parent_tag: BorTag,\n+        new_tag: BorTag,\n+        default_initial_perm: Permission,\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx> {\n+        assert!(!self.tag_mapping.contains_key(&new_tag));\n+        let idx = self.tag_mapping.insert(new_tag);\n+        let parent_idx = self.tag_mapping.get(&parent_tag).unwrap();\n+        // Create the node\n+        self.nodes.insert(\n+            idx,\n+            Node {\n+                tag: new_tag,\n+                parent: Some(parent_idx),\n+                children: SmallVec::default(),\n+                default_initial_perm,\n+                debug_info: NodeDebugInfo::new(new_tag),\n+            },\n+        );\n+        // Register new_tag as a child of parent_tag\n+        self.nodes.get_mut(parent_idx).unwrap().children.push(idx);\n+        // Initialize perms\n+        let perm = LocationState::new(default_initial_perm).with_access();\n+        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            perms.insert(idx, perm);\n+        }\n+        Ok(())\n+    }\n+\n+/// Relative position of the access\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum AccessRelatedness {\n+    /// The accessed pointer is the current one\n+    This,\n+    /// The accessed pointer is a (transitive) child of the current one.\n+    // Current pointer is excluded (unlike in some other places of this module\n+    // where \"child\" is inclusive).\n+    StrictChildAccess,\n+    /// The accessed pointer is a (transitive) parent of the current one.\n+    // Current pointer is excluded.\n+    AncestorAccess,\n+    /// The accessed pointer is neither of the above.\n+    // It's a cousin/uncle/etc., something in a side branch.\n+    // FIXME: find a better name ?\n+    DistantAccess,\n+}\n+\n+impl AccessRelatedness {\n+    /// Check that access is either Ancestor or Distant, i.e. not\n+    /// a transitive child (initial pointer included).\n+    pub fn is_foreign(self) -> bool {\n+        matches!(self, AccessRelatedness::AncestorAccess | AccessRelatedness::DistantAccess)\n+    }\n+\n+    /// Given the AccessRelatedness for the parent node, compute the AccessRelatedness\n+    /// for the child node. This function assumes that we propagate away from the initial\n+    /// access.\n+    pub fn for_child(self) -> Self {\n+        use AccessRelatedness::*;\n+        match self {\n+            AncestorAccess | This => AncestorAccess,\n+            StrictChildAccess | DistantAccess => DistantAccess,\n+        }\n+    }\n+}"}]}