{"sha": "09e937744ad6e87e751fe874bd33e18e3f73c3f6", "node_id": "C_kwDOAAsO6NoAKDA5ZTkzNzc0NGFkNmU4N2U3NTFmZTg3NGJkMzNlMThlM2Y3M2MzZjY", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-03-29T08:37:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-03-29T08:37:29Z"}, "message": "Rollup merge of #109683 - compiler-errors:self-ty-overflow, r=lcnr\n\nCheck for overflow in `assemble_candidates_after_normalizing_self_ty`\n\nPrevents a stack overflow (:warning: :exclamation:) in the new solver when we have param-env candidates that look like: `T: Trait<Assoc = <T as Trait>::Assoc>`\n\nThe current error message looks bad, but that's because we don't distinguish overflow and other ambiguity errors. I'll break that out into a separate PR since the fix may be controversial.\n\nr? `@lcnr`", "tree": {"sha": "d66516a3cc4847631464dd32e26218176511abda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d66516a3cc4847631464dd32e26218176511abda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09e937744ad6e87e751fe874bd33e18e3f73c3f6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkI/jJCRBK7hj4Ov3rIwAAgeEIAAuXhGc/D1KPTrObcFxvZ+3v\nPSsABjffQtcuAVE7f2GRNGWRA5qFY9yyNB+Pd8rMnUV24H/r+oeeU6M1hhnU57Jc\nhq5xt7vLV9wCe7UL0hErlx90SFQ/95ElneBlsEcJTjjkkJhqx4MR8tudsNWXYIx/\nYHy1oMKJFkc+P+3Md2f7SzWLfI6Tz6G7qObNF+X8L9DakMgWT08g5ZYcFfZvUtAE\n0KsIm8pyLmA+BSCX55fx3qOVmXlBgJR8YMU525bCioY5U/tOugJsEUDGj3XnXpO/\noYGSpsOkpBoaBtHWLvF/S2L7752eiVmSyYXh9uWrYYQZC/qqtbl8vvtc+LxxVcY=\n=KIth\n-----END PGP SIGNATURE-----\n", "payload": "tree d66516a3cc4847631464dd32e26218176511abda\nparent a3eb2f0f222d628440975b58589fc75994403a97\nparent ef5f773bffdc2fb28bc833fa6132cbdade1dc549\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1680079049 +0530\ncommitter GitHub <noreply@github.com> 1680079049 +0530\n\nRollup merge of #109683 - compiler-errors:self-ty-overflow, r=lcnr\n\nCheck for overflow in `assemble_candidates_after_normalizing_self_ty`\n\nPrevents a stack overflow (:warning: :exclamation:) in the new solver when we have param-env candidates that look like: `T: Trait<Assoc = <T as Trait>::Assoc>`\n\nThe current error message looks bad, but that's because we don't distinguish overflow and other ambiguity errors. I'll break that out into a separate PR since the fix may be controversial.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09e937744ad6e87e751fe874bd33e18e3f73c3f6", "html_url": "https://github.com/rust-lang/rust/commit/09e937744ad6e87e751fe874bd33e18e3f73c3f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09e937744ad6e87e751fe874bd33e18e3f73c3f6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3eb2f0f222d628440975b58589fc75994403a97", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3eb2f0f222d628440975b58589fc75994403a97", "html_url": "https://github.com/rust-lang/rust/commit/a3eb2f0f222d628440975b58589fc75994403a97"}, {"sha": "ef5f773bffdc2fb28bc833fa6132cbdade1dc549", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef5f773bffdc2fb28bc833fa6132cbdade1dc549", "html_url": "https://github.com/rust-lang/rust/commit/ef5f773bffdc2fb28bc833fa6132cbdade1dc549"}], "stats": {"total": 123, "additions": 105, "deletions": 18}, "files": [{"sha": "0f7a0eb337ba6a51aaf767cff5b94dadd9b42fff", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/09e937744ad6e87e751fe874bd33e18e3f73c3f6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e937744ad6e87e751fe874bd33e18e3f73c3f6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=09e937744ad6e87e751fe874bd33e18e3f73c3f6", "patch": "@@ -1,5 +1,6 @@\n //! Code shared by trait and projection goals for candidate assembly.\n \n+use super::search_graph::OverflowHandler;\n #[cfg(doc)]\n use super::trait_goals::structural_traits::*;\n use super::{EvalCtxt, SolverMode};\n@@ -279,25 +280,38 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             return\n         };\n \n-        self.probe(|ecx| {\n-            let normalized_ty = ecx.next_ty_infer();\n-            let normalizes_to_goal = goal.with(\n-                tcx,\n-                ty::Binder::dummy(ty::ProjectionPredicate {\n-                    projection_ty,\n-                    term: normalized_ty.into(),\n-                }),\n-            );\n-            ecx.add_goal(normalizes_to_goal);\n-            if let Ok(_) = ecx.try_evaluate_added_goals() {\n-                let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n-\n-                // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n-                // This doesn't work as long as we use `CandidateSource` in winnowing.\n-                let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n-                candidates.extend(ecx.assemble_and_evaluate_candidates(goal));\n-            }\n+        let normalized_self_candidates: Result<_, NoSolution> = self.probe(|ecx| {\n+            ecx.with_incremented_depth(\n+                |ecx| {\n+                    let result = ecx.evaluate_added_goals_and_make_canonical_response(\n+                        Certainty::Maybe(MaybeCause::Overflow),\n+                    )?;\n+                    Ok(vec![Candidate { source: CandidateSource::BuiltinImpl, result }])\n+                },\n+                |ecx| {\n+                    let normalized_ty = ecx.next_ty_infer();\n+                    let normalizes_to_goal = goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty,\n+                            term: normalized_ty.into(),\n+                        }),\n+                    );\n+                    ecx.add_goal(normalizes_to_goal);\n+                    let _ = ecx.try_evaluate_added_goals()?;\n+                    let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+                    // NOTE: Alternatively we could call `evaluate_goal` here and only\n+                    // have a `Normalized` candidate. This doesn't work as long as we\n+                    // use `CandidateSource` in winnowing.\n+                    let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+                    Ok(ecx.assemble_and_evaluate_candidates(goal))\n+                },\n+            )\n         });\n+\n+        if let Ok(normalized_self_candidates) = normalized_self_candidates {\n+            candidates.extend(normalized_self_candidates);\n+        }\n     }\n \n     fn assemble_impl_candidates<G: GoalKind<'tcx>>("}, {"sha": "574f3e9a5772d3cc406b601aa60b16f775202b49", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/overflow.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/09e937744ad6e87e751fe874bd33e18e3f73c3f6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e937744ad6e87e751fe874bd33e18e3f73c3f6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Foverflow.rs?ref=09e937744ad6e87e751fe874bd33e18e3f73c3f6", "patch": "@@ -73,6 +73,27 @@ pub(in crate::solve) trait OverflowHandler<'tcx> {\n         self.search_graph().overflow_data.deal_with_overflow();\n         on_overflow(self)\n     }\n+\n+    // Increment the `additional_depth` by one and evaluate `body`, or `on_overflow`\n+    // if the depth is overflown.\n+    fn with_incremented_depth<T>(\n+        &mut self,\n+        on_overflow: impl FnOnce(&mut Self) -> T,\n+        body: impl FnOnce(&mut Self) -> T,\n+    ) -> T {\n+        let depth = self.search_graph().stack.len();\n+        self.search_graph().overflow_data.additional_depth += 1;\n+\n+        let result = if self.search_graph().overflow_data.has_overflow(depth) {\n+            self.search_graph().overflow_data.deal_with_overflow();\n+            on_overflow(self)\n+        } else {\n+            body(self)\n+        };\n+\n+        self.search_graph().overflow_data.additional_depth -= 1;\n+        result\n+    }\n }\n \n impl<'tcx> OverflowHandler<'tcx> for EvalCtxt<'_, 'tcx> {"}, {"sha": "7417d6018a131e881359100bba62cd9d32ec2455", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.rs?ref=09e937744ad6e87e751fe874bd33e18e3f73c3f6", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo1 {\n+    type Assoc1;\n+}\n+\n+trait Foo2 {\n+    type Assoc2;\n+}\n+\n+trait Bar {}\n+fn needs_bar<S: Bar>() {}\n+\n+fn test<T: Foo1<Assoc1 = <T as Foo2>::Assoc2> + Foo2<Assoc2 = <T as Foo1>::Assoc1>>() {\n+    needs_bar::<T::Assoc1>();\n+    //~^ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "29cfa47a1050a38133a7b7c13744cdc316f681e1", "filename": "tests/ui/traits/new-solver/recursive-self-normalization-2.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization-2.stderr?ref=09e937744ad6e87e751fe874bd33e18e3f73c3f6", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/recursive-self-normalization-2.rs:15:5\n+   |\n+LL |     needs_bar::<T::Assoc1>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "f3e3d71d813e4da2f2c534a0b5c59d5b32171dd3", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.rs?ref=09e937744ad6e87e751fe874bd33e18e3f73c3f6", "patch": "@@ -0,0 +1,15 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+trait Foo {\n+    type Assoc;\n+}\n+\n+trait Bar {}\n+fn needs_bar<S: Bar>() {}\n+\n+fn test<T: Foo<Assoc = <T as Foo>::Assoc>>() {\n+    needs_bar::<T::Assoc>();\n+    //~^ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "ba39981893d447134c8955cfaf40e04c478ccbb1", "filename": "tests/ui/traits/new-solver/recursive-self-normalization.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09e937744ad6e87e751fe874bd33e18e3f73c3f6/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Frecursive-self-normalization.stderr?ref=09e937744ad6e87e751fe874bd33e18e3f73c3f6", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/recursive-self-normalization.rs:11:5\n+   |\n+LL |     needs_bar::<T::Assoc>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `S` declared on the function `needs_bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}