{"sha": "e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxMzI4MjBmOGZiZGNiZDkxZGJmMzRkZTk3MzI2MDRmYzFjNmIxYTI=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2016-10-24T13:29:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-24T13:29:54Z"}, "message": "Merge pull request #1284 from oli-obk/deep_code_inspection\n\ninitial implementation of the code inspector lint", "tree": {"sha": "f0cf58fc6f3731a05faddfd17a24485d182c1540", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0cf58fc6f3731a05faddfd17a24485d182c1540"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "html_url": "https://github.com/rust-lang/rust/commit/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7", "html_url": "https://github.com/rust-lang/rust/commit/9fcc04e7dfe965d1eb9c6a45ad26c319525b54d7"}, {"sha": "ed50cb133dd338d0e4a5ead4c0903b59d5a42dac", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed50cb133dd338d0e4a5ead4c0903b59d5a42dac", "html_url": "https://github.com/rust-lang/rust/commit/ed50cb133dd338d0e4a5ead4c0903b59d5a42dac"}], "stats": {"total": 481, "additions": 481, "deletions": 0}, "files": [{"sha": "4c97c5d465f0f7b303ac3d1067d64c7157bec211", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "patch": "@@ -7,6 +7,7 @@\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n+#![feature(repeat_str)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n \n@@ -172,6 +173,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box serde::Serde);\n     reg.register_early_lint_pass(box utils::internal_lints::Clippy);\n     reg.register_late_lint_pass(box utils::internal_lints::LintWithoutLintPass::default());\n+    reg.register_late_lint_pass(box utils::inspector::Pass);\n     reg.register_late_lint_pass(box types::TypePass);\n     reg.register_late_lint_pass(box booleans::NonminimalBool);\n     reg.register_late_lint_pass(box eq_op::EqOp);"}, {"sha": "0ad216ba04dccdaf3ad5fc5f0fdc605edbbb6a77", "filename": "clippy_lints/src/utils/inspector.rs", "status": "added", "additions": 478, "deletions": 0, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "patch": "@@ -0,0 +1,478 @@\n+#![allow(print_stdout, use_debug)]\n+\n+//! checks for attributes\n+\n+use rustc::lint::*;\n+use rustc::hir;\n+use syntax::ast::{Attribute, MetaItemKind};\n+\n+/// **What it does:** Dumps every ast/hir node which has the `#[clippy_dump]` attribute\n+///\n+/// **Why is this bad?** \ud83d\ude08\n+///\n+/// **Known problems:** \u2205\n+///\n+/// **Example:**\n+/// ```rust\n+/// #[inspect]\n+/// extern crate foo;\n+/// ```\n+declare_lint! {\n+    pub DEEP_CODE_INSPECTION,\n+    Warn,\n+    \"helper to dump info about code\"\n+}\n+\n+pub struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(DEEP_CODE_INSPECTION)\n+    }\n+}\n+\n+impl LateLintPass for Pass {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+        if !has_attr(&item.attrs) {\n+            return;\n+        }\n+        print_item(cx, item);\n+    }\n+\n+    fn check_impl_item(&mut self, cx: &LateContext, item: &hir::ImplItem) {\n+        if !has_attr(&item.attrs) {\n+            return;\n+        }\n+        println!(\"impl item `{}`\", item.name);\n+        match item.vis {\n+            hir::Visibility::Public => println!(\"public\"),\n+            hir::Visibility::Crate => println!(\"visible crate wide\"),\n+            hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", path),\n+            hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n+        }\n+        if item.defaultness.is_default() {\n+            println!(\"default\");\n+        }\n+        match item.node {\n+            hir::ImplItemKind::Const(_, ref e) => {\n+                println!(\"associated constant\");\n+                print_expr(cx, e, 1);\n+            },\n+            hir::ImplItemKind::Method(..) => println!(\"method\"),\n+            hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n+        }\n+    }\n+/*\n+    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+        if !has_attr(&item.attrs) {\n+            return;\n+        }\n+    }\n+\n+    fn check_variant(&mut self, cx: &LateContext, var: &hir::Variant, _: &hir::Generics) {\n+        if !has_attr(&var.node.attrs) {\n+            return;\n+        }\n+    }\n+\n+    fn check_struct_field(&mut self, cx: &LateContext, field: &hir::StructField) {\n+        if !has_attr(&field.attrs) {\n+            return;\n+        }\n+    }\n+*/\n+\n+    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+        if !has_attr(&expr.attrs) {\n+            return;\n+        }\n+        print_expr(cx, expr, 0);\n+    }\n+\n+    fn check_arm(&mut self, cx: &LateContext, arm: &hir::Arm) {\n+        if !has_attr(&arm.attrs) {\n+            return;\n+        }\n+        for pat in &arm.pats {\n+            print_pat(cx, pat, 1);\n+        }\n+        if let Some(ref guard) = arm.guard {\n+            println!(\"guard:\");\n+            print_expr(cx, guard, 1);\n+        }\n+        println!(\"body:\");\n+        print_expr(cx, &arm.body, 1);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+        if !has_attr(stmt.node.attrs()) {\n+            return;\n+        }\n+        match stmt.node {\n+            hir::StmtDecl(ref decl, _) => print_decl(cx, decl),\n+            hir::StmtExpr(ref e, _) | hir::StmtSemi(ref e, _) => print_expr(cx, e, 0),\n+        }\n+    }\n+/*\n+\n+    fn check_foreign_item(&mut self, cx: &LateContext, item: &hir::ForeignItem) {\n+        if !has_attr(&item.attrs) {\n+            return;\n+        }\n+    }\n+*/\n+}\n+\n+fn has_attr(attrs: &[Attribute]) -> bool {\n+    attrs.iter().any(|attr| match attr.node.value.node {\n+        MetaItemKind::Word(ref word) => word == \"clippy_dump\",\n+        _ => false,\n+    })\n+}\n+\n+fn print_decl(cx: &LateContext, decl: &hir::Decl) {\n+    match decl.node {\n+        hir::DeclLocal(ref local) => {\n+            println!(\"local variable of type {}\", cx.tcx.node_id_to_type(local.id));\n+            println!(\"pattern:\");\n+            print_pat(cx, &local.pat, 0);\n+            if let Some(ref e) = local.init {\n+                println!(\"init expression:\");\n+                print_expr(cx, e, 0);\n+            }\n+        },\n+        hir::DeclItem(_) => println!(\"item decl\"),\n+    }\n+}\n+\n+fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n+    let ind = \"  \".repeat(indent);\n+    let ty = cx.tcx.node_id_to_type(expr.id);\n+    println!(\"{}+\", ind);\n+    match expr.node {\n+        hir::ExprBox(ref e) => {\n+            println!(\"{}Box, {}\", ind, ty);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprArray(ref v) => {\n+            println!(\"{}Array, {}\", ind, ty);\n+            for e in v {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprCall(ref func, ref args) => {\n+            println!(\"{}Call, {}\", ind, ty);\n+            println!(\"{}function:\", ind);\n+            print_expr(cx, func, indent + 1);\n+            println!(\"{}arguments:\", ind);\n+            for arg in args {\n+                print_expr(cx, arg, indent + 1);\n+            }\n+        },\n+        hir::ExprMethodCall(ref name, _, ref args) => {\n+            println!(\"{}MethodCall, {}\", ind, ty);\n+            println!(\"{}method name: {}\", ind, name.node);\n+            for arg in args {\n+                print_expr(cx, arg, indent + 1);\n+            }\n+        },\n+        hir::ExprTup(ref v) => {\n+            println!(\"{}Tup, {}\", ind, ty);\n+            for e in v {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            println!(\"{}Binary, {}\", ind, ty);\n+            println!(\"{}op: {:?}\", ind, op.node);\n+            println!(\"{}lhs:\", ind);\n+            print_expr(cx, lhs, indent + 1);\n+            println!(\"{}rhs:\", ind);\n+            print_expr(cx, rhs, indent + 1);\n+        },\n+        hir::ExprUnary(op, ref inner) => {\n+            println!(\"{}Unary, {}\", ind, ty);\n+            println!(\"{}op: {:?}\", ind, op);\n+            print_expr(cx, inner, indent + 1);\n+        },\n+        hir::ExprLit(ref lit) => {\n+            println!(\"{}Lit, {}\", ind, ty);\n+            println!(\"{}{:?}\", ind, lit);\n+        },\n+        hir::ExprCast(ref e, ref target) => {\n+            println!(\"{}Cast, {}\", ind, ty);\n+            print_expr(cx, e, indent + 1);\n+            println!(\"{}target type: {:?}\", ind, target);\n+        },\n+        hir::ExprType(ref e, ref target) => {\n+            println!(\"{}Type, {}\", ind, ty);\n+            print_expr(cx, e, indent + 1);\n+            println!(\"{}target type: {:?}\", ind, target);\n+        },\n+        hir::ExprIf(ref e, _, ref els) => {\n+            println!(\"{}If, {}\", ind, ty);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, e, indent + 1);\n+            if let Some(ref els) = *els {\n+                println!(\"{}else:\", ind);\n+                print_expr(cx, els, indent + 1);\n+            }\n+        },\n+        hir::ExprWhile(ref cond, _, _) => {\n+            println!(\"{}While, {}\", ind, ty);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, cond, indent + 1);\n+        },\n+        hir::ExprLoop(..) => {\n+            println!(\"{}Loop, {}\", ind, ty);\n+        },\n+        hir::ExprMatch(ref cond, _, ref source) => {\n+            println!(\"{}Match, {}\", ind, ty);\n+            println!(\"{}condition:\", ind);\n+            print_expr(cx, cond, indent + 1);\n+            println!(\"{}source: {:?}\", ind, source);\n+        },\n+        hir::ExprClosure(ref clause, _, _, _) => {\n+            println!(\"{}Closure, {}\", ind, ty);\n+            println!(\"{}clause: {:?}\", ind, clause);\n+        },\n+        hir::ExprBlock(_) => {\n+            println!(\"{}Block, {}\", ind, ty);\n+        },\n+        hir::ExprAssign(ref lhs, ref rhs) => {\n+            println!(\"{}Assign, {}\", ind, ty);\n+            println!(\"{}lhs:\", ind);\n+            print_expr(cx, lhs, indent + 1);\n+            println!(\"{}rhs:\", ind);\n+            print_expr(cx, rhs, indent + 1);\n+        },\n+        hir::ExprAssignOp(ref binop, ref lhs, ref rhs) => {\n+            println!(\"{}AssignOp, {}\", ind, ty);\n+            println!(\"{}op: {:?}\", ind, binop.node);\n+            println!(\"{}lhs:\", ind);\n+            print_expr(cx, lhs, indent + 1);\n+            println!(\"{}rhs:\", ind);\n+            print_expr(cx, rhs, indent + 1);\n+        },\n+        hir::ExprField(ref e, ref name) => {\n+            println!(\"{}Field, {}\", ind, ty);\n+            println!(\"{}field name: {}\", ind, name.node);\n+            println!(\"{}struct expr:\", ind);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprTupField(ref e, ref idx) => {\n+            println!(\"{}TupField, {}\", ind, ty);\n+            println!(\"{}field index: {}\", ind, idx.node);\n+            println!(\"{}tuple expr:\", ind);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprIndex(ref arr, ref idx) => {\n+            println!(\"{}Index, {}\", ind, ty);\n+            println!(\"{}array expr:\", ind);\n+            print_expr(cx, arr, indent + 1);\n+            println!(\"{}index expr:\", ind);\n+            print_expr(cx, idx, indent + 1);\n+        },\n+        hir::ExprPath(ref sel, ref path) => {\n+            println!(\"{}Path, {}\", ind, ty);\n+            println!(\"{}self: {:?}\", ind, sel);\n+            println!(\"{}path: {:?}\", ind, path);\n+        },\n+        hir::ExprAddrOf(ref muta, ref e) => {\n+            println!(\"{}AddrOf, {}\", ind, ty);\n+            println!(\"mutability: {:?}\", muta);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::ExprBreak(_) => println!(\"{}Break, {}\", ind, ty),\n+        hir::ExprAgain(_) => println!(\"{}Again, {}\", ind, ty),\n+        hir::ExprRet(ref e) => {\n+            println!(\"{}Ret, {}\", ind, ty);\n+            if let Some(ref e) = *e {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprInlineAsm(_, ref input, ref output) => {\n+            println!(\"{}InlineAsm, {}\", ind, ty);\n+            println!(\"{}inputs:\", ind);\n+            for e in input {\n+                print_expr(cx, e, indent + 1);\n+            }\n+            println!(\"{}outputs:\", ind);\n+            for e in output {\n+                print_expr(cx, e, indent + 1);\n+            }\n+        },\n+        hir::ExprStruct(ref path, ref fields, ref base) => {\n+            println!(\"{}Struct, {}\", ind, ty);\n+            println!(\"{}path: {:?}\", ind, path);\n+            for field in fields {\n+                println!(\"{}field \\\"{}\\\":\", ind, field.name.node);\n+                print_expr(cx, &field.expr, indent + 1);\n+            }\n+            if let Some(ref base) = *base {\n+                println!(\"{}base:\", ind);\n+                print_expr(cx, base, indent + 1);\n+            }\n+        },\n+        hir::ExprRepeat(ref val, ref n) => {\n+            println!(\"{}Repeat, {}\", ind, ty);\n+            println!(\"{}value:\", ind);\n+            print_expr(cx, val, indent + 1);\n+            println!(\"{}repeat count:\", ind);\n+            print_expr(cx, n, indent + 1);\n+        },\n+    }\n+}\n+\n+fn print_item(cx: &LateContext, item: &hir::Item) {\n+    let did = cx.tcx.map.local_def_id(item.id);\n+    println!(\"item `{}`\", item.name);\n+    match item.vis {\n+        hir::Visibility::Public => println!(\"public\"),\n+        hir::Visibility::Crate => println!(\"visible crate wide\"),\n+        hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", path),\n+        hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n+    }\n+    match item.node {\n+        hir::ItemExternCrate(ref _renamed_from) => {\n+            if let Some(crate_id) = cx.tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n+                let source = cx.tcx.sess.cstore.used_crate_source(crate_id);\n+                if let Some(src) = source.dylib {\n+                    println!(\"extern crate dylib source: {:?}\", src.0);\n+                }\n+                if let Some(src) = source.rlib {\n+                    println!(\"extern crate rlib source: {:?}\", src.0);\n+                }\n+            } else {\n+                println!(\"weird extern crate without a crate id\");\n+            }\n+        }\n+        hir::ItemUse(ref path) => println!(\"{:?}\", path.node),\n+        hir::ItemStatic(..) => println!(\"static item: {:#?}\", cx.tcx.opt_lookup_item_type(did)),\n+        hir::ItemConst(..) => println!(\"const item: {:#?}\", cx.tcx.opt_lookup_item_type(did)),\n+        hir::ItemFn(..) => {\n+            let item_ty = cx.tcx.opt_lookup_item_type(did);\n+            println!(\"function: {:#?}\", item_ty);\n+        },\n+        hir::ItemMod(..) => println!(\"module\"),\n+        hir::ItemForeignMod(ref fm) => println!(\"foreign module with abi: {}\", fm.abi),\n+        hir::ItemTy(..) => {\n+            println!(\"type alias: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+        },\n+        hir::ItemEnum(..) => {\n+            println!(\"enum definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+        },\n+        hir::ItemStruct(..) => {\n+            println!(\"struct definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+        },\n+        hir::ItemUnion(..) => {\n+            println!(\"union definition: {:?}\", cx.tcx.opt_lookup_item_type(did));\n+        },\n+        hir::ItemTrait(..) => {\n+            println!(\"trait decl\");\n+            if cx.tcx.trait_has_default_impl(did) {\n+                println!(\"trait has a default impl\");\n+            } else {\n+                println!(\"trait has no default impl\");\n+            }\n+        },\n+        hir::ItemDefaultImpl(_, ref trait_ref) => {\n+            let trait_did = cx.tcx.map.local_def_id(trait_ref.ref_id);\n+            println!(\"default impl for `{:?}`\", cx.tcx.item_path_str(trait_did));\n+        },\n+        hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) => {\n+            let trait_did = cx.tcx.map.local_def_id(trait_ref.ref_id);\n+            println!(\"impl of trait `{:?}`\", cx.tcx.item_path_str(trait_did));\n+        },\n+        hir::ItemImpl(_, _, _, None, _, _) => {\n+            println!(\"impl\");\n+        },\n+    }\n+}\n+\n+fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n+    let ind = \"  \".repeat(indent);\n+    println!(\"{}+\", ind);\n+    match pat.node {\n+        hir::PatKind::Wild => println!(\"{}Wild\", ind),\n+        hir::PatKind::Binding(ref mode, ref name, ref inner) => {\n+            println!(\"{}Binding\", ind);\n+            println!(\"{}mode: {:?}\", ind, mode);\n+            println!(\"{}name: {}\", ind, name.node);\n+            if let Some(ref inner) = *inner {\n+                println!(\"{}inner:\", ind);\n+                print_pat(cx, inner, indent + 1);\n+            }\n+        },\n+        hir::PatKind::Struct(ref path, ref fields, ignore) => {\n+            println!(\"{}Struct\", ind);\n+            println!(\"{}name: {}\", ind, path);\n+            println!(\"{}ignore leftover fields: {}\", ind, ignore);\n+            println!(\"{}fields:\", ind);\n+            for field in fields {\n+                println!(\"{}  field name: {}\", ind, field.node.name);\n+                if field.node.is_shorthand {\n+                    println!(\"{}  in shorthand notation\", ind);\n+                }\n+                print_pat(cx, &field.node.pat, indent + 1);\n+            }\n+        },\n+        hir::PatKind::TupleStruct(ref path, ref fields, opt_dots_position) => {\n+            println!(\"{}TupleStruct\", ind);\n+            println!(\"{}path: {}\", ind, path);\n+            if let Some(dot_position) = opt_dots_position {\n+                println!(\"{}dot position: {}\", ind, dot_position);\n+            }\n+            for field in fields {\n+                print_pat(cx, field, indent + 1);\n+            }\n+        },\n+        hir::PatKind::Path(ref sel, ref path) => {\n+            println!(\"{}Path\", ind);\n+            println!(\"{}self: {:?}\", ind, sel);\n+            println!(\"{}path: {:?}\", ind, path);\n+        },\n+        hir::PatKind::Tuple(ref pats, opt_dots_position) => {\n+            println!(\"{}Tuple\", ind);\n+            if let Some(dot_position) = opt_dots_position {\n+                println!(\"{}dot position: {}\", ind, dot_position);\n+            }\n+            for field in pats {\n+                print_pat(cx, field, indent + 1);\n+            }\n+        },\n+        hir::PatKind::Box(ref inner) => {\n+            println!(\"{}Box\", ind);\n+            print_pat(cx, inner, indent + 1);\n+        },\n+        hir::PatKind::Ref(ref inner, ref muta) => {\n+            println!(\"{}Ref\", ind);\n+            println!(\"{}mutability: {:?}\", ind, muta);\n+            print_pat(cx, inner, indent + 1);\n+        },\n+        hir::PatKind::Lit(ref e) => {\n+            println!(\"{}Lit\", ind);\n+            print_expr(cx, e, indent + 1);\n+        },\n+        hir::PatKind::Range(ref l, ref r) => {\n+            println!(\"{}Range\", ind);\n+            print_expr(cx, l, indent + 1);\n+            print_expr(cx, r, indent + 1);\n+        },\n+        hir::PatKind::Slice(ref first_pats, ref range, ref last_pats) => {\n+            println!(\"{}Slice [a, b, ..i, y, z]\", ind);\n+            println!(\"[a, b]:\");\n+            for pat in first_pats {\n+                print_pat(cx, pat, indent + 1);\n+            }\n+            println!(\"i:\");\n+            if let Some(ref pat) = *range {\n+                print_pat(cx, pat, indent + 1);\n+            }\n+            println!(\"[y, z]:\");\n+            for pat in last_pats {\n+                print_pat(cx, pat, indent + 1);\n+            }\n+        },\n+    }\n+}"}, {"sha": "ba57512fcd5b0ceb5143fda6f0dafdcc47ebf939", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e132820f8fbdcbd91dbf34de9732604fc1c6b1a2/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=e132820f8fbdcbd91dbf34de9732604fc1c6b1a2", "patch": "@@ -25,6 +25,7 @@ pub mod constants;\n mod hir;\n pub mod paths;\n pub mod sugg;\n+pub mod inspector;\n pub mod internal_lints;\n pub use self::hir::{SpanlessEq, SpanlessHash};\n "}]}