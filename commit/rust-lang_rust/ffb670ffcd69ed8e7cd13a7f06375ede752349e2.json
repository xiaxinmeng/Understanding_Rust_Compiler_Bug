{"sha": "ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYjY3MGZmY2Q2OWVkOGU3Y2QxM2E3ZjA2Mzc1ZWRlNzUyMzQ5ZTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-29T08:12:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-08T02:21:43Z"}, "message": "Add initial support for a new formatting syntax\n\nThe new macro is available under the name ifmt! (only an intermediate name)", "tree": {"sha": "a3e82ac51c713a80d620128813b4fa653451da97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3e82ac51c713a80d620128813b4fa653451da97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "html_url": "https://github.com/rust-lang/rust/commit/ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b4244d917cc9341b1ec04c4e245d5f841d3facc", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b4244d917cc9341b1ec04c4e245d5f841d3facc", "html_url": "https://github.com/rust-lang/rust/commit/5b4244d917cc9341b1ec04c4e245d5f841d3facc"}], "stats": {"total": 2261, "additions": 2258, "deletions": 3}, "files": [{"sha": "bb74d9b3ec484b1d3730d74837359891c03ef4f5", "filename": "src/libstd/either.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -24,7 +24,7 @@ use vec;\n use vec::{OwnedVector, ImmutableVector};\n \n /// `Either` is a type that represents one of two alternatives\n-#[deriving(Clone, Eq)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum Either<L, R> {\n     Left(L),\n     Right(R)"}, {"sha": "2b8807b2291724a0d6f3da92671bd8622a2382f3", "filename": "src/libstd/fmt/mod.rs", "status": "added", "additions": 368, "deletions": 0, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,368 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use cast;\n+use int;\n+use rt::io::Decorator;\n+use rt::io::mem::MemWriter;\n+use rt::io;\n+use str;\n+use sys;\n+use uint;\n+use util;\n+use vec;\n+\n+pub mod parse;\n+pub mod rt;\n+\n+/// A struct to represent both where to emit formatting strings to and how they\n+/// should be formatted. A mutable version of this is passed to all formatting\n+/// traits.\n+pub struct Formatter<'self> {\n+    /// Flags for formatting (packed version of rt::Flag)\n+    flags: uint,\n+    /// Character used as 'fill' whenever there is alignment\n+    fill: char,\n+    /// Boolean indication of whether the output should be left-aligned\n+    alignleft: bool,\n+    /// Optionally specified integer width that the output should be\n+    width: Option<uint>,\n+    /// Optionally specified precision for numeric types\n+    precision: Option<uint>,\n+\n+    /// Output buffer.\n+    buf: &'self mut io::Writer,\n+\n+    priv curarg: vec::VecIterator<'self, Argument<'self>>,\n+    priv args: &'self [Argument<'self>],\n+}\n+\n+/// This struct represents the generic \"argument\" which is taken by the Xprintf\n+/// family of functions. It contains a function to format the given value. At\n+/// compile time it is ensured that the function and the value have the correct\n+/// types, and then this struct is used to canonicalize arguments to one type.\n+pub struct Argument<'self> {\n+    priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n+    priv value: &'self util::Void,\n+}\n+\n+#[allow(missing_doc)]\n+pub trait Bool { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Char { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Signed { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Unsigned { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Octal { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Binary { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait LowerHex { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait UpperHex { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait String { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Poly { fn fmt(&Self, &mut Formatter); }\n+#[allow(missing_doc)]\n+pub trait Pointer { fn fmt(&Self, &mut Formatter); }\n+\n+/// The sprintf function takes a precompiled format string and a list of\n+/// arguments, to return the resulting formatted string.\n+///\n+/// This is currently an unsafe function because the types of all arguments\n+/// aren't verified by immediate callers of this function. This currently does\n+/// not validate that the correct types of arguments are specified for each\n+/// format specifier, nor that each argument itself contains the right function\n+/// for formatting the right type value. Because of this, the function is marked\n+/// as `unsafe` if this is being called manually.\n+///\n+/// Thankfully the rust compiler provides the macro `ifmt!` which will perform\n+/// all of this validation at compile-time and provides a safe interface for\n+/// invoking this function.\n+///\n+/// # Arguments\n+///\n+///   * fmts - the precompiled format string to emit.\n+///   * args - the list of arguments to the format string. These are only the\n+///            positional arguments (not named)\n+///\n+/// Note that this function assumes that there are enough arguments for the\n+/// format string.\n+pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n+    let output = MemWriter::new();\n+    {\n+        let mut formatter = Formatter {\n+            flags: 0,\n+            width: None,\n+            precision: None,\n+            // FIXME(#8248): shouldn't need a transmute\n+            buf: cast::transmute(&output as &io::Writer),\n+            alignleft: false,\n+            fill: ' ',\n+            args: args,\n+            curarg: args.iter(),\n+        };\n+        for piece in fmt.iter() {\n+            formatter.run(piece, None);\n+        }\n+    }\n+    return str::from_bytes_owned(output.inner());\n+}\n+\n+impl<'self> Formatter<'self> {\n+    fn run(&mut self, piece: &rt::Piece, cur: Option<&str>) {\n+        let setcount = |slot: &mut Option<uint>, cnt: &parse::Count| {\n+            match *cnt {\n+                parse::CountIs(n) => { *slot = Some(n); }\n+                parse::CountImplied => { *slot = None; }\n+                parse::CountIsParam(i) => {\n+                    let v = self.args[i].value;\n+                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n+                }\n+                parse::CountIsNextParam => {\n+                    let v = self.curarg.next().unwrap().value;\n+                    unsafe { *slot = Some(*(v as *util::Void as *uint)); }\n+                }\n+            }\n+        };\n+\n+        match *piece {\n+            rt::String(s) => { self.buf.write(s.as_bytes()); }\n+            rt::CurrentArgument(()) => { self.buf.write(cur.unwrap().as_bytes()); }\n+            rt::Argument(ref arg) => {\n+                // Fill in the format parameters into the formatter\n+                self.fill = arg.format.fill;\n+                self.alignleft = arg.format.alignleft;\n+                self.flags = arg.format.flags;\n+                setcount(&mut self.width, &arg.format.width);\n+                setcount(&mut self.precision, &arg.format.precision);\n+\n+                // Extract the correct argument\n+                let value = match arg.position {\n+                    rt::ArgumentNext => { *self.curarg.next().unwrap() }\n+                    rt::ArgumentIs(i) => self.args[i],\n+                };\n+\n+                // Then actually do some printing\n+                match arg.method {\n+                    None => { (value.formatter)(value.value, self); }\n+                    Some(ref method) => { self.execute(*method, value); }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn execute(&mut self, method: &rt::Method, arg: Argument) {\n+        match *method {\n+            // Pluralization is selection upon a numeric value specified as the\n+            // parameter.\n+            rt::Plural(offset, ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // '&uint' value.\n+                let value: &uint = unsafe { cast::transmute(arg.value) };\n+                let value = *value;\n+\n+                // First, attempt to match against explicit values without the\n+                // offsetted value\n+                for s in selectors.iter() {\n+                    match s.selector {\n+                        Right(val) if value == val => {\n+                            return self.runplural(value, s.result);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                // Next, offset the value and attempt to match against the\n+                // keyword selectors.\n+                let value = value - match offset { Some(i) => i, None => 0 };\n+                for s in selectors.iter() {\n+                    let run = match s.selector {\n+                        Left(parse::Zero) => value == 0,\n+                        Left(parse::One) => value == 1,\n+                        Left(parse::Two) => value == 2,\n+\n+                        // XXX: Few/Many should have a user-specified boundary\n+                        //      One possible option would be in the function\n+                        //      pointer of the 'arg: Argument' struct.\n+                        Left(parse::Few) => value < 8,\n+                        Left(parse::Many) => value >= 8,\n+\n+                        Right(*) => false\n+                    };\n+                    if run {\n+                        return self.runplural(value, s.result);\n+                    }\n+                }\n+\n+                self.runplural(value, *default);\n+            }\n+\n+            // Select is just a matching against the string specified.\n+            rt::Select(ref selectors, ref default) => {\n+                // This is validated at compile-time to be a pointer to a\n+                // string slice,\n+                let value: & &str = unsafe { cast::transmute(arg.value) };\n+                let value = *value;\n+\n+                for s in selectors.iter() {\n+                    if s.selector == value {\n+                        for piece in s.result.iter() {\n+                            self.run(piece, Some(value));\n+                        }\n+                        return;\n+                    }\n+                }\n+                for piece in default.iter() {\n+                    self.run(piece, Some(value));\n+                }\n+            }\n+        }\n+    }\n+\n+    fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n+        do uint::to_str_bytes(value, 10) |buf| {\n+            let valuestr = str::from_bytes_slice(buf);\n+            for piece in pieces.iter() {\n+                self.run(piece, Some(valuestr));\n+            }\n+        }\n+    }\n+}\n+\n+/// This is a function which calls are emitted to by the compiler itself to\n+/// create the Argument structures that are passed into the `sprintf` function.\n+#[doc(hidden)]\n+pub fn argument<'a, T>(f: extern \"Rust\" fn(&T, &mut Formatter),\n+                       t: &'a T) -> Argument<'a> {\n+    unsafe {\n+        Argument {\n+            formatter: cast::transmute(f),\n+            value: cast::transmute(t)\n+        }\n+    }\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a string\n+/// (such as for select), then it invokes this method.\n+#[doc(hidden)]\n+pub fn argumentstr<'a>(s: &'a &str) -> Argument<'a> {\n+    argument(String::fmt, s)\n+}\n+\n+/// When the compiler determines that the type of an argument *must* be a uint\n+/// (such as for plural), then it invokes this method.\n+#[doc(hidden)]\n+pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n+    argument(Unsigned::fmt, s)\n+}\n+\n+// Implementations of the core formatting traits\n+\n+impl Bool for bool {\n+    fn fmt(b: &bool, f: &mut Formatter) {\n+        String::fmt(&(if *b {\"true\"} else {\"false\"}), f);\n+    }\n+}\n+\n+impl<'self> String for &'self str {\n+    fn fmt(s: & &'self str, f: &mut Formatter) {\n+        // XXX: formatting args\n+        f.buf.write(s.as_bytes())\n+    }\n+}\n+\n+impl Char for char {\n+    fn fmt(c: &char, f: &mut Formatter) {\n+        // XXX: formatting args\n+        // XXX: shouldn't require an allocation\n+        let mut s = ~\"\";\n+        s.push_char(*c);\n+        f.buf.write(s.as_bytes());\n+    }\n+}\n+\n+impl Signed for int {\n+    fn fmt(c: &int, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do int::to_str_bytes(*c, 10) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl Unsigned for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 10) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl Octal for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 8) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl LowerHex for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 16) |buf| {\n+            f.buf.write(buf);\n+        }\n+    }\n+}\n+\n+impl UpperHex for uint {\n+    fn fmt(c: &uint, f: &mut Formatter) {\n+        // XXX: formatting args\n+        do uint::to_str_bytes(*c, 16) |buf| {\n+            let mut local = [0u8, ..16];\n+            for (l, &b) in local.mut_iter().zip(buf.iter()) {\n+                *l = match b as char {\n+                    'a' .. 'f' => (b - 'a' as u8) + 'A' as u8,\n+                    _ => b,\n+                };\n+            }\n+            f.buf.write(local.slice_to(buf.len()));\n+        }\n+    }\n+}\n+\n+impl<T> Poly for T {\n+    fn fmt(t: &T, f: &mut Formatter) {\n+        // XXX: formatting args\n+        let s = sys::log_str(t);\n+        f.buf.write(s.as_bytes());\n+    }\n+}\n+\n+// n.b. use 'const' to get an implementation for both '*mut' and '*' at the same\n+//      time.\n+impl<T> Pointer for *const T {\n+    fn fmt(t: &*const T, f: &mut Formatter) {\n+        // XXX: formatting args\n+        f.buf.write(\"0x\".as_bytes());\n+        LowerHex::fmt(&(*t as uint), f);\n+    }\n+}\n+\n+// If you expected tests to be here, look instead at the run-pass/ifmt.rs test,\n+// it's a lot easier than creating all of the rt::Piece structures here."}, {"sha": "673ea1d3fa8b586c883708503287dec3a9affd62", "filename": "src/libstd/fmt/parse.rs", "status": "added", "additions": 896, "deletions": 0, "changes": 896, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,896 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use prelude::*;\n+\n+use char;\n+use str;\n+use iterator;\n+\n+condition! { pub parse_error: ~str -> (); }\n+\n+/// A piece is a portion of the format string which represents the next part to\n+/// emit. These are emitted as a stream by the `Parser` class.\n+#[deriving(Eq)]\n+pub enum Piece<'self> {\n+    /// A literal string which should directly be emitted\n+    String(&'self str),\n+    /// A back-reference to whatever the current argument is. This is used\n+    /// inside of a method call to refer back to the original argument.\n+    CurrentArgument,\n+    /// This describes that formatting should process the next argument (as\n+    /// specified inside) for emission.\n+    Argument(Argument<'self>),\n+}\n+\n+/// Representation of an argument specification.\n+#[deriving(Eq)]\n+pub struct Argument<'self> {\n+    /// Where to find this argument\n+    position: Position<'self>,\n+    /// How to format the argument\n+    format: FormatSpec<'self>,\n+    /// If not `None`, what method to invoke on the argument\n+    method: Option<~Method<'self>>\n+}\n+\n+/// Specification for the formatting of an argument in the format string.\n+#[deriving(Eq)]\n+pub struct FormatSpec<'self> {\n+    /// Optionally specified character to fill alignment with\n+    fill: Option<char>,\n+    /// Optionally specified alignment\n+    align: Option<Alignment>,\n+    /// Packed version of various flags provided\n+    flags: uint,\n+    /// The integer precision to use\n+    precision: Count,\n+    /// The string width requested for the resulting format\n+    width: Count,\n+    /// The descriptor string representing the name of the format desired for\n+    /// this argument, this can be empty or any number of characters, although\n+    /// it is required to be one word.\n+    ty: &'self str\n+}\n+\n+/// Enum describing where an argument for a format can be located.\n+#[deriving(Eq)]\n+pub enum Position<'self> {\n+    ArgumentNext, ArgumentIs(uint), ArgumentNamed(&'self str)\n+}\n+\n+/// Enum of alignments which are supoprted.\n+#[deriving(Eq)]\n+pub enum Alignment { AlignLeft, AlignRight }\n+\n+/// Various flags which can be applied to format strings, the meaning of these\n+/// flags is defined by the formatters themselves.\n+#[deriving(Eq)]\n+pub enum Flag {\n+    FlagSignPlus,\n+    FlagSignMinus,\n+    FlagAlternate,\n+}\n+\n+/// A count is used for the precision and width parameters of an integer, and\n+/// can reference either an argument or a literal integer.\n+#[deriving(Eq)]\n+pub enum Count {\n+    CountIs(uint),\n+    CountIsParam(uint),\n+    CountIsNextParam,\n+    CountImplied,\n+}\n+\n+/// Enum describing all of the possible methods which the formatting language\n+/// currently supports.\n+#[deriving(Eq)]\n+pub enum Method<'self> {\n+    /// A plural method selects on an integer over a list of either integer or\n+    /// keyword-defined clauses. The meaning of the keywords is defined by the\n+    /// current locale.\n+    ///\n+    /// An offset is optionally present at the beginning which is used to match\n+    /// against keywords, but it is not matched against the literal integers.\n+    ///\n+    /// The final element of this enum is the default \"other\" case which is\n+    /// always required to be specified.\n+    Plural(Option<uint>, ~[PluralArm<'self>], ~[Piece<'self>]),\n+\n+    /// A select method selects over a string. Each arm is a different string\n+    /// which can be selected for.\n+    ///\n+    /// As with `Plural`, a default \"other\" case is required as well.\n+    Select(~[SelectArm<'self>], ~[Piece<'self>]),\n+}\n+\n+/// Structure representing one \"arm\" of the `plural` function.\n+#[deriving(Eq)]\n+pub struct PluralArm<'self> {\n+    /// A selector can either be specified by a keyword or with an integer\n+    /// literal.\n+    selector: Either<PluralKeyword, uint>,\n+    /// Array of pieces which are the format of this arm\n+    result: ~[Piece<'self>],\n+}\n+\n+/// Enum of the 5 CLDR plural keywords. There is one more, \"other\", but that is\n+/// specially placed in the `Plural` variant of `Method`\n+///\n+/// http://www.icu-project.org/apiref/icu4c/classicu_1_1PluralRules.html\n+#[deriving(Eq, IterBytes)]\n+pub enum PluralKeyword {\n+    Zero, One, Two, Few, Many\n+}\n+\n+/// Structure representing one \"arm\" of the `select` function.\n+#[deriving(Eq)]\n+pub struct SelectArm<'self> {\n+    /// String selector which guards this arm\n+    selector: &'self str,\n+    /// Array of pieces which are the format of this arm\n+    result: ~[Piece<'self>],\n+}\n+\n+/// The parser structure for interpreting the input format string. This is\n+/// modelled as an iterator over `Piece` structures to form a stream of tokens\n+/// being output.\n+///\n+/// This is a recursive-descent parser for the sake of simplicity, and if\n+/// necessary there's probably lots of room for improvement performance-wise.\n+pub struct Parser<'self> {\n+    priv input: &'self str,\n+    priv cur: str::CharOffsetIterator<'self>,\n+}\n+\n+impl<'self> iterator::Iterator<Piece<'self>> for Parser<'self> {\n+    fn next(&mut self) -> Option<Piece<'self>> {\n+        match self.cur.clone().next() {\n+            Some((_, '#')) => { self.cur.next(); Some(CurrentArgument) }\n+            Some((_, '{')) => {\n+                self.cur.next();\n+                let ret = Some(Argument(self.argument()));\n+                if !self.consume('}') {\n+                    self.err(~\"unterminated format string\");\n+                }\n+                ret\n+            }\n+            Some((pos, '\\\\')) => {\n+                self.cur.next();\n+                self.escape(); // ensure it's a valid escape sequence\n+                Some(String(self.string(pos + 1))) // skip the '\\' character\n+            }\n+            Some((_, '}')) | None => { None }\n+            Some((pos, _)) => {\n+                Some(String(self.string(pos)))\n+            }\n+        }\n+    }\n+}\n+\n+impl<'self> Parser<'self> {\n+    /// Creates a new parser for the given format string\n+    pub fn new<'a>(s: &'a str) -> Parser<'a> {\n+        Parser {\n+            input: s,\n+            cur: s.char_offset_iter(),\n+        }\n+    }\n+\n+    /// Notifies of an error. The message doesn't actually need to be of type\n+    /// ~str, but I think it does when this eventually uses conditions so it\n+    /// might as well start using it now.\n+    fn err(&self, msg: ~str) {\n+        parse_error::cond.raise(msg);\n+    }\n+\n+    /// Optionally consumes the specified character. If the character is not at\n+    /// the current position, then the current iterator isn't moved and false is\n+    /// returned, otherwise the character is consumed and true is returned.\n+    fn consume(&mut self, c: char) -> bool {\n+        match self.cur.clone().next() {\n+            Some((_, maybe)) if c == maybe => {\n+                self.cur.next();\n+                true\n+            }\n+            Some(*) | None => false,\n+        }\n+    }\n+\n+    /// Attempts to consume any amount of whitespace followed by a character\n+    fn wsconsume(&mut self, c: char) -> bool {\n+        self.ws(); self.consume(c)\n+    }\n+\n+    /// Consumes all whitespace characters until the first non-whitespace\n+    /// character\n+    fn ws(&mut self) {\n+        loop {\n+            match self.cur.clone().next() {\n+                Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n+                Some(*) | None => { return }\n+            }\n+        }\n+    }\n+\n+    /// Consumes an escape sequence, failing if there is not a valid character\n+    /// to be escaped.\n+    fn escape(&mut self) -> char {\n+        match self.cur.next() {\n+            Some((_, c @ '#')) | Some((_, c @ '{')) |\n+            Some((_, c @ '\\\\')) | Some((_, c @ '}')) => { c }\n+            Some((_, c)) => {\n+                self.err(fmt!(\"invalid escape character `%c`\", c));\n+                c\n+            }\n+            None => {\n+                self.err(~\"expected an escape sequence, but format string was \\\n+                           terminated\");\n+                ' '\n+            }\n+        }\n+    }\n+\n+    /// Parses all of a string which is to be considered a \"raw literal\" in a\n+    /// format string. This is everything outside of the braces.\n+    fn string(&mut self, start: uint) -> &'self str {\n+        loop {\n+            // we may not consume the character, so clone the iterator\n+            match self.cur.clone().next() {\n+                Some((pos, '\\\\')) | Some((pos, '#')) |\n+                Some((pos, '}')) | Some((pos, '{')) => {\n+                    return self.input.slice(start, pos);\n+                }\n+                Some(*) => { self.cur.next(); }\n+                None => {\n+                    self.cur.next();\n+                    return self.input.slice(start, self.input.len());\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Parses an Argument structure, or what's contained within braces inside\n+    /// the format string\n+    fn argument(&mut self) -> Argument<'self> {\n+        Argument {\n+            position: self.position(),\n+            format: self.format(),\n+            method: self.method(),\n+        }\n+    }\n+\n+    /// Parses a positional argument for a format. This could either be an\n+    /// integer index of an argument, a named argument, or a blank string.\n+    fn position(&mut self) -> Position<'self> {\n+        match self.integer() {\n+            Some(i) => { ArgumentIs(i) }\n+            None => {\n+                match self.cur.clone().next() {\n+                    Some((_, c)) if char::is_alphabetic(c) => {\n+                        ArgumentNamed(self.word())\n+                    }\n+                    _ => ArgumentNext\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Parses a format specifier at the current position, returning all of the\n+    /// relevant information in the FormatSpec struct.\n+    fn format(&mut self) -> FormatSpec<'self> {\n+        let mut spec = FormatSpec {\n+            fill: None,\n+            align: None,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: self.input.slice(0, 0),\n+        };\n+        if !self.consume(':') { return spec }\n+\n+        // fill character\n+        match self.cur.clone().next() {\n+            Some((_, c)) => {\n+                match self.cur.clone().skip(1).next() {\n+                    Some((_, '>')) | Some((_, '<')) => {\n+                        spec.fill = Some(c);\n+                        self.cur.next();\n+                    }\n+                    Some(*) | None => {}\n+                }\n+            }\n+            None => {}\n+        }\n+        // Alignment\n+        if self.consume('<') {\n+            spec.align = Some(AlignLeft);\n+        } else if self.consume('>') {\n+            spec.align = Some(AlignRight);\n+        }\n+        // Sign flags\n+        if self.consume('+') {\n+            spec.flags |= 1 << (FlagSignPlus as uint);\n+        } else if self.consume('-') {\n+            spec.flags |= 1 << (FlagSignMinus as uint);\n+        }\n+        // Alternate marker\n+        if self.consume('#') {\n+            spec.flags |= 1 << (FlagAlternate as uint);\n+        }\n+        // Width and precision\n+        spec.width = self.count();\n+        if self.consume('.') {\n+            if self.consume('*') {\n+                spec.precision = CountIsNextParam;\n+            } else {\n+                spec.precision = self.count();\n+            }\n+        }\n+        // Finally the actual format specifier\n+        spec.ty = self.word();\n+        return spec;\n+    }\n+\n+    /// Parses a method to be applied to the previously specified argument and\n+    /// its format. The two current supported methods are 'plural' and 'select'\n+    fn method(&mut self) -> Option<~Method<'self>> {\n+        if !self.wsconsume(',') {\n+            return None;\n+        }\n+        self.ws();\n+        match self.word() {\n+            \"select\" => {\n+                if !self.wsconsume(',') {\n+                    self.err(~\"`select` must be followed by `,`\");\n+                }\n+                Some(self.select())\n+            }\n+            \"plural\" => {\n+                if !self.wsconsume(',') {\n+                    self.err(~\"`plural` must be followed by `,`\");\n+                }\n+                Some(self.plural())\n+            }\n+            \"\" => {\n+                self.err(~\"expected method after comma\");\n+                return None;\n+            }\n+            method => {\n+                self.err(fmt!(\"unknown method: `%s`\", method));\n+                return None;\n+            }\n+        }\n+    }\n+\n+    /// Parses a 'select' statement (after the initial 'select' word)\n+    fn select(&mut self) -> ~Method<'self> {\n+        let mut other = None;\n+        let mut arms = ~[];\n+        // Consume arms one at a time\n+        loop {\n+            self.ws();\n+            let selector = self.word();\n+            if selector == \"\" {\n+                self.err(~\"cannot have an empty selector\");\n+                break\n+            }\n+            if !self.wsconsume('{') {\n+                self.err(~\"selector must be followed by `{`\");\n+            }\n+            let pieces = self.collect();\n+            if !self.wsconsume('}') {\n+                self.err(~\"selector case must be terminated by `}`\");\n+            }\n+            if selector == \"other\" {\n+                if !other.is_none() {\n+                    self.err(~\"multiple `other` statements in `select\");\n+                }\n+                other = Some(pieces);\n+            } else {\n+                arms.push(SelectArm { selector: selector, result: pieces });\n+            }\n+            self.ws();\n+            match self.cur.clone().next() {\n+                Some((_, '}')) => { break }\n+                Some(*) | None => {}\n+            }\n+        }\n+        // The \"other\" selector must be present\n+        let other = match other {\n+            Some(arm) => { arm }\n+            None => {\n+                self.err(~\"`select` statement must provide an `other` case\");\n+                ~[]\n+            }\n+        };\n+        ~Select(arms, other)\n+    }\n+\n+    /// Parses a 'plural' statement (after the initial 'plural' word)\n+    fn plural(&mut self) -> ~Method<'self> {\n+        let mut offset = None;\n+        let mut other = None;\n+        let mut arms = ~[];\n+\n+        // First, attempt to parse the 'offset:' field. We know the set of\n+        // selector words which can appear in plural arms, and the only ones\n+        // which start with 'o' are \"other\" and \"offset\", hence look two\n+        // characters deep to see if we can consume the word \"offset\"\n+        self.ws();\n+        let mut it = self.cur.clone();\n+        match it.next() {\n+            Some((_, 'o')) => {\n+                match it.next() {\n+                    Some((_, 'f')) => {\n+                        let word = self.word();\n+                        if word != \"offset\" {\n+                            self.err(fmt!(\"expected `offset`, found `%s`\",\n+                                          word));\n+                        } else {\n+                            if !self.consume(':') {\n+                                self.err(~\"`offset` must be followed by `:`\");\n+                            }\n+                            match self.integer() {\n+                                Some(i) => { offset = Some(i); }\n+                                None => {\n+                                    self.err(~\"offset must be an integer\");\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Some(*) | None => {}\n+                }\n+            }\n+            Some(*) | None => {}\n+        }\n+\n+        // Next, generate all the arms\n+        loop {\n+            let mut isother = false;\n+            let selector = if self.wsconsume('=') {\n+                match self.integer() {\n+                    Some(i) => Right(i),\n+                    None => {\n+                        self.err(~\"plural `=` selectors must be followed by an \\\n+                                   integer\");\n+                        Right(0)\n+                    }\n+                }\n+            } else {\n+                let word = self.word();\n+                match word {\n+                    \"other\" => { isother = true; Left(Zero) }\n+                    \"zero\"  => Left(Zero),\n+                    \"one\"   => Left(One),\n+                    \"two\"   => Left(Two),\n+                    \"few\"   => Left(Few),\n+                    \"many\"  => Left(Many),\n+                    word    => {\n+                        self.err(fmt!(\"unexpected plural selector `%s`\", word));\n+                        if word == \"\" {\n+                            break\n+                        } else {\n+                            Left(Zero)\n+                        }\n+                    }\n+                }\n+            };\n+            if !self.wsconsume('{') {\n+                self.err(~\"selector must be followed by `{`\");\n+            }\n+            let pieces = self.collect();\n+            if !self.wsconsume('}') {\n+                self.err(~\"selector case must be terminated by `}`\");\n+            }\n+            if isother {\n+                if !other.is_none() {\n+                    self.err(~\"multiple `other` statements in `select\");\n+                }\n+                other = Some(pieces);\n+            } else {\n+                arms.push(PluralArm { selector: selector, result: pieces });\n+            }\n+            self.ws();\n+            match self.cur.clone().next() {\n+                Some((_, '}')) => { break }\n+                Some(*) | None => {}\n+            }\n+        }\n+\n+        let other = match other {\n+            Some(arm) => { arm }\n+            None => {\n+                self.err(~\"`plural` statement must provide an `other` case\");\n+                ~[]\n+            }\n+        };\n+        ~Plural(offset, arms, other)\n+    }\n+\n+    /// Parses a Count parameter at the current position. This does not check\n+    /// for 'CountIsNextParam' because that is only used in precision, not\n+    /// width.\n+    fn count(&mut self) -> Count {\n+        match self.integer() {\n+            Some(i) => {\n+                if self.consume('$') {\n+                    CountIsParam(i)\n+                } else {\n+                    CountIs(i)\n+                }\n+            }\n+            None => { CountImplied }\n+        }\n+    }\n+\n+    /// Parses a word starting at the current position. A word is considered to\n+    /// be an alphabetic character followed by any number of alphanumeric\n+    /// characters.\n+    fn word(&mut self) -> &'self str {\n+        let start = match self.cur.clone().next() {\n+            Some((pos, c)) if char::is_alphabetic(c) => {\n+                self.cur.next();\n+                pos\n+            }\n+            Some(*) | None => { return self.input.slice(0, 0); }\n+        };\n+        let mut end;\n+        loop {\n+            match self.cur.clone().next() {\n+                Some((_, c)) if char::is_alphanumeric(c) => {\n+                    self.cur.next();\n+                }\n+                Some((pos, _)) => { end = pos; break }\n+                None => { end = self.input.len(); break }\n+            }\n+        }\n+        self.input.slice(start, end)\n+    }\n+\n+    /// Optionally parses an integer at the current position. This doesn't deal\n+    /// with overflow at all, it's just accumulating digits.\n+    fn integer(&mut self) -> Option<uint> {\n+        let mut cur = 0;\n+        let mut found = false;\n+        loop {\n+            match self.cur.clone().next() {\n+                Some((_, c)) => {\n+                    match char::to_digit(c, 10) {\n+                        Some(i) => {\n+                            cur = cur * 10 + i;\n+                            found = true;\n+                            self.cur.next();\n+                        }\n+                        None => { break }\n+                    }\n+                }\n+                None => { break }\n+            }\n+        }\n+        if found {\n+            return Some(cur);\n+        } else {\n+            return None;\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::*;\n+    use realstd::fmt::{String};\n+\n+    fn same(fmt: &'static str, p: ~[Piece<'static>]) {\n+        let mut parser = Parser::new(fmt);\n+        assert_eq!(p, parser.collect());\n+    }\n+\n+    fn fmtdflt() -> FormatSpec<'static> {\n+        return FormatSpec {\n+            fill: None,\n+            align: None,\n+            flags: 0,\n+            precision: CountImplied,\n+            width: CountImplied,\n+            ty: \"\",\n+        }\n+    }\n+\n+    fn musterr(s: &str) {\n+        Parser::new(s).next();\n+    }\n+\n+    #[test]\n+    fn simple() {\n+        same(\"asdf\", ~[String(\"asdf\")]);\n+        same(\"a\\\\{b\", ~[String(\"a\"), String(\"{b\")]);\n+        same(\"a\\\\#b\", ~[String(\"a\"), String(\"#b\")]);\n+        same(\"a\\\\}b\", ~[String(\"a\"), String(\"}b\")]);\n+        same(\"a\\\\}\", ~[String(\"a\"), String(\"}\")]);\n+        same(\"\\\\}\", ~[String(\"}\")]);\n+    }\n+\n+    #[test] #[should_fail] fn invalid01() { musterr(\"{\") }\n+    #[test] #[should_fail] fn invalid02() { musterr(\"\\\\\") }\n+    #[test] #[should_fail] fn invalid03() { musterr(\"\\\\a\") }\n+    #[test] #[should_fail] fn invalid04() { musterr(\"{3a}\") }\n+    #[test] #[should_fail] fn invalid05() { musterr(\"{:|}\") }\n+    #[test] #[should_fail] fn invalid06() { musterr(\"{:>>>}\") }\n+\n+    #[test]\n+    fn format_nothing() {\n+        same(\"{}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_position() {\n+        same(\"{3}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: fmtdflt(),\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_position_nothing_else() {\n+        same(\"{3:}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: fmtdflt(),\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_type() {\n+        same(\"{3:a}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"a\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_align_fill() {\n+        same(\"{3:>}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: Some(AlignRight),\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{3:0<}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('0'),\n+                align: Some(AlignLeft),\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{3:*<abcd}\", ~[Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: Some('*'),\n+                align: Some(AlignLeft),\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"abcd\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_counts() {\n+        same(\"{:10s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountIs(10),\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:10$.10s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountIs(10),\n+                width: CountIsParam(10),\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:.*s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountIsNextParam,\n+                width: CountImplied,\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:.10$s}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountIsParam(10),\n+                width: CountImplied,\n+                ty: \"s\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_flags() {\n+        same(\"{:-}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: (1 << FlagSignMinus as uint),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+        same(\"{:+#}\", ~[Argument(Argument {\n+            position: ArgumentNext,\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"\",\n+            },\n+            method: None,\n+        })]);\n+    }\n+    #[test]\n+    fn format_mixture() {\n+        same(\"abcd {3:a} efg\", ~[String(\"abcd \"), Argument(Argument {\n+            position: ArgumentIs(3),\n+            format: FormatSpec {\n+                fill: None,\n+                align: None,\n+                flags: 0,\n+                precision: CountImplied,\n+                width: CountImplied,\n+                ty: \"a\",\n+            },\n+            method: None,\n+        }), String(\" efg\")]);\n+    }\n+\n+    #[test]\n+    fn select_simple() {\n+        same(\"{, select, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{1, select, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{1, select, other {#} }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[CurrentArgument]))\n+        })]);\n+        same(\"{1, select, other {{2, select, other {lol}}} }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[], ~[Argument(Argument{\n+                position: ArgumentIs(2),\n+                format: fmtdflt(),\n+                method: Some(~Select(~[], ~[String(\"lol\")]))\n+            })])) // wat\n+        })]);\n+    }\n+\n+    #[test]\n+    fn select_cases() {\n+        same(\"{1, select, a{1} b{2} c{3} other{4} }\", ~[Argument(Argument{\n+            position: ArgumentIs(1),\n+            format: fmtdflt(),\n+            method: Some(~Select(~[\n+                SelectArm{ selector: \"a\", result: ~[String(\"1\")] },\n+                SelectArm{ selector: \"b\", result: ~[String(\"2\")] },\n+                SelectArm{ selector: \"c\", result: ~[String(\"3\")] },\n+            ], ~[String(\"4\")]))\n+        })]);\n+    }\n+\n+    #[test] #[should_fail] fn badselect01() {\n+        musterr(\"{select, }\")\n+    }\n+    #[test] #[should_fail] fn badselect02() {\n+        musterr(\"{1, select}\")\n+    }\n+    #[test] #[should_fail] fn badselect03() {\n+        musterr(\"{1, select, }\")\n+    }\n+    #[test] #[should_fail] fn badselect04() {\n+        musterr(\"{1, select, a {}}\")\n+    }\n+    #[test] #[should_fail] fn badselect05() {\n+        musterr(\"{1, select, other }}\")\n+    }\n+    #[test] #[should_fail] fn badselect06() {\n+        musterr(\"{1, select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect07() {\n+        musterr(\"{select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect08() {\n+        musterr(\"{1 select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect09() {\n+        musterr(\"{:d select, other {}\")\n+    }\n+    #[test] #[should_fail] fn badselect10() {\n+        musterr(\"{1:d select, other {}\")\n+    }\n+\n+    #[test]\n+    fn plural_simple() {\n+        same(\"{, plural, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{:, plural, other { haha } }\", ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Plural(None, ~[], ~[String(\" haha \")]))\n+        })]);\n+        same(\"{, plural, offset:1 =2{2} =3{3} many{yes} other{haha} }\",\n+        ~[Argument(Argument{\n+            position: ArgumentNext,\n+            format: fmtdflt(),\n+            method: Some(~Plural(Some(1), ~[\n+                PluralArm{ selector: Right(2), result: ~[String(\"2\")] },\n+                PluralArm{ selector: Right(3), result: ~[String(\"3\")] },\n+                PluralArm{ selector: Left(Many), result: ~[String(\"yes\")] }\n+            ], ~[String(\"haha\")]))\n+        })]);\n+    }\n+}"}, {"sha": "6feb1d7a848038fb1ca1bc257e1b87ad3cf045f8", "filename": "src/libstd/fmt/rt.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This is an internal module used by the ifmt! runtime. These structures are\n+//! emitted to static arrays to precompile format strings ahead of time.\n+//!\n+//! These definitions are similar to their `ct` equivalents, but differ in that\n+//! these can be statically allocated and are slightly optimized for the runtime\n+\n+#[allow(missing_doc)];\n+#[doc(hidden)];\n+\n+use either::Either;\n+use fmt::parse;\n+use option::Option;\n+\n+pub enum Piece<'self> {\n+    String(&'self str),\n+    // FIXME(#8259): this shouldn't require the unit-value here\n+    CurrentArgument(()),\n+    Argument(Argument<'self>),\n+}\n+\n+pub struct Argument<'self> {\n+    position: Position,\n+    format: FormatSpec,\n+    method: Option<&'self Method<'self>>\n+}\n+\n+pub struct FormatSpec {\n+    fill: char,\n+    alignleft: bool,\n+    flags: uint,\n+    precision: parse::Count,\n+    width: parse::Count,\n+}\n+\n+pub enum Position {\n+    ArgumentNext, ArgumentIs(uint)\n+}\n+\n+pub enum Method<'self> {\n+    Plural(Option<uint>, &'self [PluralArm<'self>], &'self [Piece<'self>]),\n+    Select(&'self [SelectArm<'self>], &'self [Piece<'self>]),\n+}\n+\n+pub struct PluralArm<'self> {\n+    selector: Either<parse::PluralKeyword, uint>,\n+    result: &'self [Piece<'self>],\n+}\n+\n+pub struct SelectArm<'self> {\n+    selector: &'self str,\n+    result: &'self [Piece<'self>],\n+}"}, {"sha": "277897e5d2e27b80587309d16a7ef48475939560", "filename": "src/libstd/rt/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Frt%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmem.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -26,7 +26,7 @@ pub struct MemWriter {\n }\n \n impl MemWriter {\n-    pub fn new() -> MemWriter { MemWriter { buf: ~[] } }\n+    pub fn new() -> MemWriter { MemWriter { buf: vec::with_capacity(128) } }\n }\n \n impl Writer for MemWriter {"}, {"sha": "7000b56069df624333ba6bed60dde795a395a648", "filename": "src/libstd/std.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -177,6 +177,7 @@ pub mod rand;\n pub mod run;\n pub mod sys;\n pub mod cast;\n+pub mod fmt;\n pub mod repr;\n pub mod cleanup;\n pub mod reflect;\n@@ -216,4 +217,6 @@ mod std {\n     pub use unstable;\n     pub use str;\n     pub use os;\n+    pub use fmt;\n+    pub use to_bytes;\n }"}, {"sha": "99f74543e79782e3e907ab1073774e5515292e34", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -139,6 +139,8 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                                 ext::tt::macro_rules::add_new_extension));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n+    syntax_expanders.insert(intern(&\"ifmt\"),\n+                            builtin_normal_tt(ext::ifmt::expand_syntax_ext));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "a928680e093929f041c275f12dc8951e77801261", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -1014,7 +1014,9 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n         .. *afp};\n     let f = make_fold(f_pre);\n \n-    @f.fold_crate(c)\n+    let ret = @f.fold_crate(c);\n+    parse_sess.span_diagnostic.handler().abort_if_errors();\n+    return ret;\n }\n \n // given a function from idents to idents, produce"}, {"sha": "5cf5fdba632f4ae11e0d6ca12634af43383e286c", "filename": "src/libsyntax/ext/ifmt.rs", "status": "added", "additions": 720, "deletions": 0, "changes": 720, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,720 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ast;\n+use codemap::{span, respan};\n+use ext::base::*;\n+use ext::base;\n+use ext::build::AstBuilder;\n+use rsparse = parse;\n+use parse::token;\n+\n+use std::fmt::parse;\n+use std::hashmap::{HashMap, HashSet};\n+use std::vec;\n+\n+#[deriving(Eq)]\n+enum ArgumentType {\n+    Unknown,\n+    Known(@str),\n+    Unsigned,\n+    String,\n+}\n+\n+struct Context {\n+    ecx: @ExtCtxt,\n+    fmtsp: span,\n+\n+    // Parsed argument expressions and the types that we've found so far for\n+    // them.\n+    args: ~[@ast::expr],\n+    arg_types: ~[Option<ArgumentType>],\n+    // Parsed named expressions and the types that we've found for them so far\n+    names: HashMap<@str, @ast::expr>,\n+    name_types: HashMap<@str, ArgumentType>,\n+\n+    // Collection of the compiled `rt::Piece` structures\n+    pieces: ~[@ast::expr],\n+    name_positions: HashMap<@str, uint>,\n+    method_statics: ~[@ast::item],\n+\n+    // Updated as arguments are consumed or methods are entered\n+    nest_level: uint,\n+    next_arg: uint,\n+}\n+\n+impl Context {\n+    /// Parses the arguments from the given list of tokens, returning None if\n+    /// there's a parse error so we can continue parsing other fmt! expressions.\n+    fn parse_args(&mut self, sp: span,\n+                  tts: &[ast::token_tree]) -> Option<@ast::expr> {\n+        let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n+                                             self.ecx.cfg(),\n+                                             tts.to_owned());\n+        if *p.token == token::EOF {\n+            self.ecx.span_err(sp, \"ifmt! expects at least one argument\");\n+            return None;\n+        }\n+        let fmtstr = p.parse_expr();\n+        let mut named = false;\n+        while *p.token != token::EOF {\n+            if !p.eat(&token::COMMA) {\n+                self.ecx.span_err(sp, \"expected token: `,`\");\n+                return None;\n+            }\n+            if named || (token::is_ident(p.token) &&\n+                         p.look_ahead(1, |t| *t == token::EQ)) {\n+                named = true;\n+                let ident = match *p.token {\n+                    token::IDENT(i, _) => {\n+                        p.bump();\n+                        i\n+                    }\n+                    _ if named => {\n+                        self.ecx.span_err(*p.span,\n+                                          \"expected ident, positional arguments \\\n+                                           cannot follow named arguments\");\n+                        return None;\n+                    }\n+                    _ => {\n+                        self.ecx.span_err(*p.span,\n+                                          fmt!(\"expected ident for named \\\n+                                                argument, but found `%s`\",\n+                                               p.this_token_to_str()));\n+                        return None;\n+                    }\n+                };\n+                let name = self.ecx.str_of(ident);\n+                p.expect(&token::EQ);\n+                let e = p.parse_expr();\n+                match self.names.find(&name) {\n+                    None => {}\n+                    Some(prev) => {\n+                        self.ecx.span_err(e.span, fmt!(\"duplicate argument \\\n+                                                        named `%s`\", name));\n+                        self.ecx.parse_sess.span_diagnostic.span_note(\n+                            prev.span, \"previously here\");\n+                        loop\n+                    }\n+                }\n+                self.names.insert(name, e);\n+            } else {\n+                self.args.push(p.parse_expr());\n+                self.arg_types.push(None);\n+            }\n+        }\n+        return Some(fmtstr);\n+    }\n+\n+    /// Verifies one piece of a parse string. All errors are not emitted as\n+    /// fatal so we can continue giving errors about this and possibly other\n+    /// format strings.\n+    fn verify_piece(&mut self, p: &parse::Piece) {\n+        match *p {\n+            parse::String(*) => {}\n+            parse::CurrentArgument => {\n+                if self.nest_level == 0 {\n+                    self.ecx.span_err(self.fmtsp,\n+                                      \"`#` reference used with nothing to \\\n+                                       reference back to\");\n+                }\n+            }\n+            parse::Argument(ref arg) => {\n+                // argument first (it's first in the format string)\n+                let pos = match arg.position {\n+                    parse::ArgumentNext => {\n+                        let i = self.next_arg;\n+                        if self.check_positional_ok() {\n+                            self.next_arg += 1;\n+                        }\n+                        Left(i)\n+                    }\n+                    parse::ArgumentIs(i) => Left(i),\n+                    parse::ArgumentNamed(s) => Right(s.to_managed()),\n+                };\n+                let ty = if arg.format.ty == \"\" {\n+                    Unknown\n+                } else { Known(arg.format.ty.to_managed()) };\n+                self.verify_arg_type(pos, ty);\n+\n+                // width/precision next\n+                self.verify_count(arg.format.width);\n+                self.verify_count(arg.format.precision);\n+\n+                // and finally the method being applied\n+                match arg.method {\n+                    None => {}\n+                    Some(ref method) => { self.verify_method(pos, *method); }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn verify_pieces(&mut self, pieces: &[parse::Piece]) {\n+        for piece in pieces.iter() {\n+            self.verify_piece(piece);\n+        }\n+    }\n+\n+    fn verify_count(&mut self, c: parse::Count) {\n+        match c {\n+            parse::CountImplied | parse::CountIs(*) => {}\n+            parse::CountIsParam(i) => {\n+                self.verify_arg_type(Left(i), Unsigned);\n+            }\n+            parse::CountIsNextParam => {\n+                if self.check_positional_ok() {\n+                    self.verify_arg_type(Left(self.next_arg), Unsigned);\n+                    self.next_arg += 1;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_positional_ok(&mut self) -> bool {\n+        if self.nest_level != 0 {\n+            self.ecx.span_err(self.fmtsp, \"cannot use implicit positional \\\n+                                           arguments nested inside methods\");\n+            false\n+        } else {\n+            true\n+        }\n+    }\n+\n+    fn verify_method(&mut self, pos: Either<uint, @str>, m: &parse::Method) {\n+        self.nest_level += 1;\n+        match *m {\n+            parse::Plural(_, ref arms, ref default) => {\n+                let mut seen_cases = HashSet::new();\n+                self.verify_arg_type(pos, Unsigned);\n+                for arm in arms.iter() {\n+                    if !seen_cases.insert(arm.selector) {\n+                        match arm.selector {\n+                            Left(name) => {\n+                                self.ecx.span_err(self.fmtsp,\n+                                                  fmt!(\"duplicate selector \\\n+                                                       `%?`\", name));\n+                            }\n+                            Right(idx) => {\n+                                self.ecx.span_err(self.fmtsp,\n+                                                  fmt!(\"duplicate selector \\\n+                                                       `=%u`\", idx));\n+                            }\n+                        }\n+                    }\n+                    self.verify_pieces(arm.result);\n+                }\n+                self.verify_pieces(*default);\n+            }\n+            parse::Select(ref arms, ref default) => {\n+                self.verify_arg_type(pos, String);\n+                let mut seen_cases = HashSet::new();\n+                for arm in arms.iter() {\n+                    if !seen_cases.insert(arm.selector) {\n+                        self.ecx.span_err(self.fmtsp,\n+                                          fmt!(\"duplicate selector `%s`\",\n+                                               arm.selector));\n+                    } else if arm.selector == \"\" {\n+                        self.ecx.span_err(self.fmtsp,\n+                                          \"empty selector in `select`\");\n+                    }\n+                    self.verify_pieces(arm.result);\n+                }\n+                self.verify_pieces(*default);\n+            }\n+        }\n+        self.nest_level -= 1;\n+    }\n+\n+    fn verify_arg_type(&mut self, arg: Either<uint, @str>, ty: ArgumentType) {\n+        match arg {\n+            Left(arg) => {\n+                if arg < 0 || self.args.len() <= arg {\n+                    let msg = fmt!(\"invalid reference to argument `%u` (there \\\n+                                    are %u arguments)\", arg, self.args.len());\n+                    self.ecx.span_err(self.fmtsp, msg);\n+                    return;\n+                }\n+                self.verify_same(self.args[arg].span, ty, self.arg_types[arg]);\n+                if ty != Unknown || self.arg_types[arg].is_none() {\n+                    self.arg_types[arg] = Some(ty);\n+                }\n+            }\n+\n+            Right(name) => {\n+                let span = match self.names.find(&name) {\n+                    Some(e) => e.span,\n+                    None => {\n+                        let msg = fmt!(\"There is no argument named `%s`\", name);\n+                        self.ecx.span_err(self.fmtsp, msg);\n+                        return;\n+                    }\n+                };\n+                self.verify_same(span, ty,\n+                                 self.name_types.find(&name).map(|&x| *x));\n+                if ty != Unknown || !self.name_types.contains_key(&name) {\n+                    self.name_types.insert(name, ty);\n+                }\n+                // Assign this named argument a slot in the arguments array if\n+                // it hasn't already been assigned a slot.\n+                if !self.name_positions.contains_key(&name) {\n+                    let slot = self.name_positions.len();\n+                    self.name_positions.insert(name, slot);\n+                }\n+            }\n+        }\n+    }\n+\n+    /// When we're keeping track of the types that are declared for certain\n+    /// arguments, we assume that `None` means we haven't seen this argument\n+    /// yet, `Some(None)` means that we've seen the argument, but no format was\n+    /// specified, and `Some(Some(x))` means that the argument was declared to\n+    /// have type `x`.\n+    ///\n+    /// Obviously `Some(Some(x)) != Some(Some(y))`, but we consider it true\n+    /// that: `Some(None) == Some(Some(x))`\n+    fn verify_same(&self, sp: span, ty: ArgumentType,\n+                   before: Option<ArgumentType>) {\n+        if ty == Unknown { return }\n+        let cur = match before {\n+            Some(Unknown) | None => return,\n+            Some(t) => t,\n+        };\n+        if ty == cur { return }\n+        match (cur, ty) {\n+            (Known(cur), Known(ty)) => {\n+                self.ecx.span_err(sp,\n+                                  fmt!(\"argument redeclared with type `%s` when \\\n+                                        it was previously `%s`\", ty, cur));\n+            }\n+            (Known(cur), _) => {\n+                self.ecx.span_err(sp,\n+                                  fmt!(\"argument used to format with `%s` was \\\n+                                        attempted to not be used for formatting\",\n+                                        cur));\n+            }\n+            (_, Known(ty)) => {\n+                self.ecx.span_err(sp,\n+                                  fmt!(\"argument previously used as a format \\\n+                                        argument attempted to be used as `%s`\",\n+                                        ty));\n+            }\n+            (_, _) => {\n+                self.ecx.span_err(sp, \"argument declared with multiple formats\");\n+            }\n+        }\n+    }\n+\n+    /// Translate a `parse::Piece` to a static `rt::Piece`\n+    fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::expr {\n+        let sp = self.fmtsp;\n+        let rtpath = |s: &str| {\n+            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+              self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n+        };\n+        let ctpath = |s: &str| {\n+            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+              self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+        };\n+        let none = || {\n+            let p = self.ecx.path(sp, ~[self.ecx.ident_of(\"None\")]);\n+            self.ecx.expr_path(p)\n+        };\n+        let some = |e: @ast::expr| {\n+            self.ecx.expr_call_ident(sp, self.ecx.ident_of(\"Some\"), ~[e])\n+        };\n+        let trans_count = |c: parse::Count| {\n+            match c {\n+                parse::CountIs(i) => {\n+                    self.ecx.expr_call_global(sp, ctpath(\"CountIs\"),\n+                                              ~[self.ecx.expr_uint(sp, i)])\n+                }\n+                parse::CountIsParam(i) => {\n+                    self.ecx.expr_call_global(sp, ctpath(\"CountIsParam\"),\n+                                              ~[self.ecx.expr_uint(sp, i)])\n+                }\n+                parse::CountImplied => {\n+                    let path = self.ecx.path_global(sp, ctpath(\"CountImplied\"));\n+                    self.ecx.expr_path(path)\n+                }\n+                parse::CountIsNextParam => {\n+                    let path = self.ecx.path_global(sp, ctpath(\"CountIsNextParam\"));\n+                    self.ecx.expr_path(path)\n+                }\n+            }\n+        };\n+        let trans_method = |method: &parse::Method| {\n+            let method = match *method {\n+                parse::Select(ref arms, ref default) => {\n+                    let arms = arms.iter().transform(|arm| {\n+                        let p = self.ecx.path_global(sp, rtpath(\"SelectArm\"));\n+                        let result = arm.result.iter().transform(|p| {\n+                            self.trans_piece(p)\n+                        }).collect();\n+                        let s = arm.selector.to_managed();\n+                        let selector = self.ecx.expr_str(sp, s);\n+                        self.ecx.expr_struct(sp, p, ~[\n+                            self.ecx.field_imm(sp,\n+                                               self.ecx.ident_of(\"selector\"),\n+                                               selector),\n+                            self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n+                                               self.ecx.expr_vec_slice(sp, result)),\n+                        ])\n+                    }).collect();\n+                    let default = default.iter().transform(|p| {\n+                        self.trans_piece(p)\n+                    }).collect();\n+                    self.ecx.expr_call_global(sp, rtpath(\"Select\"), ~[\n+                        self.ecx.expr_vec_slice(sp, arms),\n+                        self.ecx.expr_vec_slice(sp, default),\n+                    ])\n+                }\n+                parse::Plural(offset, ref arms, ref default) => {\n+                    let offset = match offset {\n+                        Some(i) => { some(self.ecx.expr_uint(sp, i)) }\n+                        None => { none() }\n+                    };\n+                    let arms = arms.iter().transform(|arm| {\n+                        let p = self.ecx.path_global(sp, rtpath(\"PluralArm\"));\n+                        let result = arm.result.iter().transform(|p| {\n+                            self.trans_piece(p)\n+                        }).collect();\n+                        let (lr, selarg) = match arm.selector {\n+                            Left(t) => {\n+                                let p = ctpath(fmt!(\"%?\", t));\n+                                let p = self.ecx.path_global(sp, p);\n+                                (self.ecx.ident_of(\"Left\"),\n+                                 self.ecx.expr_path(p))\n+                            }\n+                            Right(i) => {\n+                                (self.ecx.ident_of(\"Right\"),\n+                                 self.ecx.expr_uint(sp, i))\n+                            }\n+                        };\n+                        let selector = self.ecx.expr_call_ident(sp,\n+                                lr, ~[selarg]);\n+                        self.ecx.expr_struct(sp, p, ~[\n+                            self.ecx.field_imm(sp,\n+                                               self.ecx.ident_of(\"selector\"),\n+                                               selector),\n+                            self.ecx.field_imm(sp, self.ecx.ident_of(\"result\"),\n+                                               self.ecx.expr_vec_slice(sp, result)),\n+                        ])\n+                    }).collect();\n+                    let default = default.iter().transform(|p| {\n+                        self.trans_piece(p)\n+                    }).collect();\n+                    self.ecx.expr_call_global(sp, rtpath(\"Plural\"), ~[\n+                        offset,\n+                        self.ecx.expr_vec_slice(sp, arms),\n+                        self.ecx.expr_vec_slice(sp, default),\n+                    ])\n+                }\n+            };\n+            let life = self.ecx.lifetime(sp, self.ecx.ident_of(\"static\"));\n+            let ty = self.ecx.ty_path(self.ecx.path_all(\n+                sp,\n+                true,\n+                rtpath(\"Method\"),\n+                Some(life),\n+                ~[]\n+            ), None);\n+            let st = ast::item_static(ty, ast::m_imm, method);\n+            let static_name = self.ecx.ident_of(fmt!(\"__static_method_%u\",\n+                                                     self.method_statics.len()));\n+            let item = self.ecx.item(sp, static_name, ~[], st);\n+            self.method_statics.push(item);\n+            self.ecx.expr_ident(sp, static_name)\n+        };\n+\n+        match *piece {\n+            parse::String(s) => {\n+                self.ecx.expr_call_global(sp, rtpath(\"String\"),\n+                                          ~[self.ecx.expr_str(sp, s.to_managed())])\n+            }\n+            parse::CurrentArgument => {\n+                let nil = self.ecx.expr_lit(sp, ast::lit_nil);\n+                self.ecx.expr_call_global(sp, rtpath(\"CurrentArgument\"), ~[nil])\n+            }\n+            parse::Argument(ref arg) => {\n+                // Translate the position\n+                let pos = match arg.position {\n+                    // These two have a direct mapping\n+                    parse::ArgumentNext => {\n+                        let path = self.ecx.path_global(sp,\n+                                                        rtpath(\"ArgumentNext\"));\n+                        self.ecx.expr_path(path)\n+                    }\n+                    parse::ArgumentIs(i) => {\n+                        self.ecx.expr_call_global(sp, rtpath(\"ArgumentIs\"),\n+                                                  ~[self.ecx.expr_uint(sp, i)])\n+                    }\n+                    // Named arguments are converted to positional arguments at\n+                    // the end of the list of arguments\n+                    parse::ArgumentNamed(n) => {\n+                        let n = n.to_managed();\n+                        let i = match self.name_positions.find_copy(&n) {\n+                            Some(i) => i,\n+                            None => 0, // error already emitted elsewhere\n+                        };\n+                        let i = i + self.args.len();\n+                        self.ecx.expr_call_global(sp, rtpath(\"ArgumentIs\"),\n+                                                  ~[self.ecx.expr_uint(sp, i)])\n+                    }\n+                };\n+\n+                // Translate the format\n+                let fill = match arg.format.fill { Some(c) => c, None => ' ' };\n+                let fill = self.ecx.expr_lit(sp, ast::lit_int(fill as i64,\n+                                                              ast::ty_char));\n+                let align = match arg.format.align {\n+                    None | Some(parse::AlignLeft) => {\n+                        self.ecx.expr_bool(sp, true)\n+                    }\n+                    Some(parse::AlignRight) => {\n+                        self.ecx.expr_bool(sp, false)\n+                    }\n+                };\n+                let flags = self.ecx.expr_uint(sp, arg.format.flags);\n+                let prec = trans_count(arg.format.precision);\n+                let width = trans_count(arg.format.width);\n+                let path = self.ecx.path_global(sp, rtpath(\"FormatSpec\"));\n+                let fmt = self.ecx.expr_struct(sp, path, ~[\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"alignleft\"), align),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),\n+                ]);\n+\n+                // Translate the method (if any)\n+                let method = match arg.method {\n+                    None => { none() }\n+                    Some(ref m) => {\n+                        let m = trans_method(*m);\n+                        some(self.ecx.expr_addr_of(sp, m))\n+                    }\n+                };\n+                let path = self.ecx.path_global(sp, rtpath(\"Argument\"));\n+                let s = self.ecx.expr_struct(sp, path, ~[\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"position\"), pos),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"format\"), fmt),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"method\"), method),\n+                ]);\n+                self.ecx.expr_call_global(sp, rtpath(\"Argument\"), ~[s])\n+            }\n+        }\n+    }\n+\n+    /// Actually builds the expression which the ifmt! block will be expanded\n+    /// to\n+    fn to_expr(&self) -> @ast::expr {\n+        let mut lets = ~[];\n+        let mut locals = ~[];\n+        let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n+\n+        // First, declare all of our methods that are statics\n+        for &method in self.method_statics.iter() {\n+            let decl = respan(self.fmtsp, ast::decl_item(method));\n+            lets.push(@respan(self.fmtsp,\n+                              ast::stmt_decl(@decl, self.ecx.next_id())));\n+        }\n+\n+        // Next, build up the static array which will become our precompiled\n+        // format \"string\"\n+        let fmt = self.ecx.expr_vec(self.fmtsp, self.pieces.clone());\n+        let ty = ast::ty_fixed_length_vec(\n+            self.ecx.ty_mt(\n+                self.ecx.ty_path(self.ecx.path_all(\n+                    self.fmtsp,\n+                    true, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"rt\"),\n+                        self.ecx.ident_of(\"Piece\"),\n+                    ],\n+                    Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n+                    ~[]\n+                ), None),\n+                ast::m_imm\n+            ),\n+            self.ecx.expr_uint(self.fmtsp, self.pieces.len())\n+        );\n+        let ty = self.ecx.ty(self.fmtsp, ty);\n+        let st = ast::item_static(ty, ast::m_imm, fmt);\n+        let static_name = self.ecx.ident_of(\"__static_fmtstr\");\n+        let item = self.ecx.item(self.fmtsp, static_name, ~[], st);\n+        let decl = respan(self.fmtsp, ast::decl_item(item));\n+        lets.push(@respan(self.fmtsp, ast::stmt_decl(@decl, self.ecx.next_id())));\n+\n+        // Right now there is a bug such that for the expression:\n+        //      foo(bar(&1))\n+        // the lifetime of `1` doesn't outlast the call to `bar`, so it's not\n+        // vald for the call to `foo`. To work around this all arguments to the\n+        // fmt! string are shoved into locals.\n+        for (i, &e) in self.args.iter().enumerate() {\n+            if self.arg_types[i].is_none() { loop } // error already generated\n+\n+            let name = self.ecx.ident_of(fmt!(\"__arg%u\", i));\n+            lets.push(self.ecx.stmt_let(e.span, false, name, e));\n+            locals.push(self.format_arg(e.span, Left(i), name));\n+        }\n+        for (&name, &e) in self.names.iter() {\n+            if !self.name_types.contains_key(&name) { loop }\n+\n+            let lname = self.ecx.ident_of(fmt!(\"__arg%s\", name));\n+            lets.push(self.ecx.stmt_let(e.span, false, lname, e));\n+            names[*self.name_positions.get(&name)] =\n+                Some(self.format_arg(e.span, Right(name), lname));\n+        }\n+\n+        let args = names.consume_iter().transform(|a| a.unwrap());\n+        let mut args = locals.consume_iter().chain_(args);\n+\n+        // Next, build up the actual call to the sprintf function.\n+        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(\"sprintf\"),\n+            ], ~[\n+                self.ecx.expr_ident(self.fmtsp, static_name),\n+                self.ecx.expr_vec(self.fmtsp, args.collect()),\n+            ]);\n+\n+        // sprintf is unsafe, but we just went through a lot of work to\n+        // validate that our call is save, so inject the unsafe block for the\n+        // user.\n+        let result = self.ecx.expr_block(ast::Block {\n+           view_items: ~[],\n+           stmts: ~[],\n+           expr: Some(result),\n+           id: self.ecx.next_id(),\n+           rules: ast::UnsafeBlock,\n+           span: self.fmtsp,\n+        });\n+\n+        self.ecx.expr_block(self.ecx.block(self.fmtsp, lets, Some(result)))\n+    }\n+\n+    fn format_arg(&self, sp: span, arg: Either<uint, @str>,\n+                  ident: ast::ident) -> @ast::expr {\n+        let mut ty = match arg {\n+            Left(i) => self.arg_types[i].unwrap(),\n+            Right(s) => *self.name_types.get(&s)\n+        };\n+        // Default types to '?' if nothing else is specified.\n+        if ty == Unknown {\n+            ty = Known(@\"?\");\n+        }\n+        let argptr = self.ecx.expr_addr_of(sp, self.ecx.expr_ident(sp, ident));\n+        match ty {\n+            Known(tyname) => {\n+                let fmt_trait = match tyname.as_slice() {\n+                    \"?\" => \"Poly\",\n+                    \"d\" | \"i\" => \"Signed\",\n+                    \"u\" => \"Unsigned\",\n+                    \"b\" => \"Bool\",\n+                    \"c\" => \"Char\",\n+                    \"o\" => \"Octal\",\n+                    \"x\" => \"LowerHex\",\n+                    \"X\" => \"UpperHex\",\n+                    \"s\" => \"String\",\n+                    \"p\" => \"Pointer\",\n+                    _ => {\n+                        self.ecx.span_err(sp, fmt!(\"unknown format trait \\\n+                                                    `%s`\", tyname));\n+                        \"Dummy\"\n+                    }\n+                };\n+                let format_fn = self.ecx.path_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(fmt_trait),\n+                        self.ecx.ident_of(\"fmt\"),\n+                    ]);\n+                self.ecx.expr_call_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"argument\"),\n+                    ], ~[self.ecx.expr_path(format_fn), argptr])\n+            }\n+            String => {\n+                self.ecx.expr_call_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"argumentstr\"),\n+                    ], ~[argptr])\n+            }\n+            Unsigned => {\n+                self.ecx.expr_call_global(sp, ~[\n+                        self.ecx.ident_of(\"std\"),\n+                        self.ecx.ident_of(\"fmt\"),\n+                        self.ecx.ident_of(\"argumentuint\"),\n+                    ], ~[argptr])\n+            }\n+            Unknown => { fail!() }\n+        }\n+    }\n+}\n+\n+pub fn expand_syntax_ext(ecx: @ExtCtxt, sp: span,\n+                         tts: &[ast::token_tree]) -> base::MacResult {\n+    let mut cx = Context {\n+        ecx: ecx,\n+        args: ~[],\n+        arg_types: ~[],\n+        names: HashMap::new(),\n+        name_positions: HashMap::new(),\n+        name_types: HashMap::new(),\n+        nest_level: 0,\n+        next_arg: 0,\n+        pieces: ~[],\n+        method_statics: ~[],\n+        fmtsp: sp,\n+    };\n+    let efmt = match cx.parse_args(sp, tts) {\n+        Some(e) => e,\n+        None => { return MRExpr(ecx.expr_uint(sp, 2)); }\n+    };\n+    cx.fmtsp = efmt.span;\n+    let fmt = expr_to_str(ecx, efmt,\n+                          ~\"first argument to ifmt! must be a string literal.\");\n+\n+    let mut err = false;\n+    do parse::parse_error::cond.trap(|m| {\n+        if !err {\n+            err = true;\n+            ecx.span_err(efmt.span, m);\n+        }\n+    }).inside {\n+        for piece in parse::Parser::new(fmt) {\n+            if !err {\n+                cx.verify_piece(&piece);\n+                let piece = cx.trans_piece(&piece);\n+                cx.pieces.push(piece);\n+            }\n+        }\n+    }\n+    if err { return MRExpr(efmt) }\n+\n+    // Make sure that all arguments were used and all arguments have types.\n+    for (i, ty) in cx.arg_types.iter().enumerate() {\n+        if ty.is_none() {\n+            ecx.span_err(cx.args[i].span, \"argument never used\");\n+        }\n+    }\n+    for (name, e) in cx.names.iter() {\n+        if !cx.name_types.contains_key(name) {\n+            ecx.span_err(e.span, \"named argument never used\");\n+        }\n+    }\n+\n+    MRExpr(cx.to_expr())\n+}"}, {"sha": "a5feb0483d894a24dbd75bcfa9b2a5c9818c6445", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -73,6 +73,7 @@ pub mod ext {\n \n     pub mod cfg;\n     pub mod fmt;\n+    pub mod ifmt;\n     pub mod env;\n     pub mod bytes;\n     pub mod concat_idents;"}, {"sha": "875ad0d2b62a5e8c31ce75a0e55acfa296e35199", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    // bad arguments to the ifmt! call\n+\n+    ifmt!();                //~ ERROR: expects at least one\n+    ifmt!(\"{}\");            //~ ERROR: invalid reference to argument\n+\n+    ifmt!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n+                            //~^ ERROR: argument never used\n+    ifmt!(\"{foo}\");         //~ ERROR: no argument named `foo`\n+\n+    ifmt!(\"{}\", 1, 2);               //~ ERROR: argument never used\n+    ifmt!(\"{1}\", 1, 2);              //~ ERROR: argument never used\n+    ifmt!(\"{}\", 1, foo=2);           //~ ERROR: named argument never used\n+    ifmt!(\"{foo}\", 1, foo=2);        //~ ERROR: argument never used\n+    ifmt!(\"\", foo=2);                //~ ERROR: named argument never used\n+\n+    ifmt!(\"{0:d} {0:s}\", 1);         //~ ERROR: redeclared with type `s`\n+    ifmt!(\"{foo:d} {foo:s}\", foo=1); //~ ERROR: redeclared with type `s`\n+\n+    ifmt!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n+    ifmt!(\"#\");                      //~ ERROR: `#` reference used\n+    ifmt!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n+    ifmt!(\"\" 1);                     //~ ERROR: expected token: `,`\n+    ifmt!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n+\n+    ifmt!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n+    ifmt!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n+    ifmt!(\"{0, plural, one{} one{} other{}}\", 1u); //~ ERROR: duplicate selector\n+\n+    // bad syntax of the format string\n+\n+    ifmt!(\"{\"); //~ ERROR: unterminated format string\n+    ifmt!(\"\\\\ \"); //~ ERROR: invalid escape\n+    ifmt!(\"\\\\\"); //~ ERROR: expected an escape\n+\n+    ifmt!(\"{0, }\", 1); //~ ERROR: expected method\n+    ifmt!(\"{0, foo}\", 1); //~ ERROR: unknown method\n+    ifmt!(\"{0, select}\", \"a\"); //~ ERROR: must be followed by\n+    ifmt!(\"{0, plural}\", 1); //~ ERROR: must be followed by\n+\n+    ifmt!(\"{0, select, a{{}\", 1); //~ ERROR: must be terminated\n+    ifmt!(\"{0, select, {} other{}}\", \"a\"); //~ ERROR: empty selector\n+    ifmt!(\"{0, select, other{} other{}}\", \"a\"); //~ ERROR: multiple `other`\n+    ifmt!(\"{0, plural, offset: other{}}\", \"a\"); //~ ERROR: must be an integer\n+    ifmt!(\"{0, plural, offset 1 other{}}\", \"a\"); //~ ERROR: be followed by `:`\n+    ifmt!(\"{0, plural, =a{} other{}}\", \"a\"); //~ ERROR: followed by an integer\n+    ifmt!(\"{0, plural, a{} other{}}\", \"a\"); //~ ERROR: unexpected plural\n+    ifmt!(\"{0, select, a{}}\", \"a\"); //~ ERROR: must provide an `other`\n+    ifmt!(\"{0, plural, =1{}}\", \"a\"); //~ ERROR: must provide an `other`\n+\n+    ifmt!(\"{0, plural, other{{0:s}}}\", \"a\"); //~ ERROR: previously used as\n+    ifmt!(\"{:s} {0, plural, other{}}\", \"a\"); //~ ERROR: argument used to\n+    ifmt!(\"{0, select, other{}} \\\n+           {0, plural, other{}}\", \"a\");\n+    //~^ ERROR: declared with multiple formats\n+\n+    // It should be illegal to use implicit placement arguments nested inside of\n+    // format strings because otherwise the \"internal pointer of which argument\n+    // is next\" would be invalidated if different cases had different numbers of\n+    // arguments.\n+    ifmt!(\"{0, select, other{{}}}\", \"a\"); //~ ERROR: cannot use implicit\n+    ifmt!(\"{0, plural, other{{}}}\", 1); //~ ERROR: cannot use implicit\n+    ifmt!(\"{0, plural, other{{1:.*d}}}\", 1, 2); //~ ERROR: cannot use implicit\n+}"}, {"sha": "76a697b174f5447b59cc00329e56e89729719553", "filename": "src/test/compile-fail/ifmt-bad-plural.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-plural.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{0, plural, other{}}\", \"a\");\n+    //~^ ERROR: expected uint but found\n+}"}, {"sha": "abe3b6ed65a6d577467d840fea14377df6610772", "filename": "src/test/compile-fail/ifmt-bad-select.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-select.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{0, select, other{}}\", 2);\n+    //~^ ERROR: expected &str but found integral\n+}"}, {"sha": "427f5ea562c7eb6c6c3389acaf3090e4dc2189e6", "filename": "src/test/compile-fail/ifmt-unimpl.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unimpl.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{:d}\", \"3\");\n+    //~^ ERROR: failed to find an implementation of trait std::fmt::Signed\n+}"}, {"sha": "85556f9501acb436715f0f19676ca96a3ba33006", "filename": "src/test/compile-fail/ifmt-unknown-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-unknown-trait.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    ifmt!(\"{:notimplemented}\", \"3\");\n+    //~^ ERROR: unknown format trait `notimplemented`\n+}"}, {"sha": "562642453fd27b48dbd20a4bb6b354aaa8516af5", "filename": "src/test/run-pass/ifmt.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb670ffcd69ed8e7cd13a7f06375ede752349e2/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=ffb670ffcd69ed8e7cd13a7f06375ede752349e2", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+\n+struct A;\n+struct B;\n+\n+#[fmt=\"foo\"]\n+impl fmt::Signed for A {\n+    fn fmt(_: &A, f: &mut fmt::Formatter) { f.buf.write(\"aloha\".as_bytes()); }\n+}\n+impl fmt::Signed for B {\n+    fn fmt(_: &B, f: &mut fmt::Formatter) { f.buf.write(\"adios\".as_bytes()); }\n+}\n+\n+pub fn main() {\n+    fn t(a: ~str, b: &str) { assert_eq!(a, b.to_owned()); }\n+\n+    // Make sure there's a poly formatter that takes anything\n+    t(ifmt!(\"{}\", 1), \"1\");\n+    t(ifmt!(\"{}\", A), \"{}\");\n+    t(ifmt!(\"{}\", ()), \"()\");\n+    t(ifmt!(\"{}\", @(~1, \"foo\")), \"@(~1, \\\"foo\\\")\");\n+\n+    // Various edge cases without formats\n+    t(ifmt!(\"\"), \"\");\n+    t(ifmt!(\"hello\"), \"hello\");\n+    t(ifmt!(\"hello \\\\{\"), \"hello {\");\n+\n+    // At least exercise all the formats\n+    t(ifmt!(\"{:b}\", true), \"true\");\n+    t(ifmt!(\"{:c}\", '\u2603'), \"\u2603\");\n+    t(ifmt!(\"{:d}\", 10), \"10\");\n+    t(ifmt!(\"{:i}\", 10), \"10\");\n+    t(ifmt!(\"{:u}\", 10u), \"10\");\n+    t(ifmt!(\"{:o}\", 10u), \"12\");\n+    t(ifmt!(\"{:x}\", 10u), \"a\");\n+    t(ifmt!(\"{:X}\", 10u), \"A\");\n+    t(ifmt!(\"{:s}\", \"foo\"), \"foo\");\n+    t(ifmt!(\"{:p}\", 0x1234 as *int), \"0x1234\");\n+    t(ifmt!(\"{:p}\", 0x1234 as *mut int), \"0x1234\");\n+    t(ifmt!(\"{:d}\", A), \"aloha\");\n+    t(ifmt!(\"{:d}\", B), \"adios\");\n+    t(ifmt!(\"foo {:s} \u2603\u2603\u2603\u2603\u2603\u2603\", \"bar\"), \"foo bar \u2603\u2603\u2603\u2603\u2603\u2603\");\n+    t(ifmt!(\"{1} {0}\", 0, 1), \"1 0\");\n+    t(ifmt!(\"{foo} {bar}\", foo=0, bar=1), \"0 1\");\n+    t(ifmt!(\"{foo} {1} {bar} {0}\", 0, 1, foo=2, bar=3), \"2 1 3 0\");\n+    t(ifmt!(\"{} {0:s}\", \"a\"), \"a a\");\n+    t(ifmt!(\"{} {0}\", \"a\"), \"\\\"a\\\" \\\"a\\\"\");\n+\n+    // Methods should probably work\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 0u), \"c0\");\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 1u), \"a1\");\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 2u), \"b2\");\n+    t(ifmt!(\"{0, plural, =1{a#} =2{b#} zero{c#} other{d#}}\", 3u), \"d3\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"a\"), \"aa\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"b\"), \"bb\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"c\"), \"cc\");\n+    t(ifmt!(\"{0, select, a{a#} b{b#} c{c#} other{d#}}\", \"d\"), \"dd\");\n+    t(ifmt!(\"{1, select, a{#{0:s}} other{#{1}}}\", \"b\", \"a\"), \"ab\");\n+    t(ifmt!(\"{1, select, a{#{0}} other{#{1}}}\", \"c\", \"b\"), \"bb\");\n+}\n+"}]}