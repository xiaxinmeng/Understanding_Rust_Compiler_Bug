{"sha": "468c86e4a3fa31b8c670422ea63875428e899b7f", "node_id": "C_kwDOAAsO6NoAKDQ2OGM4NmU0YTNmYTMxYjhjNjcwNDIyZWE2Mzg3NTQyOGU4OTliN2Y", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-11-16T00:25:08Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2021-12-13T11:31:17Z"}, "message": "Add `unnecessary_to_owned` lint", "tree": {"sha": "1004de8dfa16ceeff154d01baf00889be0bb95cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1004de8dfa16ceeff154d01baf00889be0bb95cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/468c86e4a3fa31b8c670422ea63875428e899b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/468c86e4a3fa31b8c670422ea63875428e899b7f", "html_url": "https://github.com/rust-lang/rust/commit/468c86e4a3fa31b8c670422ea63875428e899b7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/468c86e4a3fa31b8c670422ea63875428e899b7f/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa3648af504389ece9c5e09b848b450edad3ac38", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3648af504389ece9c5e09b848b450edad3ac38", "html_url": "https://github.com/rust-lang/rust/commit/aa3648af504389ece9c5e09b848b450edad3ac38"}], "stats": {"total": 1089, "additions": 1087, "deletions": 2}, "files": [{"sha": "7b5279cda6ea396f48cf49df821ee9b48ab31075", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -3210,6 +3210,7 @@ Released 2018-09-13\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n+[`unnecessary_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_to_owned\n [`unnecessary_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_unwrap\n [`unnecessary_wraps`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_wraps\n [`unneeded_field_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#unneeded_field_pattern"}, {"sha": "3d3999d4cc0d8a99bbc0bd7b408a74834402da8d", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -181,6 +181,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),\n     LintId::of(methods::UNNECESSARY_FOLD),\n     LintId::of(methods::UNNECESSARY_LAZY_EVALUATIONS),\n+    LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(methods::UNWRAP_OR_ELSE_DEFAULT),\n     LintId::of(methods::USELESS_ASREF),\n     LintId::of(methods::WRONG_SELF_CONVENTION),"}, {"sha": "766c5ba1bcb0f73e3837ad856f266257b433ebea", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -315,6 +315,7 @@ store.register_lints(&[\n     methods::UNNECESSARY_FILTER_MAP,\n     methods::UNNECESSARY_FOLD,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n+    methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,\n     methods::UNWRAP_USED,\n     methods::USELESS_ASREF,"}, {"sha": "2ea0b696f1feb3ad437c61d8c9c1072de7da606f", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -17,6 +17,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::MANUAL_STR_REPEAT),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),\n+    LintId::of(methods::UNNECESSARY_TO_OWNED),\n     LintId::of(misc::CMP_OWNED),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),"}, {"sha": "a0de296fd07a6c624594cdfe012d393402d85005", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -57,6 +57,7 @@ mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n mod unnecessary_lazy_eval;\n+mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n mod unwrap_used;\n mod useless_asref;\n@@ -1885,6 +1886,32 @@ declare_clippy_lint! {\n     \"usages of `str::splitn` that can be replaced with `str::split`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for unnecessary calls to [`ToOwned::to_owned`](https://doc.rust-lang.org/std/borrow/trait.ToOwned.html#tymethod.to_owned)\n+    /// and other `to_owned`-like functions.\n+    ///\n+    /// ### Why is this bad?\n+    /// The unnecessary calls result in unnecessary allocations.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let path = std::path::Path::new(\"x\");\n+    /// foo(&path.to_string_lossy().to_string());\n+    /// fn foo(s: &str) {}\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let path = std::path::Path::new(\"x\");\n+    /// foo(&path.to_string_lossy());\n+    /// fn foo(s: &str) {}\n+    /// ```\n+    #[clippy::version = \"1.58.0\"]\n+    pub UNNECESSARY_TO_OWNED,\n+    perf,\n+    \"unnecessary calls to `to_owned`-like functions\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -1964,7 +1991,8 @@ impl_lint_pass!(Methods => [\n     MANUAL_STR_REPEAT,\n     EXTEND_WITH_DRAIN,\n     MANUAL_SPLIT_ONCE,\n-    NEEDLESS_SPLITN\n+    NEEDLESS_SPLITN,\n+    UNNECESSARY_TO_OWNED\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2007,6 +2035,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 single_char_add_str::check(cx, expr, args);\n                 into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args);\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {"}, {"sha": "307de7bb65a48c715c97e89f5f2a4f64b04f8630", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -0,0 +1,328 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_opt;\n+use clippy_utils::ty::{implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::{get_parent_expr, match_def_path, paths};\n+use rustc_errors::Applicability;\n+use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n+use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_span::{sym, Symbol};\n+use std::cmp::max;\n+\n+use super::UNNECESSARY_TO_OWNED;\n+\n+const TO_OWNED_LIKE_PATHS: &[&[&str]] = &[\n+    &paths::COW_INTO_OWNED,\n+    &paths::OS_STR_TO_OS_STRING,\n+    &paths::PATH_TO_PATH_BUF,\n+    &paths::SLICE_TO_VEC,\n+    &paths::TO_OWNED_METHOD,\n+    &paths::TO_STRING_METHOD,\n+];\n+\n+pub fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n+    if_chain! {\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if TO_OWNED_LIKE_PATHS\n+            .iter()\n+            .any(|path| match_def_path(cx, method_def_id, path));\n+        if let [receiver] = args;\n+        then {\n+            // At this point, we know the call is of a `to_owned`-like function. The functions\n+            // `check_addr_of_expr` and `check_call_arg` determine whether the call is unnecessary\n+            // based on its context, that is, whether it is a referent in an `AddrOf` expression or\n+            // an argument in a function call.\n+            if check_addr_of_expr(cx, expr, method_name, receiver) {\n+                return;\n+            }\n+            check_call_arg(cx, expr, method_name, receiver);\n+        }\n+    }\n+}\n+\n+/// Checks whether `expr` is a referent in an `AddrOf` expression and, if so, determines whether its\n+/// call of a `to_owned`-like function is unnecessary.\n+fn check_addr_of_expr(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    receiver: &'tcx Expr<'tcx>,\n+) -> bool {\n+    if_chain! {\n+        if let Some(parent) = get_parent_expr(cx, expr);\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) = parent.kind;\n+        let adjustments = cx.typeck_results().expr_adjustments(parent).iter().collect::<Vec<_>>();\n+        if let Some(target_ty) = match adjustments[..]\n+        {\n+            // For matching uses of `Cow::from`\n+            [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    target: target_ty,\n+                },\n+            ]\n+            // For matching uses of arrays\n+            | [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Pointer(_),\n+                    target: target_ty,\n+                },\n+            ]\n+            // For matching everything else\n+            | [\n+                Adjustment {\n+                    kind: Adjust::Deref(None),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Deref(Some(OverloadedDeref { .. })),\n+                    ..\n+                },\n+                Adjustment {\n+                    kind: Adjust::Borrow(_),\n+                    target: target_ty,\n+                },\n+            ] => Some(target_ty),\n+            _ => None,\n+        };\n+        then {\n+            let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n+            let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+            let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n+            if_chain! {\n+                if receiver_ty == target_ty;\n+                if n_target_refs >= n_receiver_refs;\n+                if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+                then {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNNECESSARY_TO_OWNED,\n+                        parent.span,\n+                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        \"use\",\n+                        format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_target_refs - n_receiver_refs),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    return true;\n+                }\n+            }\n+            if implements_deref_trait(cx, receiver_ty, target_ty) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    UNNECESSARY_TO_OWNED,\n+                    expr.span.with_lo(receiver.span.hi()),\n+                    &format!(\"unnecessary use of `{}`\", method_name),\n+                    \"remove this\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                return true;\n+            }\n+            if_chain! {\n+                if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+                if implements_trait(cx, receiver_ty, as_ref_trait_id, &[GenericArg::from(target_ty)]);\n+                if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+                then {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        UNNECESSARY_TO_OWNED,\n+                        parent.span,\n+                        &format!(\"unnecessary use of `{}`\", method_name),\n+                        \"use\",\n+                        format!(\"{}.as_ref()\", receiver_snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                    return true;\n+                }\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+/// Checks whether `expr` is an argument in a function call and, if so, determines whether its call\n+/// of a `to_owned`-like function is unnecessary.\n+fn check_call_arg(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, receiver: &'tcx Expr<'tcx>) {\n+    if_chain! {\n+        if let Some((maybe_call, maybe_arg)) = skip_addr_of_ancestors(cx, expr);\n+        if let Some((callee_def_id, call_substs, call_args)) = get_callee_substs_and_args(cx, maybe_call);\n+        let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n+        if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n+        if let Some(input) = fn_sig.inputs().get(i);\n+        let (input, n_refs) = peel_mid_ty_refs(input);\n+        if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n+        if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n+        if let [trait_predicate] = trait_predicates\n+            .iter()\n+            .filter(|trait_predicate| trait_predicate.def_id() != sized_def_id)\n+            .collect::<Vec<_>>()[..];\n+        if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+        if let Some(as_ref_trait_id) = cx.tcx.get_diagnostic_item(sym::AsRef);\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        // If the callee has type parameters, they could appear in `projection_predicate.ty` or the\n+        // types of `trait_predicate.trait_ref.substs`.\n+        if if trait_predicate.def_id() == deref_trait_id {\n+            if let [projection_predicate] = projection_predicates[..] {\n+                let normalized_ty =\n+                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.ty);\n+                implements_deref_trait(cx, receiver_ty, normalized_ty)\n+            } else {\n+                false\n+            }\n+        } else if trait_predicate.def_id() == as_ref_trait_id {\n+            let composed_substs = compose_substs(\n+                cx,\n+                &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n+                call_substs\n+            );\n+            implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n+        } else {\n+            false\n+        };\n+        // We can't add an `&` when the trait is `Deref` because `Target = &T` won't match\n+        // `Target = T`.\n+        if n_refs > 0 || is_copy(cx, receiver_ty) || trait_predicate.def_id() != deref_trait_id;\n+        let n_refs = max(n_refs, if is_copy(cx, receiver_ty) { 0 } else { 1 });\n+        if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_TO_OWNED,\n+                maybe_arg.span,\n+                &format!(\"unnecessary use of `{}`\", method_name),\n+                \"use\",\n+                format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_refs),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+/// Walks an expression's ancestors until it finds a non-`AddrOf` expression. Returns the first such\n+/// expression found (if any) along with the immediately prior expression.\n+fn skip_addr_of_ancestors(\n+    cx: &LateContext<'tcx>,\n+    mut expr: &'tcx Expr<'tcx>,\n+) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    while let Some(parent) = get_parent_expr(cx, expr) {\n+        if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, _) = parent.kind {\n+            expr = parent;\n+        } else {\n+            return Some((parent, expr));\n+        }\n+    }\n+    None\n+}\n+\n+/// Checks whether an expression is a function or method call and, if so, returns its `DefId`,\n+/// `Substs`, and arguments.\n+fn get_callee_substs_and_args(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+) -> Option<(DefId, SubstsRef<'tcx>, &'tcx [Expr<'tcx>])> {\n+    if_chain! {\n+        if let ExprKind::Call(callee, args) = expr.kind;\n+        let callee_ty = cx.typeck_results().expr_ty(callee);\n+        if let ty::FnDef(callee_def_id, _) = callee_ty.kind();\n+        then {\n+            let substs = cx.typeck_results().node_substs(callee.hir_id);\n+            return Some((*callee_def_id, substs, args));\n+        }\n+    }\n+    if_chain! {\n+        if let ExprKind::MethodCall(_, _, args, _) = expr.kind;\n+        if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        then {\n+            let substs = cx.typeck_results().node_substs(expr.hir_id);\n+            return Some((method_def_id, substs, args));\n+        }\n+    }\n+    None\n+}\n+\n+/// Returns the `TraitPredicate`s and `ProjectionPredicate`s for a function's input type.\n+fn get_input_traits_and_projections(\n+    cx: &LateContext<'tcx>,\n+    callee_def_id: DefId,\n+    input: Ty<'tcx>,\n+) -> (Vec<TraitPredicate<'tcx>>, Vec<ProjectionPredicate<'tcx>>) {\n+    let mut trait_predicates = Vec::new();\n+    let mut projection_predicates = Vec::new();\n+    for (predicate, _) in cx.tcx.predicates_of(callee_def_id).predicates.iter() {\n+        // `substs` should have 1 + n elements. The first is the type on the left hand side of an\n+        // `as`. The remaining n are trait parameters.\n+        let is_input_substs = |substs: SubstsRef<'tcx>| {\n+            if_chain! {\n+                if let Some(arg) = substs.iter().next();\n+                if let GenericArgKind::Type(arg_ty) = arg.unpack();\n+                if arg_ty == input;\n+                then {\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        };\n+        match predicate.kind().skip_binder() {\n+            PredicateKind::Trait(trait_predicate) => {\n+                if is_input_substs(trait_predicate.trait_ref.substs) {\n+                    trait_predicates.push(trait_predicate);\n+                }\n+            },\n+            PredicateKind::Projection(projection_predicate) => {\n+                if is_input_substs(projection_predicate.projection_ty.substs) {\n+                    projection_predicates.push(projection_predicate);\n+                }\n+            },\n+            _ => {},\n+        }\n+    }\n+    (trait_predicates, projection_predicates)\n+}\n+\n+/// Composes two substitutions by applying the latter to the types of the former.\n+fn compose_substs(cx: &LateContext<'tcx>, left: &[GenericArg<'tcx>], right: SubstsRef<'tcx>) -> Vec<GenericArg<'tcx>> {\n+    left.iter()\n+        .map(|arg| {\n+            if let GenericArgKind::Type(arg_ty) = arg.unpack() {\n+                let normalized_ty = cx.tcx.subst_and_normalize_erasing_regions(right, cx.param_env, arg_ty);\n+                GenericArg::from(normalized_ty)\n+            } else {\n+                *arg\n+            }\n+        })\n+        .collect()\n+}\n+\n+/// Helper function to check whether a type implements the `Deref` trait.\n+fn implements_deref_trait(cx: &LateContext<'tcx>, ty: Ty<'tcx>, deref_target_ty: Ty<'tcx>) -> bool {\n+    if_chain! {\n+        if let Some(deref_trait_id) = cx.tcx.get_diagnostic_item(sym::Deref);\n+        if implements_trait(cx, ty, deref_trait_id, &[]);\n+        if let Some(deref_target_id) = cx.tcx.lang_items().deref_target();\n+        let substs = cx.tcx.mk_substs_trait(ty, &[]);\n+        let projection_ty = cx.tcx.mk_projection(deref_target_id, substs);\n+        let normalized_ty = cx.tcx.normalize_erasing_regions(cx.param_env, projection_ty);\n+        if normalized_ty == deref_target_ty;\n+        then {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "fe35ff33d35a4736f49f8a3b656e75b3f82b787d", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -169,7 +169,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitReturnExpectingOrd {\n                                     trait_name\n                                 ),\n                                 Some(last_semi),\n-                                &\"probably caused by this trailing semicolon\".to_string(),\n+                                \"probably caused by this trailing semicolon\",\n                             );\n                         },\n                         None => {},"}, {"sha": "634a452d6f1849bf900087c7beac089850fa050d", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -36,6 +36,7 @@ pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const CMP_MAX: [&str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n+pub const COW_INTO_OWNED: [&str; 4] = [\"alloc\", \"borrow\", \"Cow\", \"into_owned\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n@@ -170,6 +171,7 @@ pub const SLICE_FROM_RAW_PARTS: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_p\n pub const SLICE_FROM_RAW_PARTS_MUT: [&str; 4] = [\"core\", \"slice\", \"raw\", \"from_raw_parts_mut\"];\n pub const SLICE_INTO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const SLICE_ITER: [&str; 4] = [\"core\", \"slice\", \"iter\", \"Iter\"];\n+pub const SLICE_TO_VEC: [&str; 4] = [\"alloc\", \"slice\", \"<impl [T]>\", \"to_vec\"];\n pub const STDERR: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stderr\"];\n pub const STDOUT: [&str; 4] = [\"std\", \"io\", \"stdio\", \"stdout\"];\n pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];"}, {"sha": "f1a5dc91a7e575822cc4dfbd0a25dc342c00cee6", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -0,0 +1,170 @@\n+// run-rustfix\n+\n+#![allow(clippy::ptr_arg)]\n+// Some of the expressions that `redundant_clone` flags overlap with ours. Enabling it interferes\n+// with `rustfix`.\n+#![allow(clippy::redundant_clone)]\n+// `needless_borrow` is for checking the fixed code.\n+#![warn(clippy::needless_borrow)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+use std::borrow::Cow;\n+use std::ffi::{CStr, OsStr};\n+use std::ops::Deref;\n+\n+#[derive(Clone)]\n+struct X(String);\n+\n+impl Deref for X {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_bytes()\n+    }\n+}\n+\n+impl AsRef<str> for X {\n+    fn as_ref(&self) -> &str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl ToString for X {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n+    }\n+}\n+\n+impl X {\n+    fn join(&self, other: impl AsRef<str>) -> Self {\n+        let mut s = self.0.clone();\n+        s.push_str(other.as_ref());\n+        Self(s)\n+    }\n+}\n+\n+fn main() {\n+    let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n+    let os_str = OsStr::new(\"x\");\n+    let path = std::path::Path::new(\"x\");\n+    let s = \"x\";\n+    let array = [\"x\"];\n+    let array_ref = &[\"x\"];\n+    let slice = &[\"x\"][..];\n+    let x = X(String::from(\"x\"));\n+\n+    require_c_str(&Cow::from(c_str));\n+    require_c_str(c_str);\n+\n+    require_os_str(os_str);\n+    require_os_str(&Cow::from(os_str));\n+    require_os_str(os_str);\n+\n+    require_path(path);\n+    require_path(&Cow::from(path));\n+    require_path(path);\n+\n+    require_str(s);\n+    require_str(&Cow::from(s));\n+    require_str(s);\n+    require_str(x.as_ref());\n+\n+    require_slice(slice);\n+    require_slice(&Cow::from(slice));\n+    require_slice(array.as_ref());\n+    require_slice(array_ref.as_ref());\n+    require_slice(slice);\n+    require_slice(&x);\n+\n+    require_x(&Cow::<X>::Owned(x.clone()));\n+    require_x(&x);\n+\n+    require_deref_c_str(c_str);\n+    require_deref_os_str(os_str);\n+    require_deref_path(path);\n+    require_deref_str(s);\n+    require_deref_slice(slice);\n+\n+    require_impl_deref_c_str(c_str);\n+    require_impl_deref_os_str(os_str);\n+    require_impl_deref_path(path);\n+    require_impl_deref_str(s);\n+    require_impl_deref_slice(slice);\n+\n+    require_deref_str_slice(s, slice);\n+    require_deref_slice_str(slice, s);\n+\n+    require_as_ref_c_str(c_str);\n+    require_as_ref_os_str(os_str);\n+    require_as_ref_path(path);\n+    require_as_ref_str(s);\n+    require_as_ref_str(&x);\n+    require_as_ref_slice(array);\n+    require_as_ref_slice(array_ref);\n+    require_as_ref_slice(slice);\n+\n+    require_impl_as_ref_c_str(c_str);\n+    require_impl_as_ref_os_str(os_str);\n+    require_impl_as_ref_path(path);\n+    require_impl_as_ref_str(s);\n+    require_impl_as_ref_str(&x);\n+    require_impl_as_ref_slice(array);\n+    require_impl_as_ref_slice(array_ref);\n+    require_impl_as_ref_slice(slice);\n+\n+    require_as_ref_str_slice(s, array);\n+    require_as_ref_str_slice(s, array_ref);\n+    require_as_ref_str_slice(s, slice);\n+    require_as_ref_slice_str(array, s);\n+    require_as_ref_slice_str(array_ref, s);\n+    require_as_ref_slice_str(slice, s);\n+\n+    let _ = x.join(&x);\n+\n+    // negative tests\n+    require_string(&s.to_string());\n+    require_string(&Cow::from(s).into_owned());\n+    require_string(&s.to_owned());\n+    require_string(&x.to_string());\n+\n+    // `X` isn't copy.\n+    require_deref_slice(x.to_owned());\n+}\n+\n+fn require_c_str(_: &CStr) {}\n+fn require_os_str(_: &OsStr) {}\n+fn require_path(_: &std::path::Path) {}\n+fn require_str(_: &str) {}\n+fn require_slice<T>(_: &[T]) {}\n+fn require_x(_: &X) {}\n+\n+fn require_deref_c_str<T: Deref<Target = CStr>>(_: T) {}\n+fn require_deref_os_str<T: Deref<Target = OsStr>>(_: T) {}\n+fn require_deref_path<T: Deref<Target = std::path::Path>>(_: T) {}\n+fn require_deref_str<T: Deref<Target = str>>(_: T) {}\n+fn require_deref_slice<T, U: Deref<Target = [T]>>(_: U) {}\n+\n+fn require_impl_deref_c_str(_: impl Deref<Target = CStr>) {}\n+fn require_impl_deref_os_str(_: impl Deref<Target = OsStr>) {}\n+fn require_impl_deref_path(_: impl Deref<Target = std::path::Path>) {}\n+fn require_impl_deref_str(_: impl Deref<Target = str>) {}\n+fn require_impl_deref_slice<T>(_: impl Deref<Target = [T]>) {}\n+\n+fn require_deref_str_slice<T: Deref<Target = str>, U, V: Deref<Target = [U]>>(_: T, _: V) {}\n+fn require_deref_slice_str<T, U: Deref<Target = [T]>, V: Deref<Target = str>>(_: U, _: V) {}\n+\n+fn require_as_ref_c_str<T: AsRef<CStr>>(_: T) {}\n+fn require_as_ref_os_str<T: AsRef<OsStr>>(_: T) {}\n+fn require_as_ref_path<T: AsRef<std::path::Path>>(_: T) {}\n+fn require_as_ref_str<T: AsRef<str>>(_: T) {}\n+fn require_as_ref_slice<T, U: AsRef<[T]>>(_: U) {}\n+\n+fn require_impl_as_ref_c_str(_: impl AsRef<CStr>) {}\n+fn require_impl_as_ref_os_str(_: impl AsRef<OsStr>) {}\n+fn require_impl_as_ref_path(_: impl AsRef<std::path::Path>) {}\n+fn require_impl_as_ref_str(_: impl AsRef<str>) {}\n+fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n+\n+fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n+fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n+\n+fn require_string(_: &String) {}"}, {"sha": "081ff635bbdb00d21319c9ba419e7415361d2f8f", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -0,0 +1,170 @@\n+// run-rustfix\n+\n+#![allow(clippy::ptr_arg)]\n+// Some of the expressions that `redundant_clone` flags overlap with ours. Enabling it interferes\n+// with `rustfix`.\n+#![allow(clippy::redundant_clone)]\n+// `needless_borrow` is for checking the fixed code.\n+#![warn(clippy::needless_borrow)]\n+#![warn(clippy::unnecessary_to_owned)]\n+\n+use std::borrow::Cow;\n+use std::ffi::{CStr, OsStr};\n+use std::ops::Deref;\n+\n+#[derive(Clone)]\n+struct X(String);\n+\n+impl Deref for X {\n+    type Target = [u8];\n+    fn deref(&self) -> &[u8] {\n+        self.0.as_bytes()\n+    }\n+}\n+\n+impl AsRef<str> for X {\n+    fn as_ref(&self) -> &str {\n+        self.0.as_str()\n+    }\n+}\n+\n+impl ToString for X {\n+    fn to_string(&self) -> String {\n+        self.0.to_string()\n+    }\n+}\n+\n+impl X {\n+    fn join(&self, other: impl AsRef<str>) -> Self {\n+        let mut s = self.0.clone();\n+        s.push_str(other.as_ref());\n+        Self(s)\n+    }\n+}\n+\n+fn main() {\n+    let c_str = CStr::from_bytes_with_nul(&[0]).unwrap();\n+    let os_str = OsStr::new(\"x\");\n+    let path = std::path::Path::new(\"x\");\n+    let s = \"x\";\n+    let array = [\"x\"];\n+    let array_ref = &[\"x\"];\n+    let slice = &[\"x\"][..];\n+    let x = X(String::from(\"x\"));\n+\n+    require_c_str(&Cow::from(c_str).into_owned());\n+    require_c_str(&c_str.to_owned());\n+\n+    require_os_str(&os_str.to_os_string());\n+    require_os_str(&Cow::from(os_str).into_owned());\n+    require_os_str(&os_str.to_owned());\n+\n+    require_path(&path.to_path_buf());\n+    require_path(&Cow::from(path).into_owned());\n+    require_path(&path.to_owned());\n+\n+    require_str(&s.to_string());\n+    require_str(&Cow::from(s).into_owned());\n+    require_str(&s.to_owned());\n+    require_str(&x.to_string());\n+\n+    require_slice(&slice.to_vec());\n+    require_slice(&Cow::from(slice).into_owned());\n+    require_slice(&array.to_owned());\n+    require_slice(&array_ref.to_owned());\n+    require_slice(&slice.to_owned());\n+    require_slice(&x.to_owned());\n+\n+    require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n+    require_x(&x.to_owned());\n+\n+    require_deref_c_str(c_str.to_owned());\n+    require_deref_os_str(os_str.to_owned());\n+    require_deref_path(path.to_owned());\n+    require_deref_str(s.to_owned());\n+    require_deref_slice(slice.to_owned());\n+\n+    require_impl_deref_c_str(c_str.to_owned());\n+    require_impl_deref_os_str(os_str.to_owned());\n+    require_impl_deref_path(path.to_owned());\n+    require_impl_deref_str(s.to_owned());\n+    require_impl_deref_slice(slice.to_owned());\n+\n+    require_deref_str_slice(s.to_owned(), slice.to_owned());\n+    require_deref_slice_str(slice.to_owned(), s.to_owned());\n+\n+    require_as_ref_c_str(c_str.to_owned());\n+    require_as_ref_os_str(os_str.to_owned());\n+    require_as_ref_path(path.to_owned());\n+    require_as_ref_str(s.to_owned());\n+    require_as_ref_str(x.to_owned());\n+    require_as_ref_slice(array.to_owned());\n+    require_as_ref_slice(array_ref.to_owned());\n+    require_as_ref_slice(slice.to_owned());\n+\n+    require_impl_as_ref_c_str(c_str.to_owned());\n+    require_impl_as_ref_os_str(os_str.to_owned());\n+    require_impl_as_ref_path(path.to_owned());\n+    require_impl_as_ref_str(s.to_owned());\n+    require_impl_as_ref_str(x.to_owned());\n+    require_impl_as_ref_slice(array.to_owned());\n+    require_impl_as_ref_slice(array_ref.to_owned());\n+    require_impl_as_ref_slice(slice.to_owned());\n+\n+    require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+    require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+    require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+    require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+    require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+    require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+\n+    let _ = x.join(&x.to_string());\n+\n+    // negative tests\n+    require_string(&s.to_string());\n+    require_string(&Cow::from(s).into_owned());\n+    require_string(&s.to_owned());\n+    require_string(&x.to_string());\n+\n+    // `X` isn't copy.\n+    require_deref_slice(x.to_owned());\n+}\n+\n+fn require_c_str(_: &CStr) {}\n+fn require_os_str(_: &OsStr) {}\n+fn require_path(_: &std::path::Path) {}\n+fn require_str(_: &str) {}\n+fn require_slice<T>(_: &[T]) {}\n+fn require_x(_: &X) {}\n+\n+fn require_deref_c_str<T: Deref<Target = CStr>>(_: T) {}\n+fn require_deref_os_str<T: Deref<Target = OsStr>>(_: T) {}\n+fn require_deref_path<T: Deref<Target = std::path::Path>>(_: T) {}\n+fn require_deref_str<T: Deref<Target = str>>(_: T) {}\n+fn require_deref_slice<T, U: Deref<Target = [T]>>(_: U) {}\n+\n+fn require_impl_deref_c_str(_: impl Deref<Target = CStr>) {}\n+fn require_impl_deref_os_str(_: impl Deref<Target = OsStr>) {}\n+fn require_impl_deref_path(_: impl Deref<Target = std::path::Path>) {}\n+fn require_impl_deref_str(_: impl Deref<Target = str>) {}\n+fn require_impl_deref_slice<T>(_: impl Deref<Target = [T]>) {}\n+\n+fn require_deref_str_slice<T: Deref<Target = str>, U, V: Deref<Target = [U]>>(_: T, _: V) {}\n+fn require_deref_slice_str<T, U: Deref<Target = [T]>, V: Deref<Target = str>>(_: U, _: V) {}\n+\n+fn require_as_ref_c_str<T: AsRef<CStr>>(_: T) {}\n+fn require_as_ref_os_str<T: AsRef<OsStr>>(_: T) {}\n+fn require_as_ref_path<T: AsRef<std::path::Path>>(_: T) {}\n+fn require_as_ref_str<T: AsRef<str>>(_: T) {}\n+fn require_as_ref_slice<T, U: AsRef<[T]>>(_: U) {}\n+\n+fn require_impl_as_ref_c_str(_: impl AsRef<CStr>) {}\n+fn require_impl_as_ref_os_str(_: impl AsRef<OsStr>) {}\n+fn require_impl_as_ref_path(_: impl AsRef<std::path::Path>) {}\n+fn require_impl_as_ref_str(_: impl AsRef<str>) {}\n+fn require_impl_as_ref_slice<T>(_: impl AsRef<[T]>) {}\n+\n+fn require_as_ref_str_slice<T: AsRef<str>, U, V: AsRef<[U]>>(_: T, _: V) {}\n+fn require_as_ref_slice_str<T, U: AsRef<[T]>, V: AsRef<str>>(_: U, _: V) {}\n+\n+fn require_string(_: &String) {}"}, {"sha": "b15dd4c7ee76815f2569acec37df4fb7e47ecc13", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "added", "additions": 382, "deletions": 0, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/468c86e4a3fa31b8c670422ea63875428e899b7f/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/468c86e4a3fa31b8c670422ea63875428e899b7f/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=468c86e4a3fa31b8c670422ea63875428e899b7f", "patch": "@@ -0,0 +1,382 @@\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:55:36\n+   |\n+LL |     require_c_str(&Cow::from(c_str).into_owned());\n+   |                                    ^^^^^^^^^^^^^ help: remove this\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:56:19\n+   |\n+LL |     require_c_str(&c_str.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_os_string`\n+  --> $DIR/unnecessary_to_owned.rs:58:20\n+   |\n+LL |     require_os_str(&os_str.to_os_string());\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:59:38\n+   |\n+LL |     require_os_str(&Cow::from(os_str).into_owned());\n+   |                                      ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:60:20\n+   |\n+LL |     require_os_str(&os_str.to_owned());\n+   |                    ^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_path_buf`\n+  --> $DIR/unnecessary_to_owned.rs:62:18\n+   |\n+LL |     require_path(&path.to_path_buf());\n+   |                  ^^^^^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:63:34\n+   |\n+LL |     require_path(&Cow::from(path).into_owned());\n+   |                                  ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:64:18\n+   |\n+LL |     require_path(&path.to_owned());\n+   |                  ^^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:66:17\n+   |\n+LL |     require_str(&s.to_string());\n+   |                 ^^^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:67:30\n+   |\n+LL |     require_str(&Cow::from(s).into_owned());\n+   |                              ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:68:17\n+   |\n+LL |     require_str(&s.to_owned());\n+   |                 ^^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:69:17\n+   |\n+LL |     require_str(&x.to_string());\n+   |                 ^^^^^^^^^^^^^^ help: use: `x.as_ref()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:71:19\n+   |\n+LL |     require_slice(&slice.to_vec());\n+   |                   ^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:72:36\n+   |\n+LL |     require_slice(&Cow::from(slice).into_owned());\n+   |                                    ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:73:19\n+   |\n+LL |     require_slice(&array.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `array.as_ref()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:74:19\n+   |\n+LL |     require_slice(&array_ref.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref.as_ref()`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:75:19\n+   |\n+LL |     require_slice(&slice.to_owned());\n+   |                   ^^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:76:21\n+   |\n+LL |     require_slice(&x.to_owned());\n+   |                     ^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `into_owned`\n+  --> $DIR/unnecessary_to_owned.rs:78:42\n+   |\n+LL |     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n+   |                                          ^^^^^^^^^^^^^ help: remove this\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:79:15\n+   |\n+LL |     require_x(&x.to_owned());\n+   |               ^^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:81:25\n+   |\n+LL |     require_deref_c_str(c_str.to_owned());\n+   |                         ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:82:26\n+   |\n+LL |     require_deref_os_str(os_str.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:83:24\n+   |\n+LL |     require_deref_path(path.to_owned());\n+   |                        ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:84:23\n+   |\n+LL |     require_deref_str(s.to_owned());\n+   |                       ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:85:25\n+   |\n+LL |     require_deref_slice(slice.to_owned());\n+   |                         ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:87:30\n+   |\n+LL |     require_impl_deref_c_str(c_str.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:88:31\n+   |\n+LL |     require_impl_deref_os_str(os_str.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:89:29\n+   |\n+LL |     require_impl_deref_path(path.to_owned());\n+   |                             ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:90:28\n+   |\n+LL |     require_impl_deref_str(s.to_owned());\n+   |                            ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:91:30\n+   |\n+LL |     require_impl_deref_slice(slice.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:93:29\n+   |\n+LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:93:43\n+   |\n+LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n+   |                                           ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:94:29\n+   |\n+LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n+   |                             ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:94:47\n+   |\n+LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n+   |                                               ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:96:26\n+   |\n+LL |     require_as_ref_c_str(c_str.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:97:27\n+   |\n+LL |     require_as_ref_os_str(os_str.to_owned());\n+   |                           ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:98:25\n+   |\n+LL |     require_as_ref_path(path.to_owned());\n+   |                         ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:99:24\n+   |\n+LL |     require_as_ref_str(s.to_owned());\n+   |                        ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:100:24\n+   |\n+LL |     require_as_ref_str(x.to_owned());\n+   |                        ^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:101:26\n+   |\n+LL |     require_as_ref_slice(array.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:102:26\n+   |\n+LL |     require_as_ref_slice(array_ref.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:103:26\n+   |\n+LL |     require_as_ref_slice(slice.to_owned());\n+   |                          ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:105:31\n+   |\n+LL |     require_impl_as_ref_c_str(c_str.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `c_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:106:32\n+   |\n+LL |     require_impl_as_ref_os_str(os_str.to_owned());\n+   |                                ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:107:30\n+   |\n+LL |     require_impl_as_ref_path(path.to_owned());\n+   |                              ^^^^^^^^^^^^^^^ help: use: `path`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:108:29\n+   |\n+LL |     require_impl_as_ref_str(s.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:109:29\n+   |\n+LL |     require_impl_as_ref_str(x.to_owned());\n+   |                             ^^^^^^^^^^^^ help: use: `&x`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:110:31\n+   |\n+LL |     require_impl_as_ref_slice(array.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:111:31\n+   |\n+LL |     require_impl_as_ref_slice(array_ref.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:112:31\n+   |\n+LL |     require_impl_as_ref_slice(slice.to_owned());\n+   |                               ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:114:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:114:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:115:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:115:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:116:30\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+   |                              ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:116:44\n+   |\n+LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n+   |                                            ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:117:30\n+   |\n+LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `array`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:117:48\n+   |\n+LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n+   |                                                ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:118:30\n+   |\n+LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:118:52\n+   |\n+LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n+   |                                                    ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:119:30\n+   |\n+LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+   |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n+\n+error: unnecessary use of `to_owned`\n+  --> $DIR/unnecessary_to_owned.rs:119:48\n+   |\n+LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n+   |                                                ^^^^^^^^^^^^ help: use: `s`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:121:20\n+   |\n+LL |     let _ = x.join(&x.to_string());\n+   |                    ^^^^^^^^^^^^^^ help: use: `&x`\n+\n+error: aborting due to 63 previous errors\n+"}]}