{"sha": "ab88ba42999ab820b4d15c842517f09b9719fb8b", "node_id": "C_kwDOAAsO6NoAKGFiODhiYTQyOTk5YWI4MjBiNGQxNWM4NDI1MTdmMDliOTcxOWZiOGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T03:54:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-26T03:54:43Z"}, "message": "Auto merge of #2270 - RalfJung:futex-ordering, r=RalfJung\n\ntest that futexes induce appropriate synchronization\n\nThis fails when I remove the `validate_lock_acquire` or `validate_lock_release` from `futex_wake`. So finally we got those code paths actually covered in tests. :)", "tree": {"sha": "a54448940703ca3f8107000210f9d462dd31d7c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a54448940703ca3f8107000210f9d462dd31d7c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab88ba42999ab820b4d15c842517f09b9719fb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab88ba42999ab820b4d15c842517f09b9719fb8b", "html_url": "https://github.com/rust-lang/rust/commit/ab88ba42999ab820b4d15c842517f09b9719fb8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab88ba42999ab820b4d15c842517f09b9719fb8b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e67b63ad30683731c2bd0c2cea671641d1750fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e67b63ad30683731c2bd0c2cea671641d1750fe", "html_url": "https://github.com/rust-lang/rust/commit/4e67b63ad30683731c2bd0c2cea671641d1750fe"}, {"sha": "e667ccb4594b5415626f18dbe34c1713b59e3941", "url": "https://api.github.com/repos/rust-lang/rust/commits/e667ccb4594b5415626f18dbe34c1713b59e3941", "html_url": "https://github.com/rust-lang/rust/commit/e667ccb4594b5415626f18dbe34c1713b59e3941"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "b65dd46d5974cf46c1b21fc3790e6eba98bac8b1", "filename": "tests/pass/concurrency/linux-futex.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ab88ba42999ab820b4d15c842517f09b9719fb8b/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab88ba42999ab820b4d15c842517f09b9719fb8b/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fconcurrency%2Flinux-futex.rs?ref=ab88ba42999ab820b4d15c842517f09b9719fb8b", "patch": "@@ -222,11 +222,17 @@ fn wait_wake_bitset() {\n     t.join().unwrap();\n }\n \n-const FREE: i32 = 0;\n-const HELD: i32 = 1;\n fn concurrent_wait_wake() {\n+    const FREE: i32 = 0;\n+    const HELD: i32 = 1;\n+\n     static FUTEX: AtomicI32 = AtomicI32::new(0);\n-    for _ in 0..20 {\n+    static mut DATA: i32 = 0;\n+    static WOKEN: AtomicI32 = AtomicI32::new(0);\n+\n+    let rounds = 50;\n+    for _ in 0..rounds {\n+        unsafe { DATA = 0 }; // Reset\n         // Suppose the main thread is holding a lock implemented using futex...\n         FUTEX.store(HELD, Ordering::Relaxed);\n \n@@ -239,23 +245,41 @@ fn concurrent_wait_wake() {\n             // the FUTEX is FREE != HELD and return without waiting\n             // or we'll deadlock.\n             unsafe {\n-                libc::syscall(\n+                let ret = libc::syscall(\n                     libc::SYS_futex,\n                     &FUTEX as *const AtomicI32,\n                     libc::FUTEX_WAIT,\n                     HELD,\n                     ptr::null::<libc::timespec>(),\n                 );\n+                if ret == 0 {\n+                    // We actually slept. And then woke up again. So we should be ordered-after\n+                    // what happened-before the FUTEX_WAKE. So this is not a race.\n+                    assert_eq!(DATA, 1);\n+                    // Also remember that this happened at least once.\n+                    WOKEN.fetch_add(1, Ordering::Relaxed);\n+                }\n             }\n         });\n+        // Increase the chance that the other thread actually goes to sleep.\n+        // (5 yields in a loop seem to make that happen around 40% of the time.)\n+        for _ in 0..5 {\n+            thread::yield_now();\n+        }\n \n         FUTEX.store(FREE, Ordering::Relaxed);\n         unsafe {\n+            DATA = 1;\n             libc::syscall(libc::SYS_futex, &FUTEX as *const AtomicI32, libc::FUTEX_WAKE, 1);\n         }\n \n         t.join().unwrap();\n     }\n+\n+    // Make sure we got the interesting case (of having woken a thread) at least once, but not *each* time.\n+    let woken = WOKEN.load(Ordering::Relaxed);\n+    assert!(woken > 0 && woken < rounds);\n+    //eprintln!(\"waking happened {woken} times\");\n }\n \n fn main() {"}]}