{"sha": "d136714e04fa244fb45a8459cb717dc682208697", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxMzY3MTRlMDRmYTI0NGZiNDVhODQ1OWNiNzE3ZGM2ODIyMDg2OTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-05-09T14:48:36Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2015-05-30T18:06:08Z"}, "message": "debuginfo: Create common debugger pretty printer module.\n\nGDB and LLDB pretty printers have some common functionality\nand also access some common information, such as the layout of\nstandard library types. So far, this information has been\nduplicated in the two pretty printing python modules. This\ncommit introduces a common module used by both debuggers.", "tree": {"sha": "53b52f7fcb678fcb4ef77b82ece9408c2e5fa9c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/53b52f7fcb678fcb4ef77b82ece9408c2e5fa9c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d136714e04fa244fb45a8459cb717dc682208697", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d136714e04fa244fb45a8459cb717dc682208697", "html_url": "https://github.com/rust-lang/rust/commit/d136714e04fa244fb45a8459cb717dc682208697", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d136714e04fa244fb45a8459cb717dc682208697/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "474c6e0ae47578b3e608c893e18bc83798b565aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/474c6e0ae47578b3e608c893e18bc83798b565aa", "html_url": "https://github.com/rust-lang/rust/commit/474c6e0ae47578b3e608c893e18bc83798b565aa"}], "stats": {"total": 1158, "additions": 737, "deletions": 421}, "files": [{"sha": "aa7b62e13b86c77b76d8e3504a1e3c18641f9bbb", "filename": "mk/debuggers.mk", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d136714e04fa244fb45a8459cb717dc682208697/mk%2Fdebuggers.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d136714e04fa244fb45a8459cb717dc682208697/mk%2Fdebuggers.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdebuggers.mk?ref=d136714e04fa244fb45a8459cb717dc682208697", "patch": "@@ -15,7 +15,8 @@\n \n ## GDB ##\n DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB=gdb_load_rust_pretty_printers.py \\\n-                                 gdb_rust_pretty_printing.py\n+                                 gdb_rust_pretty_printing.py \\\n+                                 debugger_pretty_printers_common.py\n DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB_ABS=\\\n     $(foreach script,$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_GDB), \\\n         $(CFG_SRC_DIR)src/etc/$(script))\n@@ -27,7 +28,8 @@ DEBUGGER_BIN_SCRIPTS_GDB_ABS=\\\n \n \n ## LLDB ##\n-DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB=lldb_rust_formatters.py\n+DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB=lldb_rust_formatters.py \\\n+                                  debugger_pretty_printers_common.py\n DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB_ABS=\\\n     $(foreach script,$(DEBUGGER_RUSTLIB_ETC_SCRIPTS_LLDB), \\\n         $(CFG_SRC_DIR)src/etc/$(script))"}, {"sha": "6e667b37a9c5ca3efb789913a4eb5a421629dd9f", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/d136714e04fa244fb45a8459cb717dc682208697/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/d136714e04fa244fb45a8459cb717dc682208697/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=d136714e04fa244fb45a8459cb717dc682208697", "patch": "@@ -0,0 +1,328 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+\"\"\"\n+This module provides an abstraction layer over common Rust pretty printing\n+functionality needed by both GDB and LLDB.\n+\"\"\"\n+\n+import re\n+\n+# Type codes that indicate the kind of type as it appears in DWARF debug\n+# information. This code alone is not sufficient to determine the Rust type.\n+# For example structs, tuples, fat pointers, or enum variants will all have\n+# DWARF_TYPE_CODE_STRUCT.\n+DWARF_TYPE_CODE_STRUCT = 1\n+DWARF_TYPE_CODE_UNION  = 2\n+DWARF_TYPE_CODE_PTR    = 3\n+DWARF_TYPE_CODE_ARRAY  = 4\n+DWARF_TYPE_CODE_ENUM   = 5\n+\n+# These constants specify the most specific kind of type that could be\n+# determined for a given value.\n+TYPE_KIND_UNKNOWN           = -1\n+TYPE_KIND_EMPTY             = 0\n+TYPE_KIND_SLICE             = 1\n+TYPE_KIND_REGULAR_STRUCT    = 2\n+TYPE_KIND_TUPLE             = 3\n+TYPE_KIND_TUPLE_STRUCT      = 4\n+TYPE_KIND_CSTYLE_VARIANT    = 5\n+TYPE_KIND_TUPLE_VARIANT     = 6\n+TYPE_KIND_STRUCT_VARIANT    = 7\n+TYPE_KIND_STR_SLICE         = 8\n+TYPE_KIND_STD_VEC           = 9\n+TYPE_KIND_STD_STRING        = 10\n+TYPE_KIND_REGULAR_ENUM      = 11\n+TYPE_KIND_COMPRESSED_ENUM   = 12\n+TYPE_KIND_SINGLETON_ENUM    = 13\n+TYPE_KIND_CSTYLE_ENUM       = 14\n+TYPE_KIND_PTR               = 15\n+TYPE_KIND_FIXED_SIZE_VEC    = 16\n+\n+ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n+ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n+\n+# Slice related constants\n+SLICE_FIELD_NAME_DATA_PTR = \"data_ptr\"\n+SLICE_FIELD_NAME_LENGTH = \"length\"\n+SLICE_FIELD_NAMES = [SLICE_FIELD_NAME_DATA_PTR, SLICE_FIELD_NAME_LENGTH]\n+\n+# std::Vec<> related constants\n+STD_VEC_FIELD_NAME_DATA_PTR = \"ptr\"\n+STD_VEC_FIELD_NAME_LENGTH = \"len\"\n+STD_VEC_FIELD_NAME_CAPACITY = \"cap\"\n+STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_DATA_PTR,\n+                       STD_VEC_FIELD_NAME_LENGTH,\n+                       STD_VEC_FIELD_NAME_CAPACITY]\n+\n+# std::String related constants\n+STD_STRING_FIELD_NAMES = [\"vec\"]\n+\n+\n+class Type(object):\n+    \"\"\"\n+    This class provides a common interface for type-oriented operations.\n+    Sub-classes are supposed to wrap a debugger-specific type-object and\n+    provide implementations for the abstract methods in this class.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.__type_kind = None\n+\n+    def get_unqualified_type_name(self):\n+        \"\"\"\n+        Implementations of this method should return the unqualified name of the\n+        type-object they are wrapping. Some examples:\n+\n+        'int' -> 'int'\n+        'std::vec::Vec<std::string::String>' -> 'Vec<std::string::String>'\n+        '&std::option::Option<std::string::String>' -> '&std::option::Option<std::string::String>'\n+\n+        As you can see, type arguments stay fully qualified.\n+        \"\"\"\n+        raise NotImplementedError(\"Override this method\")\n+\n+    def get_dwarf_type_kind(self):\n+        \"\"\"\n+        Implementations of this method should return the correct\n+        DWARF_TYPE_CODE_* value for the wrapped type-object.\n+        \"\"\"\n+        raise NotImplementedError(\"Override this method\")\n+\n+    def get_fields(self):\n+        \"\"\"\n+        Implementations of this method should return a list of field-objects of\n+        this type. For Rust-enums (i.e. with DWARF_TYPE_CODE_UNION) these field-\n+        objects represent the variants of the enum. Field-objects must have a\n+        `name` attribute that gives their name as specified in DWARF.\n+        \"\"\"\n+        assert ((self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT) or\n+                (self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION))\n+        raise NotImplementedError(\"Override this method\")\n+\n+    def get_wrapped_value(self):\n+        \"\"\"\n+        Returns the debugger-specific type-object wrapped by this object. This\n+        is sometimes needed for doing things like pointer-arithmetic in GDB.\n+        \"\"\"\n+        raise NotImplementedError(\"Override this method\")\n+\n+    def get_type_kind(self):\n+        \"\"\"This method returns the TYPE_KIND_* value for this type-object.\"\"\"\n+        if self.__type_kind is None:\n+            dwarf_type_code = self.get_dwarf_type_kind()\n+\n+            if dwarf_type_code == DWARF_TYPE_CODE_STRUCT:\n+                self.__type_kind = self.__classify_struct()\n+            elif dwarf_type_code == DWARF_TYPE_CODE_UNION:\n+                self.__type_kind = self.__classify_union()\n+            elif dwarf_type_code == DWARF_TYPE_CODE_PTR:\n+                self.__type_kind = TYPE_KIND_PTR\n+            elif dwarf_type_code == DWARF_TYPE_CODE_ARRAY:\n+                self.__type_kind = TYPE_KIND_FIXED_SIZE_VEC\n+            else:\n+                self.__type_kind = TYPE_KIND_UNKNOWN\n+        return self.__type_kind\n+\n+    def __classify_struct(self):\n+        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT\n+\n+        unqualified_type_name = self.get_unqualified_type_name()\n+\n+        # STR SLICE\n+        if unqualified_type_name == \"&str\":\n+            return TYPE_KIND_STR_SLICE\n+\n+        # REGULAR SLICE\n+        if (unqualified_type_name.startswith(\"&[\") and\n+            unqualified_type_name.endswith(\"]\") and\n+            self.__conforms_to_field_layout(SLICE_FIELD_NAMES)):\n+            return TYPE_KIND_SLICE\n+\n+        fields = self.get_fields()\n+        field_count = len(fields)\n+\n+        # EMPTY STRUCT\n+        if field_count == 0:\n+            return TYPE_KIND_EMPTY\n+\n+        # STD VEC\n+        if (unqualified_type_name.startswith(\"Vec<\") and\n+            self.__conforms_to_field_layout(STD_VEC_FIELD_NAMES)):\n+            return TYPE_KIND_STD_VEC\n+\n+        # STD STRING\n+        if (unqualified_type_name.startswith(\"String\") and\n+            self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n+            return TYPE_KIND_STD_STRING\n+\n+        # ENUM VARIANTS\n+        if fields[0].name == ENUM_DISR_FIELD_NAME:\n+            if field_count == 1:\n+                return TYPE_KIND_CSTYLE_VARIANT\n+            elif self.__all_fields_conform_to_tuple_field_naming(1):\n+                return TYPE_KIND_TUPLE_VARIANT\n+            else:\n+                return TYPE_KIND_STRUCT_VARIANT\n+\n+        # TUPLE\n+        if self.__all_fields_conform_to_tuple_field_naming(0):\n+            if unqualified_type_name.startswith(\"(\"):\n+                return TYPE_KIND_TUPLE\n+            else:\n+                return TYPE_KIND_TUPLE_STRUCT\n+\n+        # REGULAR STRUCT\n+        return TYPE_KIND_REGULAR_STRUCT\n+\n+\n+    def __classify_union(self):\n+        assert self.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n+\n+        union_members = self.get_fields()\n+        union_member_count = len(union_members)\n+        if union_member_count == 0:\n+            return TYPE_KIND_EMPTY\n+        elif union_member_count == 1:\n+            first_variant_name = union_members[0].name\n+            if first_variant_name is None:\n+                return TYPE_KIND_SINGLETON_ENUM\n+            else:\n+                assert first_variant_name.startswith(ENCODED_ENUM_PREFIX)\n+                return TYPE_KIND_COMPRESSED_ENUM\n+        else:\n+            return TYPE_KIND_REGULAR_ENUM\n+\n+\n+    def __conforms_to_field_layout(self, expected_fields):\n+        actual_fields = self.get_fields()\n+        actual_field_count = len(actual_fields)\n+\n+        if actual_field_count != len(expected_fields):\n+            return False\n+\n+        for i in range(0, actual_field_count):\n+            if actual_fields[i].name != expected_fields[i]:\n+                return False\n+\n+        return True\n+\n+    def __all_fields_conform_to_tuple_field_naming(self, start_index):\n+        fields = self.get_fields()\n+        field_count = len(fields)\n+\n+        for i in range(start_index, field_count):\n+            field_name = fields[i].name\n+            if (field_name is None) or (re.match(r\"__\\d+$\", field_name) is None):\n+                return False\n+        return True\n+\n+\n+class Value(object):\n+    \"\"\"\n+    This class provides a common interface for value-oriented operations.\n+    Sub-classes are supposed to wrap a debugger-specific value-object and\n+    provide implementations for the abstract methods in this class.\n+    \"\"\"\n+    def __init__(self, ty):\n+        self.type = ty\n+\n+    def get_child_at_index(self, index):\n+        \"\"\"Returns the value of the field, array element or variant at the given index\"\"\"\n+        raise NotImplementedError(\"Override this method\")\n+\n+    def as_integer(self):\n+        \"\"\"\n+        Try to convert the wrapped value into a Python integer. This should\n+        always succeed for values that are pointers or actual integers.\n+        \"\"\"\n+        raise NotImplementedError(\"Override this method\")\n+\n+    def get_wrapped_value(self):\n+        \"\"\"\n+        Returns the debugger-specific value-object wrapped by this object. This\n+        is sometimes needed for doing things like pointer-arithmetic in GDB.\n+        \"\"\"\n+        raise NotImplementedError(\"Override this method\")\n+\n+\n+class EncodedEnumInfo(object):\n+    \"\"\"\n+    This class provides facilities for handling enum values with compressed\n+    encoding where a non-null field in one variant doubles as the discriminant.\n+    \"\"\"\n+\n+    def __init__(self, enum_val):\n+        assert enum_val.type.get_type_kind() == TYPE_KIND_COMPRESSED_ENUM\n+        variant_name = enum_val.type.get_fields()[0].name\n+        last_separator_index = variant_name.rfind(\"$\")\n+        start_index = len(ENCODED_ENUM_PREFIX)\n+        indices_substring = variant_name[start_index:last_separator_index].split(\"$\")\n+        self.__enum_val = enum_val\n+        self.__disr_field_indices = [int(index) for index in indices_substring]\n+        self.__null_variant_name = variant_name[last_separator_index + 1:]\n+\n+    def is_null_variant(self):\n+        ty = self.__enum_val.type\n+        sole_variant_val = self.__enum_val.get_child_at_index(0)\n+        discriminant_val = sole_variant_val\n+        for disr_field_index in self.__disr_field_indices:\n+            discriminant_val = discriminant_val.get_child_at_index(disr_field_index)\n+\n+        # If the discriminant field is a fat pointer we have to consider the\n+        # first word as the true discriminant\n+        if discriminant_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_STRUCT:\n+            discriminant_val = discriminant_val.get_child_at_index(0)\n+\n+        return discriminant_val.as_integer() == 0\n+\n+    def get_non_null_variant_val(self):\n+        return self.__enum_val.get_child_at_index(0)\n+\n+    def get_null_variant_name(self):\n+        return self.__null_variant_name\n+\n+\n+def get_discriminant_value_as_integer(enum_val):\n+    assert enum_val.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_UNION\n+    # we can take any variant here because the discriminant has to be the same\n+    # for all of them.\n+    variant_val = enum_val.get_child_at_index(0)\n+    disr_val = variant_val.get_child_at_index(0)\n+    return disr_val.as_integer()\n+\n+\n+def extract_length_ptr_and_cap_from_std_vec(vec_val):\n+    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VEC\n+    length_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_LENGTH)\n+    ptr_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_DATA_PTR)\n+    cap_field_index = STD_VEC_FIELD_NAMES.index(STD_VEC_FIELD_NAME_CAPACITY)\n+\n+    length = vec_val.get_child_at_index(length_field_index).as_integer()\n+    vec_ptr_val = vec_val.get_child_at_index(ptr_field_index)\n+    capacity = vec_val.get_child_at_index(cap_field_index).as_integer()\n+\n+    unique_ptr_val = vec_ptr_val.get_child_at_index(0)\n+    data_ptr = unique_ptr_val.get_child_at_index(0)\n+    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n+    return (length, data_ptr, capacity)\n+\n+def extract_length_and_ptr_from_slice(slice_val):\n+    assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n+            slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)\n+\n+    length_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_LENGTH)\n+    ptr_field_index = SLICE_FIELD_NAMES.index(SLICE_FIELD_NAME_DATA_PTR)\n+\n+    length = slice_val.get_child_at_index(length_field_index).as_integer()\n+    data_ptr = slice_val.get_child_at_index(ptr_field_index)\n+\n+    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n+    return (length, data_ptr)"}, {"sha": "f93f3490215d187ee186719024cadf31f72abdbe", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 169, "deletions": 230, "changes": 399, "blob_url": "https://github.com/rust-lang/rust/blob/d136714e04fa244fb45a8459cb717dc682208697/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/d136714e04fa244fb45a8459cb717dc682208697/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=d136714e04fa244fb45a8459cb717dc682208697", "patch": "@@ -10,246 +10,265 @@\n \n import gdb\n import re\n+import debugger_pretty_printers_common as rustpp\n \n #===============================================================================\n # GDB Pretty Printing Module for Rust\n #===============================================================================\n \n+class GdbType(rustpp.Type):\n \n-def register_printers(objfile):\n-    \"Registers Rust pretty printers for the given objfile\"\n-    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n+    def __init__(self, ty):\n+        super(GdbType, self).__init__()\n+        self.ty = ty\n+        self.fields = None\n \n+    def get_unqualified_type_name(self):\n+        tag = self.ty.tag\n \n-def rust_pretty_printer_lookup_function(val):\n-    \"Returns the correct Rust pretty printer for the given value if there is one\"\n-    type_code = val.type.code\n+        if tag is None:\n+            return tag\n \n-    if type_code == gdb.TYPE_CODE_STRUCT:\n-        struct_kind = classify_struct(val.type)\n+        return tag.replace(\"&'static \", \"&\")\n \n-        if struct_kind == STRUCT_KIND_SLICE:\n-            return RustSlicePrinter(val)\n+    def get_dwarf_type_kind(self):\n+        if self.ty.code == gdb.TYPE_CODE_STRUCT:\n+            return rustpp.DWARF_TYPE_CODE_STRUCT\n \n-        if struct_kind == STRUCT_KIND_STR_SLICE:\n-            return RustStringSlicePrinter(val)\n+        if self.ty.code == gdb.TYPE_CODE_UNION:\n+            return rustpp.DWARF_TYPE_CODE_UNION\n \n-        if struct_kind == STRUCT_KIND_STD_VEC:\n-            return RustStdVecPrinter(val)\n+        if self.ty.code == gdb.TYPE_CODE_PTR:\n+            return rustpp.DWARF_TYPE_CODE_PTR\n \n-        if struct_kind == STRUCT_KIND_STD_STRING:\n-            return RustStdStringPrinter(val)\n+        if self.ty.code == gdb.TYPE_CODE_ENUM:\n+            return rustpp.DWARF_TYPE_CODE_ENUM\n \n-        if struct_kind == STRUCT_KIND_TUPLE:\n-            return RustTuplePrinter(val)\n+    def get_fields(self):\n+        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n+                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n+        if self.fields is None:\n+            self.fields = list(self.ty.fields())\n+        return self.fields\n \n-        if struct_kind == STRUCT_KIND_TUPLE_STRUCT:\n-            return RustTupleStructPrinter(val, False)\n+    def get_wrapped_value(self):\n+        return self.ty\n \n-        if struct_kind == STRUCT_KIND_CSTYLE_VARIANT:\n-            return RustCStyleEnumPrinter(val[get_field_at_index(val, 0)])\n \n-        if struct_kind == STRUCT_KIND_TUPLE_VARIANT:\n-            return RustTupleStructPrinter(val, True)\n+class GdbValue(rustpp.Value):\n+    def __init__(self, gdb_val):\n+        super(GdbValue, self).__init__(GdbType(gdb_val.type))\n+        self.gdb_val = gdb_val\n+        self.children = {}\n \n-        if struct_kind == STRUCT_KIND_STRUCT_VARIANT:\n-            return RustStructPrinter(val, True)\n+    def get_child_at_index(self, index):\n+        child = self.children.get(index)\n+        if child is None:\n+            gdb_field = get_field_at_index(self.gdb_val, index)\n+            child = GdbValue(self.gdb_val[gdb_field])\n+            self.children[index] = child\n+        return child\n \n-        return RustStructPrinter(val, False)\n+    def as_integer(self):\n+        return int(self.gdb_val)\n \n-    # Enum handling\n-    if type_code == gdb.TYPE_CODE_UNION:\n-        enum_members = list(val.type.fields())\n-        enum_member_count = len(enum_members)\n+    def get_wrapped_value(self):\n+        return self.gdb_val\n \n-        if enum_member_count == 0:\n-            return RustStructPrinter(val, False)\n \n-        if enum_member_count == 1:\n-            first_variant_name = enum_members[0].name\n-            if first_variant_name is None:\n-                # This is a singleton enum\n-                return rust_pretty_printer_lookup_function(val[enum_members[0]])\n-            else:\n-                assert first_variant_name.startswith(\"RUST$ENCODED$ENUM$\")\n-                # This is a space-optimized enum.\n-                # This means this enum has only two states, and Rust uses one\n-                # of the fields somewhere in the struct to determine which of\n-                # the two states it's in. The location of the field is encoded\n-                # in the name as something like\n-                # RUST$ENCODED$ENUM$(num$)*name_of_zero_state\n-                last_separator_index = first_variant_name.rfind(\"$\")\n-                start_index = len(\"RUST$ENCODED$ENUM$\")\n-                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n-                disr_field_indices = [int(index) for index in disr_field_indices]\n-\n-                sole_variant_val = val[enum_members[0]]\n-                discriminant = sole_variant_val\n-                for disr_field_index in disr_field_indices:\n-                    disr_field = get_field_at_index(discriminant, disr_field_index)\n-                    discriminant = discriminant[disr_field]\n-\n-                # If the discriminant field is a fat pointer we have to consider the\n-                # first word as the true discriminant\n-                if discriminant.type.code == gdb.TYPE_CODE_STRUCT:\n-                    discriminant = discriminant[get_field_at_index(discriminant, 0)]\n-\n-                if discriminant == 0:\n-                    null_variant_name = first_variant_name[last_separator_index + 1:]\n-                    return IdentityPrinter(null_variant_name)\n-\n-                return rust_pretty_printer_lookup_function(sole_variant_val)\n+def register_printers(objfile):\n+    \"\"\"Registers Rust pretty printers for the given objfile\"\"\"\n+    objfile.pretty_printers.append(rust_pretty_printer_lookup_function)\n \n-        # This is a regular enum, extract the discriminant\n-        discriminant_name, discriminant_val = extract_discriminant_value(val)\n-        return rust_pretty_printer_lookup_function(val[enum_members[discriminant_val]])\n \n-    # No pretty printer has been found\n-    return None\n+def rust_pretty_printer_lookup_function(gdb_val):\n+    \"\"\"\n+    Returns the correct Rust pretty printer for the given value\n+    if there is one\n+    \"\"\"\n \n-#=------------------------------------------------------------------------------\n-# Pretty Printer Classes\n-#=------------------------------------------------------------------------------\n+    val = GdbValue(gdb_val)\n+    type_kind = val.type.get_type_kind()\n \n+    if (type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT or\n+        type_kind == rustpp.TYPE_KIND_EMPTY):\n+        return RustStructPrinter(val,\n+                                 omit_first_field = False,\n+                                 omit_type_name = False,\n+                                 is_tuple_like = False)\n \n-class RustStructPrinter:\n-    def __init__(self, val, hide_first_field):\n-        self.val = val\n-        self.hide_first_field = hide_first_field\n+    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n+        return RustStructPrinter(val,\n+                                 omit_first_field = True,\n+                                 omit_type_name = False,\n+                                 is_tuple_like = False)\n \n-    def to_string(self):\n-        return self.val.type.tag\n+    if type_kind == rustpp.TYPE_KIND_SLICE:\n+        return RustSlicePrinter(val)\n \n-    def children(self):\n-        cs = []\n-        for field in self.val.type.fields():\n-            field_name = field.name\n-            # Normally the field name is used as a key to access the field\n-            # value, because that's also supported in older versions of GDB...\n-            field_key = field_name\n-            if field_name is None:\n-                field_name = \"\"\n-                # ... but for fields without a name (as in tuples), we have to\n-                # fall back to the newer method of using the field object\n-                # directly as key. In older versions of GDB, this will just\n-                # fail.\n-                field_key = field\n-            name_value_tuple = (field_name, self.val[field_key])\n-            cs.append(name_value_tuple)\n-\n-        if self.hide_first_field:\n-            cs = cs[1:]\n+    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n+        return RustStringSlicePrinter(val)\n \n-        return cs\n+    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n+        return RustStdVecPrinter(val)\n \n+    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n+        return RustStdStringPrinter(val)\n \n-class RustTuplePrinter:\n-    def __init__(self, val):\n-        self.val = val\n+    if type_kind == rustpp.TYPE_KIND_TUPLE:\n+        return RustStructPrinter(val,\n+                                 omit_first_field = False,\n+                                 omit_type_name = True,\n+                                 is_tuple_like = True)\n \n-    def to_string(self):\n-        return None\n+    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n+        return RustStructPrinter(val,\n+                                 omit_first_field = False,\n+                                 omit_type_name = False,\n+                                 is_tuple_like = True)\n \n-    def children(self):\n-        cs = []\n-        for field in self.val.type.fields():\n-            cs.append((\"\", self.val[field]))\n+    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n+        return RustCStyleVariantPrinter(val.get_child_at_index(0))\n \n-        return cs\n+    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n+        return RustStructPrinter(val,\n+                                 omit_first_field = True,\n+                                 omit_type_name = False,\n+                                 is_tuple_like = True)\n \n-    def display_hint(self):\n-        return \"array\"\n+    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n+        variant = get_field_at_index(gdb_val, 0)\n+        return rust_pretty_printer_lookup_function(gdb_val[variant])\n \n+    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n+        # This is a regular enum, extract the discriminant\n+        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n+        variant = get_field_at_index(gdb_val, discriminant_val)\n+        return rust_pretty_printer_lookup_function(gdb_val[variant])\n+\n+    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n+        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n+        if encoded_enum_info.is_null_variant():\n+            return IdentityPrinter(encoded_enum_info.get_null_variant_name())\n \n-class RustTupleStructPrinter:\n-    def __init__(self, val, hide_first_field):\n-        self.val = val\n-        self.hide_first_field = hide_first_field\n+        non_null_val = encoded_enum_info.get_non_null_variant_val()\n+        return rust_pretty_printer_lookup_function(non_null_val.get_wrapped_value())\n+\n+    # No pretty printer has been found\n+    return None\n+\n+\n+#=------------------------------------------------------------------------------\n+# Pretty Printer Classes\n+#=------------------------------------------------------------------------------\n+class RustStructPrinter:\n+    def __init__(self, val, omit_first_field, omit_type_name, is_tuple_like):\n+        self.__val = val\n+        self.__omit_first_field = omit_first_field\n+        self.__omit_type_name = omit_type_name\n+        self.__is_tuple_like = is_tuple_like\n \n     def to_string(self):\n-        return self.val.type.tag\n+        if self.__omit_type_name:\n+            return None\n+        return self.__val.type.get_unqualified_type_name()\n \n     def children(self):\n         cs = []\n-        for field in self.val.type.fields():\n-            cs.append((\"\", self.val[field]))\n+        wrapped_value = self.__val.get_wrapped_value()\n+\n+        for field in self.__val.type.get_fields():\n+            field_value = wrapped_value[field.name]\n+            if self.__is_tuple_like:\n+                cs.append((\"\", field_value))\n+            else:\n+                cs.append((field.name, field_value))\n \n-        if self.hide_first_field:\n+        if self.__omit_first_field:\n             cs = cs[1:]\n \n         return cs\n \n     def display_hint(self):\n-        return \"array\"\n+        if self.__is_tuple_like:\n+            return \"array\"\n+        else:\n+            return \"\"\n+\n \n class RustSlicePrinter:\n     def __init__(self, val):\n-        self.val = val\n+        self.__val = val\n \n     def display_hint(self):\n         return \"array\"\n \n     def to_string(self):\n-        length = int(self.val[\"length\"])\n-        return self.val.type.tag + (\"(len: %i)\" % length)\n+        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n+        return (self.__val.type.get_unqualified_type_name() +\n+                (\"(len: %i)\" % length))\n \n     def children(self):\n         cs = []\n-        length = int(self.val[\"length\"])\n-        data_ptr = self.val[\"data_ptr\"]\n-        assert data_ptr.type.code == gdb.TYPE_CODE_PTR\n-        pointee_type = data_ptr.type.target()\n+        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n+        assert data_ptr.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n+        raw_ptr = data_ptr.get_wrapped_value()\n \n         for index in range(0, length):\n-            cs.append((str(index), (data_ptr + index).dereference()))\n+            cs.append((str(index), (raw_ptr + index).dereference()))\n \n         return cs\n \n+\n class RustStringSlicePrinter:\n     def __init__(self, val):\n-        self.val = val\n+        self.__val = val\n \n     def to_string(self):\n-        slice_byte_len = self.val[\"length\"]\n-        return '\"%s\"' % self.val[\"data_ptr\"].string(encoding=\"utf-8\", length=slice_byte_len)\n+        (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(self.__val)\n+        raw_ptr = data_ptr.get_wrapped_value()\n+        return '\"%s\"' % raw_ptr.string(encoding=\"utf-8\", length=length)\n+\n \n class RustStdVecPrinter:\n     def __init__(self, val):\n-        self.val = val\n+        self.__val = val\n \n     def display_hint(self):\n         return \"array\"\n \n     def to_string(self):\n-        length = int(self.val[\"len\"])\n-        cap = int(self.val[\"cap\"])\n-        return self.val.type.tag + (\"(len: %i, cap: %i)\" % (length, cap))\n+        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n+        return (self.__val.type.get_unqualified_type_name() +\n+                (\"(len: %i, cap: %i)\" % (length, cap)))\n \n     def children(self):\n         cs = []\n-        (length, data_ptr) = extract_length_and_data_ptr_from_std_vec(self.val)\n-        pointee_type = data_ptr.type.target()\n-\n+        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(self.__val)\n+        gdb_ptr = data_ptr.get_wrapped_value()\n         for index in range(0, length):\n-            cs.append((str(index), (data_ptr + index).dereference()))\n+            cs.append((str(index), (gdb_ptr + index).dereference()))\n         return cs\n \n+\n class RustStdStringPrinter:\n     def __init__(self, val):\n-        self.val = val\n+        self.__val = val\n \n     def to_string(self):\n-        (length, data_ptr) = extract_length_and_data_ptr_from_std_vec(self.val[\"vec\"])\n-        return '\"%s\"' % data_ptr.string(encoding=\"utf-8\", length=length)\n+        vec = self.__val.get_child_at_index(0)\n+        (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n+        return '\"%s\"' % data_ptr.get_wrapped_value().string(encoding=\"utf-8\",\n+                                                            length=length)\n \n \n-class RustCStyleEnumPrinter:\n+class RustCStyleVariantPrinter:\n     def __init__(self, val):\n-        assert val.type.code == gdb.TYPE_CODE_ENUM\n-        self.val = val\n+        assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ENUM\n+        self.__val = val\n \n     def to_string(self):\n-        return str(self.val)\n+        return str(self.__val.get_wrapped_value())\n \n \n class IdentityPrinter:\n@@ -259,91 +278,11 @@ def __init__(self, string):\n     def to_string(self):\n         return self.string\n \n-STRUCT_KIND_REGULAR_STRUCT  = 0\n-STRUCT_KIND_TUPLE_STRUCT    = 1\n-STRUCT_KIND_TUPLE           = 2\n-STRUCT_KIND_TUPLE_VARIANT   = 3\n-STRUCT_KIND_STRUCT_VARIANT  = 4\n-STRUCT_KIND_CSTYLE_VARIANT  = 5\n-STRUCT_KIND_SLICE           = 6\n-STRUCT_KIND_STR_SLICE       = 7\n-STRUCT_KIND_STD_VEC         = 8\n-STRUCT_KIND_STD_STRING      = 9\n-\n-\n-def classify_struct(type):\n-    # print(\"\\nclassify_struct: tag=%s\\n\" % type.tag)\n-    if type.tag == \"&str\":\n-        return STRUCT_KIND_STR_SLICE\n-\n-    if type.tag.startswith(\"&[\") and type.tag.endswith(\"]\"):\n-        return STRUCT_KIND_SLICE\n-\n-    fields = list(type.fields())\n-    field_count = len(fields)\n-\n-    if field_count == 0:\n-        return STRUCT_KIND_REGULAR_STRUCT\n-\n-    if (field_count == 3 and\n-        fields[0].name == \"ptr\" and\n-        fields[1].name == \"len\" and\n-        fields[2].name == \"cap\" and\n-        type.tag.startswith(\"Vec<\")):\n-        return STRUCT_KIND_STD_VEC\n-\n-    if (field_count == 1 and\n-        fields[0].name == \"vec\" and\n-        type.tag == \"String\"):\n-        return STRUCT_KIND_STD_STRING\n-\n-    if fields[0].name == \"RUST$ENUM$DISR\":\n-        if field_count == 1:\n-            return STRUCT_KIND_CSTYLE_VARIANT\n-        elif all_fields_conform_to_tuple_field_naming(fields, 1):\n-            return STRUCT_KIND_TUPLE_VARIANT\n-        else:\n-            return STRUCT_KIND_STRUCT_VARIANT\n-\n-    if all_fields_conform_to_tuple_field_naming(fields, 0):\n-        if type.tag.startswith(\"(\"):\n-            return STRUCT_KIND_TUPLE\n-        else:\n-            return STRUCT_KIND_TUPLE_STRUCT\n \n-    return STRUCT_KIND_REGULAR_STRUCT\n-\n-\n-def extract_discriminant_value(enum_val):\n-    assert enum_val.type.code == gdb.TYPE_CODE_UNION\n-    for variant_descriptor in enum_val.type.fields():\n-        variant_val = enum_val[variant_descriptor]\n-        for field in variant_val.type.fields():\n-            return (field.name, int(variant_val[field]))\n-\n-\n-def first_field(val):\n-    for field in val.type.fields():\n-        return field\n-\n-def get_field_at_index(val, index):\n+def get_field_at_index(gdb_val, index):\n     i = 0\n-    for field in val.type.fields():\n+    for field in gdb_val.type.fields():\n         if i == index:\n             return field\n         i += 1\n     return None\n-\n-def all_fields_conform_to_tuple_field_naming(fields, start_index):\n-    for i in range(start_index, len(fields)):\n-        if (fields[i].name is None) or (re.match(r\"__\\d+$\", fields[i].name) is None):\n-            return False\n-    return True\n-\n-def extract_length_and_data_ptr_from_std_vec(vec_val):\n-    length = int(vec_val[\"len\"])\n-    vec_ptr_val = vec_val[\"ptr\"]\n-    unique_ptr_val = vec_ptr_val[first_field(vec_ptr_val)]\n-    data_ptr = unique_ptr_val[first_field(unique_ptr_val)]\n-    assert data_ptr.type.code == gdb.TYPE_CODE_PTR\n-    return (length, data_ptr)"}, {"sha": "c22a60abf3f7662be6aa814dc7a27ffb8c25105a", "filename": "src/etc/lldb_rust_formatters.py", "status": "modified", "additions": 208, "deletions": 187, "changes": 395, "blob_url": "https://github.com/rust-lang/rust/blob/d136714e04fa244fb45a8459cb717dc682208697/src%2Fetc%2Flldb_rust_formatters.py", "raw_url": "https://github.com/rust-lang/rust/raw/d136714e04fa244fb45a8459cb717dc682208697/src%2Fetc%2Flldb_rust_formatters.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_rust_formatters.py?ref=d136714e04fa244fb45a8459cb717dc682208697", "patch": "@@ -10,58 +10,177 @@\n \n import lldb\n import re\n+import debugger_pretty_printers_common as rustpp\n \n-def print_val(val, internal_dict):\n-    '''Prints the given value with Rust syntax'''\n-    type_class = val.GetType().GetTypeClass()\n+#===============================================================================\n+# LLDB Pretty Printing Module for Rust\n+#===============================================================================\n \n-    if type_class == lldb.eTypeClassStruct:\n-        return print_struct_val(val, internal_dict)\n+class LldbType(rustpp.Type):\n \n-    if type_class == lldb.eTypeClassUnion:\n-        return print_enum_val(val, internal_dict)\n+    def __init__(self, ty):\n+        super(LldbType, self).__init__()\n+        self.ty = ty\n+        self.fields = None\n \n-    if type_class == lldb.eTypeClassPointer:\n-        return print_pointer_val(val, internal_dict)\n+    def get_unqualified_type_name(self):\n+        qualified_name = self.ty.GetName()\n \n-    if type_class == lldb.eTypeClassArray:\n-        return print_fixed_size_vec_val(val, internal_dict)\n+        if qualified_name is None:\n+            return qualified_name\n \n-    return val.GetValue()\n+        return extract_type_name(qualified_name).replace(\"&'static \", \"&\")\n \n+    def get_dwarf_type_kind(self):\n+        type_class = self.ty.GetTypeClass()\n \n-#=--------------------------------------------------------------------------------------------------\n-# Type-Specialized Printing Functions\n-#=--------------------------------------------------------------------------------------------------\n+        if type_class == lldb.eTypeClassStruct:\n+            return rustpp.DWARF_TYPE_CODE_STRUCT\n+\n+        if type_class == lldb.eTypeClassUnion:\n+            return rustpp.DWARF_TYPE_CODE_UNION\n+\n+        if type_class == lldb.eTypeClassPointer:\n+            return rustpp.DWARF_TYPE_CODE_PTR\n+\n+        if type_class == lldb.eTypeClassArray:\n+            return rustpp.DWARF_TYPE_CODE_ARRAY\n+\n+        if type_class == lldb.eTypeClassEnumeration:\n+            return rustpp.DWARF_TYPE_CODE_ENUM\n+\n+        return None\n+\n+    def get_fields(self):\n+        assert ((self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT) or\n+                (self.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_UNION))\n+        if self.fields is None:\n+            self.fields = list(self.ty.fields)\n+        return self.fields\n+\n+    def get_wrapped_value(self):\n+        return self.ty\n+\n+\n+class LldbValue(rustpp.Value):\n+    def __init__(self, lldb_val):\n+        ty = lldb_val.type\n+        wty = LldbType(ty)\n+        super(LldbValue, self).__init__(wty)\n+        self.lldb_val = lldb_val\n+        self.children = {}\n+\n+    def get_child_at_index(self, index):\n+        child = self.children.get(index)\n+        if child is None:\n+            lldb_field = self.lldb_val.GetChildAtIndex(index)\n+            child = LldbValue(lldb_field)\n+            self.children[index] = child\n+        return child\n+\n+    def as_integer(self):\n+        return self.lldb_val.GetValueAsUnsigned()\n+\n+    def get_wrapped_value(self):\n+        return self.lldb_val\n+\n+\n+def print_val(lldb_val, internal_dict):\n+    val = LldbValue(lldb_val)\n+    type_kind = val.type.get_type_kind()\n \n-def print_struct_val(val, internal_dict):\n-    '''Prints a struct, tuple, or tuple struct value with Rust syntax'''\n-    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n+    if (type_kind == rustpp.TYPE_KIND_REGULAR_STRUCT or\n+        type_kind == rustpp.TYPE_KIND_EMPTY):\n+        return print_struct_val(val,\n+                                internal_dict,\n+                                omit_first_field = False,\n+                                omit_type_name = False,\n+                                is_tuple_like = False)\n \n-    if is_vec_slice(val):\n+    if type_kind == rustpp.TYPE_KIND_STRUCT_VARIANT:\n+        return print_struct_val(val,\n+                                internal_dict,\n+                                omit_first_field = True,\n+                                omit_type_name = False,\n+                                is_tuple_like = False)\n+\n+    if type_kind == rustpp.TYPE_KIND_SLICE:\n         return print_vec_slice_val(val, internal_dict)\n-    elif is_std_vec(val):\n+\n+    if type_kind == rustpp.TYPE_KIND_STR_SLICE:\n+        return print_str_slice_val(val, internal_dict)\n+\n+    if type_kind == rustpp.TYPE_KIND_STD_VEC:\n         return print_std_vec_val(val, internal_dict)\n-    else:\n-        return print_struct_val_starting_from(0, val, internal_dict)\n \n+    if type_kind == rustpp.TYPE_KIND_STD_STRING:\n+        return print_std_string_val(val, internal_dict)\n+\n+    if type_kind == rustpp.TYPE_KIND_TUPLE:\n+        return print_struct_val(val,\n+                                internal_dict,\n+                                omit_first_field = False,\n+                                omit_type_name = True,\n+                                is_tuple_like = True)\n+\n+    if type_kind == rustpp.TYPE_KIND_TUPLE_STRUCT:\n+        return print_struct_val(val,\n+                                internal_dict,\n+                                omit_first_field = False,\n+                                omit_type_name = False,\n+                                is_tuple_like = True)\n+\n+    if type_kind == rustpp.TYPE_KIND_CSTYLE_VARIANT:\n+        return val.type.get_unqualified_type_name()\n+\n+    if type_kind == rustpp.TYPE_KIND_TUPLE_VARIANT:\n+        return print_struct_val(val,\n+                                internal_dict,\n+                                omit_first_field = True,\n+                                omit_type_name = False,\n+                                is_tuple_like = True)\n+\n+    if type_kind == rustpp.TYPE_KIND_SINGLETON_ENUM:\n+        return print_val(lldb_val.GetChildAtIndex(0), internal_dict)\n+\n+    if type_kind == rustpp.TYPE_KIND_PTR:\n+        return print_pointer_val(val, internal_dict)\n+\n+    if type_kind == rustpp.TYPE_KIND_FIXED_SIZE_VEC:\n+        return print_fixed_size_vec_val(val, internal_dict)\n+\n+    if type_kind == rustpp.TYPE_KIND_REGULAR_ENUM:\n+        # This is a regular enum, extract the discriminant\n+        discriminant_val = rustpp.get_discriminant_value_as_integer(val)\n+        return print_val(lldb_val.GetChildAtIndex(discriminant_val), internal_dict)\n+\n+    if type_kind == rustpp.TYPE_KIND_COMPRESSED_ENUM:\n+        encoded_enum_info = rustpp.EncodedEnumInfo(val)\n+        if encoded_enum_info.is_null_variant():\n+            return encoded_enum_info.get_null_variant_name()\n \n-def print_struct_val_starting_from(field_start_index, val, internal_dict):\n+        non_null_val = encoded_enum_info.get_non_null_variant_val()\n+        return print_val(non_null_val.get_wrapped_value(), internal_dict)\n+\n+    # No pretty printer has been found\n+    return lldb_val.GetValue()\n+\n+\n+#=--------------------------------------------------------------------------------------------------\n+# Type-Specialized Printing Functions\n+#=--------------------------------------------------------------------------------------------------\n+\n+def print_struct_val(val, internal_dict, omit_first_field, omit_type_name, is_tuple_like):\n     '''\n     Prints a struct, tuple, or tuple struct value with Rust syntax.\n     Ignores any fields before field_start_index.\n     '''\n-    assert val.GetType().GetTypeClass() == lldb.eTypeClassStruct\n-\n-    t = val.GetType()\n-    type_name = extract_type_name(t.GetName())\n-    num_children = val.num_children\n-\n-    if (num_children - field_start_index) == 0:\n-        # The only field of this struct is the enum discriminant\n-        return type_name\n+    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_STRUCT\n \n-    is_tuple_like = type_is_tuple_like(t)\n+    if omit_type_name:\n+        type_name = \"\"\n+    else:\n+        type_name = val.type.get_unqualified_type_name()\n \n     if is_tuple_like:\n         template = \"%(type_name)s(%(body)s)\"\n@@ -70,156 +189,96 @@ def print_struct_val_starting_from(field_start_index, val, internal_dict):\n         template = \"%(type_name)s {\\n%(body)s\\n}\"\n         separator = \", \\n\"\n \n-    if type_name.startswith(\"(\"):\n-        # this is a tuple, so don't print the type name\n-        type_name = \"\"\n+    fields = val.type.get_fields()\n \n     def render_child(child_index):\n         this = \"\"\n         if not is_tuple_like:\n-            field_name = t.GetFieldAtIndex(child_index).GetName()\n+            field_name = fields[child_index].name\n             this += field_name + \": \"\n \n-        field_val = val.GetChildAtIndex(child_index)\n+        field_val = val.get_child_at_index(child_index)\n \n-        if not field_val.IsValid():\n-            field = t.GetFieldAtIndex(child_index)\n+        if not field_val.get_wrapped_value().IsValid():\n+            field = fields[child_index]\n             # LLDB is not good at handling zero-sized values, so we have to help\n             # it a little\n             if field.GetType().GetByteSize() == 0:\n                 return this + extract_type_name(field.GetType().GetName())\n             else:\n                 return this + \"<invalid value>\"\n \n-        return this + print_val(field_val, internal_dict)\n+        return this + print_val(field_val.get_wrapped_value(), internal_dict)\n+\n+    if omit_first_field:\n+        field_start_index = 1\n+    else:\n+        field_start_index = 0\n \n-    body = separator.join([render_child(idx) for idx in range(field_start_index, num_children)])\n+    body = separator.join([render_child(idx) for idx in range(field_start_index, len(fields))])\n \n     return template % {\"type_name\": type_name,\n                        \"body\": body}\n \n-\n-def print_enum_val(val, internal_dict):\n-    '''Prints an enum value with Rust syntax'''\n-\n-    assert val.GetType().GetTypeClass() == lldb.eTypeClassUnion\n-\n-    if val.num_children == 1:\n-        # This is either an enum with just one variant, or it is an Option-like\n-        # enum where the discriminant is encoded in a non-nullable pointer\n-        # field. We find out which one it is by looking at the member name of\n-        # the sole union variant. If it starts with \"RUST$ENCODED$ENUM$\" then\n-        # we have an Option-like enum.\n-        first_variant_name = val.GetChildAtIndex(0).GetName()\n-        if first_variant_name and first_variant_name.startswith(\"RUST$ENCODED$ENUM$\"):\n-\n-            # This is an Option-like enum. The position of the discriminator field is\n-            # encoded in the name which has the format:\n-            #  RUST$ENCODED$ENUM$<index of discriminator field>$<name of null variant>\n-            last_separator_index = first_variant_name.rfind(\"$\")\n-            if last_separator_index == -1:\n-                return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-            start_index = len(\"RUST$ENCODED$ENUM$\")\n-\n-            # Extract indices of the discriminator field\n-            try:\n-                disr_field_indices = first_variant_name[start_index:last_separator_index].split(\"$\")\n-                disr_field_indices = [int(index) for index in disr_field_indices]\n-            except:\n-                return \"<invalid enum encoding: %s>\" % first_variant_name\n-\n-            # Read the discriminant\n-            disr_val = val.GetChildAtIndex(0)\n-            for index in disr_field_indices:\n-                disr_val = disr_val.GetChildAtIndex(index)\n-\n-            # If the discriminant field is a fat pointer we have to consider the\n-            # first word as the true discriminant\n-            if disr_val.GetType().GetTypeClass() == lldb.eTypeClassStruct:\n-                disr_val = disr_val.GetChildAtIndex(0)\n-\n-            if disr_val.GetValueAsUnsigned() == 0:\n-                # Null case: Print the name of the null-variant\n-                null_variant_name = first_variant_name[last_separator_index + 1:]\n-                return null_variant_name\n-            else:\n-                # Non-null case: Interpret the data as a value of the non-null variant type\n-                return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n-        else:\n-            # This is just a regular uni-variant enum without discriminator field\n-            return print_struct_val_starting_from(0, val.GetChildAtIndex(0), internal_dict)\n-\n-    # If we are here, this is a regular enum with more than one variant\n-    disr_val = val.GetChildAtIndex(0).GetChildMemberWithName(\"RUST$ENUM$DISR\")\n-    disr_type = disr_val.GetType()\n-\n-    if disr_type.GetTypeClass() != lldb.eTypeClassEnumeration:\n-        return \"<Invalid enum value encountered: Discriminator is not an enum>\"\n-\n-    variant_index = disr_val.GetValueAsUnsigned()\n-    return print_struct_val_starting_from(1, val.GetChildAtIndex(variant_index), internal_dict)\n-\n-\n def print_pointer_val(val, internal_dict):\n     '''Prints a pointer value with Rust syntax'''\n-    assert val.GetType().IsPointerType()\n+    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n     sigil = \"&\"\n-    type_name = extract_type_name(val.GetType().GetName())\n-    if type_name and type_name[0:1] in [\"&\", \"~\", \"*\"]:\n+    type_name = val.type.get_unqualified_type_name()\n+    if type_name and type_name[0:1] in [\"&\", \"*\"]:\n         sigil = type_name[0:1]\n \n-    return sigil + hex(val.GetValueAsUnsigned()) #print_val(val.Dereference(), internal_dict)\n+    return sigil + hex(val.as_integer())\n \n \n def print_fixed_size_vec_val(val, internal_dict):\n-    assert val.GetType().GetTypeClass() == lldb.eTypeClassArray\n+    assert val.type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_ARRAY\n+    lldb_val = val.get_wrapped_value()\n \n     output = \"[\"\n \n-    for i in range(val.num_children):\n-        output += print_val(val.GetChildAtIndex(i), internal_dict)\n-        if i != val.num_children - 1:\n+    for i in range(lldb_val.num_children):\n+        output += print_val(lldb_val.GetChildAtIndex(i), internal_dict)\n+        if i != lldb_val.num_children - 1:\n             output += \", \"\n \n     output += \"]\"\n     return output\n \n \n def print_vec_slice_val(val, internal_dict):\n-    length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n-\n-    data_ptr_val = val.GetChildAtIndex(0)\n-    data_ptr_type = data_ptr_val.GetType()\n-\n-    return \"&[%s]\" % print_array_of_values(val.GetName(),\n-                                           data_ptr_val,\n+    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n+    return \"&[%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n+                                           data_ptr,\n                                            length,\n                                            internal_dict)\n \n \n def print_std_vec_val(val, internal_dict):\n-    length = val.GetChildAtIndex(1).GetValueAsUnsigned()\n-\n-    # Vec<> -> Unique<> -> NonZero<> -> *T\n-    data_ptr_val = val.GetChildAtIndex(0).GetChildAtIndex(0).GetChildAtIndex(0)\n-    data_ptr_type = data_ptr_val.GetType()\n-\n-    return \"vec![%s]\" % print_array_of_values(val.GetName(),\n-                                              data_ptr_val,\n+    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(val)\n+    return \"vec![%s]\" % print_array_of_values(val.get_wrapped_value().GetName(),\n+                                              data_ptr,\n                                               length,\n                                               internal_dict)\n \n+def print_str_slice_val(val, internal_dict):\n+    (length, data_ptr) = rustpp.extract_length_and_ptr_from_slice(val)\n+    return read_utf8_string(data_ptr, length)\n+\n+def print_std_string_val(val, internal_dict):\n+    vec = val.get_child_at_index(0)\n+    (length, data_ptr, cap) = rustpp.extract_length_ptr_and_cap_from_std_vec(vec)\n+    return read_utf8_string(data_ptr, length)\n+\n #=--------------------------------------------------------------------------------------------------\n # Helper Functions\n #=--------------------------------------------------------------------------------------------------\n \n-unqualified_type_markers = frozenset([\"(\", \"[\", \"&\", \"*\"])\n-\n+UNQUALIFIED_TYPE_MARKERS = frozenset([\"(\", \"[\", \"&\", \"*\"])\n \n def extract_type_name(qualified_type_name):\n     '''Extracts the type name from a fully qualified path'''\n-    if qualified_type_name[0] in unqualified_type_markers:\n+    if qualified_type_name[0] in UNQUALIFIED_TYPE_MARKERS:\n         return qualified_type_name\n \n     end_of_search = qualified_type_name.find(\"<\")\n@@ -232,72 +291,34 @@ def extract_type_name(qualified_type_name):\n     else:\n         return qualified_type_name[index + 2:]\n \n-\n-def type_is_tuple_like(ty):\n-    '''Returns true of this is a type with field names (struct, struct-like enum variant)'''\n-    for field in ty.fields:\n-        if field.GetName() == \"RUST$ENUM$DISR\":\n-            # Ignore the enum discriminant field if there is one.\n-            continue\n-        if (field.GetName() is None) or (re.match(r\"__\\d+$\", field.GetName()) is None):\n-            return False\n-    return True\n-\n-\n-def is_vec_slice(val):\n-    ty = val.GetType()\n-    if ty.GetTypeClass() != lldb.eTypeClassStruct:\n-        return False\n-\n-    if ty.GetNumberOfFields() != 2:\n-        return False\n-\n-    if ty.GetFieldAtIndex(0).GetName() != \"data_ptr\":\n-        return False\n-\n-    if ty.GetFieldAtIndex(1).GetName() != \"length\":\n-        return False\n-\n-    type_name = extract_type_name(ty.GetName()).replace(\"&'static\", \"&\").replace(\" \", \"\")\n-    return type_name.startswith(\"&[\") and type_name.endswith(\"]\")\n-\n-def is_std_vec(val):\n-    ty = val.GetType()\n-    if ty.GetTypeClass() != lldb.eTypeClassStruct:\n-        return False\n-\n-    if ty.GetNumberOfFields() != 3:\n-        return False\n-\n-    if ty.GetFieldAtIndex(0).GetName() != \"ptr\":\n-        return False\n-\n-    if ty.GetFieldAtIndex(1).GetName() != \"len\":\n-        return False\n-\n-    if ty.GetFieldAtIndex(2).GetName() != \"cap\":\n-        return False\n-\n-    return ty.GetName().startswith(\"collections::vec::Vec<\")\n-\n-\n def print_array_of_values(array_name, data_ptr_val, length, internal_dict):\n     '''Prints a contigous memory range, interpreting it as values of the\n        pointee-type of data_ptr_val.'''\n \n-    data_ptr_type = data_ptr_val.GetType()\n-    assert data_ptr_type.IsPointerType()\n+    data_ptr_type = data_ptr_val.type\n+    assert data_ptr_type.get_dwarf_type_kind() == rustpp.DWARF_TYPE_CODE_PTR\n \n-    element_type = data_ptr_type.GetPointeeType()\n+    element_type = data_ptr_type.get_wrapped_value().GetPointeeType()\n     element_type_size = element_type.GetByteSize()\n \n-    start_address = data_ptr_val.GetValueAsUnsigned()\n+    start_address = data_ptr_val.as_integer()\n+    raw_value = data_ptr_val.get_wrapped_value()\n \n     def render_element(i):\n         address = start_address + i * element_type_size\n-        element_val = data_ptr_val.CreateValueFromAddress(array_name + (\"[%s]\" % i),\n-                                                          address,\n-                                                          element_type)\n+        element_val = raw_value.CreateValueFromAddress(array_name + (\"[%s]\" % i),\n+                                                       address,\n+                                                       element_type)\n         return print_val(element_val, internal_dict)\n \n     return ', '.join([render_element(i) for i in range(length)])\n+\n+\n+def read_utf8_string(ptr_val, byte_count):\n+    error = lldb.SBError()\n+    process = ptr_val.get_wrapped_value().GetProcess()\n+    data = process.ReadMemory(ptr_val.as_integer(), byte_count, error)\n+    if error.Success():\n+        return '\"%s\"' % data.decode(encoding='UTF-8')\n+    else:\n+        return '<error: %s>' % error.GetCString()"}, {"sha": "fba21d9a553ba80d7c341ac83170f7e274fd1a29", "filename": "src/test/debuginfo/option-like-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d136714e04fa244fb45a8459cb717dc682208697/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136714e04fa244fb45a8459cb717dc682208697/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Foption-like-enum.rs?ref=d136714e04fa244fb45a8459cb717dc682208697", "patch": "@@ -67,7 +67,7 @@\n // lldb-check:[...]$5 = Void\n \n // lldb-command:print some_str\n-// lldb-check:[...]$6 = Some(&str { data_ptr: [...], length: 3 })\n+// lldb-check:[...]$6 = Some(\"abc\")\n \n // lldb-command:print none_str\n // lldb-check:[...]$7 = None"}, {"sha": "576621737e6b6f7443ec290ef19ca99a39b746c4", "filename": "src/test/debuginfo/pretty-std.rs", "status": "renamed", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d136714e04fa244fb45a8459cb717dc682208697/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d136714e04fa244fb45a8459cb717dc682208697/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=d136714e04fa244fb45a8459cb717dc682208697", "patch": "@@ -10,10 +10,12 @@\n \n // ignore-windows failing on win32 bot\n // ignore-freebsd: gdb package too new\n-// ignore-lldb\n // ignore-android: FIXME(#10381)\n // compile-flags:-g\n // min-gdb-version 7.7\n+// min-lldb-version: 310\n+\n+// === GDB TESTS ===================================================================================\n \n // gdb-command: run\n \n@@ -35,6 +37,30 @@\n // gdb-command: print none\n // gdb-check:$6 = None\n \n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command: run\n+\n+// lldb-command: print slice\n+// lldb-check:[...]$0 = &[0, 1, 2, 3]\n+\n+// lldb-command: print vec\n+// lldb-check:[...]$1 = vec![4, 5, 6, 7]\n+\n+// lldb-command: print str_slice\n+// lldb-check:[...]$2 = \"IAMA string slice!\"\n+\n+// lldb-command: print string\n+// lldb-check:[...]$3 = \"IAMA string!\"\n+\n+// lldb-command: print some\n+// lldb-check:[...]$4 = Some(8)\n+\n+// lldb-command: print none\n+// lldb-check:[...]$5 = None\n+\n+\n #![allow(unused_variables)]\n \n fn main() {", "previous_filename": "src/test/debuginfo/gdb-pretty-std.rs"}]}