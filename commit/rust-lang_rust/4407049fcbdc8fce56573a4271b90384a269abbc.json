{"sha": "4407049fcbdc8fce56573a4271b90384a269abbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MDcwNDlmY2JkYzhmY2U1NjU3M2E0MjcxYjkwMzg0YTI2OWFiYmM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-11-22T22:00:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-22T22:00:55Z"}, "message": "Rollup merge of #77697 - WaffleLapkin:iter_split_adaptors, r=m-ou-se\n\nSplit each iterator adapter and source into individual modules\n\nThis PR creates individual modules for each iterator adapter and iterator source.\n\nThis is done to enhance the readability of corresponding modules (`adapters/mod.rs` and `sources.rs`) which were hard to navigate and read because of lots of repeated lines (e.g.: `adapters/mod.rs` was 3k lines long). This is also in line with some adapters which already had their own modules (`Flatten`, `FlatMap`, `Chain`, `Zip`, `Fuse`).\n\nThis PR also makes `Take`s adapter fields private (I have no idea why they were `pub(super)` before).\n\nr? ``@LukasKalbertodt``", "tree": {"sha": "aed62afbeeaef07f6bf1cc9657e7238441397c80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aed62afbeeaef07f6bf1cc9657e7238441397c80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4407049fcbdc8fce56573a4271b90384a269abbc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfut+XCRBK7hj4Ov3rIwAAdHIIAEL4e0rqtikW/8uuPLkX6WCs\nbpD9pQjtthhhUHFvaDVXqL1mFF10NVDYrhtQ6ObblFAAovyCuTyaw6KF/VB5adXE\n7mI1g0QYFYRDrZVi3JSA2HoH5Le0FX+uHNi5v+GlCADVkQePI/ylYnYinCM27kPA\nnfF4a2T0Qx+rywKQLXwRtla7K0Ge6dQyc9cLhDdGnBK07NONY7Kq0kjYQJk598yd\n82wQeMbdPf5nLm9AfCsCSrxb9+wuMMUy9nGD2Dd08N6esT4gGsd3aH4fRYv48SFZ\nqYXCvZD0vy82kk2dUT4FV/cBrSpiGRLF12soGFrmX9KvaOdbVP4sVhyieDmiXNM=\n=2AWI\n-----END PGP SIGNATURE-----\n", "payload": "tree aed62afbeeaef07f6bf1cc9657e7238441397c80\nparent 9b98f1d226305913c7c205bd98b6ea6b9fe3b8ce\nparent 461265825bf8bf4382a428629a9bff9b6b1665e0\nauthor Mara Bos <m-ou.se@m-ou.se> 1606082455 +0100\ncommitter GitHub <noreply@github.com> 1606082455 +0100\n\nRollup merge of #77697 - WaffleLapkin:iter_split_adaptors, r=m-ou-se\n\nSplit each iterator adapter and source into individual modules\n\nThis PR creates individual modules for each iterator adapter and iterator source.\n\nThis is done to enhance the readability of corresponding modules (`adapters/mod.rs` and `sources.rs`) which were hard to navigate and read because of lots of repeated lines (e.g.: `adapters/mod.rs` was 3k lines long). This is also in line with some adapters which already had their own modules (`Flatten`, `FlatMap`, `Chain`, `Zip`, `Fuse`).\n\nThis PR also makes `Take`s adapter fields private (I have no idea why they were `pub(super)` before).\n\nr? ``@LukasKalbertodt``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4407049fcbdc8fce56573a4271b90384a269abbc", "html_url": "https://github.com/rust-lang/rust/commit/4407049fcbdc8fce56573a4271b90384a269abbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4407049fcbdc8fce56573a4271b90384a269abbc/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b98f1d226305913c7c205bd98b6ea6b9fe3b8ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b98f1d226305913c7c205bd98b6ea6b9fe3b8ce", "html_url": "https://github.com/rust-lang/rust/commit/9b98f1d226305913c7c205bd98b6ea6b9fe3b8ce"}, {"sha": "461265825bf8bf4382a428629a9bff9b6b1665e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/461265825bf8bf4382a428629a9bff9b6b1665e0", "html_url": "https://github.com/rust-lang/rust/commit/461265825bf8bf4382a428629a9bff9b6b1665e0"}], "stats": {"total": 7040, "additions": 3574, "deletions": 3466}, "files": [{"sha": "9753e1b43ba956aac96fc6c70d7c173ff316a4f4", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -1,6 +1,5 @@\n use crate::iter::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n-use crate::ops::Try;\n-use crate::usize;\n+use crate::{ops::Try, usize};\n \n /// An iterator that links two iterators together, in a chain.\n ///"}, {"sha": "7da47dcd2d1478d004d4042069f2b79f9fdc6181", "filename": "library/core/src/iter/adapters/cloned.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcloned.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,139 @@\n+use crate::iter::adapters::{zip::try_get_unchecked, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator that clones the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cloned`]: Iterator::cloned\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Cloned<I> {\n+    it: I,\n+}\n+\n+impl<I> Cloned<I> {\n+    pub(in crate::iter) fn new(it: I) -> Cloned<I> {\n+        Cloned { it }\n+    }\n+}\n+\n+fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, elt| f(acc, elt.clone())\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> Iterator for Cloned<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().cloned()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_fold(init, clone_try_fold(f))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.map(T::clone).fold(init, f)\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().cloned()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_rfold(init, clone_try_fold(f))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.map(T::clone).rfold(init, f)\n+    }\n+}\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Clone,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Cloned<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Clone,\n+{\n+}"}, {"sha": "46f22354111a642faf838d9af3864af99b71b5ec", "filename": "library/core/src/iter/adapters/copied.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcopied.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,155 @@\n+use crate::iter::adapters::{zip::try_get_unchecked, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator that copies the elements of an underlying iterator.\n+///\n+/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`copied`]: Iterator::copied\n+/// [`Iterator`]: trait.Iterator.html\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[derive(Clone, Debug)]\n+pub struct Copied<I> {\n+    it: I,\n+}\n+\n+impl<I> Copied<I> {\n+    pub(in crate::iter) fn new(it: I) -> Copied<I> {\n+        Copied { it }\n+    }\n+}\n+\n+fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n+    move |acc, &elt| f(acc, elt)\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> Iterator for Copied<I>\n+where\n+    I: Iterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.it.next().copied()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.it.size_hint()\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_fold(init, copy_try_fold(f))\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.fold(init, copy_fold(f))\n+    }\n+\n+    fn nth(&mut self, n: usize) -> Option<T> {\n+        self.it.nth(n).copied()\n+    }\n+\n+    fn last(self) -> Option<T> {\n+        self.it.last().copied()\n+    }\n+\n+    fn count(self) -> usize {\n+        self.it.count()\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        *unsafe { try_get_unchecked(&mut self.it, idx) }\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n+where\n+    I: DoubleEndedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn next_back(&mut self) -> Option<T> {\n+        self.it.next_back().copied()\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.it.try_rfold(init, copy_try_fold(f))\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.it.rfold(init, copy_fold(f))\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n+where\n+    I: ExactSizeIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+impl<'a, I, T: 'a> FusedIterator for Copied<I>\n+where\n+    I: FusedIterator<Item = &'a T>,\n+    T: Copy,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Copied<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n+where\n+    I: TrustedLen<Item = &'a T>,\n+    T: Copy,\n+{\n+}"}, {"sha": "6e9a011f819afce629cb5411aa86807aac47460a", "filename": "library/core/src/iter/adapters/cycle.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fcycle.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,87 @@\n+use crate::{iter::FusedIterator, ops::Try};\n+\n+/// An iterator that repeats endlessly.\n+///\n+/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`cycle`]: Iterator::cycle\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Cycle<I> {\n+    orig: I,\n+    iter: I,\n+}\n+\n+impl<I: Clone> Cycle<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Cycle<I> {\n+        Cycle { orig: iter.clone(), iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Cycle<I>\n+where\n+    I: Clone + Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        match self.iter.next() {\n+            None => {\n+                self.iter = self.orig.clone();\n+                self.iter.next()\n+            }\n+            y => y,\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        // the cycle iterator is either empty or infinite\n+        match self.orig.size_hint() {\n+            sz @ (0, Some(0)) => sz,\n+            (0, _) => (0, None),\n+            _ => (usize::MAX, None),\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // fully iterate the current iterator. this is necessary because\n+        // `self.iter` may be empty even when `self.orig` isn't\n+        acc = self.iter.try_fold(acc, &mut f)?;\n+        self.iter = self.orig.clone();\n+\n+        // complete a full cycle, keeping track of whether the cycled\n+        // iterator is empty or not. we need to return early in case\n+        // of an empty iterator to prevent an infinite loop\n+        let mut is_empty = true;\n+        acc = self.iter.try_fold(acc, |acc, x| {\n+            is_empty = false;\n+            f(acc, x)\n+        })?;\n+\n+        if is_empty {\n+            return try { acc };\n+        }\n+\n+        loop {\n+            self.iter = self.orig.clone();\n+            acc = self.iter.try_fold(acc, &mut f)?;\n+        }\n+    }\n+\n+    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n+    // and we can't do anything better than the default.\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}"}, {"sha": "5978c2da98c35796a3863e54712c6e110738ad49", "filename": "library/core/src/iter/adapters/enumerate.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fenumerate.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,238 @@\n+use crate::iter::adapters::{zip::try_get_unchecked, SourceIter, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::{Add, AddAssign, Try};\n+\n+/// An iterator that yields the current count and the element during iteration.\n+///\n+/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`enumerate`]: Iterator::enumerate\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Enumerate<I> {\n+    iter: I,\n+    count: usize,\n+}\n+impl<I> Enumerate<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Enumerate<I> {\n+        Enumerate { iter, count: 0 }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Enumerate<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    /// # Overflow Behavior\n+    ///\n+    /// The method does no guarding against overflows, so enumerating more than\n+    /// `usize::MAX` elements either produces the wrong result or panics. If\n+    /// debug assertions are enabled, a panic is guaranteed.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Might panic if the index of the element overflows a `usize`.\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.next()?;\n+        let i = self.count;\n+        // Possible undefined overflow.\n+        AddAssign::add_assign(&mut self.count, 1);\n+        Some((i, a))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n+        let a = self.iter.nth(n)?;\n+        // Possible undefined overflow.\n+        let i = Add::add(self.count, n);\n+        self.count = Add::add(i, 1);\n+        Some((i, a))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn enumerate<'a, T, Acc, R>(\n+            count: &'a mut usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> R + 'a {\n+            move |acc, item| {\n+                let acc = fold(acc, (*count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                let acc = fold(acc, (count, item));\n+                // Possible undefined overflow.\n+                AddAssign::add_assign(&mut count, 1);\n+                acc\n+            }\n+        }\n+\n+        self.iter.fold(init, enumerate(self.count, fold))\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n+        (Add::add(self.count, idx), value)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.next_back()?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n+        let a = self.iter.nth_back(n)?;\n+        let len = self.iter.len();\n+        // Can safely add, `ExactSizeIterator` promises that the number of\n+        // elements fits into a `usize`.\n+        Some((self.count + len, a))\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        fn enumerate<T, Acc, R>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n+        ) -> impl FnMut(Acc, T) -> R {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.try_rfold(init, enumerate(count, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n+        // that the number of elements fits into a `usize`.\n+        fn enumerate<T, Acc>(\n+            mut count: usize,\n+            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n+        ) -> impl FnMut(Acc, T) -> Acc {\n+            move |acc, item| {\n+                count -= 1;\n+                fold(acc, (count, item))\n+            }\n+        }\n+\n+        let count = self.count + self.iter.len();\n+        self.iter.rfold(init, enumerate(count, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Enumerate<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    fn may_have_side_effect() -> bool {\n+        I::may_have_side_effect()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}"}, {"sha": "f8d684fcdda46ca9d7c52cb770a947579fb54add", "filename": "library/core/src/iter/adapters/filter.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,152 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::Try;\n+\n+/// An iterator that filters the elements of `iter` with `predicate`.\n+///\n+/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter`]: Iterator::filter\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Filter<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+impl<I, P> Filter<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n+        Filter { iter, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn filter_fold<T, Acc>(\n+    mut predicate: impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n+}\n+\n+fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n+    predicate: &'a mut impl FnMut(&T) -> bool,\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        self.iter.find(&mut self.predicate)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    // this special case allows the compiler to make `.filter(_).count()`\n+    // branchless. Barring perfect branch prediction (which is unattainable in\n+    // the general case), this will be much faster in >90% of cases (containing\n+    // virtually all real workloads) and only a tiny bit slower in the rest.\n+    //\n+    // Having this specialization thus allows us to write `.filter(p).count()`\n+    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n+    // less readable and also less backwards-compatible to Rust before 1.10.\n+    //\n+    // Using the branchless version will also simplify the LLVM byte code, thus\n+    // leaving more budget for LLVM optimizations.\n+    #[inline]\n+    fn count(self) -> usize {\n+        #[inline]\n+        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n+            move |x| predicate(&x) as usize\n+        }\n+\n+        self.iter.map(to_usize(self.predicate)).sum()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, filter_fold(self.predicate, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        self.iter.rfind(&mut self.predicate)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, filter_fold(self.predicate, fold))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}"}, {"sha": "0dccf2c533b57e8f3455ad12d95c85bb7f790c2d", "filename": "library/core/src/iter/adapters/filter_map.rs", "status": "added", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffilter_map.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,150 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that uses `f` to both filter and map elements from `iter`.\n+///\n+/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`filter_map`]: Iterator::filter_map\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct FilterMap<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> FilterMap<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> FilterMap<I, F> {\n+        FilterMap { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn filter_map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => acc,\n+    }\n+}\n+\n+fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n+    f: &'a mut impl FnMut(T) -> Option<B>,\n+    mut fold: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| match f(item) {\n+        Some(x) => fold(acc, x),\n+        None => try { acc },\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.find_map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, filter_map_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        #[inline]\n+        fn find<T, B>(\n+            f: &mut impl FnMut(T) -> Option<B>,\n+        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n+            move |(), x| match f(x) {\n+                Some(x) => ControlFlow::Break(x),\n+                None => ControlFlow::CONTINUE,\n+            }\n+        }\n+\n+        self.iter.try_rfold((), find(&mut self.f)).break_value()\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, filter_map_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n+where\n+    F: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n+    F: FnMut(I::Item) -> Option<B>\n+{\n+}"}, {"sha": "ff85e114dc98262699267286c50691c033e7fab0", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -1,9 +1,7 @@\n use crate::fmt;\n+use crate::iter::{DoubleEndedIterator, Fuse, FusedIterator, Iterator, Map};\n use crate::ops::Try;\n \n-use super::super::{DoubleEndedIterator, Fuse, FusedIterator, Iterator};\n-use super::Map;\n-\n /// An iterator that maps each element to an iterator, and yields the elements\n /// of the produced iterators.\n ///\n@@ -14,8 +12,9 @@ use super::Map;\n pub struct FlatMap<I, U: IntoIterator, F> {\n     inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>,\n }\n+\n impl<I: Iterator, U: IntoIterator, F: FnMut(I::Item) -> U> FlatMap<I, U, F> {\n-    pub(in super::super) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> FlatMap<I, U, F> {\n         FlatMap { inner: FlattenCompat::new(iter.map(f)) }\n     }\n }"}, {"sha": "ae074065315935f8a96971d7c7ef845ab2fe3a53", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -1,9 +1,6 @@\n-use super::InPlaceIterable;\n use crate::intrinsics;\n-use crate::iter::adapters::zip::try_get_unchecked;\n-use crate::iter::adapters::SourceIter;\n-use crate::iter::TrustedRandomAccess;\n-use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n+use crate::iter::adapters::{zip::try_get_unchecked, InPlaceIterable, SourceIter};\n+use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedRandomAccess};\n use crate::ops::Try;\n \n /// An iterator that yields `None` forever after the underlying iterator"}, {"sha": "88f5ee61b6b7348b127f58c872d8d4a0673d8500", "filename": "library/core/src/iter/adapters/inspect.rs", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Finspect.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,167 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::Try;\n+\n+/// An iterator that calls a function with a reference to each element before\n+/// yielding it.\n+///\n+/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`inspect`]: Iterator::inspect\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Inspect<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Inspect<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> Inspect<I, F> {\n+        Inspect { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+impl<I: Iterator, F> Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n+        if let Some(ref a) = elt {\n+            (self.f)(a);\n+        }\n+\n+        elt\n+    }\n+}\n+\n+fn inspect_fold<T, Acc>(\n+    mut f: impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n+}\n+\n+fn inspect_try_fold<'a, T, Acc, R>(\n+    f: &'a mut impl FnMut(&T),\n+    mut fold: impl FnMut(Acc, T) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, item| {\n+        f(&item);\n+        fold(acc, item)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, F> Iterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, inspect_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<I::Item> {\n+        let next = self.iter.next_back();\n+        self.do_inspect(next)\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, inspect_fold(self.f, fold))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n+where\n+    F: FnMut(&I::Item),\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}"}, {"sha": "12673806ec40d5d2ad74e267545e3588a1a24d5a", "filename": "library/core/src/iter/adapters/map.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,213 @@\n+use crate::fmt;\n+use crate::iter::adapters::{zip::try_get_unchecked, SourceIter, TrustedRandomAccess};\n+use crate::iter::{FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator that maps the values of `iter` with `f`.\n+///\n+/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map`]: Iterator::map\n+/// [`Iterator`]: trait.Iterator.html\n+///\n+/// # Notes about side effects\n+///\n+/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n+/// you can also [`map`] backwards:\n+///\n+/// ```rust\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n+///\n+/// assert_eq!(v, [4, 3, 2]);\n+/// ```\n+///\n+/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n+///\n+/// But if your closure has state, iterating backwards may act in a way you do\n+/// not expect. Let's go through an example. First, in the forward direction:\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) }) {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+///\n+/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n+///\n+/// Now consider this twist where we add a call to `rev`. This version will\n+/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n+/// but the values of the counter still go in order. This is because `map()` is\n+/// still being called lazily on each item, but we are popping items off the\n+/// back of the vector now, instead of shifting them from the front.\n+///\n+/// ```rust\n+/// let mut c = 0;\n+///\n+/// for pair in vec!['a', 'b', 'c'].into_iter()\n+///                                .map(|letter| { c += 1; (letter, c) })\n+///                                .rev() {\n+///     println!(\"{:?}\", pair);\n+/// }\n+/// ```\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Map<I, F> {\n+    iter: I,\n+    f: F,\n+}\n+impl<I, F> Map<I, F> {\n+    pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n+        Map { iter, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+fn map_fold<T, B, Acc>(\n+    mut f: impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> Acc,\n+) -> impl FnMut(Acc, T) -> Acc {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+fn map_try_fold<'a, T, B, Acc, R>(\n+    f: &'a mut impl FnMut(T) -> B,\n+    mut g: impl FnMut(Acc, B) -> R + 'a,\n+) -> impl FnMut(Acc, T) -> R + 'a {\n+    move |acc, elt| g(acc, f(elt))\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: Iterator, F> Iterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        self.iter.next().map(&mut self.f)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n+    }\n+\n+    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, map_fold(self.f, g))\n+    }\n+\n+    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n+    where\n+        Self: TrustedRandomAccess,\n+    {\n+        // SAFETY: the caller must uphold the contract for\n+        // `Iterator::__iterator_get_unchecked`.\n+        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<B> {\n+        self.iter.next_back().map(&mut self.f)\n+    }\n+\n+    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n+    where\n+        Self: Sized,\n+        G: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n+    }\n+\n+    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n+    where\n+        G: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, map_fold(self.f, g))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<B, I, F> TrustedLen for Map<I, F>\n+where\n+    I: TrustedLen,\n+    F: FnMut(I::Item) -> B,\n+{\n+}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n+unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n+where\n+    I: TrustedRandomAccess,\n+{\n+    #[inline]\n+    fn may_have_side_effect() -> bool {\n+        true\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n+where\n+    F: FnMut(I::Item) -> B,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}"}, {"sha": "26114d5328498c39671b3dba3780cc9be94d0631", "filename": "library/core/src/iter/adapters/map_while.rs", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmap_while.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,101 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n+///\n+/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`map_while`]: Iterator::map_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+#[derive(Clone)]\n+pub struct MapWhile<I, P> {\n+    iter: I,\n+    predicate: P,\n+}\n+\n+impl<I, P> MapWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n+        MapWhile { iter, predicate }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let x = self.iter.next()?;\n+        (self.predicate)(x)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        let Self { iter, predicate } = self;\n+        iter.try_fold(init, |acc, x| match predicate(x) {\n+            Some(item) => ControlFlow::from_try(fold(acc, item)),\n+            None => ControlFlow::Break(try { acc }),\n+        })\n+        .into_try()\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n+where\n+    P: FnMut(I::Item) -> Option<B>,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n+    P: FnMut(I::Item) -> Option<B>\n+{\n+}"}, {"sha": "5ef5717085e4ffb403e1f54783eb0c30bce62da5", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 40, "deletions": 2819, "changes": 2859, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -1,26 +1,51 @@\n-use crate::cmp;\n-use crate::fmt;\n-use crate::intrinsics;\n-use crate::ops::{Add, AddAssign, ControlFlow, Try};\n-\n-use super::from_fn;\n-use super::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, TrustedLen,\n-};\n+use crate::iter::{InPlaceIterable, Iterator};\n+use crate::ops::{ControlFlow, Try};\n \n mod chain;\n+mod cloned;\n+mod copied;\n+mod cycle;\n+mod enumerate;\n+mod filter;\n+mod filter_map;\n mod flatten;\n mod fuse;\n+mod inspect;\n+mod map;\n+mod map_while;\n+mod peekable;\n+mod rev;\n+mod scan;\n+mod skip;\n+mod skip_while;\n+mod step_by;\n+mod take;\n+mod take_while;\n mod zip;\n \n-pub use self::chain::Chain;\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::flatten::{FlatMap, Flatten};\n-pub use self::fuse::Fuse;\n-use self::zip::try_get_unchecked;\n+pub use self::{\n+    chain::Chain, cycle::Cycle, enumerate::Enumerate, filter::Filter, filter_map::FilterMap,\n+    flatten::FlatMap, fuse::Fuse, inspect::Inspect, map::Map, peekable::Peekable, rev::Rev,\n+    scan::Scan, skip::Skip, skip_while::SkipWhile, take::Take, take_while::TakeWhile, zip::Zip,\n+};\n+\n+#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n+pub use self::cloned::Cloned;\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+pub use self::step_by::StepBy;\n+\n+#[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n+pub use self::flatten::Flatten;\n+\n+#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n+pub use self::copied::Copied;\n+\n+#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n+pub use self::map_while::MapWhile;\n+\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n pub use self::zip::TrustedRandomAccess;\n-pub use self::zip::Zip;\n \n /// This trait provides transitive access to source-stage in an interator-adapter pipeline\n /// under the conditions that\n@@ -89,2810 +114,6 @@ pub unsafe trait SourceIter {\n     unsafe fn as_inner(&mut self) -> &mut Self::Source;\n }\n \n-/// A double-ended iterator with the direction inverted.\n-///\n-/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`rev`]: Iterator::rev\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Rev<T> {\n-    iter: T,\n-}\n-impl<T> Rev<T> {\n-    pub(super) fn new(iter: T) -> Rev<T> {\n-        Rev { iter }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Rev<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next_back()\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n-        self.iter.advance_back_by(n)\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth_back(n)\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.iter.try_rfold(init, f)\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, f)\n-    }\n-\n-    #[inline]\n-    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.iter.rfind(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Rev<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n-        self.iter.next()\n-    }\n-\n-    #[inline]\n-    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n-        self.iter.advance_by(n)\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n-        self.iter.nth(n)\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.iter.try_fold(init, f)\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, f)\n-    }\n-\n-    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n-    where\n-        P: FnMut(&Self::Item) -> bool,\n-    {\n-        self.iter.find(predicate)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Rev<I>\n-where\n-    I: ExactSizeIterator + DoubleEndedIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}\n-\n-/// An iterator that copies the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`copied`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`copied`]: Iterator::copied\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Copied<I> {\n-    it: I,\n-}\n-\n-impl<I> Copied<I> {\n-    pub(super) fn new(it: I) -> Copied<I> {\n-        Copied { it }\n-    }\n-}\n-\n-fn copy_fold<T: Copy, Acc>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, &T) -> Acc {\n-    move |acc, &elt| f(acc, elt)\n-}\n-\n-fn copy_try_fold<T: Copy, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n-    move |acc, &elt| f(acc, elt)\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> Iterator for Copied<I>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().copied()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_fold(init, copy_try_fold(f))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.fold(init, copy_fold(f))\n-    }\n-\n-    fn nth(&mut self, n: usize) -> Option<T> {\n-        self.it.nth(n).copied()\n-    }\n-\n-    fn last(self) -> Option<T> {\n-        self.it.last().copied()\n-    }\n-\n-    fn count(self) -> usize {\n-        self.it.count()\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        *unsafe { try_get_unchecked(&mut self.it, idx) }\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Copied<I>\n-where\n-    I: DoubleEndedIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().copied()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_rfold(init, copy_try_fold(f))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.rfold(init, copy_fold(f))\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Copied<I>\n-where\n-    I: ExactSizeIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Copied<I>\n-where\n-    I: FusedIterator<Item = &'a T>,\n-    T: Copy,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Copied<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Copied<I>\n-where\n-    I: TrustedLen<Item = &'a T>,\n-    T: Copy,\n-{\n-}\n-\n-/// An iterator that clones the elements of an underlying iterator.\n-///\n-/// This `struct` is created by the [`cloned`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cloned`]: Iterator::cloned\n-/// [`Iterator`]: trait.Iterator.html\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[derive(Clone, Debug)]\n-pub struct Cloned<I> {\n-    it: I,\n-}\n-impl<I> Cloned<I> {\n-    pub(super) fn new(it: I) -> Cloned<I> {\n-        Cloned { it }\n-    }\n-}\n-\n-fn clone_try_fold<T: Clone, Acc, R>(mut f: impl FnMut(Acc, T) -> R) -> impl FnMut(Acc, &T) -> R {\n-    move |acc, elt| f(acc, elt.clone())\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> Iterator for Cloned<I>\n-where\n-    I: Iterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.it.next().cloned()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.it.size_hint()\n-    }\n-\n-    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_fold(init, clone_try_fold(f))\n-    }\n-\n-    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.map(T::clone).fold(init, f)\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> T\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { try_get_unchecked(&mut self.it, idx).clone() }\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n-where\n-    I: DoubleEndedIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    fn next_back(&mut self) -> Option<T> {\n-        self.it.next_back().cloned()\n-    }\n-\n-    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        self.it.try_rfold(init, clone_try_fold(f))\n-    }\n-\n-    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.it.map(T::clone).rfold(init, f)\n-    }\n-}\n-\n-#[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n-impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n-where\n-    I: ExactSizeIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-    fn len(&self) -> usize {\n-        self.it.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.it.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n-where\n-    I: FusedIterator<Item = &'a T>,\n-    T: Clone,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Cloned<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, I, T: 'a> TrustedLen for Cloned<I>\n-where\n-    I: TrustedLen<Item = &'a T>,\n-    T: Clone,\n-{\n-}\n-\n-/// An iterator that repeats endlessly.\n-///\n-/// This `struct` is created by the [`cycle`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`cycle`]: Iterator::cycle\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Cycle<I> {\n-    orig: I,\n-    iter: I,\n-}\n-impl<I: Clone> Cycle<I> {\n-    pub(super) fn new(iter: I) -> Cycle<I> {\n-        Cycle { orig: iter.clone(), iter }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Cycle<I>\n-where\n-    I: Clone + Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        match self.iter.next() {\n-            None => {\n-                self.iter = self.orig.clone();\n-                self.iter.next()\n-            }\n-            y => y,\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        // the cycle iterator is either empty or infinite\n-        match self.orig.size_hint() {\n-            sz @ (0, Some(0)) => sz,\n-            (0, _) => (0, None),\n-            _ => (usize::MAX, None),\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        // fully iterate the current iterator. this is necessary because\n-        // `self.iter` may be empty even when `self.orig` isn't\n-        acc = self.iter.try_fold(acc, &mut f)?;\n-        self.iter = self.orig.clone();\n-\n-        // complete a full cycle, keeping track of whether the cycled\n-        // iterator is empty or not. we need to return early in case\n-        // of an empty iterator to prevent an infinite loop\n-        let mut is_empty = true;\n-        acc = self.iter.try_fold(acc, |acc, x| {\n-            is_empty = false;\n-            f(acc, x)\n-        })?;\n-\n-        if is_empty {\n-            return try { acc };\n-        }\n-\n-        loop {\n-            self.iter = self.orig.clone();\n-            acc = self.iter.try_fold(acc, &mut f)?;\n-        }\n-    }\n-\n-    // No `fold` override, because `fold` doesn't make much sense for `Cycle`,\n-    // and we can't do anything better than the default.\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Cycle<I> where I: Clone + Iterator {}\n-\n-/// An iterator for stepping iterators by a custom amount.\n-///\n-/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n-/// its documentation for more.\n-///\n-/// [`step_by`]: Iterator::step_by\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-#[derive(Clone, Debug)]\n-pub struct StepBy<I> {\n-    iter: I,\n-    step: usize,\n-    first_take: bool,\n-}\n-impl<I> StepBy<I> {\n-    pub(super) fn new(iter: I, step: usize) -> StepBy<I> {\n-        assert!(step != 0);\n-        StepBy { iter, step: step - 1, first_take: true }\n-    }\n-}\n-\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> Iterator for StepBy<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            self.iter.next()\n-        } else {\n-            self.iter.nth(self.step)\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        #[inline]\n-        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n-            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n-        }\n-\n-        #[inline]\n-        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n-            move |n| n / (step + 1)\n-        }\n-\n-        let (low, high) = self.iter.size_hint();\n-\n-        if self.first_take {\n-            let f = first_size(self.step);\n-            (f(low), high.map(f))\n-        } else {\n-            let f = other_size(self.step);\n-            (f(low), high.map(f))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n-        if self.first_take {\n-            self.first_take = false;\n-            let first = self.iter.next();\n-            if n == 0 {\n-                return first;\n-            }\n-            n -= 1;\n-        }\n-        // n and self.step are indices, we need to add 1 to get the amount of elements\n-        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n-        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n-        let mut step = self.step + 1;\n-        // n + 1 could overflow\n-        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n-        if n == usize::MAX {\n-            self.iter.nth(step - 1);\n-        } else {\n-            n += 1;\n-        }\n-\n-        // overflow handling\n-        loop {\n-            let mul = n.checked_mul(step);\n-            {\n-                if intrinsics::likely(mul.is_some()) {\n-                    return self.iter.nth(mul.unwrap() - 1);\n-                }\n-            }\n-            let div_n = usize::MAX / n;\n-            let div_step = usize::MAX / step;\n-            let nth_n = div_n * n;\n-            let nth_step = div_step * step;\n-            let nth = if nth_n > nth_step {\n-                step -= div_n;\n-                nth_n\n-            } else {\n-                n -= div_step;\n-                nth_step\n-            };\n-            self.iter.nth(nth - 1);\n-        }\n-    }\n-\n-    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth(step)\n-        }\n-\n-        if self.first_take {\n-            self.first_take = false;\n-            match self.iter.next() {\n-                None => return try { acc },\n-                Some(x) => acc = f(acc, x)?,\n-            }\n-        }\n-        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n-    }\n-\n-    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n-    where\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth(step)\n-        }\n-\n-        if self.first_take {\n-            self.first_take = false;\n-            match self.iter.next() {\n-                None => return acc,\n-                Some(x) => acc = f(acc, x),\n-            }\n-        }\n-        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n-    }\n-}\n-\n-impl<I> StepBy<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    // The zero-based index starting from the end of the iterator of the\n-    // last element. Used in the `DoubleEndedIterator` implementation.\n-    fn next_back_index(&self) -> usize {\n-        let rem = self.iter.len() % (self.step + 1);\n-        if self.first_take {\n-            if rem == 0 { self.step } else { rem - 1 }\n-        } else {\n-            rem\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for StepBy<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        self.iter.nth_back(self.next_back_index())\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n-        // is out of bounds because the length of `self.iter` does not exceed\n-        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n-        // zero-indexed\n-        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n-        self.iter.nth_back(n)\n-    }\n-\n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n-    where\n-        F: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn nth_back<I: DoubleEndedIterator>(\n-            iter: &mut I,\n-            step: usize,\n-        ) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth_back(step)\n-        }\n-\n-        match self.next_back() {\n-            None => try { init },\n-            Some(x) => {\n-                let acc = f(init, x)?;\n-                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n-    where\n-        Self: Sized,\n-        F: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn nth_back<I: DoubleEndedIterator>(\n-            iter: &mut I,\n-            step: usize,\n-        ) -> impl FnMut() -> Option<I::Item> + '_ {\n-            move || iter.nth_back(step)\n-        }\n-\n-        match self.next_back() {\n-            None => init,\n-            Some(x) => {\n-                let acc = f(init, x);\n-                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n-            }\n-        }\n-    }\n-}\n-\n-// StepBy can only make the iterator shorter, so the len will still fit.\n-#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n-impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}\n-\n-/// An iterator that maps the values of `iter` with `f`.\n-///\n-/// This `struct` is created by the [`map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map`]: Iterator::map\n-/// [`Iterator`]: trait.Iterator.html\n-///\n-/// # Notes about side effects\n-///\n-/// The [`map`] iterator implements [`DoubleEndedIterator`], meaning that\n-/// you can also [`map`] backwards:\n-///\n-/// ```rust\n-/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n-///\n-/// assert_eq!(v, [4, 3, 2]);\n-/// ```\n-///\n-/// [`DoubleEndedIterator`]: trait.DoubleEndedIterator.html\n-///\n-/// But if your closure has state, iterating backwards may act in a way you do\n-/// not expect. Let's go through an example. First, in the forward direction:\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) }) {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-///\n-/// This will print \"('a', 1), ('b', 2), ('c', 3)\".\n-///\n-/// Now consider this twist where we add a call to `rev`. This version will\n-/// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n-/// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazily on each item, but we are popping items off the\n-/// back of the vector now, instead of shifting them from the front.\n-///\n-/// ```rust\n-/// let mut c = 0;\n-///\n-/// for pair in vec!['a', 'b', 'c'].into_iter()\n-///                                .map(|letter| { c += 1; (letter, c) })\n-///                                .rev() {\n-///     println!(\"{:?}\", pair);\n-/// }\n-/// ```\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Map<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> Map<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> Map<I, F> {\n-        Map { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Map<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Map\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn map_fold<T, B, Acc>(\n-    mut f: impl FnMut(T) -> B,\n-    mut g: impl FnMut(Acc, B) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, elt| g(acc, f(elt))\n-}\n-\n-fn map_try_fold<'a, T, B, Acc, R>(\n-    f: &'a mut impl FnMut(T) -> B,\n-    mut g: impl FnMut(Acc, B) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, elt| g(acc, f(elt))\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.next().map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    fn try_fold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n-    where\n-        Self: Sized,\n-        G: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, map_try_fold(&mut self.f, g))\n-    }\n-\n-    fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n-    where\n-        G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, map_fold(self.f, g))\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> B\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        unsafe { (self.f)(try_get_unchecked(&mut self.iter, idx)) }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        self.iter.next_back().map(&mut self.f)\n-    }\n-\n-    fn try_rfold<Acc, G, R>(&mut self, init: Acc, g: G) -> R\n-    where\n-        Self: Sized,\n-        G: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, map_try_fold(&mut self.f, g))\n-    }\n-\n-    fn rfold<Acc, G>(self, init: Acc, g: G) -> Acc\n-    where\n-        G: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, map_fold(self.f, g))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for Map<I, F> where F: FnMut(I::Item) -> B {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<B, I, F> TrustedLen for Map<I, F>\n-where\n-    I: TrustedLen,\n-    F: FnMut(I::Item) -> B,\n-{\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I, F> TrustedRandomAccess for Map<I, F>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    #[inline]\n-    fn may_have_side_effect() -> bool {\n-        true\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for Map<I, F>\n-where\n-    F: FnMut(I::Item) -> B,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for Map<I, F> where F: FnMut(I::Item) -> B {}\n-\n-/// An iterator that filters the elements of `iter` with `predicate`.\n-///\n-/// This `struct` is created by the [`filter`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter`]: Iterator::filter\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Filter<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-impl<I, P> Filter<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> Filter<I, P> {\n-        Filter { iter, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for Filter<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Filter\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn filter_fold<T, Acc>(\n-    mut predicate: impl FnMut(&T) -> bool,\n-    mut fold: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { acc }\n-}\n-\n-fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n-    predicate: &'a mut impl FnMut(&T) -> bool,\n-    mut fold: impl FnMut(Acc, T) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        self.iter.find(&mut self.predicate)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    // this special case allows the compiler to make `.filter(_).count()`\n-    // branchless. Barring perfect branch prediction (which is unattainable in\n-    // the general case), this will be much faster in >90% of cases (containing\n-    // virtually all real workloads) and only a tiny bit slower in the rest.\n-    //\n-    // Having this specialization thus allows us to write `.filter(p).count()`\n-    // where we would otherwise write `.map(|x| p(x) as usize).sum()`, which is\n-    // less readable and also less backwards-compatible to Rust before 1.10.\n-    //\n-    // Using the branchless version will also simplify the LLVM byte code, thus\n-    // leaving more budget for LLVM optimizations.\n-    #[inline]\n-    fn count(self) -> usize {\n-        #[inline]\n-        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n-            move |x| predicate(&x) as usize\n-        }\n-\n-        self.iter.map(to_usize(self.predicate)).sum()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, filter_try_fold(&mut self.predicate, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, filter_fold(self.predicate, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, P> DoubleEndedIterator for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        self.iter.rfind(&mut self.predicate)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, filter_try_fold(&mut self.predicate, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, filter_fold(self.predicate, fold))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, P> FusedIterator for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for Filter<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, P> InPlaceIterable for Filter<I, P> where P: FnMut(&I::Item) -> bool {}\n-\n-/// An iterator that uses `f` to both filter and map elements from `iter`.\n-///\n-/// This `struct` is created by the [`filter_map`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`filter_map`]: Iterator::filter_map\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct FilterMap<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> FilterMap<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> FilterMap<I, F> {\n-        FilterMap { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for FilterMap<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FilterMap\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-fn filter_map_fold<T, B, Acc>(\n-    mut f: impl FnMut(T) -> Option<B>,\n-    mut fold: impl FnMut(Acc, B) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| match f(item) {\n-        Some(x) => fold(acc, x),\n-        None => acc,\n-    }\n-}\n-\n-fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n-    f: &'a mut impl FnMut(T) -> Option<B>,\n-    mut fold: impl FnMut(Acc, B) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| match f(item) {\n-        Some(x) => fold(acc, x),\n-        None => try { acc },\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: Iterator, F> Iterator for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        self.iter.find_map(&mut self.f)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, filter_map_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, filter_map_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<B> {\n-        #[inline]\n-        fn find<T, B>(\n-            f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n-            move |(), x| match f(x) {\n-                Some(x) => ControlFlow::Break(x),\n-                None => ControlFlow::CONTINUE,\n-            }\n-        }\n-\n-        self.iter.try_rfold((), find(&mut self.f)).break_value()\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, filter_map_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, filter_map_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<B, I: FusedIterator, F> FusedIterator for FilterMap<I, F> where F: FnMut(I::Item) -> Option<B> {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, F> SourceIter for FilterMap<I, F>\n-where\n-    F: FnMut(I::Item) -> Option<B>,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, F> InPlaceIterable for FilterMap<I, F> where\n-    F: FnMut(I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that yields the current count and the element during iteration.\n-///\n-/// This `struct` is created by the [`enumerate`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`enumerate`]: Iterator::enumerate\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Enumerate<I> {\n-    iter: I,\n-    count: usize,\n-}\n-impl<I> Enumerate<I> {\n-    pub(super) fn new(iter: I) -> Enumerate<I> {\n-        Enumerate { iter, count: 0 }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Enumerate<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = (usize, <I as Iterator>::Item);\n-\n-    /// # Overflow Behavior\n-    ///\n-    /// The method does no guarding against overflows, so enumerating more than\n-    /// `usize::MAX` elements either produces the wrong result or panics. If\n-    /// debug assertions are enabled, a panic is guaranteed.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Might panic if the index of the element overflows a `usize`.\n-    #[inline]\n-    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.next()?;\n-        let i = self.count;\n-        // Possible undefined overflow.\n-        AddAssign::add_assign(&mut self.count, 1);\n-        Some((i, a))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<(usize, I::Item)> {\n-        let a = self.iter.nth(n)?;\n-        // Possible undefined overflow.\n-        let i = Add::add(self.count, n);\n-        self.count = Add::add(i, 1);\n-        Some((i, a))\n-    }\n-\n-    #[inline]\n-    fn count(self) -> usize {\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        #[inline]\n-        fn enumerate<'a, T, Acc, R>(\n-            count: &'a mut usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> R + 'a {\n-            move |acc, item| {\n-                let acc = fold(acc, (*count, item));\n-                // Possible undefined overflow.\n-                AddAssign::add_assign(count, 1);\n-                acc\n-            }\n-        }\n-\n-        self.iter.try_fold(init, enumerate(&mut self.count, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn enumerate<T, Acc>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n-        ) -> impl FnMut(Acc, T) -> Acc {\n-            move |acc, item| {\n-                let acc = fold(acc, (count, item));\n-                // Possible undefined overflow.\n-                AddAssign::add_assign(&mut count, 1);\n-                acc\n-            }\n-        }\n-\n-        self.iter.fold(init, enumerate(self.count, fold))\n-    }\n-\n-    unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> <Self as Iterator>::Item\n-    where\n-        Self: TrustedRandomAccess,\n-    {\n-        // SAFETY: the caller must uphold the contract for\n-        // `Iterator::__iterator_get_unchecked`.\n-        let value = unsafe { try_get_unchecked(&mut self.iter, idx) };\n-        (Add::add(self.count, idx), value)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> DoubleEndedIterator for Enumerate<I>\n-where\n-    I: ExactSizeIterator + DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.next_back()?;\n-        let len = self.iter.len();\n-        // Can safely add, `ExactSizeIterator` promises that the number of\n-        // elements fits into a `usize`.\n-        Some((self.count + len, a))\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<(usize, <I as Iterator>::Item)> {\n-        let a = self.iter.nth_back(n)?;\n-        let len = self.iter.len();\n-        // Can safely add, `ExactSizeIterator` promises that the number of\n-        // elements fits into a `usize`.\n-        Some((self.count + len, a))\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        fn enumerate<T, Acc, R>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> R,\n-        ) -> impl FnMut(Acc, T) -> R {\n-            move |acc, item| {\n-                count -= 1;\n-                fold(acc, (count, item))\n-            }\n-        }\n-\n-        let count = self.count + self.iter.len();\n-        self.iter.try_rfold(init, enumerate(count, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        // Can safely add and subtract the count, as `ExactSizeIterator` promises\n-        // that the number of elements fits into a `usize`.\n-        fn enumerate<T, Acc>(\n-            mut count: usize,\n-            mut fold: impl FnMut(Acc, (usize, T)) -> Acc,\n-        ) -> impl FnMut(Acc, T) -> Acc {\n-            move |acc, item| {\n-                count -= 1;\n-                fold(acc, (count, item))\n-            }\n-        }\n-\n-        let count = self.count + self.iter.len();\n-        self.iter.rfold(init, enumerate(count, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I>\n-where\n-    I: ExactSizeIterator,\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[doc(hidden)]\n-#[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n-unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n-where\n-    I: TrustedRandomAccess,\n-{\n-    fn may_have_side_effect() -> bool {\n-        I::may_have_side_effect()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Enumerate<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Enumerate<I> where I: TrustedLen {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Enumerate<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Enumerate<I> {}\n-\n-/// An iterator with a `peek()` that returns an optional reference to the next\n-/// element.\n-///\n-/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`peekable`]: Iterator::peekable\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Peekable<I: Iterator> {\n-    iter: I,\n-    /// Remember a peeked value, even if it was None.\n-    peeked: Option<Option<I::Item>>,\n-}\n-impl<I: Iterator> Peekable<I> {\n-    pub(super) fn new(iter: I) -> Peekable<I> {\n-        Peekable { iter, peeked: None }\n-    }\n-}\n-\n-// Peekable must remember if a None has been seen in the `.peek()` method.\n-// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n-// underlying iterator at most once. This does not by itself make the iterator\n-// fused.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator> Iterator for Peekable<I> {\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(v) => v,\n-            None => self.iter.next(),\n-        }\n-    }\n-\n-    #[inline]\n-    #[rustc_inherit_overflow_checks]\n-    fn count(mut self) -> usize {\n-        match self.peeked.take() {\n-            Some(None) => 0,\n-            Some(Some(_)) => 1 + self.iter.count(),\n-            None => self.iter.count(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        match self.peeked.take() {\n-            Some(None) => None,\n-            Some(v @ Some(_)) if n == 0 => v,\n-            Some(Some(_)) => self.iter.nth(n - 1),\n-            None => self.iter.nth(n),\n-        }\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        let peek_opt = match self.peeked.take() {\n-            Some(None) => return None,\n-            Some(v) => v,\n-            None => None,\n-        };\n-        self.iter.last().or(peek_opt)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let peek_len = match self.peeked {\n-            Some(None) => return (0, Some(0)),\n-            Some(Some(_)) => 1,\n-            None => 0,\n-        };\n-        let (lo, hi) = self.iter.size_hint();\n-        let lo = lo.saturating_add(peek_len);\n-        let hi = match hi {\n-            Some(x) => x.checked_add(peek_len),\n-            None => None,\n-        };\n-        (lo, hi)\n-    }\n-\n-    #[inline]\n-    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        let acc = match self.peeked.take() {\n-            Some(None) => return try { init },\n-            Some(Some(v)) => f(init, v)?,\n-            None => init,\n-        };\n-        self.iter.try_fold(acc, f)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        let acc = match self.peeked {\n-            Some(None) => return init,\n-            Some(Some(v)) => fold(init, v),\n-            None => init,\n-        };\n-        self.iter.fold(acc, fold)\n-    }\n-}\n-\n-#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Peekable<I>\n-where\n-    I: DoubleEndedIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        match self.peeked.as_mut() {\n-            Some(v @ Some(_)) => self.iter.next_back().or_else(|| v.take()),\n-            Some(None) => None,\n-            None => self.iter.next_back(),\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n-    where\n-        Self: Sized,\n-        F: FnMut(B, Self::Item) -> R,\n-        R: Try<Ok = B>,\n-    {\n-        match self.peeked.take() {\n-            Some(None) => try { init },\n-            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n-                Ok(acc) => f(acc, v),\n-                Err(e) => {\n-                    self.peeked = Some(Some(v));\n-                    Try::from_error(e)\n-                }\n-            },\n-            None => self.iter.try_rfold(init, f),\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        match self.peeked {\n-            Some(None) => init,\n-            Some(Some(v)) => {\n-                let acc = self.iter.rfold(init, &mut fold);\n-                fold(acc, v)\n-            }\n-            None => self.iter.rfold(init, fold),\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n-\n-impl<I: Iterator> Peekable<I> {\n-    /// Returns a reference to the next() value without advancing the iterator.\n-    ///\n-    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n-    /// But if the iteration is over, `None` is returned.\n-    ///\n-    /// [`next`]: Iterator::next\n-    ///\n-    /// Because `peek()` returns a reference, and many iterators iterate over\n-    /// references, there can be a possibly confusing situation where the\n-    /// return value is a double reference. You can see this effect in the\n-    /// examples below.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// let xs = [1, 2, 3];\n-    ///\n-    /// let mut iter = xs.iter().peekable();\n-    ///\n-    /// // peek() lets us see into the future\n-    /// assert_eq!(iter.peek(), Some(&&1));\n-    /// assert_eq!(iter.next(), Some(&1));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&2));\n-    ///\n-    /// // The iterator does not advance even if we `peek` multiple times\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    /// assert_eq!(iter.peek(), Some(&&3));\n-    ///\n-    /// assert_eq!(iter.next(), Some(&3));\n-    ///\n-    /// // After the iterator is finished, so is `peek()`\n-    /// assert_eq!(iter.peek(), None);\n-    /// assert_eq!(iter.next(), None);\n-    /// ```\n-    #[inline]\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn peek(&mut self) -> Option<&I::Item> {\n-        let iter = &mut self.iter;\n-        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n-    }\n-\n-    /// Consume and return the next value of this iterator if a condition is true.\n-    ///\n-    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n-    /// Otherwise, return `None`.\n-    ///\n-    /// # Examples\n-    /// Consume a number if it's equal to 0.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (0..5).peekable();\n-    /// // The first item of the iterator is 0; consume it.\n-    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n-    /// // The next item returned is now 1, so `consume` will return `false`.\n-    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n-    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// ```\n-    ///\n-    /// Consume any number less than 10.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (1..20).peekable();\n-    /// // Consume all numbers less than 10\n-    /// while iter.next_if(|&x| x < 10).is_some() {}\n-    /// // The next value returned will be 10\n-    /// assert_eq!(iter.next(), Some(10));\n-    /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n-    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n-        match self.next() {\n-            Some(matched) if func(&matched) => Some(matched),\n-            other => {\n-                // Since we called `self.next()`, we consumed `self.peeked`.\n-                assert!(self.peeked.is_none());\n-                self.peeked = Some(other);\n-                None\n-            }\n-        }\n-    }\n-\n-    /// Consume and return the next item if it is equal to `expected`.\n-    ///\n-    /// # Example\n-    /// Consume a number if it's equal to 0.\n-    /// ```\n-    /// #![feature(peekable_next_if)]\n-    /// let mut iter = (0..5).peekable();\n-    /// // The first item of the iterator is 0; consume it.\n-    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n-    /// // The next item returned is now 1, so `consume` will return `false`.\n-    /// assert_eq!(iter.next_if_eq(&0), None);\n-    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n-    /// assert_eq!(iter.next(), Some(1));\n-    /// ```\n-    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n-    pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n-    where\n-        T: ?Sized,\n-        I::Item: PartialEq<T>,\n-    {\n-        self.next_if(|next| next == expected)\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}\n-\n-/// An iterator that rejects elements while `predicate` returns `true`.\n-///\n-/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip_while`]: Iterator::skip_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct SkipWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-impl<I, P> SkipWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n-        SkipWhile { iter, flag: false, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        fn check<'a, T>(\n-            flag: &'a mut bool,\n-            pred: &'a mut impl FnMut(&T) -> bool,\n-        ) -> impl FnMut(&T) -> bool + 'a {\n-            move |x| {\n-                if *flag || !pred(x) {\n-                    *flag = true;\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-        }\n-\n-        let flag = &mut self.flag;\n-        let pred = &mut self.predicate;\n-        self.iter.find(check(flag, pred))\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v)?,\n-                None => return try { init },\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if !self.flag {\n-            match self.next() {\n-                Some(v) => init = fold(init, v),\n-                None => return init,\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for SkipWhile<I, P>\n-where\n-    I: FusedIterator,\n-    P: FnMut(&I::Item) -> bool,\n-{\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n-    F: FnMut(&I::Item) -> bool\n-{\n-}\n-\n-/// An iterator that only accepts elements while `predicate` returns `true`.\n-///\n-/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take_while`]: Iterator::take_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct TakeWhile<I, P> {\n-    iter: I,\n-    flag: bool,\n-    predicate: P,\n-}\n-impl<I, P> TakeWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n-        TakeWhile { iter, flag: false, predicate }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.flag {\n-            None\n-        } else {\n-            let x = self.iter.next()?;\n-            if (self.predicate)(&x) {\n-                Some(x)\n-            } else {\n-                self.flag = true;\n-                None\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.flag {\n-            (0, Some(0))\n-        } else {\n-            let (_, upper) = self.iter.size_hint();\n-            (0, upper) // can't know a lower bound, due to the predicate\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n-            flag: &'a mut bool,\n-            p: &'a mut impl FnMut(&T) -> bool,\n-            mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| {\n-                if p(&x) {\n-                    ControlFlow::from_try(fold(acc, x))\n-                } else {\n-                    *flag = true;\n-                    ControlFlow::Break(try { acc })\n-                }\n-            }\n-        }\n-\n-        if self.flag {\n-            try { init }\n-        } else {\n-            let flag = &mut self.flag;\n-            let p = &mut self.predicate;\n-            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n-        }\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I, P> FusedIterator for TakeWhile<I, P>\n-where\n-    I: FusedIterator,\n-    P: FnMut(&I::Item) -> bool,\n-{\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n-where\n-    P: FnMut(&I::Item) -> bool,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n-    F: FnMut(&I::Item) -> bool\n-{\n-}\n-\n-/// An iterator that only accepts elements while `predicate` returns `Some(_)`.\n-///\n-/// This `struct` is created by the [`map_while`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`map_while`]: Iterator::map_while\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-#[derive(Clone)]\n-pub struct MapWhile<I, P> {\n-    iter: I,\n-    predicate: P,\n-}\n-\n-impl<I, P> MapWhile<I, P> {\n-    pub(super) fn new(iter: I, predicate: P) -> MapWhile<I, P> {\n-        MapWhile { iter, predicate }\n-    }\n-}\n-\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-impl<I: fmt::Debug, P> fmt::Debug for MapWhile<I, P> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"MapWhile\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-#[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n-impl<B, I: Iterator, P> Iterator for MapWhile<I, P>\n-where\n-    P: FnMut(I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        let x = self.iter.next()?;\n-        (self.predicate)(x)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the predicate\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, mut fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        let Self { iter, predicate } = self;\n-        iter.try_fold(init, |acc, x| match predicate(x) {\n-            Some(item) => ControlFlow::from_try(fold(acc, item)),\n-            None => ControlFlow::Break(try { acc }),\n-        })\n-        .into_try()\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, B, I: Iterator, P> SourceIter for MapWhile<I, P>\n-where\n-    P: FnMut(I::Item) -> Option<B>,\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<B, I: InPlaceIterable, P> InPlaceIterable for MapWhile<I, P> where\n-    P: FnMut(I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that skips over `n` elements of `iter`.\n-///\n-/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`skip`]: Iterator::skip\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Skip<I> {\n-    iter: I,\n-    n: usize,\n-}\n-impl<I> Skip<I> {\n-    pub(super) fn new(iter: I, n: usize) -> Skip<I> {\n-        Skip { iter, n }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Skip<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        if self.n == 0 {\n-            self.iter.next()\n-        } else {\n-            let old_n = self.n;\n-            self.n = 0;\n-            self.iter.nth(old_n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        // Can't just add n + self.n due to overflow.\n-        if self.n > 0 {\n-            let to_skip = self.n;\n-            self.n = 0;\n-            // nth(n) skips n+1\n-            self.iter.nth(to_skip - 1)?;\n-        }\n-        self.iter.nth(n)\n-    }\n-\n-    #[inline]\n-    fn count(mut self) -> usize {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return 0;\n-            }\n-        }\n-        self.iter.count()\n-    }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<I::Item> {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            self.iter.nth(self.n - 1)?;\n-        }\n-        self.iter.last()\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = lower.saturating_sub(self.n);\n-        let upper = match upper {\n-            Some(x) => Some(x.saturating_sub(self.n)),\n-            None => None,\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        let n = self.n;\n-        self.n = 0;\n-        if n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(n - 1).is_none() {\n-                return try { init };\n-            }\n-        }\n-        self.iter.try_fold(init, fold)\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n > 0 {\n-            // nth(n) skips n+1\n-            if self.iter.nth(self.n - 1).is_none() {\n-                return init;\n-            }\n-        }\n-        self.iter.fold(init, fold)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n-impl<I> DoubleEndedIterator for Skip<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.len() > 0 { self.iter.next_back() } else { None }\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n-        let len = self.len();\n-        if n < len {\n-            self.iter.nth_back(n)\n-        } else {\n-            if len > 0 {\n-                // consume the original iterator\n-                self.iter.nth_back(len - 1);\n-            }\n-            None\n-        }\n-    }\n-\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<T, Acc, R: Try<Ok = Acc>>(\n-            mut n: usize,\n-            mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n-            move |acc, x| {\n-                n -= 1;\n-                let r = fold(acc, x);\n-                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n-            }\n-        }\n-\n-        let n = self.len();\n-        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n-    }\n-\n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_rfold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}\n-\n-/// An iterator that only iterates over the first `n` iterations of `iter`.\n-///\n-/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`take`]: Iterator::take\n-/// [`Iterator`]: trait.Iterator.html\n-#[derive(Clone, Debug)]\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Take<I> {\n-    pub(super) iter: I,\n-    pub(super) n: usize,\n-}\n-impl<I> Take<I> {\n-    pub(super) fn new(iter: I, n: usize) -> Take<I> {\n-        Take { iter, n }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> Iterator for Take<I>\n-where\n-    I: Iterator,\n-{\n-    type Item = <I as Iterator>::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n-        if self.n != 0 {\n-            self.n -= 1;\n-            self.iter.next()\n-        } else {\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth(&mut self, n: usize) -> Option<I::Item> {\n-        if self.n > n {\n-            self.n -= n + 1;\n-            self.iter.nth(n)\n-        } else {\n-            if self.n > 0 {\n-                self.iter.nth(self.n - 1);\n-                self.n = 0;\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.n == 0 {\n-            return (0, Some(0));\n-        }\n-\n-        let (lower, upper) = self.iter.size_hint();\n-\n-        let lower = cmp::min(lower, self.n);\n-\n-        let upper = match upper {\n-            Some(x) if x < self.n => Some(x),\n-            _ => Some(self.n),\n-        };\n-\n-        (lower, upper)\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n-            n: &'a mut usize,\n-            mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| {\n-                *n -= 1;\n-                let r = fold(acc, x);\n-                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n-            }\n-        }\n-\n-        if self.n == 0 {\n-            try { init }\n-        } else {\n-            let n = &mut self.n;\n-            self.iter.try_fold(init, check(n, fold)).into_try()\n-        }\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n-where\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n-\n-#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n-impl<I> DoubleEndedIterator for Take<I>\n-where\n-    I: DoubleEndedIterator + ExactSizeIterator,\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Self::Item> {\n-        if self.n == 0 {\n-            None\n-        } else {\n-            let n = self.n;\n-            self.n -= 1;\n-            self.iter.nth_back(self.iter.len().saturating_sub(n))\n-        }\n-    }\n-\n-    #[inline]\n-    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        let len = self.iter.len();\n-        if self.n > n {\n-            let m = len.saturating_sub(self.n) + n;\n-            self.n -= n + 1;\n-            self.iter.nth_back(m)\n-        } else {\n-            if len > 0 {\n-                self.iter.nth_back(len - 1);\n-            }\n-            None\n-        }\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        if self.n == 0 {\n-            try { init }\n-        } else {\n-            let len = self.iter.len();\n-            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                try { init }\n-            } else {\n-                self.iter.try_rfold(init, fold)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        if self.n == 0 {\n-            init\n-        } else {\n-            let len = self.iter.len();\n-            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                init\n-            } else {\n-                self.iter.rfold(init, fold)\n-            }\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}\n-\n-/// An iterator to maintain state while iterating another iterator.\n-///\n-/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`scan`]: Iterator::scan\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Scan<I, St, F> {\n-    iter: I,\n-    f: F,\n-    state: St,\n-}\n-impl<I, St, F> Scan<I, St, F> {\n-    pub(super) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n-        Scan { iter, state, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<B, I, St, F> Iterator for Scan<I, St, F>\n-where\n-    I: Iterator,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Item = B;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        let a = self.iter.next()?;\n-        (self.f)(&mut self.state, a)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper) // can't know a lower bound, due to the scan function\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n-            state: &'a mut St,\n-            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n-            mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n-            move |acc, x| match f(state, x) {\n-                None => ControlFlow::Break(try { acc }),\n-                Some(x) => ControlFlow::from_try(fold(acc, x)),\n-            }\n-        }\n-\n-        let state = &mut self.state;\n-        let f = &mut self.f;\n-        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        #[inline]\n-        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n-            move |acc, x| Ok(f(acc, x))\n-        }\n-\n-        self.try_fold(init, ok(fold)).unwrap()\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n-where\n-    I: SourceIter<Source = S>,\n-    F: FnMut(&mut St, I::Item) -> Option<B>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n-    F: FnMut(&mut St, I::Item) -> Option<B>\n-{\n-}\n-\n-/// An iterator that calls a function with a reference to each element before\n-/// yielding it.\n-///\n-/// This `struct` is created by the [`inspect`] method on [`Iterator`]. See its\n-/// documentation for more.\n-///\n-/// [`inspect`]: Iterator::inspect\n-/// [`Iterator`]: trait.Iterator.html\n-#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[derive(Clone)]\n-pub struct Inspect<I, F> {\n-    iter: I,\n-    f: F,\n-}\n-impl<I, F> Inspect<I, F> {\n-    pub(super) fn new(iter: I, f: F) -> Inspect<I, F> {\n-        Inspect { iter, f }\n-    }\n-}\n-\n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<I: fmt::Debug, F> fmt::Debug for Inspect<I, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Inspect\").field(\"iter\", &self.iter).finish()\n-    }\n-}\n-\n-impl<I: Iterator, F> Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn do_inspect(&mut self, elt: Option<I::Item>) -> Option<I::Item> {\n-        if let Some(ref a) = elt {\n-            (self.f)(a);\n-        }\n-\n-        elt\n-    }\n-}\n-\n-fn inspect_fold<T, Acc>(\n-    mut f: impl FnMut(&T),\n-    mut fold: impl FnMut(Acc, T) -> Acc,\n-) -> impl FnMut(Acc, T) -> Acc {\n-    move |acc, item| {\n-        f(&item);\n-        fold(acc, item)\n-    }\n-}\n-\n-fn inspect_try_fold<'a, T, Acc, R>(\n-    f: &'a mut impl FnMut(&T),\n-    mut fold: impl FnMut(Acc, T) -> R + 'a,\n-) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| {\n-        f(&item);\n-        fold(acc, item)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: Iterator, F> Iterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    type Item = I::Item;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-\n-    #[inline]\n-    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_fold(init, inspect_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.fold(init, inspect_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    #[inline]\n-    fn next_back(&mut self) -> Option<I::Item> {\n-        let next = self.iter.next_back();\n-        self.do_inspect(next)\n-    }\n-\n-    #[inline]\n-    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n-    where\n-        Self: Sized,\n-        Fold: FnMut(Acc, Self::Item) -> R,\n-        R: Try<Ok = Acc>,\n-    {\n-        self.iter.try_rfold(init, inspect_try_fold(&mut self.f, fold))\n-    }\n-\n-    #[inline]\n-    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n-    where\n-        Fold: FnMut(Acc, Self::Item) -> Acc,\n-    {\n-        self.iter.rfold(init, inspect_fold(self.f, fold))\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-{\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.iter.is_empty()\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<I: FusedIterator, F> FusedIterator for Inspect<I, F> where F: FnMut(&I::Item) {}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<S: Iterator, I: Iterator, F> SourceIter for Inspect<I, F>\n-where\n-    F: FnMut(&I::Item),\n-    I: SourceIter<Source = S>,\n-{\n-    type Source = S;\n-\n-    #[inline]\n-    unsafe fn as_inner(&mut self) -> &mut S {\n-        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n-        unsafe { SourceIter::as_inner(&mut self.iter) }\n-    }\n-}\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-unsafe impl<I: InPlaceIterable, F> InPlaceIterable for Inspect<I, F> where F: FnMut(&I::Item) {}\n-\n /// An iterator adapter that produces output as long as the underlying\n /// iterator produces `Result::Ok` values.\n ///"}, {"sha": "e7fb3abc94265d6c315cebe390666ca499f19502", "filename": "library/core/src/iter/adapters/peekable.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fpeekable.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,301 @@\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::Try;\n+\n+/// An iterator with a `peek()` that returns an optional reference to the next\n+/// element.\n+///\n+/// This `struct` is created by the [`peekable`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`peekable`]: Iterator::peekable\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Peekable<I: Iterator> {\n+    iter: I,\n+    /// Remember a peeked value, even if it was None.\n+    peeked: Option<Option<I::Item>>,\n+}\n+\n+impl<I: Iterator> Peekable<I> {\n+    pub(in crate::iter) fn new(iter: I) -> Peekable<I> {\n+        Peekable { iter, peeked: None }\n+    }\n+}\n+\n+// Peekable must remember if a None has been seen in the `.peek()` method.\n+// It ensures that `.peek(); .peek();` or `.peek(); .next();` only advances the\n+// underlying iterator at most once. This does not by itself make the iterator\n+// fused.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator> Iterator for Peekable<I> {\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(v) => v,\n+            None => self.iter.next(),\n+        }\n+    }\n+\n+    #[inline]\n+    #[rustc_inherit_overflow_checks]\n+    fn count(mut self) -> usize {\n+        match self.peeked.take() {\n+            Some(None) => 0,\n+            Some(Some(_)) => 1 + self.iter.count(),\n+            None => self.iter.count(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        match self.peeked.take() {\n+            Some(None) => None,\n+            Some(v @ Some(_)) if n == 0 => v,\n+            Some(Some(_)) => self.iter.nth(n - 1),\n+            None => self.iter.nth(n),\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        let peek_opt = match self.peeked.take() {\n+            Some(None) => return None,\n+            Some(v) => v,\n+            None => None,\n+        };\n+        self.iter.last().or(peek_opt)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let peek_len = match self.peeked {\n+            Some(None) => return (0, Some(0)),\n+            Some(Some(_)) => 1,\n+            None => 0,\n+        };\n+        let (lo, hi) = self.iter.size_hint();\n+        let lo = lo.saturating_add(peek_len);\n+        let hi = match hi {\n+            Some(x) => x.checked_add(peek_len),\n+            None => None,\n+        };\n+        (lo, hi)\n+    }\n+\n+    #[inline]\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        let acc = match self.peeked.take() {\n+            Some(None) => return try { init },\n+            Some(Some(v)) => f(init, v)?,\n+            None => init,\n+        };\n+        self.iter.try_fold(acc, f)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        let acc = match self.peeked {\n+            Some(None) => return init,\n+            Some(Some(v)) => fold(init, v),\n+            None => init,\n+        };\n+        self.iter.fold(acc, fold)\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_peek_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Peekable<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        match self.peeked.as_mut() {\n+            Some(v @ Some(_)) => self.iter.next_back().or_else(|| v.take()),\n+            Some(None) => None,\n+            None => self.iter.next_back(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        match self.peeked.take() {\n+            Some(None) => try { init },\n+            Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n+                Ok(acc) => f(acc, v),\n+                Err(e) => {\n+                    self.peeked = Some(Some(v));\n+                    Try::from_error(e)\n+                }\n+            },\n+            None => self.iter.try_rfold(init, f),\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        match self.peeked {\n+            Some(None) => init,\n+            Some(Some(v)) => {\n+                let acc = self.iter.rfold(init, &mut fold);\n+                fold(acc, v)\n+            }\n+            None => self.iter.rfold(init, fold),\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: ExactSizeIterator> ExactSizeIterator for Peekable<I> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I: FusedIterator> FusedIterator for Peekable<I> {}\n+\n+impl<I: Iterator> Peekable<I> {\n+    /// Returns a reference to the next() value without advancing the iterator.\n+    ///\n+    /// Like [`next`], if there is a value, it is wrapped in a `Some(T)`.\n+    /// But if the iteration is over, `None` is returned.\n+    ///\n+    /// [`next`]: Iterator::next\n+    ///\n+    /// Because `peek()` returns a reference, and many iterators iterate over\n+    /// references, there can be a possibly confusing situation where the\n+    /// return value is a double reference. You can see this effect in the\n+    /// examples below.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// let xs = [1, 2, 3];\n+    ///\n+    /// let mut iter = xs.iter().peekable();\n+    ///\n+    /// // peek() lets us see into the future\n+    /// assert_eq!(iter.peek(), Some(&&1));\n+    /// assert_eq!(iter.next(), Some(&1));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&2));\n+    ///\n+    /// // The iterator does not advance even if we `peek` multiple times\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    /// assert_eq!(iter.peek(), Some(&&3));\n+    ///\n+    /// assert_eq!(iter.next(), Some(&3));\n+    ///\n+    /// // After the iterator is finished, so is `peek()`\n+    /// assert_eq!(iter.peek(), None);\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n+    #[inline]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn peek(&mut self) -> Option<&I::Item> {\n+        let iter = &mut self.iter;\n+        self.peeked.get_or_insert_with(|| iter.next()).as_ref()\n+    }\n+\n+    /// Consume and return the next value of this iterator if a condition is true.\n+    ///\n+    /// If `func` returns `true` for the next value of this iterator, consume and return it.\n+    /// Otherwise, return `None`.\n+    ///\n+    /// # Examples\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if(|&x| x == 0), None);\n+    /// // `next_if` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    ///\n+    /// Consume any number less than 10.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (1..20).peekable();\n+    /// // Consume all numbers less than 10\n+    /// while iter.next_if(|&x| x < 10).is_some() {}\n+    /// // The next value returned will be 10\n+    /// assert_eq!(iter.next(), Some(10));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if(&mut self, func: impl FnOnce(&I::Item) -> bool) -> Option<I::Item> {\n+        match self.next() {\n+            Some(matched) if func(&matched) => Some(matched),\n+            other => {\n+                // Since we called `self.next()`, we consumed `self.peeked`.\n+                assert!(self.peeked.is_none());\n+                self.peeked = Some(other);\n+                None\n+            }\n+        }\n+    }\n+\n+    /// Consume and return the next item if it is equal to `expected`.\n+    ///\n+    /// # Example\n+    /// Consume a number if it's equal to 0.\n+    /// ```\n+    /// #![feature(peekable_next_if)]\n+    /// let mut iter = (0..5).peekable();\n+    /// // The first item of the iterator is 0; consume it.\n+    /// assert_eq!(iter.next_if_eq(&0), Some(0));\n+    /// // The next item returned is now 1, so `consume` will return `false`.\n+    /// assert_eq!(iter.next_if_eq(&0), None);\n+    /// // `next_if_eq` saves the value of the next item if it was not equal to `expected`.\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// ```\n+    #[unstable(feature = \"peekable_next_if\", issue = \"72480\")]\n+    pub fn next_if_eq<T>(&mut self, expected: &T) -> Option<I::Item>\n+    where\n+        T: ?Sized,\n+        I::Item: PartialEq<T>,\n+    {\n+        self.next_if(|next| next == expected)\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Peekable<I> where I: TrustedLen {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Peekable<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Peekable<I> {}"}, {"sha": "105ed40a3ed117cbf2adc6ef25173bf47d8591da", "filename": "library/core/src/iter/adapters/rev.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Frev.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,137 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::ops::Try;\n+\n+/// A double-ended iterator with the direction inverted.\n+///\n+/// This `struct` is created by the [`rev`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`rev`]: Iterator::rev\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Rev<T> {\n+    iter: T,\n+}\n+\n+impl<T> Rev<T> {\n+    pub(in crate::iter) fn new(iter: T) -> Rev<T> {\n+        Rev { iter }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next_back()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.iter.size_hint()\n+    }\n+\n+    #[inline]\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_back_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth_back(n)\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.iter.try_rfold(init, f)\n+    }\n+\n+    fn fold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.rfold(init, f)\n+    }\n+\n+    #[inline]\n+    fn find<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.iter.rfind(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> DoubleEndedIterator for Rev<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<<I as Iterator>::Item> {\n+        self.iter.next()\n+    }\n+\n+    #[inline]\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        self.iter.advance_by(n)\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<<I as Iterator>::Item> {\n+        self.iter.nth(n)\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Ok = B>,\n+    {\n+        self.iter.try_fold(init, f)\n+    }\n+\n+    fn rfold<Acc, F>(self, init: Acc, f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.iter.fold(init, f)\n+    }\n+\n+    fn rfind<P>(&mut self, predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        self.iter.find(predicate)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Rev<I>\n+where\n+    I: ExactSizeIterator + DoubleEndedIterator,\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Rev<I> where I: FusedIterator + DoubleEndedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I> TrustedLen for Rev<I> where I: TrustedLen + DoubleEndedIterator {}"}, {"sha": "0214899295e351c88ac10c498fa228394ed8a6c5", "filename": "library/core/src/iter/adapters/scan.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fscan.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,111 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator to maintain state while iterating another iterator.\n+///\n+/// This `struct` is created by the [`scan`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`scan`]: Iterator::scan\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct Scan<I, St, F> {\n+    iter: I,\n+    f: F,\n+    state: St,\n+}\n+\n+impl<I, St, F> Scan<I, St, F> {\n+    pub(in crate::iter) fn new(iter: I, state: St, f: F) -> Scan<I, St, F> {\n+        Scan { iter, state, f }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, St: fmt::Debug, F> fmt::Debug for Scan<I, St, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Scan\").field(\"iter\", &self.iter).field(\"state\", &self.state).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<B, I, St, F> Iterator for Scan<I, St, F>\n+where\n+    I: Iterator,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Item = B;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<B> {\n+        let a = self.iter.next()?;\n+        (self.f)(&mut self.state, a)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the scan function\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn scan<'a, T, St, B, Acc, R: Try<Ok = Acc>>(\n+            state: &'a mut St,\n+            f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n+            mut fold: impl FnMut(Acc, B) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| match f(state, x) {\n+                None => ControlFlow::Break(try { acc }),\n+                Some(x) => ControlFlow::from_try(fold(acc, x)),\n+            }\n+        }\n+\n+        let state = &mut self.state;\n+        let f = &mut self.f;\n+        self.iter.try_fold(init, scan(state, f, fold)).into_try()\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, S: Iterator, I: Iterator> SourceIter for Scan<I, St, F>\n+where\n+    I: SourceIter<Source = S>,\n+    F: FnMut(&mut St, I::Item) -> Option<B>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<St, F, B, I: InPlaceIterable> InPlaceIterable for Scan<I, St, F> where\n+    F: FnMut(&mut St, I::Item) -> Option<B>\n+{\n+}"}, {"sha": "dd5325660c3427a80de015f6ff7f6bbe60da0234", "filename": "library/core/src/iter/adapters/skip.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,199 @@\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that skips over `n` elements of `iter`.\n+///\n+/// This `struct` is created by the [`skip`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip`]: Iterator::skip\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Skip<I> {\n+    iter: I,\n+    n: usize,\n+}\n+\n+impl<I> Skip<I> {\n+    pub(in crate::iter) fn new(iter: I, n: usize) -> Skip<I> {\n+        Skip { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Skip<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.n == 0 {\n+            self.iter.next()\n+        } else {\n+            let old_n = self.n;\n+            self.n = 0;\n+            self.iter.nth(old_n)\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        // Can't just add n + self.n due to overflow.\n+        if self.n > 0 {\n+            let to_skip = self.n;\n+            self.n = 0;\n+            // nth(n) skips n+1\n+            self.iter.nth(to_skip - 1)?;\n+        }\n+        self.iter.nth(n)\n+    }\n+\n+    #[inline]\n+    fn count(mut self) -> usize {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return 0;\n+            }\n+        }\n+        self.iter.count()\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<I::Item> {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            self.iter.nth(self.n - 1)?;\n+        }\n+        self.iter.last()\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = lower.saturating_sub(self.n);\n+        let upper = match upper {\n+            Some(x) => Some(x.saturating_sub(self.n)),\n+            None => None,\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        let n = self.n;\n+        self.n = 0;\n+        if n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(n - 1).is_none() {\n+                return try { init };\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n > 0 {\n+            // nth(n) skips n+1\n+            if self.iter.nth(self.n - 1).is_none() {\n+                return init;\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Skip<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"double_ended_skip_iterator\", since = \"1.9.0\")]\n+impl<I> DoubleEndedIterator for Skip<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.len() > 0 { self.iter.next_back() } else { None }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        let len = self.len();\n+        if n < len {\n+            self.iter.nth_back(n)\n+        } else {\n+            if len > 0 {\n+                // consume the original iterator\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<T, Acc, R: Try<Ok = Acc>>(\n+            mut n: usize,\n+            mut fold: impl FnMut(Acc, T) -> R,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n+            move |acc, x| {\n+                n -= 1;\n+                let r = fold(acc, x);\n+                if n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n+            }\n+        }\n+\n+        let n = self.len();\n+        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n+    }\n+\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<Acc, T>(mut f: impl FnMut(Acc, T) -> Acc) -> impl FnMut(Acc, T) -> Result<Acc, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_rfold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Skip<I> where I: FusedIterator {}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Skip<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Skip<I> {}"}, {"sha": "efcb469fc957725b9d8b787f73e545ef89c9a5ca", "filename": "library/core/src/iter/adapters/skip_while.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fskip_while.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,126 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::Try;\n+\n+/// An iterator that rejects elements while `predicate` returns `true`.\n+///\n+/// This `struct` is created by the [`skip_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`skip_while`]: Iterator::skip_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct SkipWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> SkipWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> SkipWhile<I, P> {\n+        SkipWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for SkipWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SkipWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        fn check<'a, T>(\n+            flag: &'a mut bool,\n+            pred: &'a mut impl FnMut(&T) -> bool,\n+        ) -> impl FnMut(&T) -> bool + 'a {\n+            move |x| {\n+                if *flag || !pred(x) {\n+                    *flag = true;\n+                    true\n+                } else {\n+                    false\n+                }\n+            }\n+        }\n+\n+        let flag = &mut self.flag;\n+        let pred = &mut self.predicate;\n+        self.iter.find(check(flag, pred))\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.iter.size_hint();\n+        (0, upper) // can't know a lower bound, due to the predicate\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, mut init: Acc, mut fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v)?,\n+                None => return try { init },\n+            }\n+        }\n+        self.iter.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, mut init: Acc, mut fold: Fold) -> Acc\n+    where\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if !self.flag {\n+            match self.next() {\n+                Some(v) => init = fold(init, v),\n+                None => return init,\n+            }\n+        }\n+        self.iter.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for SkipWhile<I, P>\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for SkipWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for SkipWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}"}, {"sha": "2ba56eeccba1729a23adb0d28a2bce1d43979326", "filename": "library/core/src/iter/adapters/step_by.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fstep_by.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,235 @@\n+use crate::{intrinsics, iter::from_fn, ops::Try};\n+\n+/// An iterator for stepping iterators by a custom amount.\n+///\n+/// This `struct` is created by the [`step_by`] method on [`Iterator`]. See\n+/// its documentation for more.\n+///\n+/// [`step_by`]: Iterator::step_by\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+#[derive(Clone, Debug)]\n+pub struct StepBy<I> {\n+    iter: I,\n+    step: usize,\n+    first_take: bool,\n+}\n+\n+impl<I> StepBy<I> {\n+    pub(in crate::iter) fn new(iter: I, step: usize) -> StepBy<I> {\n+        assert!(step != 0);\n+        StepBy { iter, step: step - 1, first_take: true }\n+    }\n+}\n+\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> Iterator for StepBy<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            self.iter.next()\n+        } else {\n+            self.iter.nth(self.step)\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        #[inline]\n+        fn first_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| if n == 0 { 0 } else { 1 + (n - 1) / (step + 1) }\n+        }\n+\n+        #[inline]\n+        fn other_size(step: usize) -> impl Fn(usize) -> usize {\n+            move |n| n / (step + 1)\n+        }\n+\n+        let (low, high) = self.iter.size_hint();\n+\n+        if self.first_take {\n+            let f = first_size(self.step);\n+            (f(low), high.map(f))\n+        } else {\n+            let f = other_size(self.step);\n+            (f(low), high.map(f))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if self.first_take {\n+            self.first_take = false;\n+            let first = self.iter.next();\n+            if n == 0 {\n+                return first;\n+            }\n+            n -= 1;\n+        }\n+        // n and self.step are indices, we need to add 1 to get the amount of elements\n+        // When calling `.nth`, we need to subtract 1 again to convert back to an index\n+        // step + 1 can't overflow because `.step_by` sets `self.step` to `step - 1`\n+        let mut step = self.step + 1;\n+        // n + 1 could overflow\n+        // thus, if n is usize::MAX, instead of adding one, we call .nth(step)\n+        if n == usize::MAX {\n+            self.iter.nth(step - 1);\n+        } else {\n+            n += 1;\n+        }\n+\n+        // overflow handling\n+        loop {\n+            let mul = n.checked_mul(step);\n+            {\n+                if intrinsics::likely(mul.is_some()) {\n+                    return self.iter.nth(mul.unwrap() - 1);\n+                }\n+            }\n+            let div_n = usize::MAX / n;\n+            let div_step = usize::MAX / step;\n+            let nth_n = div_n * n;\n+            let nth_step = div_step * step;\n+            let nth = if nth_n > nth_step {\n+                step -= div_n;\n+                nth_n\n+            } else {\n+                n -= div_step;\n+                nth_step\n+            };\n+            self.iter.nth(nth - 1);\n+        }\n+    }\n+\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return try { acc },\n+                Some(x) => acc = f(acc, x)?,\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n+    }\n+\n+    fn fold<Acc, F>(mut self, mut acc: Acc, mut f: F) -> Acc\n+    where\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return acc,\n+                Some(x) => acc = f(acc, x),\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).fold(acc, f)\n+    }\n+}\n+\n+impl<I> StepBy<I>\n+where\n+    I: ExactSizeIterator,\n+{\n+    // The zero-based index starting from the end of the iterator of the\n+    // last element. Used in the `DoubleEndedIterator` implementation.\n+    fn next_back_index(&self) -> usize {\n+        let rem = self.iter.len() % (self.step + 1);\n+        if self.first_take {\n+            if rem == 0 { self.step } else { rem - 1 }\n+        } else {\n+            rem\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"double_ended_step_by_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for StepBy<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        self.iter.nth_back(self.next_back_index())\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        // `self.iter.nth_back(usize::MAX)` does the right thing here when `n`\n+        // is out of bounds because the length of `self.iter` does not exceed\n+        // `usize::MAX` (because `I: ExactSizeIterator`) and `nth_back` is\n+        // zero-indexed\n+        let n = n.saturating_mul(self.step + 1).saturating_add(self.next_back_index());\n+        self.iter.nth_back(n)\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => try { init },\n+            Some(x) => {\n+                let acc = f(init, x)?;\n+                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, F>(mut self, init: Acc, mut f: F) -> Acc\n+    where\n+        Self: Sized,\n+        F: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => init,\n+            Some(x) => {\n+                let acc = f(init, x);\n+                from_fn(nth_back(&mut self.iter, self.step)).fold(acc, f)\n+            }\n+        }\n+    }\n+}\n+\n+// StepBy can only make the iterator shorter, so the len will still fit.\n+#[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n+impl<I> ExactSizeIterator for StepBy<I> where I: ExactSizeIterator {}"}, {"sha": "9efc7a480aeb4a4f7001ee4fdcc69a8fad060075", "filename": "library/core/src/iter/adapters/take.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,209 @@\n+use crate::cmp;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that only iterates over the first `n` iterations of `iter`.\n+///\n+/// This `struct` is created by the [`take`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take`]: Iterator::take\n+/// [`Iterator`]: trait.Iterator.html\n+#[derive(Clone, Debug)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Take<I> {\n+    iter: I,\n+    n: usize,\n+}\n+\n+impl<I> Take<I> {\n+    pub(in crate::iter) fn new(iter: I, n: usize) -> Take<I> {\n+        Take { iter, n }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> Iterator for Take<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = <I as Iterator>::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+        if self.n != 0 {\n+            self.n -= 1;\n+            self.iter.next()\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        if self.n > n {\n+            self.n -= n + 1;\n+            self.iter.nth(n)\n+        } else {\n+            if self.n > 0 {\n+                self.iter.nth(self.n - 1);\n+                self.n = 0;\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.n == 0 {\n+            return (0, Some(0));\n+        }\n+\n+        let (lower, upper) = self.iter.size_hint();\n+\n+        let lower = cmp::min(lower, self.n);\n+\n+        let upper = match upper {\n+            Some(x) if x < self.n => Some(x),\n+            _ => Some(self.n),\n+        };\n+\n+        (lower, upper)\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            n: &'a mut usize,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| {\n+                *n -= 1;\n+                let r = fold(acc, x);\n+                if *n == 0 { ControlFlow::Break(r) } else { ControlFlow::from_try(r) }\n+            }\n+        }\n+\n+        if self.n == 0 {\n+            try { init }\n+        } else {\n+            let n = &mut self.n;\n+            self.iter.try_fold(init, check(n, fold)).into_try()\n+        }\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, I: Iterator> SourceIter for Take<I>\n+where\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable> InPlaceIterable for Take<I> {}\n+\n+#[stable(feature = \"double_ended_take_iterator\", since = \"1.38.0\")]\n+impl<I> DoubleEndedIterator for Take<I>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        if self.n == 0 {\n+            None\n+        } else {\n+            let n = self.n;\n+            self.n -= 1;\n+            self.iter.nth_back(self.iter.len().saturating_sub(n))\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.iter.len();\n+        if self.n > n {\n+            let m = len.saturating_sub(self.n) + n;\n+            self.n -= n + 1;\n+            self.iter.nth_back(m)\n+        } else {\n+            if len > 0 {\n+                self.iter.nth_back(len - 1);\n+            }\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        if self.n == 0 {\n+            try { init }\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                try { init }\n+            } else {\n+                self.iter.try_rfold(init, fold)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        if self.n == 0 {\n+            init\n+        } else {\n+            let len = self.iter.len();\n+            if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n+                init\n+            } else {\n+                self.iter.rfold(init, fold)\n+            }\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I> ExactSizeIterator for Take<I> where I: ExactSizeIterator {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I> FusedIterator for Take<I> where I: FusedIterator {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I: TrustedLen> TrustedLen for Take<I> {}"}, {"sha": "746eb41f4c38742ec23a7764cc3aead95c8f8e86", "filename": "library/core/src/iter/adapters/take_while.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ftake_while.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,139 @@\n+use crate::fmt;\n+use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n+use crate::ops::{ControlFlow, Try};\n+\n+/// An iterator that only accepts elements while `predicate` returns `true`.\n+///\n+/// This `struct` is created by the [`take_while`] method on [`Iterator`]. See its\n+/// documentation for more.\n+///\n+/// [`take_while`]: Iterator::take_while\n+/// [`Iterator`]: trait.Iterator.html\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[derive(Clone)]\n+pub struct TakeWhile<I, P> {\n+    iter: I,\n+    flag: bool,\n+    predicate: P,\n+}\n+\n+impl<I, P> TakeWhile<I, P> {\n+    pub(in crate::iter) fn new(iter: I, predicate: P) -> TakeWhile<I, P> {\n+        TakeWhile { iter, flag: false, predicate }\n+    }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, P> fmt::Debug for TakeWhile<I, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"TakeWhile\").field(\"iter\", &self.iter).field(\"flag\", &self.flag).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, P> Iterator for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+{\n+    type Item = I::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<I::Item> {\n+        if self.flag {\n+            None\n+        } else {\n+            let x = self.iter.next()?;\n+            if (self.predicate)(&x) {\n+                Some(x)\n+            } else {\n+                self.flag = true;\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.flag {\n+            (0, Some(0))\n+        } else {\n+            let (_, upper) = self.iter.size_hint();\n+            (0, upper) // can't know a lower bound, due to the predicate\n+        }\n+    }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n+            flag: &'a mut bool,\n+            p: &'a mut impl FnMut(&T) -> bool,\n+            mut fold: impl FnMut(Acc, T) -> R + 'a,\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n+            move |acc, x| {\n+                if p(&x) {\n+                    ControlFlow::from_try(fold(acc, x))\n+                } else {\n+                    *flag = true;\n+                    ControlFlow::Break(try { acc })\n+                }\n+            }\n+        }\n+\n+        if self.flag {\n+            try { init }\n+        } else {\n+            let flag = &mut self.flag;\n+            let p = &mut self.predicate;\n+            self.iter.try_fold(init, check(flag, p, fold)).into_try()\n+        }\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n+    where\n+        Self: Sized,\n+        Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        #[inline]\n+        fn ok<B, T>(mut f: impl FnMut(B, T) -> B) -> impl FnMut(B, T) -> Result<B, !> {\n+            move |acc, x| Ok(f(acc, x))\n+        }\n+\n+        self.try_fold(init, ok(fold)).unwrap()\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<I, P> FusedIterator for TakeWhile<I, P>\n+where\n+    I: FusedIterator,\n+    P: FnMut(&I::Item) -> bool,\n+{\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<S: Iterator, P, I: Iterator> SourceIter for TakeWhile<I, P>\n+where\n+    P: FnMut(&I::Item) -> bool,\n+    I: SourceIter<Source = S>,\n+{\n+    type Source = S;\n+\n+    #[inline]\n+    unsafe fn as_inner(&mut self) -> &mut S {\n+        // SAFETY: unsafe function forwarding to unsafe function with the same requirements\n+        unsafe { SourceIter::as_inner(&mut self.iter) }\n+    }\n+}\n+\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+unsafe impl<I: InPlaceIterable, F> InPlaceIterable for TakeWhile<I, F> where\n+    F: FnMut(&I::Item) -> bool\n+{\n+}"}, {"sha": "8cd4c775231926d54ba38bc8dd3965dfd4d097c5", "filename": "library/core/src/iter/adapters/zip.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fzip.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -1,10 +1,7 @@\n use crate::cmp;\n use crate::fmt::{self, Debug};\n-\n-use super::super::{\n-    DoubleEndedIterator, ExactSizeIterator, FusedIterator, InPlaceIterable, Iterator, SourceIter,\n-    TrustedLen,\n-};\n+use crate::iter::{DoubleEndedIterator, ExactSizeIterator, FusedIterator, Iterator};\n+use crate::iter::{InPlaceIterable, SourceIter, TrustedLen};\n \n /// An iterator that iterates two other iterators simultaneously.\n ///\n@@ -21,7 +18,7 @@ pub struct Zip<A, B> {\n     len: usize,\n }\n impl<A: Iterator, B: Iterator> Zip<A, B> {\n-    pub(in super::super) fn new(a: A, b: B) -> Zip<A, B> {\n+    pub(in crate::iter) fn new(a: A, b: B) -> Zip<A, B> {\n         ZipImpl::new(a, b)\n     }\n     fn super_nth(&mut self, mut n: usize) -> Option<(A::Item, B::Item)> {"}, {"sha": "072373c00f679740ef3972c54b15199d6ba05561", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -335,37 +335,34 @@ pub use self::sources::{successors, Successors};\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n pub use self::traits::FusedIterator;\n+#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+pub use self::traits::InPlaceIterable;\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n pub use self::traits::TrustedLen;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{DoubleEndedIterator, Extend, FromIterator, IntoIterator};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::traits::{ExactSizeIterator, Product, Sum};\n-\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n-pub use self::traits::InPlaceIterable;\n+pub use self::traits::{\n+    DoubleEndedIterator, ExactSizeIterator, Extend, FromIterator, IntoIterator, Product, Sum,\n+};\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::adapters::Cloned;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n pub use self::adapters::Copied;\n #[stable(feature = \"iterator_flatten\", since = \"1.29.0\")]\n pub use self::adapters::Flatten;\n-\n #[unstable(feature = \"iter_map_while\", reason = \"recently added\", issue = \"68537\")]\n pub use self::adapters::MapWhile;\n-#[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n+#[unstable(feature = \"inplace_iteration\", issue = \"none\")]\n pub use self::adapters::SourceIter;\n #[stable(feature = \"iterator_step_by\", since = \"1.28.0\")]\n pub use self::adapters::StepBy;\n #[unstable(feature = \"trusted_random_access\", issue = \"none\")]\n pub use self::adapters::TrustedRandomAccess;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Chain, Cycle, Enumerate, Filter, FilterMap, Map, Rev, Zip};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{FlatMap, Peekable, Scan, Skip, SkipWhile, Take, TakeWhile};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use self::adapters::{Fuse, Inspect};\n+pub use self::adapters::{\n+    Chain, Cycle, Enumerate, Filter, FilterMap, FlatMap, Fuse, Inspect, Map, Peekable, Rev, Scan,\n+    Skip, SkipWhile, Take, TakeWhile, Zip,\n+};\n \n pub(crate) use self::adapters::process_results;\n "}, {"sha": "de0663141e25274cb5e95d1039047e58297c60a7", "filename": "library/core/src/iter/sources.rs", "status": "modified", "additions": 16, "deletions": 614, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -1,625 +1,27 @@\n-use crate::fmt;\n-use crate::marker;\n+mod empty;\n+mod from_fn;\n+mod once;\n+mod once_with;\n+mod repeat;\n+mod repeat_with;\n+mod successors;\n \n-use super::{FusedIterator, TrustedLen};\n+pub use self::repeat::{repeat, Repeat};\n \n-/// An iterator that repeats an element endlessly.\n-///\n-/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Repeat<A> {\n-    element: A,\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> Iterator for Repeat<A> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        Some(self.element.clone())\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> {\n-        Some(self.element.clone())\n-    }\n-}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<A: Clone> FusedIterator for Repeat<A> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A: Clone> TrustedLen for Repeat<A> {}\n-\n-/// Creates a new iterator that endlessly repeats a single element.\n-///\n-/// The `repeat()` function repeats a single value over and over again.\n-///\n-/// Infinite iterators like `repeat()` are often used with adapters like\n-/// [`Iterator::take()`], in order to make them finite.\n-///\n-/// If the element type of the iterator you need does not implement `Clone`,\n-/// or if you do not want to keep the repeated element in memory, you can\n-/// instead use the [`repeat_with()`] function.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // the number four 4ever:\n-/// let mut fours = iter::repeat(4);\n-///\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-/// assert_eq!(Some(4), fours.next());\n-///\n-/// // yup, still four\n-/// assert_eq!(Some(4), fours.next());\n-/// ```\n-///\n-/// Going finite with [`Iterator::take()`]:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // that last example was too many fours. Let's only have four fours.\n-/// let mut four_fours = iter::repeat(4).take(4);\n-///\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-/// assert_eq!(Some(4), four_fours.next());\n-///\n-/// // ... and now we're done\n-/// assert_eq!(None, four_fours.next());\n-/// ```\n-#[inline]\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n-    Repeat { element: elt }\n-}\n-\n-/// An iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure `F: FnMut() -> A`.\n-///\n-/// This `struct` is created by the [`repeat_with()`] function.\n-/// See its documentation for more.\n-#[derive(Copy, Clone, Debug)]\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub struct RepeatWith<F> {\n-    repeater: F,\n-}\n-\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        Some((self.repeater)())\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}\n-\n-/// Creates a new iterator that repeats elements of type `A` endlessly by\n-/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n-///\n-/// The `repeat_with()` function calls the repeater over and over again.\n-///\n-/// Infinite iterators like `repeat_with()` are often used with adapters like\n-/// [`Iterator::take()`], in order to make them finite.\n-///\n-/// If the element type of the iterator you need implements [`Clone`], and\n-/// it is OK to keep the source element in memory, you should instead use\n-/// the [`repeat()`] function.\n-///\n-/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n-/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n-/// please open a GitHub issue explaining your use case.\n-///\n-/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // let's assume we have some value of a type that is not `Clone`\n-/// // or which don't want to have in memory just yet because it is expensive:\n-/// #[derive(PartialEq, Debug)]\n-/// struct Expensive;\n-///\n-/// // a particular value forever:\n-/// let mut things = iter::repeat_with(|| Expensive);\n-///\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// assert_eq!(Some(Expensive), things.next());\n-/// ```\n-///\n-/// Using mutation and going finite:\n-///\n-/// ```rust\n-/// use std::iter;\n-///\n-/// // From the zeroth to the third power of two:\n-/// let mut curr = 1;\n-/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n-///                     .take(4);\n-///\n-/// assert_eq!(Some(1), pow2.next());\n-/// assert_eq!(Some(2), pow2.next());\n-/// assert_eq!(Some(4), pow2.next());\n-/// assert_eq!(Some(8), pow2.next());\n-///\n-/// // ... and now we're done\n-/// assert_eq!(None, pow2.next());\n-/// ```\n-#[inline]\n-#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n-pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n-    RepeatWith { repeater }\n-}\n-\n-/// An iterator that yields nothing.\n-///\n-/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n #[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-pub struct Empty<T>(marker::PhantomData<T>);\n-\n-#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n-unsafe impl<T> Send for Empty<T> {}\n-#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n-unsafe impl<T> Sync for Empty<T> {}\n+pub use self::empty::{empty, Empty};\n \n-#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n-impl<T> fmt::Debug for Empty<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.pad(\"Empty\")\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Iterator for Empty<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(0))\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> DoubleEndedIterator for Empty<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        None\n-    }\n-}\n-\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> ExactSizeIterator for Empty<T> {\n-    fn len(&self) -> usize {\n-        0\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Empty<T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Empty<T> {}\n-\n-// not #[derive] because that adds a Clone bound on T,\n-// which isn't necessary.\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Clone for Empty<T> {\n-    fn clone(&self) -> Empty<T> {\n-        Empty(marker::PhantomData)\n-    }\n-}\n-\n-// not #[derive] because that adds a Default bound on T,\n-// which isn't necessary.\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-impl<T> Default for Empty<T> {\n-    fn default() -> Empty<T> {\n-        Empty(marker::PhantomData)\n-    }\n-}\n-\n-/// Creates an iterator that yields nothing.\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // this could have been an iterator over i32, but alas, it's just not.\n-/// let mut nope = iter::empty::<i32>();\n-///\n-/// assert_eq!(None, nope.next());\n-/// ```\n-#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n-#[rustc_const_stable(feature = \"const_iter_empty\", since = \"1.32.0\")]\n-pub const fn empty<T>() -> Empty<T> {\n-    Empty(marker::PhantomData)\n-}\n-\n-/// An iterator that yields an element exactly once.\n-///\n-/// This `struct` is created by the [`once()`] function. See its documentation for more.\n-#[derive(Clone, Debug)]\n #[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub struct Once<T> {\n-    inner: crate::option::IntoIter<T>,\n-}\n+pub use self::once::{once, Once};\n \n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> Iterator for Once<T> {\n-    type Item = T;\n-\n-    fn next(&mut self) -> Option<T> {\n-        self.inner.next()\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.inner.size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> DoubleEndedIterator for Once<T> {\n-    fn next_back(&mut self) -> Option<T> {\n-        self.inner.next_back()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-impl<T> ExactSizeIterator for Once<T> {\n-    fn len(&self) -> usize {\n-        self.inner.len()\n-    }\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T> TrustedLen for Once<T> {}\n-\n-#[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<T> FusedIterator for Once<T> {}\n-\n-/// Creates an iterator that yields an element exactly once.\n-///\n-/// This is commonly used to adapt a single value into a [`chain()`] of other\n-/// kinds of iteration. Maybe you have an iterator that covers almost\n-/// everything, but you need an extra special case. Maybe you have a function\n-/// which works on iterators, but you only need to process one value.\n-///\n-/// [`chain()`]: Iterator::chain\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // one is the loneliest number\n-/// let mut one = iter::once(1);\n-///\n-/// assert_eq!(Some(1), one.next());\n-///\n-/// // just one, that's all we get\n-/// assert_eq!(None, one.next());\n-/// ```\n-///\n-/// Chaining together with another iterator. Let's say that we want to iterate\n-/// over each file of the `.foo` directory, but also a configuration file,\n-/// `.foorc`:\n-///\n-/// ```no_run\n-/// use std::iter;\n-/// use std::fs;\n-/// use std::path::PathBuf;\n-///\n-/// let dirs = fs::read_dir(\".foo\").unwrap();\n-///\n-/// // we need to convert from an iterator of DirEntry-s to an iterator of\n-/// // PathBufs, so we use map\n-/// let dirs = dirs.map(|file| file.unwrap().path());\n-///\n-/// // now, our iterator just for our config file\n-/// let config = iter::once(PathBuf::from(\".foorc\"));\n-///\n-/// // chain the two iterators together into one big iterator\n-/// let files = dirs.chain(config);\n-///\n-/// // this will give us all of the files in .foo as well as .foorc\n-/// for f in files {\n-///     println!(\"{:?}\", f);\n-/// }\n-/// ```\n-#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n-pub fn once<T>(value: T) -> Once<T> {\n-    Once { inner: Some(value).into_iter() }\n-}\n-\n-/// An iterator that yields a single element of type `A` by\n-/// applying the provided closure `F: FnOnce() -> A`.\n-///\n-/// This `struct` is created by the [`once_with()`] function.\n-/// See its documentation for more.\n-#[derive(Clone, Debug)]\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-pub struct OnceWith<F> {\n-    gen: Option<F>,\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n-    type Item = A;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<A> {\n-        let f = self.gen.take()?;\n-        Some(f())\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.gen.iter().size_hint()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n-    fn next_back(&mut self) -> Option<A> {\n-        self.next()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n-    fn len(&self) -> usize {\n-        self.gen.iter().len()\n-    }\n-}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n-\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}\n-\n-/// Creates an iterator that lazily generates a value exactly once by invoking\n-/// the provided closure.\n-///\n-/// This is commonly used to adapt a single value generator into a [`chain()`] of\n-/// other kinds of iteration. Maybe you have an iterator that covers almost\n-/// everything, but you need an extra special case. Maybe you have a function\n-/// which works on iterators, but you only need to process one value.\n-///\n-/// Unlike [`once()`], this function will lazily generate the value on request.\n-///\n-/// [`chain()`]: Iterator::chain\n-///\n-/// # Examples\n-///\n-/// Basic usage:\n-///\n-/// ```\n-/// use std::iter;\n-///\n-/// // one is the loneliest number\n-/// let mut one = iter::once_with(|| 1);\n-///\n-/// assert_eq!(Some(1), one.next());\n-///\n-/// // just one, that's all we get\n-/// assert_eq!(None, one.next());\n-/// ```\n-///\n-/// Chaining together with another iterator. Let's say that we want to iterate\n-/// over each file of the `.foo` directory, but also a configuration file,\n-/// `.foorc`:\n-///\n-/// ```no_run\n-/// use std::iter;\n-/// use std::fs;\n-/// use std::path::PathBuf;\n-///\n-/// let dirs = fs::read_dir(\".foo\").unwrap();\n-///\n-/// // we need to convert from an iterator of DirEntry-s to an iterator of\n-/// // PathBufs, so we use map\n-/// let dirs = dirs.map(|file| file.unwrap().path());\n-///\n-/// // now, our iterator just for our config file\n-/// let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n-///\n-/// // chain the two iterators together into one big iterator\n-/// let files = dirs.chain(config);\n-///\n-/// // this will give us all of the files in .foo as well as .foorc\n-/// for f in files {\n-///     println!(\"{:?}\", f);\n-/// }\n-/// ```\n-#[inline]\n-#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n-pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n-    OnceWith { gen: Some(gen) }\n-}\n-\n-/// Creates a new iterator where each iteration calls the provided closure\n-/// `F: FnMut() -> Option<T>`.\n-///\n-/// This allows creating a custom iterator with any behavior\n-/// without using the more verbose syntax of creating a dedicated type\n-/// and implementing the [`Iterator`] trait for it.\n-///\n-/// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n-/// and therefore conservatively does not implement [`FusedIterator`],\n-/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n-///\n-/// The closure can use captures and its environment to track state across iterations. Depending on\n-/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n-///\n-/// [`move`]: ../../std/keyword.move.html\n-///\n-/// # Examples\n-///\n-/// Let\u2019s re-implement the counter iterator from the [module-level documentation]:\n-///\n-/// [module-level documentation]: super\n-///\n-/// ```\n-/// let mut count = 0;\n-/// let counter = std::iter::from_fn(move || {\n-///     // Increment our count. This is why we started at zero.\n-///     count += 1;\n-///\n-///     // Check to see if we've finished counting or not.\n-///     if count < 6 {\n-///         Some(count)\n-///     } else {\n-///         None\n-///     }\n-/// });\n-/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n-/// ```\n-#[inline]\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub fn from_fn<T, F>(f: F) -> FromFn<F>\n-where\n-    F: FnMut() -> Option<T>,\n-{\n-    FromFn(f)\n-}\n-\n-/// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n-///\n-/// This `struct` is created by the [`iter::from_fn()`] function.\n-/// See its documentation for more.\n-///\n-/// [`iter::from_fn()`]: from_fn\n-#[derive(Clone)]\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-pub struct FromFn<F>(F);\n-\n-#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-impl<T, F> Iterator for FromFn<F>\n-where\n-    F: FnMut() -> Option<T>,\n-{\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        (self.0)()\n-    }\n-}\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub use self::repeat_with::{repeat_with, RepeatWith};\n \n #[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n-impl<F> fmt::Debug for FromFn<F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"FromFn\").finish()\n-    }\n-}\n+pub use self::from_fn::{from_fn, FromFn};\n \n-/// Creates a new iterator where each successive item is computed based on the preceding one.\n-///\n-/// The iterator starts with the given first item (if any)\n-/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n-///\n-/// ```\n-/// use std::iter::successors;\n-///\n-/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n-/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n-/// ```\n #[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n-where\n-    F: FnMut(&T) -> Option<T>,\n-{\n-    // If this function returned `impl Iterator<Item=T>`\n-    // it could be based on `unfold` and not need a dedicated type.\n-    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n-    Successors { next: first, succ }\n-}\n+pub use self::successors::{successors, Successors};\n \n-/// An new iterator where each successive item is computed based on the preceding one.\n-///\n-/// This `struct` is created by the [`iter::successors()`] function.\n-/// See its documentation for more.\n-///\n-/// [`iter::successors()`]: successors\n-#[derive(Clone)]\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-pub struct Successors<T, F> {\n-    next: Option<T>,\n-    succ: F,\n-}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> Iterator for Successors<T, F>\n-where\n-    F: FnMut(&T) -> Option<T>,\n-{\n-    type Item = T;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Self::Item> {\n-        let item = self.next.take()?;\n-        self.next = (self.succ)(&item);\n-        Some(item)\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n-    }\n-}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n-\n-#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n-impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n-    }\n-}\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub use self::once_with::{once_with, OnceWith};"}, {"sha": "5d4a9fe8c6cc0dde45f7609b323fbe4b40ec5a6c", "filename": "library/core/src/iter/sources/empty.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fempty.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,92 @@\n+use crate::fmt;\n+use crate::iter::{FusedIterator, TrustedLen};\n+use crate::marker;\n+\n+/// Creates an iterator that yields nothing.\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // this could have been an iterator over i32, but alas, it's just not.\n+/// let mut nope = iter::empty::<i32>();\n+///\n+/// assert_eq!(None, nope.next());\n+/// ```\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+#[rustc_const_stable(feature = \"const_iter_empty\", since = \"1.32.0\")]\n+pub const fn empty<T>() -> Empty<T> {\n+    Empty(marker::PhantomData)\n+}\n+\n+/// An iterator that yields nothing.\n+///\n+/// This `struct` is created by the [`empty()`] function. See its documentation for more.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+pub struct Empty<T>(marker::PhantomData<T>);\n+\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Send for Empty<T> {}\n+#[stable(feature = \"iter_empty_send_sync\", since = \"1.42.0\")]\n+unsafe impl<T> Sync for Empty<T> {}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<T> fmt::Debug for Empty<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"Empty\")\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Iterator for Empty<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(0))\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Empty<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        None\n+    }\n+}\n+\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Empty<T> {\n+    fn len(&self) -> usize {\n+        0\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Empty<T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Empty<T> {}\n+\n+// not #[derive] because that adds a Clone bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Clone for Empty<T> {\n+    fn clone(&self) -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}\n+\n+// not #[derive] because that adds a Default bound on T,\n+// which isn't necessary.\n+#[stable(feature = \"iter_empty\", since = \"1.2.0\")]\n+impl<T> Default for Empty<T> {\n+    fn default() -> Empty<T> {\n+        Empty(marker::PhantomData)\n+    }\n+}"}, {"sha": "3cd3830471cfe9e99900f29f952041f1271eb142", "filename": "library/core/src/iter/sources/from_fn.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Ffrom_fn.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,78 @@\n+use crate::fmt;\n+\n+/// Creates a new iterator where each iteration calls the provided closure\n+/// `F: FnMut() -> Option<T>`.\n+///\n+/// This allows creating a custom iterator with any behavior\n+/// without using the more verbose syntax of creating a dedicated type\n+/// and implementing the [`Iterator`] trait for it.\n+///\n+/// Note that the `FromFn` iterator doesn\u2019t make assumptions about the behavior of the closure,\n+/// and therefore conservatively does not implement [`FusedIterator`],\n+/// or override [`Iterator::size_hint()`] from its default `(0, None)`.\n+///\n+/// The closure can use captures and its environment to track state across iterations. Depending on\n+/// how the iterator is used, this may require specifying the [`move`] keyword on the closure.\n+///\n+/// [`move`]: ../../std/keyword.move.html\n+/// [`FusedIterator`]: crate::iter::FusedIterator\n+///\n+/// # Examples\n+///\n+/// Let\u2019s re-implement the counter iterator from [module-level documentation]:\n+///\n+/// [module-level documentation]: crate::iter\n+///\n+/// ```\n+/// let mut count = 0;\n+/// let counter = std::iter::from_fn(move || {\n+///     // Increment our count. This is why we started at zero.\n+///     count += 1;\n+///\n+///     // Check to see if we've finished counting or not.\n+///     if count < 6 {\n+///         Some(count)\n+///     } else {\n+///         None\n+///     }\n+/// });\n+/// assert_eq!(counter.collect::<Vec<_>>(), &[1, 2, 3, 4, 5]);\n+/// ```\n+#[inline]\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub fn from_fn<T, F>(f: F) -> FromFn<F>\n+where\n+    F: FnMut() -> Option<T>,\n+{\n+    FromFn(f)\n+}\n+\n+/// An iterator where each iteration calls the provided closure `F: FnMut() -> Option<T>`.\n+///\n+/// This `struct` is created by the [`iter::from_fn()`] function.\n+/// See its documentation for more.\n+///\n+/// [`iter::from_fn()`]: from_fn\n+#[derive(Clone)]\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+pub struct FromFn<F>(F);\n+\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+impl<T, F> Iterator for FromFn<F>\n+where\n+    F: FnMut() -> Option<T>,\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        (self.0)()\n+    }\n+}\n+\n+#[stable(feature = \"iter_from_fn\", since = \"1.34.0\")]\n+impl<F> fmt::Debug for FromFn<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"FromFn\").finish()\n+    }\n+}"}, {"sha": "27bc3dcfd79e092c40765099519d3aee6a242e0a", "filename": "library/core/src/iter/sources/once.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,99 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates an iterator that yields an element exactly once.\n+///\n+/// This is commonly used to adapt a single value into a [`chain()`] of other\n+/// kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// [`chain()`]: Iterator::chain\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once(1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once(PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub fn once<T>(value: T) -> Once<T> {\n+    Once { inner: Some(value).into_iter() }\n+}\n+\n+/// An iterator that yields an element exactly once.\n+///\n+/// This `struct` is created by the [`once()`] function. See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+pub struct Once<T> {\n+    inner: crate::option::IntoIter<T>,\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> Iterator for Once<T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        self.inner.next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> DoubleEndedIterator for Once<T> {\n+    fn next_back(&mut self) -> Option<T> {\n+        self.inner.next_back()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once\", since = \"1.2.0\")]\n+impl<T> ExactSizeIterator for Once<T> {\n+    fn len(&self) -> usize {\n+        self.inner.len()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T> TrustedLen for Once<T> {}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<T> FusedIterator for Once<T> {}"}, {"sha": "cf6a3c115245295de66ae010f0c50b85c6501f13", "filename": "library/core/src/iter/sources/once_with.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fonce_with.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,109 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates an iterator that lazily generates a value exactly once by invoking\n+/// the provided closure.\n+///\n+/// This is commonly used to adapt a single value generator into a [`chain()`] of\n+/// other kinds of iteration. Maybe you have an iterator that covers almost\n+/// everything, but you need an extra special case. Maybe you have a function\n+/// which works on iterators, but you only need to process one value.\n+///\n+/// Unlike [`once()`], this function will lazily generate the value on request.\n+///\n+/// [`chain()`]: Iterator::chain\n+/// [`once()`]: crate::iter::once\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // one is the loneliest number\n+/// let mut one = iter::once_with(|| 1);\n+///\n+/// assert_eq!(Some(1), one.next());\n+///\n+/// // just one, that's all we get\n+/// assert_eq!(None, one.next());\n+/// ```\n+///\n+/// Chaining together with another iterator. Let's say that we want to iterate\n+/// over each file of the `.foo` directory, but also a configuration file,\n+/// `.foorc`:\n+///\n+/// ```no_run\n+/// use std::iter;\n+/// use std::fs;\n+/// use std::path::PathBuf;\n+///\n+/// let dirs = fs::read_dir(\".foo\").unwrap();\n+///\n+/// // we need to convert from an iterator of DirEntry-s to an iterator of\n+/// // PathBufs, so we use map\n+/// let dirs = dirs.map(|file| file.unwrap().path());\n+///\n+/// // now, our iterator just for our config file\n+/// let config = iter::once_with(|| PathBuf::from(\".foorc\"));\n+///\n+/// // chain the two iterators together into one big iterator\n+/// let files = dirs.chain(config);\n+///\n+/// // this will give us all of the files in .foo as well as .foorc\n+/// for f in files {\n+///     println!(\"{:?}\", f);\n+/// }\n+/// ```\n+#[inline]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub fn once_with<A, F: FnOnce() -> A>(gen: F) -> OnceWith<F> {\n+    OnceWith { gen: Some(gen) }\n+}\n+\n+/// An iterator that yields a single element of type `A` by\n+/// applying the provided closure `F: FnOnce() -> A`.\n+///\n+/// This `struct` is created by the [`once_with()`] function.\n+/// See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+pub struct OnceWith<F> {\n+    gen: Option<F>,\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> Iterator for OnceWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let f = self.gen.take()?;\n+        Some(f())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.gen.iter().size_hint()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> DoubleEndedIterator for OnceWith<F> {\n+    fn next_back(&mut self) -> Option<A> {\n+        self.next()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> ExactSizeIterator for OnceWith<F> {\n+    fn len(&self) -> usize {\n+        self.gen.iter().len()\n+    }\n+}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+impl<A, F: FnOnce() -> A> FusedIterator for OnceWith<F> {}\n+\n+#[stable(feature = \"iter_once_with\", since = \"1.43.0\")]\n+unsafe impl<A, F: FnOnce() -> A> TrustedLen for OnceWith<F> {}"}, {"sha": "d1f2879235f1a93412c2d66b7a9f31365822d002", "filename": "library/core/src/iter/sources/repeat.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,93 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates a new iterator that endlessly repeats a single element.\n+///\n+/// The `repeat()` function repeats a single value over and over again.\n+///\n+/// Infinite iterators like `repeat()` are often used with adapters like\n+/// [`Iterator::take()`], in order to make them finite.\n+///\n+/// If the element type of the iterator you need does not implement `Clone`,\n+/// or if you do not want to keep the repeated element in memory, you can\n+/// instead use the [`repeat_with()`] function.\n+///\n+/// [`repeat_with()`]: crate::iter::repeat_with\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // the number four 4ever:\n+/// let mut fours = iter::repeat(4);\n+///\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+/// assert_eq!(Some(4), fours.next());\n+///\n+/// // yup, still four\n+/// assert_eq!(Some(4), fours.next());\n+/// ```\n+///\n+/// Going finite with [`Iterator::take()`]:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // that last example was too many fours. Let's only have four fours.\n+/// let mut four_fours = iter::repeat(4).take(4);\n+///\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+/// assert_eq!(Some(4), four_fours.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, four_fours.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n+    Repeat { element: elt }\n+}\n+\n+/// An iterator that repeats an element endlessly.\n+///\n+/// This `struct` is created by the [`repeat()`] function. See its documentation for more.\n+#[derive(Clone, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct Repeat<A> {\n+    element: A,\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> Iterator for Repeat<A> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        Some(self.element.clone())\n+    }\n+}\n+\n+#[stable(feature = \"fused\", since = \"1.26.0\")]\n+impl<A: Clone> FusedIterator for Repeat<A> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A: Clone> TrustedLen for Repeat<A> {}"}, {"sha": "44bc6890c55b5e8ae3505759a2fe6c357fe07d06", "filename": "library/core/src/iter/sources/repeat_with.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Frepeat_with.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,98 @@\n+use crate::iter::{FusedIterator, TrustedLen};\n+\n+/// Creates a new iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure, the repeater, `F: FnMut() -> A`.\n+///\n+/// The `repeat_with()` function calls the repeater over and over again.\n+///\n+/// Infinite iterators like `repeat_with()` are often used with adapters like\n+/// [`Iterator::take()`], in order to make them finite.\n+///\n+/// If the element type of the iterator you need implements [`Clone`], and\n+/// it is OK to keep the source element in memory, you should instead use\n+/// the [`repeat()`] function.\n+///\n+/// An iterator produced by `repeat_with()` is not a [`DoubleEndedIterator`].\n+/// If you need `repeat_with()` to return a [`DoubleEndedIterator`],\n+/// please open a GitHub issue explaining your use case.\n+///\n+/// [`repeat()`]: crate::iter::repeat\n+/// [`DoubleEndedIterator`]: crate::iter::DoubleEndedIterator\n+///\n+/// # Examples\n+///\n+/// Basic usage:\n+///\n+/// ```\n+/// use std::iter;\n+///\n+/// // let's assume we have some value of a type that is not `Clone`\n+/// // or which don't want to have in memory just yet because it is expensive:\n+/// #[derive(PartialEq, Debug)]\n+/// struct Expensive;\n+///\n+/// // a particular value forever:\n+/// let mut things = iter::repeat_with(|| Expensive);\n+///\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// assert_eq!(Some(Expensive), things.next());\n+/// ```\n+///\n+/// Using mutation and going finite:\n+///\n+/// ```rust\n+/// use std::iter;\n+///\n+/// // From the zeroth to the third power of two:\n+/// let mut curr = 1;\n+/// let mut pow2 = iter::repeat_with(|| { let tmp = curr; curr *= 2; tmp })\n+///                     .take(4);\n+///\n+/// assert_eq!(Some(1), pow2.next());\n+/// assert_eq!(Some(2), pow2.next());\n+/// assert_eq!(Some(4), pow2.next());\n+/// assert_eq!(Some(8), pow2.next());\n+///\n+/// // ... and now we're done\n+/// assert_eq!(None, pow2.next());\n+/// ```\n+#[inline]\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub fn repeat_with<A, F: FnMut() -> A>(repeater: F) -> RepeatWith<F> {\n+    RepeatWith { repeater }\n+}\n+\n+/// An iterator that repeats elements of type `A` endlessly by\n+/// applying the provided closure `F: FnMut() -> A`.\n+///\n+/// This `struct` is created by the [`repeat_with()`] function.\n+/// See its documentation for more.\n+#[derive(Copy, Clone, Debug)]\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+pub struct RepeatWith<F> {\n+    repeater: F,\n+}\n+\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+impl<A, F: FnMut() -> A> Iterator for RepeatWith<F> {\n+    type Item = A;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        Some((self.repeater)())\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}\n+\n+#[stable(feature = \"iterator_repeat_with\", since = \"1.28.0\")]\n+impl<A, F: FnMut() -> A> FusedIterator for RepeatWith<F> {}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<A, F: FnMut() -> A> TrustedLen for RepeatWith<F> {}"}, {"sha": "99f058a901a3103f3c8e069a4cebd54d88ccf076", "filename": "library/core/src/iter/sources/successors.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fsources%2Fsuccessors.rs?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -0,0 +1,66 @@\n+use crate::{fmt, iter::FusedIterator};\n+\n+/// Creates a new iterator where each successive item is computed based on the preceding one.\n+///\n+/// The iterator starts with the given first item (if any)\n+/// and calls the given `FnMut(&T) -> Option<T>` closure to compute each item\u2019s successor.\n+///\n+/// ```\n+/// use std::iter::successors;\n+///\n+/// let powers_of_10 = successors(Some(1_u16), |n| n.checked_mul(10));\n+/// assert_eq!(powers_of_10.collect::<Vec<_>>(), &[1, 10, 100, 1_000, 10_000]);\n+/// ```\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+pub fn successors<T, F>(first: Option<T>, succ: F) -> Successors<T, F>\n+where\n+    F: FnMut(&T) -> Option<T>,\n+{\n+    // If this function returned `impl Iterator<Item=T>`\n+    // it could be based on `unfold` and not need a dedicated type.\n+    // However having a named `Successors<T, F>` type allows it to be `Clone` when `T` and `F` are.\n+    Successors { next: first, succ }\n+}\n+\n+/// An new iterator where each successive item is computed based on the preceding one.\n+///\n+/// This `struct` is created by the [`iter::successors()`] function.\n+/// See its documentation for more.\n+///\n+/// [`iter::successors()`]: successors\n+#[derive(Clone)]\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+pub struct Successors<T, F> {\n+    next: Option<T>,\n+    succ: F,\n+}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T, F> Iterator for Successors<T, F>\n+where\n+    F: FnMut(&T) -> Option<T>,\n+{\n+    type Item = T;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let item = self.next.take()?;\n+        self.next = (self.succ)(&item);\n+        Some(item)\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.next.is_some() { (1, None) } else { (0, Some(0)) }\n+    }\n+}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T, F> FusedIterator for Successors<T, F> where F: FnMut(&T) -> Option<T> {}\n+\n+#[stable(feature = \"iter_successors\", since = \"1.34.0\")]\n+impl<T: fmt::Debug, F> fmt::Debug for Successors<T, F> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"Successors\").field(\"next\", &self.next).finish()\n+    }\n+}"}, {"sha": "d371703e29587379387388a4358bccce21f255fb", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -13,11 +13,13 @@ error[E0599]: no method named `collect` found for struct `Cloned<TakeWhile<&mut\n LL |         .collect();\n    |          ^^^^^^^ method not found in `Cloned<TakeWhile<&mut std::vec::IntoIter<u8>, [closure@$DIR/issue-31173.rs:6:39: 9:6]>>`\n    | \n-  ::: $SRC_DIR/core/src/iter/adapters/mod.rs:LL:COL\n+  ::: $SRC_DIR/core/src/iter/adapters/cloned.rs:LL:COL\n    |\n LL | pub struct Cloned<I> {\n    | -------------------- doesn't satisfy `_: Iterator`\n-...\n+   | \n+  ::: $SRC_DIR/core/src/iter/adapters/take_while.rs:LL:COL\n+   |\n LL | pub struct TakeWhile<I, P> {\n    | -------------------------- doesn't satisfy `<_ as Iterator>::Item = &_`\n    |"}, {"sha": "2efd37b4738a5130bafa0bd3d255e9116d55fa94", "filename": "src/test/ui/mismatched_types/issue-36053-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4407049fcbdc8fce56573a4271b90384a269abbc/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4407049fcbdc8fce56573a4271b90384a269abbc/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-36053-2.stderr?ref=4407049fcbdc8fce56573a4271b90384a269abbc", "patch": "@@ -15,7 +15,7 @@ LL |     once::<&str>(\"str\").fuse().filter(|a: &str| true).count();\n    |                                       doesn't satisfy `<_ as FnOnce<(&&str,)>>::Output = bool`\n    |                                       doesn't satisfy `_: FnMut<(&&str,)>`\n    | \n-  ::: $SRC_DIR/core/src/iter/adapters/mod.rs:LL:COL\n+  ::: $SRC_DIR/core/src/iter/adapters/filter.rs:LL:COL\n    |\n LL | pub struct Filter<I, P> {\n    | ----------------------- doesn't satisfy `_: Iterator`"}]}