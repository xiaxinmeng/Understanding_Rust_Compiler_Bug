{"sha": "34966aab55e0a86be6a6dbe57596151ee8c74263", "node_id": "C_kwDOAAsO6NoAKDM0OTY2YWFiNTVlMGE4NmJlNmE2ZGJlNTc1OTYxNTFlZThjNzQyNjM", "commit": {"author": {"name": "Obei Sideg", "email": "obei.sideg@gmail.com", "date": "2023-02-24T20:23:30Z"}, "committer": {"name": "Obei Sideg", "email": "obei.sideg@gmail.com", "date": "2023-02-24T20:23:30Z"}, "message": "Migrate `rustc_hir_analysis` to session diagnostic\n\nPart one, lib.rs file", "tree": {"sha": "ad9bc85d9d65e55f9c1ab75abfa4cb470aa0e35d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad9bc85d9d65e55f9c1ab75abfa4cb470aa0e35d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34966aab55e0a86be6a6dbe57596151ee8c74263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34966aab55e0a86be6a6dbe57596151ee8c74263", "html_url": "https://github.com/rust-lang/rust/commit/34966aab55e0a86be6a6dbe57596151ee8c74263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34966aab55e0a86be6a6dbe57596151ee8c74263/comments", "author": {"login": "obeis", "id": 54103142, "node_id": "MDQ6VXNlcjU0MTAzMTQy", "avatar_url": "https://avatars.githubusercontent.com/u/54103142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/obeis", "html_url": "https://github.com/obeis", "followers_url": "https://api.github.com/users/obeis/followers", "following_url": "https://api.github.com/users/obeis/following{/other_user}", "gists_url": "https://api.github.com/users/obeis/gists{/gist_id}", "starred_url": "https://api.github.com/users/obeis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/obeis/subscriptions", "organizations_url": "https://api.github.com/users/obeis/orgs", "repos_url": "https://api.github.com/users/obeis/repos", "events_url": "https://api.github.com/users/obeis/events{/privacy}", "received_events_url": "https://api.github.com/users/obeis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "obeis", "id": 54103142, "node_id": "MDQ6VXNlcjU0MTAzMTQy", "avatar_url": "https://avatars.githubusercontent.com/u/54103142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/obeis", "html_url": "https://github.com/obeis", "followers_url": "https://api.github.com/users/obeis/followers", "following_url": "https://api.github.com/users/obeis/following{/other_user}", "gists_url": "https://api.github.com/users/obeis/gists{/gist_id}", "starred_url": "https://api.github.com/users/obeis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/obeis/subscriptions", "organizations_url": "https://api.github.com/users/obeis/orgs", "repos_url": "https://api.github.com/users/obeis/repos", "events_url": "https://api.github.com/users/obeis/events{/privacy}", "received_events_url": "https://api.github.com/users/obeis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07c993eba8b76eae497e98433ae075b00f01be10", "url": "https://api.github.com/repos/rust-lang/rust/commits/07c993eba8b76eae497e98433ae075b00f01be10", "html_url": "https://github.com/rust-lang/rust/commit/07c993eba8b76eae497e98433ae075b00f01be10"}], "stats": {"total": 170, "additions": 107, "deletions": 63}, "files": [{"sha": "e87731160d93f2de86fc0908ffe649ce7ff7ee78", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/34966aab55e0a86be6a6dbe57596151ee8c74263/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/34966aab55e0a86be6a6dbe57596151ee8c74263/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=34966aab55e0a86be6a6dbe57596151ee8c74263", "patch": "@@ -132,3 +132,26 @@ hir_analysis_where_clause_on_main = `main` function is not allowed to have a `wh\n \n hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n     .label = `main` function is not allowed to be `#[track_caller]`\n+\n+hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n+    .label = `start` is not allowed to be `#[track_caller]`\n+\n+hir_analysis_start_not_async = `start` is not allowed to be `async`\n+    .label = `start` is not allowed to be `async`\n+\n+hir_analysis_start_function_where = start function is not allowed to have a `where` clause\n+    .label = start function cannot have a `where` clause\n+\n+hir_analysis_start_function_parameters = start function is not allowed to have type parameters\n+    .label = start function cannot have type parameters\n+\n+hir_analysis_main_function_return_type_generic = `main` function return type is not allowed to have generic parameters\n+\n+hir_analysis_main_function_async = `main` function is not allowed to be `async`\n+    .label = `main` function is not allowed to be `async`\n+\n+hir_analysis_main_function_generic_parameters = `main` function is not allowed to have generic parameters\n+    .label = `main` cannot have generic parameters\n+\n+hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n+    .label = C-variadic function must have a compatible calling convention"}, {"sha": "309d02052b7b2b2ff8a54f342eba9609999cc664", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/34966aab55e0a86be6a6dbe57596151ee8c74263/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34966aab55e0a86be6a6dbe57596151ee8c74263/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=34966aab55e0a86be6a6dbe57596151ee8c74263", "patch": "@@ -333,3 +333,70 @@ pub(crate) struct TrackCallerOnMain {\n     #[label]\n     pub annotated: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_not_track_caller)]\n+pub(crate) struct StartTrackCaller {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_not_async, code = \"E0752\")]\n+pub(crate) struct StartAsync {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_function_where, code = \"E0647\")]\n+pub(crate) struct StartFunctionWhere {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_start_function_parameters, code = \"E0132\")]\n+pub(crate) struct StartFunctionParameters {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_main_function_return_type_generic, code = \"E0131\")]\n+pub(crate) struct MainFunctionReturnTypeGeneric {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_main_function_async, code = \"E0752\")]\n+pub(crate) struct MainFunctionAsync {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub asyncness: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_main_function_generic_parameters, code = \"E0131\")]\n+pub(crate) struct MainFunctionGenericParameters {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub label_span: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_variadic_function_compatible_convention, code = \"E0045\")]\n+pub(crate) struct VariadicFunctionCompatibleConvention<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    pub conventions: &'a str,\n+}"}, {"sha": "33c132fd5349bc4e61abf1daf5808cc99bb743e9", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 17, "deletions": 63, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/34966aab55e0a86be6a6dbe57596151ee8c74263/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34966aab55e0a86be6a6dbe57596151ee8c74263/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=34966aab55e0a86be6a6dbe57596151ee8c74263", "patch": "@@ -98,7 +98,7 @@ mod outlives;\n pub mod structured_errors;\n mod variance;\n \n-use rustc_errors::{struct_span_err, ErrorGuaranteed};\n+use rustc_errors::ErrorGuaranteed;\n use rustc_errors::{DiagnosticMessage, SubdiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::Node;\n@@ -123,7 +123,6 @@ use bounds::Bounds;\n fluent_messages! { \"../locales/en-US.ftl\" }\n \n fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi, span: Span) {\n-    const ERROR_HEAD: &str = \"C-variadic function must have a compatible calling convention\";\n     const CONVENTIONS_UNSTABLE: &str = \"`C`, `cdecl`, `win64`, `sysv64` or `efiapi`\";\n     const CONVENTIONS_STABLE: &str = \"`C` or `cdecl`\";\n     const UNSTABLE_EXPLAIN: &str =\n@@ -155,8 +154,7 @@ fn require_c_abi_if_c_variadic(tcx: TyCtxt<'_>, decl: &hir::FnDecl<'_>, abi: Abi\n         (true, false) => CONVENTIONS_UNSTABLE,\n     };\n \n-    let mut err = struct_span_err!(tcx.sess, span, E0045, \"{}, like {}\", ERROR_HEAD, conventions);\n-    err.span_label(span, ERROR_HEAD).emit();\n+    tcx.sess.emit_err(errors::VariadicFunctionCompatibleConvention { span, conventions });\n }\n \n fn require_same_types<'tcx>(\n@@ -258,15 +256,10 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n     let main_fn_predicates = tcx.predicates_of(main_def_id);\n     if main_fn_generics.count() != 0 || !main_fnsig.bound_vars().is_empty() {\n         let generics_param_span = main_fn_generics_params_span(tcx, main_def_id);\n-        let msg = \"`main` function is not allowed to have generic \\\n-            parameters\";\n-        let mut diag =\n-            struct_span_err!(tcx.sess, generics_param_span.unwrap_or(main_span), E0131, \"{}\", msg);\n-        if let Some(generics_param_span) = generics_param_span {\n-            let label = \"`main` cannot have generic parameters\";\n-            diag.span_label(generics_param_span, label);\n-        }\n-        diag.emit();\n+        tcx.sess.emit_err(errors::MainFunctionGenericParameters {\n+            span: generics_param_span.unwrap_or(main_span),\n+            label_span: generics_param_span,\n+        });\n         error = true;\n     } else if !main_fn_predicates.predicates.is_empty() {\n         // generics may bring in implicit predicates, so we skip this check if generics is present.\n@@ -280,17 +273,8 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n \n     let main_asyncness = tcx.asyncness(main_def_id);\n     if let hir::IsAsync::Async = main_asyncness {\n-        let mut diag = struct_span_err!(\n-            tcx.sess,\n-            main_span,\n-            E0752,\n-            \"`main` function is not allowed to be `async`\"\n-        );\n         let asyncness_span = main_fn_asyncness_span(tcx, main_def_id);\n-        if let Some(asyncness_span) = asyncness_span {\n-            diag.span_label(asyncness_span, \"`main` function is not allowed to be `async`\");\n-        }\n-        diag.emit();\n+        tcx.sess.emit_err(errors::MainFunctionAsync { span: main_span, asyncness: asyncness_span });\n         error = true;\n     }\n \n@@ -308,9 +292,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: DefId) {\n         let return_ty = main_fnsig.output();\n         let return_ty_span = main_fn_return_type_span(tcx, main_def_id).unwrap_or(main_span);\n         if !return_ty.bound_vars().is_empty() {\n-            let msg = \"`main` function return type is not allowed to have generic \\\n-                    parameters\";\n-            struct_span_err!(tcx.sess, return_ty_span, E0131, \"{}\", msg).emit();\n+            tcx.sess.emit_err(errors::MainFunctionReturnTypeGeneric { span: return_ty_span });\n             error = true;\n         }\n         let return_ty = return_ty.skip_binder();\n@@ -367,56 +349,28 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                 if let hir::ItemKind::Fn(sig, generics, _) = &it.kind {\n                     let mut error = false;\n                     if !generics.params.is_empty() {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            generics.span,\n-                            E0132,\n-                            \"start function is not allowed to have type parameters\"\n-                        )\n-                        .span_label(generics.span, \"start function cannot have type parameters\")\n-                        .emit();\n+                        tcx.sess.emit_err(errors::StartFunctionParameters { span: generics.span });\n                         error = true;\n                     }\n                     if generics.has_where_clause_predicates {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            generics.where_clause_span,\n-                            E0647,\n-                            \"start function is not allowed to have a `where` clause\"\n-                        )\n-                        .span_label(\n-                            generics.where_clause_span,\n-                            \"start function cannot have a `where` clause\",\n-                        )\n-                        .emit();\n+                        tcx.sess.emit_err(errors::StartFunctionWhere {\n+                            span: generics.where_clause_span,\n+                        });\n                         error = true;\n                     }\n                     if let hir::IsAsync::Async = sig.header.asyncness {\n                         let span = tcx.def_span(it.owner_id);\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            span,\n-                            E0752,\n-                            \"`start` is not allowed to be `async`\"\n-                        )\n-                        .span_label(span, \"`start` is not allowed to be `async`\")\n-                        .emit();\n+                        tcx.sess.emit_err(errors::StartAsync { span: span });\n                         error = true;\n                     }\n \n                     let attrs = tcx.hir().attrs(start_id);\n                     for attr in attrs {\n                         if attr.has_name(sym::track_caller) {\n-                            tcx.sess\n-                                .struct_span_err(\n-                                    attr.span,\n-                                    \"`start` is not allowed to be `#[track_caller]`\",\n-                                )\n-                                .span_label(\n-                                    start_span,\n-                                    \"`start` is not allowed to be `#[track_caller]`\",\n-                                )\n-                                .emit();\n+                            tcx.sess.emit_err(errors::StartTrackCaller {\n+                                span: attr.span,\n+                                start: start_span,\n+                            });\n                             error = true;\n                         }\n                     }"}]}