{"sha": "906264b50fa6b69eed567388063233bd279242b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNjI2NGI1MGZhNmI2OWVlZDU2NzM4ODA2MzIzM2JkMjc5MjQyYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-25T10:07:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-07-25T10:07:44Z"}, "message": "auto merge of #8015 : msullivan/rust/default-methods, r=nikomatsakis\n\nLots of changes to vtable resolution, handling of super/self method calls in default methods. Fix a lot of trait inheritance bugs.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "cfe2808a6e0bbb5aec20ade1ee0af8174f8fc34d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfe2808a6e0bbb5aec20ade1ee0af8174f8fc34d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/906264b50fa6b69eed567388063233bd279242b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/906264b50fa6b69eed567388063233bd279242b1", "html_url": "https://github.com/rust-lang/rust/commit/906264b50fa6b69eed567388063233bd279242b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/906264b50fa6b69eed567388063233bd279242b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b30a16c9aefbc568f67c8121f170b6d478102c5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b30a16c9aefbc568f67c8121f170b6d478102c5f", "html_url": "https://github.com/rust-lang/rust/commit/b30a16c9aefbc568f67c8121f170b6d478102c5f"}, {"sha": "f37c7cd30651e6514c6ac03a081940e28a53292c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f37c7cd30651e6514c6ac03a081940e28a53292c", "html_url": "https://github.com/rust-lang/rust/commit/f37c7cd30651e6514c6ac03a081940e28a53292c"}], "stats": {"total": 1406, "additions": 776, "deletions": 630}, "files": [{"sha": "46a744572749144de0fdc132721f453ea18cff2e", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -732,6 +732,11 @@ impl Ord for Sign {\n     }\n }\n \n+impl TotalEq for Sign {\n+    fn equals(&self, other: &Sign) -> bool {\n+        *self == *other\n+    }\n+}\n impl TotalOrd for Sign {\n \n     fn cmp(&self, other: &Sign) -> Ordering {"}, {"sha": "ff14009e5561a47fa2a4f3a7f8495b4298438f51", "filename": "src/libextra/num/rational.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibextra%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibextra%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Frational.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -110,6 +110,25 @@ cmp_impl!(impl TotalEq, equals)\n cmp_impl!(impl Ord, lt, gt, le, ge)\n cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n \n+impl<T: Clone + Integer + Ord> Orderable for Ratio<T> {\n+    #[inline]\n+    fn min(&self, other: &Ratio<T>) -> Ratio<T> {\n+        if *self < *other { self.clone() } else { other.clone() }\n+    }\n+\n+    #[inline]\n+    fn max(&self, other: &Ratio<T>) -> Ratio<T> {\n+        if *self > *other { self.clone() } else { other.clone() }\n+    }\n+\n+    #[inline]\n+    fn clamp(&self, mn: &Ratio<T>, mx: &Ratio<T>) -> Ratio<T> {\n+        if *self > *mx { mx.clone()} else\n+        if *self < *mn { mn.clone() } else { self.clone() }\n+    }\n+}\n+\n+\n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)\n impl<T: Clone + Integer + Ord>"}, {"sha": "1c5d202d4d953644fee972fefc12522dcf4731a6", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -180,6 +180,7 @@ pub static tag_misc_info: uint = 0x7f;\n pub static tag_misc_info_crate_items: uint = 0x80;\n \n pub static tag_item_method_provided_source: uint = 0x81;\n+pub static tag_item_impl_vtables: uint = 0x82;\n \n pub struct LinkMeta {\n     name: @str,"}, {"sha": "6f7feae4479b98d5b2de29b85d2761a3e5f4dda8", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -16,6 +16,7 @@ use metadata::cstore;\n use metadata::decoder;\n use metadata;\n use middle::ty;\n+use middle::typeck;\n \n use std::vec;\n use reader = extra::ebml::reader;\n@@ -216,6 +217,14 @@ pub fn get_impl_trait(tcx: ty::ctxt,\n     decoder::get_impl_trait(cdata, def.node, tcx)\n }\n \n+// Given a def_id for an impl, return information about its vtables\n+pub fn get_impl_vtables(tcx: ty::ctxt,\n+                        def: ast::def_id) -> typeck::impl_res {\n+    let cstore = tcx.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_impl_vtables(cdata, def.node, tcx)\n+}\n+\n pub fn get_impl_method(cstore: @mut cstore::CStore,\n                        def: ast::def_id,\n                        mname: ast::ident)"}, {"sha": "01c5019154f505a71f0046b58b17d7c779d39d59", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -21,6 +21,9 @@ use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::ty;\n+use middle::typeck;\n+use middle::astencode::vtable_decoder_helpers;\n+\n \n use std::hash::HashUtil;\n use std::uint;\n@@ -410,6 +413,21 @@ pub fn get_impl_trait(cdata: cmd,\n     }\n }\n \n+pub fn get_impl_vtables(cdata: cmd,\n+                        id: ast::node_id,\n+                        tcx: ty::ctxt) -> typeck::impl_res\n+{\n+    let item_doc = lookup_item(id, cdata.data);\n+    let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n+    let mut decoder = reader::Decoder(vtables_doc);\n+\n+    typeck::impl_res {\n+        trait_vtables: decoder.read_vtable_res(tcx, cdata),\n+        self_vtables: decoder.read_vtable_param_res(tcx, cdata)\n+    }\n+}\n+\n+\n pub fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                        name: ast::ident) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);"}, {"sha": "c216e8d23865f60dff6263e6e305a7ace2d75fb6", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -17,6 +17,8 @@ use metadata::decoder;\n use metadata::tyencode;\n use middle::ty::{node_id_to_type, lookup_item_type};\n use middle::ty;\n+use middle::typeck;\n+use middle::astencode;\n use middle;\n \n use std::hash::HashUtil;\n@@ -161,6 +163,15 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n     ebml_w.end_tag();\n }\n \n+fn encode_impl_vtables(ebml_w: &mut writer::Encoder,\n+                       ecx: &EncodeContext,\n+                       vtables: &typeck::impl_res) {\n+    ebml_w.start_tag(tag_item_impl_vtables);\n+    astencode::encode_vtable_res(ecx, ebml_w, vtables.trait_vtables);\n+    astencode::encode_vtable_param_res(ecx, ebml_w, vtables.self_vtables);\n+    ebml_w.end_tag();\n+}\n+\n // Item info table encoding\n fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n@@ -1008,6 +1019,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n+            let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n+            encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         ebml_w.end_tag();"}, {"sha": "bf39be407c522f1585961ffb1bcaef3327b68f02", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -250,13 +250,21 @@ impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n \n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n+    fn read_def_id_noxcx(&mut self,\n+                         cdata: @cstore::crate_metadata) -> ast::def_id;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n         let did: ast::def_id = Decodable::decode(self);\n         did.tr(xcx)\n     }\n+\n+    fn read_def_id_noxcx(&mut self,\n+                         cdata: @cstore::crate_metadata) -> ast::def_id {\n+        let did: ast::def_id = Decodable::decode(self);\n+        decoder::translate_def_id(cdata, did)\n+    }\n }\n \n // ______________________________________________________________________\n@@ -582,34 +590,35 @@ impl tr for method_origin {\n           typeck::method_trait(did, m, vstore) => {\n               typeck::method_trait(did.tr(xcx), m, vstore)\n           }\n-          typeck::method_self(did, m) => {\n-              typeck::method_self(did.tr(xcx), m)\n-          }\n-          typeck::method_super(trait_did, m) => {\n-              typeck::method_super(trait_did.tr(xcx), m)\n-          }\n         }\n     }\n }\n \n // ______________________________________________________________________\n // Encoding and decoding vtable_res\n \n-fn encode_vtable_res(ecx: &e::EncodeContext,\n+pub fn encode_vtable_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     do ebml_w.emit_from_vec(*dr) |ebml_w, param_tables| {\n-        do ebml_w.emit_from_vec(**param_tables) |ebml_w, vtable_origin| {\n-            encode_vtable_origin(ecx, ebml_w, vtable_origin)\n-        }\n+        encode_vtable_param_res(ecx, ebml_w, *param_tables);\n     }\n }\n \n-fn encode_vtable_origin(ecx: &e::EncodeContext,\n+pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n+                     ebml_w: &mut writer::Encoder,\n+                     param_tables: typeck::vtable_param_res) {\n+    do ebml_w.emit_from_vec(*param_tables) |ebml_w, vtable_origin| {\n+        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+    }\n+}\n+\n+\n+pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n     do ebml_w.emit_enum(\"vtable_origin\") |ebml_w| {\n@@ -630,40 +639,46 @@ fn encode_vtable_origin(ecx: &e::EncodeContext,\n           typeck::vtable_param(pn, bn) => {\n             do ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u) |ebml_w| {\n                 do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n-                    ebml_w.emit_uint(pn);\n+                    pn.encode(ebml_w);\n                 }\n                 do ebml_w.emit_enum_variant_arg(1u) |ebml_w| {\n                     ebml_w.emit_uint(bn);\n                 }\n             }\n           }\n-          typeck::vtable_self(def_id) => {\n-            do ebml_w.emit_enum_variant(\"vtable_self\", 2u, 1u) |ebml_w| {\n-                do ebml_w.emit_enum_variant_arg(0u) |ebml_w| {\n-                    ebml_w.emit_def_id(def_id)\n-                }\n-            }\n-          }\n         }\n     }\n }\n \n-trait vtable_decoder_helpers {\n-    fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n+pub trait vtable_decoder_helpers {\n+    fn read_vtable_res(&mut self,\n+                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res;\n-    fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_vtable_param_res(&mut self,\n+                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                      -> typeck::vtable_param_res;\n+    fn read_vtable_origin(&mut self,\n+                          tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n                           -> typeck::vtable_origin;\n }\n \n impl vtable_decoder_helpers for reader::Decoder {\n-    fn read_vtable_res(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_vtable_res(&mut self,\n+                       tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n         @self.read_to_vec(|this|\n-           @this.read_to_vec(|this|\n-               this.read_vtable_origin(xcx)))\n+                          this.read_vtable_param_res(tcx, cdata))\n     }\n \n-    fn read_vtable_origin(&mut self, xcx: @ExtendedDecodeContext)\n+    fn read_vtable_param_res(&mut self,\n+                             tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n+                      -> typeck::vtable_param_res {\n+        @self.read_to_vec(|this|\n+                          this.read_vtable_origin(tcx, cdata))\n+    }\n+\n+    fn read_vtable_origin(&mut self,\n+                          tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n         do self.read_enum(\"vtable_origin\") |this| {\n             do this.read_enum_variant([\"vtable_static\",\n@@ -674,33 +689,26 @@ impl vtable_decoder_helpers for reader::Decoder {\n                   0 => {\n                     typeck::vtable_static(\n                         do this.read_enum_variant_arg(0u) |this| {\n-                            this.read_def_id(xcx)\n+                            this.read_def_id_noxcx(cdata)\n                         },\n                         do this.read_enum_variant_arg(1u) |this| {\n-                            this.read_tys(xcx)\n+                            this.read_tys_noxcx(tcx, cdata)\n                         },\n                         do this.read_enum_variant_arg(2u) |this| {\n-                            this.read_vtable_res(xcx)\n+                            this.read_vtable_res(tcx, cdata)\n                         }\n                     )\n                   }\n                   1 => {\n                     typeck::vtable_param(\n                         do this.read_enum_variant_arg(0u) |this| {\n-                            this.read_uint()\n+                            Decodable::decode(this)\n                         },\n                         do this.read_enum_variant_arg(1u) |this| {\n                             this.read_uint()\n                         }\n                     )\n                   }\n-                  2 => {\n-                    typeck::vtable_self(\n-                        do this.read_enum_variant_arg(0u) |this| {\n-                            this.read_def_id(xcx)\n-                        }\n-                    )\n-                  }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n                 }\n@@ -995,9 +1003,35 @@ trait ebml_decoder_decoder_helpers {\n                       source: DefIdSource,\n                       did: ast::def_id)\n                       -> ast::def_id;\n+\n+    // Versions of the type reading functions that don't need the full\n+    // ExtendedDecodeContext.\n+    fn read_ty_noxcx(&mut self,\n+                     tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t;\n+    fn read_tys_noxcx(&mut self,\n+                      tcx: ty::ctxt,\n+                      cdata: @cstore::crate_metadata) -> ~[ty::t];\n }\n \n impl ebml_decoder_decoder_helpers for reader::Decoder {\n+    fn read_ty_noxcx(&mut self,\n+                     tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n+        do self.read_opaque |_, doc| {\n+            tydecode::parse_ty_data(\n+                *doc.data,\n+                cdata.cnum,\n+                doc.start,\n+                tcx,\n+                |_, id| decoder::translate_def_id(cdata, id))\n+        }\n+    }\n+\n+    fn read_tys_noxcx(&mut self,\n+                      tcx: ty::ctxt,\n+                      cdata: @cstore::crate_metadata) -> ~[ty::t] {\n+        self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n+    }\n+\n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n@@ -1160,8 +1194,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                             val_dsr.read_method_map_entry(xcx));\n                     }\n                     c::tag_table_vtable_map => {\n-                        dcx.maps.vtable_map.insert(id,\n-                                                   val_dsr.read_vtable_res(xcx));\n+                        dcx.maps.vtable_map.insert(\n+                            id,\n+                            val_dsr.read_vtable_res(xcx.dcx.tcx, xcx.dcx.cdata));\n                     }\n                     c::tag_table_adjustments => {\n                         let adj: @ty::AutoAdjustment = @Decodable::decode(val_dsr);"}, {"sha": "e768a6d687c2ebf2e78180f4d21a9a262457588f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -15,8 +15,7 @@\n use metadata::csearch;\n use middle::ty::{ty_struct, ty_enum};\n use middle::ty;\n-use middle::typeck::{method_map, method_origin, method_param, method_self};\n-use middle::typeck::{method_super};\n+use middle::typeck::{method_map, method_origin, method_param};\n use middle::typeck::{method_static, method_trait};\n \n use std::util::ignore;\n@@ -291,9 +290,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                  method_num: method_num,\n                  _\n             }) |\n-            method_trait(trait_id, method_num, _) |\n-            method_self(trait_id, method_num) |\n-            method_super(trait_id, method_num) => {\n+            method_trait(trait_id, method_num, _) => {\n                 if trait_id.crate == local_crate {\n                     match tcx.items.find(&trait_id.node) {\n                         Some(&node_item(item, _)) => {"}, {"sha": "057e2ae531c644da2dc6e56f8f6420d45d046e63", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -193,42 +193,27 @@ pub fn trans_fn_ref_with_vtables_to_callee(\n                                                type_params, vtables))}\n }\n \n-fn get_impl_resolutions(bcx: @mut Block,\n-                        impl_id: ast::def_id)\n-                         -> typeck::vtable_res {\n-    if impl_id.crate == ast::local_crate {\n-        bcx.ccx().maps.vtable_map.get_copy(&impl_id.node)\n-    } else {\n-        // XXX: This is a temporary hack to work around not properly\n-        // exporting information about resolutions for impls.\n-        // This doesn't actually work if the trait has param bounds,\n-        // but it does allow us to survive the case when it does not.\n-        let trait_ref = ty::impl_trait_ref(bcx.tcx(), impl_id).get();\n-        @vec::from_elem(trait_ref.substs.tps.len(), @~[])\n-    }\n-}\n-\n fn resolve_default_method_vtables(bcx: @mut Block,\n                                   impl_id: ast::def_id,\n                                   method: &ty::Method,\n                                   substs: &ty::substs,\n                                   impl_vtables: Option<typeck::vtable_res>)\n-                                 -> typeck::vtable_res {\n+                          -> (typeck::vtable_res, typeck::vtable_param_res) {\n \n     // Get the vtables that the impl implements the trait at\n-    let trait_vtables = get_impl_resolutions(bcx, impl_id);\n+    let impl_res = ty::lookup_impl_vtables(bcx.tcx(), impl_id);\n \n     // Build up a param_substs that we are going to resolve the\n     // trait_vtables under.\n     let param_substs = Some(@param_substs {\n         tys: substs.tps.clone(),\n         self_ty: substs.self_ty,\n         vtables: impl_vtables,\n-        self_vtable: None\n+        self_vtables: None\n     });\n \n     let trait_vtables_fixed = resolve_vtables_under_param_substs(\n-        bcx.tcx(), param_substs, trait_vtables);\n+        bcx.tcx(), param_substs, impl_res.trait_vtables);\n \n     // Now we pull any vtables for parameters on the actual method.\n     let num_method_vtables = method.generics.type_param_defs.len();\n@@ -241,7 +226,12 @@ fn resolve_default_method_vtables(bcx: @mut Block,\n         None => vec::from_elem(num_method_vtables, @~[])\n     };\n \n-    @(*trait_vtables_fixed + method_vtables)\n+    let param_vtables = @(*trait_vtables_fixed + method_vtables);\n+\n+    let self_vtables = resolve_param_vtables_under_param_substs(\n+        bcx.tcx(), param_substs, impl_res.self_vtables);\n+\n+    (param_vtables, self_vtables)\n }\n \n \n@@ -296,7 +286,7 @@ pub fn trans_fn_ref_with_vtables(\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n-    let (is_default, def_id, substs, self_vtable, vtables) =\n+    let (is_default, def_id, substs, self_vtables, vtables) =\n         match ty::provided_source(tcx, def_id) {\n         None => (false, def_id, substs, None, vtables),\n         Some(source_id) => {\n@@ -319,20 +309,6 @@ pub fn trans_fn_ref_with_vtables(\n                 .expect(\"could not find trait_ref for impl with \\\n                          default methods\");\n \n-            // Get all of the type params for the receiver\n-            let param_defs = method.generics.type_param_defs;\n-            let receiver_substs =\n-                type_params.initn(param_defs.len()).to_owned();\n-            let receiver_vtables = match vtables {\n-                None => @~[],\n-                Some(call_vtables) => {\n-                    @call_vtables.initn(param_defs.len()).to_owned()\n-                }\n-            };\n-\n-            let self_vtable =\n-                typeck::vtable_static(impl_id, receiver_substs,\n-                                      receiver_vtables);\n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n                 tcx, impl_id, trait_ref, method);\n@@ -341,20 +317,22 @@ pub fn trans_fn_ref_with_vtables(\n             let new_substs = first_subst.subst(tcx, &substs);\n \n \n-            let vtables =\n+            let (param_vtables, self_vtables) =\n                 resolve_default_method_vtables(bcx, impl_id,\n-                                               method, &new_substs, vtables);\n+                                               method, &substs, vtables);\n \n             debug!(\"trans_fn_with_vtables - default method: \\\n                     substs = %s, trait_subst = %s, \\\n                     first_subst = %s, new_subst = %s, \\\n-                    self_vtable = %s, vtables = %s\",\n+                    vtables = %s, \\\n+                    self_vtable = %s, param_vtables = %s\",\n                    substs.repr(tcx), trait_ref.substs.repr(tcx),\n                    first_subst.repr(tcx), new_substs.repr(tcx),\n-                   self_vtable.repr(tcx), vtables.repr(tcx));\n+                   vtables.repr(tcx),\n+                   self_vtables.repr(tcx), param_vtables.repr(tcx));\n \n             (true, source_id,\n-             new_substs, Some(self_vtable), Some(vtables))\n+             new_substs, Some(self_vtables), Some(param_vtables))\n         }\n     };\n \n@@ -400,7 +378,7 @@ pub fn trans_fn_ref_with_vtables(\n \n         let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n-                                         vtables, self_vtable,\n+                                         vtables, self_vtables,\n                                          Some(ref_id));\n         let mut val = val;\n         if must_cast && ref_id != 0 {"}, {"sha": "702ef71a573c63138ff3d434feb3876d7ef37879", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -133,7 +133,7 @@ pub struct param_substs {\n     tys: ~[ty::t],\n     self_ty: Option<ty::t>,\n     vtables: Option<typeck::vtable_res>,\n-    self_vtable: Option<typeck::vtable_origin>\n+    self_vtables: Option<typeck::vtable_param_res>\n }\n \n impl param_substs {\n@@ -1020,14 +1020,25 @@ pub fn resolve_vtables_under_param_substs(tcx: ty::ctxt,\n                                           vts: typeck::vtable_res)\n     -> typeck::vtable_res {\n     @vts.iter().transform(|ds|\n-      @ds.iter().transform(\n-          |d| resolve_vtable_under_param_substs(tcx,\n-                                                param_substs,\n-                                                d))\n-                          .collect::<~[typeck::vtable_origin]>())\n-        .collect::<~[typeck::vtable_param_res]>()\n+      resolve_param_vtables_under_param_substs(tcx,\n+                                               param_substs,\n+                                               *ds))\n+        .collect()\n }\n \n+pub fn resolve_param_vtables_under_param_substs(\n+    tcx: ty::ctxt,\n+    param_substs: Option<@param_substs>,\n+    ds: typeck::vtable_param_res)\n+    -> typeck::vtable_param_res {\n+    @ds.iter().transform(\n+        |d| resolve_vtable_under_param_substs(tcx,\n+                                              param_substs,\n+                                              d))\n+        .collect()\n+}\n+\n+\n \n // Apply the typaram substitutions in the FunctionContext to a vtable. This should\n // eliminate any vtable_params.\n@@ -1068,31 +1079,26 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n                 }\n             }\n         }\n-        typeck::vtable_self(_trait_id) => {\n-            match param_substs {\n-                Some(@param_substs\n-                     {self_vtable: Some(ref self_vtable), _}) => {\n-                    (*self_vtable).clone()\n-                }\n-                _ => {\n-                    tcx.sess.bug(fmt!(\n-                        \"resolve_vtable_in_fn_ctxt: asked to lookup but \\\n-                         no self_vtable in the fn_ctxt!\"))\n-                }\n-            }\n-        }\n     }\n }\n \n pub fn find_vtable(tcx: ty::ctxt,\n                    ps: &param_substs,\n-                   n_param: uint,\n+                   n_param: typeck::param_index,\n                    n_bound: uint)\n                    -> typeck::vtable_origin {\n-    debug!(\"find_vtable(n_param=%u, n_bound=%u, ps=%s)\",\n+    debug!(\"find_vtable(n_param=%?, n_bound=%u, ps=%s)\",\n            n_param, n_bound, ps.repr(tcx));\n \n-    ps.vtables.get()[n_param][n_bound].clone()\n+    let param_bounds = match n_param {\n+        typeck::param_self => ps.self_vtables.expect(\"self vtables missing\"),\n+        typeck::param_numbered(n) => {\n+            let tables = ps.vtables\n+                .expect(\"vtables missing where they are needed\");\n+            tables[n]\n+        }\n+    };\n+    param_bounds[n_bound].clone()\n }\n \n pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {"}, {"sha": "9228f20513bb6119336c60a996ec19bbcbf74f91", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -147,46 +147,13 @@ pub fn trans_method_callee(bcx: @mut Block,\n                            mentry: typeck::method_map_entry)\n                            -> Callee {\n     let _icx = push_ctxt(\"impl::trans_method_callee\");\n-    let tcx = bcx.tcx();\n \n     debug!(\"trans_method_callee(callee_id=%?, this=%s, mentry=%s)\",\n            callee_id,\n            bcx.expr_to_str(this),\n            mentry.repr(bcx.tcx()));\n \n-    // Replace method_self with method_static here.\n-    let mut origin = mentry.origin;\n-    match origin {\n-        typeck::method_super(trait_id, method_index) => {\n-            // <self_ty> is the self type for this method call\n-            let self_ty = node_id_type(bcx, this.id);\n-            // <impl_id> is the ID of the implementation of\n-            // trait <trait_id> for type <self_ty>\n-            let impl_id = ty::bogus_get_impl_id_from_ty(tcx, trait_id, self_ty);\n-            // Get the supertrait's methods\n-            let supertrait_method_def_ids = ty::trait_method_def_ids(tcx, trait_id);\n-            // Make sure to fail with a readable error message if\n-            // there's some internal error here\n-            if !(method_index < supertrait_method_def_ids.len()) {\n-                tcx.sess.bug(\"trans_method_callee: supertrait method \\\n-                              index is out of bounds\");\n-            }\n-            // Get the method name using the method index in the origin\n-            let method_name =\n-                ty::method(tcx, supertrait_method_def_ids[method_index]).ident;\n-            // Now that we know the impl ID, we can look up the method\n-            // ID from its name\n-            origin = typeck::method_static(\n-                method_with_name(bcx.ccx(), impl_id, method_name));\n-        }\n-        typeck::method_self(*) |\n-        typeck::method_static(*) | typeck::method_param(*) |\n-        typeck::method_trait(*) => {}\n-    }\n-\n-    debug!(\"origin=%?\", origin);\n-\n-    match origin {\n+    match mentry.origin {\n         typeck::method_static(did) => {\n             let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n             let mut temp_cleanups = ~[];\n@@ -210,7 +177,8 @@ pub fn trans_method_callee(bcx: @mut Block,\n         }) => {\n             match bcx.fcx.param_substs {\n                 Some(substs) => {\n-                    let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n+                    let vtbl = find_vtable(bcx.tcx(), substs,\n+                                           p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n                                                trait_id, off, vtbl)\n                 }\n@@ -219,24 +187,6 @@ pub fn trans_method_callee(bcx: @mut Block,\n             }\n         }\n \n-        typeck::method_self(trait_id, method_index) => {\n-            match bcx.fcx.param_substs {\n-                Some(@param_substs\n-                     {self_vtable: Some(ref vtbl), _}) => {\n-                    trans_monomorphized_callee(bcx,\n-                                               callee_id,\n-                                               this,\n-                                               mentry,\n-                                               trait_id,\n-                                               method_index,\n-                                               (*vtbl).clone())\n-                }\n-                _ => {\n-                    fail!(\"trans_method_callee: missing self_vtable\")\n-                }\n-            }\n-        }\n-\n         typeck::method_trait(_, off, store) => {\n             trans_trait_callee(bcx,\n                                callee_id,\n@@ -245,9 +195,6 @@ pub fn trans_method_callee(bcx: @mut Block,\n                                store,\n                                mentry.explicit_self)\n         }\n-        typeck::method_super(*) => {\n-            fail!(\"method_super should have been handled above\")\n-        }\n     }\n }\n \n@@ -402,9 +349,6 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n       typeck::vtable_param(*) => {\n           fail!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n-      typeck::vtable_self(*) => {\n-          fail!(\"vtable_self left in monomorphized function's vtable substs\");\n-      }\n     };\n \n }\n@@ -611,7 +555,7 @@ pub fn vtable_id(ccx: @mut CrateContext,\n                 tys: (*substs).clone(),\n                 vtables: Some(sub_vtables),\n                 self_ty: None,\n-                self_vtable: None\n+                self_vtables: None\n             };\n \n             monomorphize::make_mono_id("}, {"sha": "9852e6b09b76763b36994ec9bf8a978052c5c77c", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -41,7 +41,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                       fn_id: ast::def_id,\n                       real_substs: &ty::substs,\n                       vtables: Option<typeck::vtable_res>,\n-                      self_vtable: Option<typeck::vtable_origin>,\n+                      self_vtables: Option<typeck::vtable_param_res>,\n                       ref_id: Option<ast::node_id>)\n     -> (ValueRef, bool)\n {\n@@ -54,7 +54,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n            fn_id.repr(ccx.tcx),\n            real_substs.repr(ccx.tcx),\n            vtables.repr(ccx.tcx),\n-           self_vtable.repr(ccx.tcx),\n+           self_vtables.repr(ccx.tcx),\n            ref_id);\n \n     assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n@@ -72,7 +72,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n         tys: real_substs.tps.map(|x| do_normalize(x)),\n         vtables: vtables,\n         self_ty: real_substs.self_ty.map(|x| do_normalize(x)),\n-        self_vtable: self_vtable\n+        self_vtables: self_vtables\n     };\n \n     for real_substs.tps.iter().advance |s| { assert!(!ty::type_has_params(*s)); }\n@@ -371,8 +371,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n       Some(vts) => {\n         debug!(\"make_mono_id vtables=%s substs=%s\",\n                vts.repr(ccx.tcx), substs.tys.repr(ccx.tcx));\n-        let self_vtables = substs.self_vtable.map(|vtbl| @~[(*vtbl).clone()]);\n-        let vts_iter = self_vtables.iter().chain_(vts.iter());\n+        let vts_iter = substs.self_vtables.iter().chain_(vts.iter());\n         vts_iter.zip(substs_iter).transform(|(vtable, subst)| {\n             let v = vtable.map(|vt| meth::vtable_id(ccx, vt));\n             (*subst, if !v.is_empty() { Some(@v) } else { None })"}, {"sha": "aa19af01893ca5a113c2623bf6c989dda7ce28a5", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -274,13 +274,12 @@ pub fn mark_for_method_call(cx: &Context, e_id: node_id, callee_id: node_id) {\n                   opt_static_did = Some(did);\n               }\n               typeck::method_param(typeck::method_param {\n-                  param_num: param,\n+                  param_num: typeck::param_numbered(param),\n                   _\n               }) => {\n                 cx.uses[param] |= use_tydesc;\n               }\n-              typeck::method_trait(*) | typeck::method_self(*)\n-                  | typeck::method_super(*) => (),\n+              _ => (),\n             }\n         }\n     }"}, {"sha": "e2a926875e890db5ba1c81b75721ef5fb190455b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 31, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -317,6 +317,9 @@ struct ctxt_ {\n     // some point. Local variable definitions not in this set can be warned\n     // about.\n     used_mut_nodes: @mut HashSet<ast::node_id>,\n+\n+    // vtable resolution information for impl declarations\n+    impl_vtables: typeck::impl_vtable_map\n }\n \n pub enum tbox_flag {\n@@ -911,6 +914,7 @@ pub fn mk_ctxt(s: session::Session,\n         impls:  @mut HashMap::new(),\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n+        impl_vtables: @mut HashMap::new(),\n      }\n }\n \n@@ -3061,9 +3065,7 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n               method_num: n_mth, _}) |\n-          typeck::method_trait(trt_id, n_mth, _) |\n-          typeck::method_self(trt_id, n_mth) |\n-          typeck::method_super(trt_id, n_mth) => {\n+          typeck::method_trait(trt_id, n_mth, _) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -3956,6 +3958,14 @@ pub fn lookup_item_type(cx: ctxt,\n         || csearch::get_type(cx, did))\n }\n \n+pub fn lookup_impl_vtables(cx: ctxt,\n+                           did: ast::def_id)\n+                     -> typeck::impl_res {\n+    lookup_locally_or_in_crate_store(\n+        \"impl_vtables\", did, cx.impl_vtables,\n+        || csearch::get_impl_vtables(cx, did) )\n+}\n+\n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def(cx: ctxt, did: ast::def_id) -> @ty::TraitDef {\n     match cx.trait_defs.find(&did) {\n@@ -4339,9 +4349,9 @@ pub fn determine_inherited_purity(parent: (ast::purity, ast::node_id),\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n-                                        bounds: &ParamBounds,\n+                                        bounds: &[@TraitRef],\n                                         f: &fn(@TraitRef) -> bool) -> bool {\n-    for bounds.trait_bounds.iter().advance |&bound_trait_ref| {\n+    for bounds.iter().advance |&bound_trait_ref| {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = ~[];\n         let mut i = 0;\n@@ -4383,38 +4393,14 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n                                     type_param_defs: &[TypeParameterDef]) -> uint {\n     let mut total = 0;\n     for type_param_defs.iter().advance |type_param_def| {\n-        for each_bound_trait_and_supertraits(tcx, type_param_def.bounds) |_| {\n+        for each_bound_trait_and_supertraits(\n+            tcx, type_param_def.bounds.trait_bounds) |_| {\n             total += 1;\n         }\n     }\n     return total;\n }\n \n-// Given a trait and a type, returns the impl of that type.\n-// This is broken, of course, by parametric impls. This used to use\n-// a table specifically for this mapping, but I removed that table.\n-// This is only used when calling a supertrait method from a default method,\n-// and should go away once I fix how that works. -sully\n-pub fn bogus_get_impl_id_from_ty(tcx: ctxt,\n-                                 trait_id: def_id, self_ty: t) -> def_id {\n-    match tcx.trait_impls.find(&trait_id) {\n-        Some(ty_to_impl) => {\n-            for ty_to_impl.iter().advance |imp| {\n-                let impl_ty = tcx.tcache.get_copy(&imp.did);\n-                if impl_ty.ty == self_ty { return imp.did; }\n-            }\n-            // try autoderef!\n-            match deref(tcx, self_ty, false) {\n-                Some(some_ty) =>\n-                  bogus_get_impl_id_from_ty(tcx, trait_id, some_ty.ty),\n-                None => tcx.sess.bug(\"get_impl_id: no impl of trait for \\\n-                                      this type\")\n-            }\n-        },\n-        None => tcx.sess.bug(\"get_impl_id: trait isn't in trait_impls\")\n-    }\n-}\n-\n pub fn get_tydesc_ty(tcx: ctxt) -> Result<t, ~str> {\n     do tcx.lang_items.require(TyDescStructLangItem).map |tydesc_lang_item| {\n         tcx.intrinsic_defs.find_copy(tydesc_lang_item)"}, {"sha": "fd2ef337261d1c3c51eadf19a0d76109aa75849d", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 80, "deletions": 121, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -90,7 +90,8 @@ use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n use middle::typeck::{method_map_entry, method_origin, method_param};\n-use middle::typeck::{method_self, method_static, method_trait, method_super};\n+use middle::typeck::{method_static, method_trait};\n+use middle::typeck::{param_numbered, param_self, param_index};\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use util::common::indenter;\n \n@@ -328,64 +329,6 @@ impl<'self> LookupContext<'self> {\n         }\n     }\n \n-    pub fn push_inherent_candidates_from_param(&self,\n-                                               rcvr_ty: ty::t,\n-                                               param_ty: param_ty) {\n-        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n-               param_ty);\n-        let _indenter = indenter();\n-\n-        let tcx = self.tcx();\n-        let mut next_bound_idx = 0; // count only trait bounds\n-        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n-            Some(t) => t,\n-            None => {\n-                tcx.sess.span_bug(\n-                    self.expr.span,\n-                    fmt!(\"No param def for %?\", param_ty));\n-            }\n-        };\n-\n-        for ty::each_bound_trait_and_supertraits(tcx, type_param_def.bounds)\n-            |bound_trait_ref|\n-        {\n-            let this_bound_idx = next_bound_idx;\n-            next_bound_idx += 1;\n-\n-            let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n-            let pos = {\n-                match trait_methods.iter().position(|m| {\n-                    m.explicit_self != ast::sty_static &&\n-                        m.ident == self.m_name })\n-                {\n-                    Some(pos) => pos,\n-                    None => {\n-                        debug!(\"trait doesn't contain method: %?\",\n-                               bound_trait_ref.def_id);\n-                        loop; // check next trait or bound\n-                    }\n-                }\n-            };\n-            let method = trait_methods[pos];\n-\n-            let cand = Candidate {\n-                rcvr_ty: rcvr_ty,\n-                rcvr_substs: bound_trait_ref.substs.clone(),\n-                method_ty: method,\n-                origin: method_param(\n-                    method_param {\n-                        trait_id: bound_trait_ref.def_id,\n-                        method_num: pos,\n-                        param_num: param_ty.idx,\n-                        bound_num: this_bound_idx,\n-                    })\n-            };\n-\n-            debug!(\"pushing inherent candidate for param: %?\", cand);\n-            self.inherent_candidates.push(cand);\n-        }\n-    }\n-\n     pub fn push_inherent_candidates_from_trait(&self,\n                                                self_ty: ty::t,\n                                                did: def_id,\n@@ -438,69 +381,87 @@ impl<'self> LookupContext<'self> {\n         });\n     }\n \n+    pub fn push_inherent_candidates_from_param(&self,\n+                                               rcvr_ty: ty::t,\n+                                               param_ty: param_ty) {\n+        debug!(\"push_inherent_candidates_from_param(param_ty=%?)\",\n+               param_ty);\n+        let _indenter = indenter();\n+\n+        let tcx = self.tcx();\n+        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n+            Some(t) => t,\n+            None => {\n+                tcx.sess.span_bug(\n+                    self.expr.span,\n+                    fmt!(\"No param def for %?\", param_ty));\n+            }\n+        };\n+\n+        self.push_inherent_candidates_from_bounds(\n+            rcvr_ty, type_param_def.bounds.trait_bounds,\n+            param_numbered(param_ty.idx));\n+    }\n+\n+\n     pub fn push_inherent_candidates_from_self(&self,\n                                               self_ty: ty::t,\n                                               did: def_id) {\n-        struct MethodInfo {\n-            method_ty: @ty::Method,\n-            trait_def_id: ast::def_id,\n-            index: uint,\n-            trait_ref: @ty::TraitRef\n-        }\n+        let tcx = self.tcx();\n+\n+        let trait_ref = ty::lookup_trait_def(tcx, did).trait_ref;\n+        self.push_inherent_candidates_from_bounds(\n+            self_ty, &[trait_ref], param_self);\n+    }\n \n+    pub fn push_inherent_candidates_from_bounds(&self,\n+                                                self_ty: ty::t,\n+                                                bounds: &[@TraitRef],\n+                                                param: param_index) {\n         let tcx = self.tcx();\n-        // First, try self methods\n-        let mut method_info: Option<MethodInfo> = None;\n-        let methods = ty::trait_methods(tcx, did);\n-        match methods.iter().position(|m| m.ident == self.m_name) {\n-            Some(i) => {\n-                method_info = Some(MethodInfo {\n-                    method_ty: methods[i],\n-                    index: i,\n-                    trait_def_id: did,\n-                    trait_ref: ty::lookup_trait_def(tcx, did).trait_ref\n-                });\n-            }\n-            None => ()\n-        }\n-        // No method found yet? Check each supertrait\n-        if method_info.is_none() {\n-            for ty::trait_supertraits(tcx, did).iter().advance |trait_ref| {\n-                let supertrait_methods =\n-                    ty::trait_methods(tcx, trait_ref.def_id);\n-                match supertrait_methods.iter().position(|m| m.ident == self.m_name) {\n-                    Some(i) => {\n-                        method_info = Some(MethodInfo {\n-                            method_ty: supertrait_methods[i],\n-                            index: i,\n-                            trait_def_id: trait_ref.def_id,\n-                            trait_ref: *trait_ref\n-                        });\n-                        break;\n+        let mut next_bound_idx = 0; // count only trait bounds\n+\n+        for ty::each_bound_trait_and_supertraits(tcx, bounds)\n+            |bound_trait_ref|\n+        {\n+            let this_bound_idx = next_bound_idx;\n+            next_bound_idx += 1;\n+\n+            let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n+            let pos = {\n+                match trait_methods.iter().position(|m| {\n+                    m.explicit_self != ast::sty_static &&\n+                        m.ident == self.m_name })\n+                {\n+                    Some(pos) => pos,\n+                    None => {\n+                        debug!(\"trait doesn't contain method: %?\",\n+                               bound_trait_ref.def_id);\n+                        loop; // check next trait or bound\n                     }\n-                    None => ()\n                 }\n-            }\n-        }\n-        match method_info {\n-            Some(ref info) => {\n-                // We've found a method -- return it\n-                let origin = if did == info.trait_def_id {\n-                    method_self(info.trait_def_id, info.index)\n-                } else {\n-                    method_super(info.trait_def_id, info.index)\n-                };\n-                self.inherent_candidates.push(Candidate {\n-                    rcvr_ty: self_ty,\n-                    rcvr_substs: info.trait_ref.substs.clone(),\n-                    method_ty: info.method_ty,\n-                    origin: origin\n-                });\n-            }\n-            _ => return\n+            };\n+            let method = trait_methods[pos];\n+\n+            let cand = Candidate {\n+                rcvr_ty: self_ty,\n+                rcvr_substs: bound_trait_ref.substs.clone(),\n+                method_ty: method,\n+                origin: method_param(\n+                    method_param {\n+                        trait_id: bound_trait_ref.def_id,\n+                        method_num: pos,\n+                        param_num: param,\n+                        bound_num: this_bound_idx,\n+                    })\n+            };\n+\n+            debug!(\"pushing inherent candidate for param: %?\", cand);\n+            self.inherent_candidates.push(cand);\n         }\n     }\n \n+\n     pub fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for opt_impl_infos.iter().advance |impl_infos| {\n@@ -1005,14 +966,13 @@ impl<'self> LookupContext<'self> {\n         /*!\n          *\n          * There are some limitations to calling functions through a\n-         * traint instance, because (a) the self type is not known\n+         * trait instance, because (a) the self type is not known\n          * (that's the whole point of a trait instance, after all, to\n          * obscure the self type) and (b) the call must go through a\n          * vtable and hence cannot be monomorphized. */\n \n         match candidate.origin {\n-            method_static(*) | method_param(*) |\n-                method_self(*) | method_super(*) => {\n+            method_static(*) | method_param(*) => {\n                 return; // not a call to a trait instance\n             }\n             method_trait(*) => {}\n@@ -1036,10 +996,11 @@ impl<'self> LookupContext<'self> {\n         // No code can call the finalize method explicitly.\n         let bad;\n         match candidate.origin {\n-            method_static(method_id) | method_self(method_id, _)\n-                | method_super(method_id, _) => {\n+            method_static(method_id) => {\n                 bad = self.tcx().destructors.contains(&method_id);\n             }\n+            // XXX: does this properly enforce this on everything now\n+            // that self has been merged in? -sully\n             method_param(method_param { trait_id: trait_id, _ }) |\n             method_trait(trait_id, _, _) => {\n                 bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n@@ -1158,8 +1119,7 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 type_of_trait_method(self.tcx(), mp.trait_id, mp.method_num)\n             }\n-            method_trait(did, idx, _) | method_self(did, idx) |\n-                method_super(did, idx) => {\n+            method_trait(did, idx, _) => {\n                 type_of_trait_method(self.tcx(), did, idx)\n             }\n         };\n@@ -1180,8 +1140,7 @@ impl<'self> LookupContext<'self> {\n             method_param(ref mp) => {\n                 self.report_param_candidate(idx, (*mp).trait_id)\n             }\n-            method_trait(trait_did, _, _) | method_self(trait_did, _)\n-                | method_super(trait_did, _) => {\n+            method_trait(trait_did, _, _) => {\n                 self.report_trait_candidate(idx, trait_did)\n             }\n         }"}, {"sha": "50f7f18b0a6d603c9c66652737385a546c662576", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 330, "deletions": 256, "changes": 586, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -16,11 +16,11 @@ use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::fixup_err_to_str;\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n-use middle::typeck::{CrateCtxt, vtable_origin, vtable_res};\n-use middle::typeck::{vtable_static, vtable_param, vtable_self};\n+use middle::typeck::{CrateCtxt, vtable_origin, vtable_res, vtable_param_res};\n+use middle::typeck::{vtable_static, vtable_param, impl_res};\n+use middle::typeck::{param_numbered, param_self, param_index};\n use middle::subst::Subst;\n use util::common::indenter;\n-use util::ppaux::tys_to_str;\n use util::ppaux;\n \n use std::hashmap::HashSet;\n@@ -46,6 +46,16 @@ use syntax::visit;\n // *fully* resolved. (We could be less restrictive than that, but it\n // would require much more care, and this seems to work decently in\n // practice.)\n+//\n+// While resolution on a single type requires the type to be fully\n+// resolved, when resolving a substitution against a list of bounds,\n+// we do not require all of the types to be resolved in advance.\n+// Furthermore, we process substitutions in reverse order, which\n+// allows resolution on later parameters to give information on\n+// earlier params referenced by the typeclass bounds.\n+// It may be better to do something more clever, like processing fully\n+// resolved types first.\n+\n \n /// Location info records the span and ID of the expression or item that is\n /// responsible for this vtable instantiation. (This may not be an expression\n@@ -84,42 +94,19 @@ fn lookup_vtables(vcx: &VtableContext,\n            substs.repr(vcx.tcx()));\n     let _i = indenter();\n \n-    let tcx = vcx.tcx();\n-    let mut result = ~[];\n-    let mut i = 0u;\n-    for substs.tps.iter().advance |ty| {\n-        // ty is the value supplied for the type parameter A...\n-        let mut param_result = ~[];\n-\n-        for ty::each_bound_trait_and_supertraits(\n-            tcx, type_param_defs[i].bounds) |trait_ref|\n-        {\n-            // ...and here trait_ref is each bound that was declared on A,\n-            // expressed in terms of the type parameters.\n-\n-            debug!(\"about to subst: %s, %s\", trait_ref.repr(tcx), substs.repr(tcx));\n-\n-            // Substitute the values of the type parameters that may\n-            // appear in the bound.\n-            let trait_ref = trait_ref.subst(tcx, substs);\n-\n-            debug!(\"after subst: %s\", trait_ref.repr(tcx));\n-\n-            match lookup_vtable(vcx, location_info, *ty, trait_ref, is_early) {\n-                Some(vtable) => param_result.push(vtable),\n-                None => {\n-                    vcx.tcx().sess.span_fatal(\n-                        location_info.span,\n-                        fmt!(\"failed to find an implementation of \\\n-                              trait %s for %s\",\n-                             vcx.infcx.trait_ref_to_str(trait_ref),\n-                             vcx.infcx.ty_to_str(*ty)));\n-                }\n-            }\n-        }\n-        result.push(@param_result);\n-        i += 1u;\n-    }\n+\n+    // We do this backwards for reasons discussed above.\n+    assert_eq!(substs.tps.len(), type_param_defs.len());\n+    let mut result =\n+        substs.tps.rev_iter()\n+        .zip(type_param_defs.rev_iter())\n+        .transform(|(ty, def)|\n+                   lookup_vtables_for_param(vcx, location_info, Some(substs),\n+                                            &*def.bounds, *ty, is_early))\n+        .to_owned_vec();\n+    result.reverse();\n+\n+    assert_eq!(substs.tps.len(), result.len());\n     debug!(\"lookup_vtables result(\\\n             location_info=%?, \\\n             type_param_defs=%s, \\\n@@ -132,25 +119,58 @@ fn lookup_vtables(vcx: &VtableContext,\n     @result\n }\n \n-fn fixup_substs(vcx: &VtableContext,\n-                location_info: &LocationInfo,\n-                id: ast::def_id,\n-                substs: ty::substs,\n-                is_early: bool)\n-                -> Option<ty::substs> {\n+fn lookup_vtables_for_param(vcx: &VtableContext,\n+                            location_info: &LocationInfo,\n+                            // None for substs means the identity\n+                            substs: Option<&ty::substs>,\n+                            type_param_bounds: &ty::ParamBounds,\n+                            ty: ty::t,\n+                            is_early: bool) -> vtable_param_res {\n     let tcx = vcx.tcx();\n-    // use a dummy type just to package up the substs that need fixing up\n-    let t = ty::mk_trait(tcx,\n-                         id, substs,\n-                         ty::RegionTraitStore(ty::re_static),\n-                         ast::m_imm,\n-                         ty::EmptyBuiltinBounds());\n-    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n-        match ty::get(*t_f).sty {\n-          ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n-          _ => fail!(\"t_f should be a trait\")\n+\n+    // ty is the value supplied for the type parameter A...\n+    let mut param_result = ~[];\n+\n+    for ty::each_bound_trait_and_supertraits(\n+        tcx, type_param_bounds.trait_bounds) |trait_ref|\n+    {\n+        // ...and here trait_ref is each bound that was declared on A,\n+        // expressed in terms of the type parameters.\n+\n+        // Substitute the values of the type parameters that may\n+        // appear in the bound.\n+        let trait_ref = substs.map_default(trait_ref, |substs| {\n+            debug!(\"about to subst: %s, %s\",\n+                   trait_ref.repr(tcx), substs.repr(tcx));\n+            trait_ref.subst(tcx, *substs)\n+        });\n+\n+        debug!(\"after subst: %s\", trait_ref.repr(tcx));\n+\n+        match lookup_vtable(vcx, location_info, ty, trait_ref, is_early) {\n+            Some(vtable) => param_result.push(vtable),\n+            None => {\n+                vcx.tcx().sess.span_fatal(\n+                    location_info.span,\n+                    fmt!(\"failed to find an implementation of \\\n+                          trait %s for %s\",\n+                         vcx.infcx.trait_ref_to_str(trait_ref),\n+                         vcx.infcx.ty_to_str(ty)));\n+            }\n         }\n     }\n+\n+    debug!(\"lookup_vtables_for_param result(\\\n+            location_info=%?, \\\n+            type_param_bounds=%s, \\\n+            ty=%s, \\\n+            result=%s)\",\n+           location_info,\n+           type_param_bounds.repr(vcx.tcx()),\n+           ty.repr(vcx.tcx()),\n+           param_result.repr(vcx.tcx()));\n+\n+    return @param_result;\n }\n \n fn relate_trait_refs(vcx: &VtableContext,\n@@ -173,10 +193,15 @@ fn relate_trait_refs(vcx: &VtableContext,\n     {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n+            // There is an error, but we need to do some work to make\n+            // the message good.\n+            // Resolve any type vars in the trait refs\n             let r_act_trait_ref =\n                 vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(act_trait_ref);\n             let r_exp_trait_ref =\n                 vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(exp_trait_ref);\n+            // Only print the message if there aren't any previous type errors\n+            // inside the types.\n             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n                 !ty::trait_ref_contains_error(&r_exp_trait_ref)\n             {\n@@ -192,8 +217,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n     }\n }\n \n-// Look up the vtable to use when treating an item of type `t` as if it has\n-// type `trait_ty`\n+// Look up the vtable implementing the trait `trait_ref` at type `t`\n fn lookup_vtable(vcx: &VtableContext,\n                  location_info: &LocationInfo,\n                  ty: ty::t,\n@@ -216,220 +240,247 @@ fn lookup_vtable(vcx: &VtableContext,\n             // The type has unconstrained type variables in it, so we can't\n             // do early resolution on it. Return some completely bogus vtable\n             // information: we aren't storing it anyways.\n-            return Some(vtable_param(0, 0));\n+            return Some(vtable_param(param_self, 0));\n         }\n     };\n \n-    match ty::get(ty).sty {\n+    // If the type is self or a param, we look at the trait/supertrait\n+    // bounds to see if they include the trait we are looking for.\n+    let vtable_opt = match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, def_id: did}) => {\n-            let mut n_bound = 0;\n             let type_param_def = tcx.ty_param_defs.get(&did.node);\n-            for ty::each_bound_trait_and_supertraits(\n-                tcx, type_param_def.bounds) |bound_trait_ref|\n-            {\n-                debug!(\"checking bounds trait %s\", bound_trait_ref.repr(vcx.tcx()));\n-\n-                if bound_trait_ref.def_id == trait_ref.def_id {\n-                    relate_trait_refs(vcx,\n-                                      location_info,\n-                                      bound_trait_ref,\n-                                      trait_ref);\n-                    let vtable = vtable_param(n, n_bound);\n-                    debug!(\"found param vtable: %?\",\n-                           vtable);\n-                    return Some(vtable);\n-                }\n-\n-                n_bound += 1;\n-            }\n+            lookup_vtable_from_bounds(vcx, location_info,\n+                                      type_param_def.bounds.trait_bounds,\n+                                      param_numbered(n),\n+                                      trait_ref)\n         }\n \n         ty::ty_self(trait_id) => {\n-            debug!(\"trying to find %? vtable for type %?\",\n-                   trait_ref.def_id, trait_id);\n+            let self_trait_ref = ty::lookup_trait_def(tcx, trait_id).trait_ref;\n+            lookup_vtable_from_bounds(vcx, location_info,\n+                                      &[self_trait_ref],\n+                                      param_self,\n+                                      trait_ref)\n+        }\n \n-            if trait_id == trait_ref.def_id {\n-                let vtable = vtable_self(trait_id);\n-                debug!(\"found self vtable: %?\", vtable);\n-                return Some(vtable);\n-            }\n+        // Default case just falls through\n+        _ => None\n+    };\n+\n+    if vtable_opt.is_some() { return vtable_opt; }\n+\n+    // If we aren't a self type or param, or it was, but we didn't find it,\n+    // do a search.\n+    return search_for_vtable(vcx, location_info,\n+                             ty, trait_ref, is_early)\n+}\n+\n+// Given a list of bounds on a type, search those bounds to see if any\n+// of them are the vtable we are looking for.\n+fn lookup_vtable_from_bounds(vcx: &VtableContext,\n+                             location_info: &LocationInfo,\n+                             bounds: &[@ty::TraitRef],\n+                             param: param_index,\n+                             trait_ref: @ty::TraitRef)\n+    -> Option<vtable_origin> {\n+    let tcx = vcx.tcx();\n+\n+    let mut n_bound = 0;\n+    for ty::each_bound_trait_and_supertraits(tcx, bounds) |bound_trait_ref| {\n+        debug!(\"checking bounds trait %s\",\n+               bound_trait_ref.repr(vcx.tcx()));\n+\n+        if bound_trait_ref.def_id == trait_ref.def_id {\n+            relate_trait_refs(vcx,\n+                              location_info,\n+                              bound_trait_ref,\n+                              trait_ref);\n+            let vtable = vtable_param(param, n_bound);\n+            debug!(\"found param vtable: %?\",\n+                   vtable);\n+            return Some(vtable);\n         }\n \n-        _ => {\n-            let mut found = ~[];\n+        n_bound += 1;\n+    }\n \n-            let mut impls_seen = HashSet::new();\n+    return None;\n+}\n \n-            match tcx.trait_impls.find(&trait_ref.def_id) {\n-                None => {\n-                    // Nothing found. Continue.\n-                }\n-                Some(implementations) => {\n-                    // implementations is the list of all impls in scope for\n-                    // trait_ref. (Usually, there's just one.)\n-                    for implementations.iter().advance |im| {\n-                        // im is one specific impl of trait_ref.\n-\n-                        // First, ensure we haven't processed this impl yet.\n-                        if impls_seen.contains(&im.did) {\n-                            loop;\n-                        }\n-                        impls_seen.insert(im.did);\n-\n-                        // ty::impl_traits gives us the trait im implements,\n-                        // if there is one (there's either zero or one).\n-                        //\n-                        // If foo implements a trait t, and if t is the\n-                        // same trait as trait_ref, we need to\n-                        // unify it with trait_ref in order to get all\n-                        // the ty vars sorted out.\n-                        let r = ty::impl_trait_ref(tcx, im.did);\n-                        for r.iter().advance |&of_trait_ref| {\n-                            if of_trait_ref.def_id != trait_ref.def_id { loop; }\n-\n-                            // At this point, we know that of_trait_ref is\n-                            // the same trait as trait_ref, but\n-                            // possibly applied to different substs.\n-                            //\n-                            // Next, we check whether the \"for\" ty in\n-                            // the impl is compatible with the type\n-                            // that we're casting to a trait. That is,\n-                            // if im is:\n-                            //\n-                            // impl<T> self_ty<T>: some_trait<T> { ... }\n-                            //\n-                            // we check whether self_ty<T> is the type\n-                            // of the thing that we're trying to cast\n-                            // to some_trait.  If not, then we try the next\n-                            // impl.\n-                            //\n-                            // FIXME(#5781) this should be mk_eqty not mk_subty\n-                            let ty::ty_param_substs_and_ty {\n-                                substs: substs,\n-                                ty: for_ty\n-                            } = impl_self_ty(vcx, location_info, im.did);\n-                            match infer::mk_subty(vcx.infcx,\n-                                                  false,\n-                                                  infer::RelateSelfType(\n-                                                      location_info.span),\n-                                                  ty,\n-                                                  for_ty) {\n-                                result::Err(_) => loop,\n-                                result::Ok(()) => ()\n-                            }\n-\n-                            // Now, in the previous example, for_ty is\n-                            // bound to the type self_ty, and substs\n-                            // is bound to [T].\n-                            debug!(\"The self ty is %s and its substs are %s\",\n-                                   vcx.infcx.ty_to_str(for_ty),\n-                                   tys_to_str(vcx.tcx(), substs.tps));\n-\n-                            // Next, we unify trait_ref -- the type\n-                            // that we want to cast to -- with of_trait_ref\n-                            // -- the trait that im implements. At\n-                            // this point, we require that they be\n-                            // unifiable with each other -- that's\n-                            // what relate_trait_refs does.\n-                            //\n-                            // For example, in the above example,\n-                            // of_trait_ref would be some_trait<T>, so we\n-                            // would be unifying trait_ref<U> (for some\n-                            // value of U) with some_trait<T>. This\n-                            // would fail if T and U weren't\n-                            // compatible.\n-\n-                            debug!(\"(checking vtable) @2 relating trait \\\n-                                    ty %s to of_trait_ref %s\",\n-                                   vcx.infcx.trait_ref_to_str(trait_ref),\n-                                   vcx.infcx.trait_ref_to_str(of_trait_ref));\n-\n-                            let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-                            relate_trait_refs(\n-                                vcx, location_info,\n-                                of_trait_ref, trait_ref);\n-\n-                            // Recall that trait_ref -- the trait type\n-                            // we're casting to -- is the trait with\n-                            // id trait_ref.def_id applied to the substs\n-                            // trait_ref.substs. Now we extract out the\n-                            // types themselves from trait_ref.substs.\n-\n-                            // Recall that substs is the impl self\n-                            // type's list of substitutions. That is,\n-                            // if this is an impl of some trait for\n-                            // foo<T, U>, then substs is [T,\n-                            // U]. substs might contain type\n-                            // variables, so we call fixup_substs to\n-                            // resolve them.\n-\n-                            let substs_f = match fixup_substs(vcx,\n-                                                              location_info,\n-                                                              trait_ref.def_id,\n-                                                              substs,\n-                                                              is_early) {\n-                                Some(ref substs) => (*substs).clone(),\n-                                None => {\n-                                    assert!(is_early);\n-                                    // Bail out with a bogus answer\n-                                    return Some(vtable_param(0, 0));\n-                                }\n-                            };\n-\n-                            debug!(\"The fixed-up substs are %s - \\\n-                                    they will be unified with the bounds for \\\n-                                    the target ty, %s\",\n-                                   tys_to_str(vcx.tcx(), substs_f.tps),\n-                                   vcx.infcx.trait_ref_to_str(trait_ref));\n-\n-                            // Next, we unify the fixed-up\n-                            // substitutions for the impl self ty with\n-                            // the substitutions from the trait type\n-                            // that we're trying to cast\n-                            // to. connect_trait_tps requires these\n-                            // lists of types to unify pairwise.\n-\n-                            let im_generics =\n-                                ty::lookup_item_type(tcx, im.did).generics;\n-                            connect_trait_tps(vcx,\n-                                              location_info,\n-                                              &substs_f,\n-                                              trait_ref,\n-                                              im.did);\n-                            let subres = lookup_vtables(\n-                                vcx, location_info,\n-                                *im_generics.type_param_defs, &substs_f,\n-                                is_early);\n-\n-                            // Finally, we register that we found a\n-                            // matching impl, and record the def ID of\n-                            // the impl as well as the resolved list\n-                            // of type substitutions for the target\n-                            // trait.\n-                            found.push(vtable_static(im.did,\n-                                                     substs_f.tps.clone(),\n-                                                     subres));\n-                        }\n-                    }\n-                }\n+fn search_for_vtable(vcx: &VtableContext,\n+                     location_info: &LocationInfo,\n+                     ty: ty::t,\n+                     trait_ref: @ty::TraitRef,\n+                     is_early: bool)\n+    -> Option<vtable_origin>\n+{\n+    let tcx = vcx.tcx();\n+\n+    let mut found = ~[];\n+    let mut impls_seen = HashSet::new();\n+\n+    // XXX: this is a bad way to do this, since we do\n+    // pointless allocations.\n+    let impls = tcx.trait_impls.find(&trait_ref.def_id)\n+        .map_default(@mut ~[], |x| **x);\n+    // impls is the list of all impls in scope for trait_ref.\n+    for impls.iter().advance |im| {\n+        // im is one specific impl of trait_ref.\n+\n+        // First, ensure we haven't processed this impl yet.\n+        if impls_seen.contains(&im.did) {\n+            loop;\n+        }\n+        impls_seen.insert(im.did);\n+\n+        // ty::impl_traits gives us the trait im implements.\n+        //\n+        // If foo implements a trait t, and if t is the same trait as\n+        // trait_ref, we need to unify it with trait_ref in order to\n+        // get all the ty vars sorted out.\n+        let r = ty::impl_trait_ref(tcx, im.did);\n+        let of_trait_ref = r.expect(\"trait_ref missing on trait impl\");\n+        if of_trait_ref.def_id != trait_ref.def_id { loop; }\n+\n+        // At this point, we know that of_trait_ref is the same trait\n+        // as trait_ref, but possibly applied to different substs.\n+        //\n+        // Next, we check whether the \"for\" ty in the impl is\n+        // compatible with the type that we're casting to a\n+        // trait. That is, if im is:\n+        //\n+        // impl<T> some_trait<T> for self_ty<T> { ... }\n+        //\n+        // we check whether self_ty<T> is the type of the thing that\n+        // we're trying to cast to some_trait.  If not, then we try\n+        // the next impl.\n+        //\n+        // XXX: document a bit more what this means\n+        //\n+        // FIXME(#5781) this should be mk_eqty not mk_subty\n+        let ty::ty_param_substs_and_ty {\n+            substs: substs,\n+            ty: for_ty\n+        } = impl_self_ty(vcx, location_info, im.did);\n+        match infer::mk_subty(vcx.infcx,\n+                              false,\n+                              infer::RelateSelfType(\n+                                  location_info.span),\n+                              ty,\n+                              for_ty) {\n+            result::Err(_) => loop,\n+            result::Ok(()) => ()\n+        }\n+\n+        // Now, in the previous example, for_ty is bound to\n+        // the type self_ty, and substs is bound to [T].\n+        debug!(\"The self ty is %s and its substs are %s\",\n+               vcx.infcx.ty_to_str(for_ty),\n+               vcx.infcx.tys_to_str(substs.tps));\n+\n+        // Next, we unify trait_ref -- the type that we want to cast\n+        // to -- with of_trait_ref -- the trait that im implements. At\n+        // this point, we require that they be unifiable with each\n+        // other -- that's what relate_trait_refs does.\n+        //\n+        // For example, in the above example, of_trait_ref would be\n+        // some_trait<T>, so we would be unifying trait_ref<U> (for\n+        // some value of U) with some_trait<T>. This would fail if T\n+        // and U weren't compatible.\n+\n+        debug!(\"(checking vtable) @2 relating trait \\\n+                ty %s to of_trait_ref %s\",\n+               vcx.infcx.trait_ref_to_str(trait_ref),\n+               vcx.infcx.trait_ref_to_str(of_trait_ref));\n+\n+        let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n+        relate_trait_refs(vcx, location_info, of_trait_ref, trait_ref);\n+\n+\n+        // Recall that trait_ref -- the trait type we're casting to --\n+        // is the trait with id trait_ref.def_id applied to the substs\n+        // trait_ref.substs.\n+\n+        // Resolve any sub bounds. Note that there still may be free\n+        // type variables in substs. This might still be OK: the\n+        // process of looking up bounds might constrain some of them.\n+        let im_generics =\n+            ty::lookup_item_type(tcx, im.did).generics;\n+        let subres = lookup_vtables(vcx, location_info,\n+                                    *im_generics.type_param_defs, &substs,\n+                                    is_early);\n+\n+\n+        // substs might contain type variables, so we call\n+        // fixup_substs to resolve them.\n+        let substs_f = match fixup_substs(vcx,\n+                                          location_info,\n+                                          trait_ref.def_id,\n+                                          substs,\n+                                          is_early) {\n+            Some(ref substs) => (*substs).clone(),\n+            None => {\n+                assert!(is_early);\n+                // Bail out with a bogus answer\n+                return Some(vtable_param(param_self, 0));\n             }\n+        };\n+\n+        debug!(\"The fixed-up substs are %s - \\\n+                they will be unified with the bounds for \\\n+                the target ty, %s\",\n+               vcx.infcx.tys_to_str(substs_f.tps),\n+               vcx.infcx.trait_ref_to_str(trait_ref));\n+\n+        // Next, we unify the fixed-up substitutions for the impl self\n+        // ty with the substitutions from the trait type that we're\n+        // trying to cast to. connect_trait_tps requires these lists\n+        // of types to unify pairwise.\n+        // I am a little confused about this, since it seems to be\n+        // very similar to the relate_trait_refs we already do,\n+        // but problems crop up if it is removed, so... -sully\n+        connect_trait_tps(vcx, location_info, &substs_f, trait_ref, im.did);\n+\n+        // Finally, we register that we found a matching impl, and\n+        // record the def ID of the impl as well as the resolved list\n+        // of type substitutions for the target trait.\n+        found.push(vtable_static(im.did, substs_f.tps.clone(), subres));\n+    }\n \n-            match found.len() {\n-                0 => { /* fallthrough */ }\n-                1 => return Some(found[0].clone()),\n-                _ => {\n-                    if !is_early {\n-                        vcx.tcx().sess.span_err(\n-                            location_info.span,\n-                            \"multiple applicable methods in scope\");\n-                    }\n-                    return Some(found[0].clone());\n-                }\n+    match found.len() {\n+        0 => { return None }\n+        1 => return Some(found[0].clone()),\n+        _ => {\n+            if !is_early {\n+                vcx.tcx().sess.span_err(\n+                    location_info.span,\n+                    \"multiple applicable methods in scope\");\n             }\n+            return Some(found[0].clone());\n         }\n     }\n+}\n \n-    return None;\n+\n+fn fixup_substs(vcx: &VtableContext,\n+                location_info: &LocationInfo,\n+                id: ast::def_id,\n+                substs: ty::substs,\n+                is_early: bool)\n+                -> Option<ty::substs> {\n+    let tcx = vcx.tcx();\n+    // use a dummy type just to package up the substs that need fixing up\n+    let t = ty::mk_trait(tcx,\n+                         id, substs,\n+                         ty::RegionTraitStore(ty::re_static),\n+                         ast::m_imm,\n+                         ty::EmptyBuiltinBounds());\n+    do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n+        match ty::get(*t_f).sty {\n+          ty::ty_trait(_, ref substs_f, _, _, _) => (*substs_f).clone(),\n+          _ => fail!(\"t_f should be a trait\")\n+        }\n+    }\n }\n \n fn fixup_ty(vcx: &VtableContext,\n@@ -682,16 +733,39 @@ pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n         Some(trait_ref) => {\n             let infcx = infer::new_infer_ctxt(ccx.tcx);\n             let vcx = VtableContext { ccx: ccx, infcx: infcx };\n-            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n+            let loc_info = location_info_for_item(impl_item);\n \n+            // First, check that the impl implements any trait bounds\n+            // on the trait.\n+            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n             let vtbls = lookup_vtables(&vcx,\n-                                       &location_info_for_item(impl_item),\n+                                       &loc_info,\n                                        *trait_def.generics.type_param_defs,\n                                        &trait_ref.substs,\n                                        false);\n \n-            // FIXME(#7450): Doesn't work cross crate\n-            ccx.vtable_map.insert(impl_item.id, vtbls);\n+            // Now, locate the vtable for the impl itself. The real\n+            // purpose of this is to check for supertrait impls,\n+            // but that falls out of doing this.\n+            let param_bounds = ty::ParamBounds {\n+                builtin_bounds: ty::EmptyBuiltinBounds(),\n+                trait_bounds: ~[trait_ref]\n+            };\n+            let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n+            debug!(\"=== Doing a self lookup now.\");\n+            // Right now, we don't have any place to store this.\n+            // We will need to make one so we can use this information\n+            // for compiling default methods that refer to supertraits.\n+            let self_vtable_res =\n+                lookup_vtables_for_param(&vcx, &loc_info, None,\n+                                         &param_bounds, t, false);\n+\n+\n+            let res = impl_res {\n+                trait_vtables: vtbls,\n+                self_vtables: self_vtable_res\n+            };\n+            ccx.tcx.impl_vtables.insert(def_id, res);\n         }\n     }\n }"}, {"sha": "a7319d4b0081f9a962306638c2713268debcbae4", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -20,7 +20,7 @@ use middle::typeck::infer::{force_all, resolve_all, resolve_region};\n use middle::typeck::infer::resolve_type;\n use middle::typeck::infer;\n use middle::typeck::{vtable_res, vtable_origin};\n-use middle::typeck::{vtable_static, vtable_param, vtable_self};\n+use middle::typeck::{vtable_static, vtable_param};\n use middle::typeck::method_map_entry;\n use middle::typeck::write_substs_to_tcx;\n use middle::typeck::write_ty_to_tcx;\n@@ -109,9 +109,6 @@ fn resolve_vtable_map_entry(fcx: @mut FnCtxt, sp: span, id: ast::node_id) {\n             &vtable_param(n, b) => {\n                 vtable_param(n, b)\n             }\n-            &vtable_self(def_id) => {\n-                vtable_self(def_id)\n-            }\n         }\n     }\n }"}, {"sha": "eb32f4e59f002a1673201a9e3a36add28022329f", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -653,6 +653,11 @@ impl InferCtxt {\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n+    pub fn tys_to_str(@mut self, ts: &[ty::t]) -> ~str {\n+        let tstrs = ts.map(|t| self.ty_to_str(*t));\n+        fmt!(\"(%s)\", tstrs.connect(\", \"))\n+    }\n+\n     pub fn trait_ref_to_str(@mut self, t: &ty::TraitRef) -> ~str {\n         let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n         trait_ref_to_str(self.tcx, &t)"}, {"sha": "0ea00e15863d8f1b2ccb3bc3b854b349b4a4cba9", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -75,14 +75,14 @@ pub mod infer;\n pub mod collect;\n pub mod coherence;\n \n+#[deriving(Clone, Encodable, Decodable, Eq, Ord)]\n+pub enum param_index {\n+    param_numbered(uint),\n+    param_self\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub enum method_origin {\n-    // supertrait method invoked on \"self\" inside a default method\n-    // first field is supertrait ID;\n-    // second field is method index (relative to the *supertrait*\n-    // method list)\n-    method_super(ast::def_id, uint),\n-\n     // fully statically resolved method\n     method_static(ast::def_id),\n \n@@ -92,9 +92,6 @@ pub enum method_origin {\n     // method invoked on a trait instance\n     method_trait(ast::def_id, uint, ty::TraitStore),\n \n-    // method invoked on \"self\" inside a default method\n-    method_self(ast::def_id, uint)\n-\n }\n \n // details for a method invoked with a receiver whose type is a type parameter\n@@ -109,7 +106,7 @@ pub struct method_param {\n \n     // index of the type parameter (from those that are in scope) that is\n     // the type of the receiver\n-    param_num: uint,\n+    param_num: param_index,\n \n     // index of the bound for this type parameter which specifies the trait\n     bound_num: uint,\n@@ -153,15 +150,10 @@ pub enum vtable_origin {\n       fn foo<T:quux,baz,bar>(a: T) -- a's vtable would have a\n       vtable_param origin\n \n-      The first uint is the param number (identifying T in the example),\n+      The first argument is the param index (identifying T in the example),\n       and the second is the bound number (identifying baz)\n      */\n-    vtable_param(uint, uint),\n-\n-    /*\n-     Dynamic vtable, comes from self.\n-    */\n-    vtable_self(ast::def_id)\n+    vtable_param(param_index, uint),\n }\n \n impl Repr for vtable_origin {\n@@ -178,15 +170,34 @@ impl Repr for vtable_origin {\n             vtable_param(x, y) => {\n                 fmt!(\"vtable_param(%?, %?)\", x, y)\n             }\n-            vtable_self(def_id) => {\n-                fmt!(\"vtable_self(%?)\", def_id)\n-            }\n         }\n     }\n }\n \n pub type vtable_map = @mut HashMap<ast::node_id, vtable_res>;\n \n+\n+// Information about the vtable resolutions for for a trait impl.\n+// Mostly the information is important for implementing default\n+// methods.\n+#[deriving(Clone)]\n+pub struct impl_res {\n+    // resolutions for any bounded params on the trait definition\n+    trait_vtables: vtable_res,\n+    // resolutions for the trait /itself/ (and for supertraits)\n+    self_vtables: vtable_param_res\n+}\n+\n+impl Repr for impl_res {\n+    fn repr(&self, tcx: ty::ctxt) -> ~str {\n+        fmt!(\"impl_res {trait_vtables=%s, self_vtables=%s}\",\n+             self.trait_vtables.repr(tcx),\n+             self.self_vtables.repr(tcx))\n+    }\n+}\n+\n+pub type impl_vtable_map = @mut HashMap<ast::def_id, impl_res>;\n+\n pub struct CrateCtxt {\n     // A mapping from method call sites to traits that have that method.\n     trait_map: resolve::TraitMap,"}, {"sha": "932648d4f9b9efe313cc6527270d217812a4be60", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -715,10 +715,6 @@ impl Repr for typeck::method_map_entry {\n impl Repr for typeck::method_origin {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         match self {\n-            &typeck::method_super(def_id, n) => {\n-                fmt!(\"method_super(%s, %?)\",\n-                     def_id.repr(tcx), n)\n-            }\n             &typeck::method_static(def_id) => {\n                 fmt!(\"method_static(%s)\", def_id.repr(tcx))\n             }\n@@ -729,9 +725,6 @@ impl Repr for typeck::method_origin {\n                 fmt!(\"method_trait(%s, %?, %s)\", def_id.repr(tcx), n,\n                      st.repr(tcx))\n             }\n-            &typeck::method_self(def_id, n) => {\n-                fmt!(\"method_self(%s, %?)\", def_id.repr(tcx), n)\n-            }\n         }\n     }\n }"}, {"sha": "eee786524f579e18d12c2b9c2efa71d0da416e14", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -86,6 +86,12 @@ pub trait TotalOrd: TotalEq {\n     fn cmp(&self, other: &Self) -> Ordering;\n }\n \n+impl TotalEq for Ordering {\n+    #[inline]\n+    fn equals(&self, other: &Ordering) -> bool {\n+        *self == *other\n+    }\n+}\n impl TotalOrd for Ordering {\n     #[inline]\n     fn cmp(&self, other: &Ordering) -> Ordering {"}, {"sha": "5ea7585a3dfc4b5799a5ea325900fc851f3c168a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -96,7 +96,7 @@ impl<A, T: DoubleEndedIterator<A>> Iterator<A> for InvertIterator<A, T> {\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-impl<A, T: Iterator<A>> DoubleEndedIterator<A> for InvertIterator<A, T> {\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for InvertIterator<A, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next() }\n }\n@@ -343,6 +343,18 @@ pub trait IteratorUtil<A> {\n     /// ~~~\n     fn collect<B: FromIterator<A, Self>>(&mut self) -> B;\n \n+    /// Loops through the entire iterator, collecting all of the elements into\n+    /// a unique vector. This is simply collect() specialized for vectors.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let a = [1, 2, 3, 4, 5];\n+    /// let b: ~[int] = a.iter().transform(|&x| x).to_owned_vec();\n+    /// assert!(a == b);\n+    /// ~~~\n+    fn to_owned_vec(&mut self) -> ~[A];\n+\n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n     ///\n@@ -539,6 +551,11 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         FromIterator::from_iterator(self)\n     }\n \n+    #[inline]\n+    fn to_owned_vec(&mut self) -> ~[A] {\n+        self.collect()\n+    }\n+\n     /// Return the `n`th item yielded by an iterator.\n     #[inline]\n     fn nth(&mut self, mut n: uint) -> Option<A> {"}, {"sha": "eb10553f19c24717ccfcfafa0384c5bc9ad9f767", "filename": "src/test/auxiliary/issue_3979_traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_3979_traits.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -14,12 +14,13 @@\n #[crate_type = \"lib\"];\n \n trait Positioned {\n-  fn SetX(&self, int);\n+  fn SetX(&mut self, int);\n   fn X(&self) -> int;\n }\n \n trait Movable: Positioned {\n-  fn translate(&self, dx: int) {\n-    self.SetX(self.X() + dx);\n+  fn translate(&mut self, dx: int) {\n+    let x = self.X() + dx;\n+    self.SetX(x);\n   }\n }"}, {"sha": "90a2b914021244aef585368d528161f9a5b5f42e", "filename": "src/test/run-pass/default-method-supertrait-vtable.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fdefault-method-supertrait-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fdefault-method-supertrait-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault-method-supertrait-vtable.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// Tests that we can call a function bounded over a supertrait from\n+// a default method\n+\n+fn require_y<T: Y>(x: T) -> int { x.y() }\n+\n+trait Y {\n+    fn y(self) -> int;\n+}\n+\n+\n+trait Z: Y {\n+    fn x(self) -> int {\n+        require_y(self)\n+    }\n+}\n+\n+impl Y for int {\n+    fn y(self) -> int { self }\n+}\n+\n+impl Z for int;\n+\n+fn main() {\n+    assert_eq!(12.x(), 12);\n+}"}, {"sha": "39e9f5dcd2d8d466b0a4e83d16501d279b7033a4", "filename": "src/test/run-pass/issue-3979-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-2.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n trait A {\n     fn a_method(&self);\n }"}, {"sha": "867301121daeeb743e88dd57e2be4c8980740c5a", "filename": "src/test/run-pass/issue-3979-generics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-generics.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test FIXME #5946\n trait Positioned<S> {\n   fn SetX(&mut self, S);\n   fn X(&self) -> S;\n }\n \n-trait Movable<S, T>: Positioned<T> {\n-  fn translate(&self, dx: T) {\n-    self.SetX(self.X() + dx);\n+trait Movable<S: Add<S, S>>: Positioned<S> {\n+  fn translate(&mut self, dx: S) {\n+    let x = self.X() + dx;\n+    self.SetX(x);\n   }\n }\n \n@@ -31,10 +31,10 @@ impl Positioned<int> for Point {\n     }\n }\n \n-impl Movable<int, int> for Point;\n+impl Movable<int> for Point;\n \n pub fn main() {\n-    let p = Point{ x: 1, y: 2};\n+    let mut p = Point{ x: 1, y: 2};\n     p.translate(3);\n     assert_eq!(p.X(), 4);\n }"}, {"sha": "caf6d2023169ebe4358b6a080c5d5c32d285d87d", "filename": "src/test/run-pass/issue-3979-xcrate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979-xcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979-xcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979-xcrate.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test // tjc: ???\n+// xfail-fast\n // aux-build:issue_3979_traits.rs\n extern mod issue_3979_traits;\n use issue_3979_traits::*;"}, {"sha": "2e53fb5d3f92f399e6bda09618672a766774e1c0", "filename": "src/test/run-pass/issue-3979.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fissue-3979.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3979.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-// Reason: ICE with explicit self\n \n // Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at"}, {"sha": "ae7e18d532b7951777719e05a511ba9b9a08f650", "filename": "src/test/run-pass/supertrait-default-generics.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fsupertrait-default-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/906264b50fa6b69eed567388063233bd279242b1/src%2Ftest%2Frun-pass%2Fsupertrait-default-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupertrait-default-generics.rs?ref=906264b50fa6b69eed567388063233bd279242b1", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// There is some other borrowck bug, so we make the stuff not mut.\n+\n+trait Positioned<S> {\n+  fn SetX(&mut self, S);\n+  fn X(&self) -> S;\n+}\n+\n+trait Movable<S: Add<S, S>>: Positioned<S> {\n+  fn translate(&mut self, dx: S) {\n+    let x = self.X() + dx;\n+    self.SetX(x);\n+  }\n+}\n+\n+struct Point<S> { x: S, y: S }\n+\n+impl<S: Clone> Positioned<S> for Point<S> {\n+    fn SetX(&mut self, x: S) {\n+        self.x = x;\n+    }\n+    fn X(&self) -> S {\n+        self.x.clone()\n+    }\n+}\n+\n+impl<S: Clone + Add<S, S>> Movable<S> for Point<S>;\n+\n+pub fn main() {\n+    let mut p = Point{ x: 1, y: 2};\n+    p.translate(3);\n+    assert_eq!(p.X(), 4);\n+}"}]}