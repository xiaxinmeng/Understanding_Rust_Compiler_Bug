{"sha": "43e52e4bf144bbd2f366a4f32ac0128136273226", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZTUyZTRiZjE0NGJiZDJmMzY2YTRmMzJhYzAxMjgxMzYyNzMyMjY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-07T07:30:38Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-07T07:30:38Z"}, "message": "syntax: move functions from deriving/mod to deriving/generic.\n\nThese are now only called in generic and can be private. This\nincludes manually inlining/merging some that are called once.", "tree": {"sha": "70b418e10105397724e8e87c48918f7571fe7819", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70b418e10105397724e8e87c48918f7571fe7819"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43e52e4bf144bbd2f366a4f32ac0128136273226", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43e52e4bf144bbd2f366a4f32ac0128136273226", "html_url": "https://github.com/rust-lang/rust/commit/43e52e4bf144bbd2f366a4f32ac0128136273226", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43e52e4bf144bbd2f366a4f32ac0128136273226/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4abd83b18d5dffc8c2f3d827c333447c028998a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4abd83b18d5dffc8c2f3d827c333447c028998a0", "html_url": "https://github.com/rust-lang/rust/commit/4abd83b18d5dffc8c2f3d827c333447c028998a0"}], "stats": {"total": 476, "additions": 199, "deletions": 277}, "files": [{"sha": "e386a2cfb532b5bbe38dd7cb2a876c70cddfb812", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 198, "deletions": 23, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/43e52e4bf144bbd2f366a4f32ac0128136273226/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e52e4bf144bbd2f366a4f32ac0128136273226/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=43e52e4bf144bbd2f366a4f32ac0128136273226", "patch": "@@ -169,7 +169,6 @@ use ast::{enum_def, expr, ident, Generics, struct_def};\n \n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use ext::deriving::*;\n use codemap::{span,respan};\n use opt_vec;\n \n@@ -184,18 +183,28 @@ pub fn expand_deriving_generic(cx: @ExtCtxt,\n                                _mitem: @ast::meta_item,\n                                in_items: ~[@ast::item],\n                                trait_def: &TraitDef) -> ~[@ast::item] {\n-    let expand_enum: ExpandDerivingEnumDefFn =\n-        |cx, span, enum_def, type_ident, generics| {\n-        trait_def.expand_enum_def(cx, span, enum_def, type_ident, generics)\n-    };\n-    let expand_struct: ExpandDerivingStructDefFn =\n-        |cx, span, struct_def, type_ident, generics| {\n-        trait_def.expand_struct_def(cx, span, struct_def, type_ident, generics)\n-    };\n-\n-    expand_deriving(cx, span, in_items,\n-                    expand_struct,\n-                    expand_enum)\n+    let mut result = ~[];\n+    for in_items.each |item| {\n+        result.push(*item);\n+        match item.node {\n+            ast::item_struct(struct_def, ref generics) => {\n+                result.push(trait_def.expand_struct_def(cx,\n+                                                        span,\n+                                                        struct_def,\n+                                                        item.ident,\n+                                                        generics));\n+            }\n+            ast::item_enum(ref enum_definition, ref generics) => {\n+                result.push(trait_def.expand_enum_def(cx,\n+                                                      span,\n+                                                      enum_definition,\n+                                                      item.ident,\n+                                                      generics));\n+            }\n+            _ => ()\n+        }\n+    }\n+    result\n }\n \n pub struct TraitDef<'self> {\n@@ -301,23 +310,71 @@ pub type EnumNonMatchFunc<'self> =\n \n \n impl<'self> TraitDef<'self> {\n+    /**\n+     *\n+     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n+     * 'z, A, ..., Z>`, creates an impl like:\n+     *\n+     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n+     *\n+     * where B1, B2, ... are the bounds given by `bounds_paths`.'\n+     *\n+     */\n     fn create_derived_impl(&self, cx: @ExtCtxt, span: span,\n                            type_ident: ident, generics: &Generics,\n                            methods: ~[@ast::method]) -> @ast::item {\n         let trait_path = self.path.to_path(cx, span, type_ident, generics);\n \n-        let trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+        let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n+        // Copy the lifetimes\n+        for generics.lifetimes.each |l| {\n+            trait_generics.lifetimes.push(copy *l)\n+        };\n+        // Create the type parameters.\n+        for generics.ty_params.each |ty_param| {\n+            // I don't think this can be moved out of the loop, since\n+            // a TyParamBound requires an ast id\n+            let mut bounds = opt_vec::from(\n+                // extra restrictions on the generics parameters to the type being derived upon\n+                do self.additional_bounds.map |p| {\n+                    cx.typarambound(p.to_path(cx, span, type_ident, generics))\n+                });\n+            // require the current trait\n+            bounds.push(cx.typarambound(trait_path));\n+\n+            trait_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n+        }\n+\n+        // Create the reference to the trait.\n+        let trait_ref = cx.trait_ref(trait_path);\n \n-        let additional_bounds = opt_vec::from(\n-            do self.additional_bounds.map |p| {\n-                p.to_path(cx, span, type_ident, generics)\n-            });\n+        // Create the type parameters on the `self` path.\n+        let self_ty_params = do generics.ty_params.map |ty_param| {\n+            cx.ty_ident(span, ty_param.ident)\n+        };\n \n-        create_derived_impl(cx, span,\n-                            type_ident, generics,\n-                            methods, trait_path,\n-                            trait_generics,\n-                            additional_bounds)\n+        let self_lifetime = if generics.lifetimes.is_empty() {\n+            None\n+        } else {\n+            Some(@*generics.lifetimes.get(0))\n+        };\n+\n+        // Create the type of `self`.\n+        let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n+                                               opt_vec::take_vec(self_ty_params)));\n+\n+        let doc_attr = cx.attribute(\n+            span,\n+            cx.meta_name_value(span,\n+                               ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n+        cx.item(\n+            span,\n+            ::parse::token::special_idents::clownshoes_extensions,\n+            ~[doc_attr],\n+            ast::item_impl(trait_generics,\n+                           Some(trait_ref),\n+                           self_type,\n+                           methods.map(|x| *x)))\n     }\n \n     fn expand_struct_def(&self, cx: @ExtCtxt,\n@@ -834,6 +891,124 @@ fn summarise_struct(cx: @ExtCtxt, span: span,\n     }\n }\n \n+pub fn create_subpatterns(cx: @ExtCtxt,\n+                          span: span,\n+                          field_paths: ~[@ast::Path],\n+                          mutbl: ast::mutability)\n+                   -> ~[@ast::pat] {\n+    do field_paths.map |&path| {\n+        cx.pat(span, ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n+    }\n+}\n+\n+#[deriving(Eq)] // dogfooding!\n+enum StructType {\n+    Unknown, Record, Tuple\n+}\n+\n+fn create_struct_pattern(cx: @ExtCtxt,\n+                             span: span,\n+                             struct_ident: ident,\n+                             struct_def: &struct_def,\n+                             prefix: &str,\n+                             mutbl: ast::mutability)\n+    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+    if struct_def.fields.is_empty() {\n+        return (\n+            cx.pat_ident_binding_mode(\n+                span, struct_ident, ast::bind_infer),\n+            ~[]);\n+    }\n+\n+    let matching_path = cx.path(span, ~[ struct_ident ]);\n+\n+    let mut paths = ~[];\n+    let mut ident_expr = ~[];\n+    let mut struct_type = Unknown;\n+\n+    for struct_def.fields.eachi |i, struct_field| {\n+        let opt_id = match struct_field.node.kind {\n+            ast::named_field(ident, _) if (struct_type == Unknown ||\n+                                           struct_type == Record) => {\n+                struct_type = Record;\n+                Some(ident)\n+            }\n+            ast::unnamed_field if (struct_type == Unknown ||\n+                                   struct_type == Tuple) => {\n+                struct_type = Tuple;\n+                None\n+            }\n+            _ => {\n+                cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n+            }\n+        };\n+        let path = cx.path_ident(span,\n+                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n+        paths.push(path);\n+        ident_expr.push((opt_id, cx.expr_path(path)));\n+    }\n+\n+    let subpats = create_subpatterns(cx, span, paths, mutbl);\n+\n+    // struct_type is definitely not Unknown, since struct_def.fields\n+    // must be nonempty to reach here\n+    let pattern = if struct_type == Record {\n+        let field_pats = do vec::build |push| {\n+            for vec::each2(subpats, ident_expr) |&pat, &(id, _)| {\n+                // id is guaranteed to be Some\n+                push(ast::field_pat { ident: id.get(), pat: pat })\n+            }\n+        };\n+        cx.pat_struct(span, matching_path, field_pats)\n+    } else {\n+        cx.pat_enum(span, matching_path, subpats)\n+    };\n+\n+    (pattern, ident_expr)\n+}\n+\n+fn create_enum_variant_pattern(cx: @ExtCtxt,\n+                                   span: span,\n+                                   variant: &ast::variant,\n+                                   prefix: &str,\n+                                   mutbl: ast::mutability)\n+    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n+\n+    let variant_ident = variant.node.name;\n+    match variant.node.kind {\n+        ast::tuple_variant_kind(ref variant_args) => {\n+            if variant_args.is_empty() {\n+                return (cx.pat_ident_binding_mode(\n+                    span, variant_ident, ast::bind_infer), ~[]);\n+            }\n+\n+            let matching_path = cx.path_ident(span, variant_ident);\n+\n+            let mut paths = ~[];\n+            let mut ident_expr = ~[];\n+            for uint::range(0, variant_args.len()) |i| {\n+                let path = cx.path_ident(span,\n+                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n+\n+                paths.push(path);\n+                ident_expr.push((None, cx.expr_path(path)));\n+            }\n+\n+            let subpats = create_subpatterns(cx, span, paths, mutbl);\n+\n+            (cx.pat_enum(span, matching_path, subpats),\n+             ident_expr)\n+        }\n+        ast::struct_variant_kind(struct_def) => {\n+            create_struct_pattern(cx, span,\n+                                  variant_ident, struct_def,\n+                                  prefix,\n+                                  mutbl)\n+        }\n+    }\n+}\n+\n+\n \n /* helpful premade recipes */\n "}, {"sha": "1107f21319cb844b9fb54d96414b6f6e4b194c8c", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 254, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/43e52e4bf144bbd2f366a4f32ac0128136273226/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43e52e4bf144bbd2f366a4f32ac0128136273226/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=43e52e4bf144bbd2f366a4f32ac0128136273226", "patch": "@@ -20,16 +20,10 @@ library.\n \n use core::prelude::*;\n \n-use ast;\n-use ast::{Ty, enum_def, expr, ident, item, Generics, meta_item, struct_def};\n+use ast::{enum_def, ident, item, Generics, meta_item, struct_def};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::span;\n-use parse::token::special_idents::clownshoes_extensions;\n-use opt_vec;\n-\n-use core::uint;\n-use core::vec;\n \n pub mod clone;\n pub mod iter_bytes;\n@@ -117,250 +111,3 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n         }\n     }\n }\n-\n-pub fn expand_deriving(cx: @ExtCtxt,\n-                   span: span,\n-                   in_items: ~[@item],\n-                   expand_deriving_struct_def: ExpandDerivingStructDefFn,\n-                   expand_deriving_enum_def: ExpandDerivingEnumDefFn)\n-                -> ~[@item] {\n-    let mut result = ~[];\n-    for in_items.each |item| {\n-        result.push(copy *item);\n-        match item.node {\n-            ast::item_struct(struct_def, ref generics) => {\n-                result.push(expand_deriving_struct_def(cx,\n-                                                       span,\n-                                                       struct_def,\n-                                                       item.ident,\n-                                                       generics));\n-            }\n-            ast::item_enum(ref enum_definition, ref generics) => {\n-                result.push(expand_deriving_enum_def(cx,\n-                                                     span,\n-                                                     enum_definition,\n-                                                     item.ident,\n-                                                     generics));\n-            }\n-            _ => ()\n-        }\n-    }\n-    result\n-}\n-\n-pub fn create_self_type_with_params(cx: @ExtCtxt,\n-                                    span: span,\n-                                    type_ident: ident,\n-                                    generics: &Generics)\n-    -> @Ty {\n-    // Create the type parameters on the `self` path.\n-    let mut self_ty_params = ~[];\n-    for generics.ty_params.each |ty_param| {\n-        let self_ty_param = cx.ty_ident(span, ty_param.ident);\n-        self_ty_params.push(self_ty_param);\n-    }\n-\n-    let lifetime = if generics.lifetimes.is_empty() {\n-        None\n-    } else {\n-        Some(@*generics.lifetimes.get(0))\n-    };\n-\n-\n-    // Create the type of `self`.\n-    cx.ty_path(cx.path_all(span, false, ~[ type_ident ], lifetime, self_ty_params))\n-}\n-\n-pub fn create_derived_impl(cx: @ExtCtxt,\n-                           span: span,\n-                           type_ident: ident,\n-                           generics: &Generics,\n-                           methods: &[@ast::method],\n-                           trait_path: @ast::Path,\n-                           mut impl_generics:  Generics,\n-                           bounds_paths: opt_vec::OptVec<@ast::Path>)\n-                        -> @item {\n-    /*!\n-     *\n-     * Given that we are deriving a trait `Tr` for a type `T<'a, ...,\n-     * 'z, A, ..., Z>`, creates an impl like:\n-     *\n-     *      impl<'a, ..., 'z, A:Tr B1 B2, ..., Z: Tr B1 B2> Tr for T<A, ..., Z> { ... }\n-     *\n-     * where B1, B2, ... are the bounds given by `bounds_paths`.\n-     *\n-     */\n-\n-    // Copy the lifetimes\n-    for generics.lifetimes.each |l| {\n-        impl_generics.lifetimes.push(copy *l)\n-    };\n-\n-    // Create the type parameters.\n-    for generics.ty_params.each |ty_param| {\n-        // extra restrictions on the generics parameters to the type being derived upon\n-        let mut bounds = do bounds_paths.map |&bound_path| {\n-            cx.typarambound(bound_path)\n-        };\n-\n-        let this_trait_bound = cx.typarambound(trait_path);\n-        bounds.push(this_trait_bound);\n-\n-        impl_generics.ty_params.push(cx.typaram(ty_param.ident, @bounds));\n-    }\n-\n-    // Create the reference to the trait.\n-    let trait_ref = cx.trait_ref(trait_path);\n-\n-    // Create the type of `self`.\n-    let self_type = create_self_type_with_params(cx,\n-                                                 span,\n-                                                 type_ident,\n-                                                 generics);\n-\n-    let doc_attr = cx.attribute(\n-        span,\n-        cx.meta_name_value(span,\n-                           ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n-    cx.item(\n-        span,\n-        clownshoes_extensions,\n-        ~[doc_attr],\n-        ast::item_impl(impl_generics,\n-                       Some(trait_ref),\n-                       self_type,\n-                       methods.map(|x| *x)))\n-}\n-\n-pub fn create_subpatterns(cx: @ExtCtxt,\n-                          span: span,\n-                          field_paths: ~[@ast::Path],\n-                          mutbl: ast::mutability)\n-                   -> ~[@ast::pat] {\n-    do field_paths.map |&path| {\n-        cx.pat(span,\n-                      ast::pat_ident(ast::bind_by_ref(mutbl), path, None))\n-    }\n-}\n-\n-#[deriving(Eq)] // dogfooding!\n-enum StructType {\n-    Unknown, Record, Tuple\n-}\n-\n-pub fn create_struct_pattern(cx: @ExtCtxt,\n-                             span: span,\n-                             struct_ident: ident,\n-                             struct_def: &struct_def,\n-                             prefix: &str,\n-                             mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n-    if struct_def.fields.is_empty() {\n-        return (\n-            cx.pat_ident_binding_mode(\n-                span, struct_ident, ast::bind_infer),\n-            ~[]);\n-    }\n-\n-    let matching_path = cx.path(span, ~[ struct_ident ]);\n-\n-    let mut paths = ~[];\n-    let mut ident_expr = ~[];\n-    let mut struct_type = Unknown;\n-\n-    for struct_def.fields.eachi |i, struct_field| {\n-        let opt_id = match struct_field.node.kind {\n-            ast::named_field(ident, _) if (struct_type == Unknown ||\n-                                           struct_type == Record) => {\n-                struct_type = Record;\n-                Some(ident)\n-            }\n-            ast::unnamed_field if (struct_type == Unknown ||\n-                                   struct_type == Tuple) => {\n-                struct_type = Tuple;\n-                None\n-            }\n-            _ => {\n-                cx.span_bug(span, \"A struct with named and unnamed fields in `deriving`\");\n-            }\n-        };\n-        let path = cx.path_ident(span,\n-                                 cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-        paths.push(path);\n-        ident_expr.push((opt_id, cx.expr_path(path)));\n-    }\n-\n-    let subpats = create_subpatterns(cx, span, paths, mutbl);\n-\n-    // struct_type is definitely not Unknown, since struct_def.fields\n-    // must be nonempty to reach here\n-    let pattern = if struct_type == Record {\n-        let field_pats = do vec::build |push| {\n-            for vec::each2(subpats, ident_expr) |&pat, &(id, _)| {\n-                // id is guaranteed to be Some\n-                push(ast::field_pat { ident: id.get(), pat: pat })\n-            }\n-        };\n-        cx.pat_struct(span, matching_path, field_pats)\n-    } else {\n-        cx.pat_enum(span, matching_path, subpats)\n-    };\n-\n-    (pattern, ident_expr)\n-}\n-\n-pub fn create_enum_variant_pattern(cx: @ExtCtxt,\n-                                   span: span,\n-                                   variant: &ast::variant,\n-                                   prefix: &str,\n-                                   mutbl: ast::mutability)\n-    -> (@ast::pat, ~[(Option<ident>, @expr)]) {\n-\n-    let variant_ident = variant.node.name;\n-    match variant.node.kind {\n-        ast::tuple_variant_kind(ref variant_args) => {\n-            if variant_args.is_empty() {\n-                return (cx.pat_ident_binding_mode(\n-                    span, variant_ident, ast::bind_infer), ~[]);\n-            }\n-\n-            let matching_path = cx.path_ident(span, variant_ident);\n-\n-            let mut paths = ~[];\n-            let mut ident_expr = ~[];\n-            for uint::range(0, variant_args.len()) |i| {\n-                let path = cx.path_ident(span,\n-                                         cx.ident_of(fmt!(\"%s_%u\", prefix, i)));\n-\n-                paths.push(path);\n-                ident_expr.push((None, cx.expr_path(path)));\n-            }\n-\n-            let subpats = create_subpatterns(cx, span, paths, mutbl);\n-\n-            (cx.pat_enum(span, matching_path, subpats),\n-             ident_expr)\n-        }\n-        ast::struct_variant_kind(struct_def) => {\n-            create_struct_pattern(cx, span,\n-                                  variant_ident, struct_def,\n-                                  prefix,\n-                                  mutbl)\n-        }\n-    }\n-}\n-\n-pub fn variant_arg_count(_cx: @ExtCtxt, _span: span, variant: &ast::variant) -> uint {\n-    match variant.node.kind {\n-        ast::tuple_variant_kind(ref args) => args.len(),\n-        ast::struct_variant_kind(ref struct_def) => struct_def.fields.len(),\n-    }\n-}\n-\n-pub fn expand_enum_or_struct_match(cx: @ExtCtxt,\n-                               span: span,\n-                               arms: ~[ ast::arm ])\n-                            -> @expr {\n-    let self_expr = cx.expr_deref(span, cx.expr_self(span));\n-    cx.expr_match(span, self_expr, arms)\n-}"}]}