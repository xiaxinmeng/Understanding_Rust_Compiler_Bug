{"sha": "a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4YTJhODg3ZDBhNjVmZmY2Yzc3N2Y5YmNkN2IxYzBiZGZiYmRkYzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-16T20:58:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-16T20:58:09Z"}, "message": "Auto merge of #56875 - Centril:rollup, r=Centril\n\nRollup of 20 pull requests\n\nSuccessful merges:\n\n - #53506 (Documentation for impl From for AtomicBool and other Atomic types)\n - #56343 (Remove not used mod)\n - #56439 (Clearer error message for dead assign)\n - #56640 (Add FreeBSD unsigned char platforms to std::os::raw)\n - #56648 (Fix BTreeMap UB)\n - #56672 (Document time of back operations of a Linked List)\n - #56706 (Make `const unsafe fn` bodies `unsafe`)\n - #56742 (infer: remove Box from a returned Iterator)\n - #56761 (Suggest using `.display()` when trying to print a `Path`)\n - #56781 (Update LLVM submodule)\n - #56789 (rustc: Add an unstable `simd_select_bitmask` intrinsic)\n - #56790 (Make RValue::Discriminant a normal Shallow read)\n - #56793 (rustdoc: look for comments when scraping attributes/crates from doctests)\n - #56826 (rustc: Add the `cmpxchg16b` target feature on x86/x86_64)\n - #56832 (std: Use `rustc_demangle` from crates.io)\n - #56844 (Improve CSS rule)\n - #56850 (Fixed issue with using `Self` ctor in typedefs)\n - #56855 (Remove u8 cttz hack)\n - #56857 (Fix a small mistake regarding NaNs in a deprecation message)\n - #56858 (Fix doc of `std::fs::canonicalize`)\n\nFailed merges:\n\n - #56741 (treat ref-to-raw cast like a reborrow: do a special kind of retag)\n\nr? @ghost", "tree": {"sha": "66b8ff8ea5e9f3700eec09cec28209283cb3224c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66b8ff8ea5e9f3700eec09cec28209283cb3224c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "html_url": "https://github.com/rust-lang/rust/commit/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "19dc2caf71d5df30d9214517efa1e6c203e337b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/19dc2caf71d5df30d9214517efa1e6c203e337b1", "html_url": "https://github.com/rust-lang/rust/commit/19dc2caf71d5df30d9214517efa1e6c203e337b1"}, {"sha": "6574d83dcffda1569976f40c7e09c799d3e04241", "url": "https://api.github.com/repos/rust-lang/rust/commits/6574d83dcffda1569976f40c7e09c799d3e04241", "html_url": "https://github.com/rust-lang/rust/commit/6574d83dcffda1569976f40c7e09c799d3e04241"}], "stats": {"total": 1485, "additions": 649, "deletions": 836}, "files": [{"sha": "7e03474565d857a8b4af3ebc7cc48107076162b4", "filename": "Cargo.lock", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -87,7 +87,7 @@ dependencies = [\n  \"backtrace-sys 0.1.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cfg-if 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.45 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"winapi 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1813,7 +1813,7 @@ name = \"rand_chacha\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -1835,7 +1835,7 @@ name = \"rand_hc\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1860,7 +1860,7 @@ name = \"rand_xorshift\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"rand_core 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rand_core 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -2195,8 +2195,12 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.9\"\n+version = \"0.1.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"compiler_builtins 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-std-workspace-core 1.0.0\",\n+]\n \n [[package]]\n name = \"rustc-hash\"\n@@ -2315,7 +2319,7 @@ dependencies = [\n  \"cc 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_llvm 0.0.0\",\n ]\n \n@@ -2331,7 +2335,7 @@ dependencies = [\n  \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n- \"rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n  \"rustc_apfloat 0.0.0\",\n  \"rustc_codegen_utils 0.0.0\",\n@@ -2892,6 +2896,7 @@ dependencies = [\n  \"panic_unwind 0.0.0\",\n  \"profiler_builtins 0.0.0\",\n  \"rand 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_asan 0.0.0\",\n  \"rustc_lsan 0.0.0\",\n  \"rustc_msan 0.0.0\",\n@@ -3578,7 +3583,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-ap-serialize 306.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5b2c0e8161e956647592a737074736e6ce05ea36b70c770ea8cca3eb9cb33737\"\n \"checksum rustc-ap-syntax 306.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1adc189e5e4500a4167b9afa04e67067f40d0039e0e05870c977bebb561f065a\"\n \"checksum rustc-ap-syntax_pos 306.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4d42c430dbb0be4377bfe6aa5099074c63ac8796b24098562c2e2154aecc5652\"\n-\"checksum rustc-demangle 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bcfe5b13211b4d78e5c2cadfebd7769197d95c639c35a50057eb4c05de811395\"\n+\"checksum rustc-demangle 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"82ae957aa1b3055d8e086486723c0ccd3d7b8fa190ae8fa2e35543b6171c810e\"\n \"checksum rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7540fc8b0c49f096ee9c961cda096467dce8084bec6bdca2fc83895fd9b28cb8\"\n \"checksum rustc-rayon 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8c6d5a683c6ba4ed37959097e88d71c9e8e26659a3cb5be8b389078e7ad45306\"\n \"checksum rustc-rayon-core 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40f06724db71e18d68b3b946fdf890ca8c921d9edccc1404fdfdb537b0d12649\""}, {"sha": "a2d2d3c74be9dd261813b56a42eaa19f8527df2a", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 117, "deletions": 57, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -58,9 +58,34 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// these should always be put behind pointers, and specifically behind `BoxedNode` in the owned\n /// case.\n ///\n-/// We put the metadata first so that its position is the same for every `K` and `V`, in order\n-/// to statically allocate a single dummy node to avoid allocations. This struct is `repr(C)` to\n-/// prevent them from being reordered.\n+/// We have a separate type for the header and rely on it matching the prefix of `LeafNode`, in\n+/// order to statically allocate a single dummy node to avoid allocations. This struct is\n+/// `repr(C)` to prevent them from being reordered.  `LeafNode` does not just contain a\n+/// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n+/// Crucially, `NodeHeader` can be safely transmuted to different K and V.  (This is exploited\n+/// by `as_header`.)\n+/// See `into_key_slice` for an explanation of K2.  K2 cannot be safely transmuted around\n+/// because the size of `NodeHeader` depends on its alignment!\n+#[repr(C)]\n+struct NodeHeader<K, V, K2 = ()> {\n+    /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n+    /// This either points to an actual node or is null.\n+    parent: *const InternalNode<K, V>,\n+\n+    /// This node's index into the parent node's `edges` array.\n+    /// `*node.parent.edges[node.parent_idx]` should be the same thing as `node`.\n+    /// This is only guaranteed to be initialized when `parent` is non-null.\n+    parent_idx: MaybeUninit<u16>,\n+\n+    /// The number of keys and values this node stores.\n+    ///\n+    /// This next to `parent_idx` to encourage the compiler to join `len` and\n+    /// `parent_idx` into the same 32-bit word, reducing space overhead.\n+    len: u16,\n+\n+    /// See `into_key_slice`.\n+    keys_start: [K2; 0],\n+}\n #[repr(C)]\n struct LeafNode<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n@@ -98,24 +123,25 @@ impl<K, V> LeafNode<K, V> {\n             len: 0\n         }\n     }\n+}\n \n+impl<K, V> NodeHeader<K, V> {\n     fn is_shared_root(&self) -> bool {\n         ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n     }\n }\n \n // We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for LeafNode<(), ()> {}\n+unsafe impl Sync for NodeHeader<(), ()> {}\n \n // An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use () in order to save space, since no operation on an empty tree will\n+// We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: LeafNode<(), ()> = LeafNode {\n+static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n     parent: ptr::null(),\n     parent_idx: MaybeUninit::uninitialized(),\n     len: 0,\n-    keys: MaybeUninit::uninitialized(),\n-    vals: MaybeUninit::uninitialized(),\n+    keys_start: [],\n };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n@@ -281,7 +307,7 @@ impl<K, V> Root<K, V> {\n                                     .node)\n         };\n         self.height -= 1;\n-        self.as_mut().as_leaf_mut().parent = ptr::null();\n+        unsafe { (*self.as_mut().as_leaf_mut()).parent = ptr::null(); }\n \n         unsafe {\n             Global.dealloc(NonNull::from(top).cast(), Layout::new::<InternalNode<K, V>>());\n@@ -306,6 +332,11 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n+///   Note that in case of a leaf node, this might still be the shared root!  Only turn\n+///   this into a `LeafNode` reference if you know it is not a root!  Shared references\n+///   must be dereferencable *for the entire size of their pointee*, so `&InternalNode`\n+///   pointing to the shared root is UB.\n+///   Turning this into a `NodeHeader` is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     height: usize,\n     node: NonNull<LeafNode<K, V>>,\n@@ -352,7 +383,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Finds the length of the node. This is the number of keys or values. In an\n     /// internal node, the number of edges is `len() + 1`.\n     pub fn len(&self) -> usize {\n-        self.as_leaf().len as usize\n+        self.as_header().len as usize\n     }\n \n     /// Returns the height of this node in the whole tree. Zero height denotes the\n@@ -382,14 +413,19 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf(&self) -> &LeafNode<K, V> {\n+    /// Assert that this is indeed a proper leaf node, and not the shared root.\n+    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n+        self.node.as_ref()\n+    }\n+\n+    fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe {\n-            self.node.as_ref()\n+            &*(self.node.as_ptr() as *const NodeHeader<K, V>)\n         }\n     }\n \n     pub fn is_shared_root(&self) -> bool {\n-        self.as_leaf().is_shared_root()\n+        self.as_header().is_shared_root()\n     }\n \n     pub fn keys(&self) -> &[K] {\n@@ -418,7 +454,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         >,\n         Self\n     > {\n-        let parent_as_leaf = self.as_leaf().parent as *const LeafNode<K, V>;\n+        let parent_as_leaf = self.as_header().parent as *const LeafNode<K, V>;\n         if let Some(non_zero) = NonNull::new(parent_as_leaf as *mut _) {\n             Ok(Handle {\n                 node: NodeRef {\n@@ -427,7 +463,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n                     root: self.root,\n                     _marker: PhantomData\n                 },\n-                idx: unsafe { usize::from(*self.as_leaf().parent_idx.get_ref()) },\n+                idx: unsafe { usize::from(*self.as_header().parent_idx.get_ref()) },\n                 _marker: PhantomData\n             })\n         } else {\n@@ -534,10 +570,10 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         }\n     }\n \n-    fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n-        unsafe {\n-            self.node.as_mut()\n-        }\n+    /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n+    fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n+        // We are mutable, so we cannot be the root, so accessing this as a leaf is okay.\n+        self.node.as_ptr()\n     }\n \n     fn keys_mut(&mut self) -> &mut [K] {\n@@ -551,28 +587,50 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     fn into_key_slice(self) -> &'a [K] {\n-        // When taking a pointer to the keys, if our key has a stricter\n-        // alignment requirement than the shared root does, then the pointer\n-        // would be out of bounds, which LLVM assumes will not happen. If the\n-        // alignment is more strict, we need to make an empty slice that doesn't\n-        // use an out of bounds pointer.\n+        // We have to be careful here because we might be pointing to the shared root.\n+        // In that case, we must not create an `&LeafNode`.  We could just return\n+        // an empty slice whenever the length is 0 (this includes the shared root),\n+        // but we want to avoid that run-time check.\n+        // Instead, we create a slice pointing into the node whenever possible.\n+        // We can sometimes do this even for the shared root, as the slice will be\n+        // empty.  We cannot *always* do this because if the type is too highly\n+        // aligned, the offset of `keys` in a \"full node\" might be outside the bounds\n+        // of the header!  So we do an alignment check first, that will be\n+        // evaluated at compile-time, and only do any run-time check in the rare case\n+        // that the alignment is very big.\n         if mem::align_of::<K>() > mem::align_of::<LeafNode<(), ()>>() && self.is_shared_root() {\n             &[]\n         } else {\n-            // Here either it's not the root, or the alignment is less strict,\n-            // in which case the keys pointer will point \"one-past-the-end\" of\n-            // the node, which is allowed by LLVM.\n+            // Thanks to the alignment check above, we know that `keys` will be\n+            // in-bounds of some allocation even if this is the shared root!\n+            // (We might be one-past-the-end, but that is allowed by LLVM.)\n+            // Getting the pointer is tricky though.  `NodeHeader` does not have a `keys`\n+            // field because we want its size to not depend on the alignment of `K`\n+            // (needed becuase `as_header` should be safe).  We cannot call `as_leaf`\n+            // because we might be the shared root.\n+            // For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n+            // and hence just adds a size-0-align-1 field, not affecting layout).\n+            // We know that we can transmute `NodeHeader<K, V, ()>` to `NodeHeader<K, V, K>`\n+            // because we did the alignment check above, and hence `NodeHeader<K, V, K>`\n+            // is not bigger than `NodeHeader<K, V, ()>`!  Then we can use `NodeHeader<K, V, K>`\n+            // to compute the pointer where the keys start.\n+            // This entire hack will become unnecessary once\n+            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n+            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n+\n+            // This is a non-debug-assert because it can be completely compile-time evaluated.\n+            assert!(mem::size_of::<NodeHeader<K, V>>() == mem::size_of::<NodeHeader<K, V, K>>());\n+            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n+            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n             unsafe {\n-                slice::from_raw_parts(\n-                    self.as_leaf().keys.as_ptr() as *const K,\n-                    self.len()\n-                )\n+                slice::from_raw_parts(keys, self.len())\n             }\n         }\n     }\n \n     fn into_val_slice(self) -> &'a [V] {\n         debug_assert!(!self.is_shared_root());\n+        // We cannot be the root, so `as_leaf` is okay\n         unsafe {\n             slice::from_raw_parts(\n                 self.as_leaf().vals.as_ptr() as *const V,\n@@ -602,7 +660,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         } else {\n             unsafe {\n                 slice::from_raw_parts_mut(\n-                    self.as_leaf_mut().keys.as_mut_ptr() as *mut K,\n+                    (*self.as_leaf_mut()).keys.as_mut_ptr() as *mut K,\n                     self.len()\n                 )\n             }\n@@ -613,7 +671,7 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         debug_assert!(!self.is_shared_root());\n         unsafe {\n             slice::from_raw_parts_mut(\n-                self.as_leaf_mut().vals.as_mut_ptr() as *mut V,\n+                (*self.as_leaf_mut()).vals.as_mut_ptr() as *mut V,\n                 self.len()\n             )\n         }\n@@ -637,9 +695,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-        }\n \n-        self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n+        }\n     }\n \n     /// Adds a key/value pair to the beginning of the node.\n@@ -651,9 +709,9 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n             slice_insert(self.vals_mut(), 0, val);\n-        }\n \n-        self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n+        }\n     }\n }\n \n@@ -672,7 +730,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n             ptr::write(self.as_internal_mut().edges.get_unchecked_mut(idx + 1), edge.node);\n \n-            self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n \n             Handle::new_edge(self.reborrow_mut(), idx + 1).correct_parent_link();\n         }\n@@ -708,7 +766,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n                 edge.node\n             );\n \n-            self.as_leaf_mut().len += 1;\n+            (*self.as_leaf_mut()).len += 1;\n \n             self.correct_all_childrens_parent_links();\n         }\n@@ -732,12 +790,12 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 ForceResult::Internal(internal) => {\n                     let edge = ptr::read(internal.as_internal().edges.get_unchecked(idx + 1));\n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n                     Some(new_root)\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            (*self.as_leaf_mut()).len -= 1;\n             (key, val, edge)\n         }\n     }\n@@ -765,7 +823,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                     );\n \n                     let mut new_root = Root { node: edge, height: internal.height - 1 };\n-                    new_root.as_mut().as_leaf_mut().parent = ptr::null();\n+                    (*new_root.as_mut().as_leaf_mut()).parent = ptr::null();\n \n                     for i in 0..old_len {\n                         Handle::new_edge(internal.reborrow_mut(), i).correct_parent_link();\n@@ -775,7 +833,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n                 }\n             };\n \n-            self.as_leaf_mut().len -= 1;\n+            (*self.as_leaf_mut()).len -= 1;\n \n             (key, val, edge)\n         }\n@@ -966,7 +1024,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             slice_insert(self.node.keys_mut(), self.idx, key);\n             slice_insert(self.node.vals_mut(), self.idx, val);\n \n-            self.node.as_leaf_mut().len += 1;\n+            (*self.node.as_leaf_mut()).len += 1;\n \n             self.node.vals_mut().get_unchecked_mut(self.idx)\n         }\n@@ -1009,8 +1067,10 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let idx = self.idx as u16;\n         let ptr = self.node.as_internal_mut() as *mut _;\n         let mut child = self.descend();\n-        child.as_leaf_mut().parent = ptr;\n-        child.as_leaf_mut().parent_idx.set(idx);\n+        unsafe {\n+            (*child.as_leaf_mut()).parent = ptr;\n+            (*child.as_leaf_mut()).parent_idx.set(idx);\n+        }\n     }\n \n     /// Unsafely asserts to the compiler some static information about whether the underlying\n@@ -1158,7 +1218,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n                 new_len\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n+            (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.len = new_len as u16;\n \n             (\n@@ -1180,7 +1240,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n-            self.node.as_leaf_mut().len -= 1;\n+            (*self.node.as_leaf_mut()).len -= 1;\n             (self.left_edge(), k, v)\n         }\n     }\n@@ -1221,7 +1281,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 new_len + 1\n             );\n \n-            self.node.as_leaf_mut().len = self.idx as u16;\n+            (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.data.len = new_len as u16;\n \n             let mut new_root = Root {\n@@ -1295,9 +1355,9 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n             for i in self.idx+1..self.node.len() {\n                 Handle::new_edge(self.node.reborrow_mut(), i).correct_parent_link();\n             }\n-            self.node.as_leaf_mut().len -= 1;\n+            (*self.node.as_leaf_mut()).len -= 1;\n \n-            left_node.as_leaf_mut().len += right_len as u16 + 1;\n+            (*left_node.as_leaf_mut()).len += right_len as u16 + 1;\n \n             if self.node.height > 1 {\n                 ptr::copy_nonoverlapping(\n@@ -1407,8 +1467,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 move_kv(left_kv, new_left_len, parent_kv, 0, 1);\n             }\n \n-            left_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len += count as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1468,8 +1528,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                           new_right_len);\n             }\n \n-            left_node.reborrow_mut().as_leaf_mut().len += count as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len -= count as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len += count as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len -= count as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(mut right)) => {\n@@ -1560,8 +1620,8 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, ma\n \n             move_kv(left_kv, left_new_len, right_kv, 0, right_new_len);\n \n-            left_node.reborrow_mut().as_leaf_mut().len = left_new_len as u16;\n-            right_node.reborrow_mut().as_leaf_mut().len = right_new_len as u16;\n+            (*left_node.reborrow_mut().as_leaf_mut()).len = left_new_len as u16;\n+            (*right_node.reborrow_mut().as_leaf_mut()).len = right_new_len as u16;\n \n             match (left_node.force(), right_node.force()) {\n                 (ForceResult::Internal(left), ForceResult::Internal(right)) => {"}, {"sha": "ba46fafaf169f6d09bb46a700773dab490639811", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -627,7 +627,9 @@ impl<T> LinkedList<T> {\n         self.pop_front_node().map(Node::into_element)\n     }\n \n-    /// Appends an element to the back of a list\n+    /// Appends an element to the back of a list.\n+    ///\n+    /// This operation should compute in O(1) time.\n     ///\n     /// # Examples\n     ///\n@@ -647,6 +649,8 @@ impl<T> LinkedList<T> {\n     /// Removes the last element from a list and returns it, or `None` if\n     /// it is empty.\n     ///\n+    /// This operation should compute in O(1) time.\n+    ///\n     /// # Examples\n     ///\n     /// ```"}, {"sha": "8e0caa5ae330deb3f771b2055bae935b0aec9542", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -609,10 +609,15 @@ pub trait Debug {\n /// println!(\"The origin is: {}\", origin);\n /// ```\n #[rustc_on_unimplemented(\n+    on(\n+        _Self=\"std::path::Path\",\n+        label=\"`{Self}` cannot be formatted with the default formatter; call `.display()` on it\",\n+        note=\"call `.display()` or `.to_string_lossy()` to safely print paths, \\\n+              as they may contain non-Unicode data\"\n+    ),\n     message=\"`{Self}` doesn't implement `{Display}`\",\n     label=\"`{Self}` cannot be formatted with the default formatter\",\n-    note=\"in format strings you may be able to use `{{:?}}` \\\n-          (or {{:#?}} for pretty-print) instead\",\n+    note=\"in format strings you may be able to use `{{:?}}` (or {{:#?}} for pretty-print) instead\",\n )]\n #[doc(alias = \"{}\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f1df1f2856ed6b0566f2aa00fb999b4a3fb67a64", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -70,7 +70,7 @@ assert_eq!(size_of::<Option<std::num::\", stringify!($Ty), \">>(), size_of::<\", st\n                 #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n                 #[inline]\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n-                    $Ty(unsafe { NonZero(n) })\n+                    $Ty(NonZero(n))\n                 }\n \n                 /// Create a non-zero if the given value is not zero.\n@@ -2150,19 +2150,6 @@ impl isize {\n          \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\" }\n }\n \n-// Emits the correct `cttz` call, depending on the size of the type.\n-macro_rules! uint_cttz_call {\n-    // As of LLVM 3.6 the codegen for the zero-safe cttz8 intrinsic\n-    // emits two conditional moves on x86_64. By promoting the value to\n-    // u16 and setting bit 8, we get better code without any conditional\n-    // operations.\n-    // FIXME: There's a LLVM patch (http://reviews.llvm.org/D9284)\n-    // pending, remove this workaround once LLVM generates better code\n-    // for cttz8.\n-    ($value:expr, 8) => { intrinsics::cttz($value as u16 | 0x100) };\n-    ($value:expr, $_BITS:expr) => { intrinsics::cttz($value) }\n-}\n-\n // `Int` + `UnsignedInt` implemented for unsigned integers\n macro_rules! uint_impl {\n     ($SelfT:ty, $ActualT:ty, $BITS:expr, $MaxV:expr, $Feature:expr, $EndFeature:expr,\n@@ -2306,7 +2293,7 @@ assert_eq!(n.trailing_zeros(), 3);\", $EndFeature, \"\n             #[rustc_const_unstable(feature = \"const_int_ops\")]\n             #[inline]\n             pub const fn trailing_zeros(self) -> u32 {\n-                unsafe { uint_cttz_call!(self, $BITS) as u32 }\n+                unsafe { intrinsics::cttz(self) as u32 }\n             }\n         }\n "}, {"sha": "b3c93ae1fa7b24b5a25f862ccb38ec987e75f925", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -2928,7 +2928,7 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: unsafe { NonZero(ptr as _) } }\n+        NonNull { pointer: NonZero(ptr as _) }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null."}, {"sha": "d2683e31eefb84fc04089034f8cf8d2fdb11a305", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1072,6 +1072,15 @@ impl<T> AtomicPtr<T> {\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n impl From<bool> for AtomicBool {\n+    /// Converts a `bool` into an `AtomicBool`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomic::AtomicBool;\n+    /// let atomic_bool = AtomicBool::from(true);\n+    /// assert_eq!(format!(\"{:?}\", atomic_bool), \"true\")\n+    /// ```\n     #[inline]\n     fn from(b: bool) -> Self { Self::new(b) }\n }\n@@ -1126,8 +1135,12 @@ macro_rules! atomic_int {\n \n         #[$stable_from]\n         impl From<$int_type> for $atomic_type {\n-            #[inline]\n-            fn from(v: $int_type) -> Self { Self::new(v) }\n+            doc_comment! {\n+                concat!(\n+\"Converts an `\", stringify!($int_type), \"` into an `\", stringify!($atomic_type), \"`.\"),\n+                #[inline]\n+                fn from(v: $int_type) -> Self { Self::new(v) }\n+            }\n         }\n \n         #[$stable_debug]"}, {"sha": "43bc9d88895d7e74af0c63c4f4432bd5d40a9972", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -36,6 +36,7 @@ use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::fold::TypeFoldable;\n use ty::subst::{Kind, UnpackedKind};\n use ty::{self, BoundVar, Lift, Ty, TyCtxt};\n+use util::captures::Captures;\n \n impl<'cx, 'gcx, 'tcx> InferCtxtBuilder<'cx, 'gcx, 'tcx> {\n     /// The \"main method\" for a canonicalized trait query. Given the\n@@ -527,32 +528,30 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n-        Box::new(\n-            unsubstituted_region_constraints\n-                .iter()\n-                .map(move |constraint| {\n-                    let constraint = substitute_value(self.tcx, result_subst, constraint);\n-                    let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n-\n-                    Obligation::new(\n-                        cause.clone(),\n-                        param_env,\n-                        match k1.unpack() {\n-                            UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n-                                ty::Binder::bind(\n-                                    ty::OutlivesPredicate(r1, r2)\n-                                )\n-                            ),\n-                            UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n-                                ty::Binder::bind(\n-                                    ty::OutlivesPredicate(t1, r2)\n-                                )\n-                            ),\n-                        }\n-                    )\n-                })\n-        ) as Box<dyn Iterator<Item = _>>\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a + Captures<'gcx> {\n+        unsubstituted_region_constraints\n+            .iter()\n+            .map(move |constraint| {\n+                let constraint = substitute_value(self.tcx, result_subst, constraint);\n+                let &ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+\n+                Obligation::new(\n+                    cause.clone(),\n+                    param_env,\n+                    match k1.unpack() {\n+                        UnpackedKind::Lifetime(r1) => ty::Predicate::RegionOutlives(\n+                            ty::Binder::bind(\n+                                ty::OutlivesPredicate(r1, r2)\n+                            )\n+                        ),\n+                        UnpackedKind::Type(t1) => ty::Predicate::TypeOutlives(\n+                            ty::Binder::bind(\n+                                ty::OutlivesPredicate(t1, r2)\n+                            )\n+                        ),\n+                    }\n+                )\n+            })\n     }\n \n     /// Given two sets of values for the same set of canonical variables, unify them."}, {"sha": "31a75bd106e2cb36c6a9b13deabcb7c6a4375ab7", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1657,11 +1657,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn report_dead_assign(&self, hir_id: HirId, sp: Span, var: Variable, is_argument: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_argument {\n-                self.ir.tcx.lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n-                    &format!(\"value passed to `{}` is never read\", name));\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                &format!(\"value passed to `{}` is never read\", name))\n+                .help(\"maybe it is overwritten before being read?\")\n+                .emit();\n             } else {\n-                self.ir.tcx.lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n-                    &format!(\"value assigned to `{}` is never read\", name));\n+                self.ir.tcx.struct_span_lint_hir(lint::builtin::UNUSED_ASSIGNMENTS, hir_id, sp,\n+                &format!(\"value assigned to `{}` is never read\", name))\n+                .help(\"maybe it is overwritten before being read?\")\n+                .emit();\n             }\n         }\n     }"}, {"sha": "429b7f03af8e40a058d9b7674fe4c10da06a9dd8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1754,17 +1754,19 @@ bitflags! {\n     pub struct AdtFlags: u32 {\n         const NO_ADT_FLAGS        = 0;\n         const IS_ENUM             = 1 << 0;\n-        const IS_PHANTOM_DATA     = 1 << 1;\n-        const IS_FUNDAMENTAL      = 1 << 2;\n-        const IS_UNION            = 1 << 3;\n-        const IS_BOX              = 1 << 4;\n+        const IS_UNION            = 1 << 1;\n+        const IS_STRUCT           = 1 << 2;\n+        const HAS_CTOR            = 1 << 3;\n+        const IS_PHANTOM_DATA     = 1 << 4;\n+        const IS_FUNDAMENTAL      = 1 << 5;\n+        const IS_BOX              = 1 << 6;\n         /// Indicates whether the type is an `Arc`.\n-        const IS_ARC              = 1 << 5;\n+        const IS_ARC              = 1 << 7;\n         /// Indicates whether the type is an `Rc`.\n-        const IS_RC               = 1 << 6;\n+        const IS_RC               = 1 << 8;\n         /// Indicates whether the variant list of this ADT is `#[non_exhaustive]`.\n         /// (i.e., this flag is never set unless this ADT is an enum).\n-        const IS_VARIANT_LIST_NON_EXHAUSTIVE   = 1 << 7;\n+        const IS_VARIANT_LIST_NON_EXHAUSTIVE = 1 << 9;\n     }\n }\n \n@@ -2079,31 +2081,43 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n            repr: ReprOptions) -> Self {\n         debug!(\"AdtDef::new({:?}, {:?}, {:?}, {:?})\", did, kind, variants, repr);\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n+\n+        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n+            debug!(\"found non-exhaustive variant list for {:?}\", did);\n+            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n+        }\n+        flags |= match kind {\n+            AdtKind::Enum => AdtFlags::IS_ENUM,\n+            AdtKind::Union => AdtFlags::IS_UNION,\n+            AdtKind::Struct => AdtFlags::IS_STRUCT,\n+        };\n+\n+        if let AdtKind::Struct = kind {\n+            let variant_def = &variants[VariantIdx::new(0)];\n+            let def_key = tcx.def_key(variant_def.did);\n+            match def_key.disambiguated_data.data {\n+                DefPathData::StructCtor => flags |= AdtFlags::HAS_CTOR,\n+                _ => (),\n+            }\n+        }\n+\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n-            flags = flags | AdtFlags::IS_FUNDAMENTAL;\n+            flags |= AdtFlags::IS_FUNDAMENTAL;\n         }\n         if Some(did) == tcx.lang_items().phantom_data() {\n-            flags = flags | AdtFlags::IS_PHANTOM_DATA;\n+            flags |= AdtFlags::IS_PHANTOM_DATA;\n         }\n         if Some(did) == tcx.lang_items().owned_box() {\n-            flags = flags | AdtFlags::IS_BOX;\n+            flags |= AdtFlags::IS_BOX;\n         }\n         if Some(did) == tcx.lang_items().arc() {\n-            flags = flags | AdtFlags::IS_ARC;\n+            flags |= AdtFlags::IS_ARC;\n         }\n         if Some(did) == tcx.lang_items().rc() {\n-            flags = flags | AdtFlags::IS_RC;\n-        }\n-        if kind == AdtKind::Enum && tcx.has_attr(did, \"non_exhaustive\") {\n-            debug!(\"found non-exhaustive variant list for {:?}\", did);\n-            flags = flags | AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE;\n-        }\n-        match kind {\n-            AdtKind::Enum => flags = flags | AdtFlags::IS_ENUM,\n-            AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n-            AdtKind::Struct => {}\n+            flags |= AdtFlags::IS_RC;\n         }\n+\n         AdtDef {\n             did,\n             variants,\n@@ -2114,25 +2128,25 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     #[inline]\n     pub fn is_struct(&self) -> bool {\n-        !self.is_union() && !self.is_enum()\n+        self.flags.contains(AdtFlags::IS_STRUCT)\n     }\n \n     #[inline]\n     pub fn is_union(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_UNION)\n+        self.flags.contains(AdtFlags::IS_UNION)\n     }\n \n     #[inline]\n     pub fn is_enum(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_ENUM)\n+        self.flags.contains(AdtFlags::IS_ENUM)\n     }\n \n     #[inline]\n     pub fn is_variant_list_non_exhaustive(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n+        self.flags.contains(AdtFlags::IS_VARIANT_LIST_NON_EXHAUSTIVE)\n     }\n \n-    /// Returns the kind of the ADT - Struct or Enum.\n+    /// Returns the kind of the ADT.\n     #[inline]\n     pub fn adt_kind(&self) -> AdtKind {\n         if self.is_enum() {\n@@ -2161,33 +2175,39 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n     }\n \n-    /// Returns whether this type is #[fundamental] for the purposes\n+    /// If this function returns `true`, it implies that `is_struct` must return `true`.\n+    #[inline]\n+    pub fn has_ctor(&self) -> bool {\n+        self.flags.contains(AdtFlags::HAS_CTOR)\n+    }\n+\n+    /// Returns whether this type is `#[fundamental]` for the purposes\n     /// of coherence checking.\n     #[inline]\n     pub fn is_fundamental(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_FUNDAMENTAL)\n+        self.flags.contains(AdtFlags::IS_FUNDAMENTAL)\n     }\n \n     /// Returns `true` if this is PhantomData<T>.\n     #[inline]\n     pub fn is_phantom_data(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_PHANTOM_DATA)\n+        self.flags.contains(AdtFlags::IS_PHANTOM_DATA)\n     }\n \n     /// Returns `true` if this is `Arc<T>`.\n     pub fn is_arc(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_ARC)\n+        self.flags.contains(AdtFlags::IS_ARC)\n     }\n \n     /// Returns `true` if this is `Rc<T>`.\n     pub fn is_rc(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_RC)\n+        self.flags.contains(AdtFlags::IS_RC)\n     }\n \n     /// Returns `true` if this is Box<T>.\n     #[inline]\n     pub fn is_box(&self) -> bool {\n-        self.flags.intersects(AdtFlags::IS_BOX)\n+        self.flags.contains(AdtFlags::IS_BOX)\n     }\n \n     /// Returns whether this type has a destructor."}, {"sha": "e229f8d95cd5b566d09c8ef47cc9f6e445fa8cc3", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1192,7 +1192,7 @@ fn generic_simd_intrinsic(\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n-    // every intrinsic takes a SIMD vector as its first argument\n+    // every intrinsic below takes a SIMD vector as its first argument\n     require_simd!(arg_tys[0], \"input\");\n     let in_ty = arg_tys[0];\n     let in_elem = arg_tys[0].simd_type(tcx);\n@@ -1296,6 +1296,7 @@ fn generic_simd_intrinsic(\n     if name == \"simd_select\" {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n+        require_simd!(arg_tys[1], \"argument\");\n         let v_len = arg_tys[1].simd_size(tcx);\n         require!(m_len == v_len,\n                  \"mismatched lengths: mask length `{}` != other vector length `{}`\","}, {"sha": "82b1d7e8b40e4554adb485776992b7aa04924d64", "filename": "src/librustc_codegen_llvm/llvm_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm_util.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -140,6 +140,7 @@ const X86_WHITELIST: &[(&str, Option<&str>)] = &[\n     (\"avx512vpopcntdq\", Some(\"avx512_target_feature\")),\n     (\"bmi1\", None),\n     (\"bmi2\", None),\n+    (\"cmpxchg16b\", Some(\"cmpxchg16b_target_feature\")),\n     (\"fma\", None),\n     (\"fxsr\", None),\n     (\"lzcnt\", None),\n@@ -212,6 +213,7 @@ pub fn to_llvm_feature<'a>(sess: &Session, s: &'a str) -> &'a str {\n         (\"x86\", \"pclmulqdq\") => \"pclmul\",\n         (\"x86\", \"rdrand\") => \"rdrnd\",\n         (\"x86\", \"bmi1\") => \"bmi\",\n+        (\"x86\", \"cmpxchg16b\") => \"cx16\",\n         (\"aarch64\", \"fp\") => \"fp-armv8\",\n         (\"aarch64\", \"fp16\") => \"fullfp16\",\n         (_, s) => s,"}, {"sha": "5eca62938f7a8c821cbe68b18930779f7c770b12", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -545,7 +545,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                 self.mutate_place(\n                     ContextKind::SetDiscrim.new(location),\n                     (place, span),\n-                    Shallow(Some(ArtificialField::Discriminant)),\n+                    Shallow(None),\n                     JustWrite,\n                     flow_state,\n                 );\n@@ -782,7 +782,6 @@ use self::AccessDepth::{Deep, Shallow};\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ArtificialField {\n-    Discriminant,\n     ArrayLength,\n     ShallowBorrow,\n }\n@@ -1191,14 +1190,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n                 let af = match *rvalue {\n-                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n-                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n+                    Rvalue::Discriminant(..) => None,\n                     _ => unreachable!(),\n                 };\n                 self.access_place(\n                     context,\n                     (place, span),\n-                    (Shallow(Some(af)), Read(ReadKind::Copy)),\n+                    (Shallow(af), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                     flow_state,\n                 );"}, {"sha": "07bda8af62618a6191df91d1533277641add6939", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -99,7 +99,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n                 self.mutate_place(\n                     ContextKind::SetDiscrim.new(location),\n                     place,\n-                    Shallow(Some(ArtificialField::Discriminant)),\n+                    Shallow(None),\n                     JustWrite,\n                 );\n             }\n@@ -360,14 +360,14 @@ impl<'cg, 'cx, 'tcx, 'gcx> InvalidationGenerator<'cx, 'tcx, 'gcx> {\n \n             Rvalue::Len(ref place) | Rvalue::Discriminant(ref place) => {\n                 let af = match *rvalue {\n-                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n-                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n+                    Rvalue::Discriminant(..) => None,\n                     _ => unreachable!(),\n                 };\n                 self.access_place(\n                     context,\n                     place,\n-                    (Shallow(Some(af)), Read(ReadKind::Copy)),\n+                    (Shallow(af), Read(ReadKind::Copy)),\n                     LocalMutationIsAllowed::No,\n                 );\n             }"}, {"sha": "e24586cca0929ba372e8e084253a839f6e3b4c13", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -165,15 +165,12 @@ fn place_components_conflict<'gcx, 'tcx>(\n                 let base_ty = base.ty(mir, tcx).to_ty(tcx);\n \n                 match (elem, &base_ty.sty, access) {\n-                    (_, _, Shallow(Some(ArtificialField::Discriminant)))\n-                    | (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n+                    (_, _, Shallow(Some(ArtificialField::ArrayLength)))\n                     | (_, _, Shallow(Some(ArtificialField::ShallowBorrow))) => {\n-                        // The discriminant and array length are like\n-                        // additional fields on the type; they do not\n-                        // overlap any existing data there. Furthermore,\n-                        // they cannot actually be a prefix of any\n-                        // borrowed place (at least in MIR as it is\n-                        // currently.)\n+                        // The array length is like  additional fields on the\n+                        // type; it does not overlap any existing data there.\n+                        // Furthermore, if cannot actually be a prefix of any\n+                        // borrowed place (at least in MIR as it is currently.)\n                         //\n                         // e.g., a (mutable) borrow of `a[5]` while we read the\n                         // array length of `a`."}, {"sha": "451034fd153341c89c8513ca37432dd067f185a9", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -111,13 +111,6 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n             let safety = match fn_sig.unsafety {\n                 hir::Unsafety::Normal => Safety::Safe,\n-                hir::Unsafety::Unsafe if tcx.is_min_const_fn(fn_def_id) => {\n-                    // As specified in #55607, a `const unsafe fn` differs\n-                    // from an `unsafe fn` in that its body is still considered\n-                    // safe code by default.\n-                    assert!(implicit_argument.is_none());\n-                    Safety::Safe\n-                },\n                 hir::Unsafety::Unsafe => Safety::FnUnsafe,\n             };\n "}, {"sha": "3607869384077656bcc6591ceb6ee520d9f1bae4", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -311,13 +311,9 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                            violations: &[UnsafetyViolation],\n                            unsafe_blocks: &[(ast::NodeId, bool)]) {\n         let safety = self.source_scope_local_data[self.source_info.scope].safety;\n-        let within_unsafe = match (safety, self.min_const_fn) {\n-            // Erring on the safe side, pun intended\n-            (Safety::BuiltinUnsafe, true) |\n-            // mir building encodes const fn bodies as safe, even for `const unsafe fn`\n-            (Safety::FnUnsafe, true) => bug!(\"const unsafe fn body treated as inherently unsafe\"),\n+        let within_unsafe = match safety {\n             // `unsafe` blocks are required in safe code\n-            (Safety::Safe, _) => {\n+            Safety::Safe => {\n                 for violation in violations {\n                     let mut violation = violation.clone();\n                     match violation.kind {\n@@ -342,9 +338,9 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                 }\n                 false\n             }\n-            // regular `unsafe` function bodies allow unsafe without additional unsafe blocks\n-            (Safety::BuiltinUnsafe, false) | (Safety::FnUnsafe, false) => true,\n-            (Safety::ExplicitUnsafe(node_id), _) => {\n+            // `unsafe` function bodies allow unsafe without additional unsafe blocks\n+            Safety::BuiltinUnsafe | Safety::FnUnsafe => true,\n+            Safety::ExplicitUnsafe(node_id) => {\n                 // mark unsafe block as used if there are any unsafe operations inside\n                 if !violations.is_empty() {\n                     self.used_unsafe.insert(node_id);\n@@ -616,21 +612,6 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     } in violations.iter() {\n         // Report an error.\n         match kind {\n-            UnsafetyViolationKind::General if tcx.is_min_const_fn(def_id) => {\n-                let mut err = tcx.sess.struct_span_err(\n-                    source_info.span,\n-                    &format!(\"{} is unsafe and unsafe operations \\\n-                            are not allowed in const fn\", description));\n-                err.span_label(source_info.span, &description.as_str()[..])\n-                    .note(&details.as_str()[..]);\n-                if tcx.fn_sig(def_id).unsafety() == hir::Unsafety::Unsafe {\n-                    err.note(\n-                        \"unsafe action within a `const unsafe fn` still require an `unsafe` \\\n-                        block in contrast to regular `unsafe fn`.\"\n-                    );\n-                }\n-                err.emit();\n-            }\n             UnsafetyViolationKind::GeneralAndConstFn |\n             UnsafetyViolationKind::General => {\n                 struct_span_err!("}, {"sha": "a5d2edbc5d4396f286688ded2938246aa7dbf509", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -41,7 +41,6 @@ pub mod ast_validation;\n pub mod rvalue_promotion;\n pub mod hir_stats;\n pub mod loops;\n-mod mir_stats;\n \n __build_diagnostic_array! { librustc_passes, DIAGNOSTICS }\n "}, {"sha": "fb37f03a1cc41244d0a1466174cfc009fabeb37b", "filename": "src/librustc_passes/mir_stats.rs", "status": "removed", "additions": 0, "deletions": 256, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/19dc2caf71d5df30d9214517efa1e6c203e337b1/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19dc2caf71d5df30d9214517efa1e6c203e337b1/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=19dc2caf71d5df30d9214517efa1e6c203e337b1", "patch": "@@ -1,256 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// The visitors in this module collect sizes and counts of the most important\n-// pieces of MIR. The resulting numbers are good approximations but not\n-// completely accurate (some things might be counted twice, others missed).\n-\n-use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n-use rustc::mir::{Constant, Location, Local, LocalDecl};\n-use rustc::mir::{Place, PlaceElem, PlaceProjection};\n-use rustc::mir::{Mir, Operand, ProjectionElem};\n-use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n-use rustc::mir::{Terminator, TerminatorKind, SourceScope, SourceScopeData};\n-use rustc::mir::interpret::EvalErrorKind;\n-use rustc::mir::visit as mir_visit;\n-use rustc::ty::{self, ClosureSubsts, TyCtxt};\n-use rustc::util::nodemap::{FxHashMap};\n-\n-struct NodeData {\n-    count: usize,\n-    size: usize,\n-}\n-\n-struct StatCollector<'a, 'tcx: 'a> {\n-    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    data: FxHashMap<&'static str, NodeData>,\n-}\n-\n-impl<'a, 'tcx> StatCollector<'a, 'tcx> {\n-\n-    fn record_with_size(&mut self, label: &'static str, node_size: usize) {\n-        let entry = self.data.entry(label).or_insert(NodeData {\n-            count: 0,\n-            size: 0,\n-        });\n-\n-        entry.count += 1;\n-        entry.size = node_size;\n-    }\n-\n-    fn record<T>(&mut self, label: &'static str, node: &T) {\n-        self.record_with_size(label, ::std::mem::size_of_val(node));\n-    }\n-}\n-\n-impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n-    fn visit_mir(&mut self, mir: &Mir<'tcx>) {\n-        self.record(\"Mir\", mir);\n-\n-        // since the `super_mir` method does not traverse the MIR of\n-        // promoted rvalues, (but we still want to gather statistics\n-        // on the structures represented there) we manually traverse\n-        // the promoted rvalues here.\n-        for promoted_mir in &mir.promoted {\n-            self.visit_mir(promoted_mir);\n-        }\n-\n-        self.super_mir(mir);\n-    }\n-\n-    fn visit_basic_block_data(&mut self, block: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.record(\"BasicBlockData\", data);\n-        self.super_basic_block_data(block, data);\n-    }\n-\n-    fn visit_source_scope_data(&mut self, scope_data: &SourceScopeData) {\n-        self.record(\"SourceScopeData\", scope_data);\n-        self.super_source_scope_data(scope_data);\n-    }\n-\n-    fn visit_statement(&mut self,\n-                       block: BasicBlock,\n-                       statement: &Statement<'tcx>,\n-                       location: Location) {\n-        self.record(\"Statement\", statement);\n-        self.record(match statement.kind {\n-            StatementKind::Assign(..) => \"StatementKind::Assign\",\n-            StatementKind::FakeRead(..) => \"StatementKind::FakeRead\",\n-            StatementKind::Retag { .. } => \"StatementKind::Retag\",\n-            StatementKind::EscapeToRaw { .. } => \"StatementKind::EscapeToRaw\",\n-            StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n-            StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n-            StatementKind::StorageDead(..) => \"StatementKind::StorageDead\",\n-            StatementKind::InlineAsm { .. } => \"StatementKind::InlineAsm\",\n-            StatementKind::AscribeUserType(..) => \"StatementKind::AscribeUserType\",\n-            StatementKind::Nop => \"StatementKind::Nop\",\n-        }, &statement.kind);\n-        self.super_statement(block, statement, location);\n-    }\n-\n-    fn visit_terminator(&mut self,\n-                        block: BasicBlock,\n-                        terminator: &Terminator<'tcx>,\n-                        location: Location) {\n-        self.record(\"Terminator\", terminator);\n-        self.super_terminator(block, terminator, location);\n-    }\n-\n-    fn visit_terminator_kind(&mut self,\n-                             block: BasicBlock,\n-                             kind: &TerminatorKind<'tcx>,\n-                             location: Location) {\n-        self.record(\"TerminatorKind\", kind);\n-        self.record(match *kind {\n-            TerminatorKind::Goto { .. } => \"TerminatorKind::Goto\",\n-            TerminatorKind::SwitchInt { .. } => \"TerminatorKind::SwitchInt\",\n-            TerminatorKind::Resume => \"TerminatorKind::Resume\",\n-            TerminatorKind::Abort => \"TerminatorKind::Abort\",\n-            TerminatorKind::Return => \"TerminatorKind::Return\",\n-            TerminatorKind::Unreachable => \"TerminatorKind::Unreachable\",\n-            TerminatorKind::Drop { .. } => \"TerminatorKind::Drop\",\n-            TerminatorKind::DropAndReplace { .. } => \"TerminatorKind::DropAndReplace\",\n-            TerminatorKind::Call { .. } => \"TerminatorKind::Call\",\n-            TerminatorKind::Assert { .. } => \"TerminatorKind::Assert\",\n-            TerminatorKind::GeneratorDrop => \"TerminatorKind::GeneratorDrop\",\n-            TerminatorKind::Yield { .. } => \"TerminatorKind::Yield\",\n-            TerminatorKind::FalseEdges { .. } => \"TerminatorKind::FalseEdges\",\n-            TerminatorKind::FalseUnwind { .. } => \"TerminatorKind::FalseUnwind\",\n-        }, kind);\n-        self.super_terminator_kind(block, kind, location);\n-    }\n-\n-    fn visit_assert_message(&mut self, msg: &AssertMessage<'tcx>, location: Location) {\n-        self.record(\"AssertMessage\", msg);\n-        self.record(match *msg {\n-            EvalErrorKind::BoundsCheck { .. } => \"AssertMessage::BoundsCheck\",\n-            EvalErrorKind::Overflow(..) => \"AssertMessage::Overflow\",\n-            EvalErrorKind::OverflowNeg => \"AssertMessage::OverflowNeg\",\n-            EvalErrorKind::DivisionByZero => \"AssertMessage::DivisionByZero\",\n-            EvalErrorKind::RemainderByZero => \"AssertMessage::RemainderByZero\",\n-            EvalErrorKind::GeneratorResumedAfterReturn => {\n-                \"AssertMessage::GeneratorResumedAfterReturn\"\n-            }\n-            EvalErrorKind::GeneratorResumedAfterPanic => {\n-                \"AssertMessage::GeneratorResumedAfterPanic\"\n-            }\n-            _ => bug!(),\n-        }, msg);\n-        self.super_assert_message(msg, location);\n-    }\n-\n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n-        self.record(\"Rvalue\", rvalue);\n-        let rvalue_kind = match *rvalue {\n-            Rvalue::Use(..) => \"Rvalue::Use\",\n-            Rvalue::Repeat(..) => \"Rvalue::Repeat\",\n-            Rvalue::Ref(..) => \"Rvalue::Ref\",\n-            Rvalue::Len(..) => \"Rvalue::Len\",\n-            Rvalue::Cast(..) => \"Rvalue::Cast\",\n-            Rvalue::BinaryOp(..) => \"Rvalue::BinaryOp\",\n-            Rvalue::CheckedBinaryOp(..) => \"Rvalue::CheckedBinaryOp\",\n-            Rvalue::UnaryOp(..) => \"Rvalue::UnaryOp\",\n-            Rvalue::Discriminant(..) => \"Rvalue::Discriminant\",\n-            Rvalue::NullaryOp(..) => \"Rvalue::NullaryOp\",\n-            Rvalue::Aggregate(ref kind, ref _operands) => {\n-                // AggregateKind is not distinguished by visit API, so\n-                // record it. (`super_rvalue` handles `_operands`.)\n-                self.record(match **kind {\n-                    AggregateKind::Array(_) => \"AggregateKind::Array\",\n-                    AggregateKind::Tuple => \"AggregateKind::Tuple\",\n-                    AggregateKind::Adt(..) => \"AggregateKind::Adt\",\n-                    AggregateKind::Closure(..) => \"AggregateKind::Closure\",\n-                    AggregateKind::Generator(..) => \"AggregateKind::Generator\",\n-                }, kind);\n-\n-                \"Rvalue::Aggregate\"\n-            }\n-        };\n-        self.record(rvalue_kind, rvalue);\n-        self.super_rvalue(rvalue, location);\n-    }\n-\n-    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n-        self.record(\"Operand\", operand);\n-        self.record(match *operand {\n-            Operand::Copy(..) => \"Operand::Copy\",\n-            Operand::Move(..) => \"Operand::Move\",\n-            Operand::Constant(..) => \"Operand::Constant\",\n-        }, operand);\n-        self.super_operand(operand, location);\n-    }\n-\n-    fn visit_place(&mut self,\n-                    place: &Place<'tcx>,\n-                    context: mir_visit::PlaceContext<'tcx>,\n-                    location: Location) {\n-        self.record(\"Place\", place);\n-        self.record(match *place {\n-            Place::Local(..) => \"Place::Local\",\n-            Place::Static(..) => \"Place::Static\",\n-            Place::Promoted(..) => \"Place::Promoted\",\n-            Place::Projection(..) => \"Place::Projection\",\n-        }, place);\n-        self.super_place(place, context, location);\n-    }\n-\n-    fn visit_projection(&mut self,\n-                        place: &PlaceProjection<'tcx>,\n-                        context: mir_visit::PlaceContext<'tcx>,\n-                        location: Location) {\n-        self.record(\"PlaceProjection\", place);\n-        self.super_projection(place, context, location);\n-    }\n-\n-    fn visit_projection_elem(&mut self,\n-                             place: &PlaceElem<'tcx>,\n-                             location: Location) {\n-        self.record(\"PlaceElem\", place);\n-        self.record(match *place {\n-            ProjectionElem::Deref => \"PlaceElem::Deref\",\n-            ProjectionElem::Subslice { .. } => \"PlaceElem::Subslice\",\n-            ProjectionElem::Field(..) => \"PlaceElem::Field\",\n-            ProjectionElem::Index(..) => \"PlaceElem::Index\",\n-            ProjectionElem::ConstantIndex { .. } => \"PlaceElem::ConstantIndex\",\n-            ProjectionElem::Downcast(..) => \"PlaceElem::Downcast\",\n-        }, place);\n-        self.super_projection_elem(place, location);\n-    }\n-\n-    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n-        self.record(\"Constant\", constant);\n-        self.super_constant(constant, location);\n-    }\n-\n-    fn visit_source_info(&mut self, source_info: &SourceInfo) {\n-        self.record(\"SourceInfo\", source_info);\n-        self.super_source_info(source_info);\n-    }\n-\n-    fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, _: Location) {\n-        self.record(\"ClosureSubsts\", substs);\n-        self.super_closure_substs(substs);\n-    }\n-\n-    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n-        self.record(\"Const\", constant);\n-        self.super_const(constant);\n-    }\n-\n-    fn visit_local_decl(&mut self, local: Local, local_decl: &LocalDecl<'tcx>) {\n-        self.record(\"LocalDecl\", local_decl);\n-        self.super_local_decl(local, local_decl);\n-    }\n-\n-    fn visit_source_scope(&mut self, scope: &SourceScope) {\n-        self.record(\"VisiblityScope\", scope);\n-        self.super_source_scope(scope);\n-    }\n-}"}, {"sha": "75ae868883484e0bd308d9b07d02386331faef7d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -280,7 +280,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         Def::Local(id) | Def::Upvar(id, ..) => {\n                             Some(self.tcx.hir().span(id))\n                         }\n-                        _ => self.tcx.hir().span_if_local(def.def_id())\n+                        _ => def.opt_def_id().and_then(|did| self.tcx.hir().span_if_local(did)),\n                     };\n                     if let Some(span) = def_span {\n                         let label = match (unit_variant, inner_callee_path) {"}, {"sha": "957c8d9f19f0ebe1f8e14ea8bb1c0ab4ad1eb087", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -95,7 +95,7 @@ mod op;\n \n use astconv::AstConv;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n-use rustc::hir::{self, GenericArg, Node, ItemKind, PatKind};\n+use rustc::hir::{self, GenericArg, ItemKind, Node, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -113,7 +113,8 @@ use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n                        UserSelfTy, UserSubsts};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate, RegionKind};\n+use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, Visibility, ToPredicate,\n+                RegionKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n@@ -3217,8 +3218,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             return_expr_ty);\n     }\n \n-    // A generic function for checking the then and else in an if\n-    // or if-else.\n+    // A generic function for checking the 'then' and 'else' clauses in an 'if'\n+    // or 'if-else' expression.\n     fn check_then_else(&self,\n                        cond_expr: &'gcx hir::Expr,\n                        then_expr: &'gcx hir::Expr,\n@@ -3544,7 +3545,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // We don't look at stability attributes on\n                 // struct-like enums (yet...), but it's definitely not\n                 // a bug to have constructed one.\n-                if adt_kind != ty::AdtKind::Enum {\n+                if adt_kind != AdtKind::Enum {\n                     tcx.check_stability(v_field.did, Some(expr_id), field.span);\n                 }\n \n@@ -5156,26 +5157,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }).unwrap_or(false);\n \n         let mut new_def = def;\n-        let (def_id, ty) = if let Def::SelfCtor(impl_def_id) = def {\n-            let ty = self.impl_self_ty(span, impl_def_id).ty;\n-\n-            match ty.ty_adt_def() {\n-                Some(adt_def) if adt_def.is_struct() => {\n-                    let variant = adt_def.non_enum_variant();\n-                    new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n-                    (variant.did, self.tcx.type_of(variant.did))\n-                }\n-                _ => {\n-                    (impl_def_id, self.tcx.types.err)\n+        let (def_id, ty) = match def {\n+            Def::SelfCtor(impl_def_id) => {\n+                let ty = self.impl_self_ty(span, impl_def_id).ty;\n+                let adt_def = ty.ty_adt_def();\n+\n+                match adt_def {\n+                    Some(adt_def) if adt_def.has_ctor() => {\n+                        let variant = adt_def.non_enum_variant();\n+                        new_def = Def::StructCtor(variant.did, variant.ctor_kind);\n+                        (variant.did, self.tcx.type_of(variant.did))\n+                    }\n+                    _ => {\n+                        let mut err = self.tcx.sess.struct_span_err(span,\n+                            \"the `Self` constructor can only be used with tuple or unit structs\");\n+                        if let Some(adt_def) = adt_def {\n+                            match adt_def.adt_kind() {\n+                                AdtKind::Enum => {\n+                                    err.note(\"did you mean to use one of the enum's variants?\");\n+                                },\n+                                AdtKind::Struct |\n+                                AdtKind::Union => {\n+                                    err.span_label(\n+                                        span,\n+                                        format!(\"did you mean `Self {{ /* fields */ }}`?\"),\n+                                    );\n+                                }\n+                            }\n+                        }\n+                        err.emit();\n+\n+                        (impl_def_id, self.tcx.types.err)\n+                    }\n                 }\n             }\n-        } else {\n-            let def_id = def.def_id();\n+            _ => {\n+                let def_id = def.def_id();\n \n-            // The things we are substituting into the type should not contain\n-            // escaping late-bound regions, and nor should the base type scheme.\n-            let ty = self.tcx.type_of(def_id);\n-            (def_id, ty)\n+                // The things we are substituting into the type should not contain\n+                // escaping late-bound regions, and nor should the base type scheme.\n+                let ty = self.tcx.type_of(def_id);\n+                (def_id, ty)\n+            }\n         };\n \n         let substs = AstConv::create_substs_for_generic_args("}, {"sha": "01d2cbec1922145445b74d85b24f7df27ebe66a7", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -305,7 +305,7 @@ nav.sub {\n \toverflow-x: auto;\n }\n \n-body:not(.source) .example-wrap > pre {\n+.rustdoc:not(.source) .example-wrap > pre {\n \tmargin: 0;\n }\n "}, {"sha": "84ce9f6d2574d1bc54926aa1c99ff32fb004b94f", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -395,6 +395,7 @@ pub fn make_test(s: &str,\n     // Now push any outer attributes from the example, assuming they\n     // are intended to be crate attributes.\n     prog.push_str(&crate_attrs);\n+    prog.push_str(&crates);\n \n     // Uses libsyntax to parse the doctest and find if there's a main fn and the extern\n     // crate already is included.\n@@ -488,37 +489,78 @@ pub fn make_test(s: &str,\n         prog.push_str(\"\\n}\");\n     }\n \n+    debug!(\"final doctest:\\n{}\", prog);\n+\n     (prog, line_offset)\n }\n \n // FIXME(aburka): use a real parser to deal with multiline attributes\n fn partition_source(s: &str) -> (String, String, String) {\n-    let mut after_header = false;\n+    #[derive(Copy, Clone, PartialEq)]\n+    enum PartitionState {\n+        Attrs,\n+        Crates,\n+        Other,\n+    }\n+    let mut state = PartitionState::Attrs;\n     let mut before = String::new();\n     let mut crates = String::new();\n     let mut after = String::new();\n \n     for line in s.lines() {\n         let trimline = line.trim();\n-        let header = trimline.chars().all(|c| c.is_whitespace()) ||\n-            trimline.starts_with(\"#![\") ||\n-            trimline.starts_with(\"#[macro_use] extern crate\") ||\n-            trimline.starts_with(\"extern crate\");\n-        if !header || after_header {\n-            after_header = true;\n-            after.push_str(line);\n-            after.push_str(\"\\n\");\n-        } else {\n-            if trimline.starts_with(\"#[macro_use] extern crate\")\n-                || trimline.starts_with(\"extern crate\") {\n+\n+        // FIXME(misdreavus): if a doc comment is placed on an extern crate statement, it will be\n+        // shunted into \"everything else\"\n+        match state {\n+            PartitionState::Attrs => {\n+                state = if trimline.starts_with(\"#![\") ||\n+                    trimline.chars().all(|c| c.is_whitespace()) ||\n+                    (trimline.starts_with(\"//\") && !trimline.starts_with(\"///\"))\n+                {\n+                    PartitionState::Attrs\n+                } else if trimline.starts_with(\"extern crate\") ||\n+                    trimline.starts_with(\"#[macro_use] extern crate\")\n+                {\n+                    PartitionState::Crates\n+                } else {\n+                    PartitionState::Other\n+                };\n+            }\n+            PartitionState::Crates => {\n+                state = if trimline.starts_with(\"extern crate\") ||\n+                    trimline.starts_with(\"#[macro_use] extern crate\") ||\n+                    trimline.chars().all(|c| c.is_whitespace()) ||\n+                    (trimline.starts_with(\"//\") && !trimline.starts_with(\"///\"))\n+                {\n+                    PartitionState::Crates\n+                } else {\n+                    PartitionState::Other\n+                };\n+            }\n+            PartitionState::Other => {}\n+        }\n+\n+        match state {\n+            PartitionState::Attrs => {\n+                before.push_str(line);\n+                before.push_str(\"\\n\");\n+            }\n+            PartitionState::Crates => {\n                 crates.push_str(line);\n                 crates.push_str(\"\\n\");\n             }\n-            before.push_str(line);\n-            before.push_str(\"\\n\");\n+            PartitionState::Other => {\n+                after.push_str(line);\n+                after.push_str(\"\\n\");\n+            }\n         }\n     }\n \n+    debug!(\"before:\\n{}\", before);\n+    debug!(\"crates:\\n{}\", crates);\n+    debug!(\"after:\\n{}\", after);\n+\n     (before, after, crates)\n }\n \n@@ -1035,8 +1077,8 @@ fn main() {\n assert_eq!(2+2, 4);\";\n         let expected =\n \"#![allow(unused)]\n-fn main() {\n //Ceci n'est pas une `fn main`\n+fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n         let output = make_test(input, None, false, &opts);\n@@ -1083,8 +1125,8 @@ assert_eq!(2+2, 4);\";\n \n         let expected =\n \"#![allow(unused)]\n-fn main() {\n // fn main\n+fn main() {\n assert_eq!(2+2, 4);\n }\".to_string();\n "}, {"sha": "9cee00b9c76d0a81387559b8b92168e04a00ab55", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -21,6 +21,7 @@ libc = { version = \"0.2.44\", default-features = false, features = ['rustc-dep-of\n compiler_builtins = { version = \"0.1.1\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n unwind = { path = \"../libunwind\" }\n+rustc-demangle = { version = \"0.1.10\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n rand = \"0.6.1\""}, {"sha": "d0dd4d4adcb9850a7d558d5453dc414ae1255c75", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -550,7 +550,8 @@ impl f32 {\n     #[inline]\n     #[rustc_deprecated(since = \"1.10.0\",\n                        reason = \"you probably meant `(self - other).abs()`: \\\n-                                 this operation is `(self - other).max(0.0)` (also \\\n+                                 this operation is `(self - other).max(0.0)` \\\n+                                 except that `abs_sub` also propagates NaNs (also \\\n                                  known as `fdimf` in C). If you truly need the positive \\\n                                  difference, consider using that expression or the C function \\\n                                  `fdimf`, depending on how you wish to handle NaN (please consider \\"}, {"sha": "9e627ec204291bf9afd2b64a612f578dc8a67d1e", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -491,7 +491,8 @@ impl f64 {\n     #[inline]\n     #[rustc_deprecated(since = \"1.10.0\",\n                        reason = \"you probably meant `(self - other).abs()`: \\\n-                                 this operation is `(self - other).max(0.0)` (also \\\n+                                 this operation is `(self - other).max(0.0)` \\\n+                                 except that `abs_sub` also propagates NaNs (also \\\n                                  known as `fdim` in C). If you truly need the positive \\\n                                  difference, consider using that expression or the C function \\\n                                  `fdim`, depending on how you wish to handle NaN (please consider \\"}, {"sha": "35ae4939249ea5a83ec1f7d76e9fabdd0fa42339", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1729,7 +1729,7 @@ pub fn read_link<P: AsRef<Path>>(path: P) -> io::Result<PathBuf> {\n /// limited to just these cases:\n ///\n /// * `path` does not exist.\n-/// * A component in path is not a directory.\n+/// * A non-final component in path is not a directory.\n ///\n /// # Examples\n ///"}, {"sha": "ead38f2112687144b85198b463c86a451779cb55", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -339,6 +339,7 @@ pub use core::{unreachable, unimplemented, write, writeln, try};\n extern crate alloc as alloc_crate;\n #[doc(masked)]\n extern crate libc;\n+extern crate rustc_demangle;\n \n // We always need an unwinder currently for backtraces\n #[doc(masked)]"}, {"sha": "05f30f2881a00e7d0ab35dcab1a71bdf65540739", "filename": "src/libstd/os/raw/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fraw%2Fmod.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -27,6 +27,10 @@\n           all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                          target_arch = \"arm\")),\n           all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+          all(target_os = \"freebsd\", any(target_arch = \"aarch64\",\n+                                         target_arch = \"arm\",\n+                                         target_arch = \"powerpc\",\n+                                         target_arch = \"powerpc64\")),\n           all(target_os = \"netbsd\", any(target_arch = \"aarch64\",\n                                         target_arch = \"arm\",\n                                         target_arch = \"powerpc\")),\n@@ -42,6 +46,10 @@\n               all(target_os = \"android\", any(target_arch = \"aarch64\",\n                                              target_arch = \"arm\")),\n               all(target_os = \"l4re\", target_arch = \"x86_64\"),\n+              all(target_os = \"freebsd\", any(target_arch = \"aarch64\",\n+                                             target_arch = \"arm\",\n+                                             target_arch = \"powerpc\",\n+                                             target_arch = \"powerpc64\")),\n               all(target_os = \"netbsd\", any(target_arch = \"aarch64\",\n                                             target_arch = \"arm\",\n                                             target_arch = \"powerpc\")),"}, {"sha": "e44113f76f40ed3b18665081889c366d99a16bc2", "filename": "src/libstd/sys_common/backtrace.rs", "status": "modified", "additions": 11, "deletions": 228, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Flibstd%2Fsys_common%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fbacktrace.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -14,11 +14,12 @@\n use env;\n use io::prelude::*;\n use io;\n+use path::{self, Path};\n+use ptr;\n+use rustc_demangle::demangle;\n use str;\n use sync::atomic::{self, Ordering};\n-use path::{self, Path};\n use sys::mutex::Mutex;\n-use ptr;\n \n pub use sys::backtrace::{\n     unwind_backtrace,\n@@ -191,7 +192,14 @@ fn output(w: &mut dyn Write, idx: usize, frame: Frame,\n         PrintFormat::Short => write!(w, \"  {:2}: \", idx)?,\n     }\n     match s {\n-        Some(string) => demangle(w, string, format)?,\n+        Some(string) => {\n+            let symbol = demangle(string);\n+            match format {\n+                PrintFormat::Full => write!(w, \"{}\", symbol)?,\n+                // strip the trailing hash if short mode\n+                PrintFormat::Short => write!(w, \"{:#}\", symbol)?,\n+            }\n+        }\n         None => w.write_all(b\"<unknown>\")?,\n     }\n     w.write_all(b\"\\n\")\n@@ -235,228 +243,3 @@ fn output_fileline(w: &mut dyn Write,\n     w.write_all(b\"\\n\")\n }\n \n-\n-// All rust symbols are in theory lists of \"::\"-separated identifiers. Some\n-// assemblers, however, can't handle these characters in symbol names. To get\n-// around this, we use C++-style mangling. The mangling method is:\n-//\n-// 1. Prefix the symbol with \"_ZN\"\n-// 2. For each element of the path, emit the length plus the element\n-// 3. End the path with \"E\"\n-//\n-// For example, \"_ZN4testE\" => \"test\" and \"_ZN3foo3barE\" => \"foo::bar\".\n-//\n-// We're the ones printing our backtraces, so we can't rely on anything else to\n-// demangle our symbols. It's *much* nicer to look at demangled symbols, so\n-// this function is implemented to give us nice pretty output.\n-//\n-// Note that this demangler isn't quite as fancy as it could be. We have lots\n-// of other information in our symbols like hashes, version, type information,\n-// etc. Additionally, this doesn't handle glue symbols at all.\n-pub fn demangle(writer: &mut dyn Write, mut s: &str, format: PrintFormat) -> io::Result<()> {\n-    // During ThinLTO LLVM may import and rename internal symbols, so strip out\n-    // those endings first as they're one of the last manglings applied to\n-    // symbol names.\n-    let llvm = \".llvm.\";\n-    if let Some(i) = s.find(llvm) {\n-        let candidate = &s[i + llvm.len()..];\n-        let all_hex = candidate.chars().all(|c| {\n-            match c {\n-                'A' ..= 'F' | '0' ..= '9' => true,\n-                _ => false,\n-            }\n-        });\n-\n-        if all_hex {\n-            s = &s[..i];\n-        }\n-    }\n-\n-    // Validate the symbol. If it doesn't look like anything we're\n-    // expecting, we just print it literally. Note that we must handle non-rust\n-    // symbols because we could have any function in the backtrace.\n-    let mut valid = true;\n-    let mut inner = s;\n-    if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n-        inner = &s[3 .. s.len() - 1];\n-    // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n-    } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n-        inner = &s[2 .. s.len() - 1];\n-    } else {\n-        valid = false;\n-    }\n-\n-    if valid {\n-        let mut chars = inner.chars();\n-        while valid {\n-            let mut i = 0;\n-            for c in chars.by_ref() {\n-                if c.is_numeric() {\n-                    i = i * 10 + c as usize - '0' as usize;\n-                } else {\n-                    break\n-                }\n-            }\n-            if i == 0 {\n-                valid = chars.next().is_none();\n-                break\n-            } else if chars.by_ref().take(i - 1).count() != i - 1 {\n-                valid = false;\n-            }\n-        }\n-    }\n-\n-    // Alright, let's do this.\n-    if !valid {\n-        writer.write_all(s.as_bytes())?;\n-    } else {\n-        // remove the `::hfc2edb670e5eda97` part at the end of the symbol.\n-        if format == PrintFormat::Short {\n-            // The symbol in still mangled.\n-            let mut split = inner.rsplitn(2, \"17h\");\n-            match (split.next(), split.next()) {\n-                (Some(addr), rest) => {\n-                    if addr.len() == 16 &&\n-                       addr.chars().all(|c| c.is_digit(16))\n-                    {\n-                        inner = rest.unwrap_or(\"\");\n-                    }\n-                }\n-                _ => (),\n-            }\n-        }\n-\n-        let mut first = true;\n-        while !inner.is_empty() {\n-            if !first {\n-                writer.write_all(b\"::\")?;\n-            } else {\n-                first = false;\n-            }\n-            let mut rest = inner;\n-            while rest.chars().next().unwrap().is_numeric() {\n-                rest = &rest[1..];\n-            }\n-            let i: usize = inner[.. (inner.len() - rest.len())].parse().unwrap();\n-            inner = &rest[i..];\n-            rest = &rest[..i];\n-            if rest.starts_with(\"_$\") {\n-                rest = &rest[1..];\n-            }\n-            while !rest.is_empty() {\n-                if rest.starts_with(\".\") {\n-                    if let Some('.') = rest[1..].chars().next() {\n-                        writer.write_all(b\"::\")?;\n-                        rest = &rest[2..];\n-                    } else {\n-                        writer.write_all(b\".\")?;\n-                        rest = &rest[1..];\n-                    }\n-                } else if rest.starts_with(\"$\") {\n-                    macro_rules! demangle {\n-                        ($($pat:expr => $demangled:expr),*) => ({\n-                            $(if rest.starts_with($pat) {\n-                                writer.write_all($demangled)?;\n-                                rest = &rest[$pat.len()..];\n-                              } else)*\n-                            {\n-                                writer.write_all(rest.as_bytes())?;\n-                                break;\n-                            }\n-\n-                        })\n-                    }\n-\n-                    // see src/librustc/back/link.rs for these mappings\n-                    demangle! (\n-                        \"$SP$\" => b\"@\",\n-                        \"$BP$\" => b\"*\",\n-                        \"$RF$\" => b\"&\",\n-                        \"$LT$\" => b\"<\",\n-                        \"$GT$\" => b\">\",\n-                        \"$LP$\" => b\"(\",\n-                        \"$RP$\" => b\")\",\n-                        \"$C$\" => b\",\",\n-\n-                        // in theory we can demangle any Unicode code point, but\n-                        // for simplicity we just catch the common ones.\n-                        \"$u7e$\" => b\"~\",\n-                        \"$u20$\" => b\" \",\n-                        \"$u27$\" => b\"'\",\n-                        \"$u5b$\" => b\"[\",\n-                        \"$u5d$\" => b\"]\",\n-                        \"$u7b$\" => b\"{\",\n-                        \"$u7d$\" => b\"}\",\n-                        \"$u3b$\" => b\";\",\n-                        \"$u2b$\" => b\"+\",\n-                        \"$u22$\" => b\"\\\"\"\n-                    )\n-                } else {\n-                    let idx = match rest.char_indices().find(|&(_, c)| c == '$' || c == '.') {\n-                        None => rest.len(),\n-                        Some((i, _)) => i,\n-                    };\n-                    writer.write_all(rest[..idx].as_bytes())?;\n-                    rest = &rest[idx..];\n-                }\n-            }\n-        }\n-    }\n-\n-    Ok(())\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use sys_common;\n-    macro_rules! t { ($a:expr, $b:expr) => ({\n-        let mut m = Vec::new();\n-        sys_common::backtrace::demangle(&mut m,\n-                                        $a,\n-                                        super::PrintFormat::Full).unwrap();\n-        assert_eq!(String::from_utf8(m).unwrap(), $b);\n-    }) }\n-\n-    #[test]\n-    fn demangle() {\n-        t!(\"test\", \"test\");\n-        t!(\"_ZN4testE\", \"test\");\n-        t!(\"_ZN4test\", \"_ZN4test\");\n-        t!(\"_ZN4test1a2bcE\", \"test::a::bc\");\n-    }\n-\n-    #[test]\n-    fn demangle_dollars() {\n-        t!(\"_ZN4$RP$E\", \")\");\n-        t!(\"_ZN8$RF$testE\", \"&test\");\n-        t!(\"_ZN8$BP$test4foobE\", \"*test::foob\");\n-        t!(\"_ZN9$u20$test4foobE\", \" test::foob\");\n-        t!(\"_ZN35Bar$LT$$u5b$u32$u3b$$u20$4$u5d$$GT$E\", \"Bar<[u32; 4]>\");\n-    }\n-\n-    #[test]\n-    fn demangle_many_dollars() {\n-        t!(\"_ZN13test$u20$test4foobE\", \"test test::foob\");\n-        t!(\"_ZN12test$BP$test4foobE\", \"test*test::foob\");\n-    }\n-\n-    #[test]\n-    fn demangle_windows() {\n-        t!(\"ZN4testE\", \"test\");\n-        t!(\"ZN13test$u20$test4foobE\", \"test test::foob\");\n-        t!(\"ZN12test$RF$test4foobE\", \"test&test::foob\");\n-    }\n-\n-    #[test]\n-    fn demangle_elements_beginning_with_underscore() {\n-        t!(\"_ZN13_$LT$test$GT$E\", \"<test>\");\n-        t!(\"_ZN28_$u7b$$u7b$closure$u7d$$u7d$E\", \"{{closure}}\");\n-        t!(\"_ZN15__STATIC_FMTSTRE\", \"__STATIC_FMTSTR\");\n-    }\n-\n-    #[test]\n-    fn demangle_trait_impls() {\n-        t!(\"_ZN71_$LT$Test$u20$$u2b$$u20$$u27$static$u20$as$u20$foo..Bar$LT$Test$GT$$GT$3barE\",\n-           \"<Test + 'static as foo::Bar<Test>>::bar\");\n-    }\n-}"}, {"sha": "95185c8c801c765ac1072392d081d265af9fb310", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1 +1 @@\n-Subproject commit a784eca10d2c1f09e65d67e16eca266485e1eac3\n+Subproject commit 95185c8c801c765ac1072392d081d265af9fb310"}, {"sha": "a268838de451550fe5518de5be28fbc00563be9c", "filename": "src/rustllvm/llvm-rebuild-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Frustllvm%2Fllvm-rebuild-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Frustllvm%2Fllvm-rebuild-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-rebuild-trigger?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be (optionally) cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2018-11-28\n+2018-12-13"}, {"sha": "3468bb7bda4730d833b7326d8f4aa0d570ca28a4", "filename": "src/test/rustdoc/comment-in-doctest.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Frustdoc%2Fcomment-in-doctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Frustdoc%2Fcomment-in-doctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fcomment-in-doctest.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:--test\n+\n+// comments, both doc comments and regular ones, used to trick rustdoc's doctest parser into\n+// thinking that everything after it was part of the regular program. combined with the libsyntax\n+// parser loop failing to detect the manual main function, it would wrap everything in `fn main`,\n+// which would cause the doctest to fail as the \"extern crate\" declaration was no longer valid.\n+// oddly enough, it would pass in 2018 if a crate was in the extern prelude. see\n+// https://github.com/rust-lang/rust/issues/56727\n+\n+//! ```\n+//! // crate: proc-macro-test\n+//! //! this is a test\n+//!\n+//! // used to pull in proc-macro specific items\n+//! extern crate proc_macro;\n+//!\n+//! use proc_macro::TokenStream;\n+//!\n+//! # fn main() {}\n+//! ```"}, {"sha": "6f72de0edee327be283d5389f05ea746f85fd5e7", "filename": "src/test/ui/borrowck/borrowck-anon-fields-variant.nll.stderr", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-anon-fields-variant.nll.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1,3 +1,31 @@\n+warning[E0503]: cannot use `y` because it was mutably borrowed\n+  --> $DIR/borrowck-anon-fields-variant.rs:27:7\n+   |\n+LL |       Foo::Y(ref mut a, _) => a,\n+   |              --------- borrow of `y.0` occurs here\n+...\n+LL |       Foo::Y(_, ref mut b) => b,\n+   |       ^^^^^^^^^^^^^^^^^^^^ use of borrowed `y.0`\n+...\n+LL |     *a += 1;\n+   |     ------- borrow later used here\n+   |\n+   = warning: This error has been downgraded to a warning for backwards compatibility with previous releases.\n+           It represents potential unsoundness in your code.\n+           This warning will become a hard error in the future.\n+\n+error[E0503]: cannot use `y` because it was mutably borrowed\n+  --> $DIR/borrowck-anon-fields-variant.rs:44:7\n+   |\n+LL |       Foo::Y(ref mut a, _) => a,\n+   |              --------- borrow of `y.0` occurs here\n+...\n+LL |       Foo::Y(ref mut b, _) => b, //~ ERROR cannot borrow\n+   |       ^^^^^^^^^^^^^^^^^^^^ use of borrowed `y.0`\n+...\n+LL |     *a += 1;\n+   |     ------- borrow later used here\n+\n error[E0499]: cannot borrow `y.0` as mutable more than once at a time\n   --> $DIR/borrowck-anon-fields-variant.rs:44:14\n    |\n@@ -10,6 +38,7 @@ LL |       Foo::Y(ref mut b, _) => b, //~ ERROR cannot borrow\n LL |     *a += 1;\n    |     ------- first borrow later used here\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0499`.\n+Some errors occurred: E0499, E0503.\n+For more information about an error, try `rustc --explain E0499`."}, {"sha": "92e99c6228a9b853e471dc5d3257146e3808e758", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -28,13 +28,13 @@ const fn call_unsafe_generic_cell_const_fn() -> *const Vec<std::cell::Cell<u32>>\n     unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n     //~^ ERROR calls to `const unsafe fn` in const fns\n }\n-const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x }\n //~^ dereferencing raw pointers in constant functions\n \n fn main() {}\n \n const unsafe fn no_union() {\n     union Foo { x: (), y: () }\n-    Foo { x: () }.y //~ ERROR not allowed in const fn\n+    Foo { x: () }.y\n     //~^ unions in const fn\n }"}, {"sha": "fafc89d1493685e1619b21729acec88de921ad7f", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.stderr", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1,15 +1,15 @@\n error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n   --> $DIR/min_const_fn_unsafe.rs:31:59\n    |\n-LL | const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+LL | const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x }\n    |                                                           ^^\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n error[E0658]: unions in const fn are unstable (see issue #51909)\n   --> $DIR/min_const_fn_unsafe.rs:38:5\n    |\n-LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n+LL |     Foo { x: () }.y\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(const_fn_union)] to the crate attributes to enable\n@@ -38,24 +38,6 @@ LL |     unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n    |\n    = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n \n-error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:31:59\n-   |\n-LL | const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n-   |                                                           ^^ dereference of raw pointer\n-   |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: access to union field is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:38:5\n-   |\n-LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n-   |     ^^^^^^^^^^^^^^^ access to union field\n-   |\n-   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: aborting due to 7 previous errors\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "67a48206126421f973e497d0c1ad2eae03dda04b", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_feature_gate.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -34,29 +34,28 @@ const unsafe fn foo9_3() -> *const String {\n const unsafe fn foo10_3() -> *const Vec<std::cell::Cell<u32>> {\n     unsafe { foo6::<Vec<std::cell::Cell<u32>>>() }\n }\n-// not ok\n const unsafe fn foo8_2() -> i32 {\n-    foo4() //~ ERROR not allowed in const fn\n+    foo4()\n }\n const unsafe fn foo9_2() -> *const String {\n-    foo5::<String>() //~ ERROR not allowed in const fn\n+    foo5::<String>()\n }\n const unsafe fn foo10_2() -> *const Vec<std::cell::Cell<u32>> {\n-    foo6::<Vec<std::cell::Cell<u32>>>() //~ ERROR not allowed in const fn\n+    foo6::<Vec<std::cell::Cell<u32>>>()\n }\n-const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+const unsafe fn foo30_3(x: *mut usize) -> usize { *x }\n //~^ dereferencing raw pointers in constant functions\n \n-const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x } //~ ERROR not allowed in const fn\n+const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x }\n //~^ dereferencing raw pointers in constant functions\n \n-const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ ERROR not allowed\n+const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n //~^ dereferencing raw pointers in constant functions\n \n fn main() {}\n \n const unsafe fn no_union() {\n     union Foo { x: (), y: () }\n-    Foo { x: () }.y //~ ERROR not allowed in const fn\n+    Foo { x: () }.y\n     //~^ unions in const fn\n }"}, {"sha": "63bf9a53e509cc7a908b2813d23c5d92b00bbdd8", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_feature_gate.stderr", "status": "modified", "additions": 14, "deletions": 67, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1,97 +1,44 @@\n error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:47:51\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:46:51\n    |\n-LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x }\n    |                                                   ^^\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:50:60\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:49:60\n    |\n-LL | const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x } //~ ERROR not allowed in const fn\n+LL | const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x }\n    |                                                            ^^^\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:53:62\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:52:62\n    |\n-LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ ERROR not allowed\n+LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n    |                                                              ^^^\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n error[E0658]: unions in const fn are unstable (see issue #51909)\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:60:5\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:59:5\n    |\n-LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n+LL |     Foo { x: () }.y\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(const_fn_union)] to the crate attributes to enable\n \n-error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:39:5\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:52:62\n    |\n-LL |     foo4() //~ ERROR not allowed in const fn\n-   |     ^^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:42:5\n-   |\n-LL |     foo5::<String>() //~ ERROR not allowed in const fn\n-   |     ^^^^^^^^^^^^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:45:5\n-   |\n-LL |     foo6::<Vec<std::cell::Cell<u32>>>() //~ ERROR not allowed in const fn\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n-   |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:47:51\n-   |\n-LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n-   |                                                   ^^ dereference of raw pointer\n-   |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:50:60\n-   |\n-LL | const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x } //~ ERROR not allowed in const fn\n-   |                                                            ^^^ dereference of raw pointer\n-   |\n-   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:53:62\n-   |\n-LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ ERROR not allowed\n+LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ is unsafe\n    |                                                              ^^^ dereference of raw pointer\n    |\n    = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n-error: access to union field is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe_feature_gate.rs:60:5\n-   |\n-LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n-   |     ^^^^^^^^^^^^^^^ access to union field\n-   |\n-   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n-\n-error: aborting due to 11 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors occurred: E0133, E0658.\n+For more information about an error, try `rustc --explain E0133`."}, {"sha": "83d4e31b5d1260736ac762e5cad997a7e7044deb", "filename": "src/test/ui/issues/issue-56199.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56199.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56199.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56199.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,23 @@\n+\n+enum Foo {}\n+struct Bar {}\n+\n+impl Foo {\n+    fn foo() {\n+        let _ = Self;\n+        //~^ ERROR the `Self` constructor can only be used with tuple or unit structs\n+        let _ = Self();\n+        //~^ ERROR the `Self` constructor can only be used with tuple or unit structs\n+    }\n+}\n+\n+impl Bar {\n+    fn bar() {\n+        let _ = Self;\n+        //~^ ERROR the `Self` constructor can only be used with tuple or unit structs\n+        let _ = Self();\n+        //~^ ERROR the `Self` constructor can only be used with tuple or unit structs\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "6e3c7fd17b4371c04693c66153682d3a367b7d89", "filename": "src/test/ui/issues/issue-56199.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56199.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,30 @@\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-56199.rs:7:17\n+   |\n+LL |         let _ = Self;\n+   |                 ^^^^\n+   |\n+   = note: did you mean to use one of the enum's variants?\n+\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-56199.rs:9:17\n+   |\n+LL |         let _ = Self();\n+   |                 ^^^^\n+   |\n+   = note: did you mean to use one of the enum's variants?\n+\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-56199.rs:16:17\n+   |\n+LL |         let _ = Self;\n+   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-56199.rs:18:17\n+   |\n+LL |         let _ = Self();\n+   |                 ^^^^ did you mean `Self { /* fields */ }`?\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c16550e370179de3eac37cde3d98b72fd1ba2e37", "filename": "src/test/ui/issues/issue-56835.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56835.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56835.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56835.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,10 @@\n+\n+pub struct Foo {}\n+\n+impl Foo {\n+    fn bar(Self(foo): Self) {}\n+    //~^ ERROR the `Self` constructor can only be used with tuple or unit structs\n+    //~^^ ERROR expected tuple struct/variant, found self constructor `Self` [E0164]\n+}\n+\n+fn main() {}"}, {"sha": "b7c3b142ec4524199871731915fd39b6a149cf50", "filename": "src/test/ui/issues/issue-56835.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56835.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fissues%2Fissue-56835.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-56835.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,15 @@\n+error: the `Self` constructor can only be used with tuple or unit structs\n+  --> $DIR/issue-56835.rs:5:12\n+   |\n+LL |     fn bar(Self(foo): Self) {}\n+   |            ^^^^^^^^^ did you mean `Self { /* fields */ }`?\n+\n+error[E0164]: expected tuple struct/variant, found self constructor `Self`\n+  --> $DIR/issue-56835.rs:5:12\n+   |\n+LL |     fn bar(Self(foo): Self) {}\n+   |            ^^^^^^^^^ not a tuple variant or struct\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0164`."}, {"sha": "6b9e1dc70573ee58ffe0887bbaa6e0db04602ee8", "filename": "src/test/ui/lint/issue-47390-unused-variable-in-struct-pattern.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-47390-unused-variable-in-struct-pattern.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -55,6 +55,7 @@ note: lint level defined here\n LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n    |         ^^^^^^\n    = note: #[warn(unused_assignments)] implied by #[warn(unused)]\n+   = help: maybe it is overwritten before being read?\n \n warning: unused variable: `fire`\n   --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:54:32"}, {"sha": "6e43cccdccff230b5b9916021bb0958e0e607d41", "filename": "src/test/ui/liveness/liveness-dead.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fliveness%2Fliveness-dead.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fliveness%2Fliveness-dead.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-dead.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -9,24 +9,31 @@ note: lint level defined here\n    |\n LL | #![deny(unused_assignments)]\n    |         ^^^^^^^^^^^^^^^^^^\n+   = help: maybe it is overwritten before being read?\n \n error: value assigned to `x` is never read\n   --> $DIR/liveness-dead.rs:27:5\n    |\n LL |     x = 4; //~ ERROR: value assigned to `x` is never read\n    |     ^\n+   |\n+   = help: maybe it is overwritten before being read?\n \n error: value passed to `x` is never read\n   --> $DIR/liveness-dead.rs:30:11\n    |\n LL | fn f4(mut x: i32) { //~ ERROR: value passed to `x` is never read\n    |           ^\n+   |\n+   = help: maybe it is overwritten before being read?\n \n error: value assigned to `x` is never read\n   --> $DIR/liveness-dead.rs:37:5\n    |\n LL |     x = 4; //~ ERROR: value assigned to `x` is never read\n    |     ^\n+   |\n+   = help: maybe it is overwritten before being read?\n \n error: aborting due to 4 previous errors\n "}, {"sha": "35ccc79a19ac094f3210762d67dcc006daa2e8a6", "filename": "src/test/ui/liveness/liveness-unused.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fliveness%2Fliveness-unused.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fliveness%2Fliveness-unused.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-unused.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -60,6 +60,7 @@ note: lint level defined here\n    |\n LL | #![deny(unused_assignments)]\n    |         ^^^^^^^^^^^^^^^^^^\n+   = help: maybe it is overwritten before being read?\n \n error: variable `z` is assigned to, but never used\n   --> $DIR/liveness-unused.rs:47:13\n@@ -106,6 +107,8 @@ error: value assigned to `x` is never read\n    |\n LL |         x = 0;  //~ ERROR value assigned to `x` is never read\n    |         ^\n+   |\n+   = help: maybe it is overwritten before being read?\n \n error: aborting due to 13 previous errors\n "}, {"sha": "edce2b185df34bdcd3372e1845953e7d49ddaf96", "filename": "src/test/ui/nll/match-on-borrowed.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -46,9 +46,9 @@ fn enum_example(mut e: E) {\n         E::V(ref mut x, _) => x,\n         E::W => panic!(),\n     };\n-    match e { // OK, no access of borrowed data\n+    match e { // Don't know that E uses a tag for its discriminant\n         _ if false => (),\n-        E::V(_, r) => (),\n+        E::V(_, r) => (), //~ ERROR\n         E::W => (),\n     }\n     x;\n@@ -59,9 +59,9 @@ fn indirect_enum_example(mut f: &mut E) {\n         E::V(ref mut x, _) => x,\n         E::W => panic!(),\n     };\n-    match f { // OK, no access of borrowed data\n+    match f { // Don't know that E uses a tag for its discriminant\n         _ if false => (),\n-        E::V(_, r) => (),\n+        E::V(_, r) => (), //~ ERROR\n         E::W => (),\n     }\n     x;"}, {"sha": "2d34dd7805dbf5337f08b3d3a5d00937d117363a", "filename": "src/test/ui/nll/match-on-borrowed.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmatch-on-borrowed.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -1,3 +1,27 @@\n+error[E0503]: cannot use `e` because it was mutably borrowed\n+  --> $DIR/match-on-borrowed.rs:51:9\n+   |\n+LL |         E::V(ref mut x, _) => x,\n+   |              --------- borrow of `e.0` occurs here\n+...\n+LL |         E::V(_, r) => (), //~ ERROR\n+   |         ^^^^^^^^^^ use of borrowed `e.0`\n+...\n+LL |     x;\n+   |     - borrow later used here\n+\n+error[E0503]: cannot use `*f` because it was mutably borrowed\n+  --> $DIR/match-on-borrowed.rs:64:9\n+   |\n+LL |         E::V(ref mut x, _) => x,\n+   |              --------- borrow of `f.0` occurs here\n+...\n+LL |         E::V(_, r) => (), //~ ERROR\n+   |         ^^^^^^^^^^ use of borrowed `f.0`\n+...\n+LL |     x;\n+   |     - borrow later used here\n+\n error[E0503]: cannot use `t` because it was mutably borrowed\n   --> $DIR/match-on-borrowed.rs:82:9\n    |\n@@ -16,7 +40,7 @@ error[E0381]: use of possibly uninitialized variable: `n`\n LL |     match n {} //~ ERROR\n    |           ^ use of possibly uninitialized `n`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors occurred: E0381, E0503.\n For more information about an error, try `rustc --explain E0381`."}, {"sha": "31ec8a7dc1c83a8a227f7cfa69f7993ebe101510", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-select.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -54,8 +54,14 @@ fn main() {\n         simd_select(z, z, z);\n         //~^ ERROR mask element type is `f32`, expected `i_`\n \n+        simd_select(m4, 0u32, 1u32);\n+        //~^ ERROR found non-SIMD `u32`\n+\n         simd_select_bitmask(0u8, x, x);\n         //~^ ERROR mask length `8` != other vector length `4`\n+        //\n+        simd_select_bitmask(0u8, 1u32, 2u32);\n+        //~^ ERROR found non-SIMD `u32`\n \n         simd_select_bitmask(0.0f32, x, x);\n         //~^ ERROR `f32` is not an integral type"}, {"sha": "05317da2475f1298f488d6828c5632538222de39", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-select.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-select.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -16,24 +16,36 @@ error[E0511]: invalid monomorphization of `simd_select` intrinsic: mask element\n LL |         simd_select(z, z, z);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n+error[E0511]: invalid monomorphization of `simd_select` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n   --> $DIR/simd-intrinsic-generic-select.rs:57:9\n    |\n+LL |         simd_select(m4, 0u32, 1u32);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: mismatched lengths: mask length `8` != other vector length `4`\n+  --> $DIR/simd-intrinsic-generic-select.rs:60:9\n+   |\n LL |         simd_select_bitmask(0u8, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: expected SIMD argument type, found non-SIMD `u32`\n+  --> $DIR/simd-intrinsic-generic-select.rs:63:9\n+   |\n+LL |         simd_select_bitmask(0u8, 1u32, 2u32);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `f32` is not an integral type\n-  --> $DIR/simd-intrinsic-generic-select.rs:60:9\n+  --> $DIR/simd-intrinsic-generic-select.rs:66:9\n    |\n LL |         simd_select_bitmask(0.0f32, x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_select_bitmask` intrinsic: `&str` is not an integral type\n-  --> $DIR/simd-intrinsic-generic-select.rs:63:9\n+  --> $DIR/simd-intrinsic-generic-select.rs:69:9\n    |\n LL |         simd_select_bitmask(\"x\", x, x);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0511`."}, {"sha": "62fc9e79f7aa23537de36ec3ec1be43bb973f4ca", "filename": "src/test/ui/suggestions/path-display.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,7 @@\n+use std::path::Path;\n+\n+fn main() {\n+    let path = Path::new(\"/tmp/foo/bar.txt\");\n+    println!(\"{}\", path);\n+    //~^ ERROR E0277\n+}"}, {"sha": "39d236af4f3ae8822b50b6457c09ab883e56776d", "filename": "src/test/ui/suggestions/path-display.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fpath-display.stderr?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: `std::path::Path` doesn't implement `std::fmt::Display`\n+  --> $DIR/path-display.rs:5:20\n+   |\n+LL |     println!(\"{}\", path);\n+   |                    ^^^^ `std::path::Path` cannot be formatted with the default formatter; call `.display()` on it\n+   |\n+   = help: the trait `std::fmt::Display` is not implemented for `std::path::Path`\n+   = note: call `.display()` or `.to_string_lossy()` to safely print paths, as they may contain non-Unicode data\n+   = note: required because of the requirements on the impl of `std::fmt::Display` for `&std::path::Path`\n+   = note: required by `std::fmt::Display::fmt`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "d1e4387166ca663a30d0566ac58449d37a07e678", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=a8a2a887d0a65fff6c777f9bcd7b1c0bdfbbddc0", "patch": "@@ -79,6 +79,7 @@ const WHITELIST: &[Crate] = &[\n     Crate(\"chalk-macros\"),\n     Crate(\"cloudabi\"),\n     Crate(\"cmake\"),\n+    Crate(\"compiler_builtins\"),\n     Crate(\"crc\"),\n     Crate(\"crc32fast\"),\n     Crate(\"crossbeam-deque\"),"}]}