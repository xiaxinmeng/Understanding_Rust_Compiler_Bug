{"sha": "7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "node_id": "C_kwDOAAsO6NoAKDdmMmFjMjllMjhhZTZmYjQ3MWY2NjIyNWMwNDVhMzMyZTQzYWExZjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-01T07:07:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-01T07:07:23Z"}, "message": "Auto merge of #14938 - Veykril:sig-help, r=Veykril\n\nAdd signature help for tuple patterns and expressions\n\n~~These are somewhat wonky since their signature changes as you type depending on context but they help out nevertheless.~~ should be less wonky now with added parser and lowering recoveries", "tree": {"sha": "641563b9321e64cca1302628866b72ceaa942cb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/641563b9321e64cca1302628866b72ceaa942cb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "html_url": "https://github.com/rust-lang/rust/commit/7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bafa6c4ee5d3acdbb62ec289364564270357c6a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bafa6c4ee5d3acdbb62ec289364564270357c6a2", "html_url": "https://github.com/rust-lang/rust/commit/bafa6c4ee5d3acdbb62ec289364564270357c6a2"}, {"sha": "0e2820283261183972b016d86a92144a3f8472e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2820283261183972b016d86a92144a3f8472e5", "html_url": "https://github.com/rust-lang/rust/commit/0e2820283261183972b016d86a92144a3f8472e5"}], "stats": {"total": 552, "additions": 518, "deletions": 34}, "files": [{"sha": "ebe05afca6a81fd31ab23123567a42fb595329ce", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -542,9 +542,18 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n-                let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                let mut exprs: Vec<_> = e.fields().map(|expr| self.collect_expr(expr)).collect();\n+                // if there is a leading comma, the user is most likely to type out a leading expression\n+                // so we insert a missing expression at the beginning for IDE features\n+                if comma_follows_token(e.l_paren_token()) {\n+                    exprs.insert(0, self.missing_expr());\n+                }\n+\n                 self.alloc_expr(\n-                    Expr::Tuple { exprs, is_assignee_expr: self.is_lowering_assignee_expr },\n+                    Expr::Tuple {\n+                        exprs: exprs.into_boxed_slice(),\n+                        is_assignee_expr: self.is_lowering_assignee_expr,\n+                    },\n                     syntax_ptr,\n                 )\n             }\n@@ -1180,7 +1189,11 @@ impl ExprCollector<'_> {\n             ast::Pat::TupleStructPat(p) => {\n                 let path =\n                     p.path().and_then(|path| self.expander.parse_path(self.db, path)).map(Box::new);\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n+                let (args, ellipsis) = self.collect_tuple_pat(\n+                    p.fields(),\n+                    comma_follows_token(p.l_paren_token()),\n+                    binding_list,\n+                );\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n@@ -1199,7 +1212,11 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n+                let (args, ellipsis) = self.collect_tuple_pat(\n+                    p.fields(),\n+                    comma_follows_token(p.l_paren_token()),\n+                    binding_list,\n+                );\n                 Pat::Tuple { args, ellipsis }\n             }\n             ast::Pat::WildcardPat(_) => Pat::Wild,\n@@ -1323,18 +1340,24 @@ impl ExprCollector<'_> {\n     fn collect_tuple_pat(\n         &mut self,\n         args: AstChildren<ast::Pat>,\n+        has_leading_comma: bool,\n         binding_list: &mut BindingList,\n     ) -> (Box<[PatId]>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possibility of there being multiple `..` here.\n         let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n-        let args = args\n+        let mut args: Vec<_> = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n             .map(|p| self.collect_pat(p, binding_list))\n             .collect();\n+        // if there is a leading comma, the user is most likely to type out a leading pattern\n+        // so we insert a missing pattern at the beginning for IDE features\n+        if has_leading_comma {\n+            args.insert(0, self.missing_pat());\n+        }\n \n-        (args, ellipsis)\n+        (args.into_boxed_slice(), ellipsis)\n     }\n \n     // endregion: patterns\n@@ -1493,3 +1516,8 @@ impl ExprCollector<'_> {\n         self.body.labels.alloc(label)\n     }\n }\n+\n+fn comma_follows_token(t: Option<syntax::SyntaxToken>) -> bool {\n+    (|| syntax::algo::skip_trivia_token(t?.next_token()?, syntax::Direction::Next))()\n+        .map_or(false, |it| it.kind() == syntax::T![,])\n+}"}, {"sha": "7795be54e264c6ca24015c89d2110335c996a6c9", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 408, "deletions": 28, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -15,8 +15,9 @@ use ide_db::{\n use stdx::format_to;\n use syntax::{\n     algo,\n-    ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxElementChildren, SyntaxToken, TextRange, TextSize,\n+    ast::{self, AstChildren, HasArgList},\n+    match_ast, AstNode, Direction, NodeOrToken, SyntaxElementChildren, SyntaxNode, SyntaxToken,\n+    TextRange, TextSize, T,\n };\n \n use crate::RootDatabase;\n@@ -116,6 +117,20 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_tuple_struct_pat(&sema, tuple_pat, token);\n                 },\n+                ast::TuplePat(tuple_pat) => {\n+                    let cursor_outside = tuple_pat.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_pat(&sema, tuple_pat, token);\n+                },\n+                ast::TupleExpr(tuple_expr) => {\n+                    let cursor_outside = tuple_expr.r_paren_token().as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_tuple_expr(&sema, tuple_expr, token);\n+                },\n                 _ => (),\n             }\n         }\n@@ -395,19 +410,16 @@ fn signature_help_for_tuple_struct_pat(\n     pat: ast::TupleStructPat,\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n-    let rest_pat = pat.fields().find(|it| matches!(it, ast::Pat::RestPat(_)));\n-    let is_left_of_rest_pat =\n-        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n-\n+    let path = pat.path()?;\n+    let path_res = sema.resolve_path(&path)?;\n     let mut res = SignatureHelp {\n         doc: None,\n         signature: String::new(),\n         parameters: vec![],\n         active_parameter: None,\n     };\n-\n     let db = sema.db;\n-    let path_res = sema.resolve_path(&pat.path()?)?;\n+\n     let fields: Vec<_> = if let PathResolution::Def(ModuleDef::Variant(variant)) = path_res {\n         let en = variant.parent_enum(db);\n \n@@ -435,30 +447,72 @@ fn signature_help_for_tuple_struct_pat(\n             _ => return None,\n         }\n     };\n-    let commas = pat\n-        .syntax()\n-        .children_with_tokens()\n-        .filter_map(syntax::NodeOrToken::into_token)\n-        .filter(|t| t.kind() == syntax::T![,]);\n-    res.active_parameter = Some(if is_left_of_rest_pat {\n-        commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n-    } else {\n-        let n_commas = commas\n-            .collect::<Vec<_>>()\n-            .into_iter()\n-            .rev()\n-            .take_while(|t| t.text_range().start() > token.text_range().start())\n-            .count();\n-        fields.len().saturating_sub(1).saturating_sub(n_commas)\n-    });\n+    Some(signature_help_for_tuple_pat_ish(\n+        db,\n+        res,\n+        pat.syntax(),\n+        token,\n+        pat.fields(),\n+        fields.into_iter().map(|it| it.ty(db)),\n+    ))\n+}\n+\n+fn signature_help_for_tuple_pat(\n+    sema: &Semantics<'_, RootDatabase>,\n+    pat: ast::TuplePat,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let db = sema.db;\n+    let field_pats = pat.fields();\n+    let pat = pat.into();\n+    let ty = sema.type_of_pat(&pat)?;\n+    let fields = ty.original.tuple_fields(db);\n+\n+    Some(signature_help_for_tuple_pat_ish(\n+        db,\n+        SignatureHelp {\n+            doc: None,\n+            signature: String::from('('),\n+            parameters: vec![],\n+            active_parameter: None,\n+        },\n+        pat.syntax(),\n+        token,\n+        field_pats,\n+        fields.into_iter(),\n+    ))\n+}\n \n+fn signature_help_for_tuple_expr(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expr: ast::TupleExpr,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let active_parameter = Some(\n+        expr.syntax()\n+            .children_with_tokens()\n+            .filter_map(NodeOrToken::into_token)\n+            .filter(|t| t.kind() == T![,])\n+            .take_while(|t| t.text_range().start() <= token.text_range().start())\n+            .count(),\n+    );\n+\n+    let db = sema.db;\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::from('('),\n+        parameters: vec![],\n+        active_parameter,\n+    };\n+    let expr = sema.type_of_expr(&expr.into())?;\n+    let fields = expr.original.tuple_fields(db);\n     let mut buf = String::new();\n-    for ty in fields.into_iter().map(|it| it.ty(db)) {\n+    for ty in fields {\n         format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n         res.push_call_param(&buf);\n         buf.clear();\n     }\n-    res.signature.push_str(\")\");\n+    res.signature.push(')');\n     Some(res)\n }\n \n@@ -470,8 +524,8 @@ fn signature_help_for_record_(\n     token: SyntaxToken,\n ) -> Option<SignatureHelp> {\n     let active_parameter = field_list_children\n-        .filter_map(syntax::NodeOrToken::into_token)\n-        .filter(|t| t.kind() == syntax::T![,])\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,])\n         .take_while(|t| t.text_range().start() <= token.text_range().start())\n         .count();\n \n@@ -542,6 +596,46 @@ fn signature_help_for_record_(\n     Some(res)\n }\n \n+fn signature_help_for_tuple_pat_ish(\n+    db: &RootDatabase,\n+    mut res: SignatureHelp,\n+    pat: &SyntaxNode,\n+    token: SyntaxToken,\n+    mut field_pats: AstChildren<ast::Pat>,\n+    fields: impl ExactSizeIterator<Item = hir::Type>,\n+) -> SignatureHelp {\n+    let rest_pat = field_pats.find(|it| matches!(it, ast::Pat::RestPat(_)));\n+    let is_left_of_rest_pat =\n+        rest_pat.map_or(true, |it| token.text_range().start() < it.syntax().text_range().end());\n+\n+    let commas = pat\n+        .children_with_tokens()\n+        .filter_map(NodeOrToken::into_token)\n+        .filter(|t| t.kind() == T![,]);\n+\n+    res.active_parameter = {\n+        Some(if is_left_of_rest_pat {\n+            commas.take_while(|t| t.text_range().start() <= token.text_range().start()).count()\n+        } else {\n+            let n_commas = commas\n+                .collect::<Vec<_>>()\n+                .into_iter()\n+                .rev()\n+                .take_while(|t| t.text_range().start() > token.text_range().start())\n+                .count();\n+            fields.len().saturating_sub(1).saturating_sub(n_commas)\n+        })\n+    };\n+\n+    let mut buf = String::new();\n+    for ty in fields {\n+        format_to!(buf, \"{}\", ty.display_truncated(db, Some(20)));\n+        res.push_call_param(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\")\");\n+    res\n+}\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -1851,4 +1945,290 @@ fn main() {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_tuple_expr_free() {\n+        check(\n+            r#\"\n+fn main() {\n+    (0$0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    ($0 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    (1, 3 $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    (1, 3 $0,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_expr_expected() {\n+        check(\n+            r#\"\n+fn main() {\n+    let _: (&str, u32, u32)= ($0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (&str, u32, u32)\n+                 ^^^^  ---  ---\n+            \"#]],\n+        );\n+        // FIXME: Should typeck report a 4-ary tuple for the expression here?\n+        check(\n+            r#\"\n+fn main() {\n+    let _: (&str, u32, u32, u32) = ($0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (&str, u32, u32)\n+                 ^^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let _: (&str, u32, u32)= ($0, 1, 3, 5);\n+}\n+\"#,\n+            expect![[r#\"\n+                (&str, u32, u32, i32)\n+                 ^^^^  ---  ---  ---\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_pat_free() {\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                ({unknown}, i32, i32)\n+                 ^^^^^^^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (0$0, 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0 1, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0, ..);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3, .., $0);\n+}\n+\"#,\n+            // FIXME: This is wrong, this should not mark the last as active\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tuple_pat_expected() {\n+        check(\n+            r#\"\n+fn main() {\n+    let (0$0, 1, 3): (i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0, 1, 3): (i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0): (i32,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0, ..): (i32, i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32, i32)\n+                 ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3, .., $0): (i32, i32, i32);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ---  ---  ^^^\n+            \"#]],\n+        );\n+    }\n+    #[test]\n+    fn test_tuple_pat_expected_inferred() {\n+        check(\n+            r#\"\n+fn main() {\n+    let (0$0, 1, 3) = (1, 2 ,3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let ($0 1, 3) = (1, 2, 3);\n+}\n+\"#,\n+            // FIXME: Should typeck report a 3-ary tuple for the pattern here?\n+            expect![[r#\"\n+                (i32, i32)\n+                 ^^^  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0) = (1,);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32)\n+                 ---  ^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3 $0, ..) = (1, 2, 3, 4);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32, i32)\n+                 ---  ^^^  ---  ---\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+fn main() {\n+    let (1, 3, .., $0) = (1, 2, 3);\n+}\n+\"#,\n+            expect![[r#\"\n+                (i32, i32, i32)\n+                 ---  ---  ^^^\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "d8553d3f953772ea277ec9f605bcc76d821ca0c5", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -184,6 +184,16 @@ fn tuple_expr(p: &mut Parser<'_>) -> CompletedMarker {\n \n     let mut saw_comma = false;\n     let mut saw_expr = false;\n+\n+    // test_err tuple_expr_leading_comma\n+    // fn foo() {\n+    //     (,);\n+    // }\n+    if p.eat(T![,]) {\n+        p.error(\"expected expression\");\n+        saw_comma = true;\n+    }\n+\n     while !p.at(EOF) && !p.at(T![')']) {\n         saw_expr = true;\n "}, {"sha": "39ded41bb24133e82fcfec038f8f41211d47d081", "filename": "crates/parser/src/grammar/patterns.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -413,6 +413,16 @@ fn tuple_pat(p: &mut Parser<'_>) -> CompletedMarker {\n     let mut has_comma = false;\n     let mut has_pat = false;\n     let mut has_rest = false;\n+\n+    // test_err tuple_pat_leading_comma\n+    // fn foo() {\n+    //     let (,);\n+    // }\n+    if p.eat(T![,]) {\n+        p.error(\"expected pattern\");\n+        has_comma = true;\n+    }\n+\n     while !p.at(EOF) && !p.at(T![')']) {\n         has_pat = true;\n         if !p.at_ts(PAT_TOP_FIRST) {"}, {"sha": "3fbc0da4002e4c7b1eee150794bf032c6487acbc", "filename": "crates/parser/test_data/parser/inline/err/0019_tuple_expr_leading_comma.rast", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0019_tuple_expr_leading_comma.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0019_tuple_expr_leading_comma.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0019_tuple_expr_leading_comma.rast?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -0,0 +1,24 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"foo\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        EXPR_STMT\n+          TUPLE_EXPR\n+            L_PAREN \"(\"\n+            COMMA \",\"\n+            R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+  WHITESPACE \"\\n\"\n+error 17: expected expression"}, {"sha": "12fab59a77656e8ae3d6d3b49a2793d941cd8210", "filename": "crates/parser/test_data/parser/inline/err/0019_tuple_expr_leading_comma.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0019_tuple_expr_leading_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0019_tuple_expr_leading_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0019_tuple_expr_leading_comma.rs?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -0,0 +1,3 @@\n+fn foo() {\n+    (,);\n+}"}, {"sha": "9c8837292d2890cf038a904bffbcce8d7e1398ef", "filename": "crates/parser/test_data/parser/inline/err/0020_tuple_pat_leading_comma.rast", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0020_tuple_pat_leading_comma.rast", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0020_tuple_pat_leading_comma.rast", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0020_tuple_pat_leading_comma.rast?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -0,0 +1,26 @@\n+SOURCE_FILE\n+  FN\n+    FN_KW \"fn\"\n+    WHITESPACE \" \"\n+    NAME\n+      IDENT \"foo\"\n+    PARAM_LIST\n+      L_PAREN \"(\"\n+      R_PAREN \")\"\n+    WHITESPACE \" \"\n+    BLOCK_EXPR\n+      STMT_LIST\n+        L_CURLY \"{\"\n+        WHITESPACE \"\\n    \"\n+        LET_STMT\n+          LET_KW \"let\"\n+          WHITESPACE \" \"\n+          TUPLE_PAT\n+            L_PAREN \"(\"\n+            COMMA \",\"\n+            R_PAREN \")\"\n+          SEMICOLON \";\"\n+        WHITESPACE \"\\n\"\n+        R_CURLY \"}\"\n+  WHITESPACE \"\\n\"\n+error 21: expected pattern"}, {"sha": "de168521e1d3f74a95c34ce92e984ecb015d458e", "filename": "crates/parser/test_data/parser/inline/err/0020_tuple_pat_leading_comma.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0020_tuple_pat_leading_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f2ac29e28ae6fb471f66225c045a332e43aa1f1/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0020_tuple_pat_leading_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Ftest_data%2Fparser%2Finline%2Ferr%2F0020_tuple_pat_leading_comma.rs?ref=7f2ac29e28ae6fb471f66225c045a332e43aa1f1", "patch": "@@ -0,0 +1,3 @@\n+fn foo() {\n+    let (,);\n+}"}]}