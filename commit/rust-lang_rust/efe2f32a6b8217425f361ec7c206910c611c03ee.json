{"sha": "efe2f32a6b8217425f361ec7c206910c611c03ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZTJmMzJhNmI4MjE3NDI1ZjM2MWVjN2MyMDY5MTBjNjExYzAzZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-17T10:03:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-17T10:03:02Z"}, "message": "Auto merge of #60030 - Centril:rollup-3d0t24t, r=Centril\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #59128 (Emit ansi color codes in the `rendered` field of json diagnostics)\n - #59646 (const fn: Improve wording)\n - #59986 (Miri: refactor new allocation tagging)\n - #60003 (LLD is not supported on Darwin)\n - #60018 (Miri now supports entropy, but is still slow)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8976b59372367993066cd5d3bdd70f8b50e7aa81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8976b59372367993066cd5d3bdd70f8b50e7aa81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efe2f32a6b8217425f361ec7c206910c611c03ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efe2f32a6b8217425f361ec7c206910c611c03ee", "html_url": "https://github.com/rust-lang/rust/commit/efe2f32a6b8217425f361ec7c206910c611c03ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efe2f32a6b8217425f361ec7c206910c611c03ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4e032a0ae82d7db4f99872ff98626af2941c4a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e032a0ae82d7db4f99872ff98626af2941c4a5", "html_url": "https://github.com/rust-lang/rust/commit/e4e032a0ae82d7db4f99872ff98626af2941c4a5"}, {"sha": "eb958e1b2e498f4751ac7c36cb2aeb4ce2ab68a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb958e1b2e498f4751ac7c36cb2aeb4ce2ab68a0", "html_url": "https://github.com/rust-lang/rust/commit/eb958e1b2e498f4751ac7c36cb2aeb4ce2ab68a0"}], "stats": {"total": 870, "additions": 444, "deletions": 426}, "files": [{"sha": "96aed7293450c7f531744d678ca36d3712b805fe", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -156,8 +156,10 @@ impl Step for Llvm {\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n         if builder.config.llvm_thin_lto && !emscripten {\n-            cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\")\n-               .define(\"LLVM_ENABLE_LLD\", \"ON\");\n+            cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n+            if !target.contains(\"apple\") {\n+               cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n+            }\n         }\n \n         // By default, LLVM will automatically find OCaml and, if it finds it,"}, {"sha": "0685fa943c0b87a78c4312cb4e8cee7789b0776c", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -282,7 +282,7 @@ fn assert_covariance() {\n //\n // Destructors must be called exactly once per element.\n #[test]\n-#[cfg(not(miri))] // Miri does not support panics nor entropy\n+#[cfg(not(miri))] // Miri does not support catching panics\n fn panic_safe() {\n     static DROP_COUNTER: AtomicUsize = AtomicUsize::new(0);\n "}, {"sha": "ad2cd7c95eb8fc381acb684cb3b0ae62d228b37c", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -389,7 +389,7 @@ fn test_reverse() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support entropy\n+#[cfg(not(miri))] // Miri is too slow\n fn test_sort() {\n     let mut rng = thread_rng();\n \n@@ -466,10 +466,19 @@ fn test_sort() {\n }\n \n #[test]\n-#[cfg(not(miri))] // Miri does not support entropy\n fn test_sort_stability() {\n-    for len in (2..25).chain(500..510) {\n-        for _ in 0..10 {\n+    #[cfg(not(miri))] // Miri is too slow\n+    let large_range = 500..510;\n+    #[cfg(not(miri))] // Miri is too slow\n+    let rounds = 10;\n+\n+    #[cfg(miri)]\n+    let large_range = 0..0; // empty range\n+    #[cfg(miri)]\n+    let rounds = 1;\n+\n+    for len in (2..25).chain(large_range) {\n+        for _ in 0..rounds {\n             let mut counts = [0; 10];\n \n             // create a vector like [(6, 1), (5, 1), (6, 2), ...],\n@@ -1397,7 +1406,7 @@ fn test_box_slice_clone() {\n #[test]\n #[allow(unused_must_use)] // here, we care about the side effects of `.clone()`\n #[cfg_attr(target_os = \"emscripten\", ignore)]\n-#[cfg(not(miri))] // Miri does not support threads nor entropy\n+#[cfg(not(miri))] // Miri does not support threads\n fn test_box_slice_clone_panics() {\n     use std::sync::Arc;\n     use std::sync::atomic::{AtomicUsize, Ordering};\n@@ -1589,7 +1598,7 @@ thread_local!(static SILENCE_PANIC: Cell<bool> = Cell::new(false));\n \n #[test]\n #[cfg_attr(target_os = \"emscripten\", ignore)] // no threads\n-#[cfg(not(miri))] // Miri does not support threads nor entropy\n+#[cfg(not(miri))] // Miri does not support threads\n fn panic_safe() {\n     let prev = panic::take_hook();\n     panic::set_hook(Box::new(move |info| {"}, {"sha": "acf6b03791f01ad27baed0bcc0ddef31e11985cc", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1024,22 +1024,31 @@ fn test_rotate_right() {\n \n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n-#[cfg(not(miri))] // Miri does not support entropy\n fn sort_unstable() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use core::slice::heapsort;\n     use rand::{FromEntropy, Rng, rngs::SmallRng, seq::SliceRandom};\n \n+    #[cfg(not(miri))] // Miri is too slow\n+    let large_range = 500..510;\n+    #[cfg(not(miri))] // Miri is too slow\n+    let rounds = 100;\n+\n+    #[cfg(miri)]\n+    let large_range = 0..0; // empty range\n+    #[cfg(miri)]\n+    let rounds = 1;\n+\n     let mut v = [0; 600];\n     let mut tmp = [0; 600];\n     let mut rng = SmallRng::from_entropy();\n \n-    for len in (2..25).chain(500..510) {\n+    for len in (2..25).chain(large_range) {\n         let v = &mut v[0..len];\n         let tmp = &mut tmp[0..len];\n \n         for &modulus in &[5, 10, 100, 1000] {\n-            for _ in 0..100 {\n+            for _ in 0..rounds {\n                 for i in 0..len {\n                     v[i] = rng.gen::<i32>() % modulus;\n                 }\n@@ -1095,7 +1104,7 @@ fn sort_unstable() {\n \n #[test]\n #[cfg(not(target_arch = \"wasm32\"))]\n-#[cfg(not(miri))] // Miri does not support entropy\n+#[cfg(not(miri))] // Miri is too slow\n fn partition_at_index() {\n     use core::cmp::Ordering::{Equal, Greater, Less};\n     use rand::rngs::SmallRng;"}, {"sha": "ca5feaee12ee4f6f903a6bdb0091de76a18a1231", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 20, "deletions": 53, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -45,12 +45,10 @@ pub struct Allocation<Tag=(),Extra=()> {\n }\n \n \n-pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n-    /// Hook to initialize the extra data when an allocation gets created.\n-    fn memory_allocated(\n-        _size: Size,\n-        _memory_extra: &MemoryExtra\n-    ) -> Self;\n+pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n+    // There is no constructor in here because the constructor's type depends\n+    // on `MemoryKind`, and making things sufficiently generic leads to painful\n+    // inference failure.\n \n     /// Hook for performing extra checks on a memory read access.\n     ///\n@@ -88,15 +86,8 @@ pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n     }\n }\n \n-impl AllocationExtra<(), ()> for () {\n-    #[inline(always)]\n-    fn memory_allocated(\n-        _size: Size,\n-        _memory_extra: &()\n-    ) -> Self {\n-        ()\n-    }\n-}\n+// For Tag=() and no extra state, we have is a trivial implementation.\n+impl AllocationExtra<()> for () { }\n \n impl<Tag, Extra> Allocation<Tag, Extra> {\n     /// Creates a read-only allocation initialized by the given bytes\n@@ -159,23 +150,21 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors\n-impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes. You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n     /// on that.\n-    fn get_bytes_internal<MemoryExtra>(\n+    fn get_bytes_internal(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.check_bounds(cx, ptr, size)?;\n \n@@ -196,43 +185,37 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n \n     #[inline]\n-    pub fn get_bytes<MemoryExtra>(\n+    pub fn get_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr<MemoryExtra>(\n+    pub fn get_bytes_with_undef_and_ptr(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n-    pub fn get_bytes_mut<MemoryExtra>(\n+    pub fn get_bytes_mut(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> EvalResult<'tcx, &mut [u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_bounds(cx, ptr, size)?;\n@@ -250,16 +233,14 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n /// Reading and writing\n-impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n-    pub fn read_c_str<MemoryExtra>(\n+    pub fn read_c_str(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> EvalResult<'tcx, &[u8]>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n@@ -278,15 +259,13 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor undef bytes.\n-    pub fn check_bytes<MemoryExtra>(\n+    pub fn check_bytes(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         allow_ptr_and_undef: bool,\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // Check bounds and relocations on the edges\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n@@ -301,30 +280,26 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// Will do bounds checks on the allocation.\n-    pub fn write_bytes<MemoryExtra>(\n+    pub fn write_bytes(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         src: &[u8],\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    pub fn write_repeat<MemoryExtra>(\n+    pub fn write_repeat(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: u8,\n         count: Size\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let bytes = self.get_bytes_mut(cx, ptr, count)?;\n         for b in bytes {\n@@ -341,14 +316,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_scalar<MemoryExtra>(\n+    pub fn read_scalar(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         // get_bytes_unchecked tests relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n@@ -379,13 +352,11 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_ptr_sized<MemoryExtra>(\n+    pub fn read_ptr_sized(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n@@ -398,15 +369,13 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_scalar<MemoryExtra>(\n+    pub fn write_scalar(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n@@ -446,14 +415,12 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_ptr_sized<MemoryExtra>(\n+    pub fn write_ptr_sized(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>\n     ) -> EvalResult<'tcx>\n-        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n-        where Extra: AllocationExtra<Tag, MemoryExtra>\n     {\n         let ptr_size = cx.data_layout().pointer_size;\n         self.write_scalar(cx, ptr.into(), val, ptr_size)"}, {"sha": "75e0f704a58545e239e05f14ba0ad9990cf8bb46", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -94,11 +94,17 @@ impl<'tcx> Pointer<()> {\n         Pointer { alloc_id, offset, tag: () }\n     }\n \n+    #[inline(always)]\n+    pub fn with_tag<Tag>(self, tag: Tag) -> Pointer<Tag>\n+    {\n+        Pointer::new_with_tag(self.alloc_id, self.offset, tag)\n+    }\n+\n     #[inline(always)]\n     pub fn with_default_tag<Tag>(self) -> Pointer<Tag>\n         where Tag: Default\n     {\n-        Pointer::new_with_tag(self.alloc_id, self.offset, Default::default())\n+        self.with_tag(Tag::default())\n     }\n }\n "}, {"sha": "18c82ecd38edc20ce250d39fd10a4b70cd7bada2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -119,14 +119,19 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n \n impl<'tcx> Scalar<()> {\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n-        where Tag: Default\n-    {\n+    pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_default_tag()),\n+            Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n             Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n         }\n     }\n+\n+    #[inline(always)]\n+    pub fn with_default_tag<Tag>(self) -> Scalar<Tag>\n+        where Tag: Default\n+    {\n+        self.with_tag(Tag::default())\n+    }\n }\n \n impl<'tcx, Tag> Scalar<Tag> {\n@@ -138,14 +143,6 @@ impl<'tcx, Tag> Scalar<Tag> {\n         }\n     }\n \n-    #[inline]\n-    pub fn with_tag(self, new_tag: Tag) -> Self {\n-        match self {\n-            Scalar::Ptr(ptr) => Scalar::Ptr(Pointer { tag: new_tag, ..ptr }),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n-        }\n-    }\n-\n     #[inline]\n     pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n         Scalar::Bits {\n@@ -434,14 +431,19 @@ impl<Tag> fmt::Display for ScalarMaybeUndef<Tag> {\n \n impl<'tcx> ScalarMaybeUndef<()> {\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n-        where Tag: Default\n-    {\n+    pub fn with_tag<Tag>(self, new_tag: Tag) -> ScalarMaybeUndef<Tag> {\n         match self {\n-            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_default_tag()),\n+            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.with_tag(new_tag)),\n             ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n         }\n     }\n+\n+    #[inline(always)]\n+    pub fn with_default_tag<Tag>(self) -> ScalarMaybeUndef<Tag>\n+        where Tag: Default\n+    {\n+        self.with_tag(Tag::default())\n+    }\n }\n \n impl<'tcx, Tag> ScalarMaybeUndef<Tag> {"}, {"sha": "dc1ceaf69f0135cb7da294658b2bb07a55ff968a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 70, "deletions": 36, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -19,6 +19,7 @@ use syntax::parse::token;\n use syntax::parse;\n use syntax::symbol::Symbol;\n use syntax::feature_gate::UnstableFeatures;\n+use errors::emitter::HumanReadableErrorType;\n \n use errors::{ColorConfig, FatalError, Handler};\n \n@@ -219,14 +220,18 @@ impl OutputType {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum ErrorOutputType {\n-    HumanReadable(ColorConfig),\n-    Json(bool),\n-    Short(ColorConfig),\n+    HumanReadable(HumanReadableErrorType),\n+    Json {\n+        /// Render the json in a human readable way (with indents and newlines)\n+        pretty: bool,\n+        /// The way the `rendered` field is created\n+        json_rendered: HumanReadableErrorType,\n+    },\n }\n \n impl Default for ErrorOutputType {\n     fn default() -> ErrorOutputType {\n-        ErrorOutputType::HumanReadable(ColorConfig::Auto)\n+        ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n     }\n }\n \n@@ -1372,6 +1377,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"print some statistics about AST and HIR\"),\n     always_encode_mir: bool = (false, parse_bool, [TRACKED],\n         \"encode MIR of all functions into the crate metadata\"),\n+    json_rendered: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+        \"describes how to render the `rendered` field of json diagnostics\"),\n     unleash_the_miri_inside_of_you: bool = (false, parse_bool, [TRACKED],\n         \"take the breaks off const evaluation. NOTE: this is unsound\"),\n     osx_rpath_install_name: bool = (false, parse_bool, [TRACKED],\n@@ -1825,6 +1832,12 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n             \"How errors and other messages are produced\",\n             \"human|json|short\",\n         ),\n+        opt::opt(\n+            \"\",\n+            \"json-rendered\",\n+            \"Choose `rendered` field of json diagnostics render scheme\",\n+            \"plain|termcolor\",\n+        ),\n         opt::opt_s(\n             \"\",\n             \"color\",\n@@ -1965,21 +1978,32 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n+    let json_rendered = matches.opt_str(\"json-rendered\").and_then(|s| match s.as_str() {\n+        \"plain\" => None,\n+        \"termcolor\" => Some(HumanReadableErrorType::Default(ColorConfig::Always)),\n+        _ => early_error(\n+            ErrorOutputType::default(),\n+            &format!(\n+                \"argument for --json-rendered must be `plain` or `termcolor` (instead was `{}`)\",\n+                s,\n+            ),\n+        ),\n+    }).unwrap_or(HumanReadableErrorType::Default(ColorConfig::Never));\n \n     // We need the opts_present check because the driver will send us Matches\n     // with only stable options if no unstable options are used. Since error-format\n     // is unstable, it will not be present. We have to use opts_present not\n     // opt_present because the latter will panic.\n     let error_format = if matches.opts_present(&[\"error-format\".to_owned()]) {\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-            Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-            Some(\"json\") => ErrorOutputType::Json(false),\n-            Some(\"pretty-json\") => ErrorOutputType::Json(true),\n-            Some(\"short\") => ErrorOutputType::Short(color),\n-            None => ErrorOutputType::HumanReadable(color),\n+            None |\n+            Some(\"human\") => ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n+            Some(\"json\") => ErrorOutputType::Json { pretty: false, json_rendered },\n+            Some(\"pretty-json\") => ErrorOutputType::Json { pretty: true, json_rendered },\n+            Some(\"short\") => ErrorOutputType::HumanReadable(HumanReadableErrorType::Short(color)),\n \n             Some(arg) => early_error(\n-                ErrorOutputType::HumanReadable(color),\n+                ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n                 &format!(\n                     \"argument for --error-format must be `human`, `json` or \\\n                      `short` (instead was `{}`)\",\n@@ -1988,7 +2012,7 @@ pub fn build_session_options_and_crate_config(\n             ),\n         }\n     } else {\n-        ErrorOutputType::HumanReadable(color)\n+        ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color))\n     };\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n@@ -2000,11 +2024,16 @@ pub fn build_session_options_and_crate_config(\n \n     let mut debugging_opts = build_debugging_options(matches, error_format);\n \n-    if !debugging_opts.unstable_options && error_format == ErrorOutputType::Json(true) {\n-        early_error(\n-            ErrorOutputType::Json(false),\n-            \"--error-format=pretty-json is unstable\",\n-        );\n+    if !debugging_opts.unstable_options {\n+        if matches.opt_str(\"json-rendered\").is_some() {\n+            early_error(error_format, \"`--json-rendered=x` is unstable\");\n+        }\n+        if let ErrorOutputType::Json { pretty: true, json_rendered } = error_format {\n+            early_error(\n+                ErrorOutputType::Json { pretty: false, json_rendered },\n+                \"--error-format=pretty-json is unstable\",\n+            );\n+        }\n     }\n \n     if debugging_opts.pgo_gen.enabled() && !debugging_opts.pgo_use.is_empty() {\n@@ -2928,50 +2957,55 @@ mod tests {\n         let mut v3 = Options::default();\n         let mut v4 = Options::default();\n \n+        const JSON: super::ErrorOutputType = super::ErrorOutputType::Json {\n+            pretty: false,\n+            json_rendered: super::HumanReadableErrorType::Default(super::ColorConfig::Never),\n+        };\n+\n         // Reference\n         v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n         v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n         v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n         v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n         v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n \n         v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n         v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n         v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n         v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n         v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n \n         v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n         v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n         v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n         v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n         v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n \n         v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n         v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n         v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n         v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n         v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", super::ErrorOutputType::Json(false)));\n+            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n \n         assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());"}, {"sha": "eed516a43817504c111f4a2899fe0ba22aa4f456", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1033,39 +1033,42 @@ fn default_emitter(\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n     match (sopts.error_format, emitter_dest) {\n-        (config::ErrorOutputType::HumanReadable(color_config), None) => Box::new(\n-            EmitterWriter::stderr(\n-                color_config,\n-                Some(source_map.clone()),\n-                false,\n-                sopts.debugging_opts.teach,\n-            ).ui_testing(sopts.debugging_opts.ui_testing),\n-        ),\n-        (config::ErrorOutputType::HumanReadable(_), Some(dst)) => Box::new(\n-            EmitterWriter::new(dst, Some(source_map.clone()), false, false)\n-                .ui_testing(sopts.debugging_opts.ui_testing),\n-        ),\n-        (config::ErrorOutputType::Json(pretty), None) => Box::new(\n+        (config::ErrorOutputType::HumanReadable(kind), dst) => {\n+            let (short, color_config) = kind.unzip();\n+            let emitter = match dst {\n+                None => EmitterWriter::stderr(\n+                    color_config,\n+                    Some(source_map.clone()),\n+                    short,\n+                    sopts.debugging_opts.teach,\n+                ),\n+                Some(dst) => EmitterWriter::new(\n+                    dst,\n+                    Some(source_map.clone()),\n+                    short,\n+                    false, // no teach messages when writing to a buffer\n+                    false, // no colors when writing to a buffer\n+                ),\n+            };\n+            Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n+        },\n+        (config::ErrorOutputType::Json { pretty, json_rendered }, None) => Box::new(\n             JsonEmitter::stderr(\n                 Some(registry),\n                 source_map.clone(),\n                 pretty,\n+                json_rendered,\n             ).ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n-        (config::ErrorOutputType::Json(pretty), Some(dst)) => Box::new(\n+        (config::ErrorOutputType::Json { pretty, json_rendered }, Some(dst)) => Box::new(\n             JsonEmitter::new(\n                 dst,\n                 Some(registry),\n                 source_map.clone(),\n                 pretty,\n+                json_rendered,\n             ).ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n-        (config::ErrorOutputType::Short(color_config), None) => Box::new(\n-            EmitterWriter::stderr(color_config, Some(source_map.clone()), true, false),\n-        ),\n-        (config::ErrorOutputType::Short(_), Some(dst)) => {\n-            Box::new(EmitterWriter::new(dst, Some(source_map.clone()), true, false))\n-        }\n     }\n }\n \n@@ -1322,13 +1325,12 @@ pub enum IncrCompSession {\n \n pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n-        config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config, None, false, false))\n-        }\n-        config::ErrorOutputType::Json(pretty) => Box::new(JsonEmitter::basic(pretty)),\n-        config::ErrorOutputType::Short(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config, None, true, false))\n+        config::ErrorOutputType::HumanReadable(kind) => {\n+            let (short, color_config) = kind.unzip();\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n         }\n+        config::ErrorOutputType::Json { pretty, json_rendered } =>\n+            Box::new(JsonEmitter::basic(pretty, json_rendered)),\n     };\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n@@ -1337,13 +1339,12 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n-        config::ErrorOutputType::HumanReadable(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config, None, false, false))\n-        }\n-        config::ErrorOutputType::Json(pretty) => Box::new(JsonEmitter::basic(pretty)),\n-        config::ErrorOutputType::Short(color_config) => {\n-            Box::new(EmitterWriter::stderr(color_config, None, true, false))\n+        config::ErrorOutputType::HumanReadable(kind) => {\n+            let (short, color_config) = kind.unzip();\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n         }\n+        config::ErrorOutputType::Json { pretty, json_rendered } =>\n+            Box::new(JsonEmitter::basic(pretty, json_rendered)),\n     };\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n     handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);"}, {"sha": "a1472479afa89f001154453cfb3fa490e3a0ba39", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 55, "deletions": 12, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -16,9 +16,35 @@ use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n use std::cmp::{min, Reverse};\n-use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter};\n+use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter, Ansi};\n use termcolor::{WriteColor, Color, Buffer};\n \n+/// Describes the way the content of the `rendered` field of the json output is generated\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum HumanReadableErrorType {\n+    Default(ColorConfig),\n+    Short(ColorConfig),\n+}\n+\n+impl HumanReadableErrorType {\n+    /// Returns a (`short`, `color`) tuple\n+    pub fn unzip(self) -> (bool, ColorConfig) {\n+        match self {\n+            HumanReadableErrorType::Default(cc) => (false, cc),\n+            HumanReadableErrorType::Short(cc) => (true, cc),\n+        }\n+    }\n+    pub fn new_emitter(\n+        self,\n+        dst: Box<dyn Write + Send>,\n+        source_map: Option<Lrc<SourceMapperDyn>>,\n+        teach: bool,\n+    ) -> EmitterWriter {\n+        let (short, color_config) = self.unzip();\n+        EmitterWriter::new(dst, source_map, short, teach, color_config.suggests_using_colors())\n+    }\n+}\n+\n const ANONYMIZED_LINE_NUM: &str = \"LL\";\n \n /// Emitter trait for emitting errors.\n@@ -104,8 +130,8 @@ pub enum ColorConfig {\n }\n \n impl ColorConfig {\n-    fn to_color_choice(&self) -> ColorChoice {\n-        match *self {\n+    fn to_color_choice(self) -> ColorChoice {\n+        match self {\n             ColorConfig::Always => {\n                 if atty::is(atty::Stream::Stderr) {\n                     ColorChoice::Always\n@@ -120,6 +146,14 @@ impl ColorConfig {\n             ColorConfig::Auto => ColorChoice::Never,\n         }\n     }\n+    fn suggests_using_colors(self) -> bool {\n+        match self {\n+            | ColorConfig::Always\n+            | ColorConfig::Auto\n+            => true,\n+            ColorConfig::Never => false,\n+        }\n+    }\n }\n \n pub struct EmitterWriter {\n@@ -152,13 +186,15 @@ impl EmitterWriter {\n         }\n     }\n \n-    pub fn new(dst: Box<dyn Write + Send>,\n-               source_map: Option<Lrc<SourceMapperDyn>>,\n-               short_message: bool,\n-               teach: bool)\n-               -> EmitterWriter {\n+    pub fn new(\n+        dst: Box<dyn Write + Send>,\n+        source_map: Option<Lrc<SourceMapperDyn>>,\n+        short_message: bool,\n+        teach: bool,\n+        colored: bool,\n+    ) -> EmitterWriter {\n         EmitterWriter {\n-            dst: Raw(dst),\n+            dst: Raw(dst, colored),\n             sm: source_map,\n             short_message,\n             teach,\n@@ -1538,13 +1574,15 @@ fn emit_to_destination(rendered_buffer: &[Vec<StyledString>],\n pub enum Destination {\n     Terminal(StandardStream),\n     Buffered(BufferWriter),\n-    Raw(Box<dyn Write + Send>),\n+    // The bool denotes whether we should be emitting ansi color codes or not\n+    Raw(Box<(dyn Write + Send)>, bool),\n }\n \n pub enum WritableDst<'a> {\n     Terminal(&'a mut StandardStream),\n     Buffered(&'a mut BufferWriter, Buffer),\n-    Raw(&'a mut Box<dyn Write + Send>),\n+    Raw(&'a mut (dyn Write + Send)),\n+    ColoredRaw(Ansi<&'a mut (dyn Write + Send)>),\n }\n \n impl Destination {\n@@ -1570,7 +1608,8 @@ impl Destination {\n                 let buf = t.buffer();\n                 WritableDst::Buffered(t, buf)\n             }\n-            Destination::Raw(ref mut t) => WritableDst::Raw(t),\n+            Destination::Raw(ref mut t, false) => WritableDst::Raw(t),\n+            Destination::Raw(ref mut t, true) => WritableDst::ColoredRaw(Ansi::new(t)),\n         }\n     }\n }\n@@ -1628,6 +1667,7 @@ impl<'a> WritableDst<'a> {\n         match *self {\n             WritableDst::Terminal(ref mut t) => t.set_color(color),\n             WritableDst::Buffered(_, ref mut t) => t.set_color(color),\n+            WritableDst::ColoredRaw(ref mut t) => t.set_color(color),\n             WritableDst::Raw(_) => Ok(())\n         }\n     }\n@@ -1636,6 +1676,7 @@ impl<'a> WritableDst<'a> {\n         match *self {\n             WritableDst::Terminal(ref mut t) => t.reset(),\n             WritableDst::Buffered(_, ref mut t) => t.reset(),\n+            WritableDst::ColoredRaw(ref mut t) => t.reset(),\n             WritableDst::Raw(_) => Ok(()),\n         }\n     }\n@@ -1647,6 +1688,7 @@ impl<'a> Write for WritableDst<'a> {\n             WritableDst::Terminal(ref mut t) => t.write(bytes),\n             WritableDst::Buffered(_, ref mut buf) => buf.write(bytes),\n             WritableDst::Raw(ref mut w) => w.write(bytes),\n+            WritableDst::ColoredRaw(ref mut t) => t.write(bytes),\n         }\n     }\n \n@@ -1655,6 +1697,7 @@ impl<'a> Write for WritableDst<'a> {\n             WritableDst::Terminal(ref mut t) => t.flush(),\n             WritableDst::Buffered(_, ref mut buf) => buf.flush(),\n             WritableDst::Raw(ref mut w) => w.flush(),\n+            WritableDst::ColoredRaw(ref mut w) => w.flush(),\n         }\n     }\n }"}, {"sha": "09c50d4f81f494e17c01636371fffbc21027ae39", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::Def;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n-use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n+use rustc::ty::layout::{self, LayoutOf, VariantIdx, Size};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n@@ -21,7 +21,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use crate::interpret::{self,\n-    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n+    PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     EvalResult, EvalError, InterpError, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n@@ -406,6 +406,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         Cow::Borrowed(alloc)\n     }\n \n+    #[inline(always)]\n+    fn new_allocation(\n+        _size: Size,\n+        _extra: &Self::MemoryExtra,\n+        _kind: MemoryKind<!>,\n+    ) -> (Self::AllocExtra, Self::PointerTag) {\n+        ((), ())\n+    }\n+\n     fn box_alloc(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n@@ -439,15 +448,6 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n         )\n     }\n \n-    #[inline(always)]\n-    fn tag_new_allocation(\n-        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer,\n-        _kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> Pointer {\n-        ptr\n-    }\n-\n     #[inline(always)]\n     fn stack_push(\n         _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,"}, {"sha": "288ffbf3cd616f57839f8858a17fa1cea76c6674", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n-use rustc::ty::{self, query::TyCtxtAt};\n+use rustc::ty::{self, query::TyCtxtAt, layout::Size};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n+    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -76,7 +76,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     type MemoryExtra: Default;\n \n     /// Extra data stored in every allocation.\n-    type AllocExtra: AllocationExtra<Self::PointerTag, Self::MemoryExtra> + 'static;\n+    type AllocExtra: AllocationExtra<Self::PointerTag> + 'static;\n \n     /// Memory's allocation map\n     type MemoryMap:\n@@ -139,18 +139,6 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         memory_extra: &Self::MemoryExtra,\n     ) -> EvalResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag, Self::AllocExtra>>>;\n \n-    /// Called to turn an allocation obtained from the `tcx` into one that has\n-    /// the right type for this machine.\n-    ///\n-    /// This should avoid copying if no work has to be done! If this returns an owned\n-    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n-    /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n-    /// owned allocation to the map even when the map is shared.)\n-    fn adjust_static_allocation<'b>(\n-        alloc: &'b Allocation,\n-        memory_extra: &Self::MemoryExtra,\n-    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n-\n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n     /// value, and for the `Offset` operation that is inherently about pointers.\n     ///\n@@ -168,12 +156,24 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n-    /// Adds the tag for a newly allocated pointer.\n-    fn tag_new_allocation(\n-        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer,\n+    /// Called to turn an allocation obtained from the `tcx` into one that has\n+    /// the right type for this machine.\n+    ///\n+    /// This should avoid copying if no work has to be done! If this returns an owned\n+    /// allocation (because a copy had to be done to add tags or metadata), machine memory will\n+    /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n+    /// owned allocation to the map even when the map is shared.)\n+    fn adjust_static_allocation<'b>(\n+        alloc: &'b Allocation,\n+        memory_extra: &Self::MemoryExtra,\n+    ) -> Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>;\n+\n+    /// Computes the extra state and the tag for a new allocation.\n+    fn new_allocation(\n+        size: Size,\n+        extra: &Self::MemoryExtra,\n         kind: MemoryKind<Self::MemoryKinds>,\n-    ) -> Pointer<Self::PointerTag>;\n+    ) -> (Self::AllocExtra, Self::PointerTag);\n \n     /// Executed when evaluating the `*` operator: Following a reference.\n     /// This has the chance to adjust the tag. It should not change anything else!"}, {"sha": "117bd15399cde336807be187951da319842a3d9d", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -132,9 +132,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> Pointer {\n-        let extra = AllocationExtra::memory_allocated(size, &self.extra);\n-        Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind))\n+    ) -> Pointer<M::PointerTag> {\n+        let (extra, tag) = M::new_allocation(size, &self.extra, kind);\n+        Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind)).with_tag(tag)\n     }\n \n     pub fn reallocate(\n@@ -145,7 +145,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n-    ) -> EvalResult<'tcx, Pointer> {\n+    ) -> EvalResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(ReallocateNonBasePtr);\n         }\n@@ -156,7 +156,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         self.copy(\n             ptr.into(),\n             old_align,\n-            new_ptr.with_default_tag().into(),\n+            new_ptr.into(),\n             new_align,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,"}, {"sha": "55c1bfb17dec31a18f2eea1123bc06f312998729", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -31,19 +31,6 @@ pub enum Immediate<Tag=(), Id=AllocId> {\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n }\n \n-impl Immediate {\n-    #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Immediate<Tag>\n-        where Tag: Default\n-    {\n-        match self {\n-            Immediate::Scalar(x) => Immediate::Scalar(x.with_default_tag()),\n-            Immediate::ScalarPair(x, y) =>\n-                Immediate::ScalarPair(x.with_default_tag(), y.with_default_tag()),\n-        }\n-    }\n-}\n-\n impl<'tcx, Tag> Immediate<Tag> {\n     #[inline]\n     pub fn from_scalar(val: Scalar<Tag>) -> Self {\n@@ -142,18 +129,6 @@ pub enum Operand<Tag=(), Id=AllocId> {\n     Indirect(MemPlace<Tag, Id>),\n }\n \n-impl Operand {\n-    #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Operand<Tag>\n-        where Tag: Default\n-    {\n-        match self {\n-            Operand::Immediate(x) => Operand::Immediate(x.with_default_tag()),\n-            Operand::Indirect(x) => Operand::Indirect(x.with_default_tag()),\n-        }\n-    }\n-}\n-\n impl<Tag> Operand<Tag> {\n     #[inline]\n     pub fn erase_tag(self) -> Operand\n@@ -554,16 +529,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway.\n                 Operand::Indirect(\n-                    MemPlace::from_ptr(ptr, alloc.align)\n-                ).with_default_tag()\n+                    MemPlace::from_ptr(ptr.with_default_tag(), alloc.align)\n+                )\n             },\n             ConstValue::Slice(a, b) =>\n                 Operand::Immediate(Immediate::ScalarPair(\n-                    a.into(),\n-                    Scalar::from_uint(b, self.tcx.data_layout.pointer_size).into(),\n-                )).with_default_tag(),\n+                    a.with_default_tag().into(),\n+                    Scalar::from_uint(b, self.tcx.data_layout.pointer_size)\n+                        .with_default_tag().into(),\n+                )),\n             ConstValue::Scalar(x) =>\n-                Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag(),\n+                Operand::Immediate(Immediate::Scalar(x.with_default_tag().into())),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {"}, {"sha": "8239337796e9a57faeaaca129f1e30e2a02cdd6c", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -83,40 +83,26 @@ impl<'tcx, Tag> From<MPlaceTy<'tcx, Tag>> for PlaceTy<'tcx, Tag> {\n     }\n }\n \n-impl MemPlace {\n+impl<Tag> MemPlace<Tag> {\n+    /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> MemPlace<Tag>\n-        where Tag: Default\n-    {\n+    pub fn replace_tag(self, new_tag: Tag) -> Self {\n         MemPlace {\n-            ptr: self.ptr.with_default_tag(),\n+            ptr: self.ptr.erase_tag().with_tag(new_tag),\n             align: self.align,\n-            meta: self.meta.map(Scalar::with_default_tag),\n+            meta: self.meta,\n         }\n     }\n-}\n \n-impl<Tag> MemPlace<Tag> {\n     #[inline]\n-    pub fn erase_tag(self) -> MemPlace\n-    {\n+    pub fn erase_tag(self) -> MemPlace {\n         MemPlace {\n             ptr: self.ptr.erase_tag(),\n             align: self.align,\n             meta: self.meta.map(Scalar::erase_tag),\n         }\n     }\n \n-    #[inline]\n-    pub fn with_tag(self, new_tag: Tag) -> Self\n-    {\n-        MemPlace {\n-            ptr: self.ptr.with_tag(new_tag),\n-            align: self.align,\n-            meta: self.meta,\n-        }\n-    }\n-\n     #[inline(always)]\n     pub fn from_scalar_ptr(ptr: Scalar<Tag>, align: Align) -> Self {\n         MemPlace {\n@@ -189,11 +175,11 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n         }\n     }\n \n+    /// Replace ptr tag, maintain vtable tag (if any)\n     #[inline]\n-    pub fn with_tag(self, new_tag: Tag) -> Self\n-    {\n+    pub fn replace_tag(self, new_tag: Tag) -> Self {\n         MPlaceTy {\n-            mplace: self.mplace.with_tag(new_tag),\n+            mplace: self.mplace.replace_tag(new_tag),\n             layout: self.layout,\n         }\n     }\n@@ -312,7 +298,7 @@ where\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<Tag, M::MemoryExtra>,\n+    M::AllocExtra: AllocationExtra<Tag>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n@@ -943,7 +929,6 @@ where\n                         let (size, align) = self.size_and_align_of(meta, local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n                         let ptr = self.memory.allocate(size, align, MemoryKind::Stack);\n-                        let ptr = M::tag_new_allocation(self, ptr, MemoryKind::Stack);\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let Some(value) = old_val {\n                             // Preserve old value.\n@@ -981,7 +966,6 @@ where\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n         let ptr = self.memory.allocate(layout.size, layout.align.abi, kind);\n-        let ptr = M::tag_new_allocation(self, ptr, kind);\n         MPlaceTy::from_aligned_ptr(ptr, layout)\n     }\n "}, {"sha": "0bed62ccf500a227688af85362de56d46797d910", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             ptr_size * (3 + methods.len() as u64),\n             ptr_align,\n             MemoryKind::Vtable,\n-        ).with_default_tag();\n+        );\n         let tcx = &*self.tcx;\n \n         let drop = crate::monomorphize::resolve_drop_in_place(*tcx, ty);"}, {"sha": "7826d3da4fed2a2e79587138823705f1d983998f", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -326,7 +326,12 @@ fn check_terminator(\n                     abi::Abi::Rust if tcx.is_min_const_fn(def_id) => {},\n                     abi::Abi::Rust => return Err((\n                         span,\n-                        \"can only call other `min_const_fn` within a `min_const_fn`\".into(),\n+                        format!(\n+                            \"can only call other `const fn` within a `const fn`, \\\n+                             but `{:?}` is not stable as `const fn`\",\n+                            func,\n+                        )\n+                        .into(),\n                     )),\n                     abi => return Err((\n                         span,"}, {"sha": "769ea3ff7bc740848b01dc7f8c82d5b6bd7b5802", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use std::path::PathBuf;\n \n use errors;\n-use errors::emitter::ColorConfig;\n+use errors::emitter::{ColorConfig, HumanReadableErrorType};\n use getopts;\n use rustc::lint::Level;\n use rustc::session::early_error;\n@@ -254,12 +254,19 @@ impl Options {\n                                       (instead was `{}`)\", arg));\n             }\n         };\n+        // FIXME: deduplicate this code from the identical code in librustc/session/config.rs\n         let error_format = match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n-            Some(\"human\") => ErrorOutputType::HumanReadable(color),\n-            Some(\"json\") => ErrorOutputType::Json(false),\n-            Some(\"pretty-json\") => ErrorOutputType::Json(true),\n-            Some(\"short\") => ErrorOutputType::Short(color),\n-            None => ErrorOutputType::HumanReadable(color),\n+            None |\n+            Some(\"human\") => ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n+            Some(\"json\") => ErrorOutputType::Json {\n+                pretty: false,\n+                json_rendered: HumanReadableErrorType::Default(ColorConfig::Never),\n+            },\n+            Some(\"pretty-json\") => ErrorOutputType::Json {\n+                pretty: true,\n+                json_rendered: HumanReadableErrorType::Default(ColorConfig::Never),\n+            },\n+            Some(\"short\") => ErrorOutputType::HumanReadable(HumanReadableErrorType::Short(color)),\n             Some(arg) => {\n                 early_error(ErrorOutputType::default(),\n                             &format!(\"argument for --error-format must be `human`, `json` or \\"}, {"sha": "c141b47481531fd446f436194545d1d439ab634d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -299,32 +299,29 @@ pub fn new_handler(error_format: ErrorOutputType,\n     // stick to the defaults\n     let sessopts = Options::default();\n     let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n-        ErrorOutputType::HumanReadable(color_config) => Box::new(\n-            EmitterWriter::stderr(\n-                color_config,\n-                source_map.map(|cm| cm as _),\n-                false,\n-                sessopts.debugging_opts.teach,\n-            ).ui_testing(ui_testing)\n-        ),\n-        ErrorOutputType::Json(pretty) => {\n+        ErrorOutputType::HumanReadable(kind) => {\n+            let (short, color_config) = kind.unzip();\n+            Box::new(\n+                EmitterWriter::stderr(\n+                    color_config,\n+                    source_map.map(|cm| cm as _),\n+                    short,\n+                    sessopts.debugging_opts.teach,\n+                ).ui_testing(ui_testing)\n+            )\n+        },\n+        ErrorOutputType::Json { pretty, json_rendered } => {\n             let source_map = source_map.unwrap_or_else(\n                 || Lrc::new(source_map::SourceMap::new(sessopts.file_path_mapping())));\n             Box::new(\n                 JsonEmitter::stderr(\n                     None,\n                     source_map,\n                     pretty,\n+                    json_rendered,\n                 ).ui_testing(ui_testing)\n             )\n         },\n-        ErrorOutputType::Short(color_config) => Box::new(\n-            EmitterWriter::stderr(\n-                color_config,\n-                source_map.map(|cm| cm as _),\n-                true,\n-                false)\n-        ),\n     };\n \n     errors::Handler::with_emitter_and_flags("}, {"sha": "abf74158c938e4b0b8f65f6dd9646ece7e517510", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -381,7 +381,7 @@ pub fn make_test(s: &str,\n         // Any errors in parsing should also appear when the doctest is compiled for real, so just\n         // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n         let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false);\n+        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false);\n         let handler = Handler::with_emitter(false, None, box emitter);\n         let sess = ParseSess::with_span_handler(handler, cm);\n "}, {"sha": "c19b408442ad12b16b224dbd3ab4f36201c0d6f9", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -14,7 +14,7 @@ use crate::source_map::{SourceMap, FilePathMapping};\n use errors::registry::Registry;\n use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, SourceMapper};\n use errors::{DiagnosticId, Applicability};\n-use errors::emitter::{Emitter, EmitterWriter};\n+use errors::emitter::{Emitter, HumanReadableErrorType};\n \n use syntax_pos::{MacroBacktrace, Span, SpanLabel, MultiSpan};\n use rustc_data_structures::sync::{self, Lrc};\n@@ -30,37 +30,46 @@ pub struct JsonEmitter {\n     sm: Lrc<dyn SourceMapper + sync::Send + sync::Sync>,\n     pretty: bool,\n     ui_testing: bool,\n+    json_rendered: HumanReadableErrorType,\n }\n \n impl JsonEmitter {\n-    pub fn stderr(registry: Option<Registry>,\n-                  source_map: Lrc<SourceMap>,\n-                  pretty: bool) -> JsonEmitter {\n+    pub fn stderr(\n+        registry: Option<Registry>,\n+        source_map: Lrc<SourceMap>,\n+        pretty: bool,\n+        json_rendered: HumanReadableErrorType,\n+    ) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::stderr()),\n             registry,\n             sm: source_map,\n             pretty,\n             ui_testing: false,\n+            json_rendered,\n         }\n     }\n \n-    pub fn basic(pretty: bool) -> JsonEmitter {\n+    pub fn basic(pretty: bool, json_rendered: HumanReadableErrorType) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(None, Lrc::new(SourceMap::new(file_path_mapping)),\n-                            pretty)\n+                            pretty, json_rendered)\n     }\n \n-    pub fn new(dst: Box<dyn Write + Send>,\n-               registry: Option<Registry>,\n-               source_map: Lrc<SourceMap>,\n-               pretty: bool) -> JsonEmitter {\n+    pub fn new(\n+        dst: Box<dyn Write + Send>,\n+        registry: Option<Registry>,\n+        source_map: Lrc<SourceMap>,\n+        pretty: bool,\n+        json_rendered: HumanReadableErrorType,\n+    ) -> JsonEmitter {\n         JsonEmitter {\n             dst,\n             registry,\n             sm: source_map,\n             pretty,\n             ui_testing: false,\n+            json_rendered,\n         }\n     }\n \n@@ -190,7 +199,7 @@ impl Diagnostic {\n         }\n         let buf = BufWriter::default();\n         let output = buf.clone();\n-        EmitterWriter::new(Box::new(buf), Some(je.sm.clone()), false, false)\n+        je.json_rendered.new_emitter(Box::new(buf), Some(je.sm.clone()), false)\n             .ui_testing(je.ui_testing).emit(db);\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();\n         let output = String::from_utf8(output).unwrap();"}, {"sha": "3b980fafc2f1c4e6c2ed3c6e24964be271cf1e54", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1920,6 +1920,7 @@ mod tests {\n         let emitter = errors::emitter::EmitterWriter::new(Box::new(io::sink()),\n                                                           Some(sm.clone()),\n                                                           false,\n+                                                          false,\n                                                           false);\n         ParseSess {\n             span_diagnostic: errors::Handler::with_emitter(true, None, Box::new(emitter)),"}, {"sha": "cba429068fd5b6841dabc60f4aabe95ab2fed175", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -57,6 +57,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n         let emitter = EmitterWriter::new(Box::new(Shared { data: output.clone() }),\n                                         Some(source_map.clone()),\n                                         false,\n+                                        false,\n                                         false);\n         let handler = Handler::with_emitter(true, None, Box::new(emitter));\n         handler.span_err(msp, \"foo\");"}, {"sha": "759d9ab6a408137aa619f5109eedbc7165bf0446", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -12,14 +12,14 @@ const fn foo() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n+const fn bar() -> u32 { foo() } //~ ERROR can only call other `const fn`\n \n #[unstable(feature = \"rust1\", issue=\"0\")]\n const fn foo2() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n+const fn bar2() -> u32 { foo2() } //~ ERROR can only call other `const fn`\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // conformity is required, even with `const_fn` feature gate\n@@ -31,6 +31,6 @@ const fn foo2_gated() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n+const fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `const fn`\n \n fn main() {}"}, {"sha": "c73eda9ab9fc19e54342d20865d741f34683e670", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_libstd_stability.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_libstd_stability.stderr?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1,12 +1,12 @@\n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:15:25\n    |\n LL | const fn bar() -> u32 { foo() }\n    |                         ^^^^^\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:22:26\n    |\n LL | const fn bar2() -> u32 { foo2() }\n@@ -22,7 +22,7 @@ LL | const fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2_gated` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_fn_libstd_stability.rs:34:32\n    |\n LL | const fn bar2_gated() -> u32 { foo2_gated() }"}, {"sha": "64057b012b8dffaf047ef1aef90a6934dcdf0fda", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -12,14 +12,14 @@ const unsafe fn foo() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `min_const_fn`\n+const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `const fn`\n \n #[unstable(feature = \"rust1\", issue=\"0\")]\n const unsafe fn foo2() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `min_const_fn`\n+const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `const fn`\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // conformity is required, even with `const_fn` feature gate\n@@ -31,6 +31,7 @@ const unsafe fn foo2_gated() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } } //~ ERROR can only call other\n+const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } }\n+//~^ ERROR can only call other `const fn`\n \n fn main() {}"}, {"sha": "87b572dcc46f3cc4bbc41957d4c4639e597bad3f", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1,12 +1,12 @@\n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:15:41\n    |\n LL | const unsafe fn bar() -> u32 { unsafe { foo() } }\n    |                                         ^^^^^\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:22:42\n    |\n LL | const unsafe fn bar2() -> u32 { unsafe { foo2() } }\n@@ -22,7 +22,7 @@ LL | const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 }\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2_gated` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability.rs:34:48\n    |\n LL | const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } }"}, {"sha": "deb2cb6b619bbe7369284ae124a965d31959e439", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -12,21 +12,21 @@ const fn foo() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n+const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `const fn`\n \n #[unstable(feature = \"rust1\", issue=\"0\")]\n const fn foo2() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n+const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `const fn`\n \n // check whether this function cannot be called even with the feature gate active\n #[unstable(feature = \"foo2\", issue=\"0\")]\n const fn foo2_gated() -> u32 { 42 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n // can't call non-min_const_fn\n-const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n+const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `const fn`\n \n fn main() {}"}, {"sha": "5fddc119758844fd3c46308cde24b621a7715847", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1,20 +1,20 @@\n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:15:32\n    |\n LL | const unsafe fn bar() -> u32 { foo() }\n    |                                ^^^^^\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:22:33\n    |\n LL | const unsafe fn bar2() -> u32 { foo2() }\n    |                                 ^^^^^^\n    |\n    = help: add #![feature(const_fn)] to the crate attributes to enable\n \n-error[E0723]: can only call other `min_const_fn` within a `min_const_fn` (see issue #57563)\n+error[E0723]: can only call other `const fn` within a `const fn`, but `const foo2_gated` is not stable as `const fn` (see issue #57563)\n   --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:30:39\n    |\n LL | const unsafe fn bar2_gated() -> u32 { foo2_gated() }"}, {"sha": "9679ce4a2ae1d1638d8f3b479e70d1d656c138b7", "filename": "src/test/ui/lint/use_suggestion_json.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -1,5 +1,6 @@\n // ignore-cloudabi\n-// compile-flags: --error-format pretty-json -Zunstable-options\n+// ignore-windows\n+// compile-flags: --error-format pretty-json -Zunstable-options --json-rendered=termcolor\n \n // The output for humans should just highlight the whole span without showing\n // the suggested replacement, but we also want to test that suggested"}, {"sha": "632666db75b667b01ae691d23ec8a4a53521ac9a", "filename": "src/test/ui/lint/use_suggestion_json.stderr", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fuse_suggestion_json.stderr?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -73,10 +73,10 @@ mod foo {\n   \"spans\": [\n     {\n       \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-      \"byte_start\": 440,\n-      \"byte_end\": 444,\n-      \"line_start\": 11,\n-      \"line_end\": 11,\n+      \"byte_start\": 484,\n+      \"byte_end\": 488,\n+      \"line_start\": 12,\n+      \"line_end\": 12,\n       \"column_start\": 12,\n       \"column_end\": 16,\n       \"is_primary\": true,\n@@ -101,10 +101,10 @@ mod foo {\n       \"spans\": [\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -124,10 +124,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -147,10 +147,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -170,10 +170,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -193,10 +193,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -216,10 +216,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -239,10 +239,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -262,10 +262,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -285,10 +285,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -308,10 +308,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -331,10 +331,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -354,10 +354,10 @@ mod foo {\n         },\n         {\n           \"file_name\": \"$DIR/use_suggestion_json.rs\",\n-          \"byte_start\": 417,\n-          \"byte_end\": 417,\n-          \"line_start\": 10,\n-          \"line_end\": 10,\n+          \"byte_start\": 461,\n+          \"byte_end\": 461,\n+          \"line_start\": 11,\n+          \"line_end\": 11,\n           \"column_start\": 1,\n           \"column_end\": 1,\n           \"is_primary\": true,\n@@ -380,22 +380,22 @@ mod foo {\n       \"rendered\": null\n     }\n   ],\n-  \"rendered\": \"error[E0412]: cannot find type `Iter` in this scope\n-  --> $DIR/use_suggestion_json.rs:11:12\n-   |\n-LL |     let x: Iter;\n-   |            ^^^^ not found in this scope\n-help: possible candidates are found in other modules, you can import them into scope\n-   |\n-LL | use std::collections::binary_heap::Iter;\n-   |\n-LL | use std::collections::btree_map::Iter;\n-   |\n-LL | use std::collections::btree_set::Iter;\n-   |\n-LL | use std::collections::hash_map::Iter;\n-   |\n-and 8 other candidates\n+  \"rendered\": \"\\u001b[0m\\u001b[1m\\u001b[38;5;9merror[E0412]\\u001b[0m\\u001b[0m\\u001b[1m: cannot find type `Iter` in this scope\\u001b[0m\n+\\u001b[0m  \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m--> \\u001b[0m\\u001b[0m$DIR/use_suggestion_json.rs:12:12\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n+\\u001b[0m\\u001b[1m\\u001b[38;5;12mLL\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0m    let x: Iter;\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0m           \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;9m^^^^\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;9mnot found in this scope\\u001b[0m\n+\\u001b[0m\\u001b[1m\\u001b[38;5;14mhelp\\u001b[0m\\u001b[0m: possible candidates are found in other modules, you can import them into scope\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n+\\u001b[0m\\u001b[1m\\u001b[38;5;12mLL\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0muse std::collections::binary_heap::Iter;\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n+\\u001b[0m\\u001b[1m\\u001b[38;5;12mLL\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0muse std::collections::btree_map::Iter;\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n+\\u001b[0m\\u001b[1m\\u001b[38;5;12mLL\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0muse std::collections::btree_set::Iter;\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n+\\u001b[0m\\u001b[1m\\u001b[38;5;12mLL\\u001b[0m\\u001b[0m \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m| \\u001b[0m\\u001b[0muse std::collections::hash_map::Iter;\\u001b[0m\n+\\u001b[0m   \\u001b[0m\\u001b[0m\\u001b[1m\\u001b[38;5;12m|\\u001b[0m\n+\\u001b[0mand 8 other candidates\\u001b[0m\n \n \"\n }\n@@ -405,7 +405,7 @@ and 8 other candidates\n   \"level\": \"error\",\n   \"spans\": [],\n   \"children\": [],\n-  \"rendered\": \"error: aborting due to previous error\n+  \"rendered\": \"\\u001b[0m\\u001b[1m\\u001b[38;5;9merror\\u001b[0m\\u001b[0m\\u001b[1m: aborting due to previous error\\u001b[0m\n \n \"\n }\n@@ -415,6 +415,6 @@ and 8 other candidates\n   \"level\": \"\",\n   \"spans\": [],\n   \"children\": [],\n-  \"rendered\": \"For more information about this error, try `rustc --explain E0412`.\n+  \"rendered\": \"\\u001b[0m\\u001b[1mFor more information about this error, try `rustc --explain E0412`.\\u001b[0m\n \"\n }"}, {"sha": "a7615f5f423a3d913219b29c5179298f77ca6d89", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -62,19 +62,20 @@ struct DiagnosticCode {\n     explanation: Option<String>,\n }\n \n-pub fn extract_rendered(output: &str, proc_res: &ProcRes) -> String {\n+pub fn extract_rendered(output: &str) -> String {\n     output\n         .lines()\n         .filter_map(|line| {\n             if line.starts_with('{') {\n                 match serde_json::from_str::<Diagnostic>(line) {\n                     Ok(diagnostic) => diagnostic.rendered,\n                     Err(error) => {\n-                        proc_res.fatal(Some(&format!(\n+                        print!(\n                             \"failed to decode compiler output as json: \\\n                              `{}`\\nline: {}\\noutput: {}\",\n                             error, line, output\n-                        )));\n+                        );\n+                        panic!()\n                     }\n                 }\n             } else {"}, {"sha": "6df56168973bb844649f8722443bb6f6ad4bccf4", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 4, "deletions": 42, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efe2f32a6b8217425f361ec7c206910c611c03ee/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=efe2f32a6b8217425f361ec7c206910c611c03ee", "patch": "@@ -2090,50 +2090,10 @@ impl<'test> TestCx<'test> {\n     }\n \n     fn fatal_proc_rec(&self, err: &str, proc_res: &ProcRes) -> ! {\n-        self.try_print_open_handles();\n         self.error(err);\n         proc_res.fatal(None);\n     }\n \n-    // This function is a poor man's attempt to debug rust-lang/rust#38620, if\n-    // that's closed then this should be deleted\n-    //\n-    // This is a very \"opportunistic\" debugging attempt, so we ignore all\n-    // errors here.\n-    fn try_print_open_handles(&self) {\n-        if !cfg!(windows) {\n-            return;\n-        }\n-        if self.config.mode != Incremental {\n-            return;\n-        }\n-\n-        let filename = match self.testpaths.file.file_stem() {\n-            Some(path) => path,\n-            None => return,\n-        };\n-\n-        let mut cmd = Command::new(\"handle.exe\");\n-        cmd.arg(\"-a\").arg(\"-u\");\n-        cmd.arg(filename);\n-        cmd.arg(\"-nobanner\");\n-        cmd.stdout(Stdio::piped());\n-        cmd.stderr(Stdio::piped());\n-        let output = match cmd.spawn().and_then(read2_abbreviated) {\n-            Ok(output) => output,\n-            Err(_) => return,\n-        };\n-        println!(\"---------------------------------------------------\");\n-        println!(\"ran extra command to debug rust-lang/rust#38620: \");\n-        println!(\"{:?}\", cmd);\n-        println!(\"result: {}\", output.status);\n-        println!(\"--- stdout ----------------------------------------\");\n-        println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n-        println!(\"--- stderr ----------------------------------------\");\n-        println!(\"{}\", String::from_utf8_lossy(&output.stderr));\n-        println!(\"---------------------------------------------------\");\n-    }\n-\n     // codegen tests (using FileCheck)\n \n     fn compile_test_and_save_ir(&self) -> ProcRes {\n@@ -2844,7 +2804,7 @@ impl<'test> TestCx<'test> {\n         let stderr = if explicit {\n             proc_res.stderr.clone()\n         } else {\n-            json::extract_rendered(&proc_res.stderr, &proc_res)\n+            json::extract_rendered(&proc_res.stderr)\n         };\n \n         let normalized_stderr = self.normalize_output(&stderr, &self.props.normalize_stderr);\n@@ -3464,7 +3424,9 @@ impl ProcRes {\n              {}\\n\\\n              ------------------------------------------\\n\\\n              \\n\",\n-            self.status, self.cmdline, self.stdout, self.stderr\n+            self.status, self.cmdline,\n+            json::extract_rendered(&self.stdout),\n+            json::extract_rendered(&self.stderr),\n         );\n         // Use resume_unwind instead of panic!() to prevent a panic message + backtrace from\n         // compiletest, which is unnecessary noise."}]}