{"sha": "0e022f87e7103fcb4b62ae32a467b92503abb178", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMDIyZjg3ZTcxMDNmY2I0YjYyYWUzMmE0NjdiOTI1MDNhYmIxNzg=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-25T17:26:20Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-07-25T17:26:20Z"}, "message": "Remove needless indirection through Rc\n\nNamedMatch is already cheap to clone due to Lrc's inside.", "tree": {"sha": "e002b703427169dba242a6df635d808a34cad844", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e002b703427169dba242a6df635d808a34cad844"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e022f87e7103fcb4b62ae32a467b92503abb178", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e022f87e7103fcb4b62ae32a467b92503abb178", "html_url": "https://github.com/rust-lang/rust/commit/0e022f87e7103fcb4b62ae32a467b92503abb178", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e022f87e7103fcb4b62ae32a467b92503abb178/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c", "html_url": "https://github.com/rust-lang/rust/commit/eedf6ce4ef54bb03818ab21d714f1b9f13a6b31c"}], "stats": {"total": 36, "additions": 16, "deletions": 20}, "files": [{"sha": "dbf14daa30e75e51bae34fd3a78a63dc1302e3e6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e022f87e7103fcb4b62ae32a467b92503abb178/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e022f87e7103fcb4b62ae32a467b92503abb178/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0e022f87e7103fcb4b62ae32a467b92503abb178", "patch": "@@ -92,7 +92,6 @@ use rustc_data_structures::sync::Lrc;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::mem;\n use std::ops::{Deref, DerefMut};\n-use std::rc::Rc;\n \n // To avoid costly uniqueness checks, we require that `MatchSeq` always has a nonempty body.\n \n@@ -280,7 +279,7 @@ pub enum ParseResult<T> {\n \n /// A `ParseResult` where the `Success` variant contains a mapping of `Ident`s to `NamedMatch`es.\n /// This represents the mapping of metavars to the token trees they bind to.\n-pub type NamedParseResult = ParseResult<FxHashMap<Ident, Rc<NamedMatch>>>;\n+pub type NamedParseResult = ParseResult<FxHashMap<Ident, NamedMatch>>;\n \n /// Count how many metavars are named in the given matcher `ms`.\n pub fn count_names(ms: &[TokenTree]) -> usize {\n@@ -373,7 +372,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n         sess: &ParseSess,\n         m: &TokenTree,\n         res: &mut I,\n-        ret_val: &mut FxHashMap<Ident, Rc<NamedMatch>>,\n+        ret_val: &mut FxHashMap<Ident, NamedMatch>,\n     ) -> Result<(), (syntax_pos::Span, String)> {\n         match *m {\n             TokenTree::Sequence(_, ref seq) => for next_m in &seq.tts {\n@@ -390,8 +389,7 @@ fn nameize<I: Iterator<Item = NamedMatch>>(\n             TokenTree::MetaVarDecl(sp, bind_name, _) => {\n                 match ret_val.entry(bind_name) {\n                     Vacant(spot) => {\n-                        // FIXME(simulacrum): Don't construct Rc here\n-                        spot.insert(Rc::new(res.next().unwrap()));\n+                        spot.insert(res.next().unwrap());\n                     }\n                     Occupied(..) => {\n                         return Err((sp, format!(\"duplicated bind name: {}\", bind_name)))"}, {"sha": "c96290ce2709543b87a72e9823d8c09450bf67b9", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e022f87e7103fcb4b62ae32a467b92503abb178/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e022f87e7103fcb4b62ae32a467b92503abb178/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0e022f87e7103fcb4b62ae32a467b92503abb178", "patch": "@@ -308,7 +308,7 @@ pub fn compile(\n     let mut valid = true;\n \n     // Extract the arguments:\n-    let lhses = match *argument_map[&lhs_nm] {\n+    let lhses = match argument_map[&lhs_nm] {\n         MatchedSeq(ref s, _) => s\n             .iter()\n             .map(|m| {\n@@ -335,7 +335,7 @@ pub fn compile(\n         _ => sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\"),\n     };\n \n-    let rhses = match *argument_map[&rhs_nm] {\n+    let rhses = match argument_map[&rhs_nm] {\n         MatchedSeq(ref s, _) => s\n             .iter()\n             .map(|m| {"}, {"sha": "214e721fd1506dc838f2c0b28b19390f6271e774", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e022f87e7103fcb4b62ae32a467b92503abb178/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e022f87e7103fcb4b62ae32a467b92503abb178/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0e022f87e7103fcb4b62ae32a467b92503abb178", "patch": "@@ -12,7 +12,6 @@ use smallvec::{smallvec, SmallVec};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use std::mem;\n-use std::rc::Rc;\n \n /// An iterator over the token trees in a delimited token tree (`{ ... }`) or a sequence (`$(...)`).\n enum Frame {\n@@ -65,9 +64,9 @@ impl Iterator for Frame {\n /// `transcribe` would return a `TokenStream` containing `println!(\"{}\", stringify!(bar));`.\n ///\n /// Along the way, we do some additional error checking.\n-pub fn transcribe(\n+pub(super) fn transcribe(\n     cx: &ExtCtxt<'_>,\n-    interp: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interp: &FxHashMap<Ident, NamedMatch>,\n     src: Vec<quoted::TokenTree>,\n ) -> TokenStream {\n     // Nothing for us to transcribe...\n@@ -212,7 +211,7 @@ pub fn transcribe(\n                 // Find the matched nonterminal from the macro invocation, and use it to replace\n                 // the meta-var.\n                 if let Some(cur_matched) = lookup_cur_matched(ident, interp, &repeats) {\n-                    if let MatchedNonterminal(ref nt) = *cur_matched {\n+                    if let MatchedNonterminal(ref nt) = cur_matched {\n                         // FIXME #2887: why do we apply a mark when matching a token tree meta-var\n                         // (e.g. `$x:tt`), but not when we are matching any other type of token\n                         // tree?\n@@ -273,18 +272,17 @@ pub fn transcribe(\n /// See the definition of `repeats` in the `transcribe` function. `repeats` is used to descend\n /// into the right place in nested matchers. If we attempt to descend too far, the macro writer has\n /// made a mistake, and we return `None`.\n-fn lookup_cur_matched(\n+fn lookup_cur_matched<'a>(\n     ident: Ident,\n-    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: &'a FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n-) -> Option<Rc<NamedMatch>> {\n+) -> Option<&'a NamedMatch> {\n     interpolations.get(&ident).map(|matched| {\n-        let mut matched = matched.clone();\n+        let mut matched = matched;\n         for &(idx, _) in repeats {\n-            let m = matched.clone();\n-            match *m {\n+            match matched {\n                 MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads, _) => matched = Rc::new(ads[idx].clone()),\n+                MatchedSeq(ref ads, _) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -343,7 +341,7 @@ impl LockstepIterSize {\n /// multiple nested matcher sequences.\n fn lockstep_iter_size(\n     tree: &quoted::TokenTree,\n-    interpolations: &FxHashMap<Ident, Rc<NamedMatch>>,\n+    interpolations: &FxHashMap<Ident, NamedMatch>,\n     repeats: &[(usize, usize)],\n ) -> LockstepIterSize {\n     use quoted::TokenTree;\n@@ -360,7 +358,7 @@ fn lockstep_iter_size(\n         }\n         TokenTree::MetaVar(_, name) | TokenTree::MetaVarDecl(_, name, _) => {\n             match lookup_cur_matched(name, interpolations, repeats) {\n-                Some(matched) => match *matched {\n+                Some(matched) => match matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n                     MatchedSeq(ref ads, _) => LockstepIterSize::Constraint(ads.len(), name),\n                 },"}]}