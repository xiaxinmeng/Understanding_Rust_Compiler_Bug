{"sha": "95b3689b34035a0c3d7831441c1eae0904903351", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YjM2ODliMzQwMzVhMGMzZDc4MzE0NDFjMWVhZTA5MDQ5MDMzNTE=", "commit": {"author": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2013-08-05T17:15:55Z"}, "committer": {"name": "Stepan Koltsov", "email": "stepan.koltsov@gmail.com", "date": "2013-08-06T14:16:15Z"}, "message": "Implement FromStr for IpAddr and SocketAddr\n\nBetter than that in rt::uv::net, because it:\n\n* handles invalid input explicitly, without fail!()\n* parses socket address, not just IP\n* handles various ipv4-in-ipv6 addresses, like 2001:db8:122:344::192.0.2.33\n  (see http://tools.ietf.org/html/rfc6052 for example)\n* rejects output like `127.0000000.0.1`\n* does not allocate heap memory\n* have unit tests", "tree": {"sha": "edb16fafc8a0f2ae956adf2ce13ae703ea25c7ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/edb16fafc8a0f2ae956adf2ce13ae703ea25c7ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95b3689b34035a0c3d7831441c1eae0904903351", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95b3689b34035a0c3d7831441c1eae0904903351", "html_url": "https://github.com/rust-lang/rust/commit/95b3689b34035a0c3d7831441c1eae0904903351", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95b3689b34035a0c3d7831441c1eae0904903351/comments", "author": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "stepancheg", "id": 28969, "node_id": "MDQ6VXNlcjI4OTY5", "avatar_url": "https://avatars.githubusercontent.com/u/28969?v=4", "gravatar_id": "", "url": "https://api.github.com/users/stepancheg", "html_url": "https://github.com/stepancheg", "followers_url": "https://api.github.com/users/stepancheg/followers", "following_url": "https://api.github.com/users/stepancheg/following{/other_user}", "gists_url": "https://api.github.com/users/stepancheg/gists{/gist_id}", "starred_url": "https://api.github.com/users/stepancheg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/stepancheg/subscriptions", "organizations_url": "https://api.github.com/users/stepancheg/orgs", "repos_url": "https://api.github.com/users/stepancheg/repos", "events_url": "https://api.github.com/users/stepancheg/events{/privacy}", "received_events_url": "https://api.github.com/users/stepancheg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca6385034c1ca269b0b797fa039d485f7f413959", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca6385034c1ca269b0b797fa039d485f7f413959", "html_url": "https://github.com/rust-lang/rust/commit/ca6385034c1ca269b0b797fa039d485f7f413959"}], "stats": {"total": 365, "additions": 365, "deletions": 0}, "files": [{"sha": "81269d197d501ea6dc5dbd1b15b444fbe3fc8357", "filename": "src/libstd/rt/io/net/ip.rs", "status": "modified", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/95b3689b34035a0c3d7831441c1eae0904903351/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b3689b34035a0c3d7831441c1eae0904903351/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fnet%2Fip.rs?ref=95b3689b34035a0c3d7831441c1eae0904903351", "patch": "@@ -9,7 +9,11 @@\n // except according to those terms.\n \n use num::FromStrRadix;\n+use vec::MutableCloneableVector;\n use to_str::ToStr;\n+use from_str::FromStr;\n+use option::{Option, None, Some};\n+\n \n type Port = u16;\n \n@@ -73,3 +77,364 @@ impl ToStr for SocketAddr {\n         }\n     }\n }\n+\n+struct Parser<'self> {\n+    // parsing as ASCII, so can use byte array\n+    s: &'self [u8],\n+    pos: uint,\n+}\n+\n+impl<'self> Parser<'self> {\n+    fn new(s: &'self str) -> Parser<'self> {\n+        Parser {\n+            s: s.as_bytes(),\n+            pos: 0,\n+        }\n+    }\n+\n+    fn is_eof(&self) -> bool {\n+        self.pos == self.s.len()\n+    }\n+\n+    // Commit only if parser returns Some\n+    fn read_atomically<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+        let pos = self.pos;\n+        let r = cb(self);\n+        if r.is_none() {\n+            self.pos = pos;\n+        }\n+        r\n+    }\n+\n+    // Commit only if parser read till EOF\n+    fn read_till_eof<T>(&mut self, cb: &fn(&mut Parser) -> Option<T>) -> Option<T> {\n+        do self.read_atomically |p| {\n+            cb(p).filtered(|_| p.is_eof())\n+        }\n+    }\n+\n+    // Return result of first successful parser\n+    fn read_or<T>(&mut self, parsers: &[&fn(&mut Parser) -> Option<T>]) -> Option<T> {\n+        for pf in parsers.iter() {\n+            match self.read_atomically(|p: &mut Parser| (*pf)(p)) {\n+                Some(r) => return Some(r),\n+                None => {}\n+            }\n+        }\n+        None\n+    }\n+\n+    // Apply 3 parsers sequentially\n+    fn read_seq_3<A, B, C>(&mut self,\n+            pa: &fn(&mut Parser) -> Option<A>,\n+            pb: &fn(&mut Parser) -> Option<B>,\n+            pc: &fn(&mut Parser) -> Option<C>\n+        ) -> Option<(A, B, C)>\n+    {\n+        do self.read_atomically |p| {\n+            let a = pa(p);\n+            let b = if a.is_some() { pb(p) } else { None };\n+            let c = if b.is_some() { pc(p) } else { None };\n+            match (a, b, c) {\n+                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n+                _ => None\n+            }\n+        }\n+    }\n+\n+    // Read next char\n+    fn read_char(&mut self) -> Option<char> {\n+        if self.is_eof() {\n+            None\n+        } else {\n+            let r = self.s[self.pos] as char;\n+            self.pos += 1;\n+            Some(r)\n+        }\n+    }\n+\n+    // Return char and advance iff next char is equal to requested\n+    fn read_given_char(&mut self, c: char) -> Option<char> {\n+        do self.read_atomically |p| {\n+            p.read_char().filtered(|&next| next == c)\n+        }\n+    }\n+\n+    // Read digit\n+    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n+        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n+            // assuming radix is either 10 or 16\n+            if c >= '0' && c <= '9' {\n+                Some((c - '0') as u8)\n+            } else if radix > 10 && c >= 'a' && c < 'a' + (radix - 10) as char {\n+                Some((c - 'a' + (10 as char)) as u8)\n+            } else if radix > 10 && c >= 'A' && c < 'A' + (radix - 10) as char {\n+                Some((c - 'A' + (10 as char)) as u8)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        do self.read_atomically |p| {\n+            p.read_char().chain(|c| parse_digit(c, radix))\n+        }\n+    }\n+\n+    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        let mut r = 0u32;\n+        let mut digit_count = 0;\n+        loop {\n+            match self.read_digit(radix) {\n+                Some(d) => {\n+                    r = r * (radix as u32) + (d as u32);\n+                    digit_count += 1;\n+                    if digit_count > max_digits || r >= upto {\n+                        return None\n+                    }\n+                }\n+                None => {\n+                    if digit_count == 0 {\n+                        return None\n+                    } else {\n+                        return Some(r)\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n+    // Read number, failing if max_digits of number value exceeded\n+    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n+        do self.read_atomically |p| {\n+            p.read_number_impl(radix, max_digits, upto)\n+        }\n+    }\n+\n+    fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> {\n+        let mut bs = [0u8, ..4];\n+        let mut i = 0;\n+        while i < 4 {\n+            if i != 0 && self.read_given_char('.').is_none() {\n+                return None;\n+            }\n+\n+            let octet = self.read_number(10, 3, 0x100).map(|&n| n as u8);\n+            match octet {\n+                Some(d) => bs[i] = d,\n+                None => return None,\n+            };\n+            i += 1;\n+        }\n+        Some(Ipv4Addr(bs[0], bs[1], bs[2], bs[3]))\n+    }\n+\n+    // Read IPv4 address\n+    fn read_ipv4_addr(&mut self) -> Option<IpAddr> {\n+        do self.read_atomically |p| {\n+            p.read_ipv4_addr_impl()\n+        }\n+    }\n+\n+    fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> {\n+        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> IpAddr {\n+            assert!(head.len() + tail.len() <= 8);\n+            let mut gs = [0u16, ..8];\n+            gs.copy_from(head);\n+            gs.mut_slice(8 - tail.len(), 8).copy_from(tail);\n+            Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n+        }\n+\n+        fn read_groups(p: &mut Parser, groups: &mut [u16, ..8], limit: uint) -> (uint, bool) {\n+            let mut i = 0;\n+            while i < limit {\n+                if i < limit - 1 {\n+                    let ipv4 = do p.read_atomically |p| {\n+                        if i == 0 || p.read_given_char(':').is_some() {\n+                            p.read_ipv4_addr()\n+                        } else {\n+                            None\n+                        }\n+                    };\n+                    match ipv4 {\n+                        Some(Ipv4Addr(a, b, c, d)) => {\n+                            groups[i + 0] = (a as u16 << 8) | (b as u16);\n+                            groups[i + 1] = (c as u16 << 8) | (d as u16);\n+                            return (i + 2, true);\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                let group = do p.read_atomically |p| {\n+                    if i == 0 || p.read_given_char(':').is_some() {\n+                        p.read_number(16, 4, 0x10000).map(|&n| n as u16)\n+                    } else {\n+                        None\n+                    }\n+                };\n+                match group {\n+                    Some(g) => groups[i] = g,\n+                    None => return (i, false)\n+                }\n+                i += 1;\n+            }\n+            (i, false)\n+        }\n+\n+        let mut head = [0u16, ..8];\n+        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+\n+        if head_size == 8 {\n+            return Some(Ipv6Addr(\n+                head[0], head[1], head[2], head[3],\n+                head[4], head[5], head[6], head[7]))\n+        }\n+\n+        // IPv4 part is not allowed before `::`\n+        if head_ipv4 {\n+            return None\n+        }\n+\n+        // read `::` if previous code parsed less than 8 groups\n+        if !self.read_given_char(':').is_some() || !self.read_given_char(':').is_some() {\n+            return None;\n+        }\n+\n+        let mut tail = [0u16, ..8];\n+        let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n+        Some(ipv6_addr_from_head_tail(head.slice(0, head_size), tail.slice(0, tail_size)))\n+    }\n+\n+    fn read_ipv6_addr(&mut self) -> Option<IpAddr> {\n+        do self.read_atomically |p| {\n+            p.read_ipv6_addr_impl()\n+        }\n+    }\n+\n+    fn read_ip_addr(&mut self) -> Option<IpAddr> {\n+        let ipv4_addr = |p: &mut Parser| p.read_ipv4_addr();\n+        let ipv6_addr = |p: &mut Parser| p.read_ipv6_addr();\n+        self.read_or([ipv4_addr, ipv6_addr])\n+    }\n+\n+    fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n+        let ip_addr = |p: &mut Parser| {\n+            let ipv4_p = |p: &mut Parser| p.read_ip_addr();\n+            let ipv6_p = |p: &mut Parser| {\n+                let open_br = |p: &mut Parser| p.read_given_char('[');\n+                let ip_addr = |p: &mut Parser| p.read_ipv6_addr();\n+                let clos_br = |p: &mut Parser| p.read_given_char(']');\n+                p.read_seq_3::<char, IpAddr, char>(open_br, ip_addr, clos_br)\n+                        .map(|&t| match t { (_, ip, _) => ip })\n+            };\n+            p.read_or([ipv4_p, ipv6_p])\n+        };\n+        let colon = |p: &mut Parser| p.read_given_char(':');\n+        let port  = |p: &mut Parser| p.read_number(10, 5, 0x10000).map(|&n| n as u16);\n+\n+        // host, colon, port\n+        self.read_seq_3::<IpAddr, char, u16>(ip_addr, colon, port)\n+                .map(|&t| match t { (ip, _, port) => SocketAddr { ip: ip, port: port } })\n+    }\n+}\n+\n+impl FromStr for IpAddr {\n+    fn from_str(s: &str) -> Option<IpAddr> {\n+        do Parser::new(s).read_till_eof |p| {\n+            p.read_ip_addr()\n+        }\n+    }\n+}\n+\n+impl FromStr for SocketAddr {\n+    fn from_str(s: &str) -> Option<SocketAddr> {\n+        do Parser::new(s).read_till_eof |p| {\n+            p.read_socket_addr()\n+        }\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use from_str::FromStr;\n+    use option::{Some, None};\n+\n+    #[test]\n+    fn test_from_str_ipv4() {\n+        assert_eq!(Some(Ipv4Addr(127, 0, 0, 1)), FromStr::from_str(\"127.0.0.1\"));\n+        assert_eq!(Some(Ipv4Addr(255, 255, 255, 255)), FromStr::from_str(\"255.255.255.255\"));\n+        assert_eq!(Some(Ipv4Addr(0, 0, 0, 0)), FromStr::from_str(\"0.0.0.0\"));\n+\n+        // out of range\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"256.0.0.1\"));\n+        // too short\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0\"));\n+        // too long\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0.0.1.2\"));\n+        // no number between dots\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"255.0..1\"));\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv6() {\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"0:0:0:0:0:0:0:0\"));\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"0:0:0:0:0:0:0:1\"));\n+\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 1)), FromStr::from_str(\"::1\"));\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 0, 0)), FromStr::from_str(\"::\"));\n+\n+        assert_eq!(Some(Ipv6Addr(0x2a02, 0x6b8, 0, 0, 0, 0, 0x11, 0x11)),\n+                FromStr::from_str(\"2a02:6b8::11:11\"));\n+\n+        // too long group\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::00000\"));\n+        // too short\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7\"));\n+        // too long\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:3:4:5:6:7:8:9\"));\n+        // triple colon\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2:::6:7:8\"));\n+        // two double colons\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1:2::6::8\"));\n+    }\n+\n+    #[test]\n+    fn test_from_str_ipv4_in_ipv6() {\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0, 49152, 545)),\n+                FromStr::from_str(\"::192.0.2.33\"));\n+        assert_eq!(Some(Ipv6Addr(0, 0, 0, 0, 0, 0xFFFF, 49152, 545)),\n+                FromStr::from_str(\"::FFFF:192.0.2.33\"));\n+        assert_eq!(Some(Ipv6Addr(0x64, 0xff9b, 0, 0, 0, 0, 49152, 545)),\n+                FromStr::from_str(\"64:ff9b::192.0.2.33\"));\n+        assert_eq!(Some(Ipv6Addr(0x2001, 0xdb8, 0x122, 0xc000, 0x2, 0x2100, 49152, 545)),\n+                FromStr::from_str(\"2001:db8:122:c000:2:2100:192.0.2.33\"));\n+\n+        // colon after v4\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"::127.0.0.1:\"));\n+        // not enought groups\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:127.0.0.1\"));\n+        // too many groups\n+        assert_eq!(None, FromStr::from_str::<IpAddr>(\"1.2.3.4.5:6:7:127.0.0.1\"));\n+    }\n+\n+    #[test]\n+    fn test_from_str_socket_addr() {\n+        assert_eq!(Some(SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 80 }),\n+                FromStr::from_str(\"77.88.21.11:80\"));\n+        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 }),\n+                FromStr::from_str(\"[2a02:6b8:0:1::1]:53\"));\n+        assert_eq!(Some(SocketAddr { ip: Ipv6Addr(0, 0, 0, 0, 0, 0, 0x7F00, 1), port: 22 }),\n+                FromStr::from_str(\"[::127.0.0.1]:22\"));\n+\n+        // without port\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1\"));\n+        // without port\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:\"));\n+        // wrong brackets around v4\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"[127.0.0.1]:22\"));\n+        // port out of range\n+        assert_eq!(None, FromStr::from_str::<SocketAddr>(\"127.0.0.1:123456\"));\n+    }\n+}"}]}