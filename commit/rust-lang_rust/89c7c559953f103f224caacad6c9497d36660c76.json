{"sha": "89c7c559953f103f224caacad6c9497d36660c76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YzdjNTU5OTUzZjEwM2YyMjRjYWFjYWQ2Yzk0OTdkMzY2NjBjNzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-09T15:34:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-09T15:34:43Z"}, "message": "Merge #5270\n\n5270: Add argument count mismatch diagnostic r=matklad a=jonas-schievink\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/4025.\r\n\r\nThis currently has one false positive on this line, where `max` is resolved to `Iterator::max` instead of `Ord::max`:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/8aa10c00a4c5b957d459fac5a103cd9688e8dcdd/crates/expect/src/lib.rs#L263\r\n\r\n(I have no idea why it thinks that `usize` is an `Iterator`)\r\n\r\nTODO:\r\n* [x] Tests\r\n* [x] Improve diagnostic text for method calls\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>", "tree": {"sha": "fff7cbf2b489053af801e075c51288d7d7d6afca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fff7cbf2b489053af801e075c51288d7d7d6afca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89c7c559953f103f224caacad6c9497d36660c76", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfBzkTCRBK7hj4Ov3rIwAAdHIIAJgYiM36boLLDeuk91WHx2q0\nm7qG0H2eKMpIKHfkZGvNyrLTaLWtqPfDKo2lFrlayjpExS9pu5Yi5l5JqCk2taC2\n7sAFCPQsIhZOVV5Bma9YoZMNBxsqxAbO3qTsHfnKY6PddMXz5wazHUOxM0mhOAb5\nJtgUUt7pwGe1eXSScce7vk+L/xJktcRElo6hxMyzYYe7Do45IPLRpOBuE+qmRZiz\n44wM1dbOR1iNLGA8RYtlC9j/yVN/3hTs4Lw4pqdVhDLfC5x9wLb8dqf1vN3SxHyP\n/An6Vavqw2I5MzsPkt2ZpG698UWaD/BJniW4nRsIxA9Vum8lCRTGHZG8L/okZ+w=\n=Z9Cj\n-----END PGP SIGNATURE-----\n", "payload": "tree fff7cbf2b489053af801e075c51288d7d7d6afca\nparent f1d084fbd9504497aed24b907b03247bfcd31675\nparent f4a9d9a00f0462bce92ddbac24cb91825c8ab192\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1594308883 +0000\ncommitter GitHub <noreply@github.com> 1594308883 +0000\n\nMerge #5270\n\n5270: Add argument count mismatch diagnostic r=matklad a=jonas-schievink\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/4025.\r\n\r\nThis currently has one false positive on this line, where `max` is resolved to `Iterator::max` instead of `Ord::max`:\r\n\r\nhttps://github.com/rust-analyzer/rust-analyzer/blob/8aa10c00a4c5b957d459fac5a103cd9688e8dcdd/crates/expect/src/lib.rs#L263\r\n\r\n(I have no idea why it thinks that `usize` is an `Iterator`)\r\n\r\nTODO:\r\n* [x] Tests\r\n* [x] Improve diagnostic text for method calls\n\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89c7c559953f103f224caacad6c9497d36660c76", "html_url": "https://github.com/rust-lang/rust/commit/89c7c559953f103f224caacad6c9497d36660c76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89c7c559953f103f224caacad6c9497d36660c76/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1d084fbd9504497aed24b907b03247bfcd31675", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1d084fbd9504497aed24b907b03247bfcd31675", "html_url": "https://github.com/rust-lang/rust/commit/f1d084fbd9504497aed24b907b03247bfcd31675"}, {"sha": "f4a9d9a00f0462bce92ddbac24cb91825c8ab192", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4a9d9a00f0462bce92ddbac24cb91825c8ab192", "html_url": "https://github.com/rust-lang/rust/commit/f4a9d9a00f0462bce92ddbac24cb91825c8ab192"}], "stats": {"total": 244, "additions": 230, "deletions": 14}, "files": [{"sha": "752edddd69623f1d2ed4b54a286700400e90468e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89c7c559953f103f224caacad6c9497d36660c76/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/89c7c559953f103f224caacad6c9497d36660c76/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=89c7c559953f103f224caacad6c9497d36660c76", "patch": "@@ -1104,6 +1104,7 @@ dependencies = [\n  \"chalk-ir\",\n  \"chalk-solve\",\n  \"ena\",\n+ \"expect\",\n  \"insta\",\n  \"itertools\",\n  \"log\","}, {"sha": "11a0ecb8b23136258725045169c06e62c30381f0", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=89c7c559953f103f224caacad6c9497d36660c76", "patch": "@@ -1,4 +1,6 @@\n //! FIXME: write short doc here\n pub use hir_def::diagnostics::UnresolvedModule;\n pub use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-pub use hir_ty::diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField};\n+pub use hir_ty::diagnostics::{\n+    MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField,\n+};"}, {"sha": "ce257dc0bb58d6d295261d6fda9c297139e06090", "filename": "crates/ra_hir_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2FCargo.toml?ref=89c7c559953f103f224caacad6c9497d36660c76", "patch": "@@ -32,3 +32,4 @@ chalk-ir = { version = \"0.15.0\" }\n \n [dev-dependencies]\n insta = \"0.16.0\"\n+expect = { path = \"../expect\" }"}, {"sha": "5b0dda634f5f4d86096b9bc7859073f83c96941f", "filename": "crates/ra_hir_ty/src/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fdiagnostics.rs?ref=89c7c559953f103f224caacad6c9497d36660c76", "patch": "@@ -197,3 +197,33 @@ impl AstDiagnostic for MissingUnsafe {\n         ast::Expr::cast(node).unwrap()\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct MismatchedArgCount {\n+    pub file: HirFileId,\n+    pub call_expr: AstPtr<ast::Expr>,\n+    pub expected: usize,\n+    pub found: usize,\n+}\n+\n+impl Diagnostic for MismatchedArgCount {\n+    fn message(&self) -> String {\n+        let s = if self.expected == 1 { \"\" } else { \"s\" };\n+        format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n+    }\n+    fn source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile { file_id: self.file, value: self.call_expr.clone().into() }\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}\n+\n+impl AstDiagnostic for MismatchedArgCount {\n+    type AST = ast::CallExpr;\n+    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n+        let root = db.parse_or_expand(self.source().file_id).unwrap();\n+        let node = self.source().value.to_node(&root);\n+        ast::CallExpr::cast(node).unwrap()\n+    }\n+}"}, {"sha": "6f34aaf170c28d842199571d7132ba1e1c3f8c50", "filename": "crates/ra_hir_ty/src/expr.rs", "status": "modified", "additions": 195, "deletions": 5, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fexpr.rs?ref=89c7c559953f103f224caacad6c9497d36660c76", "patch": "@@ -9,9 +9,11 @@ use rustc_hash::FxHashSet;\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{MissingFields, MissingMatchArms, MissingOkInTailExpr, MissingPatFields},\n+    diagnostics::{\n+        MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, MissingPatFields,\n+    },\n     utils::variant_data,\n-    ApplicationTy, InferenceResult, Ty, TypeCtor,\n+    ApplicationTy, CallableDef, InferenceResult, Ty, TypeCtor,\n     _match::{is_useful, MatchCheckCtx, Matrix, PatStack, Usefulness},\n };\n \n@@ -24,7 +26,8 @@ pub use hir_def::{\n         ArithOp, Array, BinaryOp, BindingAnnotation, CmpOp, Expr, ExprId, Literal, LogicOp,\n         MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement, UnaryOp,\n     },\n-    LocalFieldId, VariantId,\n+    src::HasSource,\n+    LocalFieldId, Lookup, VariantId,\n };\n \n pub struct ExprValidator<'a, 'b: 'a> {\n@@ -56,8 +59,15 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n                     missed_fields,\n                 );\n             }\n-            if let Expr::Match { expr, arms } = expr {\n-                self.validate_match(id, *expr, arms, db, self.infer.clone());\n+\n+            match expr {\n+                Expr::Match { expr, arms } => {\n+                    self.validate_match(id, *expr, arms, db, self.infer.clone());\n+                }\n+                Expr::Call { .. } | Expr::MethodCall { .. } => {\n+                    self.validate_call(db, id, expr);\n+                }\n+                _ => {}\n             }\n         }\n         for (id, pat) in body.pats.iter() {\n@@ -138,6 +148,68 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n+    fn validate_call(&mut self, db: &dyn HirDatabase, call_id: ExprId, expr: &Expr) -> Option<()> {\n+        // Check that the number of arguments matches the number of parameters.\n+\n+        // FIXME: Due to shortcomings in the current type system implementation, only emit this\n+        // diagnostic if there are no type mismatches in the containing function.\n+        if self.infer.type_mismatches.iter().next().is_some() {\n+            return Some(());\n+        }\n+\n+        let is_method_call = matches!(expr, Expr::MethodCall { .. });\n+        let (callee, args) = match expr {\n+            Expr::Call { callee, args } => {\n+                let callee = &self.infer.type_of_expr[*callee];\n+                let (callable, _) = callee.as_callable()?;\n+                let callee = match callable {\n+                    CallableDef::FunctionId(func) => func,\n+\n+                    // FIXME: Handle tuple struct/variant constructor calls.\n+                    _ => return None,\n+                };\n+\n+                (callee, args.clone())\n+            }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                let callee = self.infer.method_resolution(call_id)?;\n+                let mut args = args.clone();\n+                args.insert(0, *receiver);\n+                (callee, args)\n+            }\n+            _ => return None,\n+        };\n+\n+        let loc = callee.lookup(db.upcast());\n+        let ast = loc.source(db.upcast());\n+        let params = ast.value.param_list()?;\n+\n+        let mut param_count = params.params().count();\n+        let mut arg_count = args.len();\n+\n+        if params.self_param().is_some() {\n+            param_count += 1;\n+        }\n+\n+        if arg_count != param_count {\n+            let (_, source_map) = db.body_with_source_map(self.func.into());\n+            if let Ok(source_ptr) = source_map.expr_syntax(call_id) {\n+                if is_method_call {\n+                    param_count -= 1;\n+                    arg_count -= 1;\n+                }\n+                self.sink.push(MismatchedArgCount {\n+                    file: source_ptr.file_id,\n+                    call_expr: source_ptr.value,\n+                    expected: param_count,\n+                    found: arg_count,\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn validate_match(\n         &mut self,\n         id: ExprId,\n@@ -312,3 +384,121 @@ pub fn record_pattern_missing_fields(\n     }\n     Some((variant_def, missed_fields, exhaustive))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect::{expect, Expect};\n+    use ra_db::fixture::WithFixture;\n+\n+    use crate::{diagnostics::MismatchedArgCount, test_db::TestDB};\n+\n+    fn check_diagnostic(ra_fixture: &str, expect: Expect) {\n+        let msg = TestDB::with_single_file(ra_fixture).0.diagnostic::<MismatchedArgCount>().0;\n+        expect.assert_eq(&msg);\n+    }\n+\n+    fn check_no_diagnostic(ra_fixture: &str) {\n+        let (s, diagnostic_count) =\n+            TestDB::with_single_file(ra_fixture).0.diagnostic::<MismatchedArgCount>();\n+\n+        assert_eq!(0, diagnostic_count, \"expected no diagnostic, found one: {}\", s);\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_zero() {\n+        check_diagnostic(\n+            r\"\n+            fn zero() {}\n+            fn f() { zero(1); }\n+            \",\n+            expect![[\"\\\"zero(1)\\\": Expected 0 arguments, found 1\\n\"]],\n+        );\n+\n+        check_no_diagnostic(\n+            r\"\n+            fn zero() {}\n+            fn f() { zero(); }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn simple_free_fn_one() {\n+        check_diagnostic(\n+            r\"\n+            fn one(arg: u8) {}\n+            fn f() { one(); }\n+            \",\n+            expect![[\"\\\"one()\\\": Expected 1 argument, found 0\\n\"]],\n+        );\n+\n+        check_no_diagnostic(\n+            r\"\n+            fn one(arg: u8) {}\n+            fn f() { one(1); }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_as_fn() {\n+        check_diagnostic(\n+            r\"\n+            struct S;\n+            impl S {\n+                fn method(&self) {}\n+            }\n+\n+            fn f() {\n+                S::method();\n+            }\n+            \",\n+            expect![[\"\\\"S::method()\\\": Expected 1 argument, found 0\\n\"]],\n+        );\n+\n+        check_no_diagnostic(\n+            r\"\n+            struct S;\n+            impl S {\n+                fn method(&self) {}\n+            }\n+\n+            fn f() {\n+                S::method(&S);\n+                S.method();\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn method_with_arg() {\n+        check_diagnostic(\n+            r\"\n+            struct S;\n+            impl S {\n+                fn method(&self, arg: u8) {}\n+            }\n+\n+            fn f() {\n+                S.method();\n+            }\n+            \",\n+            expect![[\"\\\"S.method()\\\": Expected 1 argument, found 0\\n\"]],\n+        );\n+\n+        check_no_diagnostic(\n+            r\"\n+            struct S;\n+            impl S {\n+                fn method(&self, arg: u8) {}\n+            }\n+\n+            fn f() {\n+                S::method(&S, 0);\n+                S.method(1);\n+            }\n+            \",\n+        );\n+    }\n+}"}, {"sha": "e69e9b4ec595e0d845b4121004da6b71482f2f43", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89c7c559953f103f224caacad6c9497d36660c76/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=89c7c559953f103f224caacad6c9497d36660c76", "patch": "@@ -99,14 +99,6 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             fix,\n         })\n     })\n-    .on::<hir::diagnostics::MissingMatchArms, _>(|d| {\n-        res.borrow_mut().push(Diagnostic {\n-            range: sema.diagnostics_range(d).range,\n-            message: d.message(),\n-            severity: Severity::Error,\n-            fix: None,\n-        })\n-    })\n     .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n         let node = d.ast(db);\n         let replacement = format!(\"Ok({})\", node.syntax());"}]}