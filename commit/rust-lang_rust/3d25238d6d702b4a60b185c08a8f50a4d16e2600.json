{"sha": "3d25238d6d702b4a60b185c08a8f50a4d16e2600", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMjUyMzhkNmQ3MDJiNGE2MGIxODVjMDhhOGY1MGE0ZDE2ZTI2MDA=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-06-25T15:37:03Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-06-25T15:37:03Z"}, "message": "fixed some clippy warnings in compiletest", "tree": {"sha": "9bccefa1c193ed43793bef221953e30069e7cf71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bccefa1c193ed43793bef221953e30069e7cf71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d25238d6d702b4a60b185c08a8f50a4d16e2600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d25238d6d702b4a60b185c08a8f50a4d16e2600", "html_url": "https://github.com/rust-lang/rust/commit/3d25238d6d702b4a60b185c08a8f50a4d16e2600", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d25238d6d702b4a60b185c08a8f50a4d16e2600/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc9822af2eb8f59300354fd7c9336aa1f78304a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc9822af2eb8f59300354fd7c9336aa1f78304a1", "html_url": "https://github.com/rust-lang/rust/commit/bc9822af2eb8f59300354fd7c9336aa1f78304a1"}], "stats": {"total": 172, "additions": 79, "deletions": 93}, "files": [{"sha": "0b9b9599be6035388836cb34dd309f9b8f1063a2", "filename": "src/tools/compiletest/src/errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Ferrors.rs?ref=3d25238d6d702b4a60b185c08a8f50a4d16e2600", "patch": "@@ -35,7 +35,7 @@ impl FromStr for ErrorKind {\n             \"ERROR\" => Ok(ErrorKind::Error),\n             \"NOTE\" => Ok(ErrorKind::Note),\n             \"SUGGESTION\" => Ok(ErrorKind::Suggestion),\n-            \"WARN\" => Ok(ErrorKind::Warning),\n+            \"WARN\" |\n             \"WARNING\" => Ok(ErrorKind::Warning),\n             _ => Err(()),\n         }\n@@ -95,7 +95,7 @@ pub fn load_errors(testfile: &Path, cfg: Option<&str>) -> Vec<Error> {\n \n     let tag = match cfg {\n         Some(rev) => format!(\"//[{}]~\", rev),\n-        None => format!(\"//~\"),\n+        None => \"//~\".to_string(),\n     };\n \n     rdr.lines()\n@@ -153,7 +153,7 @@ fn parse_expected(last_nonfollow_error: Option<usize>,\n     let msg = msg.trim().to_owned();\n \n     let (which, line_num) = if follow {\n-        assert!(adjusts == 0, \"use either //~| or //~^, not both.\");\n+        assert_eq!(adjusts, 0, \"use either //~| or //~^, not both.\");\n         let line_num = last_nonfollow_error.expect(\"encountered //~| without \\\n                                                     preceding //~^ line.\");\n         (FollowPrevious(line_num), line_num)"}, {"sha": "ce33787a7d3e0b797b0361ea8d64c2eff1f7408b", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=3d25238d6d702b4a60b185c08a8f50a4d16e2600", "patch": "@@ -258,7 +258,7 @@ impl TestProps {\n             check_stdout: false,\n             no_prefer_dynamic: false,\n             pretty_expanded: false,\n-            pretty_mode: format!(\"normal\"),\n+            pretty_mode: \"normal\".to_string(),\n             pretty_compare_only: false,\n             forbid_output: vec![],\n             incremental_dir: None,\n@@ -381,14 +381,11 @@ impl TestProps {\n             }\n         });\n \n-        for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n-            match env::var(key) {\n-                Ok(val) => {\n-                    if self.exec_env.iter().find(|&&(ref x, _)| *x == key).is_none() {\n-                        self.exec_env.push((key.to_owned(), val))\n-                    }\n+        for key in &[\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n+            if let Ok(val) = env::var(key) {\n+                if self.exec_env.iter().find(|&&(ref x, _)| x == key).is_none() {\n+                    self.exec_env.push(((*key).to_owned(), val))\n                 }\n-                Err(..) => {}\n             }\n         }\n     }\n@@ -409,7 +406,7 @@ fn iter_header(testfile: &Path, cfg: Option<&str>, it: &mut FnMut(&str)) {\n             return;\n         } else if ln.starts_with(\"//[\") {\n             // A comment like `//[foo]` is specific to revision `foo`\n-            if let Some(close_brace) = ln.find(\"]\") {\n+            if let Some(close_brace) = ln.find(']') {\n                 let lncfg = &ln[3..close_brace];\n                 let matches = match cfg {\n                     Some(s) => s == &lncfg[..],\n@@ -521,12 +518,10 @@ impl Config {\n     fn parse_pp_exact(&self, line: &str, testfile: &Path) -> Option<PathBuf> {\n         if let Some(s) = self.parse_name_value_directive(line, \"pp-exact\") {\n             Some(PathBuf::from(&s))\n+        } else if self.parse_name_directive(line, \"pp-exact\") {\n+            testfile.file_name().map(PathBuf::from)\n         } else {\n-            if self.parse_name_directive(line, \"pp-exact\") {\n-                testfile.file_name().map(PathBuf::from)\n-            } else {\n-                None\n-            }\n+            None\n         }\n     }\n \n@@ -555,8 +550,8 @@ pub fn lldb_version_to_int(version_string: &str) -> isize {\n     let error_string = format!(\"Encountered LLDB version string with unexpected format: {}\",\n                                version_string);\n     let error_string = error_string;\n-    let major: isize = version_string.parse().ok().expect(&error_string);\n-    return major;\n+    let major: isize = version_string.parse().expect(&error_string);\n+    major\n }\n \n fn expand_variables(mut value: String, config: &Config) -> String {"}, {"sha": "23782c3ccc9bb62661850220a5b3829d0bba903d", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=3d25238d6d702b4a60b185c08a8f50a4d16e2600", "patch": "@@ -65,7 +65,7 @@ pub fn parse_output(file_name: &str, output: &str, proc_res: &ProcRes) -> Vec<Er\n fn parse_line(file_name: &str, line: &str, output: &str, proc_res: &ProcRes) -> Vec<Error> {\n     // The compiler sometimes intermingles non-JSON stuff into the\n     // output.  This hack just skips over such lines. Yuck.\n-    if line.chars().next() == Some('{') {\n+    if line.starts_with('{') {\n         match json::decode::<Diagnostic>(line) {\n             Ok(diagnostic) => {\n                 let mut expected_errors = vec![];"}, {"sha": "692e31ebad0507deb2fc51eb5a6f21a001e32be8", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=3d25238d6d702b4a60b185c08a8f50a4d16e2600", "patch": "@@ -168,7 +168,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         src_base: opt_path(matches, \"src-base\"),\n         build_base: opt_path(matches, \"build-base\"),\n         stage_id: matches.opt_str(\"stage-id\").unwrap(),\n-        mode: matches.opt_str(\"mode\").unwrap().parse().ok().expect(\"invalid mode\"),\n+        mode: matches.opt_str(\"mode\").unwrap().parse().expect(\"invalid mode\"),\n         run_ignored: matches.opt_present(\"ignored\"),\n         filter: matches.free.first().cloned(),\n         filter_exact: matches.opt_present(\"exact\"),\n@@ -208,7 +208,7 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n \n pub fn log_config(config: &Config) {\n     let c = config;\n-    logv(c, format!(\"configuration:\"));\n+    logv(c, \"configuration:\".to_string());\n     logv(c, format!(\"compile_lib_path: {:?}\", config.compile_lib_path));\n     logv(c, format!(\"run_lib_path: {:?}\", config.run_lib_path));\n     logv(c, format!(\"rustc_path: {:?}\", config.rustc_path.display()));\n@@ -238,10 +238,10 @@ pub fn log_config(config: &Config) {\n                     config.adb_device_status));\n     logv(c, format!(\"verbose: {}\", config.verbose));\n     logv(c, format!(\"quiet: {}\", config.quiet));\n-    logv(c, format!(\"\\n\"));\n+    logv(c, \"\\n\".to_string());\n }\n \n-pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n+pub fn opt_str(maybestr: &Option<String>) -> &str {\n     match *maybestr {\n         None => \"(none)\",\n         Some(ref s) => s,\n@@ -465,11 +465,9 @@ pub fn make_test(config: &Config, testpaths: &TestPaths) -> test::TestDescAndFn\n     };\n \n     // Debugging emscripten code doesn't make sense today\n-    let mut ignore = early_props.ignore || !up_to_date(config, testpaths, &early_props);\n-    if (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb) &&\n-        config.target.contains(\"emscripten\") {\n-        ignore = true;\n-    }\n+    let ignore = early_props.ignore || !up_to_date(config, testpaths, &early_props) ||\n+                 (config.mode == DebugInfoGdb || config.mode == DebugInfoLldb) &&\n+                  config.target.contains(\"emscripten\");\n \n     test::TestDescAndFn {\n         desc: test::TestDesc {\n@@ -487,7 +485,7 @@ fn stamp(config: &Config, testpaths: &TestPaths) -> PathBuf {\n                                            .to_str().unwrap(),\n                              config.stage_id);\n     config.build_base.canonicalize()\n-          .unwrap_or(config.build_base.clone())\n+          .unwrap_or_else(|_| config.build_base.clone())\n           .join(stamp_name)\n }\n \n@@ -512,7 +510,7 @@ fn up_to_date(config: &Config, testpaths: &TestPaths, props: &EarlyProps) -> boo\n fn mtime(path: &Path) -> FileTime {\n     fs::metadata(path).map(|f| {\n         FileTime::from_last_modification_time(&f)\n-    }).unwrap_or(FileTime::zero())\n+    }).unwrap_or_else(|_| FileTime::zero())\n }\n \n pub fn make_test_name(config: &Config, testpaths: &TestPaths) -> test::TestName {\n@@ -560,7 +558,7 @@ fn analyze_gdb(gdb: Option<String>) -> (Option<String>, Option<u32>, bool) {\n \n     let gdb_native_rust = version.map_or(false, |v| v >= MIN_GDB_WITH_RUST);\n \n-    return (Some(gdb.to_owned()), version, gdb_native_rust);\n+    (Some(gdb.to_owned()), version, gdb_native_rust)\n }\n \n fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n@@ -600,7 +598,7 @@ fn extract_gdb_version(full_version_line: &str) -> Option<u32> {\n             Some(idx) => if line.as_bytes()[idx] == b'.' {\n                 let patch = &line[idx + 1..];\n \n-                let patch_len = patch.find(|c: char| !c.is_digit(10)).unwrap_or(patch.len());\n+                let patch_len = patch.find(|c: char| !c.is_digit(10)).unwrap_or_else(|| patch.len());\n                 let patch = &patch[..patch_len];\n                 let patch = if patch_len > 3 || patch_len == 0 { None } else { Some(patch) };\n "}, {"sha": "35f6ed243fecc51157616daf67b7810c744010b3", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=3d25238d6d702b4a60b185c08a8f50a4d16e2600", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use std::env;\n-use std::ffi::OsString;\n use std::io::prelude::*;\n use std::io;\n use std::path::PathBuf;\n@@ -31,7 +30,7 @@ fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n     // Need to be sure to put both the lib_path and the aux path in the dylib\n     // search path for the child.\n     let var = dylib_env_var();\n-    let mut path = env::split_paths(&env::var_os(var).unwrap_or(OsString::new()))\n+    let mut path = env::split_paths(&env::var_os(var).unwrap_or_default())\n         .collect::<Vec<_>>();\n     if let Some(p) = aux_path {\n         path.insert(0, PathBuf::from(p))"}, {"sha": "bb8591ef1fe4d439b4159c1a3e95648e7c3f3b0e", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 52, "deletions": 58, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d25238d6d702b4a60b185c08a8f50a4d16e2600/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=3d25238d6d702b4a60b185c08a8f50a4d16e2600", "patch": "@@ -68,7 +68,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n     } else {\n         for revision in &base_props.revisions {\n             let mut revision_props = base_props.clone();\n-            revision_props.load_from(&testpaths.file, Some(&revision), &config);\n+            revision_props.load_from(&testpaths.file, Some(revision), &config);\n             let rev_cx = TestCx {\n                 config: &config,\n                 props: &revision_props,\n@@ -81,7 +81,7 @@ pub fn run(config: Config, testpaths: &TestPaths) {\n \n     base_cx.complete_all();\n \n-    File::create(::stamp(&config, &testpaths)).unwrap();\n+    File::create(::stamp(&config, testpaths)).unwrap();\n }\n \n struct TestCx<'test> {\n@@ -101,17 +101,16 @@ impl<'test> TestCx<'test> {\n     /// invoked once before any revisions have been processed\n     fn init_all(&self) {\n         assert!(self.revision.is_none(), \"init_all invoked for a revision\");\n-        match self.config.mode {\n-            Incremental => self.init_incremental_test(),\n-            _ => { }\n+        if let Incremental = self.config.mode {\n+            self.init_incremental_test()\n         }\n     }\n \n     /// Code executed for each revision in turn (or, if there are no\n     /// revisions, exactly once, with revision == None).\n     fn run_revision(&self) {\n         match self.config.mode {\n-            CompileFail => self.run_cfail_test(),\n+            CompileFail |\n             ParseFail => self.run_cfail_test(),\n             RunFail => self.run_rfail_test(),\n             RunPass => self.run_rpass_test(),\n@@ -352,10 +351,10 @@ impl<'test> TestCx<'test> {\n                             aux_dir.to_str().unwrap().to_owned()];\n         args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n         args.extend(self.props.compile_flags.iter().cloned());\n-        return ProcArgs {\n+        ProcArgs {\n             prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n             args: args,\n-        };\n+        }\n     }\n \n     fn compare_source(&self,\n@@ -407,17 +406,17 @@ actual:\\n\\\n                             aux_dir.to_str().unwrap().to_owned()];\n         if let Some(revision) = self.revision {\n             args.extend(vec![\n-                format!(\"--cfg\"),\n-                format!(\"{}\", revision),\n+                \"--cfg\".to_string(),\n+                revision.to_string(),\n             ]);\n         }\n         args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n         args.extend(self.props.compile_flags.iter().cloned());\n         // FIXME (#9639): This needs to handle non-utf8 paths\n-        return ProcArgs {\n+        ProcArgs {\n             prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n             args: args,\n-        };\n+        }\n     }\n \n     fn run_debuginfo_gdb_test(&self) {\n@@ -708,7 +707,7 @@ actual:\\n\\\n             }\n         }\n \n-        return None;\n+        None\n     }\n \n     fn run_debuginfo_lldb_test(&self) {\n@@ -875,13 +874,13 @@ actual:\\n\\\n                     for &(ref command_directive, ref check_directive) in &directives {\n                         self.config.parse_name_value_directive(\n                             &line,\n-                            &command_directive).map(|cmd| {\n+                            command_directive).map(|cmd| {\n                                 commands.push(cmd)\n                             });\n \n                         self.config.parse_name_value_directive(\n                             &line,\n-                            &check_directive).map(|cmd| {\n+                            check_directive).map(|cmd| {\n                                 check_lines.push(cmd)\n                             });\n                     }\n@@ -962,8 +961,7 @@ actual:\\n\\\n                 (line, 0)\n             };\n \n-            for fragment_index in first_fragment .. check_fragments.len() {\n-                let current_fragment = check_fragments[fragment_index];\n+            for current_fragment in &check_fragments[first_fragment..] {\n                 match rest.find(current_fragment) {\n                     Some(pos) => {\n                         rest = &rest[pos + current_fragment.len() .. ];\n@@ -976,7 +974,7 @@ actual:\\n\\\n                 return false;\n             }\n \n-            return true;\n+            true\n         }\n     }\n \n@@ -1059,7 +1057,7 @@ actual:\\n\\\n         let expect_note = expected_errors.iter().any(|ee| ee.kind == Some(ErrorKind::Note));\n \n         // Parse the JSON output from the compiler and extract out the messages.\n-        let actual_errors = json::parse_output(&file_name, &proc_res.stderr, &proc_res);\n+        let actual_errors = json::parse_output(&file_name, &proc_res.stderr, proc_res);\n         let mut unexpected = Vec::new();\n         let mut found = vec![false; expected_errors.len()];\n         for actual_error in &actual_errors {\n@@ -1092,7 +1090,7 @@ actual:\\n\\\n                                      .map_or(String::from(\"message\"),\n                                              |k| k.to_string()),\n                                      actual_error.msg));\n-                        unexpected.push(actual_error.clone());\n+                        unexpected.push(actual_error);\n                     }\n                 }\n             }\n@@ -1110,20 +1108,20 @@ actual:\\n\\\n                              .map_or(\"message\".into(),\n                                      |k| k.to_string()),\n                              expected_error.msg));\n-                not_found.push(expected_error.clone());\n+                not_found.push(expected_error);\n             }\n         }\n \n-        if unexpected.len() > 0 || not_found.len() > 0 {\n+        if !unexpected.is_empty() || !not_found.is_empty() {\n             self.error(\n                 &format!(\"{} unexpected errors found, {} expected errors not found\",\n                          unexpected.len(), not_found.len()));\n-            print!(\"status: {}\\ncommand: {}\\n\",\n+            println!(\"status: {}\\ncommand: {}\",\n                    proc_res.status, proc_res.cmdline);\n-            if unexpected.len() > 0 {\n+            if !unexpected.is_empty() {\n                 println!(\"unexpected errors (from JSON output): {:#?}\\n\", unexpected);\n             }\n-            if not_found.len() > 0 {\n+            if !not_found.is_empty() {\n                 println!(\"not found errors (from test file): {:#?}\\n\", not_found);\n             }\n             panic!();\n@@ -1142,9 +1140,9 @@ actual:\\n\\\n         match actual_error.kind {\n             Some(ErrorKind::Help) => expect_help,\n             Some(ErrorKind::Note) => expect_note,\n-            Some(ErrorKind::Error) => true,\n+            Some(ErrorKind::Error) |\n             Some(ErrorKind::Warning) => true,\n-            Some(ErrorKind::Suggestion) => false,\n+            Some(ErrorKind::Suggestion) |\n             None => false\n         }\n     }\n@@ -1287,7 +1285,8 @@ actual:\\n\\\n                                                      self.config);\n             let mut crate_type = if aux_props.no_prefer_dynamic {\n                 Vec::new()\n-            } else {\n+            } else if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n+                      self.config.target.contains(\"emscripten\") {\n                 // We primarily compile all auxiliary libraries as dynamic libraries\n                 // to avoid code size bloat and large binaries as much as possible\n                 // for the test suite (otherwise including libstd statically in all\n@@ -1297,13 +1296,9 @@ actual:\\n\\\n                 // dynamic libraries so we just go back to building a normal library. Note,\n                 // however, that for MUSL if the library is built with `force_host` then\n                 // it's ok to be a dylib as the host should always support dylibs.\n-                if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n-                    self.config.target.contains(\"emscripten\")\n-                {\n-                    vec![\"--crate-type=lib\".to_owned()]\n-                } else {\n-                    vec![\"--crate-type=dylib\".to_owned()]\n-                }\n+                vec![\"--crate-type=lib\".to_owned()]\n+            } else {\n+                vec![\"--crate-type=dylib\".to_owned()]\n             };\n             crate_type.extend(extra_link_args.clone());\n             let aux_output = {\n@@ -1344,7 +1339,7 @@ actual:\\n\\\n                        lib_path: &str,\n                        aux_path: Option<&str>,\n                        input: Option<String>) -> ProcRes {\n-        return self.program_output(lib_path, prog, aux_path, args, procenv, input);\n+        self.program_output(lib_path, prog, aux_path, args, procenv, input)\n     }\n \n     fn make_compile_args(&self,\n@@ -1367,7 +1362,7 @@ actual:\\n\\\n         // Optionally prevent default --target if specified in test compile-flags.\n         let custom_target = self.props.compile_flags\n             .iter()\n-            .fold(false, |acc, ref x| acc || x.starts_with(\"--target\"));\n+            .fold(false, |acc, x| acc || x.starts_with(\"--target\"));\n \n         if !custom_target {\n             args.extend(vec![\n@@ -1377,14 +1372,14 @@ actual:\\n\\\n \n         if let Some(revision) = self.revision {\n             args.extend(vec![\n-                format!(\"--cfg\"),\n-                format!(\"{}\", revision),\n+                \"--cfg\".to_string(),\n+                revision.to_string(),\n             ]);\n         }\n \n         if let Some(ref incremental_dir) = self.props.incremental_dir {\n             args.extend(vec![\n-                format!(\"-Z\"),\n+                \"-Z\".to_string(),\n                 format!(\"incremental={}\", incremental_dir.display()),\n             ]);\n         }\n@@ -1457,10 +1452,10 @@ actual:\\n\\\n             args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n         }\n         args.extend(self.props.compile_flags.iter().cloned());\n-        return ProcArgs {\n+        ProcArgs {\n             prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n             args: args,\n-        };\n+        }\n     }\n \n     fn make_lib_name(&self, auxfile: &Path) -> PathBuf {\n@@ -1508,10 +1503,10 @@ actual:\\n\\\n         args.extend(self.split_maybe_args(&self.props.run_flags));\n \n         let prog = args.remove(0);\n-        return ProcArgs {\n+         ProcArgs {\n             prog: prog,\n             args: args,\n-        };\n+        }\n     }\n \n     fn split_maybe_args(&self, argstr: &Option<String>) -> Vec<String> {\n@@ -1558,12 +1553,12 @@ actual:\\n\\\n                          env,\n                          input).expect(&format!(\"failed to exec `{}`\", prog));\n         self.dump_output(&out, &err);\n-        return ProcRes {\n+        ProcRes {\n             status: status,\n             stdout: out,\n             stderr: err,\n             cmdline: cmdline,\n-        };\n+        }\n     }\n \n     fn make_cmdline(&self, libpath: &str, prog: &str, args: &[String]) -> String {\n@@ -1764,7 +1759,7 @@ actual:\\n\\\n             self.fatal_proc_rec(\"rustdoc failed!\", &proc_res);\n         }\n \n-        if self.props.check_test_line_numbers_match == true {\n+        if self.props.check_test_line_numbers_match {\n             self.check_rustdoc_test_option(proc_res);\n         } else {\n             let root = self.find_rust_src_root().unwrap();\n@@ -1791,7 +1786,7 @@ actual:\\n\\\n                .filter_map(|(line_nb, line)| {\n                    if (line.trim_left().starts_with(\"pub mod \") ||\n                        line.trim_left().starts_with(\"mod \")) &&\n-                      line.ends_with(\";\") {\n+                      line.ends_with(';') {\n                        if let Some(ref mut other_files) = other_files {\n                            other_files.push(line.rsplit(\"mod \")\n                                       .next()\n@@ -1840,7 +1835,7 @@ actual:\\n\\\n         }\n \n         let mut tested = 0;\n-        for _ in res.stdout.split(\"\\n\")\n+        for _ in res.stdout.split('\\n')\n                            .filter(|s| s.starts_with(\"test \"))\n                            .inspect(|s| {\n                                let tmp: Vec<&str> = s.split(\" - \").collect();\n@@ -1853,7 +1848,7 @@ actual:\\n\\\n                                        iter.next();\n                                        let line = iter.next()\n                                                       .unwrap_or(\")\")\n-                                                      .split(\")\")\n+                                                      .split(')')\n                                                       .next()\n                                                       .unwrap_or(\"0\")\n                                                       .parse()\n@@ -1873,7 +1868,7 @@ actual:\\n\\\n             self.fatal_proc_rec(&format!(\"No test has been found... {:?}\", files), &res);\n         } else {\n             for (entry, v) in &files {\n-                if v.len() != 0 {\n+                if !v.is_empty() {\n                     self.fatal_proc_rec(&format!(\"Not found test at line{} \\\"{}\\\":{:?}\",\n                                                  if v.len() > 1 { \"s\" } else { \"\" }, entry, v),\n                                         &res);\n@@ -1916,11 +1911,10 @@ actual:\\n\\\n                                                    .find(|ti| ti.name == expected_item.name);\n \n             if let Some(actual_item) = actual_item_with_same_name {\n-                if !expected_item.codegen_units.is_empty() {\n-                    // Also check for codegen units\n-                    if expected_item.codegen_units != actual_item.codegen_units {\n-                        wrong_cgus.push((expected_item.clone(), actual_item.clone()));\n-                    }\n+                if !expected_item.codegen_units.is_empty() &&\n+                   // Also check for codegen units\n+                   expected_item.codegen_units != actual_item.codegen_units {\n+                    wrong_cgus.push((expected_item.clone(), actual_item.clone()));\n                 }\n             } else {\n                 missing.push(expected_item.string.clone());\n@@ -2005,7 +1999,7 @@ actual:\\n\\\n             let cgus = if parts.len() > 1 {\n                 let cgus_str = parts[1];\n \n-                cgus_str.split(\" \")\n+                cgus_str.split(' ')\n                         .map(str::trim)\n                         .filter(|s| !s.is_empty())\n                         .map(str::to_owned)\n@@ -2323,7 +2317,7 @@ actual:\\n\\\n         }\n     }\n \n-    fn compare_mir_test_output(&self, test_name: &str, expected_content: &Vec<&str>) {\n+    fn compare_mir_test_output(&self, test_name: &str, expected_content: &[&str]) {\n         let mut output_file = PathBuf::new();\n         output_file.push(self.get_mir_dump_dir());\n         output_file.push(test_name);"}]}