{"sha": "77ed39cfe37a17737e0b2256b1a1689e01c32b26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3ZWQzOWNmZTM3YTE3NzM3ZTBiMjI1NmIxYTE2ODllMDFjMzJiMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-04T08:46:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-04T08:46:29Z"}, "message": "Auto merge of #29850 - Kimundi:attributes_that_make_a_statement, r=pnkfelix\n\nSee https://github.com/rust-lang/rfcs/pull/16 and https://github.com/rust-lang/rust/issues/15701\n\n- Added syntax support for attributes on expressions and all syntax nodes in statement position.\n- Extended `#[cfg]` folder to allow removal of statements, and\nof expressions in optional positions like expression lists and trailing\nblock expressions.\n- Extended lint checker to recognize lint levels on expressions and\nlocals.\n- As per RFC, attributes are not yet accepted on `if` expressions.\n\nExamples:\n  ```rust\nlet x = y;\n{\n        ...\n}\nassert_eq!((1, #[cfg(unset)] 2, 3), (1, 3));\n\nlet FOO = 0;\n```\n\nImplementation wise, there are a few rough corners and open questions:\n- The parser work ended up a bit ugly.\n- The pretty printer change was based mostly on guessing.\n- Similar to the `if` case, there are some places in the grammar where a new `Expr` node starts,\n  but where it seemed weird to accept attributes and hence the parser doesn't. This includes:\n  - const expressions in patterns\n  - in the middle of an postfix operator chain (that is, after `.`, before indexing, before calls)\n  - on range expressions, since `#[attr] x .. y` parses as  `(#[attr] x) .. y`, which is inconsistent with\n    `#[attr] .. y` which would parse as `#[attr] (.. y)`\n- Attributes are added as additional `Option<Box<Vec<Attribute>>>` fields in expressions and locals.\n- Memory impact has not been measured yet.\n- A cfg-away trailing expression in a block does not currently promote the previous `StmtExpr` in a block to a new trailing expr. That is to say, this won't work:\n```rust\nlet x = {\n    #[cfg(foo)]\n    Foo { data: x }\n    #[cfg(not(foo))]\n    Foo { data: y }\n};\n```\n- One-element tuples can have their inner expression removed to become Unit, but just Parenthesis can't. Eg, `(#[cfg(unset)] x,) == ()` but `(#[cfg(unset)] x) == error`. This seemed reasonable to me since tuples and unit are type constructors, but could probably be argued either way.\n- Attributes on macro nodes are currently unconditionally dropped during macro expansion, which seemed fine since macro disappear at that point?\n- Attributes on `ast::ExprParens` will be prepend-ed to the inner expression in the hir folder.\n- The work on pretty printer tests for this did trigger, but not fix errors regarding macros:\n  - expression `foo![]` prints as `foo!()`\n  - expression `foo!{}` prints as `foo!()`\n  - statement `foo![];` prints as `foo!();`\n  - statement `foo!{};` prints as `foo!();`\n  - statement `foo!{}` triggers a `None` unwrap ICE.", "tree": {"sha": "729dbf03cf54683035cb017448f4959ad9196f5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/729dbf03cf54683035cb017448f4959ad9196f5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77ed39cfe37a17737e0b2256b1a1689e01c32b26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77ed39cfe37a17737e0b2256b1a1689e01c32b26", "html_url": "https://github.com/rust-lang/rust/commit/77ed39cfe37a17737e0b2256b1a1689e01c32b26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77ed39cfe37a17737e0b2256b1a1689e01c32b26/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5673a7b374c9645ba4bc947588555667f7162cdb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5673a7b374c9645ba4bc947588555667f7162cdb", "html_url": "https://github.com/rust-lang/rust/commit/5673a7b374c9645ba4bc947588555667f7162cdb"}, {"sha": "d06f48054cefec1fdb87e9c9196ce1f2a31c2a9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d06f48054cefec1fdb87e9c9196ce1f2a31c2a9f", "html_url": "https://github.com/rust-lang/rust/commit/d06f48054cefec1fdb87e9c9196ce1f2a31c2a9f"}], "stats": {"total": 2869, "additions": 2283, "deletions": 586}, "files": [{"sha": "98074f09441c4b0e3a220f14dcdeeca803f21be4", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -2368,6 +2368,9 @@ The currently implemented features of the reference compiler are:\n                                         influence type inference.\n * - `braced_empty_structs` - Allows use of empty structs and enum variants with braces.\n \n+* - `stmt_expr_attributes` - Allows attributes on expressions and\n+                             non-item statements.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about `#![feature]` directives which enabled\n the new feature (because the directive is no longer necessary). However, if a"}, {"sha": "1ed873f0508d56aaf00d78b9016f3ebb08ed5dd6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -42,6 +42,7 @@ use syntax::attr::{self, AttrMetaMethods};\n use syntax::codemap::Span;\n use syntax::parse::token::InternedString;\n use syntax::ast;\n+use syntax::attr::ThinAttributesExt;\n use rustc_front::hir;\n use rustc_front::util;\n use rustc_front::intravisit as hir_visit;\n@@ -674,11 +675,18 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, e: &hir::Expr) {\n-        run_lints!(self, check_expr, late_passes, e);\n-        hir_visit::walk_expr(self, e);\n+        self.with_lint_attrs(e.attrs.as_attr_slice(), |cx| {\n+            run_lints!(cx, check_expr, late_passes, e);\n+            hir_visit::walk_expr(cx, e);\n+        })\n     }\n \n     fn visit_stmt(&mut self, s: &hir::Stmt) {\n+        // statement attributes are actually just attributes on one of\n+        // - item\n+        // - local\n+        // - expression\n+        // so we keep track of lint levels there\n         run_lints!(self, check_stmt, late_passes, s);\n         hir_visit::walk_stmt(self, s);\n     }\n@@ -730,8 +738,10 @@ impl<'a, 'tcx, 'v> hir_visit::Visitor<'v> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_local(&mut self, l: &hir::Local) {\n-        run_lints!(self, check_local, late_passes, l);\n-        hir_visit::walk_local(self, l);\n+        self.with_lint_attrs(l.attrs.as_attr_slice(), |cx| {\n+            run_lints!(cx, check_local, late_passes, l);\n+            hir_visit::walk_local(cx, l);\n+        })\n     }\n \n     fn visit_block(&mut self, b: &hir::Block) {"}, {"sha": "a292c83682c0e3340da742af8f078f4e70925c3a", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -409,7 +409,8 @@ fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: 0,\n         node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n-        span: DUMMY_SP\n+        span: DUMMY_SP,\n+        attrs: None,\n     })\n }\n "}, {"sha": "9a489ac6fdf71a29a408d82a0ae28a7f21bfea9f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -654,6 +654,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                 node: ast::ExprLoop(empty_block, None),\n                 id: ast::DUMMY_NODE_ID,\n                 span: codemap::DUMMY_SP,\n+                attrs: None,\n             });\n \n             expr_to_block(b.rules, Some(loop_expr))"}, {"sha": "5f39376d156032d642b7ea06560482c0929b0c3c", "filename": "src/librustc_front/fold.rs", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Ffold.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -14,39 +14,13 @@\n use hir::*;\n use syntax::ast::{Ident, Name, NodeId, DUMMY_NODE_ID, Attribute, Attribute_, MetaItem};\n use syntax::ast::{MetaWord, MetaList, MetaNameValue};\n+use syntax::attr::ThinAttributesExt;\n use hir;\n use syntax::codemap::{respan, Span, Spanned};\n use syntax::owned_slice::OwnedSlice;\n use syntax::ptr::P;\n use syntax::parse::token;\n-use std::ptr;\n-\n-// This could have a better place to live.\n-pub trait MoveMap<T> {\n-    fn move_map<F>(self, f: F) -> Self where F: FnMut(T) -> T;\n-}\n-\n-impl<T> MoveMap<T> for Vec<T> {\n-    fn move_map<F>(mut self, mut f: F) -> Vec<T>\n-        where F: FnMut(T) -> T\n-    {\n-        for p in &mut self {\n-            unsafe {\n-                // FIXME(#5016) this shouldn't need to zero to be safe.\n-                ptr::write(p, f(ptr::read_and_drop(p)));\n-            }\n-        }\n-        self\n-    }\n-}\n-\n-impl<T> MoveMap<T> for OwnedSlice<T> {\n-    fn move_map<F>(self, f: F) -> OwnedSlice<T>\n-        where F: FnMut(T) -> T\n-    {\n-        OwnedSlice::from_vec(self.into_vec().move_map(f))\n-    }\n-}\n+use syntax::util::move_map::MoveMap;\n \n pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n@@ -332,7 +306,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n }\n \n pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n-    attrs.into_iter().flat_map(|x| fld.fold_attribute(x)).collect()\n+    attrs.move_flat_map(|x| fld.fold_attribute(x))\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm { attrs, pats, guard, body }: Arm, fld: &mut T) -> Arm {\n@@ -501,13 +475,14 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local { id, pat, ty, init, span }| {\n+    l.map(|Local { id, pat, ty, init, span, attrs }| {\n         Local {\n             id: fld.new_id(id),\n             ty: ty.map(|t| fld.fold_ty(t)),\n             pat: fld.fold_pat(pat),\n             init: init.map(|e| fld.fold_expr(e)),\n             span: fld.new_span(span),\n+            attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, fld)),\n         }\n     })\n }\n@@ -769,7 +744,7 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block { id, stmts, expr, rules, span }| {\n         Block {\n             id: folder.new_id(id),\n-            stmts: stmts.into_iter().map(|s| folder.fold_stmt(s)).collect(),\n+            stmts: stmts.move_map(|s| folder.fold_stmt(s)),\n             expr: expr.map(|x| folder.fold_expr(x)),\n             rules: rules,\n             span: folder.new_span(span),\n@@ -816,9 +791,8 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items.into_iter()\n-                                           .map(|item| folder.fold_impl_item(item))\n-                                           .collect();\n+            let new_impl_items = impl_items\n+                .move_map(|item| folder.fold_impl_item(item));\n             let ifce = match ifce {\n                 None => None,\n                 Some(ref trait_ref) => {\n@@ -834,9 +808,7 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         }\n         ItemTrait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let items = items.into_iter()\n-                             .map(|item| folder.fold_trait_item(item))\n-                             .collect();\n+            let items = items.move_map(|item| folder.fold_trait_item(item));\n             ItemTrait(unsafety, folder.fold_generics(generics), bounds, items)\n         }\n     }\n@@ -892,7 +864,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T) -> P<ImplI\n pub fn noop_fold_mod<T: Folder>(Mod { inner, item_ids }: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        item_ids: item_ids.into_iter().map(|x| folder.fold_item_id(x)).collect(),\n+        item_ids: item_ids.move_map(|x| folder.fold_item_id(x)),\n     }\n }\n \n@@ -1048,7 +1020,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     })\n }\n \n-pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T) -> Expr {\n+pub fn noop_fold_expr<T: Folder>(Expr { id, node, span, attrs }: Expr, folder: &mut T) -> Expr {\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n@@ -1171,6 +1143,7 @@ pub fn noop_fold_expr<T: Folder>(Expr { id, node, span }: Expr, folder: &mut T)\n             }\n         },\n         span: folder.new_span(span),\n+        attrs: attrs.map_thin_attrs(|attrs| fold_attrs(attrs, folder)),\n     }\n }\n "}, {"sha": "beb7059d73cd2914ad817dd313ace033d8b61e70", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -41,6 +41,7 @@ use syntax::codemap::{self, Span, Spanned, DUMMY_SP, ExpnId};\n use syntax::abi::Abi;\n use syntax::ast::{Name, Ident, NodeId, DUMMY_NODE_ID, TokenTree, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, CrateConfig};\n+use syntax::attr::ThinAttributes;\n use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -558,6 +559,7 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n+    pub attrs: ThinAttributes,\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -609,6 +611,7 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n+    pub attrs: ThinAttributes,\n }\n \n impl fmt::Debug for Expr {"}, {"sha": "3bfa645afc7d92f9b3f85434484edda66dddcf06", "filename": "src/librustc_front/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flib.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -35,7 +35,6 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(str_char)]\n-#![feature(filling_drop)]\n \n extern crate serialize;\n #[macro_use]"}, {"sha": "e8c4a6484e2a2a95d97ee366c68f8b207f357355", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 98, "deletions": 57, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -66,6 +66,7 @@ use hir;\n use std::collections::BTreeMap;\n use std::collections::HashMap;\n use syntax::ast::*;\n+use syntax::attr::{ThinAttributes, ThinAttributesExt};\n use syntax::ptr::P;\n use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n@@ -331,6 +332,7 @@ pub fn lower_local(lctx: &LoweringContext, l: &Local) -> P<hir::Local> {\n         pat: lower_pat(lctx, &l.pat),\n         init: l.init.as_ref().map(|e| lower_expr(lctx, e)),\n         span: l.span,\n+        attrs: l.attrs.clone(),\n     })\n }\n \n@@ -984,16 +986,16 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     let make_call = |lctx: &LoweringContext, p, args| {\n                         let path = core_path(lctx, e.span, p);\n-                        let path = expr_path(lctx, path);\n-                        expr_call(lctx, e.span, path, args)\n+                        let path = expr_path(lctx, path, None);\n+                        expr_call(lctx, e.span, path, args, None)\n                     };\n \n                     let mk_stmt_let = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, false, bind, expr)\n+                        stmt_let(lctx, e.span, false, bind, expr, None)\n                     };\n \n                     let mk_stmt_let_mut = |lctx: &LoweringContext, bind, expr| {\n-                        stmt_let(lctx, e.span, true, bind, expr)\n+                        stmt_let(lctx, e.span, true, bind, expr, None)\n                     };\n \n                     // let placer = <placer_expr> ;\n@@ -1002,21 +1004,22 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                             vec![],\n                                                             placer_expr,\n                                                             e.span,\n-                                                            hir::PopUnstableBlock);\n+                                                            hir::PopUnstableBlock,\n+                                                            None);\n                         mk_stmt_let(lctx, placer_ident, placer_expr)\n                     };\n \n                     // let mut place = Placer::make_place(placer);\n                     let s2 = {\n-                        let placer = expr_ident(lctx, e.span, placer_ident);\n+                        let placer = expr_ident(lctx, e.span, placer_ident, None);\n                         let call = make_call(lctx, &make_place, vec![placer]);\n                         mk_stmt_let_mut(lctx, place_ident, call)\n                     };\n \n                     // let p_ptr = Place::pointer(&mut place);\n                     let s3 = {\n-                        let agent = expr_ident(lctx, e.span, place_ident);\n-                        let args = vec![expr_mut_addr_of(lctx, e.span, agent)];\n+                        let agent = expr_ident(lctx, e.span, place_ident, None);\n+                        let args = vec![expr_mut_addr_of(lctx, e.span, agent, None)];\n                         let call = make_call(lctx, &place_pointer, args);\n                         mk_stmt_let(lctx, p_ptr_ident, call)\n                     };\n@@ -1027,40 +1030,42 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                            vec![],\n                                                            value_expr,\n                                                            e.span,\n-                                                           hir::PopUnstableBlock);\n+                                                           hir::PopUnstableBlock,\n+                                                           None);\n                         signal_block_expr(lctx,\n                                           vec![],\n                                           value_expr,\n                                           e.span,\n-                                          hir::PopUnsafeBlock(hir::CompilerGenerated))\n+                                          hir::PopUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     // push_unsafe!({\n                     //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n                     //     InPlace::finalize(place)\n                     // })\n                     let expr = {\n-                        let ptr = expr_ident(lctx, e.span, p_ptr_ident);\n+                        let ptr = expr_ident(lctx, e.span, p_ptr_ident, None);\n                         let call_move_val_init =\n                             hir::StmtSemi(\n                                 make_call(lctx, &move_val_init, vec![ptr, pop_unsafe_expr]),\n                                 lctx.next_id());\n                         let call_move_val_init = respan(e.span, call_move_val_init);\n \n-                        let place = expr_ident(lctx, e.span, place_ident);\n+                        let place = expr_ident(lctx, e.span, place_ident, None);\n                         let call = make_call(lctx, &inplace_finalize, vec![place]);\n                         signal_block_expr(lctx,\n                                           vec![P(call_move_val_init)],\n                                           call,\n                                           e.span,\n-                                          hir::PushUnsafeBlock(hir::CompilerGenerated))\n+                                          hir::PushUnsafeBlock(hir::CompilerGenerated), None)\n                     };\n \n                     signal_block_expr(lctx,\n                                       vec![s1, s2, s3],\n                                       expr,\n                                       e.span,\n-                                      hir::PushUnstableBlock)\n+                                      hir::PushUnstableBlock,\n+                                      e.attrs.clone())\n                 });\n             }\n \n@@ -1123,7 +1128,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                     rules: hir::DefaultBlock,\n                                     span: span,\n                                 });\n-                                expr_block(lctx, blk)\n+                                expr_block(lctx, blk, None)\n                             })\n                         }\n                         _ => lower_expr(lctx, els),\n@@ -1215,7 +1220,13 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                 maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n             }\n             ExprParen(ref ex) => {\n-                return lower_expr(lctx, ex);\n+                // merge attributes into the inner expression.\n+                return lower_expr(lctx, ex).map(|mut ex| {\n+                    ex.attrs.update(|attrs| {\n+                        attrs.prepend(e.attrs.clone())\n+                    });\n+                    ex\n+                });\n             }\n \n             // Desugar ExprIfLet\n@@ -1233,7 +1244,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body, None);\n                         arm(vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n@@ -1252,7 +1263,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                                 attrs: vec![],\n                                                 pats: vec![pat_under],\n                                                 guard: Some(cond),\n-                                                body: expr_block(lctx, then),\n+                                                body: expr_block(lctx, then, None),\n                                             });\n                                             else_opt.map(|else_opt| (else_opt, true))\n                                         }\n@@ -1284,7 +1295,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                         let pat_under = pat_wild(lctx, e.span);\n                         let else_expr =\n                             else_opt.unwrap_or_else(\n-                                || expr_tuple(lctx, e.span, vec![]));\n+                                || expr_tuple(lctx, e.span, vec![], None));\n                         arm(vec![pat_under], else_expr)\n                     };\n \n@@ -1294,13 +1305,15 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     arms.push(else_arm);\n \n                     let sub_expr = lower_expr(lctx, sub_expr);\n+                    // add attributes to the outer returned expr node\n                     expr(lctx,\n                          e.span,\n                          hir::ExprMatch(sub_expr,\n                                         arms,\n                                         hir::MatchSource::IfLetDesugar {\n                                             contains_else_clause: contains_else_clause,\n-                                        }))\n+                                        }),\n+                         e.attrs.clone())\n                 });\n             }\n \n@@ -1320,14 +1333,14 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     // `<pat> => <body>`\n                     let pat_arm = {\n                         let body = lower_block(lctx, body);\n-                        let body_expr = expr_block(lctx, body);\n+                        let body_expr = expr_block(lctx, body, None);\n                         arm(vec![lower_pat(lctx, pat)], body_expr)\n                     };\n \n                     // `_ => break`\n                     let break_arm = {\n                         let pat_under = pat_wild(lctx, e.span);\n-                        let break_expr = expr_break(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span, None);\n                         arm(vec![pat_under], break_expr)\n                     };\n \n@@ -1338,11 +1351,13 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                                           e.span,\n                                           hir::ExprMatch(sub_expr,\n                                                          arms,\n-                                                         hir::MatchSource::WhileLetDesugar));\n+                                                         hir::MatchSource::WhileLetDesugar),\n+                                          None);\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n-                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident))\n+                    // add attributes to the outer returned expr node\n+                    expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident), e.attrs.clone())\n                 });\n             }\n \n@@ -1379,6 +1394,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                             id: lctx.next_id(),\n                             node: hir::ExprBlock(body_block),\n                             span: body_span,\n+                            attrs: None,\n                         });\n                         let pat = lower_pat(lctx, pat);\n                         let some_pat = pat_some(lctx, e.span, pat);\n@@ -1388,7 +1404,7 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                     // `::std::option::Option::None => break`\n                     let break_arm = {\n-                        let break_expr = expr_break(lctx, e.span);\n+                        let break_expr = expr_break(lctx, e.span, None);\n \n                         arm(vec![pat_none(lctx, e.span)], break_expr)\n                     };\n@@ -1400,20 +1416,28 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n \n                             path_global(e.span, strs)\n                         };\n-                        let iter = expr_ident(lctx, e.span, iter);\n-                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter);\n-                        let next_path = expr_path(lctx, next_path);\n-                        let next_expr = expr_call(lctx, e.span, next_path, vec![ref_mut_iter]);\n+                        let iter = expr_ident(lctx, e.span, iter, None);\n+                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, iter, None);\n+                        let next_path = expr_path(lctx, next_path, None);\n+                        let next_expr = expr_call(lctx,\n+                                                  e.span,\n+                                                  next_path,\n+                                                  vec![ref_mut_iter],\n+                                                  None);\n                         let arms = vec![pat_arm, break_arm];\n \n                         expr(lctx,\n                              e.span,\n-                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n+                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar),\n+                             None)\n                     };\n \n                     // `[opt_ident]: loop { ... }`\n                     let loop_block = block_expr(lctx, match_expr);\n-                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident));\n+                    let loop_expr = expr(lctx,\n+                                         e.span,\n+                                         hir::ExprLoop(loop_block, opt_ident),\n+                                         None);\n \n                     // `mut iter => { ... }`\n                     let iter_arm = {\n@@ -1432,28 +1456,31 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                             path_global(e.span, strs)\n                         };\n \n-                        let into_iter = expr_path(lctx, into_iter_path);\n-                        expr_call(lctx, e.span, into_iter, vec![head])\n+                        let into_iter = expr_path(lctx, into_iter_path, None);\n+                        expr_call(lctx, e.span, into_iter, vec![head], None)\n                     };\n \n                     let match_expr = expr_match(lctx,\n                                                 e.span,\n                                                 into_iter_expr,\n                                                 vec![iter_arm],\n-                                                hir::MatchSource::ForLoopDesugar);\n+                                                hir::MatchSource::ForLoopDesugar,\n+                                                None);\n \n                     // `{ let result = ...; result }`\n                     let result_ident = lctx.str_to_ident(\"result\");\n-                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr);\n-                    let result = expr_ident(lctx, e.span, result_ident);\n+                    let let_stmt = stmt_let(lctx, e.span, false, result_ident, match_expr, None);\n+                    let result = expr_ident(lctx, e.span, result_ident, None);\n                     let block = block_all(lctx, e.span, vec![let_stmt], Some(result));\n-                    expr_block(lctx, block)\n+                    // add the attributes to the outer returned expr node\n+                    expr_block(lctx, block, e.attrs.clone())\n                 });\n             }\n \n             ExprMac(_) => panic!(\"Shouldn't exist here\"),\n         },\n         span: e.span,\n+        attrs: e.attrs.clone(),\n     })\n }\n \n@@ -1552,60 +1579,71 @@ fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n     }\n }\n \n-fn expr_break(lctx: &LoweringContext, span: Span) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprBreak(None))\n+fn expr_break(lctx: &LoweringContext, span: Span,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprBreak(None), attrs)\n }\n \n fn expr_call(lctx: &LoweringContext,\n              span: Span,\n              e: P<hir::Expr>,\n-             args: Vec<P<hir::Expr>>)\n+             args: Vec<P<hir::Expr>>,\n+             attrs: ThinAttributes)\n              -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprCall(e, args))\n+    expr(lctx, span, hir::ExprCall(e, args), attrs)\n }\n \n-fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident) -> P<hir::Expr> {\n-    expr_path(lctx, path_ident(span, id))\n+fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr_path(lctx, path_ident(span, id), attrs)\n }\n \n-fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e))\n+fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>,\n+                    attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e), attrs)\n }\n \n-fn expr_path(lctx: &LoweringContext, path: hir::Path) -> P<hir::Expr> {\n-    expr(lctx, path.span, hir::ExprPath(None, path))\n+fn expr_path(lctx: &LoweringContext, path: hir::Path,\n+             attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, path.span, hir::ExprPath(None, path), attrs)\n }\n \n fn expr_match(lctx: &LoweringContext,\n               span: Span,\n               arg: P<hir::Expr>,\n               arms: Vec<hir::Arm>,\n-              source: hir::MatchSource)\n+              source: hir::MatchSource,\n+              attrs: ThinAttributes)\n               -> P<hir::Expr> {\n-    expr(lctx, span, hir::ExprMatch(arg, arms, source))\n+    expr(lctx, span, hir::ExprMatch(arg, arms, source), attrs)\n }\n \n-fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n-    expr(lctx, b.span, hir::ExprBlock(b))\n+fn expr_block(lctx: &LoweringContext, b: P<hir::Block>,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, b.span, hir::ExprBlock(b), attrs)\n }\n \n-fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>) -> P<hir::Expr> {\n-    expr(lctx, sp, hir::ExprTup(exprs))\n+fn expr_tuple(lctx: &LoweringContext, sp: Span, exprs: Vec<P<hir::Expr>>,\n+              attrs: ThinAttributes) -> P<hir::Expr> {\n+    expr(lctx, sp, hir::ExprTup(exprs), attrs)\n }\n \n-fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_) -> P<hir::Expr> {\n+fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_,\n+        attrs: ThinAttributes) -> P<hir::Expr> {\n     P(hir::Expr {\n         id: lctx.next_id(),\n         node: node,\n         span: span,\n+        attrs: attrs,\n     })\n }\n \n fn stmt_let(lctx: &LoweringContext,\n             sp: Span,\n             mutbl: bool,\n             ident: Ident,\n-            ex: P<hir::Expr>)\n+            ex: P<hir::Expr>,\n+            attrs: ThinAttributes)\n             -> P<hir::Stmt> {\n     let pat = if mutbl {\n         pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n@@ -1618,6 +1656,7 @@ fn stmt_let(lctx: &LoweringContext,\n         init: Some(ex),\n         id: lctx.next_id(),\n         span: sp,\n+        attrs: attrs,\n     });\n     let decl = respan(sp, hir::DeclLocal(local));\n     P(respan(sp, hir::StmtDecl(P(decl), lctx.next_id())))\n@@ -1755,7 +1794,8 @@ fn signal_block_expr(lctx: &LoweringContext,\n                      stmts: Vec<P<hir::Stmt>>,\n                      expr: P<hir::Expr>,\n                      span: Span,\n-                     rule: hir::BlockCheckMode)\n+                     rule: hir::BlockCheckMode,\n+                     attrs: ThinAttributes)\n                      -> P<hir::Expr> {\n     let id = lctx.next_id();\n     expr_block(lctx,\n@@ -1765,7 +1805,8 @@ fn signal_block_expr(lctx: &LoweringContext,\n                    id: id,\n                    stmts: stmts,\n                    expr: Some(expr),\n-               }))\n+               }),\n+               attrs)\n }\n \n "}, {"sha": "b5f8be496fb02f451867a5d26e61e2d4ca1f5a39", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -138,7 +138,7 @@ impl LateLintPass for NonCamelCaseTypes {\n declare_lint! {\n     pub NON_SNAKE_CASE,\n     Warn,\n-    \"methods, functions, lifetime parameters and modules should have snake case names\"\n+    \"variables, methods, functions, lifetime parameters and modules should have snake case names\"\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "f11291fc0f7e7a005124589df7fd3332e0605eba", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -45,6 +45,7 @@ pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n \n+use attr::ThinAttributes;\n use codemap::{Span, Spanned, DUMMY_SP, ExpnId};\n use abi::Abi;\n use ast_util;\n@@ -692,8 +693,21 @@ pub enum Stmt_ {\n     /// Expr with trailing semi-colon (may have any type):\n     StmtSemi(P<Expr>, NodeId),\n \n-    StmtMac(P<Mac>, MacStmtStyle),\n+    StmtMac(P<Mac>, MacStmtStyle, ThinAttributes),\n }\n+\n+impl Stmt_ {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            StmtDecl(ref d, _) => d.attrs(),\n+            StmtExpr(ref e, _) |\n+            StmtSemi(ref e, _) => e.attrs(),\n+            StmtMac(_, _, Some(ref b)) => b,\n+            StmtMac(_, _, None) => &[],\n+        }\n+    }\n+}\n+\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum MacStmtStyle {\n     /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n@@ -718,6 +732,16 @@ pub struct Local {\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n     pub span: Span,\n+    pub attrs: ThinAttributes,\n+}\n+\n+impl Local {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match self.attrs {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n }\n \n pub type Decl = Spanned<Decl_>;\n@@ -730,6 +754,15 @@ pub enum Decl_ {\n     DeclItem(P<Item>),\n }\n \n+impl Decl {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match self.node {\n+            DeclLocal(ref l) => l.attrs(),\n+            DeclItem(ref i) => i.attrs(),\n+        }\n+    }\n+}\n+\n /// represents one arm of a 'match'\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Arm {\n@@ -766,6 +799,16 @@ pub struct Expr {\n     pub id: NodeId,\n     pub node: Expr_,\n     pub span: Span,\n+    pub attrs: ThinAttributes\n+}\n+\n+impl Expr {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        match self.attrs {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n }\n \n impl fmt::Debug for Expr {\n@@ -1792,6 +1835,12 @@ pub struct Item {\n     pub span: Span,\n }\n \n+impl Item {\n+    pub fn attrs(&self) -> &[Attribute] {\n+        &self.attrs\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n     /// An`extern crate` item, with optional original crate name,"}, {"sha": "e828d8ae24874fd4773e2fdbf054dc1c3dd445b7", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 175, "deletions": 9, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -16,10 +16,13 @@ pub use self::IntType::*;\n \n use ast;\n use ast::{AttrId, Attribute, Attribute_, MetaItem, MetaWord, MetaNameValue, MetaList};\n+use ast::{Stmt, StmtDecl, StmtExpr, StmtMac, StmtSemi, DeclItem, DeclLocal};\n+use ast::{Expr, Item, Local, Decl};\n use codemap::{Span, Spanned, spanned, dummy_spanned};\n use codemap::BytePos;\n+use config::CfgDiag;\n use diagnostic::SpanHandler;\n-use feature_gate::GatedCfg;\n+use feature_gate::{GatedCfg, GatedCfgAttr};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::token::{InternedString, intern_and_get_ident};\n use parse::token;\n@@ -356,26 +359,35 @@ pub fn requests_inline(attrs: &[Attribute]) -> bool {\n }\n \n /// Tests if a cfg-pattern matches the cfg set\n-pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::MetaItem,\n-                   feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n+pub fn cfg_matches<T: CfgDiag>(cfgs: &[P<MetaItem>],\n+                           cfg: &ast::MetaItem,\n+                           diag: &mut T) -> bool {\n     match cfg.node {\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"any\" =>\n-            mis.iter().any(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n+            mis.iter().any(|mi| cfg_matches(cfgs, &**mi, diag)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"all\" =>\n-            mis.iter().all(|mi| cfg_matches(diagnostic, cfgs, &**mi, feature_gated_cfgs)),\n+            mis.iter().all(|mi| cfg_matches(cfgs, &**mi, diag)),\n         ast::MetaList(ref pred, ref mis) if &pred[..] == \"not\" => {\n             if mis.len() != 1 {\n-                diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                diag.emit_error(|diagnostic| {\n+                    diagnostic.span_err(cfg.span, \"expected 1 cfg-pattern\");\n+                });\n                 return false;\n             }\n-            !cfg_matches(diagnostic, cfgs, &*mis[0], feature_gated_cfgs)\n+            !cfg_matches(cfgs, &*mis[0], diag)\n         }\n         ast::MetaList(ref pred, _) => {\n-            diagnostic.span_err(cfg.span, &format!(\"invalid predicate `{}`\", pred));\n+            diag.emit_error(|diagnostic| {\n+                diagnostic.span_err(cfg.span,\n+                    &format!(\"invalid predicate `{}`\", pred));\n+            });\n             false\n         },\n         ast::MetaWord(_) | ast::MetaNameValue(..) => {\n-            feature_gated_cfgs.extend(GatedCfg::gate(cfg));\n+            diag.flag_gated(|feature_gated_cfgs| {\n+                feature_gated_cfgs.extend(\n+                    GatedCfg::gate(cfg).map(GatedCfgAttr::GatedCfg));\n+            });\n             contains(cfgs, cfg)\n         }\n     }\n@@ -720,3 +732,157 @@ impl IntType {\n         }\n     }\n }\n+\n+/// A list of attributes, behind a optional box as\n+/// a space optimization.\n+pub type ThinAttributes = Option<Box<Vec<Attribute>>>;\n+\n+pub trait ThinAttributesExt {\n+    fn map_thin_attrs<F>(self, f: F) -> Self\n+        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>;\n+    fn prepend(mut self, attrs: Self) -> Self;\n+    fn append(mut self, attrs: Self) -> Self;\n+    fn update<F>(&mut self, f: F)\n+        where Self: Sized,\n+              F: FnOnce(Self) -> Self;\n+    fn as_attr_slice(&self) -> &[Attribute];\n+    fn into_attr_vec(self) -> Vec<Attribute>;\n+}\n+\n+impl ThinAttributesExt for ThinAttributes {\n+    fn map_thin_attrs<F>(self, f: F) -> Self\n+        where F: FnOnce(Vec<Attribute>) -> Vec<Attribute>\n+    {\n+        f(self.map(|b| *b).unwrap_or(Vec::new())).into_thin_attrs()\n+    }\n+\n+    fn prepend(self, attrs: ThinAttributes) -> Self {\n+        attrs.map_thin_attrs(|mut attrs| {\n+            attrs.extend(self.into_attr_vec());\n+            attrs\n+        })\n+    }\n+\n+    fn append(self, attrs: ThinAttributes) -> Self {\n+        self.map_thin_attrs(|mut self_| {\n+            self_.extend(attrs.into_attr_vec());\n+            self_\n+        })\n+    }\n+\n+    fn update<F>(&mut self, f: F)\n+        where Self: Sized,\n+              F: FnOnce(ThinAttributes) -> ThinAttributes\n+    {\n+        let self_ = f(self.take());\n+        *self = self_;\n+    }\n+\n+    fn as_attr_slice(&self) -> &[Attribute] {\n+        match *self {\n+            Some(ref b) => b,\n+            None => &[],\n+        }\n+    }\n+\n+    fn into_attr_vec(self) -> Vec<Attribute> {\n+        match self {\n+            Some(b) => *b,\n+            None => Vec::new(),\n+        }\n+    }\n+}\n+\n+pub trait AttributesExt {\n+    fn into_thin_attrs(self) -> ThinAttributes;\n+}\n+\n+impl AttributesExt for Vec<Attribute> {\n+    fn into_thin_attrs(self) -> ThinAttributes {\n+        if self.len() == 0 {\n+            None\n+        } else {\n+            Some(Box::new(self))\n+        }\n+    }\n+}\n+\n+/// A cheap way to add Attributes to an AST node.\n+pub trait WithAttrs {\n+    // FIXME: Could be extended to anything IntoIter<Item=Attribute>\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self;\n+}\n+\n+impl WithAttrs for P<Expr> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|mut e| {\n+            e.attrs.update(|a| a.append(attrs));\n+            e\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Item> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Item { ident, attrs: mut ats, id, node, vis, span }| {\n+            ats.extend(attrs.into_attr_vec());\n+            Item {\n+                ident: ident,\n+                attrs: ats,\n+                id: id,\n+                node: node,\n+                vis: vis,\n+                span: span,\n+            }\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Local> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Local { pat, ty, init, id, span, attrs: mut ats }| {\n+            ats.update(|a| a.append(attrs));\n+            Local {\n+                pat: pat,\n+                ty: ty,\n+                init: init,\n+                id: id,\n+                span: span,\n+                attrs: ats,\n+            }\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Decl> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Spanned { span, node }| {\n+            Spanned {\n+                span: span,\n+                node: match node {\n+                    DeclLocal(local) => DeclLocal(local.with_attrs(attrs)),\n+                    DeclItem(item) => DeclItem(item.with_attrs(attrs)),\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+impl WithAttrs for P<Stmt> {\n+    fn with_attrs(self, attrs: ThinAttributes) -> Self {\n+        self.map(|Spanned { span, node }| {\n+            Spanned {\n+                span: span,\n+                node: match node {\n+                    StmtDecl(decl, id) => StmtDecl(decl.with_attrs(attrs), id),\n+                    StmtExpr(expr, id) => StmtExpr(expr.with_attrs(attrs), id),\n+                    StmtSemi(expr, id) => StmtSemi(expr.with_attrs(attrs), id),\n+                    StmtMac(mac, style, mut ats) => {\n+                        ats.update(|a| a.append(attrs));\n+                        StmtMac(mac, style, ats)\n+                    }\n+                },\n+            }\n+        })\n+    }\n+}"}, {"sha": "1209c58fd5ed1abf01a440b7e2fa4d56e239f829", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 271, "deletions": 77, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -10,47 +10,71 @@\n \n use attr::AttrMetaMethods;\n use diagnostic::SpanHandler;\n-use feature_gate::GatedCfg;\n+use feature_gate::GatedCfgAttr;\n use fold::Folder;\n use {ast, fold, attr};\n+use visit;\n use codemap::{Spanned, respan};\n use ptr::P;\n \n use util::small_vector::SmallVector;\n \n /// A folder that strips out items that do not belong in the current\n /// configuration.\n-struct Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n+struct Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     in_cfg: F,\n+    diagnostic: &'a SpanHandler,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n // any items that do not belong in the current configuration\n pub fn strip_unconfigured_items(diagnostic: &SpanHandler, krate: ast::Crate,\n-                                feature_gated_cfgs: &mut Vec<GatedCfg>)\n+                                feature_gated_cfgs: &mut Vec<GatedCfgAttr>)\n                                 -> ast::Crate\n {\n+    // Need to do this check here because cfg runs before feature_gates\n+    check_for_gated_stmt_expr_attributes(&krate, feature_gated_cfgs);\n+\n     let krate = process_cfg_attr(diagnostic, krate, feature_gated_cfgs);\n     let config = krate.config.clone();\n-    strip_items(krate, |attrs| in_cfg(diagnostic, &config, attrs, feature_gated_cfgs))\n+    strip_items(diagnostic,\n+                krate,\n+                |attrs| {\n+                    let mut diag = CfgDiagReal {\n+                        diag: diagnostic,\n+                        feature_gated_cfgs: feature_gated_cfgs,\n+                    };\n+                    in_cfg(&config, attrs, &mut diag)\n+                })\n }\n \n-impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n-    fn fold_mod(&mut self, module: ast::Mod) -> ast::Mod {\n-        fold_mod(self, module)\n-    }\n-    fn fold_block(&mut self, block: P<ast::Block>) -> P<ast::Block> {\n-        fold_block(self, block)\n-    }\n+impl<'a, F> fold::Folder for Context<'a, F> where F: FnMut(&[ast::Attribute]) -> bool {\n     fn fold_foreign_mod(&mut self, foreign_mod: ast::ForeignMod) -> ast::ForeignMod {\n         fold_foreign_mod(self, foreign_mod)\n     }\n     fn fold_item_underscore(&mut self, item: ast::Item_) -> ast::Item_ {\n         fold_item_underscore(self, item)\n     }\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n+        // If an expr is valid to cfg away it will have been removed by the\n+        // outer stmt or expression folder before descending in here.\n+        // Anything else is always required, and thus has to error out\n+        // in case of a cfg attr.\n+        //\n+        // NB: This is intentionally not part of the fold_expr() function\n+        //     in order for fold_opt_expr() to be able to avoid this check\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a)) {\n+            self.diagnostic.span_err(attr.span,\n+                \"removing an expression is not supported in this position\");\n+        }\n         fold_expr(self, expr)\n     }\n+    fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n+        fold_opt_expr(self, expr)\n+    }\n+    fn fold_stmt(&mut self, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>> {\n+        fold_stmt(self, stmt)\n+    }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n     }\n@@ -59,28 +83,17 @@ impl<F> fold::Folder for Context<F> where F: FnMut(&[ast::Attribute]) -> bool {\n     }\n }\n \n-pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n+pub fn strip_items<'a, F>(diagnostic: &'a SpanHandler,\n+                          krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     F: FnMut(&[ast::Attribute]) -> bool,\n {\n     let mut ctxt = Context {\n         in_cfg: in_cfg,\n+        diagnostic: diagnostic,\n     };\n     ctxt.fold_crate(krate)\n }\n \n-fn fold_mod<F>(cx: &mut Context<F>,\n-               ast::Mod {inner, items}: ast::Mod)\n-               -> ast::Mod where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    ast::Mod {\n-        inner: inner,\n-        items: items.into_iter().flat_map(|a| {\n-            cx.fold_item(a).into_iter()\n-        }).collect()\n-    }\n-}\n-\n fn filter_foreign_item<F>(cx: &mut Context<F>,\n                           item: P<ast::ForeignItem>)\n                           -> Option<P<ast::ForeignItem>> where\n@@ -182,45 +195,20 @@ fn fold_struct<F>(cx: &mut Context<F>, vdata: ast::VariantData) -> ast::VariantD\n     }\n }\n \n-fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n+fn fold_opt_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> Option<P<ast::Expr>>\n+    where F: FnMut(&[ast::Attribute]) -> bool\n {\n-    match stmt.node {\n-        ast::StmtDecl(ref decl, _) => {\n-            match decl.node {\n-                ast::DeclItem(ref item) => {\n-                    item_in_cfg(cx, item)\n-                }\n-                _ => true\n-            }\n-        }\n-        _ => true\n+    if expr_in_cfg(cx, &expr) {\n+        Some(fold_expr(cx, expr))\n+    } else {\n+        None\n     }\n }\n \n-fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    b.map(|ast::Block {id, stmts, expr, rules, span}| {\n-        let resulting_stmts: Vec<P<ast::Stmt>> =\n-            stmts.into_iter().filter(|a| retain_stmt(cx, a)).collect();\n-        let resulting_stmts = resulting_stmts.into_iter()\n-            .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n-            .collect();\n-        ast::Block {\n-            id: id,\n-            stmts: resulting_stmts,\n-            expr: expr.map(|x| cx.fold_expr(x)),\n-            rules: rules,\n-            span: span,\n-        }\n-    })\n-}\n-\n fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    expr.map(|ast::Expr {id, span, node}| {\n+    expr.map(|ast::Expr {id, span, node, attrs}| {\n         fold::noop_fold_expr(ast::Expr {\n             id: id,\n             node: match node {\n@@ -231,11 +219,34 @@ fn fold_expr<F>(cx: &mut Context<F>, expr: P<ast::Expr>) -> P<ast::Expr> where\n                 }\n                 _ => node\n             },\n-            span: span\n+            span: span,\n+            attrs: attrs,\n         }, cx)\n     })\n }\n \n+fn fold_stmt<F>(cx: &mut Context<F>, stmt: P<ast::Stmt>) -> SmallVector<P<ast::Stmt>>\n+    where F: FnMut(&[ast::Attribute]) -> bool\n+{\n+    if stmt_in_cfg(cx, &stmt) {\n+        stmt.and_then(|s| fold::noop_fold_stmt(s, cx))\n+    } else {\n+        SmallVector::zero()\n+    }\n+}\n+\n+fn stmt_in_cfg<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n+    (cx.in_cfg)(stmt.node.attrs())\n+}\n+\n+fn expr_in_cfg<F>(cx: &mut Context<F>, expr: &ast::Expr) -> bool where\n+    F: FnMut(&[ast::Attribute]) -> bool\n+{\n+    (cx.in_cfg)(expr.attrs())\n+}\n+\n fn item_in_cfg<F>(cx: &mut Context<F>, item: &ast::Item) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n@@ -248,44 +259,51 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(&item.attrs);\n }\n \n+fn is_cfg(attr: &ast::Attribute) -> bool {\n+    attr.check_name(\"cfg\")\n+}\n+\n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(diagnostic: &SpanHandler, cfg: &[P<ast::MetaItem>], attrs: &[ast::Attribute],\n-          feature_gated_cfgs: &mut Vec<GatedCfg>) -> bool {\n+fn in_cfg<T: CfgDiag>(cfg: &[P<ast::MetaItem>],\n+                      attrs: &[ast::Attribute],\n+                      diag: &mut T) -> bool {\n     attrs.iter().all(|attr| {\n         let mis = match attr.node.value.node {\n-            ast::MetaList(_, ref mis) if attr.check_name(\"cfg\") => mis,\n+            ast::MetaList(_, ref mis) if is_cfg(&attr) => mis,\n             _ => return true\n         };\n \n         if mis.len() != 1 {\n-            diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+            diag.emit_error(|diagnostic| {\n+                diagnostic.span_err(attr.span, \"expected 1 cfg-pattern\");\n+            });\n             return true;\n         }\n \n-        attr::cfg_matches(diagnostic, cfg, &mis[0],\n-                          feature_gated_cfgs)\n+        attr::cfg_matches(cfg, &mis[0], diag)\n     })\n }\n \n-struct CfgAttrFolder<'a, 'b> {\n-    diag: &'a SpanHandler,\n-    config: ast::CrateConfig,\n-    feature_gated_cfgs: &'b mut Vec<GatedCfg>\n+struct CfgAttrFolder<'a, T> {\n+    diag: T,\n+    config: &'a ast::CrateConfig,\n }\n \n // Process `#[cfg_attr]`.\n fn process_cfg_attr(diagnostic: &SpanHandler, krate: ast::Crate,\n-                    feature_gated_cfgs: &mut Vec<GatedCfg>) -> ast::Crate {\n+                    feature_gated_cfgs: &mut Vec<GatedCfgAttr>) -> ast::Crate {\n     let mut fld = CfgAttrFolder {\n-        diag: diagnostic,\n-        config: krate.config.clone(),\n-        feature_gated_cfgs: feature_gated_cfgs,\n+        diag: CfgDiagReal {\n+            diag: diagnostic,\n+            feature_gated_cfgs: feature_gated_cfgs,\n+        },\n+        config: &krate.config.clone(),\n     };\n     fld.fold_crate(krate)\n }\n \n-impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n+impl<'a, T: CfgDiag> fold::Folder for CfgAttrFolder<'a, T> {\n     fn fold_attribute(&mut self, attr: ast::Attribute) -> Option<ast::Attribute> {\n         if !attr.check_name(\"cfg_attr\") {\n             return fold::noop_fold_attribute(attr, self);\n@@ -294,20 +312,25 @@ impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n         let attr_list = match attr.meta_item_list() {\n             Some(attr_list) => attr_list,\n             None => {\n-                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                self.diag.emit_error(|diag| {\n+                    diag.span_err(attr.span,\n+                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                });\n                 return None;\n             }\n         };\n         let (cfg, mi) = match (attr_list.len(), attr_list.get(0), attr_list.get(1)) {\n             (2, Some(cfg), Some(mi)) => (cfg, mi),\n             _ => {\n-                self.diag.span_err(attr.span, \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                self.diag.emit_error(|diag| {\n+                    diag.span_err(attr.span,\n+                        \"expected `#[cfg_attr(<cfg pattern>, <attr>)]`\");\n+                });\n                 return None;\n             }\n         };\n \n-        if attr::cfg_matches(self.diag, &self.config[..], &cfg,\n-                             self.feature_gated_cfgs) {\n+        if attr::cfg_matches(&self.config[..], &cfg, &mut self.diag) {\n             Some(respan(mi.span, ast::Attribute_ {\n                 id: attr::mk_attr_id(),\n                 style: attr.node.style,\n@@ -324,3 +347,174 @@ impl<'a,'b> fold::Folder for CfgAttrFolder<'a,'b> {\n         fold::noop_fold_mac(mac, self)\n     }\n }\n+\n+fn check_for_gated_stmt_expr_attributes(krate: &ast::Crate,\n+                                        discovered: &mut Vec<GatedCfgAttr>) {\n+    let mut v = StmtExprAttrFeatureVisitor {\n+        config: &krate.config,\n+        discovered: discovered,\n+    };\n+    visit::walk_crate(&mut v, krate);\n+}\n+\n+/// To cover this feature, we need to discover all attributes\n+/// so we need to run before cfg.\n+struct StmtExprAttrFeatureVisitor<'a, 'b> {\n+    config: &'a ast::CrateConfig,\n+    discovered: &'b mut Vec<GatedCfgAttr>,\n+}\n+\n+// Runs the cfg_attr and cfg folders locally in \"silent\" mode\n+// to discover attribute use on stmts or expressions ahead of time\n+impl<'v, 'a, 'b> visit::Visitor<'v> for StmtExprAttrFeatureVisitor<'a, 'b> {\n+    fn visit_stmt(&mut self, s: &'v ast::Stmt) {\n+        // check if there even are any attributes on this node\n+        let stmt_attrs = s.node.attrs();\n+        if stmt_attrs.len() > 0 {\n+            // attributes on items are fine\n+            if let ast::StmtDecl(ref decl, _) = s.node {\n+                if let ast::DeclItem(_) = decl.node {\n+                    visit::walk_stmt(self, s);\n+                    return;\n+                }\n+            }\n+\n+            // flag the offending attributes\n+            for attr in stmt_attrs {\n+                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n+            }\n+\n+            // if the node does not end up being cfg-d away, walk down\n+            if node_survives_cfg(stmt_attrs, self.config) {\n+                visit::walk_stmt(self, s);\n+            }\n+        } else {\n+            visit::walk_stmt(self, s);\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'v ast::Expr) {\n+        // check if there even are any attributes on this node\n+        let expr_attrs = ex.attrs();\n+        if expr_attrs.len() > 0 {\n+\n+            // flag the offending attributes\n+            for attr in expr_attrs {\n+                self.discovered.push(GatedCfgAttr::GatedAttr(attr.span));\n+            }\n+\n+            // if the node does not end up being cfg-d away, walk down\n+            if node_survives_cfg(expr_attrs, self.config) {\n+                visit::walk_expr(self, ex);\n+            }\n+        } else {\n+            visit::walk_expr(self, ex);\n+        }\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'v ast::ForeignItem) {\n+        if node_survives_cfg(&i.attrs, self.config) {\n+            visit::walk_foreign_item(self, i);\n+        }\n+    }\n+\n+    fn visit_item(&mut self, i: &'v ast::Item) {\n+        if node_survives_cfg(&i.attrs, self.config) {\n+            visit::walk_item(self, i);\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'v ast::ImplItem) {\n+        if node_survives_cfg(&ii.attrs, self.config) {\n+            visit::walk_impl_item(self, ii);\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'v ast::TraitItem) {\n+        if node_survives_cfg(&ti.attrs, self.config) {\n+            visit::walk_trait_item(self, ti);\n+        }\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'v ast::StructField) {\n+        if node_survives_cfg(&s.node.attrs, self.config) {\n+            visit::walk_struct_field(self, s);\n+        }\n+    }\n+\n+    fn visit_variant(&mut self, v: &'v ast::Variant,\n+                     g: &'v ast::Generics, item_id: ast::NodeId) {\n+        if node_survives_cfg(&v.node.attrs, self.config) {\n+            visit::walk_variant(self, v, g, item_id);\n+        }\n+    }\n+\n+    fn visit_arm(&mut self, a: &'v ast::Arm) {\n+        if node_survives_cfg(&a.attrs, self.config) {\n+            visit::walk_arm(self, a);\n+        }\n+    }\n+\n+    // This visitor runs pre expansion, so we need to prevent\n+    // the default panic here\n+    fn visit_mac(&mut self, mac: &'v ast::Mac) {\n+        visit::walk_mac(self, mac)\n+    }\n+}\n+\n+pub trait CfgDiag {\n+    fn emit_error<F>(&mut self, f: F) where F: FnMut(&SpanHandler);\n+    fn flag_gated<F>(&mut self, f: F) where F: FnMut(&mut Vec<GatedCfgAttr>);\n+}\n+\n+pub struct CfgDiagReal<'a, 'b> {\n+    pub diag: &'a SpanHandler,\n+    pub feature_gated_cfgs: &'b mut Vec<GatedCfgAttr>,\n+}\n+\n+impl<'a, 'b> CfgDiag for CfgDiagReal<'a, 'b> {\n+    fn emit_error<F>(&mut self, mut f: F) where F: FnMut(&SpanHandler) {\n+        f(self.diag)\n+    }\n+    fn flag_gated<F>(&mut self, mut f: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {\n+        f(self.feature_gated_cfgs)\n+    }\n+}\n+\n+struct CfgDiagSilent {\n+    error: bool,\n+}\n+\n+impl CfgDiag for CfgDiagSilent {\n+    fn emit_error<F>(&mut self, _: F) where F: FnMut(&SpanHandler) {\n+        self.error = true;\n+    }\n+    fn flag_gated<F>(&mut self, _: F) where F: FnMut(&mut Vec<GatedCfgAttr>) {}\n+}\n+\n+fn node_survives_cfg(attrs: &[ast::Attribute],\n+                     config: &ast::CrateConfig) -> bool {\n+    let mut survives_cfg = true;\n+\n+    for attr in attrs {\n+        let mut fld = CfgAttrFolder {\n+            diag: CfgDiagSilent { error: false },\n+            config: config,\n+        };\n+        let attr = fld.fold_attribute(attr.clone());\n+\n+        // In case of error we can just return true,\n+        // since the actual cfg folders will end compilation anyway.\n+\n+        if fld.diag.error { return true; }\n+\n+        survives_cfg &= attr.map(|attr| {\n+            let mut diag = CfgDiagSilent { error: false };\n+            let r = in_cfg(config, &[attr], &mut diag);\n+            if diag.error { return true; }\n+            r\n+        }).unwrap_or(true)\n+    }\n+\n+    survives_cfg\n+}"}, {"sha": "d968858f634eb60f20267808233d1cb90f0604ce", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -233,6 +233,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             dialect: dialect,\n             expn_id: expn_id,\n         }),\n-        span: sp\n+        span: sp,\n+        attrs: None,\n     }))\n }"}, {"sha": "3b613922bc947f89a7081ad79513aefc5fca0850", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -17,7 +17,7 @@ use codemap::{CodeMap, Span, ExpnId, ExpnInfo, NO_EXPANSION};\n use ext;\n use ext::expand;\n use ext::tt::macro_rules;\n-use feature_gate::GatedCfg;\n+use feature_gate::GatedCfgAttr;\n use parse;\n use parse::parser;\n use parse::token;\n@@ -350,6 +350,7 @@ impl DummyResult {\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ExprLit(P(codemap::respan(sp, ast::LitBool(false)))),\n             span: sp,\n+            attrs: None,\n         })\n     }\n \n@@ -572,7 +573,7 @@ pub struct ExtCtxt<'a> {\n     pub backtrace: ExpnId,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub crate_root: Option<&'static str>,\n-    pub feature_gated_cfgs: &'a mut Vec<GatedCfg>,\n+    pub feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>,\n \n     pub mod_path: Vec<ast::Ident> ,\n     pub exported_macros: Vec<ast::MacroDef>,\n@@ -584,7 +585,7 @@ pub struct ExtCtxt<'a> {\n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess, cfg: ast::CrateConfig,\n                ecfg: expand::ExpansionConfig<'a>,\n-               feature_gated_cfgs: &'a mut Vec<GatedCfg>) -> ExtCtxt<'a> {\n+               feature_gated_cfgs: &'a mut Vec<GatedCfgAttr>) -> ExtCtxt<'a> {\n         let env = initial_syntax_expander_table(&ecfg);\n         ExtCtxt {\n             parse_sess: parse_sess,"}, {"sha": "806f5a7ee22ed36cec7529a9d89836dd503eb515", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -525,6 +525,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n+            attrs: None,\n         });\n         let decl = respan(sp, ast::DeclLocal(local));\n         P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n@@ -548,6 +549,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             init: Some(ex),\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n+            attrs: None,\n         });\n         let decl = respan(sp, ast::DeclLocal(local));\n         P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))\n@@ -584,6 +586,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n+            attrs: None,\n         })\n     }\n "}, {"sha": "e100355e4f8682a2ead0ccbdb7fce1956bab7e5a", "filename": "src/libsyntax/ext/cfg.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fcfg.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -20,6 +20,7 @@ use ext::build::AstBuilder;\n use attr;\n use attr::*;\n use parse::token;\n+use config::CfgDiagReal;\n \n pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        sp: Span,\n@@ -33,7 +34,12 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cx.parse_sess.span_diagnostic, &cx.cfg, &cfg,\n-                                        cx.feature_gated_cfgs);\n+    let matches_cfg = {\n+        let mut diag = CfgDiagReal {\n+            diag: &cx.parse_sess.span_diagnostic,\n+            feature_gated_cfgs: cx.feature_gated_cfgs,\n+        };\n+        attr::cfg_matches(&cx.cfg, &cfg, &mut diag)\n+    };\n     MacEager::expr(cx.expr_bool(sp, matches_cfg))\n }"}, {"sha": "c2233202b2f81067ee9abbd9413f358e9d7cc09e", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -67,6 +67,7 @@ pub fn expand_syntax_ext<'cx>(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n             }\n         ),\n         span: sp,\n+        attrs: None,\n     });\n     MacEager::expr(e)\n }"}, {"sha": "9488cfb86fc9fd6d2439acb2d65517e192b76a06", "filename": "src/libsyntax/ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdebug.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -148,6 +148,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt,\n         init: Some(expr),\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n+        attrs: None,\n     });\n     let decl = respan(sp, ast::DeclLocal(local));\n     P(respan(sp, ast::StmtDecl(P(decl), ast::DUMMY_NODE_ID)))"}, {"sha": "bd89430d81de04b9ee8b2a3a26e679625162c042", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -204,7 +204,7 @@ use ext::build::AstBuilder;\n use codemap::{self, DUMMY_SP};\n use codemap::Span;\n use diagnostic::SpanHandler;\n-use fold::MoveMap;\n+use util::move_map::MoveMap;\n use owned_slice::OwnedSlice;\n use parse::token::{intern, InternedString};\n use parse::token::special_idents;"}, {"sha": "573f4cfe8fa5d8d811872e32d5725e77a455bba3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -17,13 +17,14 @@ use ast;\n use ext::mtwt;\n use ext::build::AstBuilder;\n use attr;\n-use attr::AttrMetaMethods;\n+use attr::{AttrMetaMethods, WithAttrs};\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use ext::base::*;\n-use feature_gate::{self, Features, GatedCfg};\n+use feature_gate::{self, Features, GatedCfgAttr};\n use fold;\n use fold::*;\n+use util::move_map::MoveMap;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n use ptr::P;\n@@ -37,11 +38,15 @@ use std::collections::HashSet;\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n     let expr_span = e.span;\n-    return e.and_then(|ast::Expr {id, node, span}| match node {\n+    return e.and_then(|ast::Expr {id, node, span, attrs}| match node {\n \n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ast::ExprMac(mac) => {\n+\n+            // Assert that we drop any macro attributes on the floor here\n+            drop(attrs);\n+\n             let expanded_expr = match expand_mac_invoc(mac, span,\n                                                        |r| r.make_expr(),\n                                                        mark_expr, fld) {\n@@ -60,6 +65,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                 id: ast::DUMMY_NODE_ID,\n                 node: e.node,\n                 span: span,\n+                attrs: e.attrs,\n             })\n         }\n \n@@ -73,12 +79,14 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n             fld.cx.expr(span, ast::ExprInPlace(placer, value_expr))\n+                .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprWhile(cond, body, opt_ident))\n+                .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n         ast::ExprWhileLet(pat, expr, body, opt_ident) => {\n@@ -96,11 +104,13 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             assert!(rewritten_pats.len() == 1);\n \n             fld.cx.expr(span, ast::ExprWhileLet(rewritten_pats.remove(0), expr, body, opt_ident))\n+                .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n         ast::ExprLoop(loop_block, opt_ident) => {\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n+                .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n@@ -118,6 +128,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             let head = fld.fold_expr(head);\n             fld.cx.expr(span, ast::ExprForLoop(rewritten_pats.remove(0), head, body, opt_ident))\n+                .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n         ast::ExprIfLet(pat, sub_expr, body, else_opt) => {\n@@ -136,6 +147,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let else_opt = else_opt.map(|else_opt| fld.fold_expr(else_opt));\n             let sub_expr = fld.fold_expr(sub_expr);\n             fld.cx.expr(span, ast::ExprIfLet(rewritten_pats.remove(0), sub_expr, body, else_opt))\n+                .with_attrs(fold_thin_attrs(attrs, fld))\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {\n@@ -144,14 +156,16 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             let new_node = ast::ExprClosure(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n-            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n+            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span),\n+                        attrs: fold_thin_attrs(attrs, fld)})\n         }\n \n         _ => {\n             P(noop_fold_expr(ast::Expr {\n                 id: id,\n                 node: node,\n-                span: span\n+                span: span,\n+                attrs: attrs\n             }, fld))\n         }\n     });\n@@ -487,11 +501,14 @@ pub fn expand_item_mac(it: P<ast::Item>,\n /// Expand a stmt\n fn expand_stmt(stmt: P<Stmt>, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let stmt = stmt.and_then(|stmt| stmt);\n-    let (mac, style) = match stmt.node {\n-        StmtMac(mac, style) => (mac, style),\n+    let (mac, style, attrs) = match stmt.node {\n+        StmtMac(mac, style, attrs) => (mac, style, attrs),\n         _ => return expand_non_macro_stmt(stmt, fld)\n     };\n \n+    // Assert that we drop any macro attributes on the floor here\n+    drop(attrs);\n+\n     let maybe_new_items =\n         expand_mac_invoc(mac.and_then(|m| m), stmt.span,\n                          |r| r.make_stmts(),\n@@ -539,7 +556,7 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n         StmtDecl(decl, node_id) => decl.and_then(|Spanned {node: decl, span}| match decl {\n             DeclLocal(local) => {\n                 // take it apart:\n-                let rewritten_local = local.map(|Local {id, pat, ty, init, span}| {\n+                let rewritten_local = local.map(|Local {id, pat, ty, init, span, attrs}| {\n                     // expand the ty since TyFixedLengthVec contains an Expr\n                     // and thus may have a macro use\n                     let expanded_ty = ty.map(|t| fld.fold_ty(t));\n@@ -569,7 +586,8 @@ fn expand_non_macro_stmt(Spanned {node, span: stmt_span}: Stmt, fld: &mut MacroE\n                         pat: rewritten_pat,\n                         // also, don't forget to expand the init:\n                         init: init.map(|e| fld.fold_expr(e)),\n-                        span: span\n+                        span: span,\n+                        attrs: fold::fold_thin_attrs(attrs, fld),\n                     }\n                 });\n                 SmallVector::one(P(Spanned {\n@@ -1263,7 +1281,7 @@ pub fn expand_crate<'feat>(parse_sess: &parse::ParseSess,\n                            // these are the macros being imported to this crate:\n                            imported_macros: Vec<ast::MacroDef>,\n                            user_exts: Vec<NamedSyntaxExtension>,\n-                           feature_gated_cfgs: &mut Vec<GatedCfg>,\n+                           feature_gated_cfgs: &mut Vec<GatedCfgAttr>,\n                            c: Crate) -> (Crate, HashSet<Name>) {\n     let mut cx = ExtCtxt::new(parse_sess, c.config.clone(), cfg,\n                               feature_gated_cfgs);"}, {"sha": "fc6cacb40f1f37d95511ad8f083cce399c59fe0a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -242,6 +242,7 @@ pub mod rt {\n                 id: ast::DUMMY_NODE_ID,\n                 node: ast::ExprLit(P(self.clone())),\n                 span: DUMMY_SP,\n+                attrs: None,\n             }).to_tokens(cx)\n         }\n     }"}, {"sha": "e00c3e3bea409d75437c6d3af393fbc4f26a2d9a", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -227,6 +227,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n \n     // Allows cfg(target_vendor = \"...\").\n     (\"cfg_target_vendor\", \"1.5.0\", Some(29718), Active),\n+\n+    // Allow attributes on expressions and non-item statements\n+    (\"stmt_expr_attributes\", \"1.6.0\", Some(15701), Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -407,25 +410,57 @@ const GATED_CFGS: &'static [(&'static str, &'static str, fn(&Features) -> bool)]\n     (\"target_vendor\", \"cfg_target_vendor\", cfg_fn!(|x| x.cfg_target_vendor)),\n ];\n \n+#[derive(Debug, Eq, PartialEq)]\n+pub enum GatedCfgAttr {\n+    GatedCfg(GatedCfg),\n+    GatedAttr(Span),\n+}\n+\n #[derive(Debug, Eq, PartialEq)]\n pub struct GatedCfg {\n     span: Span,\n     index: usize,\n }\n \n-impl Ord for GatedCfg {\n-    fn cmp(&self, other: &GatedCfg) -> cmp::Ordering {\n-        (self.span.lo.0, self.span.hi.0, self.index)\n-            .cmp(&(other.span.lo.0, other.span.hi.0, other.index))\n+impl Ord for GatedCfgAttr {\n+    fn cmp(&self, other: &GatedCfgAttr) -> cmp::Ordering {\n+        let to_tup = |s: &GatedCfgAttr| match *s {\n+            GatedCfgAttr::GatedCfg(ref gated_cfg) => {\n+                (gated_cfg.span.lo.0, gated_cfg.span.hi.0, gated_cfg.index)\n+            }\n+            GatedCfgAttr::GatedAttr(ref span) => {\n+                (span.lo.0, span.hi.0, GATED_CFGS.len())\n+            }\n+        };\n+        to_tup(self).cmp(&to_tup(other))\n     }\n }\n \n-impl PartialOrd for GatedCfg {\n-    fn partial_cmp(&self, other: &GatedCfg) -> Option<cmp::Ordering> {\n+impl PartialOrd for GatedCfgAttr {\n+    fn partial_cmp(&self, other: &GatedCfgAttr) -> Option<cmp::Ordering> {\n         Some(self.cmp(other))\n     }\n }\n \n+impl GatedCfgAttr {\n+    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+        match *self {\n+            GatedCfgAttr::GatedCfg(ref cfg) => {\n+                cfg.check_and_emit(diagnostic, features);\n+            }\n+            GatedCfgAttr::GatedAttr(span) => {\n+                if !features.stmt_expr_attributes {\n+                    emit_feature_err(diagnostic,\n+                                     \"stmt_expr_attributes\",\n+                                     span,\n+                                     GateIssue::Language,\n+                                     EXPLAIN_STMT_ATTR_SYNTAX);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n         let name = cfg.name();\n@@ -438,7 +473,7 @@ impl GatedCfg {\n                       }\n                   })\n     }\n-    pub fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n+    fn check_and_emit(&self, diagnostic: &SpanHandler, features: &Features) {\n         let (cfg, feature, has_feature) = GATED_CFGS[self.index];\n         if !has_feature(features) {\n             let explain = format!(\"`cfg({})` is experimental and subject to change\", cfg);\n@@ -504,6 +539,7 @@ pub struct Features {\n     pub augmented_assignments: bool,\n     pub braced_empty_structs: bool,\n     pub staged_api: bool,\n+    pub stmt_expr_attributes: bool,\n }\n \n impl Features {\n@@ -537,6 +573,7 @@ impl Features {\n             augmented_assignments: false,\n             braced_empty_structs: false,\n             staged_api: false,\n+            stmt_expr_attributes: false,\n         }\n     }\n }\n@@ -550,6 +587,9 @@ const EXPLAIN_PLACEMENT_IN: &'static str =\n const EXPLAIN_PUSHPOP_UNSAFE: &'static str =\n     \"push/pop_unsafe macros are experimental and subject to change.\";\n \n+const EXPLAIN_STMT_ATTR_SYNTAX: &'static str =\n+    \"attributes on non-item statements and expressions are experimental.\";\n+\n pub fn check_for_box_syntax(f: Option<&Features>, diag: &SpanHandler, span: Span) {\n     if let Some(&Features { allow_box: true, .. }) = f {\n         return;\n@@ -1111,6 +1151,7 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n         augmented_assignments: cx.has_feature(\"augmented_assignments\"),\n         braced_empty_structs: cx.has_feature(\"braced_empty_structs\"),\n         staged_api: cx.has_feature(\"staged_api\"),\n+        stmt_expr_attributes: cx.has_feature(\"stmt_expr_attributes\"),\n     }\n }\n "}, {"sha": "73f2c51b246222a90bae743f392410e1a049ef33", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -20,39 +20,17 @@\n \n use ast::*;\n use ast;\n+use attr::{ThinAttributes, ThinAttributesExt};\n use ast_util;\n use codemap::{respan, Span, Spanned};\n use owned_slice::OwnedSlice;\n use parse::token;\n use ptr::P;\n-use std::ptr;\n use util::small_vector::SmallVector;\n+use util::move_map::MoveMap;\n \n use std::rc::Rc;\n \n-// This could have a better place to live.\n-pub trait MoveMap<T> {\n-    fn move_map<F>(self, f: F) -> Self where F: FnMut(T) -> T;\n-}\n-\n-impl<T> MoveMap<T> for Vec<T> {\n-    fn move_map<F>(mut self, mut f: F) -> Vec<T> where F: FnMut(T) -> T {\n-        for p in &mut self {\n-            unsafe {\n-                // FIXME(#5016) this shouldn't need to zero to be safe.\n-                ptr::write(p, f(ptr::read_and_drop(p)));\n-            }\n-        }\n-        self\n-    }\n-}\n-\n-impl<T> MoveMap<T> for OwnedSlice<T> {\n-    fn move_map<F>(self, f: F) -> OwnedSlice<T> where F: FnMut(T) -> T {\n-        OwnedSlice::from_vec(self.into_vec().move_map(f))\n-    }\n-}\n-\n pub trait Folder : Sized {\n     // Any additions to this trait should happen in form\n     // of a call to a public `noop_*` function that only calls\n@@ -134,6 +112,14 @@ pub trait Folder : Sized {\n         e.map(|e| noop_fold_expr(e, self))\n     }\n \n+    fn fold_opt_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n+        noop_fold_opt_expr(e, self)\n+    }\n+\n+    fn fold_exprs(&mut self, es: Vec<P<Expr>>) -> Vec<P<Expr>> {\n+        noop_fold_exprs(es, self)\n+    }\n+\n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         noop_fold_ty(t, self)\n     }\n@@ -353,7 +339,11 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n }\n \n pub fn fold_attrs<T: Folder>(attrs: Vec<Attribute>, fld: &mut T) -> Vec<Attribute> {\n-    attrs.into_iter().flat_map(|x| fld.fold_attribute(x)).collect()\n+    attrs.move_flat_map(|x| fld.fold_attribute(x))\n+}\n+\n+pub fn fold_thin_attrs<T: Folder>(attrs: ThinAttributes, fld: &mut T) -> ThinAttributes {\n+    attrs.map_thin_attrs(|v| fold_attrs(v, fld))\n }\n \n pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n@@ -508,12 +498,13 @@ pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedPara\n }\n \n pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n-    l.map(|Local {id, pat, ty, init, span}| Local {\n+    l.map(|Local {id, pat, ty, init, span, attrs}| Local {\n         id: fld.new_id(id),\n         ty: ty.map(|t| fld.fold_ty(t)),\n         pat: fld.fold_pat(pat),\n         init: init.map(|e| fld.fold_expr(e)),\n-        span: fld.new_span(span)\n+        span: fld.new_span(span),\n+        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, fld)),\n     })\n }\n \n@@ -609,6 +600,8 @@ pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n }\n \n pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree> {\n+    // FIXME: Does this have to take a tts slice?\n+    // Could use move_map otherwise...\n     tts.iter().map(|tt| fld.fold_tt(tt)).collect()\n }\n \n@@ -890,8 +883,8 @@ fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n     b.map(|Block {id, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n-        stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n-        expr: expr.map(|x| folder.fold_expr(x)),\n+        stmts: stmts.move_flat_map(|s| folder.fold_stmt(s).into_iter()),\n+        expr: expr.and_then(|x| folder.fold_opt_expr(x)),\n         rules: rules,\n         span: folder.new_span(span),\n     })\n@@ -939,9 +932,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemDefaultImpl(unsafety, folder.fold_trait_ref((*trait_ref).clone()))\n         }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let new_impl_items = impl_items.into_iter().flat_map(|item| {\n-                folder.fold_impl_item(item).into_iter()\n-            }).collect();\n+            let new_impl_items = impl_items.move_flat_map(|item| {\n+                folder.fold_impl_item(item)\n+            });\n             let ifce = match ifce {\n                 None => None,\n                 Some(ref trait_ref) => {\n@@ -957,9 +950,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         }\n         ItemTrait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let items = items.into_iter().flat_map(|item| {\n-                folder.fold_trait_item(item).into_iter()\n-            }).collect();\n+            let items = items.move_flat_map(|item| {\n+                folder.fold_trait_item(item)\n+            });\n             ItemTrait(unsafety,\n                       folder.fold_generics(generics),\n                       bounds,\n@@ -1018,7 +1011,7 @@ pub fn noop_fold_impl_item<T: Folder>(i: P<ImplItem>, folder: &mut T)\n pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n+        items: items.move_flat_map(|x| folder.fold_item(x)),\n     }\n }\n \n@@ -1171,7 +1164,7 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n     })\n }\n \n-pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) -> Expr {\n+pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mut T) -> Expr {\n     Expr {\n         id: folder.new_id(id),\n         node: match node {\n@@ -1182,21 +1175,21 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                 ExprInPlace(folder.fold_expr(p), folder.fold_expr(e))\n             }\n             ExprVec(exprs) => {\n-                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n+                ExprVec(folder.fold_exprs(exprs))\n             }\n             ExprRepeat(expr, count) => {\n                 ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n             }\n-            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n+            ExprTup(exprs) => ExprTup(folder.fold_exprs(exprs)),\n             ExprCall(f, args) => {\n                 ExprCall(folder.fold_expr(f),\n-                         args.move_map(|x| folder.fold_expr(x)))\n+                         folder.fold_exprs(args))\n             }\n             ExprMethodCall(i, tps, args) => {\n                 ExprMethodCall(\n                     respan(folder.new_span(i.span), folder.fold_ident(i.node)),\n                     tps.move_map(|x| folder.fold_ty(x)),\n-                    args.move_map(|x| folder.fold_expr(x)))\n+                    folder.fold_exprs(args))\n             }\n             ExprBinary(binop, lhs, rhs) => {\n                 ExprBinary(binop,\n@@ -1329,10 +1322,19 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             },\n             ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n         },\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n+        attrs: attrs.map_thin_attrs(|v| fold_attrs(v, folder)),\n     }\n }\n \n+pub fn noop_fold_opt_expr<T: Folder>(e: P<Expr>, folder: &mut T) -> Option<P<Expr>> {\n+    Some(folder.fold_expr(e))\n+}\n+\n+pub fn noop_fold_exprs<T: Folder>(es: Vec<P<Expr>>, folder: &mut T) -> Vec<P<Expr>> {\n+    es.move_flat_map(|e| folder.fold_opt_expr(e))\n+}\n+\n pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n                                  -> SmallVector<P<Stmt>> {\n     let span = folder.new_span(span);\n@@ -1346,20 +1348,30 @@ pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n         }\n         StmtExpr(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(P(Spanned {\n-                node: StmtExpr(folder.fold_expr(e), id),\n-                span: span\n-            }))\n+            if let Some(e) = folder.fold_opt_expr(e) {\n+                SmallVector::one(P(Spanned {\n+                    node: StmtExpr(e, id),\n+                    span: span\n+                }))\n+            } else {\n+                SmallVector::zero()\n+            }\n         }\n         StmtSemi(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(P(Spanned {\n-                node: StmtSemi(folder.fold_expr(e), id),\n-                span: span\n-            }))\n+            if let Some(e) = folder.fold_opt_expr(e) {\n+                SmallVector::one(P(Spanned {\n+                    node: StmtSemi(e, id),\n+                    span: span\n+                }))\n+            } else {\n+                SmallVector::zero()\n+            }\n         }\n-        StmtMac(mac, semi) => SmallVector::one(P(Spanned {\n-            node: StmtMac(mac.map(|m| folder.fold_mac(m)), semi),\n+        StmtMac(mac, semi, attrs) => SmallVector::one(P(Spanned {\n+            node: StmtMac(mac.map(|m| folder.fold_mac(m)),\n+                          semi,\n+                          attrs.map_thin_attrs(|v| fold_attrs(v, folder))),\n             span: span\n         }))\n     }"}, {"sha": "9401999465bfba7341ba5d454b7818c4aa3c42a4", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -71,6 +71,7 @@ pub mod util {\n     #[cfg(test)]\n     pub mod parser_testing;\n     pub mod small_vector;\n+    pub mod move_map;\n }\n \n pub mod diagnostics {"}, {"sha": "e9c8173a4d9802e4bc6b0f5d7a36f0e6a06aa8e9", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -699,7 +699,8 @@ mod tests {\n                             }\n                         ),\n                     }),\n-                    span: sp(0, 1)\n+                    span: sp(0, 1),\n+                    attrs: None,\n                    }))\n     }\n \n@@ -721,7 +722,8 @@ mod tests {\n                                 }\n                             )\n                         }),\n-                    span: sp(0, 6)\n+                    span: sp(0, 6),\n+                    attrs: None,\n                    }))\n     }\n \n@@ -848,9 +850,11 @@ mod tests {\n                                 }\n                             ),\n                         }),\n-                        span:sp(7,8)\n+                        span:sp(7,8),\n+                        attrs: None,\n                     }))),\n-                    span:sp(0,8)\n+                    span:sp(0,8),\n+                    attrs: None,\n                    }))\n     }\n \n@@ -869,7 +873,8 @@ mod tests {\n                                 }\n                                ),\n                             }),\n-                           span: sp(0,1)}),\n+                           span: sp(0,1),\n+                           attrs: None}),\n                                            ast::DUMMY_NODE_ID),\n                        span: sp(0,1)})))\n \n@@ -963,7 +968,8 @@ mod tests {\n                                                             }\n                                                         ),\n                                                       }),\n-                                                span: sp(17,18)}),\n+                                                span: sp(17,18),\n+                                                attrs: None,}),\n                                                 ast::DUMMY_NODE_ID),\n                                             span: sp(17,19)})),\n                                         expr: None,"}, {"sha": "7502a8cbc35466156a00ce3238eeb1d2e9519133", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 302, "deletions": 146, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -56,6 +56,7 @@ use ast::TypeTraitItem;\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n+use attr::{ThinAttributes, ThinAttributesExt, AttributesExt};\n use ast;\n use ast_util::{self, ident_to_path};\n use codemap::{self, Span, BytePos, Spanned, spanned, mk_sp, CodeMap};\n@@ -140,7 +141,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt)))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprPath(None, pt), None))\n                 }\n                 token::Interpolated(token::NtBlock(_)) => {\n                     // FIXME: The following avoids an issue with lexical borrowck scopes,\n@@ -150,7 +151,7 @@ macro_rules! maybe_whole_expr {\n                         _ => unreachable!()\n                     };\n                     let span = $p.span;\n-                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b)))\n+                    Some($p.mk_expr(span.lo, span.hi, ExprBlock(b), None))\n                 }\n                 _ => None\n             };\n@@ -319,6 +320,27 @@ pub struct ModulePathError {\n     pub help_msg: String,\n }\n \n+pub enum LhsExpr {\n+    NotYetParsed,\n+    AttributesParsed(ThinAttributes),\n+    AlreadyParsed(P<Expr>),\n+}\n+\n+impl From<Option<ThinAttributes>> for LhsExpr {\n+    fn from(o: Option<ThinAttributes>) -> Self {\n+        if let Some(attrs) = o {\n+            LhsExpr::AttributesParsed(attrs)\n+        } else {\n+            LhsExpr::NotYetParsed\n+        }\n+    }\n+}\n+\n+impl From<P<Expr>> for LhsExpr {\n+    fn from(expr: P<Expr>) -> Self {\n+        LhsExpr::AlreadyParsed(expr)\n+    }\n+}\n \n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n@@ -1557,19 +1579,18 @@ impl<'a> Parser<'a> {\n     }\n \n     /// matches '-' lit | lit\n-    pub fn parse_literal_maybe_minus(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_pat_literal_maybe_minus(&mut self) -> PResult<P<Expr>> {\n         let minus_lo = self.span.lo;\n         let minus_present = try!(self.eat(&token::BinOp(token::Minus)));\n-\n         let lo = self.span.lo;\n         let literal = P(try!(self.parse_lit()));\n         let hi = self.last_span.hi;\n-        let expr = self.mk_expr(lo, hi, ExprLit(literal));\n+        let expr = self.mk_expr(lo, hi, ExprLit(literal), None);\n \n         if minus_present {\n             let minus_hi = self.last_span.hi;\n             let unary = self.mk_unary(UnNeg, expr);\n-            Ok(self.mk_expr(minus_lo, minus_hi, unary))\n+            Ok(self.mk_expr(minus_lo, minus_hi, unary, None))\n         } else {\n             Ok(expr)\n         }\n@@ -1914,11 +1935,13 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos, node: Expr_) -> P<Expr> {\n+    pub fn mk_expr(&mut self, lo: BytePos, hi: BytePos,\n+                   node: Expr_, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n+            attrs: attrs,\n         })\n     }\n \n@@ -1966,15 +1989,17 @@ impl<'a> Parser<'a> {\n         ExprAssignOp(binop, lhs, rhs)\n     }\n \n-    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos, m: Mac_) -> P<Expr> {\n+    pub fn mk_mac_expr(&mut self, lo: BytePos, hi: BytePos,\n+                       m: Mac_, attrs: ThinAttributes) -> P<Expr> {\n         P(Expr {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n+            attrs: attrs,\n         })\n     }\n \n-    pub fn mk_lit_u32(&mut self, i: u32) -> P<Expr> {\n+    pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinAttributes) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n             node: LitInt(i as u64, ast::UnsignedIntLit(TyU32)),\n@@ -1985,6 +2010,7 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: ExprLit(lv_lit),\n             span: *span,\n+            attrs: attrs,\n         })\n     }\n \n@@ -2002,9 +2028,20 @@ impl<'a> Parser<'a> {\n     /// At the bottom (top?) of the precedence hierarchy,\n     /// parse things like parenthesized exprs,\n     /// macros, return, etc.\n-    pub fn parse_bottom_expr(&mut self) -> PResult<P<Expr>> {\n+    ///\n+    /// NB: This does not parse outer attributes,\n+    ///     and is private because it only works\n+    ///     correctly if called from parse_dot_or_call_expr().\n+    fn parse_bottom_expr(&mut self) -> PResult<P<Expr>> {\n         maybe_whole_expr!(self);\n \n+        // Outer attributes are already parsed and will be\n+        // added to the return value after the fact.\n+        //\n+        // Therefore, prevent sub-parser from parsing\n+        // attributes by giving them a empty \"already parsed\" list.\n+        let mut attrs = None;\n+\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n \n@@ -2015,6 +2052,10 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Paren) => {\n                 try!(self.bump());\n \n+                let attrs = try!(self.parse_inner_attributes())\n+                    .into_thin_attrs()\n+                    .prepend(attrs);\n+\n                 // (e) is parenthesized e\n                 // (e,) is a tuple with only one field, e\n                 let mut es = vec![];\n@@ -2036,17 +2077,17 @@ impl<'a> Parser<'a> {\n \n                 hi = self.last_span.hi;\n                 return if es.len() == 1 && !trailing_comma {\n-                    Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap())))\n+                    Ok(self.mk_expr(lo, hi, ExprParen(es.into_iter().nth(0).unwrap()), attrs))\n                 } else {\n-                    Ok(self.mk_expr(lo, hi, ExprTup(es)))\n+                    Ok(self.mk_expr(lo, hi, ExprTup(es), attrs))\n                 }\n             },\n             token::OpenDelim(token::Brace) => {\n-                return self.parse_block_expr(lo, DefaultBlock);\n+                return self.parse_block_expr(lo, DefaultBlock, attrs);\n             },\n             token::BinOp(token::Or) |  token::OrOr => {\n                 let lo = self.span.lo;\n-                return self.parse_lambda_expr(lo, CaptureByRef);\n+                return self.parse_lambda_expr(lo, CaptureByRef, attrs);\n             },\n             token::Ident(id @ ast::Ident {\n                             name: token::SELF_KEYWORD_NAME,\n@@ -2060,6 +2101,10 @@ impl<'a> Parser<'a> {\n             token::OpenDelim(token::Bracket) => {\n                 try!(self.bump());\n \n+                let inner_attrs = try!(self.parse_inner_attributes())\n+                    .into_thin_attrs();\n+                attrs.update(|attrs| attrs.append(inner_attrs));\n+\n                 if self.check(&token::CloseDelim(token::Bracket)) {\n                     // Empty vector.\n                     try!(self.bump());\n@@ -2097,42 +2142,42 @@ impl<'a> Parser<'a> {\n                     let (qself, path) =\n                         try!(self.parse_qualified_path(LifetimeAndTypesWithColons));\n                     hi = path.span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path)));\n+                    return Ok(self.mk_expr(lo, hi, ExprPath(Some(qself), path), attrs));\n                 }\n                 if try!(self.eat_keyword(keywords::Move) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_lambda_expr(lo, CaptureByValue);\n+                    return self.parse_lambda_expr(lo, CaptureByValue, attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::If)) {\n-                    return self.parse_if_expr();\n+                    return self.parse_if_expr(attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::For) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_for_expr(None, lo);\n+                    return self.parse_for_expr(None, lo, attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::While) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_while_expr(None, lo);\n+                    return self.parse_while_expr(None, lo, attrs);\n                 }\n                 if self.token.is_lifetime() {\n                     let lifetime = self.get_lifetime();\n                     let lo = self.span.lo;\n                     try!(self.bump());\n                     try!(self.expect(&token::Colon));\n                     if try!(self.eat_keyword(keywords::While) ){\n-                        return self.parse_while_expr(Some(lifetime), lo)\n+                        return self.parse_while_expr(Some(lifetime), lo, attrs)\n                     }\n                     if try!(self.eat_keyword(keywords::For) ){\n-                        return self.parse_for_expr(Some(lifetime), lo)\n+                        return self.parse_for_expr(Some(lifetime), lo, attrs)\n                     }\n                     if try!(self.eat_keyword(keywords::Loop) ){\n-                        return self.parse_loop_expr(Some(lifetime), lo)\n+                        return self.parse_loop_expr(Some(lifetime), lo, attrs)\n                     }\n                     return Err(self.fatal(\"expected `while`, `for`, or `loop` after a label\"))\n                 }\n                 if try!(self.eat_keyword(keywords::Loop) ){\n                     let lo = self.last_span.lo;\n-                    return self.parse_loop_expr(None, lo);\n+                    return self.parse_loop_expr(None, lo, attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::Continue) ){\n                     let ex = if self.token.is_lifetime() {\n@@ -2146,15 +2191,16 @@ impl<'a> Parser<'a> {\n                         ExprAgain(None)\n                     };\n                     let hi = self.last_span.hi;\n-                    return Ok(self.mk_expr(lo, hi, ex));\n+                    return Ok(self.mk_expr(lo, hi, ex, attrs));\n                 }\n                 if try!(self.eat_keyword(keywords::Match) ){\n-                    return self.parse_match_expr();\n+                    return self.parse_match_expr(attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::Unsafe) ){\n                     return self.parse_block_expr(\n                         lo,\n-                        UnsafeBlock(ast::UserProvided));\n+                        UnsafeBlock(ast::UserProvided),\n+                        attrs);\n                 }\n                 if try!(self.eat_keyword(keywords::Return) ){\n                     if self.token.can_begin_expr() {\n@@ -2196,7 +2242,8 @@ impl<'a> Parser<'a> {\n \n                         return Ok(self.mk_mac_expr(lo,\n                                                    hi,\n-                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT }));\n+                                                   Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT },\n+                                                   attrs));\n                     }\n                     if self.check(&token::OpenDelim(token::Brace)) {\n                         // This is a struct literal, unless we're prohibited\n@@ -2210,6 +2257,10 @@ impl<'a> Parser<'a> {\n                             let mut fields = Vec::new();\n                             let mut base = None;\n \n+                            let attrs = attrs.append(\n+                                try!(self.parse_inner_attributes())\n+                                    .into_thin_attrs());\n+\n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if try!(self.eat(&token::DotDot) ){\n                                     base = Some(try!(self.parse_expr()));\n@@ -2225,7 +2276,7 @@ impl<'a> Parser<'a> {\n                             hi = self.span.hi;\n                             try!(self.expect(&token::CloseDelim(token::Brace)));\n                             ex = ExprStruct(pth, fields, base);\n-                            return Ok(self.mk_expr(lo, hi, ex));\n+                            return Ok(self.mk_expr(lo, hi, ex, attrs));\n                         }\n                     }\n \n@@ -2240,24 +2291,74 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        return Ok(self.mk_expr(lo, hi, ex));\n+        return Ok(self.mk_expr(lo, hi, ex, attrs));\n+    }\n+\n+    fn parse_or_use_outer_attributes(&mut self,\n+                                     already_parsed_attrs: Option<ThinAttributes>)\n+                                     -> PResult<ThinAttributes> {\n+        if let Some(attrs) = already_parsed_attrs {\n+            Ok(attrs)\n+        } else {\n+            self.parse_outer_attributes().map(|a| a.into_thin_attrs())\n+        }\n     }\n \n     /// Parse a block or unsafe block\n-    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode)\n+    pub fn parse_block_expr(&mut self, lo: BytePos, blk_mode: BlockCheckMode,\n+                            attrs: ThinAttributes)\n                             -> PResult<P<Expr>> {\n+\n+        let outer_attrs = attrs;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n+\n+        let inner_attrs = try!(self.parse_inner_attributes()).into_thin_attrs();\n+        let attrs = outer_attrs.append(inner_attrs);\n+\n         let blk = try!(self.parse_block_tail(lo, blk_mode));\n-        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk)));\n+        return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n-    pub fn parse_dot_or_call_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_dot_or_call_expr(&mut self,\n+                                  already_parsed_attrs: Option<ThinAttributes>)\n+                                  -> PResult<P<Expr>> {\n+        let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n+\n         let b = try!(self.parse_bottom_expr());\n-        self.parse_dot_or_call_expr_with(b)\n+        self.parse_dot_or_call_expr_with(b, attrs)\n+    }\n+\n+    pub fn parse_dot_or_call_expr_with(&mut self,\n+                                       e0: P<Expr>,\n+                                       attrs: ThinAttributes)\n+                                       -> PResult<P<Expr>> {\n+        // Stitch the list of outer attributes onto the return value.\n+        // A little bit ugly, but the best way given the current code\n+        // structure\n+        self.parse_dot_or_call_expr_with_(e0)\n+        .map(|expr|\n+            expr.map(|mut expr| {\n+                expr.attrs.update(|a| a.prepend(attrs));\n+                match expr.node {\n+                    ExprIf(..) | ExprIfLet(..) => {\n+                        if !expr.attrs.as_attr_slice().is_empty() {\n+                            // Just point to the first attribute in there...\n+                            let span = expr.attrs.as_attr_slice()[0].span;\n+\n+                            self.span_err(span,\n+                                \"attributes are not yet allowed on `if` \\\n+                                expressions\");\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+                expr\n+            })\n+        )\n     }\n \n-    pub fn parse_dot_or_call_expr_with(&mut self, e0: P<Expr>) -> PResult<P<Expr>> {\n+    fn parse_dot_or_call_expr_with_(&mut self, e0: P<Expr>) -> PResult<P<Expr>> {\n         let mut e = e0;\n         let lo = e.span.lo;\n         let mut hi;\n@@ -2295,7 +2396,7 @@ impl<'a> Parser<'a> {\n                             es.insert(0, e);\n                             let id = spanned(dot, hi, i);\n                             let nd = self.mk_method_call(id, tys, es);\n-                            e = self.mk_expr(lo, hi, nd);\n+                            e = self.mk_expr(lo, hi, nd, None);\n                         }\n                         _ => {\n                             if !tys.is_empty() {\n@@ -2307,7 +2408,7 @@ impl<'a> Parser<'a> {\n \n                             let id = spanned(dot, hi, i);\n                             let field = self.mk_field(e, id);\n-                            e = self.mk_expr(lo, hi, field);\n+                            e = self.mk_expr(lo, hi, field, None);\n                         }\n                     }\n                   }\n@@ -2326,7 +2427,7 @@ impl<'a> Parser<'a> {\n                         Some(n) => {\n                             let id = spanned(dot, hi, n);\n                             let field = self.mk_tup_field(e, id);\n-                            e = self.mk_expr(lo, hi, field);\n+                            e = self.mk_expr(lo, hi, field, None);\n                         }\n                         None => {\n                             let last_span = self.last_span;\n@@ -2370,7 +2471,7 @@ impl<'a> Parser<'a> {\n                 hi = self.last_span.hi;\n \n                 let nd = self.mk_call(e, es);\n-                e = self.mk_expr(lo, hi, nd);\n+                e = self.mk_expr(lo, hi, nd, None);\n               }\n \n               // expr[...]\n@@ -2381,7 +2482,7 @@ impl<'a> Parser<'a> {\n                 hi = self.span.hi;\n                 try!(self.commit_expr_expecting(&*ix, token::CloseDelim(token::Bracket)));\n                 let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo, hi, index)\n+                e = self.mk_expr(lo, hi, index, None)\n               }\n               _ => return Ok(e)\n             }\n@@ -2578,75 +2679,90 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a prefix-unary-operator expr\n-    pub fn parse_prefix_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_prefix_expr(&mut self,\n+                             already_parsed_attrs: Option<ThinAttributes>)\n+                             -> PResult<P<Expr>> {\n+        let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let hi;\n         // Note: when adding new unary operators, don't forget to adjust Token::can_begin_expr()\n         let ex = match self.token {\n             token::Not => {\n                 try!(self.bump());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 self.mk_unary(UnNot, e)\n             }\n             token::BinOp(token::Minus) => {\n                 try!(self.bump());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 self.mk_unary(UnNeg, e)\n             }\n             token::BinOp(token::Star) => {\n                 try!(self.bump());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 self.mk_unary(UnDeref, e)\n             }\n             token::BinOp(token::And) | token::AndAnd => {\n                 try!(self.expect_and());\n                 let m = try!(self.parse_mutability());\n-                let e = try!(self.parse_prefix_expr());\n+                let e = try!(self.parse_prefix_expr(None));\n                 hi = e.span.hi;\n                 ExprAddrOf(m, e)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::In) => {\n                 try!(self.bump());\n-                let place = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+                let place = try!(self.parse_expr_res(\n+                    Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                    None,\n+                ));\n                 let blk = try!(self.parse_block());\n                 let span = blk.span;\n                 hi = span.hi;\n-                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk));\n+                let blk_expr = self.mk_expr(span.lo, span.hi, ExprBlock(blk),\n+                                            None);\n                 ExprInPlace(place, blk_expr)\n             }\n             token::Ident(..) if self.token.is_keyword(keywords::Box) => {\n                 try!(self.bump());\n-                let subexpression = try!(self.parse_prefix_expr());\n+                let subexpression = try!(self.parse_prefix_expr(None));\n                 hi = subexpression.span.hi;\n                 ExprBox(subexpression)\n             }\n-            _ => return self.parse_dot_or_call_expr()\n+            _ => return self.parse_dot_or_call_expr(Some(attrs))\n         };\n-        return Ok(self.mk_expr(lo, hi, ex));\n+        return Ok(self.mk_expr(lo, hi, ex, attrs));\n     }\n \n     /// Parse an associative expression\n     ///\n     /// This parses an expression accounting for associativity and precedence of the operators in\n     /// the expression.\n-    pub fn parse_assoc_expr(&mut self) -> PResult<P<Expr>> {\n-        self.parse_assoc_expr_with(0, None)\n+    pub fn parse_assoc_expr(&mut self,\n+                            already_parsed_attrs: Option<ThinAttributes>)\n+                            -> PResult<P<Expr>> {\n+        self.parse_assoc_expr_with(0, already_parsed_attrs.into())\n     }\n \n     /// Parse an associative expression with operators of at least `min_prec` precedence\n     pub fn parse_assoc_expr_with(&mut self,\n                                  min_prec: usize,\n-                                 lhs: Option<P<Expr>>)\n+                                 lhs: LhsExpr)\n                                  -> PResult<P<Expr>> {\n-        let mut lhs = if lhs.is_some() {\n-            lhs.unwrap()\n-        } else if self.token == token::DotDot {\n-            return self.parse_prefix_range_expr();\n+        let mut lhs = if let LhsExpr::AlreadyParsed(expr) = lhs {\n+            expr\n         } else {\n-            try!(self.parse_prefix_expr())\n+            let attrs = match lhs {\n+                LhsExpr::AttributesParsed(attrs) => Some(attrs),\n+                _ => None,\n+            };\n+            if self.token == token::DotDot {\n+                return self.parse_prefix_range_expr(attrs);\n+            } else {\n+                try!(self.parse_prefix_expr(attrs))\n+            }\n         };\n         if self.expr_is_complete(&*lhs) {\n             // Semi-statement forms are odd. See https://github.com/rust-lang/rust/issues/29071\n@@ -2670,7 +2786,8 @@ impl<'a> Parser<'a> {\n             // Special cases:\n             if op == AssocOp::As {\n                 let rhs = try!(self.parse_ty());\n-                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi, ExprCast(lhs, rhs));\n+                lhs = self.mk_expr(lhs.span.lo, rhs.span.hi,\n+                                   ExprCast(lhs, rhs), None);\n                 continue\n             } else if op == AssocOp::DotDot {\n                     // If we didn\u2019t have to handle `x..`, it would be pretty easy to generalise\n@@ -2679,7 +2796,8 @@ impl<'a> Parser<'a> {\n                     // We have 2 alternatives here: `x..y` and `x..` The other two variants are\n                     // handled with `parse_prefix_range_expr` call above.\n                     let rhs = if self.is_at_start_of_range_notation_rhs() {\n-                        self.parse_assoc_expr_with(op.precedence() + 1, None).ok()\n+                        self.parse_assoc_expr_with(op.precedence() + 1,\n+                                                   LhsExpr::NotYetParsed).ok()\n                     } else {\n                         None\n                     };\n@@ -2689,22 +2807,22 @@ impl<'a> Parser<'a> {\n                         cur_op_span\n                     });\n                     let r = self.mk_range(Some(lhs), rhs);\n-                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r);\n+                    lhs = self.mk_expr(lhs_span.lo, rhs_span.hi, r, None);\n                     break\n             }\n \n \n             let rhs = try!(match op.fixity() {\n                 Fixity::Right => self.with_res(restrictions, |this|{\n-                    this.parse_assoc_expr_with(op.precedence(), None)\n+                    this.parse_assoc_expr_with(op.precedence(), LhsExpr::NotYetParsed)\n                 }),\n                 Fixity::Left => self.with_res(restrictions, |this|{\n-                    this.parse_assoc_expr_with(op.precedence() + 1, None)\n+                    this.parse_assoc_expr_with(op.precedence() + 1, LhsExpr::NotYetParsed)\n                 }),\n                 // We currently have no non-associative operators that are not handled above by\n                 // the special cases. The code is here only for future convenience.\n                 Fixity::None => self.with_res(restrictions, |this|{\n-                    this.parse_assoc_expr_with(op.precedence() + 1, None)\n+                    this.parse_assoc_expr_with(op.precedence() + 1, LhsExpr::NotYetParsed)\n                 }),\n             });\n \n@@ -2717,12 +2835,12 @@ impl<'a> Parser<'a> {\n                     let ast_op = op.to_ast_binop().unwrap();\n                     let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n                     let binary = self.mk_binary(codemap::respan(cur_op_span, ast_op), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary)\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, binary, None)\n                 }\n                 AssocOp::Assign =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs)),\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprAssign(lhs, rhs), None),\n                 AssocOp::Inplace =>\n-                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs)),\n+                    self.mk_expr(lhs.span.lo, rhs.span.hi, ExprInPlace(lhs, rhs), None),\n                 AssocOp::AssignOp(k) => {\n                     let aop = match k {\n                         token::Plus =>    BiAdd,\n@@ -2738,7 +2856,7 @@ impl<'a> Parser<'a> {\n                     };\n                     let (lhs_span, rhs_span) = (lhs.span, rhs.span);\n                     let aopexpr = self.mk_assign_op(codemap::respan(cur_op_span, aop), lhs, rhs);\n-                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr)\n+                    self.mk_expr(lhs_span.lo, rhs_span.hi, aopexpr, None)\n                 }\n                 AssocOp::As | AssocOp::DotDot => self.bug(\"As or DotDot branch reached\")\n             };\n@@ -2769,23 +2887,28 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse prefix-forms of range notation: `..expr` and `..`\n-    fn parse_prefix_range_expr(&mut self) -> PResult<P<Expr>> {\n+    fn parse_prefix_range_expr(&mut self,\n+                               already_parsed_attrs: Option<ThinAttributes>)\n+                               -> PResult<P<Expr>> {\n         debug_assert!(self.token == token::DotDot);\n+        let attrs = try!(self.parse_or_use_outer_attributes(already_parsed_attrs));\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         try!(self.bump());\n         let opt_end = if self.is_at_start_of_range_notation_rhs() {\n             // RHS must be parsed with more associativity than DotDot.\n             let next_prec = AssocOp::from_token(&token::DotDot).unwrap().precedence() + 1;\n-            Some(try!(self.parse_assoc_expr_with(next_prec, None).map(|x|{\n+            Some(try!(self.parse_assoc_expr_with(next_prec,\n+                                                 LhsExpr::NotYetParsed)\n+            .map(|x|{\n                 hi = x.span.hi;\n                 x\n             })))\n          } else {\n             None\n         };\n         let r = self.mk_range(None, opt_end);\n-        Ok(self.mk_expr(lo, hi, r))\n+        Ok(self.mk_expr(lo, hi, r, attrs))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -2801,12 +2924,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an 'if' or 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_if_expr(&mut self, attrs: ThinAttributes) -> PResult<P<Expr>> {\n         if self.check_keyword(keywords::Let) {\n-            return self.parse_if_let_expr();\n+            return self.parse_if_let_expr(attrs);\n         }\n         let lo = self.last_span.lo;\n-        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let thn = try!(self.parse_block());\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span.hi;\n@@ -2815,28 +2938,31 @@ impl<'a> Parser<'a> {\n             hi = elexpr.span.hi;\n             els = Some(elexpr);\n         }\n-        Ok(self.mk_expr(lo, hi, ExprIf(cond, thn, els)))\n+        Ok(self.mk_expr(lo, hi, ExprIf(cond, thn, els), attrs))\n     }\n \n     /// Parse an 'if let' expression ('if' token already eaten)\n-    pub fn parse_if_let_expr(&mut self) -> PResult<P<Expr>> {\n+    pub fn parse_if_let_expr(&mut self, attrs: ThinAttributes)\n+                             -> PResult<P<Expr>> {\n         let lo = self.last_span.lo;\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         let thn = try!(self.parse_block());\n         let (hi, els) = if try!(self.eat_keyword(keywords::Else) ){\n             let expr = try!(self.parse_else_expr());\n             (expr.span.hi, Some(expr))\n         } else {\n             (thn.span.hi, None)\n         };\n-        Ok(self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els)))\n+        Ok(self.mk_expr(lo, hi, ExprIfLet(pat, expr, thn, els), attrs))\n     }\n \n     // `|args| expr`\n-    pub fn parse_lambda_expr(&mut self, lo: BytePos, capture_clause: CaptureClause)\n+    pub fn parse_lambda_expr(&mut self, lo: BytePos,\n+                             capture_clause: CaptureClause,\n+                             attrs: ThinAttributes)\n                              -> PResult<P<Expr>>\n     {\n         let decl = try!(self.parse_fn_block_decl());\n@@ -2863,80 +2989,98 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(\n             lo,\n             body.span.hi,\n-            ExprClosure(capture_clause, decl, body)))\n+            ExprClosure(capture_clause, decl, body), attrs))\n     }\n \n+    // `else` token already eaten\n     pub fn parse_else_expr(&mut self) -> PResult<P<Expr>> {\n         if try!(self.eat_keyword(keywords::If) ){\n-            return self.parse_if_expr();\n+            return self.parse_if_expr(None);\n         } else {\n             let blk = try!(self.parse_block());\n-            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk)));\n+            return Ok(self.mk_expr(blk.span.lo, blk.span.hi, ExprBlock(blk), None));\n         }\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n     pub fn parse_for_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                          span_lo: BytePos) -> PResult<P<Expr>> {\n+                          span_lo: BytePos,\n+                          attrs: ThinAttributes) -> PResult<P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n         let pat = try!(self.parse_pat());\n         try!(self.expect_keyword(keywords::In));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-        let loop_block = try!(self.parse_block());\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let (iattrs, loop_block) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n+\n         let hi = self.last_span.hi;\n \n-        Ok(self.mk_expr(span_lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident)))\n+        Ok(self.mk_expr(span_lo, hi,\n+                        ExprForLoop(pat, expr, loop_block, opt_ident),\n+                        attrs))\n     }\n \n     /// Parse a 'while' or 'while let' expression ('while' token already eaten)\n     pub fn parse_while_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                            span_lo: BytePos) -> PResult<P<Expr>> {\n+                            span_lo: BytePos,\n+                            attrs: ThinAttributes) -> PResult<P<Expr>> {\n         if self.token.is_keyword(keywords::Let) {\n-            return self.parse_while_let_expr(opt_ident, span_lo);\n+            return self.parse_while_let_expr(opt_ident, span_lo, attrs);\n         }\n-        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-        let body = try!(self.parse_block());\n+        let cond = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident)));\n+        return Ok(self.mk_expr(span_lo, hi, ExprWhile(cond, body, opt_ident),\n+                               attrs));\n     }\n \n     /// Parse a 'while let' expression ('while' token already eaten)\n     pub fn parse_while_let_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                                span_lo: BytePos) -> PResult<P<Expr>> {\n+                                span_lo: BytePos,\n+                                attrs: ThinAttributes) -> PResult<P<Expr>> {\n         try!(self.expect_keyword(keywords::Let));\n         let pat = try!(self.parse_pat());\n         try!(self.expect(&token::Eq));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n-        let body = try!(self.parse_block());\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident)));\n+        return Ok(self.mk_expr(span_lo, hi, ExprWhileLet(pat, expr, body, opt_ident), attrs));\n     }\n \n+    // parse `loop {...}`, `loop` token already eaten\n     pub fn parse_loop_expr(&mut self, opt_ident: Option<ast::Ident>,\n-                           span_lo: BytePos) -> PResult<P<Expr>> {\n-        let body = try!(self.parse_block());\n+                           span_lo: BytePos,\n+                           attrs: ThinAttributes) -> PResult<P<Expr>> {\n+        let (iattrs, body) = try!(self.parse_inner_attrs_and_block());\n+        let attrs = attrs.append(iattrs.into_thin_attrs());\n         let hi = body.span.hi;\n-        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident)))\n+        Ok(self.mk_expr(span_lo, hi, ExprLoop(body, opt_ident), attrs))\n     }\n \n-    fn parse_match_expr(&mut self) -> PResult<P<Expr>> {\n+    // `match` token already eaten\n+    fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n-        let discriminant = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL));\n+        let discriminant = try!(self.parse_expr_res(\n+            Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n         if let Err(e) = self.commit_expr_expecting(&*discriminant, token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n                 self.span_note(match_span, \"did you mean to remove this `match` keyword?\");\n             }\n             return Err(e)\n         }\n+        let attrs = attrs.append(\n+            try!(self.parse_inner_attributes()).into_thin_attrs());\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n             arms.push(try!(self.parse_arm()));\n         }\n         let hi = self.span.hi;\n         try!(self.bump());\n-        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms)));\n+        return Ok(self.mk_expr(lo, hi, ExprMatch(discriminant, arms), attrs));\n     }\n \n     pub fn parse_arm(&mut self) -> PResult<Arm> {\n@@ -2949,7 +3093,7 @@ impl<'a> Parser<'a> {\n             guard = Some(try!(self.parse_expr()));\n         }\n         try!(self.expect(&token::FatArrow));\n-        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n+        let expr = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR, None));\n \n         let require_comma =\n             !classify::expr_is_simple_block(&*expr)\n@@ -2971,7 +3115,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse an expression\n     pub fn parse_expr(&mut self) -> PResult<P<Expr>> {\n-        self.parse_expr_res(Restrictions::empty())\n+        self.parse_expr_res(Restrictions::empty(), None)\n     }\n \n     /// Evaluate the closure with restrictions in place.\n@@ -2988,8 +3132,10 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an expression, subject to the given restrictions\n-    pub fn parse_expr_res(&mut self, r: Restrictions) -> PResult<P<Expr>> {\n-        self.with_res(r, |this| this.parse_assoc_expr())\n+    pub fn parse_expr_res(&mut self, r: Restrictions,\n+                          already_parsed_attrs: Option<ThinAttributes>)\n+                          -> PResult<P<Expr>> {\n+        self.with_res(r, |this| this.parse_assoc_expr(already_parsed_attrs))\n     }\n \n     /// Parse the RHS of a local variable declaration (e.g. '= 14;')\n@@ -3173,9 +3319,9 @@ impl<'a> Parser<'a> {\n                 (None, try!(self.parse_path(LifetimeAndTypesWithColons)))\n             };\n             let hi = self.last_span.hi;\n-            Ok(self.mk_expr(lo, hi, ExprPath(qself, path)))\n+            Ok(self.mk_expr(lo, hi, ExprPath(qself, path), None))\n         } else {\n-            self.parse_literal_maybe_minus()\n+            self.parse_pat_literal_maybe_minus()\n         }\n     }\n \n@@ -3275,7 +3421,7 @@ impl<'a> Parser<'a> {\n                       token::DotDotDot => {\n                         // Parse range\n                         let hi = self.last_span.hi;\n-                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path));\n+                        let begin = self.mk_expr(lo, hi, ExprPath(qself, path), None);\n                         try!(self.bump());\n                         let end = try!(self.parse_pat_range_end());\n                         pat = PatRange(begin, end);\n@@ -3322,7 +3468,7 @@ impl<'a> Parser<'a> {\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n-                let begin = try!(self.parse_literal_maybe_minus());\n+                let begin = try!(self.parse_pat_literal_maybe_minus());\n                 if try!(self.eat(&token::DotDotDot)) {\n                     let end = try!(self.parse_pat_range_end());\n                     pat = PatRange(begin, end);\n@@ -3379,7 +3525,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a local variable declaration\n-    fn parse_local(&mut self) -> PResult<P<Local>> {\n+    fn parse_local(&mut self, attrs: ThinAttributes) -> PResult<P<Local>> {\n         let lo = self.span.lo;\n         let pat = try!(self.parse_pat());\n \n@@ -3394,13 +3540,14 @@ impl<'a> Parser<'a> {\n             init: init,\n             id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, self.last_span.hi),\n+            attrs: attrs,\n         }))\n     }\n \n     /// Parse a \"let\" stmt\n-    fn parse_let(&mut self) -> PResult<P<Decl>> {\n+    fn parse_let(&mut self, attrs: ThinAttributes) -> PResult<P<Decl>> {\n         let lo = self.span.lo;\n-        let local = try!(self.parse_local());\n+        let local = try!(self.parse_local(attrs));\n         Ok(P(spanned(lo, self.last_span.hi, DeclLocal(local))))\n     }\n \n@@ -3445,28 +3592,20 @@ impl<'a> Parser<'a> {\n     fn parse_stmt_(&mut self) -> PResult<Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n-        fn check_expected_item(p: &mut Parser, attrs: &[Attribute]) {\n-            // If we have attributes then we should have an item\n-            if !attrs.is_empty() {\n-                p.expected_item_err(attrs);\n-            }\n-        }\n-\n         let attrs = try!(self.parse_outer_attributes());\n         let lo = self.span.lo;\n \n         Ok(Some(if self.check_keyword(keywords::Let) {\n-            check_expected_item(self, &attrs);\n             try!(self.expect_keyword(keywords::Let));\n-            let decl = try!(self.parse_let());\n-            spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n+            let decl = try!(self.parse_let(attrs.into_thin_attrs()));\n+            let hi = decl.span.hi;\n+            let stmt = StmtDecl(decl, ast::DUMMY_NODE_ID);\n+            spanned(lo, hi, stmt)\n         } else if self.token.is_ident()\n             && !self.token.is_any_keyword()\n             && self.look_ahead(1, |t| *t == token::Not) {\n             // it's a macro invocation:\n \n-            check_expected_item(self, &attrs);\n-\n             // Potential trouble: if we allow macros with paths instead of\n             // idents, we'd need to look ahead past the whole path here...\n             let pth = try!(self.parse_path(NoTypesAllowed));\n@@ -3512,11 +3651,12 @@ impl<'a> Parser<'a> {\n             };\n \n             if id.name == token::special_idents::invalid.name {\n-                spanned(lo, hi,\n-                        StmtMac(P(spanned(lo,\n-                                          hi,\n-                                          Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                                  style))\n+                let stmt = StmtMac(P(spanned(lo,\n+                                             hi,\n+                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n+                                   style,\n+                                   attrs.into_thin_attrs());\n+                spanned(lo, hi, stmt)\n             } else {\n                 // if it has a special ident, it's definitely an item\n                 //\n@@ -3536,30 +3676,43 @@ impl<'a> Parser<'a> {\n                             lo, hi, id /*id is good here*/,\n                             ItemMac(spanned(lo, hi,\n                                             Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT })),\n-                            Inherited, Vec::new(/*no attrs*/))))),\n+                            Inherited, attrs)))),\n                     ast::DUMMY_NODE_ID))\n             }\n         } else {\n-            match try!(self.parse_item_(attrs, false)) {\n+            // FIXME: Bad copy of attrs\n+            match try!(self.parse_item_(attrs.clone(), false, true)) {\n                 Some(i) => {\n                     let hi = i.span.hi;\n                     let decl = P(spanned(lo, hi, DeclItem(i)));\n                     spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID))\n                 }\n                 None => {\n+                    let unused_attrs = |attrs: &[_], s: &mut Self| {\n+                        if attrs.len() > 0 {\n+                            s.span_err(s.span,\n+                                \"expected statement after outer attribute\");\n+                        }\n+                    };\n+\n                     // Do not attempt to parse an expression if we're done here.\n                     if self.token == token::Semi {\n+                        unused_attrs(&attrs, self);\n                         try!(self.bump());\n                         return Ok(None);\n                     }\n \n                     if self.token == token::CloseDelim(token::Brace) {\n+                        unused_attrs(&attrs, self);\n                         return Ok(None);\n                     }\n \n                     // Remainder are line-expr stmts.\n-                    let e = try!(self.parse_expr_res(Restrictions::RESTRICTION_STMT_EXPR));\n-                    spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID))\n+                    let e = try!(self.parse_expr_res(\n+                        Restrictions::RESTRICTION_STMT_EXPR, Some(attrs.into_thin_attrs())));\n+                    let hi = e.span.hi;\n+                    let stmt = StmtExpr(e, ast::DUMMY_NODE_ID);\n+                    spanned(lo, hi, stmt)\n                 }\n             }\n         }))\n@@ -3615,22 +3768,23 @@ impl<'a> Parser<'a> {\n                 StmtExpr(e, _) => {\n                     try!(self.handle_expression_like_statement(e, span, &mut stmts, &mut expr));\n                 }\n-                StmtMac(mac, MacStmtWithoutBraces) => {\n+                StmtMac(mac, MacStmtWithoutBraces, attrs) => {\n                     // statement macro without braces; might be an\n                     // expr depending on whether a semicolon follows\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(mac, MacStmtWithSemicolon),\n+                                node: StmtMac(mac, MacStmtWithSemicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n                             }));\n                             try!(self.bump());\n                         }\n                         _ => {\n                             let e = self.mk_mac_expr(span.lo, span.hi,\n-                                                     mac.and_then(|m| m.node));\n-                            let e = try!(self.parse_dot_or_call_expr_with(e));\n-                            let e = try!(self.parse_assoc_expr_with(0, Some(e)));\n+                                                     mac.and_then(|m| m.node),\n+                                                     None);\n+                            let e = try!(self.parse_dot_or_call_expr_with(e, attrs));\n+                            let e = try!(self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e)));\n                             try!(self.handle_expression_like_statement(\n                                 e,\n                                 span,\n@@ -3639,12 +3793,12 @@ impl<'a> Parser<'a> {\n                         }\n                     }\n                 }\n-                StmtMac(m, style) => {\n+                StmtMac(m, style, attrs) => {\n                     // statement macro; might be an expr\n                     match self.token {\n                         token::Semi => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(m, MacStmtWithSemicolon),\n+                                node: StmtMac(m, MacStmtWithSemicolon, attrs),\n                                 span: mk_sp(span.lo, self.span.hi),\n                             }));\n                             try!(self.bump());\n@@ -3653,11 +3807,12 @@ impl<'a> Parser<'a> {\n                             // if a block ends in `m!(arg)` without\n                             // a `;`, it must be an expr\n                             expr = Some(self.mk_mac_expr(span.lo, span.hi,\n-                                                         m.and_then(|x| x.node)));\n+                                                         m.and_then(|x| x.node),\n+                                                         attrs));\n                         }\n                         _ => {\n                             stmts.push(P(Spanned {\n-                                node: StmtMac(m, style),\n+                                node: StmtMac(m, style, attrs),\n                                 span: span\n                             }));\n                         }\n@@ -5212,7 +5367,7 @@ impl<'a> Parser<'a> {\n     /// NB: this function no longer parses the items inside an\n     /// extern crate.\n     fn parse_item_(&mut self, attrs: Vec<Attribute>,\n-                   macros_allowed: bool) -> PResult<Option<P<Item>>> {\n+                   macros_allowed: bool, attributes_allowed: bool) -> PResult<Option<P<Item>>> {\n         let nt_item = match self.token {\n             token::Interpolated(token::NtItem(ref item)) => {\n                 Some((**item).clone())\n@@ -5470,7 +5625,7 @@ impl<'a> Parser<'a> {\n                                     maybe_append(attrs, extra_attrs));\n             return Ok(Some(item));\n         }\n-        self.parse_macro_use_or_failure(attrs,macros_allowed,lo,visibility)\n+        self.parse_macro_use_or_failure(attrs,macros_allowed,attributes_allowed,lo,visibility)\n     }\n \n     /// Parse a foreign item.\n@@ -5489,7 +5644,7 @@ impl<'a> Parser<'a> {\n         }\n \n         // FIXME #5668: this will occur for a macro invocation:\n-        match try!(self.parse_macro_use_or_failure(attrs, true, lo, visibility)) {\n+        match try!(self.parse_macro_use_or_failure(attrs, true, false, lo, visibility)) {\n             Some(item) => {\n                 return Err(self.span_fatal(item.span, \"macros cannot expand to foreign items\"));\n             }\n@@ -5502,6 +5657,7 @@ impl<'a> Parser<'a> {\n         &mut self,\n         attrs: Vec<Attribute> ,\n         macros_allowed: bool,\n+        attributes_allowed: bool,\n         lo: BytePos,\n         visibility: Visibility\n     ) -> PResult<Option<P<Item>>> {\n@@ -5570,15 +5726,15 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n-        if !attrs.is_empty() {\n+        if !attributes_allowed && !attrs.is_empty() {\n             self.expected_item_err(&attrs);\n         }\n         Ok(None)\n     }\n \n     pub fn parse_item(&mut self) -> PResult<Option<P<Item>>> {\n         let attrs = try!(self.parse_outer_attributes());\n-        self.parse_item_(attrs, true)\n+        self.parse_item_(attrs, true, false)\n     }\n \n "}, {"sha": "17b7d8dbaece9588d1dbcf846a0ac32391381619", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -202,6 +202,7 @@ impl Token {\n             Interpolated(NtIdent(..))   => true,\n             Interpolated(NtBlock(..))   => true,\n             Interpolated(NtPath(..))    => true,\n+            Pound                       => true, // for expression attributes\n             _                           => false,\n         }\n     }"}, {"sha": "aa55cb847faffabb882abf25587011ba38168959", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 144, "deletions": 84, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -13,6 +13,8 @@ pub use self::AnnNode::*;\n use abi;\n use ast::{self, TokenTree};\n use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use ast::Attribute;\n+use attr::ThinAttributesExt;\n use ast_util;\n use util::parser::AssocOp;\n use attr;\n@@ -77,7 +79,7 @@ pub fn rust_printer<'a>(writer: Box<Write+'a>) -> State<'a> {\n pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n                                   ann: &'a PpAnn) -> State<'a> {\n     State {\n-        s: pp::mk_printer(writer, default_columns),\n+        s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n         comments: None,\n         literals: None,\n@@ -90,11 +92,9 @@ pub fn rust_printer_annotated<'a>(writer: Box<Write+'a>,\n     }\n }\n \n-#[allow(non_upper_case_globals)]\n-pub const indent_unit: usize = 4;\n+pub const INDENT_UNIT: usize = 4;\n \n-#[allow(non_upper_case_globals)]\n-pub const default_columns: usize = 78;\n+pub const DEFAULT_COLUMNS: usize = 78;\n \n /// Requires you to pass an input filename and reader so that\n /// it can scan the input text for comments and literals to\n@@ -170,7 +170,7 @@ impl<'a> State<'a> {\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n         State {\n-            s: pp::mk_printer(out, default_columns),\n+            s: pp::mk_printer(out, DEFAULT_COLUMNS),\n             cm: Some(cm),\n             comments: comments,\n             literals: literals,\n@@ -401,7 +401,7 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n pub fn block_to_string(blk: &ast::Block) -> String {\n     to_string(|s| {\n         // containing cbox, will be closed by print-block at }\n-        try!(s.cbox(indent_unit));\n+        try!(s.cbox(INDENT_UNIT));\n         // head-ibox, will be closed by print-block after {\n         try!(s.ibox(0));\n         s.print_block(blk)\n@@ -707,43 +707,61 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_inner_attributes(&mut self,\n-                                  attrs: &[ast::Attribute]) -> io::Result<()> {\n-        let mut count = 0;\n-        for attr in attrs {\n-            match attr.node.style {\n-                ast::AttrStyle::Inner => {\n-                    try!(self.print_attribute(attr));\n-                    count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n-            }\n-        }\n-        if count > 0 {\n-            try!(self.hardbreak_if_not_bol());\n-        }\n-        Ok(())\n+                              attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, true)\n+    }\n+\n+    fn print_inner_attributes_no_trailing_hardbreak(&mut self,\n+                                                   attrs: &[ast::Attribute])\n+                                                   -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Inner, false, false)\n     }\n \n     fn print_outer_attributes(&mut self,\n                               attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Outer, false, true)\n+    }\n+\n+    fn print_inner_attributes_inline(&mut self,\n+                                     attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Inner, true, true)\n+    }\n+\n+    fn print_outer_attributes_inline(&mut self,\n+                                     attrs: &[ast::Attribute]) -> io::Result<()> {\n+        self.print_either_attributes(attrs, ast::AttrStyle::Outer, true, true)\n+    }\n+\n+    fn print_either_attributes(&mut self,\n+                              attrs: &[ast::Attribute],\n+                              kind: ast::AttrStyle,\n+                              is_inline: bool,\n+                              trailing_hardbreak: bool) -> io::Result<()> {\n         let mut count = 0;\n         for attr in attrs {\n-            match attr.node.style {\n-                ast::AttrStyle::Outer => {\n-                    try!(self.print_attribute(attr));\n+            if attr.node.style == kind {\n+                    try!(self.print_attribute_inline(attr, is_inline));\n+                    if is_inline {\n+                        try!(self.nbsp());\n+                    }\n                     count += 1;\n-                }\n-                _ => {/* fallthrough */ }\n             }\n         }\n-        if count > 0 {\n+        if count > 0 && trailing_hardbreak && !is_inline {\n             try!(self.hardbreak_if_not_bol());\n         }\n         Ok(())\n     }\n \n     fn print_attribute(&mut self, attr: &ast::Attribute) -> io::Result<()> {\n-        try!(self.hardbreak_if_not_bol());\n+        self.print_attribute_inline(attr, false)\n+    }\n+\n+    fn print_attribute_inline(&mut self, attr: &ast::Attribute,\n+                              is_inline: bool) -> io::Result<()> {\n+        if !is_inline {\n+            try!(self.hardbreak_if_not_bol());\n+        }\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.node.is_sugared_doc {\n             word(self.writer(), &attr.value_str().unwrap())\n@@ -758,7 +776,7 @@ pub trait PrintState<'a> {\n     }\n \n     fn print_meta_item(&mut self, item: &ast::MetaItem) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         match item.node {\n             ast::MetaWord(ref name) => {\n                 try!(word(self.writer(), &name));\n@@ -779,6 +797,13 @@ pub trait PrintState<'a> {\n         }\n         self.end()\n     }\n+\n+    fn space_if_not_bol(&mut self) -> io::Result<()> {\n+        if !self.is_bol() { try!(space(self.writer())); }\n+        Ok(())\n+    }\n+\n+    fn nbsp(&mut self) -> io::Result<()> { word(self.writer(), \" \") }\n }\n \n impl<'a> PrintState<'a> for State<'a> {\n@@ -809,16 +834,14 @@ impl<'a> State<'a> {\n         pp::cbox(&mut self.s, u)\n     }\n \n-    pub fn nbsp(&mut self) -> io::Result<()> { word(&mut self.s, \" \") }\n-\n     pub fn word_nbsp(&mut self, w: &str) -> io::Result<()> {\n         try!(word(&mut self.s, w));\n         self.nbsp()\n     }\n \n     pub fn head(&mut self, w: &str) -> io::Result<()> {\n         // outer-box is consistent\n-        try!(self.cbox(indent_unit));\n+        try!(self.cbox(INDENT_UNIT));\n         // head-box is inconsistent\n         try!(self.ibox(w.len() + 1));\n         // keyword that starts the head\n@@ -848,7 +871,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n     pub fn bclose(&mut self, span: codemap::Span) -> io::Result<()> {\n-        self.bclose_(span, indent_unit)\n+        self.bclose_(span, INDENT_UNIT)\n     }\n \n     pub fn in_cbox(&self) -> bool {\n@@ -858,10 +881,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn space_if_not_bol(&mut self) -> io::Result<()> {\n-        if !self.is_bol() { try!(space(&mut self.s)); }\n-        Ok(())\n-    }\n     pub fn break_offset_if_not_bol(&mut self, n: usize,\n                                    off: isize) -> io::Result<()> {\n         if !self.is_bol() {\n@@ -1200,7 +1219,7 @@ impl<'a> State<'a> {\n                 try!(self.bclose(item.span));\n             }\n             ast::ItemTy(ref ty, ref params) => {\n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 try!(self.ibox(0));\n                 try!(self.word_nbsp(&visibility_qualified(item.vis, \"type\")));\n                 try!(self.print_ident(item.ident));\n@@ -1314,7 +1333,7 @@ impl<'a> State<'a> {\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n                 try!(self.print_ident(item.ident));\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 try!(self.popen());\n                 try!(self.print_tts(&node.tts[..]));\n                 try!(self.pclose());\n@@ -1370,7 +1389,7 @@ impl<'a> State<'a> {\n             try!(self.space_if_not_bol());\n             try!(self.maybe_print_comment(v.span.lo));\n             try!(self.print_outer_attributes(&v.node.attrs));\n-            try!(self.ibox(indent_unit));\n+            try!(self.ibox(INDENT_UNIT));\n             try!(self.print_variant(&**v));\n             try!(word(&mut self.s, \",\"));\n             try!(self.end());\n@@ -1592,7 +1611,7 @@ impl<'a> State<'a> {\n                 // code copied from ItemMac:\n                 try!(self.print_path(&node.path, false, 0));\n                 try!(word(&mut self.s, \"! \"));\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 try!(self.popen());\n                 try!(self.print_tts(&node.tts[..]));\n                 try!(self.pclose());\n@@ -1611,15 +1630,16 @@ impl<'a> State<'a> {\n             }\n             ast::StmtExpr(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr_outer_attr_style(&**expr, false));\n             }\n             ast::StmtSemi(ref expr, _) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr_outer_attr_style(&**expr, false));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtMac(ref mac, style) => {\n+            ast::StmtMac(ref mac, style, ref attrs) => {\n                 try!(self.space_if_not_bol());\n+                try!(self.print_outer_attributes(attrs.as_attr_slice()));\n                 let delim = match style {\n                     ast::MacStmtWithBraces => token::Brace,\n                     _ => token::Paren\n@@ -1642,7 +1662,13 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_block_unclosed(&mut self, blk: &ast::Block) -> io::Result<()> {\n-        self.print_block_unclosed_indent(blk, indent_unit)\n+        self.print_block_unclosed_indent(blk, INDENT_UNIT)\n+    }\n+\n+    pub fn print_block_unclosed_with_attrs(&mut self, blk: &ast::Block,\n+                                            attrs: &[ast::Attribute])\n+                                           -> io::Result<()> {\n+        self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, false)\n     }\n \n     pub fn print_block_unclosed_indent(&mut self, blk: &ast::Block,\n@@ -1653,7 +1679,7 @@ impl<'a> State<'a> {\n     pub fn print_block_with_attrs(&mut self,\n                                   blk: &ast::Block,\n                                   attrs: &[ast::Attribute]) -> io::Result<()> {\n-        self.print_block_maybe_unclosed(blk, indent_unit, attrs, true)\n+        self.print_block_maybe_unclosed(blk, INDENT_UNIT, attrs, true)\n     }\n \n     pub fn print_block_maybe_unclosed(&mut self,\n@@ -1677,7 +1703,7 @@ impl<'a> State<'a> {\n         match blk.expr {\n             Some(ref expr) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_expr(&**expr));\n+                try!(self.print_expr_outer_attr_style(&**expr, false));\n                 try!(self.maybe_print_trailing_comment(expr.span, Some(blk.span.hi)));\n             }\n             _ => ()\n@@ -1692,7 +1718,7 @@ impl<'a> State<'a> {\n                 match _else.node {\n                     // \"another else-if\"\n                     ast::ExprIf(ref i, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if \"));\n                         try!(self.print_expr(&**i));\n@@ -1702,7 +1728,7 @@ impl<'a> State<'a> {\n                     }\n                     // \"another else-if-let\"\n                     ast::ExprIfLet(ref pat, ref expr, ref then, ref e) => {\n-                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else if let \"));\n                         try!(self.print_pat(&**pat));\n@@ -1715,7 +1741,7 @@ impl<'a> State<'a> {\n                     }\n                     // \"final else\"\n                     ast::ExprBlock(ref b) => {\n-                        try!(self.cbox(indent_unit - 1));\n+                        try!(self.cbox(INDENT_UNIT - 1));\n                         try!(self.ibox(0));\n                         try!(word(&mut self.s, \" else \"));\n                         self.print_block(&**b)\n@@ -1758,7 +1784,13 @@ impl<'a> State<'a> {\n         match delim {\n             token::Paren => try!(self.popen()),\n             token::Bracket => try!(word(&mut self.s, \"[\")),\n-            token::Brace => try!(self.bopen()),\n+            token::Brace => {\n+                // head-ibox, will be closed by bopen()\n+                try!(self.ibox(0));\n+                // Don't ask me why the regular bopen() does\n+                // more then just opening a brace...\n+                try!(self.bopen())\n+            }\n         }\n         try!(self.print_tts(&m.node.tts));\n         match delim {\n@@ -1811,19 +1843,23 @@ impl<'a> State<'a> {\n         self.print_expr_maybe_paren(expr)\n     }\n \n-    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+    fn print_expr_vec(&mut self, exprs: &[P<ast::Expr>],\n+                      attrs: &[Attribute]) -> io::Result<()> {\n+        try!(self.ibox(INDENT_UNIT));\n         try!(word(&mut self.s, \"[\"));\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         try!(word(&mut self.s, \"]\"));\n         self.end()\n     }\n \n     fn print_expr_repeat(&mut self,\n                          element: &ast::Expr,\n-                         count: &ast::Expr) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+                         count: &ast::Expr,\n+                         attrs: &[Attribute]) -> io::Result<()> {\n+        try!(self.ibox(INDENT_UNIT));\n         try!(word(&mut self.s, \"[\"));\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.print_expr(element));\n         try!(self.word_space(\";\"));\n         try!(self.print_expr(count));\n@@ -1834,14 +1870,16 @@ impl<'a> State<'a> {\n     fn print_expr_struct(&mut self,\n                          path: &ast::Path,\n                          fields: &[ast::Field],\n-                         wth: &Option<P<ast::Expr>>) -> io::Result<()> {\n+                         wth: &Option<P<ast::Expr>>,\n+                         attrs: &[Attribute]) -> io::Result<()> {\n         try!(self.print_path(path, true, 0));\n         try!(word(&mut self.s, \"{\"));\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_cmnt(\n             Consistent,\n             &fields[..],\n             |s, field| {\n-                try!(s.ibox(indent_unit));\n+                try!(s.ibox(INDENT_UNIT));\n                 try!(s.print_ident(field.ident.node));\n                 try!(s.word_space(\":\"));\n                 try!(s.print_expr(&*field.expr));\n@@ -1850,7 +1888,7 @@ impl<'a> State<'a> {\n             |f| f.span));\n         match *wth {\n             Some(ref expr) => {\n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 if !fields.is_empty() {\n                     try!(word(&mut self.s, \",\"));\n                     try!(space(&mut self.s));\n@@ -1867,8 +1905,10 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>]) -> io::Result<()> {\n+    fn print_expr_tup(&mut self, exprs: &[P<ast::Expr>],\n+                      attrs: &[Attribute]) -> io::Result<()> {\n         try!(self.popen());\n+        try!(self.print_inner_attributes_inline(attrs));\n         try!(self.commasep_exprs(Inconsistent, &exprs[..]));\n         if exprs.len() == 1 {\n             try!(word(&mut self.s, \",\"));\n@@ -1934,8 +1974,22 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_expr(&mut self, expr: &ast::Expr) -> io::Result<()> {\n+        self.print_expr_outer_attr_style(expr, true)\n+    }\n+\n+    fn print_expr_outer_attr_style(&mut self,\n+                                  expr: &ast::Expr,\n+                                  is_inline: bool) -> io::Result<()> {\n         try!(self.maybe_print_comment(expr.span.lo));\n-        try!(self.ibox(indent_unit));\n+\n+        let attrs = expr.attrs.as_attr_slice();\n+        if is_inline {\n+            try!(self.print_outer_attributes_inline(attrs));\n+        } else {\n+            try!(self.print_outer_attributes(attrs));\n+        }\n+\n+        try!(self.ibox(INDENT_UNIT));\n         try!(self.ann.pre(self, NodeExpr(expr)));\n         match expr.node {\n             ast::ExprBox(ref expr) => {\n@@ -1946,16 +2000,16 @@ impl<'a> State<'a> {\n                 try!(self.print_expr_in_place(place, expr));\n             }\n             ast::ExprVec(ref exprs) => {\n-                try!(self.print_expr_vec(&exprs[..]));\n+                try!(self.print_expr_vec(&exprs[..], attrs));\n             }\n             ast::ExprRepeat(ref element, ref count) => {\n-                try!(self.print_expr_repeat(&**element, &**count));\n+                try!(self.print_expr_repeat(&**element, &**count, attrs));\n             }\n             ast::ExprStruct(ref path, ref fields, ref wth) => {\n-                try!(self.print_expr_struct(path, &fields[..], wth));\n+                try!(self.print_expr_struct(path, &fields[..], wth, attrs));\n             }\n             ast::ExprTup(ref exprs) => {\n-                try!(self.print_expr_tup(&exprs[..]));\n+                try!(self.print_expr_tup(&exprs[..], attrs));\n             }\n             ast::ExprCall(ref func, ref args) => {\n                 try!(self.print_expr_call(&**func, &args[..]));\n@@ -1999,7 +2053,7 @@ impl<'a> State<'a> {\n                 try!(self.head(\"while\"));\n                 try!(self.print_expr(&**test));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprWhileLet(ref pat, ref expr, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2012,7 +2066,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"=\"));\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprForLoop(ref pat, ref iter, ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2025,7 +2079,7 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\"in\"));\n                 try!(self.print_expr(&**iter));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprLoop(ref blk, opt_ident) => {\n                 if let Some(ident) = opt_ident {\n@@ -2034,19 +2088,20 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.head(\"loop\"));\n                 try!(space(&mut self.s));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprMatch(ref expr, ref arms) => {\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 try!(self.ibox(4));\n                 try!(self.word_nbsp(\"match\"));\n                 try!(self.print_expr(&**expr));\n                 try!(space(&mut self.s));\n                 try!(self.bopen());\n+                try!(self.print_inner_attributes_no_trailing_hardbreak(attrs));\n                 for arm in arms {\n                     try!(self.print_arm(arm));\n                 }\n-                try!(self.bclose_(expr.span, indent_unit));\n+                try!(self.bclose_(expr.span, INDENT_UNIT));\n             }\n             ast::ExprClosure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n@@ -2063,13 +2118,16 @@ impl<'a> State<'a> {\n                     try!(self.print_block_unclosed(&**body));\n                 } else {\n                     // we extract the block, so as not to create another set of boxes\n-                    match body.expr.as_ref().unwrap().node {\n+                    let i_expr = body.expr.as_ref().unwrap();\n+                    match i_expr.node {\n                         ast::ExprBlock(ref blk) => {\n-                            try!(self.print_block_unclosed(&**blk));\n+                            try!(self.print_block_unclosed_with_attrs(\n+                                &**blk,\n+                                i_expr.attrs.as_attr_slice()));\n                         }\n                         _ => {\n                             // this is a bare expression\n-                            try!(self.print_expr(body.expr.as_ref().map(|e| &**e).unwrap()));\n+                            try!(self.print_expr(&**i_expr));\n                             try!(self.end()); // need to close a box\n                         }\n                     }\n@@ -2081,10 +2139,10 @@ impl<'a> State<'a> {\n             }\n             ast::ExprBlock(ref blk) => {\n                 // containing cbox, will be closed by print-block at }\n-                try!(self.cbox(indent_unit));\n+                try!(self.cbox(INDENT_UNIT));\n                 // head-box, will be closed by print-block after {\n                 try!(self.ibox(0));\n-                try!(self.print_block(&**blk));\n+                try!(self.print_block_with_attrs(&**blk, attrs));\n             }\n             ast::ExprAssign(ref lhs, ref rhs) => {\n                 try!(self.print_expr(&**lhs));\n@@ -2222,6 +2280,7 @@ impl<'a> State<'a> {\n             ast::ExprMac(ref m) => try!(self.print_mac(m, token::Paren)),\n             ast::ExprParen(ref e) => {\n                 try!(self.popen());\n+                try!(self.print_inner_attributes_inline(attrs));\n                 try!(self.print_expr(&**e));\n                 try!(self.pclose());\n             }\n@@ -2243,11 +2302,12 @@ impl<'a> State<'a> {\n         try!(self.maybe_print_comment(decl.span.lo));\n         match decl.node {\n             ast::DeclLocal(ref loc) => {\n+                try!(self.print_outer_attributes(loc.attrs.as_attr_slice()));\n                 try!(self.space_if_not_bol());\n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 try!(self.word_nbsp(\"let\"));\n \n-                try!(self.ibox(indent_unit));\n+                try!(self.ibox(INDENT_UNIT));\n                 try!(self.print_local_decl(&**loc));\n                 try!(self.end());\n                 if let Some(ref init) = loc.init {\n@@ -2452,7 +2512,7 @@ impl<'a> State<'a> {\n                 try!(self.commasep_cmnt(\n                     Consistent, &fields[..],\n                     |s, f| {\n-                        try!(s.cbox(indent_unit));\n+                        try!(s.cbox(INDENT_UNIT));\n                         if !f.node.is_shorthand {\n                             try!(s.print_ident(f.node.ident));\n                             try!(s.word_nbsp(\":\"));\n@@ -2525,7 +2585,7 @@ impl<'a> State<'a> {\n         if arm.attrs.is_empty() {\n             try!(space(&mut self.s));\n         }\n-        try!(self.cbox(indent_unit));\n+        try!(self.cbox(INDENT_UNIT));\n         try!(self.ibox(0));\n         try!(self.print_outer_attributes(&arm.attrs));\n         let mut first = true;\n@@ -2549,7 +2609,7 @@ impl<'a> State<'a> {\n         match arm.body.node {\n             ast::ExprBlock(ref blk) => {\n                 // the block will close the pattern's ibox\n-                try!(self.print_block_unclosed_indent(&**blk, indent_unit));\n+                try!(self.print_block_unclosed_indent(&**blk, INDENT_UNIT));\n \n                 // If it is a user-provided unsafe block, print a comma after it\n                 if let ast::UnsafeBlock(ast::UserProvided) = blk.rules {\n@@ -2907,7 +2967,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_arg(&mut self, input: &ast::Arg) -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         match input.ty.node {\n             ast::TyInfer => try!(self.print_pat(&*input.pat)),\n             _ => {\n@@ -2935,7 +2995,7 @@ impl<'a> State<'a> {\n         }\n \n         try!(self.space_if_not_bol());\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         try!(self.word_space(\"->\"));\n         match decl.output {\n             ast::NoReturn(_) =>\n@@ -2960,7 +3020,7 @@ impl<'a> State<'a> {\n                        generics: &ast::Generics,\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n-        try!(self.ibox(indent_unit));\n+        try!(self.ibox(INDENT_UNIT));\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n             try!(word(&mut self.s, \"for\"));\n             try!(self.print_generics(generics));"}, {"sha": "6fd3833a3cd50ab739dd8e3f1e4458bbd37cebc5", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -29,7 +29,8 @@ use entry::{self, EntryPointType};\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::expand::ExpansionConfig;\n-use fold::{Folder, MoveMap};\n+use fold::Folder;\n+use util::move_map::MoveMap;\n use fold;\n use owned_slice::OwnedSlice;\n use parse::token::{intern, InternedString};\n@@ -88,7 +89,7 @@ pub fn modify_for_testing(sess: &ParseSess,\n     if should_test {\n         generate_test_harness(sess, reexport_test_harness_main, krate, cfg, span_diagnostic)\n     } else {\n-        strip_test_functions(krate)\n+        strip_test_functions(span_diagnostic, krate)\n     }\n }\n \n@@ -314,10 +315,11 @@ fn generate_test_harness(sess: &ParseSess,\n     return res;\n }\n \n-fn strip_test_functions(krate: ast::Crate) -> ast::Crate {\n+fn strip_test_functions(diagnostic: &diagnostic::SpanHandler, krate: ast::Crate)\n+                        -> ast::Crate {\n     // When not compiling with --test we should not compile the\n     // #[test] functions\n-    config::strip_items(krate, |attrs| {\n+    config::strip_items(diagnostic, krate, |attrs| {\n         !attr::contains_name(&attrs[..], \"test\") &&\n         !attr::contains_name(&attrs[..], \"bench\")\n     })\n@@ -619,8 +621,10 @@ fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n                     mk_test_desc_and_fn_rec(cx, test)\n                 }).collect()),\n                 span: DUMMY_SP,\n+                attrs: None,\n             })),\n         span: DUMMY_SP,\n+        attrs: None,\n     })\n }\n "}, {"sha": "95c24c66630f048298814882ddebfccdc77693b6", "filename": "src/libsyntax/util/move_map.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Futil%2Fmove_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Futil%2Fmove_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fmove_map.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use owned_slice::OwnedSlice;\n+\n+use std::ptr;\n+\n+pub trait MoveMap<T>: Sized {\n+    fn move_map<F>(self, mut f: F) -> Self where F: FnMut(T) -> T {\n+        self.move_flat_map(|e| Some(f(e)))\n+    }\n+\n+    fn move_flat_map<F, I>(self, f: F) -> Self\n+        where F: FnMut(T) -> I,\n+              I: IntoIterator<Item=T>;\n+}\n+\n+impl<T> MoveMap<T> for Vec<T> {\n+    fn move_flat_map<F, I>(mut self, mut f: F) -> Self\n+        where F: FnMut(T) -> I,\n+              I: IntoIterator<Item=T>\n+    {\n+        let mut read_i = 0;\n+        let mut write_i = 0;\n+        unsafe {\n+            let mut old_len = self.len();\n+            self.set_len(0); // make sure we just leak elements in case of panic\n+\n+            while read_i < old_len {\n+                // move the read_i'th item out of the vector and map it\n+                // to an iterator\n+                let e = ptr::read(self.get_unchecked(read_i));\n+                let mut iter = f(e).into_iter();\n+                read_i += 1;\n+\n+                while let Some(e) = iter.next() {\n+                    if write_i < read_i {\n+                        ptr::write(self.get_unchecked_mut(write_i), e);\n+                        write_i += 1;\n+                    } else {\n+                        // If this is reached we ran out of space\n+                        // in the middle of the vector.\n+                        // However, the vector is in a valid state here,\n+                        // so we just do a somewhat inefficient insert.\n+                        self.set_len(old_len);\n+                        self.insert(write_i, e);\n+\n+                        old_len = self.len();\n+                        self.set_len(0);\n+\n+                        read_i += 1;\n+                        write_i += 1;\n+                    }\n+                }\n+            }\n+\n+            // write_i tracks the number of actually written new items.\n+            self.set_len(write_i);\n+        }\n+\n+        self\n+    }\n+}\n+\n+impl<T> MoveMap<T> for OwnedSlice<T> {\n+    fn move_flat_map<F, I>(self, f: F) -> Self\n+        where F: FnMut(T) -> I,\n+              I: IntoIterator<Item=T>\n+    {\n+        OwnedSlice::from_vec(self.into_vec().move_flat_map(f))\n+    }\n+}"}, {"sha": "ee183d7f3e96a3455f024fa33c0fdd65b5062ded", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -16,7 +16,7 @@ use std::mem;\n use std::slice;\n use std::vec;\n \n-use fold::MoveMap;\n+use util::move_map::MoveMap;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n pub struct SmallVector<T> {\n@@ -134,15 +134,6 @@ impl<T> SmallVector<T> {\n         self.into_iter()\n     }\n \n-    pub fn into_iter(self) -> IntoIter<T> {\n-        let repr = match self.repr {\n-            Zero => ZeroIterator,\n-            One(v) => OneIterator(v),\n-            Many(vs) => ManyIterator(vs.into_iter())\n-        };\n-        IntoIter { repr: repr }\n-    }\n-\n     pub fn len(&self) -> usize {\n         match self.repr {\n             Zero => 0,\n@@ -154,6 +145,19 @@ impl<T> SmallVector<T> {\n     pub fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n+impl<T> IntoIterator for SmallVector<T> {\n+    type Item = T;\n+    type IntoIter = IntoIter<T>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        let repr = match self.repr {\n+            Zero => ZeroIterator,\n+            One(v) => OneIterator(v),\n+            Many(vs) => ManyIterator(vs.into_iter())\n+        };\n+        IntoIter { repr: repr }\n+    }\n+}\n+\n pub struct IntoIter<T> {\n     repr: IntoIterRepr<T>,\n }\n@@ -192,13 +196,15 @@ impl<T> Iterator for IntoIter<T> {\n }\n \n impl<T> MoveMap<T> for SmallVector<T> {\n-    fn move_map<F>(self, mut f: F) -> SmallVector<T> where F: FnMut(T) -> T {\n-        let repr = match self.repr {\n-            Zero => Zero,\n-            One(v) => One(f(v)),\n-            Many(vs) => Many(vs.move_map(f))\n-        };\n-        SmallVector { repr: repr }\n+    fn move_flat_map<F, I>(self, mut f: F) -> Self\n+        where F: FnMut(T) -> I,\n+              I: IntoIterator<Item=T>\n+    {\n+        match self.repr {\n+            Zero => Self::zero(),\n+            One(v) => f(v).into_iter().collect(),\n+            Many(vs) => SmallVector { repr: Many(vs.move_flat_map(f)) },\n+        }\n     }\n }\n "}, {"sha": "cdc11fb2c1cb0262cef3e0ce563290ee0d2b737c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -25,6 +25,7 @@\n \n use abi::Abi;\n use ast::*;\n+use attr::ThinAttributesExt;\n use codemap::Span;\n \n #[derive(Copy, Clone, PartialEq, Eq)]\n@@ -628,7 +629,12 @@ pub fn walk_stmt<'v, V: Visitor<'v>>(visitor: &mut V, statement: &'v Stmt) {\n         StmtExpr(ref expression, _) | StmtSemi(ref expression, _) => {\n             visitor.visit_expr(expression)\n         }\n-        StmtMac(ref mac, _) => visitor.visit_mac(mac),\n+        StmtMac(ref mac, _, ref attrs) => {\n+            visitor.visit_mac(mac);\n+            for attr in attrs.as_attr_slice() {\n+                visitor.visit_attribute(attr);\n+            }\n+        }\n     }\n }\n "}, {"sha": "d9d379ddc7dd59874cbf961bc267e3220e499b94", "filename": "src/test/compile-fail/cfg-non-opt-expr.rs", "status": "renamed", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fcompile-fail%2Fcfg-non-opt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fcompile-fail%2Fcfg-non-opt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcfg-non-opt-expr.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n-\n fn main() {\n-    #[attr] //~ ERROR expected item after attributes\n-    println!(\"hi\");\n+    let _ = #[cfg(unset)] ();\n+    //~^ ERROR removing an expression is not supported in this position\n+    let _ = 1 + 2 + #[cfg(unset)] 3;\n+    //~^ ERROR removing an expression is not supported in this position\n+    let _ = [1, 2, 3][#[cfg(unset)] 1];\n+    //~^ ERROR removing an expression is not supported in this position\n }", "previous_filename": "src/test/parse-fail/attr-before-ext.rs"}, {"sha": "49b2fa0e3502239dccde3de7b149f87a8b4996c6", "filename": "src/test/compile-fail/expr_attr_paren_order.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fcompile-fail%2Fexpr_attr_paren_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fcompile-fail%2Fexpr_attr_paren_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexpr_attr_paren_order.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(stmt_expr_attributes)]\n+\n+fn main() {\n+\n+    // Test that attributes on parens get concatenated\n+    // in the expected order in the hir folder.\n+\n+    #[deny(non_snake_case)] (\n+        #![allow(non_snake_case)]\n+        {\n+            let X = 0;\n+            let _ = X;\n+        }\n+    );\n+\n+    #[allow(non_snake_case)] (\n+        #![deny(non_snake_case)]\n+        {\n+            let X = 0; //~ ERROR snake case name\n+            let _ = X;\n+        }\n+    );\n+\n+}"}, {"sha": "68338b115950c0f901d177a6c01a63530bf8340b", "filename": "src/test/compile-fail/stmt_expr_attrs_no_feature.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstmt_expr_attrs_no_feature.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,151 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(custom_attribute)]\n+#![feature(associated_consts)]\n+\n+macro_rules! stmt_mac {\n+    () => {\n+        fn b() {}\n+    }\n+}\n+\n+fn main() {\n+    #[attr]\n+    fn a() {}\n+\n+    #[attr] //~ ERROR 15701\n+    {\n+\n+    }\n+\n+    #[attr] //~ ERROR 15701\n+    5;\n+\n+    #[attr] //~ ERROR 15701\n+    stmt_mac!();\n+}\n+\n+// Check that cfg works right\n+\n+#[cfg(unset)]\n+fn c() {\n+    #[attr]\n+    5;\n+}\n+\n+#[cfg(not(unset))]\n+fn j() {\n+    #[attr] //~ ERROR 15701\n+    5;\n+}\n+\n+#[cfg_attr(not(unset), cfg(unset))]\n+fn d() {\n+    #[attr]\n+    8;\n+}\n+\n+#[cfg_attr(not(unset), cfg(not(unset)))]\n+fn i() {\n+    #[attr] //~ ERROR 15701\n+    8;\n+}\n+\n+// check that macro expansion and cfg works right\n+\n+macro_rules! item_mac {\n+    ($e:ident) => {\n+        fn $e() {\n+            #[attr] //~ ERROR 15701\n+            42;\n+\n+            #[cfg(unset)]\n+            fn f() {\n+                #[attr]\n+                5;\n+            }\n+\n+            #[cfg(not(unset))]\n+            fn k() {\n+                #[attr] //~ ERROR 15701\n+                5;\n+            }\n+\n+            #[cfg_attr(not(unset), cfg(unset))]\n+            fn g() {\n+                #[attr]\n+                8;\n+            }\n+\n+            #[cfg_attr(not(unset), cfg(not(unset)))]\n+            fn h() {\n+                #[attr] //~ ERROR 15701\n+                8;\n+            }\n+\n+        }\n+    }\n+}\n+\n+item_mac!(e);\n+\n+// check that the gate visitor works right:\n+\n+extern {\n+    #[cfg(unset)]\n+    fn x(a: [u8; #[attr] 5]);\n+    fn y(a: [u8; #[attr] 5]); //~ ERROR 15701\n+}\n+\n+struct Foo;\n+impl Foo {\n+    #[cfg(unset)]\n+    const X: u8 = #[attr] 5;\n+    const Y: u8 = #[attr] 5; //~ ERROR 15701\n+}\n+\n+trait Bar {\n+    #[cfg(unset)]\n+    const X: [u8; #[attr] 5];\n+    const Y: [u8; #[attr] 5]; //~ ERROR 15701\n+}\n+\n+struct Joyce {\n+    #[cfg(unset)]\n+    field: [u8; #[attr] 5],\n+    field2: [u8; #[attr] 5] //~ ERROR 15701\n+}\n+\n+struct Walky(\n+    #[cfg(unset)] [u8; #[attr] 5],\n+    [u8; #[attr] 5] //~ ERROR 15701\n+);\n+\n+enum Mike {\n+    Happy(\n+        #[cfg(unset)] [u8; #[attr] 5],\n+        [u8; #[attr] 5] //~ ERROR 15701\n+    ),\n+    Angry {\n+        #[cfg(unset)]\n+        field: [u8; #[attr] 5],\n+        field2: [u8; #[attr] 5] //~ ERROR 15701\n+    }\n+}\n+\n+fn pat() {\n+    match 5 {\n+        #[cfg(unset)]\n+        5 => #[attr] (),\n+        6 => #[attr] (), //~ ERROR 15701\n+        _ => (),\n+    }\n+}"}, {"sha": "03dabb980f20d923c3a22c49c3ab84d9d160d785", "filename": "src/test/parse-fail/attr-before-let.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5673a7b374c9645ba4bc947588555667f7162cdb/src%2Ftest%2Fparse-fail%2Fattr-before-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5673a7b374c9645ba4bc947588555667f7162cdb/src%2Ftest%2Fparse-fail%2Fattr-before-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-before-let.rs?ref=5673a7b374c9645ba4bc947588555667f7162cdb", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn main() {\n-    #[attr] //~ ERROR expected item\n-    let __isize = 0;\n-}"}, {"sha": "bc306048cdc4a3e6760e09adab210554ff33faad", "filename": "src/test/parse-fail/attr-before-stmt.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5673a7b374c9645ba4bc947588555667f7162cdb/src%2Ftest%2Fparse-fail%2Fattr-before-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5673a7b374c9645ba4bc947588555667f7162cdb/src%2Ftest%2Fparse-fail%2Fattr-before-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-before-stmt.rs?ref=5673a7b374c9645ba4bc947588555667f7162cdb", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-// error-pattern:expected item\n-\n-fn f() {\n-  #[foo = \"bar\"]\n-  let x = 10;\n-}\n-\n-fn main() {\n-}"}, {"sha": "7b731b6d6de609632241c3aebeb5b62d1253a0f1", "filename": "src/test/parse-fail/attr-dangling-in-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fparse-fail%2Fattr-dangling-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fparse-fail%2Fattr-dangling-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fattr-dangling-in-fn.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: -Z parse-only\n \n-// error-pattern:expected item\n+// error-pattern:expected statement\n \n fn f() {\n   #[foo = \"bar\"]"}, {"sha": "44435bde03c0d39fe998f692e09e09a00373f98d", "filename": "src/test/parse-fail/doc-before-macro.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5673a7b374c9645ba4bc947588555667f7162cdb/src%2Ftest%2Fparse-fail%2Fdoc-before-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5673a7b374c9645ba4bc947588555667f7162cdb/src%2Ftest%2Fparse-fail%2Fdoc-before-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdoc-before-macro.rs?ref=5673a7b374c9645ba4bc947588555667f7162cdb", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// compile-flags: -Z parse-only\n-\n-fn main() {\n-    /// hi\n-    println!(\"hi\");\n-    //~^^ ERROR expected item after doc comment\n-}"}, {"sha": "295d5ae432ecb3f48f1c3a1216c115582919daaf", "filename": "src/test/parse-fail/doc-before-rbrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fparse-fail%2Fdoc-before-rbrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fparse-fail%2Fdoc-before-rbrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdoc-before-rbrace.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     println!(\"Hi\"); /// hi\n-    //~^ ERROR expected item after doc comment\n }\n+//~^ ERROR expected statement"}, {"sha": "6a8906953be091ade684055cd72cf09527813445", "filename": "src/test/parse-fail/doc-before-semi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fparse-fail%2Fdoc-before-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fparse-fail%2Fdoc-before-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fdoc-before-semi.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -13,5 +13,5 @@\n fn main() {\n     /// hi\n     ;\n-    //~^^ ERROR expected item after doc comment\n+    //~^ ERROR expected statement\n }"}, {"sha": "e52932cd7befa32bd391ea2f8bb0b7dd5006b762", "filename": "src/test/pretty/stmt_expr_attributes.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fstmt_expr_attributes.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,282 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// pp-exact\n+\n+#![feature(custom_attribute)]\n+#![feature(box_syntax)]\n+#![feature(placement_in_syntax)]\n+#![feature(stmt_expr_attributes)]\n+\n+fn main() { }\n+\n+fn _0() {\n+\n+    #[attr]\n+    foo();\n+}\n+\n+fn _1() {\n+\n+    #[attr]\n+    unsafe {\n+        // code\n+    }\n+}\n+\n+fn _2() {\n+\n+    #[attr]\n+    { foo(); }\n+\n+    {\n+        #![attr]\n+\n+        foo()\n+    }\n+}\n+\n+fn _3() {\n+\n+    #[attr]\n+    match () { _ => { } }\n+}\n+\n+fn _4() {\n+\n+    #[attr]\n+    match () {\n+        #![attr]\n+        _ => (),\n+    }\n+\n+    let _ =\n+        #[attr] match () {\n+                    #![attr]\n+                    () => (),\n+                };\n+}\n+\n+fn _5() {\n+\n+    #[attr]\n+    let x = 1;\n+\n+    let x = #[attr] 1;\n+\n+    let y = ();\n+    let z = ();\n+\n+    foo3(x, #[attr] y, z);\n+\n+    qux(3 + #[attr] 2);\n+}\n+\n+fn _6() {\n+\n+    #[attr]\n+    [#![attr] 1, 2, 3];\n+\n+    let _ = #[attr] [#![attr] 1, 2, 3];\n+\n+    #[attr]\n+    [#![attr] 1; 4];\n+\n+    let _ = #[attr] [#![attr] 1; 4];\n+}\n+\n+struct Foo {\n+    data: (),\n+}\n+\n+struct Bar(());\n+\n+fn _7() {\n+\n+    #[attr]\n+    Foo{#![attr] data: (),};\n+\n+    let _ = #[attr] Foo{#![attr] data: (),};\n+}\n+\n+fn _8() {\n+\n+    #[attr]\n+    (#![attr] );\n+\n+    #[attr]\n+    (#![attr] 0);\n+\n+    #[attr]\n+    (#![attr] 0,);\n+\n+    #[attr]\n+    (#![attr] 0, 1);\n+}\n+\n+fn _9() {\n+    macro_rules! stmt_mac((  ) => { let _ = (  ) ; });\n+\n+    #[attr]\n+    stmt_mac!();\n+\n+    /*\n+    // pre existing pp bug: delimiter styles gets lost:\n+\n+    #[attr]\n+    stmt_mac!{ };\n+\n+    #[attr]\n+    stmt_mac![];\n+\n+    #[attr]\n+    stmt_mac!{ } // pre-existing pp bug: compiler ICEs with a None unwrap\n+    */\n+\n+    let _ = ();\n+}\n+\n+macro_rules! expr_mac((  ) => { (  ) });\n+\n+fn _10() {\n+\n+    let _ = #[attr] expr_mac!();\n+\n+    /*\n+    // pre existing pp bug: delimiter styles gets lost:\n+    let _ = #[attr] expr_mac![];\n+    let _ = #[attr] expr_mac!{};\n+    */\n+}\n+\n+fn _11() {\n+    let _ = #[attr] box 0;\n+    let _: [(); 0] = #[attr] [#![attr] ];\n+    let _ = #[attr] [#![attr] 0, 0];\n+    let _ = #[attr] [#![attr] 0; 0];\n+    let _ = #[attr] foo();\n+    let _ = #[attr] 1i32.clone();\n+    let _ = #[attr] (#![attr] );\n+    let _ = #[attr] (#![attr] 0);\n+    let _ = #[attr] (#![attr] 0,);\n+    let _ = #[attr] (#![attr] 0, 0);\n+    let _ = #[attr] 0 + #[attr] 0;\n+    let _ = #[attr] !0;\n+    let _ = #[attr] -0i32;\n+    let _ = #[attr] false;\n+    let _ = #[attr] 'c';\n+    let _ = #[attr] 0;\n+    let _ = #[attr] 0 as usize;\n+    let _ =\n+        #[attr] while false {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] while let None = Some(()) {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] for _ in 0..0 {\n+                    #![attr]\n+                };\n+    // FIXME: pp bug, two spaces after the loop\n+    let _ =\n+        #[attr] loop  {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] match false {\n+                    #![attr]\n+                    _ => (),\n+                };\n+    let _ = #[attr] || #[attr] ();\n+    let _ = #[attr] move || #[attr] ();\n+    let _ = #[attr] || {\n+        #![attr]\n+        #[attr]\n+        () };\n+    let _ = #[attr] move || {\n+        #![attr]\n+        #[attr]\n+        () };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                    let _ = ();\n+                };\n+    let _ =\n+        #[attr] {\n+                    #![attr]\n+                    let _ = ();\n+                    ()\n+                };\n+    let mut x = 0;\n+    let _ = #[attr] x = 15;\n+    let _ = #[attr] x += 15;\n+    let s = Foo{data: (),};\n+    let _ = #[attr] s.data;\n+    let _ = (#[attr] s).data;\n+    let t = Bar(());\n+    let _ = #[attr] t.0;\n+    let _ = (#[attr] t).0;\n+    let v = vec!(0);\n+    let _ = #[attr] v[0];\n+    let _ = (#[attr] v)[0];\n+    let _ = #[attr] 0..#[attr] 0;\n+    let _ = #[attr] 0..;\n+    let _ = #[attr] (0..0);\n+    let _ = #[attr] (0..);\n+    let _ = #[attr] (..0);\n+    let _ = #[attr] (..);\n+    let _: fn(&u32) -> u32 = #[attr] std::clone::Clone::clone;\n+    let _ = #[attr] &0;\n+    let _ = #[attr] &mut 0;\n+    let _ = #[attr] &#[attr] 0;\n+    let _ = #[attr] &mut #[attr] 0;\n+    // FIXME: pp bug, extra space after keyword?\n+    while false { let _ = #[attr] continue ; }\n+    while true { let _ = #[attr] break ; }\n+    || #[attr] return;\n+    let _ = #[attr] expr_mac!();\n+    /* FIXME: pp bug, loosing delimiter styles\n+    let _ = #[attr] expr_mac![];\n+    let _ = #[attr] expr_mac!{};\n+    */\n+    let _ = #[attr] Foo{#![attr] data: (),};\n+    let _ = #[attr] Foo{#![attr] ..s};\n+    let _ = #[attr] Foo{#![attr] data: (), ..s};\n+    let _ = #[attr] (#![attr] 0);\n+}\n+\n+fn _12() {\n+    #[attr]\n+    let _ = 0;\n+\n+    #[attr]\n+    0;\n+\n+    #[attr]\n+    expr_mac!();\n+\n+    #[attr]\n+    {\n+        #![attr]\n+    }\n+}\n+\n+/////////////////\n+\n+fn foo() { }\n+fn foo3(_: i32, _: (), _: ()) { }\n+fn qux(_: i32) { }"}, {"sha": "e40abe050233331444fb50cb880ba377578d261c", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,308 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-cross-compile\n+\n+#![feature(rustc_private)]\n+\n+extern crate syntax;\n+\n+use syntax::ast::*;\n+use syntax::attr::*;\n+use syntax::ast;\n+use syntax::parse;\n+use syntax::parse::{ParseSess,filemap_to_tts, PResult};\n+use syntax::parse::new_parser_from_source_str;\n+use syntax::parse::parser::Parser;\n+use syntax::parse::token;\n+use syntax::ptr::P;\n+use syntax::str::char_at;\n+use syntax::parse::attr::*;\n+use syntax::print::pprust;\n+use std::fmt;\n+\n+// Copied out of syntax::util::parser_testing\n+\n+pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n+    new_parser_from_source_str(ps,\n+                               Vec::new(),\n+                               \"bogofile\".to_string(),\n+                               source_str)\n+}\n+\n+fn with_error_checking_parse<T, F>(s: String, f: F) -> PResult<T> where\n+    F: FnOnce(&mut Parser) -> PResult<T>,\n+{\n+    let ps = ParseSess::new();\n+    let mut p = string_to_parser(&ps, s);\n+    let x = f(&mut p);\n+\n+    if ps.span_diagnostic.handler().has_errors() || p.token != token::Eof {\n+        return Err(p.fatal(\"parse error\"));\n+    }\n+\n+    x\n+}\n+\n+fn expr(s: &str) -> PResult<P<ast::Expr>> {\n+    with_error_checking_parse(s.to_string(), |p| {\n+        p.parse_expr()\n+    })\n+}\n+\n+fn stmt(s: &str) -> PResult<P<ast::Stmt>> {\n+    with_error_checking_parse(s.to_string(), |p| {\n+        p.parse_stmt().map(|s| s.unwrap())\n+    })\n+}\n+\n+fn attr(s: &str) -> PResult<ast::Attribute> {\n+    with_error_checking_parse(s.to_string(), |p| {\n+        p.parse_attribute(true)\n+    })\n+}\n+\n+fn str_compare<T, F: Fn(&T) -> String>(e: &str, expected: &[T], actual: &[T], f: F) {\n+    let expected: Vec<_> = expected.iter().map(|e| f(e)).collect();\n+    let actual: Vec<_> = actual.iter().map(|e| f(e)).collect();\n+\n+    if expected != actual {\n+        panic!(\"parsed `{}` as {:?}, expected {:?}\", e, actual, expected);\n+    }\n+}\n+\n+fn check_expr_attrs(es: &str, expected: &[&str]) {\n+    let e = expr(es).expect(\"parse error\");\n+    let actual = &e.attrs;\n+    str_compare(es,\n+                &expected.iter().map(|r| attr(r).unwrap()).collect::<Vec<_>>(),\n+                actual.as_attr_slice(),\n+                pprust::attribute_to_string);\n+}\n+\n+fn check_stmt_attrs(es: &str, expected: &[&str]) {\n+    let e = stmt(es).expect(\"parse error\");\n+    let actual = e.node.attrs();\n+    str_compare(es,\n+                &expected.iter().map(|r| attr(r).unwrap()).collect::<Vec<_>>(),\n+                actual,\n+                pprust::attribute_to_string);\n+}\n+\n+fn reject_expr_parse(es: &str) {\n+    assert!(expr(es).is_err(), \"parser did not reject `{}`\", es);\n+}\n+\n+fn reject_stmt_parse(es: &str) {\n+    assert!(stmt(es).is_err(), \"parser did not reject `{}`\", es);\n+}\n+\n+fn main() {\n+    let both = &[\"#[attr]\", \"#![attr]\"];\n+    let outer = &[\"#[attr]\"];\n+    let none = &[];\n+\n+    check_expr_attrs(\"#[attr] box 0\", outer);\n+    reject_expr_parse(\"box #![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] 0 <- #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] (0 <- 0)\", outer);\n+    reject_expr_parse(\"0 #[attr] <- 0\");\n+    reject_expr_parse(\"0 <- #![attr] 0\");\n+\n+    check_expr_attrs(\"in #[attr] 0 {#[attr] 0}\", none);\n+    check_expr_attrs(\"#[attr] (in 0 {0})\", outer);\n+    reject_expr_parse(\"in 0 #[attr] {0}\");\n+    reject_expr_parse(\"in 0 {#![attr] 0}\");\n+\n+    check_expr_attrs(\"#[attr] [#![attr]]\", both);\n+    check_expr_attrs(\"#[attr] [#![attr] 0]\", both);\n+    check_expr_attrs(\"#[attr] [#![attr] 0; 0]\", both);\n+    check_expr_attrs(\"#[attr] [#![attr] 0, 0, 0]\", both);\n+    reject_expr_parse(\"[#[attr]]\");\n+\n+    check_expr_attrs(\"#[attr] foo()\", outer);\n+    check_expr_attrs(\"#[attr] x.foo()\", outer);\n+    reject_expr_parse(\"foo#[attr]()\");\n+    reject_expr_parse(\"foo(#![attr])\");\n+    reject_expr_parse(\"x.foo(#![attr])\");\n+    reject_expr_parse(\"x.#[attr]foo()\");\n+    reject_expr_parse(\"x.#![attr]foo()\");\n+\n+    check_expr_attrs(\"#[attr] (#![attr])\", both);\n+    check_expr_attrs(\"#[attr] (#![attr] #[attr] 0,)\", both);\n+    check_expr_attrs(\"#[attr] (#![attr] #[attr] 0, 0)\", both);\n+\n+    check_expr_attrs(\"#[attr] 0 + #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0 / #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0 & #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0 % #[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] (0 + 0)\", outer);\n+    reject_expr_parse(\"0 + #![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] !0\", outer);\n+    check_expr_attrs(\"#[attr] -0\", outer);\n+    reject_expr_parse(\"!#![attr] 0\");\n+    reject_expr_parse(\"-#![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] false\", outer);\n+    check_expr_attrs(\"#[attr] 0\", outer);\n+    check_expr_attrs(\"#[attr] 'c'\", outer);\n+\n+    check_expr_attrs(\"#[attr] x as Y\", none);\n+    check_expr_attrs(\"#[attr] (x as Y)\", outer);\n+    reject_expr_parse(\"x #![attr] as Y\");\n+\n+    reject_expr_parse(\"#[attr] if false {}\");\n+    reject_expr_parse(\"if false #[attr] {}\");\n+    reject_expr_parse(\"if false {#![attr]}\");\n+    reject_expr_parse(\"if false {} #[attr] else {}\");\n+    reject_expr_parse(\"if false {} else #[attr] {}\");\n+    reject_expr_parse(\"if false {} else {#![attr]}\");\n+    reject_expr_parse(\"if false {} else #[attr] if true {}\");\n+    reject_expr_parse(\"if false {} else if true #[attr] {}\");\n+    reject_expr_parse(\"if false {} else if true {#![attr]}\");\n+\n+    reject_expr_parse(\"#[attr] if let Some(false) = false {}\");\n+    reject_expr_parse(\"if let Some(false) = false #[attr] {}\");\n+    reject_expr_parse(\"if let Some(false) = false {#![attr]}\");\n+    reject_expr_parse(\"if let Some(false) = false {} #[attr] else {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else #[attr] {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else {#![attr]}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else #[attr] if let Some(false) = true {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else if let Some(false) = true #[attr] {}\");\n+    reject_expr_parse(\"if let Some(false) = false {} else if let Some(false) = true {#![attr]}\");\n+\n+    check_expr_attrs(\"#[attr] while true {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] while let Some(false) = true {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] for x in y {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] loop {#![attr]}\", both);\n+\n+    check_expr_attrs(\"#[attr] match true {#![attr] #[attr] _ => false}\", both);\n+\n+    check_expr_attrs(\"#[attr]      || #[attr] foo\", outer);\n+    check_expr_attrs(\"#[attr] move || #[attr] foo\", outer);\n+    check_expr_attrs(\"#[attr]      || #[attr] { #![attr] foo }\", outer);\n+    check_expr_attrs(\"#[attr] move || #[attr] { #![attr] foo }\", outer);\n+    check_expr_attrs(\"#[attr]      || { #![attr] foo }\", outer);\n+    check_expr_attrs(\"#[attr] move || { #![attr] foo }\", outer);\n+    reject_expr_parse(\"|| #![attr] foo\");\n+    reject_expr_parse(\"move || #![attr] foo\");\n+    reject_expr_parse(\"|| #![attr] {foo}\");\n+    reject_expr_parse(\"move || #![attr] {foo}\");\n+\n+    check_expr_attrs(\"#[attr] { #![attr] }\", both);\n+    check_expr_attrs(\"#[attr] { #![attr] let _ = (); }\", both);\n+    check_expr_attrs(\"#[attr] { #![attr] let _ = (); foo }\", both);\n+\n+    check_expr_attrs(\"#[attr] x = y\", none);\n+    check_expr_attrs(\"#[attr] (x = y)\", outer);\n+\n+    check_expr_attrs(\"#[attr] x += y\", none);\n+    check_expr_attrs(\"#[attr] (x += y)\", outer);\n+\n+    check_expr_attrs(\"#[attr] foo.bar\", outer);\n+    check_expr_attrs(\"(#[attr] foo).bar\", none);\n+\n+    check_expr_attrs(\"#[attr] foo.0\", outer);\n+    check_expr_attrs(\"(#[attr] foo).0\", none);\n+\n+    check_expr_attrs(\"#[attr] foo[bar]\", outer);\n+    check_expr_attrs(\"(#[attr] foo)[bar]\", none);\n+\n+    check_expr_attrs(\"#[attr] 0..#[attr] 0\", none);\n+    check_expr_attrs(\"#[attr] 0..\", none);\n+    reject_expr_parse(\"#[attr] ..#[attr] 0\");\n+    reject_expr_parse(\"#[attr] ..\");\n+\n+    check_expr_attrs(\"#[attr] (0..0)\", outer);\n+    check_expr_attrs(\"#[attr] (0..)\", outer);\n+    check_expr_attrs(\"#[attr] (..0)\", outer);\n+    check_expr_attrs(\"#[attr] (..)\", outer);\n+\n+    check_expr_attrs(\"#[attr] foo::bar::baz\", outer);\n+\n+    check_expr_attrs(\"#[attr] &0\", outer);\n+    check_expr_attrs(\"#[attr] &mut 0\", outer);\n+    check_expr_attrs(\"#[attr] & #[attr] 0\", outer);\n+    check_expr_attrs(\"#[attr] &mut #[attr] 0\", outer);\n+    reject_expr_parse(\"#[attr] &#![attr] 0\");\n+    reject_expr_parse(\"#[attr] &mut #![attr] 0\");\n+\n+    check_expr_attrs(\"#[attr] break\", outer);\n+    check_expr_attrs(\"#[attr] continue\", outer);\n+    check_expr_attrs(\"#[attr] return\", outer);\n+\n+    check_expr_attrs(\"#[attr] foo!()\", outer);\n+    check_expr_attrs(\"#[attr] foo!(#![attr])\", outer);\n+    check_expr_attrs(\"#[attr] foo![]\", outer);\n+    check_expr_attrs(\"#[attr] foo![#![attr]]\", outer);\n+    check_expr_attrs(\"#[attr] foo!{}\", outer);\n+    check_expr_attrs(\"#[attr] foo!{#![attr]}\", outer);\n+\n+    check_expr_attrs(\"#[attr] Foo { #![attr] bar: baz }\", both);\n+    check_expr_attrs(\"#[attr] Foo { #![attr] ..foo }\", both);\n+    check_expr_attrs(\"#[attr] Foo { #![attr] bar: baz, ..foo }\", both);\n+\n+    check_expr_attrs(\"#[attr] (#![attr] 0)\", both);\n+\n+    // Look at statements in their natural habitat...\n+    check_expr_attrs(\"{\n+        #[attr] let _ = 0;\n+        #[attr] 0;\n+        #[attr] foo!();\n+        #[attr] foo!{}\n+        #[attr] foo![];\n+    }\", none);\n+\n+    check_stmt_attrs(\"#[attr] let _ = 0\", outer);\n+    check_stmt_attrs(\"#[attr] 0\",         outer);\n+    check_stmt_attrs(\"#[attr] {#![attr]}\", both);\n+    check_stmt_attrs(\"#[attr] foo!()\",    outer);\n+    check_stmt_attrs(\"#[attr] foo![]\",    outer);\n+    check_stmt_attrs(\"#[attr] foo!{}\",    outer);\n+\n+    reject_stmt_parse(\"#[attr] #![attr] let _ = 0\");\n+    reject_stmt_parse(\"#[attr] #![attr] 0\");\n+    reject_stmt_parse(\"#[attr] #![attr] foo!()\");\n+    reject_stmt_parse(\"#[attr] #![attr] foo![]\");\n+    reject_stmt_parse(\"#[attr] #![attr] foo!{}\");\n+\n+    // FIXME: Allow attributes in pattern constexprs?\n+    // would require parens in patterns to allow disambiguation...\n+\n+    reject_expr_parse(\"match 0 {\n+        0...#[attr] 10 => ()\n+    }\");\n+    reject_expr_parse(\"match 0 {\n+        0...#[attr] -10 => ()\n+    }\");\n+    reject_expr_parse(\"match 0 {\n+        0...-#[attr] 10 => ()\n+    }\");\n+    reject_expr_parse(\"match 0 {\n+        0...#[attr] FOO => ()\n+    }\");\n+\n+    // make sure we don't catch this bug again...\n+    reject_expr_parse(\"{\n+        fn foo() {\n+            #[attr];\n+        }\n+    }\");\n+    reject_expr_parse(\"{\n+        fn foo() {\n+            #[attr]\n+        }\n+    }\");\n+}"}, {"sha": "fcc93557665bff538c5980e4a3443e62e40214a8", "filename": "src/test/run-pass/cfg_stmt_expr.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcfg_stmt_expr.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(non_snake_case)]\n+#![feature(stmt_expr_attributes)]\n+\n+fn main() {\n+    let a = 413;\n+    #[cfg(unset)]\n+    let a = ();\n+    assert_eq!(a, 413);\n+\n+    let mut b = 612;\n+    #[cfg(unset)]\n+    {\n+        b = 1111;\n+    }\n+    assert_eq!(b, 612);\n+\n+    #[cfg(unset)]\n+    undefined_fn();\n+\n+    #[cfg(unset)]\n+    undefined_macro!();\n+    #[cfg(unset)]\n+    undefined_macro![];\n+    #[cfg(unset)]\n+    undefined_macro!{};\n+\n+    // pretty printer bug...\n+    // #[cfg(unset)]\n+    // undefined_macro!{}\n+\n+    let () = (#[cfg(unset)] 341,); // Should this also work on parens?\n+    let t = (1, #[cfg(unset)] 3, 4);\n+    assert_eq!(t, (1, 4));\n+\n+    let f = |_: u32, _: u32| ();\n+    f(2, 1, #[cfg(unset)] 6);\n+\n+    let _: u32 = a.clone(#[cfg(unset)] undefined);\n+\n+    let _: [(); 0] = [#[cfg(unset)] 126];\n+    let t = [#[cfg(unset)] 1, 2, 6];\n+    assert_eq!(t, [2, 6]);\n+\n+    {\n+        let r;\n+        #[cfg(unset)]\n+        (r = 5);\n+        #[cfg(not(unset))]\n+        (r = 10);\n+        assert_eq!(r, 10);\n+    }\n+\n+    // check that macro expanded code works\n+\n+    macro_rules! if_cfg {\n+        ($cfg:meta $ib:block else $eb:block) => {\n+            {\n+                let r;\n+                #[cfg($cfg)]\n+                (r = $ib);\n+                #[cfg(not($cfg))]\n+                (r = $eb);\n+                r\n+            }\n+        }\n+    }\n+\n+    let n = if_cfg!(unset {\n+        413\n+    } else {\n+        612\n+    });\n+\n+    assert_eq!((#[cfg(unset)] 1, #[cfg(not(unset))] 2), (2,));\n+    assert_eq!(n, 612);\n+\n+    // check that lints work\n+\n+    #[allow(non_snake_case)]\n+    let FOOBAR = {\n+        fn SYLADEX() {}\n+    };\n+\n+    #[allow(non_snake_case)]\n+    {\n+        fn CRUXTRUDER() {}\n+    }\n+}"}, {"sha": "23559e8789bf536534e88ac0d3fa5aa895393aa2", "filename": "src/test/run-pass/stmt_expr_attr_macro_parse.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Frun-pass%2Fstmt_expr_attr_macro_parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77ed39cfe37a17737e0b2256b1a1689e01c32b26/src%2Ftest%2Frun-pass%2Fstmt_expr_attr_macro_parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstmt_expr_attr_macro_parse.rs?ref=77ed39cfe37a17737e0b2256b1a1689e01c32b26", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! m {\n+    ($e:expr) => {\n+        \"expr includes attr\"\n+    };\n+    (#[$attr:meta] $e:expr) => {\n+        \"expr excludes attr\"\n+    }\n+}\n+\n+macro_rules! n {\n+    (#[$attr:meta] $e:expr) => {\n+        \"expr excludes attr\"\n+    };\n+    ($e:expr) => {\n+        \"expr includes attr\"\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(m!(#[attr] 1), \"expr includes attr\");\n+    assert_eq!(n!(#[attr] 1), \"expr excludes attr\");\n+}"}]}