{"sha": "e97089dae33d5b228bb1b50ae12e96b13ab499b3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5NzA4OWRhZTMzZDViMjI4YmIxYjUwYWUxMmU5NmIxM2FiNDk5YjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2017-12-27T20:32:01Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:08:14Z"}, "message": "Move librustc_const_eval to librustc_mir", "tree": {"sha": "8746e6ce819ca68f421ff661278eb48fd40dc27c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8746e6ce819ca68f421ff661278eb48fd40dc27c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e97089dae33d5b228bb1b50ae12e96b13ab499b3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg4V4ACgkQpp+NIls6\n19kR4RAAoamBien7TZEkhjo04s7I4KCnZmjauSatqPUpfQdrG6aNnLhJPFJ14KDM\nNdg1aL2BSMb62baF/wOrC0ilyTGtk/Z4x1DKpazrTsiWIlHeVHVWAxCaRoh5ZDNf\n3PaiRlPRQilZq2cErgS4bIWtcaxrrcvHW8yNaaLkf80JWhTBA5GqmeXuN6ggf9fY\nnt68eioZHUNgKrSR/NBExU4uq2q/Es1C0qQFFQ3xPQcTVfrNP/JvH8uo0yy5tsNA\n3h/t5LEFCq5way1+GmT74HXajVSjKbK4ml0ydPeJluGixkQzCc5tvgiuiOIznHxb\nuawkdo9CyQvHhYcrfChWrPMVMpioaktZcgMwBzdPOYQr3QnpsV2WYaMcOFwmrc8O\nh9lvnNMJiswfEE5j0N65RaaqgUrdEv3GCL4doL7KW5/tnwWYpgd/dG5gHuJu6ow1\ngi8dtWd7OyhebPlnZGDbZEHRIrd0w29RFa6wokDihFoQKyMi00Yj+6ksEtOC++Fo\nPD2MLFvDHLA0Jykn1q1L6xvVQKJ2lzM+TOZNmApWmHrbgoWpZ11VJuDE9hFe3615\n51nItea5ILUbL3bZtSDG5G6xDEN8sEovc2q1yw6j6z1wtcDjxGCxpZyHxTX2+SsT\n+LsvNJcafCGRn4uZPlUKSsjUlSqVVj6nNnwg+7qpaQijZFaXk9g=\n=lul8\n-----END PGP SIGNATURE-----", "payload": "tree 8746e6ce819ca68f421ff661278eb48fd40dc27c\nparent 918b6d763319863fb53c5b7bceebc14ad5fb4024\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1514406721 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520492894 +0100\n\nMove librustc_const_eval to librustc_mir\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e97089dae33d5b228bb1b50ae12e96b13ab499b3", "html_url": "https://github.com/rust-lang/rust/commit/e97089dae33d5b228bb1b50ae12e96b13ab499b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e97089dae33d5b228bb1b50ae12e96b13ab499b3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "918b6d763319863fb53c5b7bceebc14ad5fb4024", "url": "https://api.github.com/repos/rust-lang/rust/commits/918b6d763319863fb53c5b7bceebc14ad5fb4024", "html_url": "https://github.com/rust-lang/rust/commit/918b6d763319863fb53c5b7bceebc14ad5fb4024"}], "stats": {"total": 1268, "additions": 626, "deletions": 642}, "files": [{"sha": "b62762ef69e0136e61975ad92df73df6e23e8fd1", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -64,7 +64,6 @@ for details on how to format and write long error codes.\n   [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n   [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n   [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n-  [librustc_const_eval](https://github.com/rust-lang/rust/blob/master/src/librustc_const_eval/diagnostics.rs),\n   [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n   [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n   [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),"}, {"sha": "ed46296389da4ba4f0ad96d6f5f83d3fca4183fe", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -63,7 +63,6 @@\n use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n use hir::map::DefPathHash;\n use hir::{HirId, ItemLocalId};\n-use mir;\n \n use ich::Fingerprint;\n use ty::{TyCtxt, Instance, InstanceDef, ParamEnv, ParamEnvAnd, PolyTraitRef, Ty};"}, {"sha": "d880b022e2f18c90c981882b70a6b79d69bac763", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -13,7 +13,6 @@ use hir::def_id::{CrateNum, DefId, DefIndex};\n use ty::{self, Ty, TyCtxt};\n use ty::maps::queries;\n use ty::subst::Substs;\n-use mir;\n \n use std::hash::Hash;\n use syntax_pos::symbol::InternedString;"}, {"sha": "53b8402ab2ad5e7927a2b3464498853e4fd7d11c", "filename": "src/librustc_const_eval/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"rustc_const_eval\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"rustc_const_eval\"\n-path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n-\n-[dependencies]\n-arena = { path = \"../libarena\" }\n-log = \"0.4\"\n-rustc = { path = \"../librustc\" }\n-rustc_const_math = { path = \"../librustc_const_math\" }\n-rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n-syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "d01b3c45f7fd1642603e3402008addf6085d6c5f", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 571, "changes": 571, "blob_url": "https://github.com/rust-lang/rust/blob/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918b6d763319863fb53c5b7bceebc14ad5fb4024/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=918b6d763319863fb53c5b7bceebc14ad5fb4024", "patch": "@@ -1,571 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(non_snake_case)]\n-\n-// Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80 characters.\n-// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-register_long_diagnostics! {\n-\n-E0001: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error suggests that the expression arm corresponding to the noted pattern\n-will never be reached as for all possible values of the expression being\n-matched, one of the preceding patterns will match.\n-\n-This means that perhaps some of the preceding patterns are too general, this\n-one is too specific or the ordering is incorrect.\n-\n-For example, the following `match` block has too many arms:\n-\n-```\n-match Some(0) {\n-    Some(bar) => {/* ... */}\n-    x => {/* ... */} // This handles the `None` case\n-    _ => {/* ... */} // All possible cases have already been handled\n-}\n-```\n-\n-`match` blocks have their patterns matched in order, so, for example, putting\n-a wildcard arm above a more specific arm will make the latter arm irrelevant.\n-\n-Ensure the ordering of the match arm is correct and remove any superfluous\n-arms.\n-\"##,\n-\n-E0002: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error indicates that an empty match expression is invalid because the type\n-it is matching on is non-empty (there exist values of this type). In safe code\n-it is impossible to create an instance of an empty type, so empty match\n-expressions are almost never desired. This error is typically fixed by adding\n-one or more cases to the match expression.\n-\n-An example of an empty type is `enum Empty { }`. So, the following will work:\n-\n-```\n-enum Empty {}\n-\n-fn foo(x: Empty) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\n-However, this won't:\n-\n-```compile_fail\n-fn foo(x: Option<String>) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\"##,\n-\n-E0003: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Not-a-Number (NaN) values cannot be compared for equality and hence can never\n-match the input to a match expression. So, the following will not compile:\n-\n-```compile_fail\n-const NAN: f32 = 0.0 / 0.0;\n-\n-let number = 0.1f32;\n-\n-match number {\n-    NAN => { /* ... */ },\n-    _ => {}\n-}\n-```\n-\n-To match against NaN values, you should instead use the `is_nan()` method in a\n-guard, like so:\n-\n-```\n-let number = 0.1f32;\n-\n-match number {\n-    x if x.is_nan() => { /* ... */ }\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0004: r##\"\n-This error indicates that the compiler cannot guarantee a matching pattern for\n-one or more possible inputs to a match expression. Guaranteed matches are\n-required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution. Erroneous code example:\n-\n-```compile_fail,E0004\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n-    Terminator::TalkToMyHand => {}\n-}\n-```\n-\n-If you encounter this error you must alter your patterns so that every possible\n-value of the input type is matched. For types with a small number of variants\n-(like enums) you should probably cover all cases explicitly. Alternatively, the\n-underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\". Example:\n-\n-```\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    Terminator::HastaLaVistaBaby => {}\n-}\n-\n-// or:\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases. Erroneous code example:\n-\n-```compile_fail,E0005\n-let x = Some(1);\n-let Some(y) = x;\n-// error: refutable pattern in local binding: `None` not covered\n-```\n-\n-If you encounter this error you probably need to use a `match` or `if let` to\n-deal with the possibility of failure. Example:\n-\n-```\n-let x = Some(1);\n-\n-match x {\n-    Some(y) => {\n-        // do something\n-    },\n-    None => {}\n-}\n-\n-// or:\n-\n-if let Some(y) = x {\n-    // do something\n-}\n-```\n-\"##,\n-\n-E0007: r##\"\n-This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code\n-like the following is invalid as it requires the entire `Option<String>` to be\n-moved into a variable called `op_string` while simultaneously requiring the\n-inner `String` to be moved into a variable called `s`.\n-\n-```compile_fail,E0007\n-let x = Some(\"s\".to_string());\n-\n-match x {\n-    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n-    None => {},\n-}\n-```\n-\n-See also the error E0303.\n-\"##,\n-\n-E0008: r##\"\n-Names bound in match arms retain their type in pattern guards. As such, if a\n-name is bound by move in a pattern, it should also be moved to wherever it is\n-referenced in the pattern guard code. Doing so however would prevent the name\n-from being available in the body of the match arm. Consider the following:\n-\n-```compile_fail,E0008\n-match Some(\"hi\".to_string()) {\n-    Some(s) if s.len() == 0 => {}, // use s.\n-    _ => {},\n-}\n-```\n-\n-The variable `s` has type `String`, and its use in the guard is as a variable of\n-type `String`. The guard code effectively executes in a separate scope to the\n-body of the arm, so the value would be moved into this anonymous scope and\n-therefore becomes unavailable in the body of the arm.\n-\n-The problem above can be solved by using the `ref` keyword.\n-\n-```\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) if s.len() == 0 => {},\n-    _ => {},\n-}\n-```\n-\n-Though this example seems innocuous and easy to solve, the problem becomes clear\n-when it encounters functions which consume the value:\n-\n-```compile_fail,E0008\n-struct A{}\n-\n-impl A {\n-    fn consume(self) -> usize {\n-        0\n-    }\n-}\n-\n-fn main() {\n-    let a = Some(A{});\n-    match a {\n-        Some(y) if y.consume() > 0 => {}\n-        _ => {}\n-    }\n-}\n-```\n-\n-In this situation, even the `ref` keyword cannot solve it, since borrowed\n-content cannot be moved. This problem cannot be solved generally. If the value\n-can be cloned, here is a not-so-specific solution:\n-\n-```\n-#[derive(Clone)]\n-struct A{}\n-\n-impl A {\n-    fn consume(self) -> usize {\n-        0\n-    }\n-}\n-\n-fn main() {\n-    let a = Some(A{});\n-    match a{\n-        Some(ref y) if y.clone().consume() > 0 => {}\n-        _ => {}\n-    }\n-}\n-```\n-\n-If the value will be consumed in the pattern guard, using its clone will not\n-move its ownership, so the code works.\n-\"##,\n-\n-E0009: r##\"\n-In a pattern, all values that don't implement the `Copy` trait have to be bound\n-the same way. The goal here is to avoid binding simultaneously by-move and\n-by-ref.\n-\n-This limitation may be removed in a future version of Rust.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0009\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n-                            //        same pattern\n-    None => panic!()\n-}\n-```\n-\n-You have two solutions:\n-\n-Solution #1: Bind the pattern's values the same way.\n-\n-```\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((ref y, ref z)) => {},\n-    // or Some((y, z)) => {}\n-    None => panic!()\n-}\n-```\n-\n-Solution #2: Implement the `Copy` trait for the `X` structure.\n-\n-However, please keep in mind that the first solution should be preferred.\n-\n-```\n-#[derive(Clone, Copy)]\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {},\n-    None => panic!()\n-}\n-```\n-\"##,\n-\n-E0158: r##\"\n-`const` and `static` mean different things. A `const` is a compile-time\n-constant, an alias for a literal value. This property means you can match it\n-directly within a pattern.\n-\n-The `static` keyword, on the other hand, guarantees a fixed location in memory.\n-This does not always mean that the value is constant. For example, a global\n-mutex can be declared `static` as well.\n-\n-If you want to match against a `static`, consider using a guard instead:\n-\n-```\n-static FORTY_TWO: i32 = 42;\n-\n-match Some(42) {\n-    Some(x) if x == FORTY_TWO => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0162: r##\"\n-An if-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding instead. For instance:\n-\n-```compile_fail,E0162\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-if let Irrefutable(x) = irr {\n-    // This body will always be executed.\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-let Irrefutable(x) = irr;\n-println!(\"{}\", x);\n-```\n-\"##,\n-\n-E0165: r##\"\n-A while-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding inside a `loop` instead. For instance:\n-\n-```compile_fail,E0165\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-while let Irrefutable(x) = irr {\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```no_run\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-loop {\n-    let Irrefutable(x) = irr;\n-    // ...\n-}\n-```\n-\"##,\n-\n-E0170: r##\"\n-Enum variants are qualified by default. For example, given this type:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-```\n-\n-You would match it using:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-\n-let m = Method::GET;\n-\n-match m {\n-    Method::GET => {},\n-    Method::POST => {},\n-}\n-```\n-\n-If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n-that happens.\n-\n-Qualified names are good practice, and most code works well with them. But if\n-you prefer them unqualified, you can import the variants into scope:\n-\n-```\n-use Method::*;\n-enum Method { GET, POST }\n-# fn main() {}\n-```\n-\n-If you want others to be able to import variants from your module directly, use\n-`pub use`:\n-\n-```\n-pub use Method::*;\n-pub enum Method { GET, POST }\n-# fn main() {}\n-```\n-\"##,\n-\n-\n-E0297: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Patterns used to bind names must be irrefutable. That is, they must guarantee\n-that a name will be extracted in all cases. Instead of pattern matching the\n-loop variable, consider using a `match` or `if let` inside the loop body. For\n-instance:\n-\n-```compile_fail,E0005\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-// This fails because `None` is not covered.\n-for Some(x) in xs {\n-    // ...\n-}\n-```\n-\n-Match inside the loop instead:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    match item {\n-        Some(x) => {},\n-        None => {},\n-    }\n-}\n-```\n-\n-Or use `if let`:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    if let Some(x) = item {\n-        // ...\n-    }\n-}\n-```\n-\"##,\n-\n-E0301: r##\"\n-Mutable borrows are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if mutable\n-borrows were allowed:\n-\n-```compile_fail,E0301\n-match Some(()) {\n-    None => { },\n-    option if option.take().is_none() => {\n-        /* impossible, option is `Some` */\n-    },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0302: r##\"\n-Assignments are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if assignments\n-were allowed:\n-\n-```compile_fail,E0302\n-match Some(()) {\n-    None => { },\n-    option if { option = None; false } => { },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0303: r##\"\n-In certain cases it is possible for sub-bindings to violate memory safety.\n-Updates to the borrow checker in a future version of Rust may remove this\n-restriction, but for now patterns must be rewritten without sub-bindings.\n-\n-Before:\n-\n-```compile_fail,E0303\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(s) => {},\n-    None => {},\n-}\n-```\n-\n-After:\n-\n-```\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) => {\n-        let op_string_ref = &Some(s);\n-        // ...\n-    },\n-    None => {},\n-}\n-```\n-\n-The `op_string_ref` binding has type `&Option<&String>` in both cases.\n-\n-See also https://github.com/rust-lang/rust/issues/14587\n-\"##,\n-\n-}\n-\n-\n-register_diagnostics! {\n-//  E0298, // cannot compare constants\n-//  E0299, // mismatched types between arms\n-//  E0471, // constant evaluation error (in pattern)\n-}"}, {"sha": "6a1d9e5653428ff1f05ac6bb8ce1dd9920a0b740", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -17,7 +17,6 @@ rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_borrowck = { path = \"../librustc_borrowck\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }"}, {"sha": "54457eacbf2e685e412665f6ca0035faadc09407", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -37,7 +37,7 @@ use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_passes::{self, ast_validation, loops, consts, hir_stats};\n-use rustc_const_eval::{self, check_match};\n+use rustc_mir::const_eval::check_match;\n use super::Compilation;\n \n use serialize::json;\n@@ -942,7 +942,6 @@ pub fn default_provide(providers: &mut ty::maps::Providers) {\n     ty::provide(providers);\n     traits::provide(providers);\n     reachable::provide(providers);\n-    rustc_const_eval::provide(providers);\n     rustc_passes::provide(providers);\n     middle::region::provide(providers);\n     cstore::provide(providers);"}, {"sha": "4953b85f994b3be391af2104eadd8cb58d6b6326", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -35,7 +35,6 @@ extern crate rustc;\n extern crate rustc_allocator;\n extern crate rustc_back;\n extern crate rustc_borrowck;\n-extern crate rustc_const_eval;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_passes;\n@@ -1566,7 +1565,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     // FIXME: need to figure out a way to get these back in here\n     // all_errors.extend_from_slice(get_trans(sess).diagnostics());\n     all_errors.extend_from_slice(&rustc_trans_utils::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);"}, {"sha": "5ff891202dbc5b79d10c0a652ef32facd047ec49", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -12,6 +12,6 @@ test = false\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_mir = { path = \"../librustc_mir\"}\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "79f3ff9f19f65d0386ef19809b74d8a001e38a5a", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -39,7 +39,7 @@ extern crate syntax;\n extern crate rustc;\n #[macro_use]\n extern crate log;\n-extern crate rustc_const_eval;\n+extern crate rustc_mir;\n extern crate syntax_pos;\n \n use rustc::lint;"}, {"sha": "926aa2a724125d3019644abef5bcc1ed32019d7e", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -15,7 +15,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf};\n use middle::const_val::ConstVal;\n-use rustc_const_eval::ConstContext;\n+use rustc_mir::const_eval::ConstContext;\n use rustc::mir::interpret::{Value, PrimVal};\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};"}, {"sha": "90a0f18aba367040be8687c674d86124d6816435", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -9,13 +9,13 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+arena = { path = \"../libarena\" }\n bitflags = \"1.0\"\n graphviz = { path = \"../libgraphviz\" }\n log = \"0.4\"\n log_settings = \"0.1.1\"\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "0f4d1e5bb0eca2f1f293949b6346f727d86c675a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeMap;\n use rustc_back::PanicStrategy;\n-use rustc_const_eval::pattern::{BindingMode, PatternKind};\n+use const_eval::pattern::{BindingMode, PatternKind};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use shim;\n use std::mem;"}, {"sha": "9ebbc11162812ed5371a12d9f3bb9f25b2cba561", "filename": "src/librustc_mir/const_eval/_match.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2F_match.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -13,15 +13,15 @@ use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n use rustc::middle::const_val::ConstVal;\n-use eval::{compare_const_vals};\n+use const_eval::eval::{compare_const_vals};\n \n use rustc_const_math::ConstInt;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n-use pattern::{FieldPattern, Pattern, PatternKind};\n-use pattern::{PatternFoldable, PatternFolder};\n+use const_eval::pattern::{FieldPattern, Pattern, PatternKind};\n+use const_eval::pattern::{PatternFoldable, PatternFolder};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;", "previous_filename": "src/librustc_const_eval/_match.rs"}, {"sha": "3621d80df1de486b8a470f6f3faf50ac3e06ed7b", "filename": "src/librustc_mir/const_eval/check_match.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fcheck_match.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use _match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n-use _match::Usefulness::*;\n-use _match::WitnessPreference::*;\n+use const_eval::_match::{MatchCheckCtxt, Matrix, expand_pattern, is_useful};\n+use const_eval::_match::Usefulness::*;\n+use const_eval::_match::WitnessPreference::*;\n \n-use pattern::{Pattern, PatternContext, PatternError, PatternKind};\n+use const_eval::pattern::{Pattern, PatternContext, PatternError, PatternKind};\n \n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};", "previous_filename": "src/librustc_const_eval/check_match.rs"}, {"sha": "58fe40d12be849f467d10d369837f8dfd1fe9eaf", "filename": "src/librustc_mir/const_eval/eval.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "previous_filename": "src/librustc_const_eval/eval.rs"}, {"sha": "27356c2b0821f05b13c0c5b4a3208db711b6eee3", "filename": "src/librustc_mir/const_eval/mod.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmod.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! constant evaluation on the HIR and code to validate patterns/matches\n+\n+mod eval;\n+mod _match;\n+pub mod check_match;\n+pub mod pattern;\n+\n+pub use self::eval::*;"}, {"sha": "a1109dbfdd1e09bb9d87d2a1c69769efa3ece612", "filename": "src/librustc_mir/const_eval/pattern.rs", "status": "renamed", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fpattern.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use eval;\n+use const_eval::eval;\n+use interpret::{const_val_field, const_discr};\n \n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ConstAggregate};\n use rustc::mir::{Field, BorrowKind, Mutability};\n@@ -693,7 +694,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             return match expr.node {\n                 hir::ExprLit(ref lit) => {\n                     let ty = self.tables.expr_ty(expr);\n-                    match ::eval::lit_to_const(&lit.node, self.tcx, ty, false) {\n+                    match super::eval::lit_to_const(&lit.node, self.tcx, ty, false) {\n                         Ok(value) => PatternKind::Constant {\n                             value: self.tcx.mk_const(ty::Const {\n                                 ty,\n@@ -716,7 +717,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         hir::ExprLit(ref lit) => lit,\n                         _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n                     };\n-                    match ::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n+                    match super::eval::lit_to_const(&lit.node, self.tcx, ty, true) {\n                         Ok(value) => PatternKind::Constant {\n                             value: self.tcx.mk_const(ty::Const {\n                                 ty,\n@@ -782,9 +783,9 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n                 match cv.val {\n                     ConstVal::Value(val) => {\n-                        let discr = self.tcx.const_discr(self.param_env.and((\n-                            instance, val, cv.ty\n-                        ))).unwrap();\n+                        let discr = const_discr(\n+                            self.tcx, self.param_env, instance, val, cv.ty\n+                        ).unwrap();\n                         let variant_index = adt_def\n                             .discriminants(self.tcx)\n                             .position(|var| var.to_u128_unchecked() == discr)\n@@ -801,8 +802,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 .map(|(i, _)| {\n                                 let field = Field::new(i);\n                                 let val = match cv.val {\n-                                    ConstVal::Value(miri) => self.tcx.const_val_field(\n-                                        self.param_env.and((instance, field, miri, cv.ty)),\n+                                    ConstVal::Value(miri) => const_val_field(\n+                                        self.tcx, self.param_env, instance, field, miri, cv.ty,\n                                     ).unwrap(),\n                                     _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                                 };\n@@ -844,8 +845,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                             ConstVal::Aggregate(ConstAggregate::Struct(consts)) => {\n                                 consts.iter().find(|&&(name, _)| name == f.name).unwrap().1\n                             },\n-                            ConstVal::Value(miri) => self.tcx.const_val_field(\n-                                self.param_env.and((instance, field, miri, cv.ty)),\n+                            ConstVal::Value(miri) => const_val_field(\n+                                self.tcx, self.param_env, instance, field, miri, cv.ty,\n                             ).unwrap(),\n                             _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                         };\n@@ -862,8 +863,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         let field = Field::new(i);\n                         let val = match cv.val {\n                             ConstVal::Aggregate(ConstAggregate::Tuple(consts)) => consts[i],\n-                            ConstVal::Value(miri) => self.tcx.const_val_field(\n-                                self.param_env.and((instance, field, miri, cv.ty)),\n+                            ConstVal::Value(miri) => const_val_field(\n+                                self.tcx, self.param_env, instance, field, miri, cv.ty,\n                             ).unwrap(),\n                             _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                         };\n@@ -882,8 +883,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         let val = match cv.val {\n                             ConstVal::Aggregate(ConstAggregate::Array(consts)) => consts[i],\n                             ConstVal::Aggregate(ConstAggregate::Repeat(cv, _)) => cv,\n-                            ConstVal::Value(miri) => self.tcx.const_val_field(\n-                                self.param_env.and((instance, field, miri, cv.ty)),\n+                            ConstVal::Value(miri) => const_val_field(\n+                                self.tcx, self.param_env, instance, field, miri, cv.ty,\n                             ).unwrap(),\n                             _ => bug!(\"{:#?} is not a valid tuple\", cv),\n                         };", "previous_filename": "src/librustc_const_eval/pattern.rs"}, {"sha": "d71298fb1a6f5ec77b131093b95bccf36e4d5b92", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 550, "deletions": 0, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -12,6 +12,553 @@\n \n register_long_diagnostics! {\n \n+\n+E0001: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error suggests that the expression arm corresponding to the noted pattern\n+will never be reached as for all possible values of the expression being\n+matched, one of the preceding patterns will match.\n+\n+This means that perhaps some of the preceding patterns are too general, this\n+one is too specific or the ordering is incorrect.\n+\n+For example, the following `match` block has too many arms:\n+\n+```\n+match Some(0) {\n+    Some(bar) => {/* ... */}\n+    x => {/* ... */} // This handles the `None` case\n+    _ => {/* ... */} // All possible cases have already been handled\n+}\n+```\n+\n+`match` blocks have their patterns matched in order, so, for example, putting\n+a wildcard arm above a more specific arm will make the latter arm irrelevant.\n+\n+Ensure the ordering of the match arm is correct and remove any superfluous\n+arms.\n+\"##,\n+\n+E0002: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+This error indicates that an empty match expression is invalid because the type\n+it is matching on is non-empty (there exist values of this type). In safe code\n+it is impossible to create an instance of an empty type, so empty match\n+expressions are almost never desired. This error is typically fixed by adding\n+one or more cases to the match expression.\n+\n+An example of an empty type is `enum Empty { }`. So, the following will work:\n+\n+```\n+enum Empty {}\n+\n+fn foo(x: Empty) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\n+However, this won't:\n+\n+```compile_fail\n+fn foo(x: Option<String>) {\n+    match x {\n+        // empty\n+    }\n+}\n+```\n+\"##,\n+\n+E0003: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Not-a-Number (NaN) values cannot be compared for equality and hence can never\n+match the input to a match expression. So, the following will not compile:\n+\n+```compile_fail\n+const NAN: f32 = 0.0 / 0.0;\n+\n+let number = 0.1f32;\n+\n+match number {\n+    NAN => { /* ... */ },\n+    _ => {}\n+}\n+```\n+\n+To match against NaN values, you should instead use the `is_nan()` method in a\n+guard, like so:\n+\n+```\n+let number = 0.1f32;\n+\n+match number {\n+    x if x.is_nan() => { /* ... */ }\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0004: r##\"\n+This error indicates that the compiler cannot guarantee a matching pattern for\n+one or more possible inputs to a match expression. Guaranteed matches are\n+required in order to assign values to match expressions, or alternatively,\n+determine the flow of execution. Erroneous code example:\n+\n+```compile_fail,E0004\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n+    Terminator::TalkToMyHand => {}\n+}\n+```\n+\n+If you encounter this error you must alter your patterns so that every possible\n+value of the input type is matched. For types with a small number of variants\n+(like enums) you should probably cover all cases explicitly. Alternatively, the\n+underscore `_` wildcard pattern can be added after all other patterns to match\n+\"anything else\". Example:\n+\n+```\n+enum Terminator {\n+    HastaLaVistaBaby,\n+    TalkToMyHand,\n+}\n+\n+let x = Terminator::HastaLaVistaBaby;\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    Terminator::HastaLaVistaBaby => {}\n+}\n+\n+// or:\n+\n+match x {\n+    Terminator::TalkToMyHand => {}\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0005: r##\"\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. Erroneous code example:\n+\n+```compile_fail,E0005\n+let x = Some(1);\n+let Some(y) = x;\n+// error: refutable pattern in local binding: `None` not covered\n+```\n+\n+If you encounter this error you probably need to use a `match` or `if let` to\n+deal with the possibility of failure. Example:\n+\n+```\n+let x = Some(1);\n+\n+match x {\n+    Some(y) => {\n+        // do something\n+    },\n+    None => {}\n+}\n+\n+// or:\n+\n+if let Some(y) = x {\n+    // do something\n+}\n+```\n+\"##,\n+\n+E0007: r##\"\n+This error indicates that the bindings in a match arm would require a value to\n+be moved into more than one location, thus violating unique ownership. Code\n+like the following is invalid as it requires the entire `Option<String>` to be\n+moved into a variable called `op_string` while simultaneously requiring the\n+inner `String` to be moved into a variable called `s`.\n+\n+```compile_fail,E0007\n+let x = Some(\"s\".to_string());\n+\n+match x {\n+    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n+    None => {},\n+}\n+```\n+\n+See also the error E0303.\n+\"##,\n+\n+E0008: r##\"\n+Names bound in match arms retain their type in pattern guards. As such, if a\n+name is bound by move in a pattern, it should also be moved to wherever it is\n+referenced in the pattern guard code. Doing so however would prevent the name\n+from being available in the body of the match arm. Consider the following:\n+\n+```compile_fail,E0008\n+match Some(\"hi\".to_string()) {\n+    Some(s) if s.len() == 0 => {}, // use s.\n+    _ => {},\n+}\n+```\n+\n+The variable `s` has type `String`, and its use in the guard is as a variable of\n+type `String`. The guard code effectively executes in a separate scope to the\n+body of the arm, so the value would be moved into this anonymous scope and\n+therefore becomes unavailable in the body of the arm.\n+\n+The problem above can be solved by using the `ref` keyword.\n+\n+```\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) if s.len() == 0 => {},\n+    _ => {},\n+}\n+```\n+\n+Though this example seems innocuous and easy to solve, the problem becomes clear\n+when it encounters functions which consume the value:\n+\n+```compile_fail,E0008\n+struct A{}\n+\n+impl A {\n+    fn consume(self) -> usize {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let a = Some(A{});\n+    match a {\n+        Some(y) if y.consume() > 0 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+In this situation, even the `ref` keyword cannot solve it, since borrowed\n+content cannot be moved. This problem cannot be solved generally. If the value\n+can be cloned, here is a not-so-specific solution:\n+\n+```\n+#[derive(Clone)]\n+struct A{}\n+\n+impl A {\n+    fn consume(self) -> usize {\n+        0\n+    }\n+}\n+\n+fn main() {\n+    let a = Some(A{});\n+    match a{\n+        Some(ref y) if y.clone().consume() > 0 => {}\n+        _ => {}\n+    }\n+}\n+```\n+\n+If the value will be consumed in the pattern guard, using its clone will not\n+move its ownership, so the code works.\n+\"##,\n+\n+E0009: r##\"\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0009\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n+                            //        same pattern\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+\n+Solution #1: Bind the pattern's values the same way.\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+Solution #2: Implement the `Copy` trait for the `X` structure.\n+\n+However, please keep in mind that the first solution should be preferred.\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\"##,\n+\n+E0158: r##\"\n+`const` and `static` mean different things. A `const` is a compile-time\n+constant, an alias for a literal value. This property means you can match it\n+directly within a pattern.\n+\n+The `static` keyword, on the other hand, guarantees a fixed location in memory.\n+This does not always mean that the value is constant. For example, a global\n+mutex can be declared `static` as well.\n+\n+If you want to match against a `static`, consider using a guard instead:\n+\n+```\n+static FORTY_TWO: i32 = 42;\n+\n+match Some(42) {\n+    Some(x) if x == FORTY_TWO => {}\n+    _ => {}\n+}\n+```\n+\"##,\n+\n+E0162: r##\"\n+An if-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding instead. For instance:\n+\n+```compile_fail,E0162\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+if let Irrefutable(x) = irr {\n+    // This body will always be executed.\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+let Irrefutable(x) = irr;\n+println!(\"{}\", x);\n+```\n+\"##,\n+\n+E0165: r##\"\n+A while-let pattern attempts to match the pattern, and enters the body if the\n+match was successful. If the match is irrefutable (when it cannot fail to\n+match), use a regular `let`-binding inside a `loop` instead. For instance:\n+\n+```compile_fail,E0165\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+// This fails to compile because the match is irrefutable.\n+while let Irrefutable(x) = irr {\n+    // ...\n+}\n+```\n+\n+Try this instead:\n+\n+```no_run\n+struct Irrefutable(i32);\n+let irr = Irrefutable(0);\n+\n+loop {\n+    let Irrefutable(x) = irr;\n+    // ...\n+}\n+```\n+\"##,\n+\n+E0170: r##\"\n+Enum variants are qualified by default. For example, given this type:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+```\n+\n+You would match it using:\n+\n+```\n+enum Method {\n+    GET,\n+    POST,\n+}\n+\n+let m = Method::GET;\n+\n+match m {\n+    Method::GET => {},\n+    Method::POST => {},\n+}\n+```\n+\n+If you don't qualify the names, the code will bind new variables named \"GET\" and\n+\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n+that happens.\n+\n+Qualified names are good practice, and most code works well with them. But if\n+you prefer them unqualified, you can import the variants into scope:\n+\n+```\n+use Method::*;\n+enum Method { GET, POST }\n+# fn main() {}\n+```\n+\n+If you want others to be able to import variants from your module directly, use\n+`pub use`:\n+\n+```\n+pub use Method::*;\n+pub enum Method { GET, POST }\n+# fn main() {}\n+```\n+\"##,\n+\n+\n+E0297: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+Patterns used to bind names must be irrefutable. That is, they must guarantee\n+that a name will be extracted in all cases. Instead of pattern matching the\n+loop variable, consider using a `match` or `if let` inside the loop body. For\n+instance:\n+\n+```compile_fail,E0005\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+// This fails because `None` is not covered.\n+for Some(x) in xs {\n+    // ...\n+}\n+```\n+\n+Match inside the loop instead:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    match item {\n+        Some(x) => {},\n+        None => {},\n+    }\n+}\n+```\n+\n+Or use `if let`:\n+\n+```\n+let xs : Vec<Option<i32>> = vec![Some(1), None];\n+\n+for item in xs {\n+    if let Some(x) = item {\n+        // ...\n+    }\n+}\n+```\n+\"##,\n+\n+E0301: r##\"\n+Mutable borrows are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if mutable\n+borrows were allowed:\n+\n+```compile_fail,E0301\n+match Some(()) {\n+    None => { },\n+    option if option.take().is_none() => {\n+        /* impossible, option is `Some` */\n+    },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```\n+\"##,\n+\n+E0302: r##\"\n+Assignments are not allowed in pattern guards, because matching cannot have\n+side effects. Side effects could alter the matched object or the environment\n+on which the match depends in such a way, that the match would not be\n+exhaustive. For instance, the following would not match any arm if assignments\n+were allowed:\n+\n+```compile_fail,E0302\n+match Some(()) {\n+    None => { },\n+    option if { option = None; false } => { },\n+    Some(_) => { } // When the previous match failed, the option became `None`.\n+}\n+```\n+\"##,\n+\n+E0303: r##\"\n+In certain cases it is possible for sub-bindings to violate memory safety.\n+Updates to the borrow checker in a future version of Rust may remove this\n+restriction, but for now patterns must be rewritten without sub-bindings.\n+\n+Before:\n+\n+```compile_fail,E0303\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(s) => {},\n+    None => {},\n+}\n+```\n+\n+After:\n+\n+```\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(s);\n+        // ...\n+    },\n+    None => {},\n+}\n+```\n+\n+The `op_string_ref` binding has type `&Option<&String>` in both cases.\n+\n+See also https://github.com/rust-lang/rust/issues/14587\n+\"##,\n+\n E0010: r##\"\n The value of statics and constants must be known at compile time, and they live\n for the entire lifetime of a program. Creating a boxed value allocates memory on\n@@ -1771,6 +2318,9 @@ b.resume();\n }\n \n register_diagnostics! {\n+//  E0298, // cannot compare constants\n+//  E0299, // mismatched types between arms\n+//  E0471, // constant evaluation error (in pattern)\n //    E0385, // {} in an aliasable location\n     E0493, // destructors cannot be evaluated at compile-time\n     E0524, // two closures require unique access to `..` at the same time"}, {"sha": "329365c4415e8631c9e85e1bb86a8e821dd35caf", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -27,7 +27,7 @@ use self::cx::Cx;\n \n pub mod cx;\n \n-pub use rustc_const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n+pub use const_eval::pattern::{BindingMode, Pattern, PatternKind, FieldPattern};\n \n #[derive(Copy, Clone, Debug)]\n pub enum LintLevel {"}, {"sha": "f5408c73818596628325817ff663e1899499f663", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::middle::const_val::ErrKind::{CheckMatchError, TypeckError};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal};\n-use rustc_const_eval::{lookup_const_by_id, ConstContext};\n+use const_eval::{lookup_const_by_id, ConstContext};\n use rustc::mir::Field;\n use rustc_data_structures::indexed_vec::Idx;\n \n@@ -306,28 +306,34 @@ impl<'tcx> super::Machine<'tcx> for CompileTimeEvaluator {\n \n pub fn const_val_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, mir::Field, Value, Ty<'tcx>)>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    field: mir::Field,\n+    val: Value,\n+    ty: Ty<'tcx>,\n ) -> ::rustc::middle::const_val::EvalResult<'tcx> {\n-    trace!(\"const_val_field: {:#?}\", key);\n-    match const_val_field_inner(tcx, key) {\n+    match const_val_field_inner(tcx, param_env, instance, field, val, ty) {\n         Ok((field, ty)) => Ok(tcx.mk_const(ty::Const {\n             val: ConstVal::Value(field),\n             ty,\n         })),\n         Err(err) => Err(ConstEvalErr {\n-            span: tcx.def_span(key.value.0.def_id()),\n+            span: tcx.def_span(instance.def_id()),\n             kind: err.into(),\n         }),\n     }\n }\n \n fn const_val_field_inner<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, mir::Field, Value, Ty<'tcx>)>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    field: mir::Field,\n+    value: Value,\n+    ty: Ty<'tcx>,\n ) -> ::rustc::mir::interpret::EvalResult<'tcx, (Value, Ty<'tcx>)> {\n-    trace!(\"const_val_field: {:#?}\", key);\n-    let (instance, field, value, ty) = key.value;\n-    let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n+    trace!(\"const_val_field: {:?}, {:?}, {:?}, {:?}\", instance, field, value, ty);\n+    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let (mut field, ty) = match value {\n         Value::ByValPair(..) | Value::ByVal(_) => ecx.read_field(value, field, ty)?.expect(\"const_val_field on non-field\"),\n         Value::ByRef(ptr, align) => {\n@@ -348,11 +354,13 @@ fn const_val_field_inner<'a, 'tcx>(\n \n pub fn const_discr<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    key: ty::ParamEnvAnd<'tcx, (ty::Instance<'tcx>, Value, Ty<'tcx>)>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    instance: ty::Instance<'tcx>,\n+    value: Value,\n+    ty: Ty<'tcx>,\n ) -> EvalResult<'tcx, u128> {\n-    trace!(\"const_discr: {:#?}\", key);\n-    let (instance, value, ty) = key.value;\n-    let mut ecx = mk_eval_cx(tcx, instance, key.param_env).unwrap();\n+    trace!(\"const_discr: {:?}, {:?}, {:?}\", instance, value, ty);\n+    let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let (ptr, align) = match value {\n         Value::ByValPair(..) | Value::ByVal(_) => {\n             let layout = ecx.layout_of(ty)?;"}, {"sha": "d25caa588faf1d94c1ac0069dedbfcc01b3d9c3e", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -16,6 +16,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![deny(warnings)]\n \n+#![feature(slice_patterns)]\n+#![feature(from_ref)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(catch_expr)]\n@@ -38,6 +40,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(nonzero)]\n #![feature(underscore_lifetimes)]\n \n+extern crate arena;\n #[macro_use]\n extern crate bitflags;\n #[macro_use] extern crate log;\n@@ -52,7 +55,6 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_back;\n extern crate rustc_const_math;\n-extern crate rustc_const_eval;\n extern crate core; // for NonZero\n extern crate log_settings;\n extern crate rustc_apfloat;\n@@ -69,6 +71,7 @@ pub mod transform;\n pub mod util;\n pub mod interpret;\n pub mod monomorphize;\n+pub mod const_eval;\n \n use rustc::ty::maps::Providers;\n \n@@ -77,6 +80,7 @@ pub fn provide(providers: &mut Providers) {\n     shim::provide(providers);\n     transform::provide(providers);\n     providers.const_eval = interpret::const_eval_provider;\n+    providers.check_match = const_eval::check_match::check_match;\n }\n \n __build_diagnostic_array! { librustc_mir, DIAGNOSTICS }"}, {"sha": "4bab24ae1392c1198fc1c8dba27ce64607ebfea6", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -11,7 +11,7 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n-rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_mir = { path = \"../librustc_mir\"}\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "420e8c4aad2c2401d07e5a7929fac6d794cead1f", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -25,7 +25,7 @@\n // by borrowck::gather_loans\n \n use rustc::ty::cast::CastKind;\n-use rustc_const_eval::ConstContext;\n+use rustc_mir::const_eval::ConstContext;\n use rustc::middle::const_val::ConstEvalErr;\n use rustc::middle::const_val::ErrKind::{IndexOpFeatureGated, UnimplementedConstVal, MiscCatchAll};\n use rustc::middle::const_val::ErrKind::{ErroneousReferencedConstant, MiscBinaryOp, NonConstPath};"}, {"sha": "a51bee9149951c88d33ceebfdc7fb0f70805e5bb", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e97089dae33d5b228bb1b50ae12e96b13ab499b3/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=e97089dae33d5b228bb1b50ae12e96b13ab499b3", "patch": "@@ -23,7 +23,7 @@\n \n #[macro_use]\n extern crate rustc;\n-extern crate rustc_const_eval;\n+extern crate rustc_mir;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n "}]}