{"sha": "f07ee8a998eff61977d594eeac44dc1d0ead7b02", "node_id": "C_kwDOAAsO6NoAKGYwN2VlOGE5OThlZmY2MTk3N2Q1OTRlZWFjNDRkYzFkMGVhZDdiMDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-21T20:42:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-21T20:42:51Z"}, "message": "Auto merge of #8232 - Jarcho:match_same_arm_860, r=xFrednet\n\n`match_same_arms` fix\n\nfixes #860\nfixes #1140\n\nchangelog: Don't lint `match_same_arms` when an interposing arm's pattern would overlap", "tree": {"sha": "d17e9b7df751c8b47538dc9a610863954fde5d73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d17e9b7df751c8b47538dc9a610863954fde5d73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f07ee8a998eff61977d594eeac44dc1d0ead7b02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f07ee8a998eff61977d594eeac44dc1d0ead7b02", "html_url": "https://github.com/rust-lang/rust/commit/f07ee8a998eff61977d594eeac44dc1d0ead7b02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f07ee8a998eff61977d594eeac44dc1d0ead7b02/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a07662d948bd831eba6a87b7acc080cbee88d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a07662d948bd831eba6a87b7acc080cbee88d4a", "html_url": "https://github.com/rust-lang/rust/commit/4a07662d948bd831eba6a87b7acc080cbee88d4a"}, {"sha": "773d20341ad8061df9acca781bab7a0fb38ed684", "url": "https://api.github.com/repos/rust-lang/rust/commits/773d20341ad8061df9acca781bab7a0fb38ed684", "html_url": "https://github.com/rust-lang/rust/commit/773d20341ad8061df9acca781bab7a0fb38ed684"}], "stats": {"total": 867, "additions": 618, "deletions": 249}, "files": [{"sha": "703aa458f44e5a074ac0cd3a1cc33b1573444223", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -637,12 +637,6 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 loop {\n                     match parser.parse_item(ForceCollect::No) {\n                         Ok(Some(item)) => match &item.kind {\n-                            // Tests with one of these items are ignored\n-                            ItemKind::Static(..)\n-                            | ItemKind::Const(..)\n-                            | ItemKind::ExternCrate(..)\n-                            | ItemKind::ForeignMod(..) => return false,\n-                            // We found a main function ...\n                             ItemKind::Fn(box Fn {\n                                 sig, body: Some(block), ..\n                             }) if item.ident.name == sym::main => {\n@@ -661,8 +655,13 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                                     return false;\n                                 }\n                             },\n-                            // Another function was found; this case is ignored too\n-                            ItemKind::Fn(..) => return false,\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..)\n+                            // Another function was found; this case is ignored\n+                            | ItemKind::Fn(..) => return false,\n                             _ => {},\n                         },\n                         Ok(None) => break,"}, {"sha": "f2a07999144482e48231ba3e4bf19edbf4d71d77", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -23,6 +23,7 @@\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n+extern crate rustc_arena;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;"}, {"sha": "b8591fe0db0ad31a3e94fc030f69310a3f137f7f", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 353, "deletions": 43, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -1,19 +1,66 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n-use rustc_hir::{Arm, Expr, HirId, HirIdMap, HirIdSet, Pat, PatKind};\n+use core::cmp::Ordering;\n+use core::iter;\n+use core::slice;\n+use rustc_arena::DroplessArena;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, Pat, PatKind, RangeEnd};\n use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::Symbol;\n use std::collections::hash_map::Entry;\n \n use super::MATCH_SAME_ARMS;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n     let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(arm.body);\n         h.finish()\n     };\n \n+    let arena = DroplessArena::default();\n+    let normalized_pats: Vec<_> = arms\n+        .iter()\n+        .map(|a| NormalizedPat::from_pat(cx, &arena, a.pat))\n+        .collect();\n+\n+    // The furthast forwards a pattern can move without semantic changes\n+    let forwards_blocking_idxs: Vec<_> = normalized_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            normalized_pats[i + 1..]\n+                .iter()\n+                .enumerate()\n+                .find_map(|(j, other)| pat.has_overlapping_values(other).then(|| i + 1 + j))\n+                .unwrap_or(normalized_pats.len())\n+        })\n+        .collect();\n+\n+    // The furthast backwards a pattern can move without semantic changes\n+    let backwards_blocking_idxs: Vec<_> = normalized_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            normalized_pats[..i]\n+                .iter()\n+                .enumerate()\n+                .rev()\n+                .zip(forwards_blocking_idxs[..i].iter().copied().rev())\n+                .skip_while(|&(_, forward_block)| forward_block > i)\n+                .find_map(|((j, other), forward_block)| {\n+                    (forward_block == i || pat.has_overlapping_values(other)).then(|| j)\n+                })\n+                .unwrap_or(0)\n+        })\n+        .collect();\n+\n     let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n         let min_index = usize::min(lindex, rindex);\n         let max_index = usize::max(lindex, rindex);\n@@ -42,53 +89,316 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n             }\n         };\n         // Arms with a guard are ignored, those can\u2019t always be merged together\n-        // This is also the case for arms in-between each there is an arm with a guard\n-        (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-            && SpanlessEq::new(cx)\n-                .expr_fallback(eq_fallback)\n-                .eq_expr(lhs.body, rhs.body)\n-            // these checks could be removed to allow unused bindings\n-            && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-            && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+        // If both arms overlap with an arm in between then these can't be merged either.\n+        !(backwards_blocking_idxs[max_index] > min_index && forwards_blocking_idxs[min_index] < max_index)\n+                && lhs.guard.is_none()\n+                && rhs.guard.is_none()\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n     };\n \n     let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-    for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-        span_lint_and_then(\n-            cx,\n-            MATCH_SAME_ARMS,\n-            j.body.span,\n-            \"this `match` has identical arm bodies\",\n-            |diag| {\n-                diag.span_note(i.body.span, \"same as this\");\n-\n-                // Note: this does not use `span_suggestion` on purpose:\n-                // there is no clean way\n-                // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                // makes an even more confusing error message. Also in order not to make up a\n-                // span for the whole pattern, the suggestion is only shown when there is only\n-                // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                if let PatKind::Wild = j.pat.kind {\n-                    // if the last arm is _, then i could be integrated into _\n-                    // note that i.pat cannot be _, because that would mean that we're\n-                    // hiding all the subsequent arms, and rust won't compile\n-                    diag.span_note(\n-                        i.body.span,\n-                        &format!(\n-                            \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                            lhs\n-                        ),\n-                    );\n+    for (&(i, arm1), &(j, arm2)) in search_same(&indexed_arms, hash, eq) {\n+        if matches!(arm2.pat.kind, PatKind::Wild) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                arm1.span,\n+                \"this match arm has an identical body to the `_` wildcard arm\",\n+                |diag| {\n+                    diag.span_suggestion(\n+                        arm1.span,\n+                        \"try removing the arm\",\n+                        String::new(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .help(\"or try changing either arm body\")\n+                    .span_note(arm2.span, \"`_` wildcard arm here\");\n+                },\n+            );\n+        } else {\n+            let back_block = backwards_blocking_idxs[j];\n+            let (keep_arm, move_arm) = if back_block < i || (back_block == 0 && forwards_blocking_idxs[i] <= j) {\n+                (arm1, arm2)\n+            } else {\n+                (arm2, arm1)\n+            };\n+\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                keep_arm.span,\n+                \"this match arm has an identical body to another arm\",\n+                |diag| {\n+                    let move_pat_snip = snippet(cx, move_arm.pat.span, \"<pat2>\");\n+                    let keep_pat_snip = snippet(cx, keep_arm.pat.span, \"<pat1>\");\n+\n+                    diag.span_suggestion(\n+                        keep_arm.pat.span,\n+                        \"try merging the arm patterns\",\n+                        format!(\"{} | {}\", keep_pat_snip, move_pat_snip),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .help(\"or try changing either arm body\")\n+                    .span_note(move_arm.span, \"other arm here\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum NormalizedPat<'a> {\n+    Wild,\n+    Struct(Option<DefId>, &'a [(Symbol, Self)]),\n+    Tuple(Option<DefId>, &'a [Self]),\n+    Or(&'a [Self]),\n+    Path(Option<DefId>),\n+    LitStr(Symbol),\n+    LitBytes(&'a [u8]),\n+    LitInt(u128),\n+    LitBool(bool),\n+    Range(PatRange),\n+    /// A slice pattern. If the second value is `None`, then this matches an exact size. Otherwise\n+    /// the first value contains everything before the `..` wildcard pattern, and the second value\n+    /// contains everything afterwards. Note that either side, or both sides, may contain zero\n+    /// patterns.\n+    Slice(&'a [Self], Option<&'a [Self]>),\n+}\n+\n+#[derive(Clone, Copy)]\n+struct PatRange {\n+    start: u128,\n+    end: u128,\n+    bounds: RangeEnd,\n+}\n+impl PatRange {\n+    fn contains(&self, x: u128) -> bool {\n+        x >= self.start\n+            && match self.bounds {\n+                RangeEnd::Included => x <= self.end,\n+                RangeEnd::Excluded => x < self.end,\n+            }\n+    }\n+\n+    fn overlaps(&self, other: &Self) -> bool {\n+        // Note: Empty ranges are impossible, so this is correct even though it would return true if an\n+        // empty exclusive range were to reside within an inclusive range.\n+        (match self.bounds {\n+            RangeEnd::Included => self.end >= other.start,\n+            RangeEnd::Excluded => self.end > other.start,\n+        } && match other.bounds {\n+            RangeEnd::Included => self.start <= other.end,\n+            RangeEnd::Excluded => self.start < other.end,\n+        })\n+    }\n+}\n+\n+/// Iterates over the pairs of fields with matching names.\n+fn iter_matching_struct_fields<'a>(\n+    left: &'a [(Symbol, NormalizedPat<'a>)],\n+    right: &'a [(Symbol, NormalizedPat<'a>)],\n+) -> impl Iterator<Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>)> + 'a {\n+    struct Iter<'a>(\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+    );\n+    impl<'a> Iterator for Iter<'a> {\n+        type Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>);\n+        fn next(&mut self) -> Option<Self::Item> {\n+            // Note: all the fields in each slice are sorted by symbol value.\n+            let mut left = self.0.next()?;\n+            let mut right = self.1.next()?;\n+            loop {\n+                match left.0.cmp(&right.0) {\n+                    Ordering::Equal => return Some((&left.1, &right.1)),\n+                    Ordering::Less => left = self.0.next()?,\n+                    Ordering::Greater => right = self.1.next()?,\n+                }\n+            }\n+        }\n+    }\n+    Iter(left.iter(), right.iter())\n+}\n+\n+#[allow(clippy::similar_names)]\n+impl<'a> NormalizedPat<'a> {\n+    #[allow(clippy::too_many_lines)]\n+    fn from_pat(cx: &LateContext<'_>, arena: &'a DroplessArena, pat: &'a Pat<'_>) -> Self {\n+        match pat.kind {\n+            PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n+            PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => {\n+                Self::from_pat(cx, arena, pat)\n+            },\n+            PatKind::Struct(ref path, fields, _) => {\n+                let fields =\n+                    arena.alloc_from_iter(fields.iter().map(|f| (f.ident.name, Self::from_pat(cx, arena, f.pat))));\n+                fields.sort_by_key(|&(name, _)| name);\n+                Self::Struct(cx.qpath_res(path, pat.hir_id).opt_def_id(), fields)\n+            },\n+            PatKind::TupleStruct(ref path, pats, wild_idx) => {\n+                let adt = match cx.typeck_results().pat_ty(pat).ty_adt_def() {\n+                    Some(x) => x,\n+                    None => return Self::Wild,\n+                };\n+                let (var_id, variant) = if adt.is_enum() {\n+                    match cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        Some(x) => (Some(x), adt.variant_with_ctor_id(x)),\n+                        None => return Self::Wild,\n+                    }\n                 } else {\n-                    diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                        .help(\"...or consider changing the match arm bodies\");\n+                    (None, adt.non_enum_variant())\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(variant.fields.len() - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(var_id, pats)\n+            },\n+            PatKind::Or(pats) => Self::Or(arena.alloc_from_iter(pats.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n+            PatKind::Path(ref path) => Self::Path(cx.qpath_res(path, pat.hir_id).opt_def_id()),\n+            PatKind::Tuple(pats, wild_idx) => {\n+                let field_count = match cx.typeck_results().pat_ty(pat).kind() {\n+                    ty::Tuple(subs) => subs.len(),\n+                    _ => return Self::Wild,\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(field_count - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(None, pats)\n+            },\n+            PatKind::Lit(e) => match &e.kind {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n+                ExprKind::Lit(lit) => match lit.node {\n+                    LitKind::Str(sym, _) => Self::LitStr(sym),\n+                    LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n+                    LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::Char(val) => Self::LitInt(val.into()),\n+                    LitKind::Int(val, _) => Self::LitInt(val),\n+                    LitKind::Bool(val) => Self::LitBool(val),\n+                    LitKind::Float(..) | LitKind::Err(_) => Self::Wild,\n+                },\n+                _ => Self::Wild,\n+            },\n+            PatKind::Range(start, end, bounds) => {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n+                let start = match start {\n+                    None => 0,\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => val,\n+                            LitKind::Char(val) => val.into(),\n+                            LitKind::Byte(val) => val.into(),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                let (end, bounds) = match end {\n+                    None => (u128::MAX, RangeEnd::Included),\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => (val, bounds),\n+                            LitKind::Char(val) => (val.into(), bounds),\n+                            LitKind::Byte(val) => (val.into(), bounds),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                Self::Range(PatRange { start, end, bounds })\n+            },\n+            PatKind::Slice(front, wild_pat, back) => Self::Slice(\n+                arena.alloc_from_iter(front.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                wild_pat.map(|_| &*arena.alloc_from_iter(back.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n+            ),\n+        }\n+    }\n+\n+    /// Checks if two patterns overlap in the values they can match assuming they are for the same\n+    /// type.\n+    fn has_overlapping_values(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (Self::Wild, _) | (_, Self::Wild) => true,\n+            (Self::Or(pats), ref other) | (ref other, Self::Or(pats)) => {\n+                pats.iter().any(|pat| pat.has_overlapping_values(other))\n+            },\n+            (Self::Struct(lpath, lfields), Self::Struct(rpath, rfields)) => {\n+                if lpath != rpath {\n+                    return false;\n+                }\n+                iter_matching_struct_fields(lfields, rfields).all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n+            },\n+            (Self::Tuple(lpath, lpats), Self::Tuple(rpath, rpats)) => {\n+                if lpath != rpath {\n+                    return false;\n                 }\n+                lpats\n+                    .iter()\n+                    .zip(rpats.iter())\n+                    .all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n+            },\n+            (Self::Path(x), Self::Path(y)) => x == y,\n+            (Self::LitStr(x), Self::LitStr(y)) => x == y,\n+            (Self::LitBytes(x), Self::LitBytes(y)) => x == y,\n+            (Self::LitInt(x), Self::LitInt(y)) => x == y,\n+            (Self::LitBool(x), Self::LitBool(y)) => x == y,\n+            (Self::Range(ref x), Self::Range(ref y)) => x.overlaps(y),\n+            (Self::Range(ref range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(ref range)) => range.contains(x),\n+            (Self::Slice(lpats, None), Self::Slice(rpats, None)) => {\n+                lpats.len() == rpats.len() && lpats.iter().zip(rpats.iter()).all(|(x, y)| x.has_overlapping_values(y))\n             },\n-        );\n+            (Self::Slice(pats, None), Self::Slice(front, Some(back)))\n+            | (Self::Slice(front, Some(back)), Self::Slice(pats, None)) => {\n+                // Here `pats` is an exact size match. If the combined lengths of `front` and `back` are greater\n+                // then the minium length required will be greater than the length of `pats`.\n+                if pats.len() < front.len() + back.len() {\n+                    return false;\n+                }\n+                pats[..front.len()]\n+                    .iter()\n+                    .zip(front.iter())\n+                    .chain(pats[pats.len() - back.len()..].iter().zip(back.iter()))\n+                    .all(|(x, y)| x.has_overlapping_values(y))\n+            },\n+            (Self::Slice(lfront, Some(lback)), Self::Slice(rfront, Some(rback))) => lfront\n+                .iter()\n+                .zip(rfront.iter())\n+                .chain(lback.iter().rev().zip(rback.iter().rev()))\n+                .all(|(x, y)| x.has_overlapping_values(y)),\n+\n+            // Enums can mix unit variants with tuple/struct variants. These can never overlap.\n+            (Self::Path(_), Self::Tuple(..) | Self::Struct(..))\n+            | (Self::Tuple(..) | Self::Struct(..), Self::Path(_)) => false,\n+\n+            // Tuples can be matched like a struct.\n+            (Self::Tuple(x, _), Self::Struct(y, _)) | (Self::Struct(x, _), Self::Tuple(y, _)) => {\n+                // TODO: check fields here.\n+                x == y\n+            },\n+\n+            // TODO: Lit* with Path, Range with Path, LitBytes with Slice\n+            _ => true,\n+        }\n     }\n }\n "}, {"sha": "f3d818cc3485dd0c617da2a3591418a2b39b032a", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -581,14 +581,19 @@ impl Write {\n             };\n \n             let replacement: String = match lit.token.kind {\n-                LitKind::Integer | LitKind::Float | LitKind::Err => continue,\n                 LitKind::StrRaw(_) | LitKind::ByteStrRaw(_) if matches!(fmtstr.style, StrStyle::Raw(_)) => {\n                     lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n                 LitKind::Str | LitKind::ByteStr if matches!(fmtstr.style, StrStyle::Cooked) => {\n                     lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n-                LitKind::StrRaw(_) | LitKind::Str | LitKind::ByteStrRaw(_) | LitKind::ByteStr => continue,\n+                LitKind::StrRaw(_)\n+                | LitKind::Str\n+                | LitKind::ByteStrRaw(_)\n+                | LitKind::ByteStr\n+                | LitKind::Integer\n+                | LitKind::Float\n+                | LitKind::Err => continue,\n                 LitKind::Byte | LitKind::Char => match lit.token.symbol.as_str() {\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Cooked) => \"\\\\\\\"\",\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Raw(0)) => continue,"}, {"sha": "b6d04263b37a3e7e7327425fe8d2d802b8f913fc", "filename": "tests/ui/match_same_arms.stderr", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/tests%2Fui%2Fmatch_same_arms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/tests%2Fui%2Fmatch_same_arms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms.stderr?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -1,128 +1,121 @@\n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:13:14\n+error: this match arm has an identical body to the `_` wildcard arm\n+  --> $DIR/match_same_arms.rs:11:9\n    |\n-LL |         _ => 0, //~ ERROR match arms have same body\n-   |              ^\n+LL |         Abc::A => 0,\n+   |         ^^^^^^^^^^^ help: try removing the arm\n    |\n    = note: `-D clippy::match-same-arms` implied by `-D warnings`\n-note: same as this\n-  --> $DIR/match_same_arms.rs:11:19\n+   = help: or try changing either arm body\n+note: `_` wildcard arm here\n+  --> $DIR/match_same_arms.rs:13:9\n    |\n-LL |         Abc::A => 0,\n-   |                   ^\n-note: `Abc::A` has the same arm body as the `_` wildcard, consider removing it\n-  --> $DIR/match_same_arms.rs:11:19\n-   |\n-LL |         Abc::A => 0,\n-   |                   ^\n+LL |         _ => 0, //~ ERROR match arms have same body\n+   |         ^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:18:20\n-   |\n-LL |         (.., 3) => 42, //~ ERROR match arms have same body\n-   |                    ^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:17:23\n-   |\n-LL |         (1, .., 3) => 42,\n-   |                       ^^\n-help: consider refactoring into `(1, .., 3) | (.., 3)`\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms.rs:17:9\n    |\n LL |         (1, .., 3) => 42,\n-   |         ^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ----------^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(1, .., 3) | (.., 3)`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms.rs:18:9\n+   |\n+LL |         (.., 3) => 42, //~ ERROR match arms have same body\n+   |         ^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:24:15\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:24:9\n    |\n LL |         51 => 1, //~ ERROR match arms have same body\n-   |               ^\n+   |         --^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `51 | 42`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:23:15\n-   |\n-LL |         42 => 1,\n-   |               ^\n-help: consider refactoring into `42 | 51`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:23:9\n    |\n LL |         42 => 1,\n-   |         ^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:26:15\n-   |\n-LL |         52 => 2, //~ ERROR match arms have same body\n-   |               ^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:25:15\n-   |\n-LL |         41 => 2,\n-   |               ^\n-help: consider refactoring into `41 | 52`\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms.rs:25:9\n    |\n LL |         41 => 2,\n-   |         ^^\n-   = help: ...or consider changing the match arm bodies\n+   |         --^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `41 | 52`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms.rs:26:9\n+   |\n+LL |         52 => 2, //~ ERROR match arms have same body\n+   |         ^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:32:14\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:32:9\n    |\n LL |         2 => 2, //~ ERROR 2nd matched arms have same body\n-   |              ^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:31:14\n+   |         -^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `2 | 1`\n    |\n-LL |         1 => 2,\n-   |              ^\n-help: consider refactoring into `1 | 2`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:31:9\n    |\n LL |         1 => 2,\n-   |         ^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:33:14\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:33:9\n    |\n LL |         3 => 2, //~ ERROR 3rd matched arms have same body\n-   |              ^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:31:14\n+   |         -^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `3 | 1`\n    |\n-LL |         1 => 2,\n-   |              ^\n-help: consider refactoring into `1 | 3`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:31:9\n    |\n LL |         1 => 2,\n-   |         ^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:50:55\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:32:9\n    |\n-LL |                 CommandInfo::External { name, .. } => name.to_string(),\n-   |                                                       ^^^^^^^^^^^^^^^^\n+LL |         2 => 2, //~ ERROR 2nd matched arms have same body\n+   |         -^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `2 | 3`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:49:54\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms.rs:33:9\n    |\n-LL |                 CommandInfo::BuiltIn { name, .. } => name.to_string(),\n-   |                                                      ^^^^^^^^^^^^^^^^\n-help: consider refactoring into `CommandInfo::BuiltIn { name, .. } | CommandInfo::External { name, .. }`\n+LL |         3 => 2, //~ ERROR 3rd matched arms have same body\n+   |         ^^^^^^\n+\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:50:17\n+   |\n+LL |                 CommandInfo::External { name, .. } => name.to_string(),\n+   |                 ----------------------------------^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 help: try merging the arm patterns: `CommandInfo::External { name, .. } | CommandInfo::BuiltIn { name, .. }`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:49:17\n    |\n LL |                 CommandInfo::BuiltIn { name, .. } => name.to_string(),\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "dbfeb4379d513f7d910ef64346eadf197571ad11", "filename": "tests/ui/match_same_arms2.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/tests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/tests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.rs?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -174,4 +174,57 @@ fn main() {\n         Some(2) => 2,\n         _ => 1,\n     };\n+\n+    enum Foo {\n+        X(u32),\n+        Y(u32),\n+        Z(u32),\n+    }\n+\n+    // Don't lint. `Foo::X(0)` and `Foo::Z(_)` overlap with the arm in between.\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::X(_) | Foo::Y(_) | Foo::Z(0) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n+\n+    // Suggest moving `Foo::Z(_)` up.\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::X(_) | Foo::Y(_) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n+\n+    // Suggest moving `Foo::X(0)` down.\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::Y(_) | Foo::Z(0) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n+\n+    // Don't lint.\n+    let _ = match 0 {\n+        -2 => 1,\n+        -5..=50 => 2,\n+        -150..=88 => 1,\n+        _ => 3,\n+    };\n+\n+    struct Bar {\n+        x: u32,\n+        y: u32,\n+        z: u32,\n+    }\n+\n+    // Lint.\n+    let _ = match None {\n+        Some(Bar { x: 0, y: 5, .. }) => 1,\n+        Some(Bar { y: 10, z: 0, .. }) => 2,\n+        None => 50,\n+        Some(Bar { y: 0, x: 5, .. }) => 1,\n+        _ => 200,\n+    };\n }"}, {"sha": "14a672ba2fec1d0a5098cb1720566f8639632b1b", "filename": "tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 118, "deletions": 110, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/f07ee8a998eff61977d594eeac44dc1d0ead7b02/tests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f07ee8a998eff61977d594eeac44dc1d0ead7b02/tests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_same_arms2.stderr?ref=f07ee8a998eff61977d594eeac44dc1d0ead7b02", "patch": "@@ -1,175 +1,138 @@\n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:20:14\n+error: this match arm has an identical body to the `_` wildcard arm\n+  --> $DIR/match_same_arms2.rs:11:9\n    |\n-LL |           _ => {\n-   |  ______________^\n-LL | |             //~ ERROR match arms have same body\n+LL | /         42 => {\n LL | |             foo();\n LL | |             let mut a = 42 + [23].len() as i32;\n+LL | |             if true {\n ...  |\n LL | |             a\n LL | |         },\n-   | |_________^\n+   | |_________^ help: try removing the arm\n    |\n    = note: `-D clippy::match-same-arms` implied by `-D warnings`\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:11:15\n+   = help: or try changing either arm body\n+note: `_` wildcard arm here\n+  --> $DIR/match_same_arms2.rs:20:9\n    |\n-LL |           42 => {\n-   |  _______________^\n-LL | |             foo();\n-LL | |             let mut a = 42 + [23].len() as i32;\n-LL | |             if true {\n-...  |\n-LL | |             a\n-LL | |         },\n-   | |_________^\n-note: `42` has the same arm body as the `_` wildcard, consider removing it\n-  --> $DIR/match_same_arms2.rs:11:15\n-   |\n-LL |           42 => {\n-   |  _______________^\n+LL | /         _ => {\n+LL | |             //~ ERROR match arms have same body\n LL | |             foo();\n LL | |             let mut a = 42 + [23].len() as i32;\n-LL | |             if true {\n ...  |\n LL | |             a\n LL | |         },\n    | |_________^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:34:15\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:34:9\n    |\n LL |         51 => foo(), //~ ERROR match arms have same body\n-   |               ^^^^^\n+   |         --^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `51 | 42`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:33:15\n-   |\n-LL |         42 => foo(),\n-   |               ^^^^^\n-help: consider refactoring into `42 | 51`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:33:9\n    |\n LL |         42 => foo(),\n-   |         ^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:40:17\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:40:9\n    |\n LL |         None => 24, //~ ERROR match arms have same body\n-   |                 ^^\n+   |         ----^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `None | Some(_)`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:39:20\n-   |\n-LL |         Some(_) => 24,\n-   |                    ^^\n-help: consider refactoring into `Some(_) | None`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:39:9\n    |\n LL |         Some(_) => 24,\n-   |         ^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:62:28\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:62:9\n    |\n LL |         (None, Some(a)) => bar(a), //~ ERROR match arms have same body\n-   |                            ^^^^^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:61:28\n+   |         ---------------^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(None, Some(a)) | (Some(a), None)`\n    |\n-LL |         (Some(a), None) => bar(a),\n-   |                            ^^^^^^\n-help: consider refactoring into `(Some(a), None) | (None, Some(a))`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:61:9\n    |\n LL |         (Some(a), None) => bar(a),\n-   |         ^^^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:68:26\n-   |\n-LL |         (.., Some(a)) => bar(a), //~ ERROR match arms have same body\n-   |                          ^^^^^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:67:26\n-   |\n-LL |         (Some(a), ..) => bar(a),\n-   |                          ^^^^^^\n-help: consider refactoring into `(Some(a), ..) | (.., Some(a))`\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms2.rs:67:9\n    |\n LL |         (Some(a), ..) => bar(a),\n-   |         ^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n-\n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:102:29\n-   |\n-LL |         (Ok(_), Some(x)) => println!(\"ok {}\", x),\n-   |                             ^^^^^^^^^^^^^^^^^^^^\n+   |         -------------^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(Some(a), ..) | (.., Some(a))`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:101:29\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:68:9\n    |\n-LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n-   |                             ^^^^^^^^^^^^^^^^^^^^\n-help: consider refactoring into `(Ok(x), Some(_)) | (Ok(_), Some(x))`\n+LL |         (.., Some(a)) => bar(a), //~ ERROR match arms have same body\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms2.rs:101:9\n    |\n LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n-   |         ^^^^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n-   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |         ----------------^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(Ok(x), Some(_)) | (Ok(_), Some(x))`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:102:9\n+   |\n+LL |         (Ok(_), Some(x)) => println!(\"ok {}\", x),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:117:18\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:117:9\n    |\n LL |         Ok(_) => println!(\"ok\"),\n-   |                  ^^^^^^^^^^^^^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:116:18\n+   |         -----^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Ok(_) | Ok(3)`\n    |\n-LL |         Ok(3) => println!(\"ok\"),\n-   |                  ^^^^^^^^^^^^^^\n-help: consider refactoring into `Ok(3) | Ok(_)`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:116:9\n    |\n LL |         Ok(3) => println!(\"ok\"),\n-   |         ^^^^^\n-   = help: ...or consider changing the match arm bodies\n-   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:144:14\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:144:9\n    |\n LL |           1 => {\n-   |  ______________^\n+   |           ^ help: try merging the arm patterns: `1 | 0`\n+   |  _________|\n+   | |\n LL | |             empty!(0);\n LL | |         },\n    | |_________^\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:141:14\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:141:9\n    |\n-LL |           0 => {\n-   |  ______________^\n+LL | /         0 => {\n LL | |             empty!(0);\n LL | |         },\n    | |_________^\n-help: consider refactoring into `0 | 1`\n-  --> $DIR/match_same_arms2.rs:141:9\n-   |\n-LL |         0 => {\n-   |         ^\n-   = help: ...or consider changing the match arm bodies\n \n error: match expression looks like `matches!` macro\n   --> $DIR/match_same_arms2.rs:162:16\n@@ -184,5 +147,50 @@ LL | |     };\n    |\n    = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n \n-error: aborting due to 9 previous errors\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:194:9\n+   |\n+LL |         Foo::X(0) => 1,\n+   |         ---------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Foo::X(0) | Foo::Z(_)`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:196:9\n+   |\n+LL |         Foo::Z(_) => 1,\n+   |         ^^^^^^^^^^^^^^\n+\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:204:9\n+   |\n+LL |         Foo::Z(_) => 1,\n+   |         ---------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Foo::Z(_) | Foo::X(0)`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:202:9\n+   |\n+LL |         Foo::X(0) => 1,\n+   |         ^^^^^^^^^^^^^^\n+\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:227:9\n+   |\n+LL |         Some(Bar { y: 0, x: 5, .. }) => 1,\n+   |         ----------------------------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Some(Bar { y: 0, x: 5, .. }) | Some(Bar { x: 0, y: 5, .. })`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:224:9\n+   |\n+LL |         Some(Bar { x: 0, y: 5, .. }) => 1,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n "}]}