{"sha": "5bc95de47d960f7a4082798237f438ac8d9f225b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViYzk1ZGU0N2Q5NjBmN2E0MDgyNzk4MjM3ZjQzOGFjOGQ5ZjIyNWI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-14T19:31:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-14T19:31:51Z"}, "message": "Rollup merge of #57043 - ssomers:master, r=alexcrichton\n\nFix poor worst case performance of set intersection\n\nSpecifically, intersection of asymmetrically sized sets when the large set is on the left. See also the [latest answer on stackoverflow](https://stackoverflow.com/questions/35439376/python-set-intersection-is-faster-then-rust-hashset-intersection).\n\nAlso applied to the union member, where the effect is much less but still measurable.\n\nFormatted the changed code only, does not increase the error count reported by tidy check, and tried to adhere to the spirit of the unit tests.", "tree": {"sha": "b4bee7a59c0c904ccf620e68db1ca36838131c1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4bee7a59c0c904ccf620e68db1ca36838131c1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bc95de47d960f7a4082798237f438ac8d9f225b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcPOOnCRBK7hj4Ov3rIwAAdHIIABWbXPn05C65sJXgahstm7w+\nfWj9SHiFrJgJs8CDiR7CdZluj+Y7pY7f5LJxDViohyaiM3Q5Bs1FwOi6AJK+vnS9\n12r8VNIWWKmhIs8QJB+zBCT9R+gp6dluxxODpvROa7cW2RmtJEOIlbeojejBt5E2\nyluOIu/vrYilYqd1r/dwEjYZQ7DILT6HFgaWiIE/b1AQ+KUqoGNs6EYtd6t/iORP\n7FTvut/nAgJyqTPiN9muPi9hoPYxJmzNLzEpi3cQDkDbLgA7Kh5UOckZd16HEMem\n8HpYHOUs30UwQSmmBp/6dIeUp3fVU58gdTStGahM5C9U+elNvghQbyZu2UYdwAA=\n=+A07\n-----END PGP SIGNATURE-----\n", "payload": "tree b4bee7a59c0c904ccf620e68db1ca36838131c1b\nparent d10680818b2a0aabb76e6a07098e031b31707fcc\nparent cef2e2f3d53795787085bf63a6c2a8563e7ba9c9\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547494311 +0100\ncommitter GitHub <noreply@github.com> 1547494311 +0100\n\nRollup merge of #57043 - ssomers:master, r=alexcrichton\n\nFix poor worst case performance of set intersection\n\nSpecifically, intersection of asymmetrically sized sets when the large set is on the left. See also the [latest answer on stackoverflow](https://stackoverflow.com/questions/35439376/python-set-intersection-is-faster-then-rust-hashset-intersection).\n\nAlso applied to the union member, where the effect is much less but still measurable.\n\nFormatted the changed code only, does not increase the error count reported by tidy check, and tried to adhere to the spirit of the unit tests.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc95de47d960f7a4082798237f438ac8d9f225b", "html_url": "https://github.com/rust-lang/rust/commit/5bc95de47d960f7a4082798237f438ac8d9f225b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bc95de47d960f7a4082798237f438ac8d9f225b/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10680818b2a0aabb76e6a07098e031b31707fcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10680818b2a0aabb76e6a07098e031b31707fcc", "html_url": "https://github.com/rust-lang/rust/commit/d10680818b2a0aabb76e6a07098e031b31707fcc"}, {"sha": "cef2e2f3d53795787085bf63a6c2a8563e7ba9c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cef2e2f3d53795787085bf63a6c2a8563e7ba9c9", "html_url": "https://github.com/rust-lang/rust/commit/cef2e2f3d53795787085bf63a6c2a8563e7ba9c9"}], "stats": {"total": 67, "additions": 60, "deletions": 7}, "files": [{"sha": "c55dd049ec60fd15ca924349e78042f31cd3ae85", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5bc95de47d960f7a4082798237f438ac8d9f225b/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc95de47d960f7a4082798237f438ac8d9f225b/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=5bc95de47d960f7a4082798237f438ac8d9f225b", "patch": "@@ -410,9 +410,16 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n-        Intersection {\n-            iter: self.iter(),\n-            other,\n+        if self.len() <= other.len() {\n+            Intersection {\n+                iter: self.iter(),\n+                other,\n+            }\n+        } else {\n+            Intersection {\n+                iter: other.iter(),\n+                other: self,\n+            }\n         }\n     }\n \n@@ -436,7 +443,15 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n-        Union { iter: self.iter().chain(other.difference(self)) }\n+        if self.len() <= other.len() {\n+            Union {\n+                iter: self.iter().chain(other.difference(self)),\n+            }\n+        } else {\n+            Union {\n+                iter: other.iter().chain(self.difference(other)),\n+            }\n+        }\n     }\n \n     /// Returns the number of elements in the set.\n@@ -584,7 +599,11 @@ impl<T, S> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n-        self.iter().all(|v| !other.contains(v))\n+        if self.len() <= other.len() {\n+            self.iter().all(|v| !other.contains(v))\n+        } else {\n+            other.iter().all(|v| !self.contains(v))\n+        }\n     }\n \n     /// Returns `true` if the set is a subset of another,\n@@ -1494,6 +1513,7 @@ mod test_set {\n     fn test_intersection() {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n+        assert!(a.intersection(&b).next().is_none());\n \n         assert!(a.insert(11));\n         assert!(a.insert(1));\n@@ -1518,6 +1538,22 @@ mod test_set {\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n+\n+        assert!(a.insert(9)); // make a bigger than b\n+\n+        i = 0;\n+        for x in a.intersection(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+\n+        i = 0;\n+        for x in b.intersection(&a) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]\n@@ -1573,11 +1609,11 @@ mod test_set {\n     fn test_union() {\n         let mut a = HashSet::new();\n         let mut b = HashSet::new();\n+        assert!(a.union(&b).next().is_none());\n+        assert!(b.union(&a).next().is_none());\n \n         assert!(a.insert(1));\n         assert!(a.insert(3));\n-        assert!(a.insert(5));\n-        assert!(a.insert(9));\n         assert!(a.insert(11));\n         assert!(a.insert(16));\n         assert!(a.insert(19));\n@@ -1597,6 +1633,23 @@ mod test_set {\n             i += 1\n         }\n         assert_eq!(i, expected.len());\n+\n+        assert!(a.insert(9)); // make a bigger than b\n+        assert!(a.insert(5));\n+\n+        i = 0;\n+        for x in a.union(&b) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n+\n+        i = 0;\n+        for x in b.union(&a) {\n+            assert!(expected.contains(x));\n+            i += 1\n+        }\n+        assert_eq!(i, expected.len());\n     }\n \n     #[test]"}]}