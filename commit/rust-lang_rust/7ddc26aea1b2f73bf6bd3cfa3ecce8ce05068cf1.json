{"sha": "7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkZGMyNmFlYTFiMmY3M2JmNmJkM2NmYTNlY2NlOGNlMDUwNjhjZjE=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-10T11:55:26Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-10T11:55:26Z"}, "message": "add clone generation for structs and bare enums", "tree": {"sha": "8f5d0c0ef34293d0d93e5fe94b8f3406f0bd09ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f5d0c0ef34293d0d93e5fe94b8f3406f0bd09ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1", "html_url": "https://github.com/rust-lang/rust/commit/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d7a50daf7114fc8af62d74cf3162132dd826eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d7a50daf7114fc8af62d74cf3162132dd826eaa", "html_url": "https://github.com/rust-lang/rust/commit/7d7a50daf7114fc8af62d74cf3162132dd826eaa"}], "stats": {"total": 106, "additions": 97, "deletions": 9}, "files": [{"sha": "10959bfd01c566322593e53c40ffd6ce85ed26ce", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1", "patch": "@@ -467,10 +467,7 @@ struct Foo {\n \n impl Clone for Foo {\n     $0fn clone(&self) -> Self {\n-        Self {\n-            bin: self.bin.clone(),\n-            bar: self.bar.clone(),\n-        }\n+        Self { bin: self.bin.clone(), bar: self.bar.clone() }\n     }\n }\n \"#,\n@@ -498,6 +495,27 @@ impl Clone for Foo {\n         )\n     }\n \n+    #[test]\n+    fn add_custom_impl_clone_empty_struct() {\n+        check_assist(\n+            replace_derive_with_manual_impl,\n+            r#\"\n+//- minicore: clone\n+#[derive(Clo$0ne)]\n+struct Foo;\n+\"#,\n+            r#\"\n+struct Foo;\n+\n+impl Clone for Foo {\n+    $0fn clone(&self) -> Self {\n+        Self {  }\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn add_custom_impl_clone_enum() {\n         check_assist(\n@@ -536,7 +554,7 @@ impl Clone for Foo {\n //- minicore: clone\n #[derive(Clo$0ne)]\n enum Foo {\n-    Bar,\n+    Bar(String),\n     Baz,\n }\n \"#,"}, {"sha": "ee7d594c03f320c23e51337801e5d3be744df169", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 74, "deletions": 4, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=7ddc26aea1b2f73bf6bd3cfa3ecce8ce05068cf1", "patch": "@@ -16,13 +16,83 @@ pub(crate) fn gen_trait_fn_body(\n     adt: &ast::Adt,\n ) -> Option<()> {\n     match trait_path.segment()?.name_ref()?.text().as_str() {\n+        \"Clone\" => gen_clone_impl(adt, func),\n         \"Debug\" => gen_debug_impl(adt, func),\n         \"Default\" => gen_default_impl(adt, func),\n         \"Hash\" => gen_hash_impl(adt, func),\n         _ => None,\n     }\n }\n \n+/// Generate a `Clone` impl based on the fields and members of the target type.\n+fn gen_clone_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n+    fn gen_clone_call(target: ast::Expr) -> ast::Expr {\n+        let method = make::name_ref(\"clone\");\n+        make::expr_method_call(target, method, make::arg_list(None))\n+    }\n+    let expr = match adt {\n+        // `Clone` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => return None,\n+        ast::Adt::Enum(enum_) => {\n+            let list = enum_.variant_list()?;\n+            let mut arms = vec![];\n+            for variant in list.variants() {\n+                let name = variant.name()?;\n+                let left = make::ext::ident_path(\"Self\");\n+                let right = make::ext::ident_path(&format!(\"{}\", name));\n+                let variant_name = make::path_concat(left, right);\n+\n+                let pattern = make::path_pat(variant_name.clone());\n+                let variant_expr = make::expr_path(variant_name);\n+                arms.push(make::match_arm(Some(pattern.into()), None, variant_expr));\n+            }\n+\n+            let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n+            let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+            make::expr_match(match_target, list)\n+        }\n+        ast::Adt::Struct(strukt) => {\n+            match strukt.field_list() {\n+                // => Self { name: self.name.clone() }\n+                Some(ast::FieldList::RecordFieldList(field_list)) => {\n+                    let mut fields = vec![];\n+                    for field in field_list.fields() {\n+                        let base = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let target = make::expr_field(base, &field.name()?.to_string());\n+                        let method_call = gen_clone_call(target);\n+                        let name_ref = make::name_ref(&field.name()?.to_string());\n+                        let field = make::record_expr_field(name_ref, Some(method_call));\n+                        fields.push(field);\n+                    }\n+                    let struct_name = make::ext::ident_path(\"Self\");\n+                    let fields = make::record_expr_field_list(fields);\n+                    make::record_expr(struct_name, fields).into()\n+                }\n+                // => Self(self.0.clone(), self.1.clone())\n+                Some(ast::FieldList::TupleFieldList(field_list)) => {\n+                    let mut fields = vec![];\n+                    for (i, _) in field_list.fields().enumerate() {\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let target = make::expr_field(f_path, &format!(\"{}\", i)).into();\n+                        fields.push(gen_clone_call(target));\n+                    }\n+                    let struct_name = make::expr_path(make::ext::ident_path(\"Self\"));\n+                    make::expr_call(struct_name, make::arg_list(fields))\n+                }\n+                // => Self { }\n+                None => {\n+                    let struct_name = make::ext::ident_path(\"Self\");\n+                    let fields = make::record_expr_field_list(None);\n+                    make::record_expr(struct_name, fields).into()\n+                }\n+            }\n+        }\n+    };\n+    let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n+    ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+    Some(())\n+}\n+\n /// Generate a `Debug` impl based on the fields and members of the target type.\n fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n     let annotated_name = adt.name()?;\n@@ -88,10 +158,10 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 Some(ast::FieldList::TupleFieldList(field_list)) => {\n                     let method = make::name_ref(\"debug_tuple\");\n                     let mut expr = make::expr_method_call(target, method, args);\n-                    for (idx, _) in field_list.fields().enumerate() {\n+                    for (i, _) in field_list.fields().enumerate() {\n                         let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n                         let f_path = make::expr_ref(f_path, false);\n-                        let f_path = make::expr_field(f_path, &format!(\"{}\", idx)).into();\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", i)).into();\n                         let method = make::name_ref(\"field\");\n                         expr = make::expr_method_call(expr, method, make::arg_list(Some(f_path)));\n                     }\n@@ -182,7 +252,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n             make::block_expr(Some(stmt), None).indent(ast::edit::IndentLevel(1))\n         }\n         ast::Adt::Struct(strukt) => match strukt.field_list() {\n-            // => self.<field>.hash(state);*\n+            // => self.<field>.hash(state);\n             Some(ast::FieldList::RecordFieldList(field_list)) => {\n                 let mut stmts = vec![];\n                 for field in field_list.fields() {\n@@ -193,7 +263,7 @@ fn gen_hash_impl(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                 make::block_expr(stmts, None).indent(ast::edit::IndentLevel(1))\n             }\n \n-            // => self.<field_index>.hash(state);*\n+            // => self.<field_index>.hash(state);\n             Some(ast::FieldList::TupleFieldList(field_list)) => {\n                 let mut stmts = vec![];\n                 for (i, _) in field_list.fields().enumerate() {"}]}