{"sha": "d9595d1737677dd61d9f52f674c34f13d708e39c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NTk1ZDE3Mzc2NzdkZDYxZDlmNTJmNjc0YzM0ZjEzZDcwOGUzOWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-09T05:31:23Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-14T05:15:46Z"}, "message": "core: remove unnecessary unsafe blocks/functions", "tree": {"sha": "304855240a098090a217dc325c4ca377b31d9ba2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/304855240a098090a217dc325c4ca377b31d9ba2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9595d1737677dd61d9f52f674c34f13d708e39c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9595d1737677dd61d9f52f674c34f13d708e39c", "html_url": "https://github.com/rust-lang/rust/commit/d9595d1737677dd61d9f52f674c34f13d708e39c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9595d1737677dd61d9f52f674c34f13d708e39c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bfa3c6663ad6facdbdb8bd533442b050085f753", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bfa3c6663ad6facdbdb8bd533442b050085f753", "html_url": "https://github.com/rust-lang/rust/commit/4bfa3c6663ad6facdbdb8bd533442b050085f753"}], "stats": {"total": 468, "additions": 226, "deletions": 242}, "files": [{"sha": "d665bf311f362868c7fc9f01a6c9af4f77fe45a5", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -188,16 +188,14 @@ impl<T: Owned> Peekable<T> for Port<T> {\n \n #[inline(always)]\n fn port_peek<T:Owned>(self: &Port<T>) -> bool {\n-    unsafe {\n-        let mut endp = None;\n-        endp <-> self.endp;\n-        let peek = match &endp {\n-            &Some(ref endp) => peek(endp),\n-            &None => fail!(~\"peeking empty stream\")\n-        };\n-        self.endp <-> endp;\n-        peek\n-    }\n+    let mut endp = None;\n+    endp <-> self.endp;\n+    let peek = match &endp {\n+        &Some(ref endp) => peek(endp),\n+        &None => fail!(~\"peeking empty stream\")\n+    };\n+    self.endp <-> endp;\n+    peek\n }\n \n impl<T: Owned> Selectable for Port<T> {"}, {"sha": "3c5900f51a247d4ba8fa08ac2985a6e91a5aa048", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -1536,11 +1536,8 @@ pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     let mut v = with_bytes_writer(f);\n \n-    // FIXME (#3758): This should not be needed.\n-    unsafe {\n-        // Make sure the vector has a trailing null and is proper utf8.\n-        v.push(0);\n-    }\n+    // Make sure the vector has a trailing null and is proper utf8.\n+    v.push(0);\n     assert!(str::is_utf8(v));\n \n     unsafe { ::cast::transmute(v) }\n@@ -1640,16 +1637,14 @@ pub mod fsync {\n     // outer res\n     pub fn FILE_res_sync(file: &FILERes, opt_level: Option<Level>,\n                          blk: &fn(v: Res<*libc::FILE>)) {\n-        unsafe {\n-            blk(Res(Arg {\n-                val: file.f, opt_level: opt_level,\n-                fsync_fn: |file, l| {\n-                    unsafe {\n-                        os::fsync_fd(libc::fileno(file), l) as int\n-                    }\n+        blk(Res(Arg {\n+            val: file.f, opt_level: opt_level,\n+            fsync_fn: |file, l| {\n+                unsafe {\n+                    os::fsync_fd(libc::fileno(file), l) as int\n                 }\n-            }));\n-        }\n+            }\n+        }));\n     }\n \n     // fsync fd after executing blk"}, {"sha": "2bd3959acf4de476bc28ba5aaa16f0e48e9536f9", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -38,13 +38,13 @@ pub mod raw {\n #[inline(always)]\n pub fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     //! Determine if two shared boxes point to the same object\n-    unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n+    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n }\n \n #[inline(always)]\n pub fn mut_ptr_eq<T>(a: @mut T, b: @mut T) -> bool {\n     //! Determine if two mutable shared boxes point to the same object\n-    unsafe { ptr::addr_of(&(*a)) == ptr::addr_of(&(*b)) }\n+    ptr::addr_of(&(*a)) == ptr::addr_of(&(*b))\n }\n \n #[cfg(notest)]"}, {"sha": "87d04b05087c23dc7cbae85746b9bb91b98382b5", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -369,27 +369,27 @@ pub fn is_NaN(x: float) -> bool { f64::is_NaN(x as f64) }\n \n #[inline(always)]\n pub fn abs(x: float) -> float {\n-    unsafe { f64::abs(x as f64) as float }\n+    f64::abs(x as f64) as float\n }\n #[inline(always)]\n pub fn sqrt(x: float) -> float {\n-    unsafe { f64::sqrt(x as f64) as float }\n+    f64::sqrt(x as f64) as float\n }\n #[inline(always)]\n pub fn atan(x: float) -> float {\n-    unsafe { f64::atan(x as f64) as float }\n+    f64::atan(x as f64) as float\n }\n #[inline(always)]\n pub fn sin(x: float) -> float {\n-    unsafe { f64::sin(x as f64) as float }\n+    f64::sin(x as f64) as float\n }\n #[inline(always)]\n pub fn cos(x: float) -> float {\n-    unsafe { f64::cos(x as f64) as float }\n+    f64::cos(x as f64) as float\n }\n #[inline(always)]\n pub fn tan(x: float) -> float {\n-    unsafe { f64::tan(x as f64) as float }\n+    f64::tan(x as f64) as float\n }\n \n #[cfg(notest)]"}, {"sha": "0e8dbd144b14395e2fe6c9a0a7c884542ca18b99", "filename": "src/libcore/path.rs", "status": "modified", "additions": 25, "deletions": 35, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -389,13 +389,11 @@ impl GenericPath for PosixPath {\n     }\n \n     fn dirname(&self) -> ~str {\n-        unsafe {\n-            let s = self.dir_path().to_str();\n-            if s.len() == 0 {\n-                ~\".\"\n-            } else {\n-                s\n-            }\n+        let s = self.dir_path().to_str();\n+        if s.len() == 0 {\n+            ~\".\"\n+        } else {\n+            s\n         }\n     }\n \n@@ -439,10 +437,8 @@ impl GenericPath for PosixPath {\n     }\n \n     fn with_filename(&self, f: &str) -> PosixPath {\n-        unsafe {\n-            assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n-            self.dir_path().push(f)\n-        }\n+        assert!(! str::any(f, |c| windows::is_sep(c as u8)));\n+        self.dir_path().push(f)\n     }\n \n     fn with_filestem(&self, s: &str) -> PosixPath {\n@@ -509,7 +505,7 @@ impl GenericPath for PosixPath {\n             for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n                 ss.push(s.to_owned())\n             }\n-            unsafe { v.push_all_move(ss); }\n+            v.push_all_move(ss);\n         }\n         PosixPath { is_absolute: self.is_absolute,\n                     components: v }\n@@ -521,14 +517,14 @@ impl GenericPath for PosixPath {\n         for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n             ss.push(s.to_owned())\n         }\n-        unsafe { v.push_all_move(ss); }\n+        v.push_all_move(ss);\n         PosixPath { components: v, ..copy *self }\n     }\n \n     fn pop(&self) -> PosixPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { cs.pop(); }\n+            cs.pop();\n         }\n         return PosixPath {\n             is_absolute: self.is_absolute,\n@@ -607,13 +603,11 @@ impl GenericPath for WindowsPath {\n     }\n \n     fn dirname(&self) -> ~str {\n-        unsafe {\n-            let s = self.dir_path().to_str();\n-            if s.len() == 0 {\n-                ~\".\"\n-            } else {\n-                s\n-            }\n+        let s = self.dir_path().to_str();\n+        if s.len() == 0 {\n+            ~\".\"\n+        } else {\n+            s\n         }\n     }\n \n@@ -770,7 +764,7 @@ impl GenericPath for WindowsPath {\n             for str::each_split_nonempty(*e, |c| windows::is_sep(c as u8)) |s| {\n                 ss.push(s.to_owned())\n             }\n-            unsafe { v.push_all_move(ss); }\n+            v.push_all_move(ss);\n         }\n         // tedious, but as-is, we can't use ..self\n         return WindowsPath {\n@@ -787,14 +781,14 @@ impl GenericPath for WindowsPath {\n         for str::each_split_nonempty(s, |c| windows::is_sep(c as u8)) |s| {\n             ss.push(s.to_owned())\n         }\n-        unsafe { v.push_all_move(ss); }\n+        v.push_all_move(ss);\n         return WindowsPath { components: v, ..copy *self }\n     }\n \n     fn pop(&self) -> WindowsPath {\n         let mut cs = copy self.components;\n         if cs.len() != 0 {\n-            unsafe { cs.pop(); }\n+            cs.pop();\n         }\n         return WindowsPath {\n             host: copy self.host,\n@@ -820,18 +814,14 @@ impl GenericPath for WindowsPath {\n \n pub fn normalize(components: &[~str]) -> ~[~str] {\n     let mut cs = ~[];\n-    unsafe {\n-        for components.each |c| {\n-            unsafe {\n-                if *c == ~\".\" && components.len() > 1 { loop; }\n-                if *c == ~\"\" { loop; }\n-                if *c == ~\"..\" && cs.len() != 0 {\n-                    cs.pop();\n-                    loop;\n-                }\n-                cs.push(copy *c);\n-            }\n+    for components.each |c| {\n+        if *c == ~\".\" && components.len() > 1 { loop; }\n+        if *c == ~\"\" { loop; }\n+        if *c == ~\"..\" && cs.len() != 0 {\n+            cs.pop();\n+            loop;\n         }\n+        cs.push(copy *c);\n     }\n     cs\n }"}, {"sha": "14e17de4fbda08170f6d1d0adaa41d5932e74877", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -55,17 +55,13 @@ pub fn addr_of<T>(val: &T) -> *T { unsafe { rusti::addr_of(*val) } }\n /// Calculate the offset from a pointer\n #[inline(always)]\n pub fn offset<T>(ptr: *T, count: uint) -> *T {\n-    unsafe {\n-        (ptr as uint + count * sys::size_of::<T>()) as *T\n-    }\n+    (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a const pointer\n #[inline(always)]\n pub fn const_offset<T>(ptr: *const T, count: uint) -> *const T {\n-    unsafe {\n-        (ptr as uint + count * sys::size_of::<T>()) as *T\n-    }\n+    (ptr as uint + count * sys::size_of::<T>()) as *T\n }\n \n /// Calculate the offset from a mut pointer"}, {"sha": "4714be9e3d520715c97c676e8467fdb3dc22340e", "filename": "src/libcore/rt/context.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fcontext.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -205,8 +205,6 @@ fn align_down(sp: *mut uint) -> *mut uint {\n #[inline(always)]\n pub fn mut_offset<T>(ptr: *mut T, count: int) -> *mut T {\n     use core::sys::size_of;\n-    unsafe {\n-        (ptr as int + count * (size_of::<T>() as int)) as *mut T\n-    }\n+    (ptr as int + count * (size_of::<T>() as int)) as *mut T\n }\n "}, {"sha": "366996fb93560b275b85e0aae62296258065c699", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -21,17 +21,17 @@ pub type Key = pthread_key_t;\n \n #[cfg(unix)]\n pub unsafe fn create(key: &mut Key) {\n-    unsafe { assert!(0 == pthread_key_create(key, null())); }\n+    assert!(0 == pthread_key_create(key, null()));\n }\n \n #[cfg(unix)]\n pub unsafe fn set(key: Key, value: *mut c_void) {\n-    unsafe { assert!(0 == pthread_setspecific(key, value)); }\n+    assert!(0 == pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n pub unsafe fn get(key: Key) -> *mut c_void {\n-    unsafe { pthread_getspecific(key) }\n+    pthread_getspecific(key)\n }\n \n #[cfg(target_os=\"macos\")]"}, {"sha": "49df2938afd4009c4ab7efd6e151b4f413faa78c", "filename": "src/libcore/run.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -382,64 +382,62 @@ pub struct ProgramOutput {status: int, out: ~str, err: ~str}\n  * the contents of stdout and the contents of stderr.\n  */\n pub fn program_output(prog: &str, args: &[~str]) -> ProgramOutput {\n-    unsafe {\n-        let pipe_in = os::pipe();\n-        let pipe_out = os::pipe();\n-        let pipe_err = os::pipe();\n-        let pid = spawn_process(prog, args, &None, &None,\n-                                pipe_in.in, pipe_out.out, pipe_err.out);\n-\n-        os::close(pipe_in.in);\n-        os::close(pipe_out.out);\n-        os::close(pipe_err.out);\n-        if pid == -1i32 {\n-            os::close(pipe_in.out);\n-            os::close(pipe_out.in);\n-            os::close(pipe_err.in);\n-            fail!();\n-        }\n+    let pipe_in = os::pipe();\n+    let pipe_out = os::pipe();\n+    let pipe_err = os::pipe();\n+    let pid = spawn_process(prog, args, &None, &None,\n+                            pipe_in.in, pipe_out.out, pipe_err.out);\n \n+    os::close(pipe_in.in);\n+    os::close(pipe_out.out);\n+    os::close(pipe_err.out);\n+    if pid == -1i32 {\n         os::close(pipe_in.out);\n+        os::close(pipe_out.in);\n+        os::close(pipe_err.in);\n+        fail!();\n+    }\n \n-        // Spawn two entire schedulers to read both stdout and sterr\n-        // in parallel so we don't deadlock while blocking on one\n-        // or the other. FIXME (#2625): Surely there's a much more\n-        // clever way to do this.\n-        let (p, ch) = stream();\n-        let ch = SharedChan(ch);\n-        let ch_clone = ch.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let errput = readclose(pipe_err.in);\n-            ch.send((2, errput));\n-        };\n-        do task::spawn_sched(task::SingleThreaded) {\n-            let output = readclose(pipe_out.in);\n-            ch_clone.send((1, output));\n-        };\n-        let status = run::waitpid(pid);\n-        let mut errs = ~\"\";\n-        let mut outs = ~\"\";\n-        let mut count = 2;\n-        while count > 0 {\n-            let stream = p.recv();\n-            match stream {\n-                (1, copy s) => {\n-                    outs = s;\n-                }\n-                (2, copy s) => {\n-                    errs = s;\n-                }\n-                (n, _) => {\n-                    fail!(fmt!(\"program_output received an unexpected file \\\n-                               number: %u\", n));\n-                }\n-            };\n-            count -= 1;\n+    os::close(pipe_in.out);\n+\n+    // Spawn two entire schedulers to read both stdout and sterr\n+    // in parallel so we don't deadlock while blocking on one\n+    // or the other. FIXME (#2625): Surely there's a much more\n+    // clever way to do this.\n+    let (p, ch) = stream();\n+    let ch = SharedChan(ch);\n+    let ch_clone = ch.clone();\n+    do task::spawn_sched(task::SingleThreaded) {\n+        let errput = readclose(pipe_err.in);\n+        ch.send((2, errput));\n+    };\n+    do task::spawn_sched(task::SingleThreaded) {\n+        let output = readclose(pipe_out.in);\n+        ch_clone.send((1, output));\n+    };\n+    let status = run::waitpid(pid);\n+    let mut errs = ~\"\";\n+    let mut outs = ~\"\";\n+    let mut count = 2;\n+    while count > 0 {\n+        let stream = p.recv();\n+        match stream {\n+            (1, copy s) => {\n+                outs = s;\n+            }\n+            (2, copy s) => {\n+                errs = s;\n+            }\n+            (n, _) => {\n+                fail!(fmt!(\"program_output received an unexpected file \\\n+                           number: %u\", n));\n+            }\n         };\n-        return ProgramOutput {status: status,\n-                              out: outs,\n-                              err: errs};\n-    }\n+        count -= 1;\n+    };\n+    return ProgramOutput {status: status,\n+                          out: outs,\n+                          err: errs};\n }\n \n pub fn writeclose(fd: c_int, s: ~str) {"}, {"sha": "b0653db365e03c97c1b8d6367ed4d9631d4ab59c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 19, "deletions": 25, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -170,18 +170,16 @@ pub fn push_char(s: &mut ~str, ch: char) {\n /// Convert a char to a string\n pub fn from_char(ch: char) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe { push_char(&mut buf, ch); }\n+    push_char(&mut buf, ch);\n     buf\n }\n \n /// Convert a vector of chars to a string\n pub fn from_chars(chs: &[char]) -> ~str {\n     let mut buf = ~\"\";\n-    unsafe {\n-        reserve(&mut buf, chs.len());\n-        for vec::each(chs) |ch| {\n-            push_char(&mut buf, *ch);\n-        }\n+    reserve(&mut buf, chs.len());\n+    for vec::each(chs) |ch| {\n+        push_char(&mut buf, *ch);\n     }\n     buf\n }\n@@ -226,17 +224,15 @@ pub fn push_str(lhs: &mut ~str, rhs: &str) {\n #[inline(always)]\n pub fn append(lhs: ~str, rhs: &str) -> ~str {\n     let mut v = lhs;\n-    unsafe {\n-        push_str_no_overallocate(&mut v, rhs);\n-    }\n+    push_str_no_overallocate(&mut v, rhs);\n     v\n }\n \n /// Concatenate a vector of strings\n pub fn concat(v: &[~str]) -> ~str {\n     let mut s: ~str = ~\"\";\n     for vec::each(v) |ss| {\n-        unsafe { push_str(&mut s, *ss) };\n+        push_str(&mut s, *ss);\n     }\n     s\n }\n@@ -245,8 +241,8 @@ pub fn concat(v: &[~str]) -> ~str {\n pub fn connect(v: &[~str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n-        if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n-        unsafe { push_str(&mut s, *ss) };\n+        if first { first = false; } else { push_str(&mut s, sep); }\n+        push_str(&mut s, *ss);\n     }\n     s\n }\n@@ -255,8 +251,8 @@ pub fn connect(v: &[~str], sep: &str) -> ~str {\n pub fn connect_slices(v: &[&str], sep: &str) -> ~str {\n     let mut s = ~\"\", first = true;\n     for vec::each(v) |ss| {\n-        if first { first = false; } else { unsafe { push_str(&mut s, sep); } }\n-        unsafe { push_str(&mut s, *ss) };\n+        if first { first = false; } else { push_str(&mut s, sep); }\n+        push_str(&mut s, *ss);\n     }\n     s\n }\n@@ -2251,16 +2247,14 @@ pub mod raw {\n             assert!((end <= n));\n \n             let mut v = vec::with_capacity(end - begin + 1u);\n-            unsafe {\n-                do vec::as_imm_buf(v) |vbuf, _vlen| {\n-                    let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n-                    let src = ptr::offset(sbuf, begin);\n-                    ptr::copy_memory(vbuf, src, end - begin);\n-                }\n-                vec::raw::set_len(&mut v, end - begin);\n-                v.push(0u8);\n-                ::cast::transmute(v)\n+            do vec::as_imm_buf(v) |vbuf, _vlen| {\n+                let vbuf = ::cast::transmute_mut_unsafe(vbuf);\n+                let src = ptr::offset(sbuf, begin);\n+                ptr::copy_memory(vbuf, src, end - begin);\n             }\n+            vec::raw::set_len(&mut v, end - begin);\n+            v.push(0u8);\n+            ::cast::transmute(v)\n         }\n     }\n \n@@ -2304,7 +2298,7 @@ pub mod raw {\n     }\n \n     /// Removes the last byte from a string and returns it. (Not UTF-8 safe).\n-    pub unsafe fn pop_byte(s: &mut ~str) -> u8 {\n+    pub fn pop_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[len - 1u];\n@@ -2313,7 +2307,7 @@ pub mod raw {\n     }\n \n     /// Removes the first byte from a string and returns it. (Not UTF-8 safe).\n-    pub unsafe fn shift_byte(s: &mut ~str) -> u8 {\n+    pub fn shift_byte(s: &mut ~str) -> u8 {\n         let len = len(*s);\n         assert!((len > 0u));\n         let b = s[0];"}, {"sha": "678005ce06f9622bd3a50f9ff6ff882968a47332", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -127,10 +127,8 @@ pub fn refcount<T>(t: @T) -> uint {\n }\n \n pub fn log_str<T>(t: &T) -> ~str {\n-    unsafe {\n-        do io::with_str_writer |wr| {\n-            repr::write_repr(wr, t)\n-        }\n+    do io::with_str_writer |wr| {\n+        repr::write_repr(wr, t)\n     }\n }\n \n@@ -157,10 +155,8 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n }\n \n pub fn fail_assert(msg: &str, file: &str, line: uint) -> ! {\n-    unsafe {\n-        let (msg, file) = (msg.to_owned(), file.to_owned());\n-        begin_unwind(~\"assertion failed: \" + msg, file, line)\n-    }\n+    let (msg, file) = (msg.to_owned(), file.to_owned());\n+    begin_unwind(~\"assertion failed: \" + msg, file, line)\n }\n \n #[cfg(test)]"}, {"sha": "d712bf8f98f44960f19141fdb8e24cef6e8a6e7a", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 54, "deletions": 25, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -39,10 +39,9 @@ use result::Result;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use prelude::*;\n use result;\n-use task::rt::{task_id, sched_id};\n+use task::rt::{task_id, sched_id, rust_task};\n use util;\n use util::replace;\n-use unstable::finally::Finally;\n \n #[cfg(test)] use comm::SharedChan;\n \n@@ -566,46 +565,76 @@ pub fn get_scheduler() -> Scheduler {\n  * ~~~\n  */\n pub unsafe fn unkillable<U>(f: &fn() -> U) -> U {\n-    unsafe {\n-        let t = rt::rust_get_task();\n-        rt::rust_task_inhibit_kill(t);\n-        do (|| {\n-            f()\n-        }).finally {\n-            rt::rust_task_allow_kill(t);\n+    struct AllowFailure {\n+        t: *rust_task,\n+        drop {\n+            unsafe {\n+                rt::rust_task_allow_kill(self.t);\n+            }\n+        }\n+    }\n+\n+    fn AllowFailure(t: *rust_task) -> AllowFailure{\n+        AllowFailure {\n+            t: t\n         }\n     }\n+\n+    let t = rt::rust_get_task();\n+    let _allow_failure = AllowFailure(t);\n+    rt::rust_task_inhibit_kill(t);\n+    f()\n }\n \n /// The inverse of unkillable. Only ever to be used nested in unkillable().\n pub unsafe fn rekillable<U>(f: &fn() -> U) -> U {\n-    unsafe {\n-        let t = rt::rust_get_task();\n-        rt::rust_task_allow_kill(t);\n-        do (|| {\n-            f()\n-        }).finally {\n-            rt::rust_task_inhibit_kill(t);\n+    struct DisallowFailure {\n+        t: *rust_task,\n+        drop {\n+            unsafe {\n+                rt::rust_task_inhibit_kill(self.t);\n+            }\n         }\n     }\n+\n+    fn DisallowFailure(t: *rust_task) -> DisallowFailure {\n+        DisallowFailure {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _allow_failure = DisallowFailure(t);\n+    rt::rust_task_allow_kill(t);\n+    f()\n }\n \n /**\n  * A stronger version of unkillable that also inhibits scheduling operations.\n  * For use with exclusive ARCs, which use pthread mutexes directly.\n  */\n pub unsafe fn atomically<U>(f: &fn() -> U) -> U {\n-    unsafe {\n-        let t = rt::rust_get_task();\n-        rt::rust_task_inhibit_kill(t);\n-        rt::rust_task_inhibit_yield(t);\n-        do (|| {\n-            f()\n-        }).finally {\n-            rt::rust_task_allow_yield(t);\n-            rt::rust_task_allow_kill(t);\n+    struct DeferInterrupts {\n+        t: *rust_task,\n+        drop {\n+            unsafe {\n+                rt::rust_task_allow_yield(self.t);\n+                rt::rust_task_allow_kill(self.t);\n+            }\n         }\n     }\n+\n+    fn DeferInterrupts(t: *rust_task) -> DeferInterrupts {\n+        DeferInterrupts {\n+            t: t\n+        }\n+    }\n+\n+    let t = rt::rust_get_task();\n+    let _interrupts = DeferInterrupts(t);\n+    rt::rust_task_inhibit_kill(t);\n+    rt::rust_task_inhibit_yield(t);\n+    f()\n }\n \n #[test] #[should_fail] #[ignore(cfg(windows))]"}, {"sha": "c71f7d26d40f1f51901330211651c7991f62378b", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -157,13 +157,13 @@ struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n-    unsafe { x.with(blk) }\n+    x.with(blk)\n }\n \n #[inline(always)]\n fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n-    unsafe { x.with(blk) }\n+    x.with(blk)\n }\n \n // Iterates over an ancestor list."}, {"sha": "e43d321dc4d05b86057e7e7c5c22f41c1ee9aafb", "filename": "src/libcore/unstable.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -152,45 +152,37 @@ pub type SharedMutableState<T> = ArcDestruct<T>;\n pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n         SharedMutableState<T> {\n     let data = ~ArcData { count: 1, data: Some(data) };\n-    unsafe {\n-        let ptr = cast::transmute(data);\n-        ArcDestruct(ptr)\n-    }\n+    let ptr = cast::transmute(data);\n+    ArcDestruct(ptr)\n }\n \n #[inline(always)]\n pub unsafe fn get_shared_mutable_state<T:Owned>(\n     rc: *SharedMutableState<T>) -> *mut T\n {\n-    unsafe {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert!(ptr.count > 0);\n-        let r = cast::transmute(ptr.data.get_ref());\n-        cast::forget(ptr);\n-        return r;\n-    }\n+    let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+    assert!(ptr.count > 0);\n+    let r = cast::transmute(ptr.data.get_ref());\n+    cast::forget(ptr);\n+    return r;\n }\n #[inline(always)]\n pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n         rc: &'a SharedMutableState<T>) -> &'a T {\n-    unsafe {\n-        let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        assert!(ptr.count > 0);\n-        // Cast us back into the correct region\n-        let r = cast::transmute_region(ptr.data.get_ref());\n-        cast::forget(ptr);\n-        return r;\n-    }\n+    let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+    assert!(ptr.count > 0);\n+    // Cast us back into the correct region\n+    let r = cast::transmute_region(ptr.data.get_ref());\n+    cast::forget(ptr);\n+    return r;\n }\n \n pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n-    unsafe {\n-        let mut ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n-        let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-        assert!(new_count >= 2);\n-        cast::forget(ptr);\n-    }\n+    let mut ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n+    let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n+    assert!(new_count >= 2);\n+    cast::forget(ptr);\n     ArcDestruct((*rc).data)\n }\n "}, {"sha": "8ca5486d929923b9682283b7a7a15d79f3c75f8c", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -19,27 +19,25 @@ use ptr::null;\n use intrinsic::TyDesc;\n \n pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n-    unsafe {\n-        assert!(td.is_not_null());\n+    assert!(td.is_not_null());\n \n-        let total_size = get_box_size(size, (*td).align);\n-        let p = c_malloc(total_size as size_t);\n-        assert!(p.is_not_null());\n+    let total_size = get_box_size(size, (*td).align);\n+    let p = c_malloc(total_size as size_t);\n+    assert!(p.is_not_null());\n \n-        // FIXME #3475: Converting between our two different tydesc types\n-        let td: *TyDesc = transmute(td);\n+    // FIXME #3475: Converting between our two different tydesc types\n+    let td: *TyDesc = transmute(td);\n \n-        let box: &mut BoxRepr = transmute(p);\n-        box.header.ref_count = -1; // Exchange values not ref counted\n-        box.header.type_desc = td;\n-        box.header.prev = null();\n-        box.header.next = null();\n+    let box: &mut BoxRepr = transmute(p);\n+    box.header.ref_count = -1; // Exchange values not ref counted\n+    box.header.type_desc = td;\n+    box.header.prev = null();\n+    box.header.next = null();\n \n-        let exchange_count = &mut *rust_get_exchange_count_ptr();\n-        atomic_xadd(exchange_count, 1);\n+    let exchange_count = &mut *rust_get_exchange_count_ptr();\n+    atomic_xadd(exchange_count, 1);\n \n-        return transmute(box);\n-    }\n+    return transmute(box);\n }\n /**\n Thin wrapper around libc::malloc, none of the box header"}, {"sha": "ad3dce0a7499253ef7e7be4f63a6a55b1b1a3b96", "filename": "src/libcore/unstable/extfmt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fextfmt.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -512,7 +512,7 @@ pub mod rt {\n                 None\n             }\n         } else { Some('-') };\n-        unsafe { pad(cv, s, head, PadSigned, buf) };\n+        pad(cv, s, head, PadSigned, buf);\n     }\n     pub fn conv_uint(cv: Conv, u: uint, buf: &mut ~str) {\n         let prec = get_int_precision(cv);\n@@ -524,7 +524,7 @@ pub mod rt {\n               TyBits => uint_to_str_prec(u, 2, prec),\n               TyOctal => uint_to_str_prec(u, 8, prec)\n             };\n-        unsafe { pad(cv, rs, None, PadUnsigned, buf) };\n+        pad(cv, rs, None, PadUnsigned, buf);\n     }\n     pub fn conv_bool(cv: Conv, b: bool, buf: &mut ~str) {\n         let s = if b { \"true\" } else { \"false\" };\n@@ -533,7 +533,7 @@ pub mod rt {\n         conv_str(cv, s, buf);\n     }\n     pub fn conv_char(cv: Conv, c: char, buf: &mut ~str) {\n-        unsafe { pad(cv, \"\", Some(c), PadNozero, buf) };\n+        pad(cv, \"\", Some(c), PadNozero, buf);\n     }\n     pub fn conv_str(cv: Conv, s: &str, buf: &mut ~str) {\n         // For strings, precision is the maximum characters\n@@ -546,14 +546,14 @@ pub mod rt {\n             s\n           }\n         };\n-        unsafe { pad(cv, unpadded, None, PadNozero, buf) };\n+        pad(cv, unpadded, None, PadNozero, buf);\n     }\n     pub fn conv_float(cv: Conv, f: float, buf: &mut ~str) {\n         let (to_str, digits) = match cv.precision {\n               CountIs(c) => (float::to_str_exact, c as uint),\n               CountImplied => (float::to_str_digits, 6u)\n         };\n-        let mut s = unsafe { to_str(f, digits) };\n+        let mut s = to_str(f, digits);\n         let head = if 0.0 <= f {\n             if have_flag(cv.flags, flag_sign_always) {\n                 Some('+')\n@@ -563,7 +563,7 @@ pub mod rt {\n                 None\n             }\n         } else { None };\n-        unsafe { pad(cv, s, head, PadFloat, buf) };\n+        pad(cv, s, head, PadFloat, buf);\n     }\n     pub fn conv_poly<T>(cv: Conv, v: &T, buf: &mut ~str) {\n         let s = sys::log_str(v);"}, {"sha": "be776a39742f0073439576460beb12aac07f45dc", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9595d1737677dd61d9f52f674c34f13d708e39c/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=d9595d1737677dd61d9f52f674c34f13d708e39c", "patch": "@@ -44,7 +44,7 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n }\n \n #[lang=\"fail_bounds_check\"]\n-pub unsafe fn fail_bounds_check(file: *c_char, line: size_t,\n+pub fn fail_bounds_check(file: *c_char, line: size_t,\n                                 index: size_t, len: size_t) {\n     let msg = fmt!(\"index out of bounds: the len is %d but the index is %d\",\n                     len as int, index as int);\n@@ -53,7 +53,7 @@ pub unsafe fn fail_bounds_check(file: *c_char, line: size_t,\n     }\n }\n \n-pub unsafe fn fail_borrowed() {\n+pub fn fail_borrowed() {\n     let msg = \"borrowed\";\n     do str::as_buf(msg) |msg_p, _| {\n         do str::as_buf(\"???\") |file_p, _| {"}]}