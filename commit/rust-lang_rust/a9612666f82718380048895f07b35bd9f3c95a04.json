{"sha": "a9612666f82718380048895f07b35bd9f3c95a04", "node_id": "C_kwDOAAsO6NoAKGE5NjEyNjY2ZjgyNzE4MzgwMDQ4ODk1ZjA3YjM1YmQ5ZjNjOTVhMDQ", "commit": {"author": {"name": "Eduardo Canellas", "email": "eduardocanellas98@gmail.com", "date": "2022-01-04T18:03:46Z"}, "committer": {"name": "Eduardo Canellas", "email": "eduardocanellas98@gmail.com", "date": "2022-01-04T18:03:46Z"}, "message": "fix(completions): improve fn_param\n\n- insert commas around when necessary\n- only suggest `self` completions when param list is empty\n- stop suggesting completions for identifiers which are already on the param list", "tree": {"sha": "c069fd026f4286292496165fc6ed8fc353aa82f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c069fd026f4286292496165fc6ed8fc353aa82f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9612666f82718380048895f07b35bd9f3c95a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9612666f82718380048895f07b35bd9f3c95a04", "html_url": "https://github.com/rust-lang/rust/commit/a9612666f82718380048895f07b35bd9f3c95a04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9612666f82718380048895f07b35bd9f3c95a04/comments", "author": {"login": "dbofmmbt", "id": 34381457, "node_id": "MDQ6VXNlcjM0MzgxNDU3", "avatar_url": "https://avatars.githubusercontent.com/u/34381457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dbofmmbt", "html_url": "https://github.com/dbofmmbt", "followers_url": "https://api.github.com/users/dbofmmbt/followers", "following_url": "https://api.github.com/users/dbofmmbt/following{/other_user}", "gists_url": "https://api.github.com/users/dbofmmbt/gists{/gist_id}", "starred_url": "https://api.github.com/users/dbofmmbt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dbofmmbt/subscriptions", "organizations_url": "https://api.github.com/users/dbofmmbt/orgs", "repos_url": "https://api.github.com/users/dbofmmbt/repos", "events_url": "https://api.github.com/users/dbofmmbt/events{/privacy}", "received_events_url": "https://api.github.com/users/dbofmmbt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dbofmmbt", "id": 34381457, "node_id": "MDQ6VXNlcjM0MzgxNDU3", "avatar_url": "https://avatars.githubusercontent.com/u/34381457?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dbofmmbt", "html_url": "https://github.com/dbofmmbt", "followers_url": "https://api.github.com/users/dbofmmbt/followers", "following_url": "https://api.github.com/users/dbofmmbt/following{/other_user}", "gists_url": "https://api.github.com/users/dbofmmbt/gists{/gist_id}", "starred_url": "https://api.github.com/users/dbofmmbt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dbofmmbt/subscriptions", "organizations_url": "https://api.github.com/users/dbofmmbt/orgs", "repos_url": "https://api.github.com/users/dbofmmbt/repos", "events_url": "https://api.github.com/users/dbofmmbt/events{/privacy}", "received_events_url": "https://api.github.com/users/dbofmmbt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584", "html_url": "https://github.com/rust-lang/rust/commit/dbb1c1b4b1cd2fcd45755e5f043c7466a0001584"}], "stats": {"total": 99, "additions": 75, "deletions": 24}, "files": [{"sha": "e73e39d1367899eed24901caec706239adf2e00f", "filename": "crates/ide_completion/src/completions/fn_param.rs", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a9612666f82718380048895f07b35bd9f3c95a04/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9612666f82718380048895f07b35bd9f3c95a04/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=a9612666f82718380048895f07b35bd9f3c95a04", "patch": "@@ -3,7 +3,7 @@\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, HasModuleItem},\n-    match_ast, AstNode,\n+    match_ast, AstNode, SyntaxKind,\n };\n \n use crate::{\n@@ -16,24 +16,22 @@ use crate::{\n /// `spam: &mut Spam` insert text/label and `spam` lookup string will be\n /// suggested.\n pub(crate) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n-    if !matches!(ctx.pattern_ctx, Some(PatternContext { is_param: Some(ParamKind::Function), .. }))\n-    {\n+    let param_of_fn =\n+        matches!(ctx.pattern_ctx, Some(PatternContext { is_param: Some(ParamKind::Function), .. }));\n+\n+    if !param_of_fn {\n         return None;\n     }\n \n-    let mut params = FxHashMap::default();\n+    let mut file_params = FxHashMap::default();\n \n-    let me = ctx.token.ancestors().find_map(ast::Fn::cast);\n-    let mut process_fn = |func: ast::Fn| {\n-        if Some(&func) == me.as_ref() {\n-            return;\n-        }\n-        func.param_list().into_iter().flat_map(|it| it.params()).for_each(|param| {\n+    let mut extract_params = |f: ast::Fn| {\n+        f.param_list().into_iter().flat_map(|it| it.params()).for_each(|param| {\n             if let Some(pat) = param.pat() {\n                 // FIXME: We should be able to turn these into SmolStr without having to allocate a String\n-                let text = param.syntax().text().to_string();\n-                let lookup = pat.syntax().text().to_string();\n-                params.entry(text).or_insert(lookup);\n+                let whole_param = param.syntax().text().to_string();\n+                let binding = pat.syntax().text().to_string();\n+                file_params.entry(whole_param).or_insert(binding);\n             }\n         });\n     };\n@@ -44,32 +42,77 @@ pub(crate) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n                 ast::SourceFile(it) => it.items().filter_map(|item| match item {\n                     ast::Item::Fn(it) => Some(it),\n                     _ => None,\n-                }).for_each(&mut process_fn),\n+                }).for_each(&mut extract_params),\n                 ast::ItemList(it) => it.items().filter_map(|item| match item {\n                     ast::Item::Fn(it) => Some(it),\n                     _ => None,\n-                }).for_each(&mut process_fn),\n+                }).for_each(&mut extract_params),\n                 ast::AssocItemList(it) => it.assoc_items().filter_map(|item| match item {\n                     ast::AssocItem::Fn(it) => Some(it),\n                     _ => None,\n-                }).for_each(&mut process_fn),\n+                }).for_each(&mut extract_params),\n                 _ => continue,\n             }\n         };\n     }\n \n+    let function = ctx.token.ancestors().find_map(ast::Fn::cast)?;\n+    let param_list = function.param_list()?;\n+\n+    remove_duplicated(&mut file_params, param_list.params())?;\n+\n     let self_completion_items = [\"self\", \"&self\", \"mut self\", \"&mut self\"];\n-    if ctx.impl_def.is_some() && me?.param_list()?.params().next().is_none() {\n+    if should_add_self_completions(ctx, param_list) {\n         self_completion_items.into_iter().for_each(|self_item| {\n             add_new_item_to_acc(ctx, acc, self_item.to_string(), self_item.to_string())\n         });\n     }\n \n-    params.into_iter().for_each(|(label, lookup)| add_new_item_to_acc(ctx, acc, label, lookup));\n+    file_params.into_iter().try_for_each(|(whole_param, binding)| {\n+        Some(add_new_item_to_acc(ctx, acc, surround_with_commas(ctx, whole_param)?, binding))\n+    })?;\n \n     Some(())\n }\n \n+fn remove_duplicated(\n+    file_params: &mut FxHashMap<String, String>,\n+    mut fn_params: ast::AstChildren<ast::Param>,\n+) -> Option<()> {\n+    fn_params.try_for_each(|param| {\n+        let whole_param = param.syntax().text().to_string();\n+        file_params.remove(&whole_param);\n+\n+        let binding = param.pat()?.syntax().text().to_string();\n+\n+        file_params.retain(|_, v| v != &binding);\n+        Some(())\n+    })\n+}\n+\n+fn should_add_self_completions(ctx: &CompletionContext, param_list: ast::ParamList) -> bool {\n+    let inside_impl = ctx.impl_def.is_some();\n+    let no_params = param_list.params().next().is_none() && param_list.self_param().is_none();\n+\n+    inside_impl && no_params\n+}\n+\n+fn surround_with_commas(ctx: &CompletionContext, param: String) -> Option<String> {\n+    let end_of_param_list = matches!(ctx.token.next_token()?.kind(), SyntaxKind::R_PAREN);\n+    let trailing = if end_of_param_list { \"\" } else { \",\" };\n+\n+    let previous_token = if matches!(ctx.token.kind(), SyntaxKind::IDENT | SyntaxKind::WHITESPACE) {\n+        ctx.previous_token.as_ref()?\n+    } else {\n+        &ctx.token\n+    };\n+\n+    let needs_leading = !matches!(previous_token.kind(), SyntaxKind::L_PAREN | SyntaxKind::COMMA);\n+    let leading = if needs_leading { \", \" } else { \"\" };\n+\n+    Some(format!(\"{}{}{}\", leading, param, trailing))\n+}\n+\n fn add_new_item_to_acc(\n     ctx: &CompletionContext,\n     acc: &mut Completions,"}, {"sha": "940cecf395d87a36e9c93b5f0b89f9b7c1ae17a6", "filename": "crates/ide_completion/src/tests/fn_param.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9612666f82718380048895f07b35bd9f3c95a04/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9612666f82718380048895f07b35bd9f3c95a04/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs?ref=a9612666f82718380048895f07b35bd9f3c95a04", "patch": "@@ -46,7 +46,20 @@ fn bar(file_id: usize) {}\n fn baz(file$0 id: u32) {}\n \"#,\n         expect![[r#\"\n-            bn file_id: usize\n+            bn file_id: usize,\n+            kw mut\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn repeated_param_name() {\n+    check(\n+        r#\"\n+fn foo(file_id: usize) {}\n+fn bar(file_id: u32, $0) {}\n+\"#,\n+        expect![[r#\"\n             kw mut\n         \"#]],\n     );\n@@ -126,7 +139,6 @@ impl A {\n \n #[test]\n fn in_impl_after_self() {\n-    // FIXME: self completions should not be here\n     check(\n         r#\"\n struct A {}\n@@ -137,10 +149,6 @@ impl A {\n }\n \"#,\n         expect![[r#\"\n-            bn self\n-            bn &self\n-            bn mut self\n-            bn &mut self\n             bn file_id: usize\n             kw mut\n             sp Self"}]}