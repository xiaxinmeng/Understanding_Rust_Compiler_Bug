{"sha": "82fccb971e49d6d8945b7764dd9e9ed883f6148f", "node_id": "C_kwDOAAsO6NoAKDgyZmNjYjk3MWU0OWQ2ZDg5NDViNzc2NGRkOWU5ZWQ4ODNmNjE0OGY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-15T11:12:02Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-01-15T11:23:26Z"}, "message": "feat: Add very simplistic ident completion for format_args! macro input", "tree": {"sha": "9ba14f913b65f5619820d849cf7617a2e635b9ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ba14f913b65f5619820d849cf7617a2e635b9ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82fccb971e49d6d8945b7764dd9e9ed883f6148f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82fccb971e49d6d8945b7764dd9e9ed883f6148f", "html_url": "https://github.com/rust-lang/rust/commit/82fccb971e49d6d8945b7764dd9e9ed883f6148f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82fccb971e49d6d8945b7764dd9e9ed883f6148f/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c36102722e2764f3cb1bf1ed610c8f6aed186ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c36102722e2764f3cb1bf1ed610c8f6aed186ca", "html_url": "https://github.com/rust-lang/rust/commit/2c36102722e2764f3cb1bf1ed610c8f6aed186ca"}], "stats": {"total": 202, "additions": 163, "deletions": 39}, "files": [{"sha": "869f4a10f84fe361077e602b032d8bd26da2449d", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -5,7 +5,10 @@\n //!\n //! So, this modules should not be used during hir construction, it exists\n //! purely for \"IDE needs\".\n-use std::{iter::once, sync::Arc};\n+use std::{\n+    iter::{self, once},\n+    sync::Arc,\n+};\n \n use hir_def::{\n     body::{\n@@ -25,7 +28,7 @@ use hir_ty::{\n };\n use syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode, TextRange, TextSize,\n+    SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{\n@@ -488,14 +491,20 @@ fn scope_for_offset(\n         .scope_by_expr()\n         .iter()\n         .filter_map(|(id, scope)| {\n-            let source = source_map.expr_syntax(*id).ok()?;\n-            // FIXME: correctly handle macro expansion\n-            if source.file_id != offset.file_id {\n-                return None;\n+            let InFile { file_id, value } = source_map.expr_syntax(*id).ok()?;\n+            if offset.file_id == file_id {\n+                let root = db.parse_or_expand(file_id)?;\n+                let node = value.to_node(&root);\n+                return Some((node.syntax().text_range(), scope));\n             }\n-            let root = source.file_syntax(db.upcast());\n-            let node = source.value.to_node(&root);\n-            Some((node.syntax().text_range(), scope))\n+\n+            // FIXME handle attribute expansion\n+            let source = iter::successors(file_id.call_node(db.upcast()), |it| {\n+                it.file_id.call_node(db.upcast())\n+            })\n+            .find(|it| it.file_id == offset.file_id)\n+            .filter(|it| it.value.kind() == SyntaxKind::MACRO_CALL)?;\n+            Some((source.value.text_range(), scope))\n         })\n         // find containing scope\n         .min_by_key(|(expr_range, _scope)| {"}, {"sha": "0aa97a6102030b98bf0b84a38a79852abd9a904d", "filename": "crates/ide/src/syntax_highlighting/format.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fformat.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -1,8 +1,8 @@\n //! Syntax highlighting for format macro strings.\n-use ide_db::SymbolKind;\n+use ide_db::{helpers::format_string::is_format_string, SymbolKind};\n use syntax::{\n     ast::{self, FormatSpecifier, HasFormatSpecifier},\n-    AstNode, AstToken, TextRange,\n+    TextRange,\n };\n \n use crate::{syntax_highlighting::highlights::Highlights, HlRange, HlTag};\n@@ -13,7 +13,7 @@ pub(super) fn highlight_format_string(\n     expanded_string: &ast::String,\n     range: TextRange,\n ) {\n-    if is_format_string(expanded_string).is_none() {\n+    if !is_format_string(expanded_string) {\n         return;\n     }\n \n@@ -28,32 +28,6 @@ pub(super) fn highlight_format_string(\n     });\n }\n \n-fn is_format_string(string: &ast::String) -> Option<()> {\n-    // Check if `string` is a format string argument of a macro invocation.\n-    // `string` is a string literal, mapped down into the innermost macro expansion.\n-    // Since `format_args!` etc. remove the format string when expanding, but place all arguments\n-    // in the expanded output, we know that the string token is (part of) the format string if it\n-    // appears in `format_args!` (otherwise it would have been mapped down further).\n-    //\n-    // This setup lets us correctly highlight the components of `concat!(\"{}\", \"bla\")` format\n-    // strings. It still fails for `concat!(\"{\", \"}\")`, but that is rare.\n-\n-    let macro_call = string.syntax().ancestors().find_map(ast::MacroCall::cast)?;\n-    let name = macro_call.path()?.segment()?.name_ref()?;\n-\n-    if !matches!(\n-        name.text().as_str(),\n-        \"format_args\" | \"format_args_nl\" | \"const_format_args\" | \"panic_2015\" | \"panic_2021\"\n-    ) {\n-        return None;\n-    }\n-\n-    // NB: we match against `panic_2015`/`panic_2021` here because they have a special-cased arm for\n-    // `\"{}\"`, which otherwise wouldn't get highlighted.\n-\n-    Some(())\n-}\n-\n fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HlTag> {\n     Some(match kind {\n         FormatSpecifier::Open"}, {"sha": "e399213731db84a87b25afb327056a35a6b69567", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -14,6 +14,7 @@ pub(crate) mod record;\n pub(crate) mod snippet;\n pub(crate) mod trait_impl;\n pub(crate) mod unqualified_path;\n+pub(crate) mod format_string;\n \n use std::iter;\n "}, {"sha": "08f5a59437f81f7d089dd07ccd2d3e8dc9aef4fd", "filename": "crates/ide_completion/src/completions/format_string.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -0,0 +1,107 @@\n+//! Completes identifiers in format string literals.\n+\n+use ide_db::helpers::format_string::is_format_string;\n+use itertools::Itertools;\n+use syntax::{ast, AstToken, TextRange, TextSize};\n+\n+use crate::{context::CompletionContext, CompletionItem, CompletionItemKind, Completions};\n+\n+/// Complete identifiers in format strings.\n+pub(crate) fn format_string(acc: &mut Completions, ctx: &CompletionContext) {\n+    let string = match ast::String::cast(ctx.token.clone()) {\n+        Some(it) if is_format_string(&it) => it,\n+        _ => return,\n+    };\n+    let cursor = ctx.position.offset;\n+    let lit_start = ctx.token.text_range().start();\n+    let cursor_in_lit = cursor - lit_start;\n+\n+    let prefix = &string.text()[..cursor_in_lit.into()];\n+    let braces = prefix.char_indices().rev().skip_while(|&(_, c)| c.is_alphanumeric()).next_tuple();\n+    let brace_offset = match braces {\n+        // escaped brace\n+        Some(((_, '{'), (_, '{'))) => return,\n+        Some(((idx, '{'), _)) => lit_start + TextSize::from(idx as u32 + 1),\n+        _ => return,\n+    };\n+\n+    let source_range = TextRange::new(brace_offset, cursor);\n+    ctx.locals.iter().for_each(|(name, _)| {\n+        CompletionItem::new(CompletionItemKind::Binding, source_range, name.to_smol_str())\n+            .add_to(acc);\n+    })\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+\n+    use crate::tests::{check_edit, completion_list_no_kw};\n+\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list_no_kw(ra_fixture);\n+        expect.assert_eq(&actual);\n+    }\n+\n+    #[test]\n+    fn no_completion_without_brace() {\n+        check(\n+            r#\"\n+macro_rules! format_args {\n+($lit:literal $(tt:tt)*) => { 0 },\n+}\n+fn main() {\n+let foobar = 1;\n+format_args!(\"f$0\");\n+}\n+\"#,\n+            expect![[]],\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_locals() {\n+        check_edit(\n+            \"foobar\",\n+            r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+fn main() {\n+    let foobar = 1;\n+    format_args!(\"{f$0\");\n+}\n+\"#,\n+            r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+fn main() {\n+    let foobar = 1;\n+    format_args!(\"{foobar\");\n+}\n+\"#,\n+        );\n+        check_edit(\n+            \"foobar\",\n+            r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+fn main() {\n+    let foobar = 1;\n+    format_args!(\"{$0\");\n+}\n+\"#,\n+            r#\"\n+macro_rules! format_args {\n+    ($lit:literal $(tt:tt)*) => { 0 },\n+}\n+fn main() {\n+    let foobar = 1;\n+    format_args!(\"{foobar\");\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "e8e0c7ea9f1d1b65d7e66e8a3a206d4bcefe3a09", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -179,7 +179,7 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n \n     postfix_snippet(\"box\", \"Box::new(expr)\", &format!(\"Box::new({})\", receiver_text)).add_to(acc);\n-    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({})\", receiver_text)).add_to(acc);\n+    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({})\", receiver_text)).add_to(acc); // fixme\n     postfix_snippet(\"dbgr\", \"dbg!(&expr)\", &format!(\"dbg!(&{})\", receiver_text)).add_to(acc);\n     postfix_snippet(\"call\", \"function(expr)\", &format!(\"${{1}}({})\", receiver_text)).add_to(acc);\n "}, {"sha": "a2217af493df216479e86840030552201ad53145", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -168,6 +168,7 @@ pub fn completions(\n     completions::flyimport::import_on_the_fly(&mut acc, &ctx);\n     completions::lifetime::complete_lifetime(&mut acc, &ctx);\n     completions::lifetime::complete_label(&mut acc, &ctx);\n+    completions::format_string::format_string(&mut acc, &ctx);\n \n     Some(acc)\n }"}, {"sha": "2d3d64093385c3ac2525ba66f80cf8a23530817b", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -7,6 +7,7 @@ pub mod merge_imports;\n pub mod insert_whitespace_into_node;\n pub mod node_ext;\n pub mod rust_doc;\n+pub mod format_string;\n \n use std::{collections::VecDeque, iter};\n "}, {"sha": "c615d07250ed153e647ef473a7dcdf10349f8be7", "filename": "crates/ide_db/src/helpers/format_string.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_db%2Fsrc%2Fhelpers%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82fccb971e49d6d8945b7764dd9e9ed883f6148f/crates%2Fide_db%2Fsrc%2Fhelpers%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fformat_string.rs?ref=82fccb971e49d6d8945b7764dd9e9ed883f6148f", "patch": "@@ -0,0 +1,31 @@\n+//! Tools to work with format string literals for the `format_args!` family of macros.\n+use syntax::{ast, AstNode, AstToken};\n+\n+pub fn is_format_string(string: &ast::String) -> bool {\n+    // Check if `string` is a format string argument of a macro invocation.\n+    // `string` is a string literal, mapped down into the innermost macro expansion.\n+    // Since `format_args!` etc. remove the format string when expanding, but place all arguments\n+    // in the expanded output, we know that the string token is (part of) the format string if it\n+    // appears in `format_args!` (otherwise it would have been mapped down further).\n+    //\n+    // This setup lets us correctly highlight the components of `concat!(\"{}\", \"bla\")` format\n+    // strings. It still fails for `concat!(\"{\", \"}\")`, but that is rare.\n+\n+    (|| {\n+        let macro_call = string.syntax().ancestors().find_map(ast::MacroCall::cast)?;\n+        let name = macro_call.path()?.segment()?.name_ref()?;\n+\n+        if !matches!(\n+            name.text().as_str(),\n+            \"format_args\" | \"format_args_nl\" | \"const_format_args\" | \"panic_2015\" | \"panic_2021\"\n+        ) {\n+            return None;\n+        }\n+\n+        // NB: we match against `panic_2015`/`panic_2021` here because they have a special-cased arm for\n+        // `\"{}\"`, which otherwise wouldn't get highlighted.\n+\n+        Some(())\n+    })()\n+    .is_some()\n+}"}]}