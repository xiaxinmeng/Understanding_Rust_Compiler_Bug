{"sha": "e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "node_id": "C_kwDOAAsO6NoAKGU3YTAwODhiMmYzNDhjN2Y4ZjhhMTFjYmIyNWM1ZjE2OTZkNDU0OGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T15:32:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-17T15:32:32Z"}, "message": "Auto merge of #12565 - Veykril:completion, r=Veykril\n\ninternal: More completion refactors", "tree": {"sha": "96225a3e4382afdb7d64a4ae25df97516925e926", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96225a3e4382afdb7d64a4ae25df97516925e926"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "html_url": "https://github.com/rust-lang/rust/commit/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bea4ba08e08c0818258955867609deb0e36ca8de", "url": "https://api.github.com/repos/rust-lang/rust/commits/bea4ba08e08c0818258955867609deb0e36ca8de", "html_url": "https://github.com/rust-lang/rust/commit/bea4ba08e08c0818258955867609deb0e36ca8de"}, {"sha": "85b68b1f7dd9a1983a4bfa0b9ab0212aea18de42", "url": "https://api.github.com/repos/rust-lang/rust/commits/85b68b1f7dd9a1983a4bfa0b9ab0212aea18de42", "html_url": "https://github.com/rust-lang/rust/commit/85b68b1f7dd9a1983a4bfa0b9ab0212aea18de42"}], "stats": {"total": 195, "additions": 94, "deletions": 101}, "files": [{"sha": "fe5bdeec66209ee49a1a61c04a1a3b08f0359fc3", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -18,9 +18,7 @@ use syntax::{\n \n use crate::{\n     completions::module_or_attr,\n-    context::{\n-        CompletionContext, IdentContext, PathCompletionCtx, PathKind, PathQualifierCtx, Qualified,\n-    },\n+    context::{CompletionContext, IdentContext, PathCompletionCtx, PathKind, Qualified},\n     item::CompletionItem,\n     Completions,\n };\n@@ -84,7 +82,7 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n     };\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+        Qualified::With { resolution, is_super_chain, .. } => {\n             if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n@@ -112,6 +110,7 @@ pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n+        Qualified::Infer => {}\n     }\n \n     let attributes = annotated_item_kind.and_then(|kind| {"}, {"sha": "aefb986535ef9e933da441476f352a850a2652a1", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -5,21 +5,23 @@ use itertools::Itertools;\n use syntax::SmolStr;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx, Qualified},\n+    context::{CompletionContext, PathCompletionCtx, PathKind, Qualified},\n     item::CompletionItem,\n     Completions,\n };\n \n pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n-    let qualified = match ctx.path_context() {\n-        Some(&PathCompletionCtx { kind: PathKind::Derive, ref qualified, .. }) => qualified,\n+    let (qualified, existing_derives) = match ctx.path_context() {\n+        Some(PathCompletionCtx {\n+            kind: PathKind::Derive { existing_derives }, qualified, ..\n+        }) => (qualified, existing_derives),\n         _ => return,\n     };\n \n     let core = ctx.famous_defs().core();\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+        Qualified::With { resolution, is_super_chain, .. } => {\n             if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n@@ -32,7 +34,7 @@ pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n             for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                 let add_def = match def {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac)) => {\n-                        !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db)\n+                        !existing_derives.contains(&mac) && mac.is_derive(ctx.db)\n                     }\n                     ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) => true,\n                     _ => false,\n@@ -48,7 +50,7 @@ pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n             ctx.process_all_names(&mut |name, def| {\n                 let mac = match def {\n                     ScopeDef::ModuleDef(hir::ModuleDef::Macro(mac))\n-                        if !ctx.existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n+                        if !existing_derives.contains(&mac) && mac.is_derive(ctx.db) =>\n                     {\n                         mac\n                     }\n@@ -74,7 +76,7 @@ pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n                         let mut components = vec![derive_completion.label];\n                         components.extend(derive_completion.dependencies.iter().filter(\n                             |&&dependency| {\n-                                !ctx.existing_derives\n+                                !existing_derives\n                                     .iter()\n                                     .map(|it| it.name(ctx.db))\n                                     .any(|it| it.to_smol_str() == dependency)\n@@ -99,6 +101,7 @@ pub(crate) fn complete_derive(acc: &mut Completions, ctx: &CompletionContext) {\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n+        Qualified::Infer => {}\n     }\n }\n "}, {"sha": "fcd2144809e344ff5ff13d37f5c6c3731ed914e1", "filename": "crates/ide-completion/src/completions/expr.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fexpr.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -4,9 +4,7 @@ use hir::ScopeDef;\n use ide_db::FxHashSet;\n \n use crate::{\n-    context::{\n-        NameRefContext, NameRefKind, PathCompletionCtx, PathKind, PathQualifierCtx, Qualified,\n-    },\n+    context::{NameRefContext, NameRefKind, PathCompletionCtx, PathKind, Qualified},\n     CompletionContext, Completions,\n };\n \n@@ -61,15 +59,13 @@ pub(crate) fn complete_expr_path(acc: &mut Completions, ctx: &CompletionContext)\n     };\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx { is_infer_qualifier, resolution, .. }) => {\n-            if *is_infer_qualifier {\n-                ctx.traits_in_scope()\n-                    .0\n-                    .into_iter()\n-                    .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n-                    .for_each(|item| add_assoc_item(acc, ctx, item));\n-                return;\n-            }\n+        Qualified::Infer => ctx\n+            .traits_in_scope()\n+            .0\n+            .into_iter()\n+            .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n+            .for_each(|item| add_assoc_item(acc, ctx, item)),\n+        Qualified::With { resolution, .. } => {\n             let resolution = match resolution {\n                 Some(it) => it,\n                 None => return,"}, {"sha": "33ae365cff769f8218260943dd468910f728c894", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -120,7 +120,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n                         kind @ (PathKind::Expr { .. }\n                         | PathKind::Type { .. }\n                         | PathKind::Attr { .. }\n-                        | PathKind::Derive\n+                        | PathKind::Derive { .. }\n                         | PathKind::Pat),\n                     ..\n                 })),\n@@ -188,10 +188,10 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             (PathKind::Attr { .. }, ItemInNs::Macros(mac)) => mac.is_attr(ctx.db),\n             (PathKind::Attr { .. }, _) => false,\n \n-            (PathKind::Derive, ItemInNs::Macros(mac)) => {\n-                mac.is_derive(ctx.db) && !ctx.existing_derives.contains(&mac)\n+            (PathKind::Derive { existing_derives }, ItemInNs::Macros(mac)) => {\n+                mac.is_derive(ctx.db) && !existing_derives.contains(&mac)\n             }\n-            (PathKind::Derive, _) => false,\n+            (PathKind::Derive { .. }, _) => false,\n         }\n     };\n "}, {"sha": "2e03935086dfe32d7471f20c02ce78ab11ad0b84", "filename": "crates/ide-completion/src/completions/item_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -2,7 +2,7 @@\n \n use crate::{\n     completions::module_or_fn_macro,\n-    context::{ItemListKind, PathCompletionCtx, PathKind, PathQualifierCtx, Qualified},\n+    context::{ItemListKind, PathCompletionCtx, PathKind, Qualified},\n     CompletionContext, Completions,\n };\n \n@@ -44,7 +44,7 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n     }\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+        Qualified::With { resolution, is_super_chain, .. } => {\n             if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n                 for (name, def) in module.scope(ctx.db, Some(ctx.module)) {\n                     if let Some(def) = module_or_fn_macro(ctx.db, def) {\n@@ -66,7 +66,7 @@ pub(crate) fn complete_item_list(acc: &mut Completions, ctx: &CompletionContext)\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n-        Qualified::No => {}\n+        Qualified::Infer | Qualified::No => {}\n     }\n }\n "}, {"sha": "b2630798bbca69d40eca00fccd2a9fc25f9bb95c", "filename": "crates/ide-completion/src/completions/pattern.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -5,7 +5,7 @@ use ide_db::FxHashSet;\n use syntax::ast::Pat;\n \n use crate::{\n-    context::{PathCompletionCtx, PathQualifierCtx, PatternRefutability, Qualified},\n+    context::{PathCompletionCtx, PatternRefutability, Qualified},\n     CompletionContext, Completions,\n };\n \n@@ -114,7 +114,7 @@ fn pattern_path_completion(\n     PathCompletionCtx { qualified, .. }: &PathCompletionCtx,\n ) {\n     match qualified {\n-        Qualified::With(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+        Qualified::With { resolution, is_super_chain, .. } => {\n             if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n@@ -208,5 +208,6 @@ fn pattern_path_completion(\n \n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n+        Qualified::Infer => {}\n     }\n }"}, {"sha": "b6666ef1a4a844c2e678e87dc400bc508ece4bfa", "filename": "crates/ide-completion/src/completions/type.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ftype.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -5,10 +5,7 @@ use ide_db::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    context::{\n-        PathCompletionCtx, PathKind, PathQualifierCtx, Qualified, TypeAscriptionTarget,\n-        TypeLocation,\n-    },\n+    context::{PathCompletionCtx, PathKind, Qualified, TypeAscriptionTarget, TypeLocation},\n     render::render_type_inference,\n     CompletionContext, Completions,\n };\n@@ -55,15 +52,13 @@ pub(crate) fn complete_type_path(acc: &mut Completions, ctx: &CompletionContext)\n     };\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx { is_infer_qualifier, resolution, .. }) => {\n-            if *is_infer_qualifier {\n-                ctx.traits_in_scope()\n-                    .0\n-                    .into_iter()\n-                    .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n-                    .for_each(|item| add_assoc_item(acc, item));\n-                return;\n-            }\n+        Qualified::Infer => ctx\n+            .traits_in_scope()\n+            .0\n+            .into_iter()\n+            .flat_map(|it| hir::Trait::from(it).items(ctx.sema.db))\n+            .for_each(|item| add_assoc_item(acc, item)),\n+        Qualified::With { resolution, .. } => {\n             let resolution = match resolution {\n                 Some(it) => it,\n                 None => return,"}, {"sha": "64fa426395945d8ebe3ee9cacfc0e0ee0e4801d6", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -6,31 +6,30 @@ use syntax::{ast, AstNode};\n \n use crate::{\n     context::{\n-        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind,\n-        PathQualifierCtx, Qualified,\n+        CompletionContext, NameRefContext, NameRefKind, PathCompletionCtx, PathKind, Qualified,\n     },\n     item::Builder,\n     CompletionItem, CompletionItemKind, CompletionRelevance, Completions,\n };\n \n pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (qualified, name_ref) = match ctx.nameref_ctx() {\n+    let (qualified, name_ref, use_tree_parent) = match ctx.nameref_ctx() {\n         Some(NameRefContext {\n-            kind: Some(NameRefKind::Path(PathCompletionCtx { kind: PathKind::Use, qualified, .. })),\n+            kind:\n+                Some(NameRefKind::Path(PathCompletionCtx {\n+                    kind: PathKind::Use,\n+                    qualified,\n+                    use_tree_parent,\n+                    ..\n+                })),\n             nameref,\n             ..\n-        }) => (qualified, nameref),\n+        }) => (qualified, nameref, use_tree_parent),\n         _ => return,\n     };\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx {\n-            path,\n-            resolution,\n-            is_super_chain,\n-            use_tree_parent,\n-            ..\n-        }) => {\n+        Qualified::With { path, resolution, is_super_chain } => {\n             if *is_super_chain {\n                 acc.add_keyword(ctx, \"super::\");\n             }\n@@ -136,5 +135,6 @@ pub(crate) fn complete_use_tree(acc: &mut Completions, ctx: &CompletionContext)\n             });\n             acc.add_nameref_keywords_with_colon(ctx);\n         }\n+        Qualified::Infer => {}\n     }\n }"}, {"sha": "319976737e899c2f9012dc9463887630a4bf6a77", "filename": "crates/ide-completion/src/completions/vis.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fvis.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -3,7 +3,7 @@\n use hir::ScopeDef;\n \n use crate::{\n-    context::{CompletionContext, PathCompletionCtx, PathKind, PathQualifierCtx, Qualified},\n+    context::{CompletionContext, PathCompletionCtx, PathKind, Qualified},\n     Completions,\n };\n \n@@ -16,7 +16,7 @@ pub(crate) fn complete_vis_path(acc: &mut Completions, ctx: &CompletionContext)\n     };\n \n     match qualified {\n-        Qualified::With(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+        Qualified::With { resolution, is_super_chain, .. } => {\n             // Try completing next child module of the path that is still a parent of the current module\n             if let Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))) = resolution {\n                 let next_towards_current = ctx\n@@ -37,7 +37,7 @@ pub(crate) fn complete_vis_path(acc: &mut Completions, ctx: &CompletionContext)\n                 acc.add_keyword(ctx, \"super::\");\n             }\n         }\n-        Qualified::Absolute => {}\n+        Qualified::Absolute | Qualified::Infer => {}\n         Qualified::No => {\n             if !has_in_token {\n                 cov_mark::hit!(kw_completion_in);"}, {"sha": "6af24f87489c96edd0735da1fc19b81c63a36362", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -64,6 +64,8 @@ pub(crate) struct PathCompletionCtx {\n     pub(super) kind: PathKind,\n     /// Whether the path segment has type args or not.\n     pub(super) has_type_args: bool,\n+    /// Whether the qualifier comes from a use tree parent or not\n+    pub(crate) use_tree_parent: bool,\n }\n \n impl PathCompletionCtx {\n@@ -101,7 +103,9 @@ pub(super) enum PathKind {\n         kind: AttrKind,\n         annotated_item_kind: Option<SyntaxKind>,\n     },\n-    Derive,\n+    Derive {\n+        existing_derives: FxHashSet<hir::Macro>,\n+    },\n     /// Path in item position, that is inside an (Assoc)ItemList\n     Item {\n         kind: ItemListKind,\n@@ -147,24 +151,18 @@ pub(super) enum ItemListKind {\n #[derive(Debug)]\n pub(super) enum Qualified {\n     No,\n-    With(PathQualifierCtx),\n+    With {\n+        path: ast::Path,\n+        resolution: Option<PathResolution>,\n+        /// Whether this path consists solely of `super` segments\n+        is_super_chain: bool,\n+    },\n+    /// <_>::\n+    Infer,\n     /// Whether the path is an absolute path\n     Absolute,\n }\n \n-/// The path qualifier state of the path we are completing.\n-#[derive(Debug)]\n-pub(crate) struct PathQualifierCtx {\n-    pub(crate) path: ast::Path,\n-    pub(crate) resolution: Option<PathResolution>,\n-    /// Whether this path consists solely of `super` segments\n-    pub(crate) is_super_chain: bool,\n-    /// Whether the qualifier comes from a use tree parent or not\n-    pub(crate) use_tree_parent: bool,\n-    /// <_>\n-    pub(crate) is_infer_qualifier: bool,\n-}\n-\n /// The state of the pattern we are completing.\n #[derive(Debug)]\n pub(super) struct PatternContext {\n@@ -318,22 +316,23 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) expected_type: Option<Type>,\n \n     /// The parent function of the cursor position if it exists.\n+    // FIXME: This probably doesn't belong here\n     pub(super) function_def: Option<ast::Fn>,\n     /// The parent impl of the cursor position if it exists.\n+    // FIXME: This probably doesn't belong here\n     pub(super) impl_def: Option<ast::Impl>,\n     /// Are we completing inside a let statement with a missing semicolon?\n     // FIXME: This should be part of PathKind::Expr\n     pub(super) incomplete_let: bool,\n \n+    // FIXME: This shouldn't exist\n     pub(super) previous_token: Option<SyntaxToken>,\n \n     pub(super) ident_ctx: IdentContext,\n \n     pub(super) pattern_ctx: Option<PatternContext>,\n     pub(super) qualifier_ctx: QualifierCtx,\n \n-    pub(super) existing_derives: FxHashSet<hir::Macro>,\n-\n     pub(super) locals: FxHashMap<Name, Local>,\n }\n \n@@ -354,6 +353,7 @@ impl<'a> CompletionContext<'a> {\n         }\n     }\n \n+    // FIXME: This shouldn't exist\n     pub(crate) fn previous_token_is(&self, kind: SyntaxKind) -> bool {\n         self.previous_token.as_ref().map_or(false, |tok| tok.kind() == kind)\n     }\n@@ -406,7 +406,7 @@ impl<'a> CompletionContext<'a> {\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n         self.path_context().and_then(|it| match &it.qualified {\n-            Qualified::With(it) => Some(&it.path),\n+            Qualified::With { path, .. } => Some(path),\n             _ => None,\n         })\n     }\n@@ -556,7 +556,6 @@ impl<'a> CompletionContext<'a> {\n             ident_ctx: IdentContext::UnexpandedAttrTT { fake_attribute_under_caret: None },\n             pattern_ctx: None,\n             qualifier_ctx: Default::default(),\n-            existing_derives: Default::default(),\n             locals,\n         };\n         ctx.expand_and_fill("}, {"sha": "25b384d32380256de1e4cc575d6532395615fafa", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=e7a0088b2f348c7f8f8a11cbb25c5f1696d4548a", "patch": "@@ -13,8 +13,8 @@ use syntax::{\n use crate::context::{\n     CompletionContext, DotAccess, DotAccessKind, IdentContext, ItemListKind, LifetimeContext,\n     LifetimeKind, NameContext, NameKind, NameRefContext, NameRefKind, ParamKind, PathCompletionCtx,\n-    PathKind, PathQualifierCtx, PatternContext, PatternRefutability, Qualified, QualifierCtx,\n-    TypeAscriptionTarget, TypeLocation, COMPLETION_MARKER,\n+    PathKind, PatternContext, PatternRefutability, Qualified, QualifierCtx, TypeAscriptionTarget,\n+    TypeLocation, COMPLETION_MARKER,\n };\n \n impl<'a> CompletionContext<'a> {\n@@ -339,22 +339,22 @@ impl<'a> CompletionContext<'a> {\n \n         // Overwrite the path kind for derives\n         if let Some((original_file, file_with_fake_ident, offset, origin_attr)) = derive_ctx {\n-            self.existing_derives = self\n-                .sema\n-                .resolve_derive_macro(&origin_attr)\n-                .into_iter()\n-                .flatten()\n-                .flatten()\n-                .collect();\n-\n             if let Some(ast::NameLike::NameRef(name_ref)) =\n                 find_node_at_offset(&file_with_fake_ident, offset)\n             {\n                 let parent = name_ref.syntax().parent()?;\n                 let (mut nameref_ctx, _, _) =\n                     Self::classify_name_ref(&self.sema, &original_file, name_ref, parent);\n                 if let Some(NameRefKind::Path(path_ctx)) = &mut nameref_ctx.kind {\n-                    path_ctx.kind = PathKind::Derive;\n+                    path_ctx.kind = PathKind::Derive {\n+                        existing_derives: self\n+                            .sema\n+                            .resolve_derive_macro(&origin_attr)\n+                            .into_iter()\n+                            .flatten()\n+                            .flatten()\n+                            .collect(),\n+                    };\n                 }\n                 self.ident_ctx = IdentContext::NameRef(nameref_ctx);\n                 return Some(());\n@@ -589,6 +589,7 @@ impl<'a> CompletionContext<'a> {\n             parent: path.parent_path(),\n             kind: PathKind::Item { kind: ItemListKind::SourceFile },\n             has_type_args: false,\n+            use_tree_parent: false,\n         };\n \n         let is_in_block = |it: &SyntaxNode| {\n@@ -853,6 +854,7 @@ impl<'a> CompletionContext<'a> {\n \n         // calculate the qualifier context\n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n+            path_ctx.use_tree_parent = use_tree_parent;\n             if !use_tree_parent && segment.coloncolon_token().is_some() {\n                 path_ctx.qualified = Qualified::Absolute;\n             } else {\n@@ -861,10 +863,6 @@ impl<'a> CompletionContext<'a> {\n                     .and_then(|it| find_node_in_file(original_file, &it))\n                     .map(|it| it.parent_path());\n                 if let Some(path) = path {\n-                    let res = sema.resolve_path(&path);\n-                    let is_super_chain = iter::successors(Some(path.clone()), |p| p.qualifier())\n-                        .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n-\n                     // `<_>::$0`\n                     let is_infer_qualifier = path.qualifier().is_none()\n                         && matches!(\n@@ -875,13 +873,15 @@ impl<'a> CompletionContext<'a> {\n                             })\n                         );\n \n-                    path_ctx.qualified = Qualified::With(PathQualifierCtx {\n-                        path,\n-                        resolution: res,\n-                        is_super_chain,\n-                        use_tree_parent,\n-                        is_infer_qualifier,\n-                    })\n+                    path_ctx.qualified = if is_infer_qualifier {\n+                        Qualified::Infer\n+                    } else {\n+                        let res = sema.resolve_path(&path);\n+                        let is_super_chain =\n+                            iter::successors(Some(path.clone()), |p| p.qualifier())\n+                                .all(|p| p.segment().and_then(|s| s.super_token()).is_some());\n+                        Qualified::With { path, resolution: res, is_super_chain }\n+                    }\n                 };\n             }\n         } else if let Some(segment) = path.segment() {"}]}