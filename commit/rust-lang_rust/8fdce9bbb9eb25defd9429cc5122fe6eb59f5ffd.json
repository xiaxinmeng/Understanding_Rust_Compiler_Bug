{"sha": "8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZGNlOWJiYjllYjI1ZGVmZDk0MjljYzUxMjJmZTZlYjU5ZjVmZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-23T23:10:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-23T23:10:33Z"}, "message": "Auto merge of #74489 - jyn514:assoc-items, r=manishearth,petrochenkov\n\nFix intra-doc links for associated items\n\n@Manishearth and I found that links of the following sort are broken:\n```rust\n$ cat str_from.rs\n/// [`String::from`]\npub fn foo() {}\n$ rustdoc str_from.rs\nwarning: `[String::from]` cannot be resolved, ignoring it.\n --> str_from.rs:4:6\n  |\n4 | /// [`String::from`]\n  |      ^^^^^^^^^^^^^^ cannot be resolved, ignoring\n```\nIt turns out this is because the current implementation only looks at inherent impls (`impl Bar {}`) and traits _for the item being documented_. Note that this is not the same as the item being _linked_ to. So this code would work:\n\n```rust\npub trait T1 {\n    fn method();\n}\n\npub struct S;\nimpl T1 for S {\n    /// [S::method] on method\n    fn method() {}\n}\n```\n\nbut putting the documentation on `trait T1` would not.\n\n~~I realized that writing it up that my fix is only partially correct: It removes the inherent impls code when it should instead remove the `trait_item` code.~~ Fixed.\n\nAdditionally, I discovered while writing this there is some ambiguity: you could have multiple methods with the same name, but for different traits:\n\n```rust\npub trait T1 {\n    fn method();\n}\n\npub trait T2 {\n    fn method();\n}\n\n/// See [S::method]\npub struct S;\n```\n\nRustdoc should give an ambiguity error here, but since there is currently no way to disambiguate the traits (https://github.com/rust-lang/rust/issues/74563) it does not (https://github.com/rust-lang/rust/pull/74489#issuecomment-673878404).\n\nThere is a _third_ ambiguity that pops up: What if the trait is generic and is implemented multiple times with different generic parameters? In this case, my fix does not do very well: it thinks there is only one trait instantiated and links to that trait:\n\n```\n/// [`String::from`] -- this resolves to https://doc.rust-lang.org/nightly/alloc/string/struct.String.html#method.from\npub fn foo() {}\n```\n\nHowever, every `From` implementation has a method called `from`! So the browser picks a random one. This is not the desired behavior, but it's not clear how to avoid it.\n\nTo be consistent with the rest of intra-doc links, this only resolves associated items from traits that are in scope. This required changes to rustc_resolve to work cross-crate; the relevant commits are prefixed with `resolve: `. As a bonus, considering only traits in scope is slightly faster. To avoid re-calculating the traits over and over, rustdoc uses a cache to store the traits in scope for a given module.", "tree": {"sha": "4967006a0c165333603255797dca21e6a63e6428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4967006a0c165333603255797dca21e6a63e6428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "html_url": "https://github.com/rust-lang/rust/commit/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5180f3da5fd72627a8d38558ad1297df38793acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/5180f3da5fd72627a8d38558ad1297df38793acd", "html_url": "https://github.com/rust-lang/rust/commit/5180f3da5fd72627a8d38558ad1297df38793acd"}, {"sha": "d77eff21b97886a0829b784100846daf59df2f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/d77eff21b97886a0829b784100846daf59df2f39", "html_url": "https://github.com/rust-lang/rust/commit/d77eff21b97886a0829b784100846daf59df2f39"}], "stats": {"total": 654, "additions": 480, "deletions": 174}, "files": [{"sha": "d113eb22abadcefb864cb295aa4c7bec4cc6d2d1", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 15, "deletions": 80, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -8,7 +8,7 @@\n use RibKind::*;\n \n use crate::{path_names_to_string, BindingError, CrateLint, LexicalScopeBinding};\n-use crate::{Module, ModuleOrUniformRoot, NameBindingKind, ParentScope, PathResult};\n+use crate::{Module, ModuleOrUniformRoot, ParentScope, PathResult};\n use crate::{ResolutionError, Resolver, Segment, UseError};\n \n use rustc_ast::ptr::P;\n@@ -24,7 +24,6 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX};\n use rustc_hir::TraitCandidate;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n-use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n@@ -2342,95 +2341,31 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ident.span = ident.span.normalize_to_macros_2_0();\n         let mut search_module = self.parent_scope.module;\n         loop {\n-            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n+            self.r.get_traits_in_module_containing_item(\n+                ident,\n+                ns,\n+                search_module,\n+                &mut found_traits,\n+                &self.parent_scope,\n+            );\n             search_module =\n                 unwrap_or!(self.r.hygienic_lexical_parent(search_module, &mut ident.span), break);\n         }\n \n         if let Some(prelude) = self.r.prelude {\n             if !search_module.no_implicit_prelude {\n-                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n+                self.r.get_traits_in_module_containing_item(\n+                    ident,\n+                    ns,\n+                    prelude,\n+                    &mut found_traits,\n+                    &self.parent_scope,\n+                );\n             }\n         }\n \n         found_traits\n     }\n-\n-    fn get_traits_in_module_containing_item(\n-        &mut self,\n-        ident: Ident,\n-        ns: Namespace,\n-        module: Module<'a>,\n-        found_traits: &mut Vec<TraitCandidate>,\n-    ) {\n-        assert!(ns == TypeNS || ns == ValueNS);\n-        let mut traits = module.traits.borrow_mut();\n-        if traits.is_none() {\n-            let mut collected_traits = Vec::new();\n-            module.for_each_child(self.r, |_, name, ns, binding| {\n-                if ns != TypeNS {\n-                    return;\n-                }\n-                match binding.res() {\n-                    Res::Def(DefKind::Trait | DefKind::TraitAlias, _) => {\n-                        collected_traits.push((name, binding))\n-                    }\n-                    _ => (),\n-                }\n-            });\n-            *traits = Some(collected_traits.into_boxed_slice());\n-        }\n-\n-        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            // Traits have pseudo-modules that can be used to search for the given ident.\n-            if let Some(module) = binding.module() {\n-                let mut ident = ident;\n-                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n-                    continue;\n-                }\n-                if self\n-                    .r\n-                    .resolve_ident_in_module_unadjusted(\n-                        ModuleOrUniformRoot::Module(module),\n-                        ident,\n-                        ns,\n-                        &self.parent_scope,\n-                        false,\n-                        module.span,\n-                    )\n-                    .is_ok()\n-                {\n-                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                    let trait_def_id = module.def_id().unwrap();\n-                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-                }\n-            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n-                // For now, just treat all trait aliases as possible candidates, since we don't\n-                // know if the ident is somewhere in the transitive bounds.\n-                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                let trait_def_id = binding.res().def_id();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-            } else {\n-                bug!(\"candidate is not trait or trait alias?\")\n-            }\n-        }\n-    }\n-\n-    fn find_transitive_imports(\n-        &mut self,\n-        mut kind: &NameBindingKind<'_>,\n-        trait_name: Ident,\n-    ) -> SmallVec<[LocalDefId; 1]> {\n-        let mut import_ids = smallvec![];\n-        while let NameBindingKind::Import { import, binding, .. } = kind {\n-            let id = self.r.local_def_id(import.id);\n-            self.r.maybe_unused_trait_imports.insert(id);\n-            self.r.add_to_glob_map(&import, trait_name);\n-            import_ids.push(id);\n-            kind = &binding.kind;\n-        }\n-        import_ids\n-    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "f2319bfe64de8c02257f3fb0498ee77c3db1e01c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 115, "deletions": 1, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -43,9 +43,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n use rustc_middle::middle::cstore::{CrateStore, MetadataLoaderDyn};\n-use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, ResolverOutputs};\n+use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n@@ -54,6 +54,7 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n+use smallvec::{smallvec, SmallVec};\n use std::cell::{Cell, RefCell};\n use std::collections::BTreeSet;\n use std::{cmp, fmt, iter, ptr};\n@@ -521,6 +522,29 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n+    /// This modifies `self` in place. The traits will be stored in `self.traits`.\n+    fn ensure_traits<R>(&'a self, resolver: &mut R)\n+    where\n+        R: AsMut<Resolver<'a>>,\n+    {\n+        let mut traits = self.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            self.for_each_child(resolver, |_, name, ns, binding| {\n+                if ns != TypeNS {\n+                    return;\n+                }\n+                match binding.res() {\n+                    Res::Def(DefKind::Trait | DefKind::TraitAlias, _) => {\n+                        collected_traits.push((name, binding))\n+                    }\n+                    _ => (),\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+    }\n+\n     fn res(&self) -> Option<Res> {\n         match self.kind {\n             ModuleKind::Def(kind, def_id, _) => Some(Res::Def(kind, def_id)),\n@@ -1430,6 +1454,68 @@ impl<'a> Resolver<'a> {\n         self.crate_loader.postprocess(krate);\n     }\n \n+    fn get_traits_in_module_containing_item(\n+        &mut self,\n+        ident: Ident,\n+        ns: Namespace,\n+        module: Module<'a>,\n+        found_traits: &mut Vec<TraitCandidate>,\n+        parent_scope: &ParentScope<'a>,\n+    ) {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        module.ensure_traits(self);\n+        let traits = module.traits.borrow();\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(module.expansion, binding.span).is_none() {\n+                    continue;\n+                }\n+                if self\n+                    .resolve_ident_in_module_unadjusted(\n+                        ModuleOrUniformRoot::Module(module),\n+                        ident,\n+                        ns,\n+                        parent_scope,\n+                        false,\n+                        module.span,\n+                    )\n+                    .is_ok()\n+                {\n+                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+                }\n+            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                let trait_def_id = binding.res().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n+            }\n+        }\n+    }\n+\n+    fn find_transitive_imports(\n+        &mut self,\n+        mut kind: &NameBindingKind<'_>,\n+        trait_name: Ident,\n+    ) -> SmallVec<[LocalDefId; 1]> {\n+        let mut import_ids = smallvec![];\n+        while let NameBindingKind::Import { import, binding, .. } = kind {\n+            let id = self.local_def_id(import.id);\n+            self.maybe_unused_trait_imports.insert(id);\n+            self.add_to_glob_map(&import, trait_name);\n+            import_ids.push(id);\n+            kind = &binding.kind;\n+        }\n+        import_ids\n+    }\n+\n     fn new_module(\n         &self,\n         parent: Module<'a>,\n@@ -3039,6 +3125,34 @@ impl<'a> Resolver<'a> {\n         })\n     }\n \n+    /// This is equivalent to `get_traits_in_module_containing_item`, but without filtering by the associated item.\n+    ///\n+    /// This is used by rustdoc for intra-doc links.\n+    pub fn traits_in_scope(&mut self, module_id: DefId) -> Vec<TraitCandidate> {\n+        let module = self.get_module(module_id);\n+        module.ensure_traits(self);\n+        let traits = module.traits.borrow();\n+        let to_candidate =\n+            |this: &mut Self, &(trait_name, binding): &(Ident, &NameBinding<'_>)| TraitCandidate {\n+                def_id: binding.res().def_id(),\n+                import_ids: this.find_transitive_imports(&binding.kind, trait_name),\n+            };\n+\n+        let mut candidates: Vec<_> =\n+            traits.as_ref().unwrap().iter().map(|x| to_candidate(self, x)).collect();\n+\n+        if let Some(prelude) = self.prelude {\n+            if !module.no_implicit_prelude {\n+                prelude.ensure_traits(self);\n+                candidates.extend(\n+                    prelude.traits.borrow().as_ref().unwrap().iter().map(|x| to_candidate(self, x)),\n+                );\n+            }\n+        }\n+\n+        candidates\n+    }\n+\n     /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n     /// isn't something that can be returned because it can't be made to live that long,\n     /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,"}, {"sha": "932585918dfb3f1142cdf913893d21ba2bf61768", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -20,7 +20,7 @@ use rustc_hir::lang_items;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::stability;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{AssocKind, TyCtxt};\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -282,12 +282,21 @@ pub enum ItemEnum {\n }\n \n impl ItemEnum {\n-    pub fn is_associated(&self) -> bool {\n+    pub fn is_type_alias(&self) -> bool {\n         match *self {\n             ItemEnum::TypedefItem(_, _) | ItemEnum::AssocTypeItem(_, _) => true,\n             _ => false,\n         }\n     }\n+\n+    pub fn as_assoc_kind(&self) -> Option<AssocKind> {\n+        match *self {\n+            ItemEnum::AssocConstItem(..) => Some(AssocKind::Const),\n+            ItemEnum::AssocTypeItem(..) => Some(AssocKind::Type),\n+            ItemEnum::TyMethodItem(..) | ItemEnum::MethodItem(..) => Some(AssocKind::Fn),\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Clone, Debug)]"}, {"sha": "a2f6d33a27a0e10e0b29a97222a3adc001a053fd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -69,6 +69,11 @@ pub struct DocContext<'tcx> {\n     pub auto_traits: Vec<DefId>,\n     /// The options given to rustdoc that could be relevant to a pass.\n     pub render_options: RenderOptions,\n+    /// The traits in scope for a given module.\n+    ///\n+    /// See `collect_intra_doc_links::traits_implemented_by` for more details.\n+    /// `map<module, set<trait>>`\n+    pub module_trait_cache: RefCell<FxHashMap<DefId, FxHashSet<DefId>>>,\n }\n \n impl<'tcx> DocContext<'tcx> {\n@@ -510,6 +515,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                         .filter(|trait_def_id| tcx.trait_is_auto(*trait_def_id))\n                         .collect(),\n                     render_options,\n+                    module_trait_cache: RefCell::new(FxHashMap::default()),\n                 };\n                 debug!(\"crate: {:?}\", tcx.hir().krate());\n "}, {"sha": "d17961521c87d33f14b2899a8f2bd13978dbcf3d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -3612,7 +3612,7 @@ fn render_impl(\n         };\n \n         let (is_hidden, extra_class) =\n-            if (trait_.is_none() || item.doc_value().is_some() || item.inner.is_associated())\n+            if (trait_.is_none() || item.doc_value().is_some() || item.inner.is_type_alias())\n                 && !is_default_item\n             {\n                 (false, \"\")"}, {"sha": "2ed3d07974fcf74fbcee0d82bf19a5f01650e35e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 209, "deletions": 90, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -1,4 +1,5 @@\n use rustc_ast as ast;\n+use rustc_data_structures::stable_set::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtensionKind;\n use rustc_feature::UnstableFeatures;\n@@ -185,7 +186,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         current_item: &Option<String>,\n         parent_id: Option<DefId>,\n         extra_fragment: &Option<String>,\n-        item_opt: Option<&Item>,\n     ) -> Result<(Res, Option<String>), ErrorKind> {\n         let cx = self.cx;\n \n@@ -245,13 +245,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     return Err(ErrorKind::AnchorFailure(AnchorFailure::Primitive));\n                 }\n                 return Ok((prim, Some(path.to_owned())));\n-            } else {\n-                // If resolution failed, it may still be a method\n-                // because methods are not handled by the resolver\n-                // If so, bail when we're not looking for a value.\n-                if ns != ValueNS {\n-                    return Err(ErrorKind::ResolutionFailure);\n-                }\n             }\n \n             // Try looking for methods and associated items.\n@@ -299,65 +292,56 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 })\n                 .map_err(|_| ErrorKind::ResolutionFailure)?;\n             if let Res::Err = ty_res {\n-                return self.variant_field(path_str, current_item, module_id);\n+                return if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, current_item, module_id)\n+                } else {\n+                    Err(ErrorKind::ResolutionFailure)\n+                };\n             }\n             let ty_res = ty_res.map_id(|_| panic!(\"unexpected node_id\"));\n-            match ty_res {\n+            let res = match ty_res {\n                 Res::Def(\n                     DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias,\n                     did,\n                 ) => {\n+                    debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                     // Checks if item_name belongs to `impl SomeItem`\n-                    let impl_item = cx\n+                    let kind = cx\n                         .tcx\n                         .inherent_impls(did)\n                         .iter()\n-                        .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n-                        .find(|item| item.ident.name == item_name);\n-                    let trait_item = item_opt\n-                        .and_then(|item| self.cx.as_local_hir_id(item.def_id))\n-                        .and_then(|item_hir| {\n-                            // Checks if item_name belongs to `impl SomeTrait for SomeItem`\n-                            let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n-                            let item_parent = self.cx.tcx.hir().find(parent_hir);\n-                            match item_parent {\n-                                Some(hir::Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Impl { of_trait: Some(_), self_ty, .. },\n-                                    ..\n-                                })) => cx\n-                                    .tcx\n-                                    .associated_item_def_ids(self_ty.hir_id.owner)\n-                                    .iter()\n-                                    .map(|child| {\n-                                        let associated_item = cx.tcx.associated_item(*child);\n-                                        associated_item\n-                                    })\n-                                    .find(|child| child.ident.name == item_name),\n-                                _ => None,\n-                            }\n+                        .flat_map(|&imp| {\n+                            cx.tcx.associated_items(imp).find_by_name_and_namespace(\n+                                cx.tcx,\n+                                Ident::with_dummy_span(item_name),\n+                                ns,\n+                                imp,\n+                            )\n+                        })\n+                        .map(|item| item.kind)\n+                        // There should only ever be one associated item that matches from any inherent impl\n+                        .next()\n+                        // Check if item_name belongs to `impl SomeTrait for SomeItem`\n+                        // This gives precedence to `impl SomeItem`:\n+                        // Although having both would be ambiguous, use impl version for compat. sake.\n+                        // To handle that properly resolve() would have to support\n+                        // something like [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n+                        .or_else(|| {\n+                            let kind = resolve_associated_trait_item(\n+                                did, module_id, item_name, ns, &self.cx,\n+                            );\n+                            debug!(\"got associated item kind {:?}\", kind);\n+                            kind\n                         });\n-                    let item = match (impl_item, trait_item) {\n-                        (Some(from_impl), Some(_)) => {\n-                            // Although it's ambiguous, return impl version for compat. sake.\n-                            // To handle that properly resolve() would have to support\n-                            // something like\n-                            // [`ambi_fn`](<SomeStruct as SomeTrait>::ambi_fn)\n-                            Some(from_impl)\n-                        }\n-                        (None, Some(from_trait)) => Some(from_trait),\n-                        (Some(from_impl), None) => Some(from_impl),\n-                        _ => None,\n-                    };\n-\n-                    if let Some(item) = item {\n-                        let out = match item.kind {\n-                            ty::AssocKind::Fn if ns == ValueNS => \"method\",\n-                            ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n-                            ty::AssocKind::Type if ns == ValueNS => \"associatedtype\",\n-                            _ => return self.variant_field(path_str, current_item, module_id),\n+\n+                    if let Some(kind) = kind {\n+                        let out = match kind {\n+                            ty::AssocKind::Fn => \"method\",\n+                            ty::AssocKind::Const => \"associatedconstant\",\n+                            ty::AssocKind::Type => \"associatedtype\",\n                         };\n-                        if extra_fragment.is_some() {\n-                            Err(ErrorKind::AnchorFailure(if item.kind == ty::AssocKind::Fn {\n+                        Some(if extra_fragment.is_some() {\n+                            Err(ErrorKind::AnchorFailure(if kind == ty::AssocKind::Fn {\n                                 AnchorFailure::Method\n                             } else {\n                                 AnchorFailure::AssocConstant\n@@ -366,20 +350,21 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             // HACK(jynelson): `clean` expects the type, not the associated item.\n                             // but the disambiguator logic expects the associated item.\n                             // Store the kind in a side channel so that only the disambiguator logic looks at it.\n-                            self.kind_side_channel.replace(Some(item.kind.as_def_kind()));\n+                            self.kind_side_channel.set(Some(kind.as_def_kind()));\n                             Ok((ty_res, Some(format!(\"{}.{}\", out, item_name))))\n-                        }\n-                    } else {\n+                        })\n+                    } else if ns == Namespace::ValueNS {\n                         match cx.tcx.type_of(did).kind {\n                             ty::Adt(def, _) => {\n-                                if let Some(item) = if def.is_enum() {\n+                                let field = if def.is_enum() {\n                                     def.all_fields().find(|item| item.ident.name == item_name)\n                                 } else {\n                                     def.non_enum_variant()\n                                         .fields\n                                         .iter()\n                                         .find(|item| item.ident.name == item_name)\n-                                } {\n+                                };\n+                                field.map(|item| {\n                                     if extra_fragment.is_some() {\n                                         Err(ErrorKind::AnchorFailure(if def.is_enum() {\n                                             AnchorFailure::Variant\n@@ -400,31 +385,31 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                             )),\n                                         ))\n                                     }\n-                                } else {\n-                                    self.variant_field(path_str, current_item, module_id)\n-                                }\n+                                })\n                             }\n-                            _ => self.variant_field(path_str, current_item, module_id),\n+                            _ => None,\n                         }\n+                    } else {\n+                        // We already know this isn't in ValueNS, so no need to check variant_field\n+                        return Err(ErrorKind::ResolutionFailure);\n                     }\n                 }\n-                Res::Def(DefKind::Trait, did) => {\n-                    let item = cx\n-                        .tcx\n-                        .associated_item_def_ids(did)\n-                        .iter()\n-                        .map(|item| cx.tcx.associated_item(*item))\n-                        .find(|item| item.ident.name == item_name);\n-                    if let Some(item) = item {\n-                        let kind =\n-                            match item.kind {\n-                                ty::AssocKind::Const if ns == ValueNS => \"associatedconstant\",\n-                                ty::AssocKind::Type if ns == TypeNS => \"associatedtype\",\n-                                ty::AssocKind::Fn if ns == ValueNS => {\n-                                    if item.defaultness.has_value() { \"method\" } else { \"tymethod\" }\n+                Res::Def(DefKind::Trait, did) => cx\n+                    .tcx\n+                    .associated_items(did)\n+                    .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, did)\n+                    .map(|item| {\n+                        let kind = match item.kind {\n+                            ty::AssocKind::Const => \"associatedconstant\",\n+                            ty::AssocKind::Type => \"associatedtype\",\n+                            ty::AssocKind::Fn => {\n+                                if item.defaultness.has_value() {\n+                                    \"method\"\n+                                } else {\n+                                    \"tymethod\"\n                                 }\n-                                _ => return self.variant_field(path_str, current_item, module_id),\n-                            };\n+                            }\n+                        };\n \n                         if extra_fragment.is_some() {\n                             Err(ErrorKind::AnchorFailure(if item.kind == ty::AssocKind::Const {\n@@ -438,19 +423,151 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                             let res = Res::Def(item.kind.as_def_kind(), item.def_id);\n                             Ok((res, Some(format!(\"{}.{}\", kind, item_name))))\n                         }\n-                    } else {\n-                        self.variant_field(path_str, current_item, module_id)\n-                    }\n+                    }),\n+                _ => None,\n+            };\n+            res.unwrap_or_else(|| {\n+                if ns == Namespace::ValueNS {\n+                    self.variant_field(path_str, current_item, module_id)\n+                } else {\n+                    Err(ErrorKind::ResolutionFailure)\n                 }\n-                _ => self.variant_field(path_str, current_item, module_id),\n-            }\n+            })\n         } else {\n             debug!(\"attempting to resolve item without parent module: {}\", path_str);\n             Err(ErrorKind::ResolutionFailure)\n         }\n     }\n }\n \n+fn resolve_associated_trait_item(\n+    did: DefId,\n+    module: DefId,\n+    item_name: Symbol,\n+    ns: Namespace,\n+    cx: &DocContext<'_>,\n+) -> Option<ty::AssocKind> {\n+    let ty = cx.tcx.type_of(did);\n+    // First consider automatic impls: `impl From<T> for T`\n+    let implicit_impls = crate::clean::get_auto_trait_and_blanket_impls(cx, ty, did);\n+    let mut candidates: Vec<_> = implicit_impls\n+        .flat_map(|impl_outer| {\n+            match impl_outer.inner {\n+                ImplItem(impl_) => {\n+                    debug!(\"considering auto or blanket impl for trait {:?}\", impl_.trait_);\n+                    // Give precedence to methods that were overridden\n+                    if !impl_.provided_trait_methods.contains(&*item_name.as_str()) {\n+                        let mut items = impl_.items.into_iter().filter_map(|assoc| {\n+                            if assoc.name.as_deref() != Some(&*item_name.as_str()) {\n+                                return None;\n+                            }\n+                            let kind = assoc\n+                                .inner\n+                                .as_assoc_kind()\n+                                .expect(\"inner items for a trait should be associated items\");\n+                            if kind.namespace() != ns {\n+                                return None;\n+                            }\n+\n+                            trace!(\"considering associated item {:?}\", assoc.inner);\n+                            // We have a slight issue: normal methods come from `clean` types,\n+                            // but provided methods come directly from `tcx`.\n+                            // Fortunately, we don't need the whole method, we just need to know\n+                            // what kind of associated item it is.\n+                            Some((assoc.def_id, kind))\n+                        });\n+                        let assoc = items.next();\n+                        debug_assert_eq!(items.count(), 0);\n+                        assoc\n+                    } else {\n+                        // These are provided methods or default types:\n+                        // ```\n+                        // trait T {\n+                        //   type A = usize;\n+                        //   fn has_default() -> A { 0 }\n+                        // }\n+                        // ```\n+                        let trait_ = impl_.trait_.unwrap().def_id().unwrap();\n+                        cx.tcx\n+                            .associated_items(trait_)\n+                            .find_by_name_and_namespace(\n+                                cx.tcx,\n+                                Ident::with_dummy_span(item_name),\n+                                ns,\n+                                trait_,\n+                            )\n+                            .map(|assoc| (assoc.def_id, assoc.kind))\n+                    }\n+                }\n+                _ => panic!(\"get_impls returned something that wasn't an impl\"),\n+            }\n+        })\n+        .collect();\n+\n+    // Next consider explicit impls: `impl MyTrait for MyType`\n+    // Give precedence to inherent impls.\n+    if candidates.is_empty() {\n+        let traits = traits_implemented_by(cx, did, module);\n+        debug!(\"considering traits {:?}\", traits);\n+        candidates.extend(traits.iter().filter_map(|&trait_| {\n+            cx.tcx\n+                .associated_items(trait_)\n+                .find_by_name_and_namespace(cx.tcx, Ident::with_dummy_span(item_name), ns, trait_)\n+                .map(|assoc| (assoc.def_id, assoc.kind))\n+        }));\n+    }\n+    // FIXME: warn about ambiguity\n+    debug!(\"the candidates were {:?}\", candidates);\n+    candidates.pop().map(|(_, kind)| kind)\n+}\n+\n+/// Given a type, return all traits in scope in `module` implemented by that type.\n+///\n+/// NOTE: this cannot be a query because more traits could be available when more crates are compiled!\n+/// So it is not stable to serialize cross-crate.\n+fn traits_implemented_by(cx: &DocContext<'_>, type_: DefId, module: DefId) -> FxHashSet<DefId> {\n+    let mut cache = cx.module_trait_cache.borrow_mut();\n+    let in_scope_traits = cache.entry(module).or_insert_with(|| {\n+        cx.enter_resolver(|resolver| {\n+            resolver.traits_in_scope(module).into_iter().map(|candidate| candidate.def_id).collect()\n+        })\n+    });\n+\n+    let ty = cx.tcx.type_of(type_);\n+    let iter = in_scope_traits.iter().flat_map(|&trait_| {\n+        trace!(\"considering explicit impl for trait {:?}\", trait_);\n+        let mut saw_impl = false;\n+        // Look at each trait implementation to see if it's an impl for `did`\n+        cx.tcx.for_each_relevant_impl(trait_, ty, |impl_| {\n+            // FIXME: this is inefficient, find a way to short-circuit for_each_* so this doesn't take as long\n+            if saw_impl {\n+                return;\n+            }\n+\n+            let trait_ref = cx.tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n+            // Check if these are the same type.\n+            let impl_type = trait_ref.self_ty();\n+            debug!(\n+                \"comparing type {} with kind {:?} against type {:?}\",\n+                impl_type, impl_type.kind, type_\n+            );\n+            // Fast path: if this is a primitive simple `==` will work\n+            saw_impl = impl_type == ty\n+                || match impl_type.kind {\n+                    // Check if these are the same def_id\n+                    ty::Adt(def, _) => {\n+                        debug!(\"adt def_id: {:?}\", def.did);\n+                        def.did == type_\n+                    }\n+                    ty::Foreign(def_id) => def_id == type_,\n+                    _ => false,\n+                };\n+        });\n+        if saw_impl { Some(trait_) } else { None }\n+    });\n+    iter.collect()\n+}\n+\n /// Check for resolve collisions between a trait and its derive\n ///\n /// These are common and we should just resolve to the trait in that case\n@@ -644,7 +761,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             &current_item,\n                             base_node,\n                             &extra_fragment,\n-                            Some(&item),\n                         ) {\n                             Ok(res) => res,\n                             Err(ErrorKind::ResolutionFailure) => {\n@@ -673,13 +789,16 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 &current_item,\n                                 base_node,\n                                 &extra_fragment,\n-                                Some(&item),\n                             ) {\n+                                Ok(res) => {\n+                                    debug!(\"got res in TypeNS: {:?}\", res);\n+                                    Some(res)\n+                                }\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                x => x.ok(),\n+                                Err(ErrorKind::ResolutionFailure) => None,\n                             },\n                             value_ns: match self.resolve(\n                                 path_str,\n@@ -688,13 +807,13 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 &current_item,\n                                 base_node,\n                                 &extra_fragment,\n-                                Some(&item),\n                             ) {\n+                                Ok(res) => Some(res),\n                                 Err(ErrorKind::AnchorFailure(msg)) => {\n                                     anchor_failure(cx, &item, &ori_link, &dox, link_range, msg);\n                                     continue;\n                                 }\n-                                x => x.ok(),\n+                                Err(ErrorKind::ResolutionFailure) => None,\n                             }\n                             .and_then(|(res, fragment)| {\n                                 // Constructors are picked up in the type namespace."}, {"sha": "c5bb4305db7ec724fdb73598957d2a574ce5e009", "filename": "src/test/rustdoc-ui/assoc-item-not-in-scope.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -0,0 +1,22 @@\n+#![deny(broken_intra_doc_links)]\n+\n+#[derive(Debug)]\n+/// Link to [`S::fmt`]\n+//~^ ERROR unresolved link\n+pub struct S;\n+\n+pub mod inner {\n+    use std::fmt::Debug;\n+    use super::S;\n+\n+    /// Link to [`S::fmt`]\n+    pub fn f() {}\n+}\n+\n+pub mod ambiguous {\n+    use std::fmt::{Display, Debug};\n+    use super::S;\n+\n+    /// Link to [`S::fmt`]\n+    pub fn f() {}\n+}"}, {"sha": "8827c9351a62defc8c202c6542b851404a4c2322", "filename": "src/test/rustdoc-ui/assoc-item-not-in-scope.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fassoc-item-not-in-scope.stderr?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -0,0 +1,15 @@\n+error: unresolved link to `S::fmt`\n+  --> $DIR/assoc-item-not-in-scope.rs:4:14\n+   |\n+LL | /// Link to [`S::fmt`]\n+   |              ^^^^^^^^ unresolved link\n+   |\n+note: the lint level is defined here\n+  --> $DIR/assoc-item-not-in-scope.rs:1:9\n+   |\n+LL | #![deny(broken_intra_doc_links)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "2051129b948f3ca71170ee2ed02ca09cbd1dfefc", "filename": "src/test/rustdoc/intra-link-associated-defaults.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc%2Fintra-link-associated-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc%2Fintra-link-associated-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-associated-defaults.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -0,0 +1,27 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+#![feature(associated_type_defaults)]\n+\n+pub trait TraitWithDefault {\n+    type T = usize;\n+    fn f() -> Self::T {\n+        0\n+    }\n+}\n+\n+/// Link to [UsesDefaults::T] and [UsesDefaults::f]\n+// @has 'intra_link_associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.UsesDefaults.html#associatedtype.T\"]' 'UsesDefaults::T'\n+// @has 'intra_link_associated_defaults/struct.UsesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.UsesDefaults.html#method.f\"]' 'UsesDefaults::f'\n+pub struct UsesDefaults;\n+impl TraitWithDefault for UsesDefaults {}\n+\n+/// Link to [OverridesDefaults::T] and [OverridesDefaults::f]\n+// @has 'intra_link_associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.OverridesDefaults.html#associatedtype.T\"]' 'OverridesDefaults::T'\n+// @has 'intra_link_associated_defaults/struct.OverridesDefaults.html' '//a[@href=\"../intra_link_associated_defaults/struct.OverridesDefaults.html#method.f\"]' 'OverridesDefaults::f'\n+pub struct OverridesDefaults;\n+impl TraitWithDefault for OverridesDefaults {\n+    type T = bool;\n+    fn f() -> bool {\n+        true\n+    }\n+}"}, {"sha": "16a21e33748fa100cbfc3c91b99c6c1f46373e2a", "filename": "src/test/rustdoc/intra-link-associated-items.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-associated-items.rs?ref=8fdce9bbb9eb25defd9429cc5122fe6eb59f5ffd", "patch": "@@ -0,0 +1,59 @@\n+// ignore-tidy-linelength\n+#![deny(intra_doc_link_resolution_failure)]\n+\n+/// [`std::collections::BTreeMap::into_iter`]\n+/// [`String::from`] is ambiguous as to which `From` impl\n+// @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/collections/btree/map/struct.BTreeMap.html#method.into_iter\"]' 'std::collections::BTreeMap::into_iter'\n+// @has 'intra_link_associated_items/fn.foo.html' '//a[@href=\"https://doc.rust-lang.org/nightly/alloc/string/struct.String.html#method.from\"]' 'String::from'\n+pub fn foo() {}\n+\n+/// Link to [MyStruct], [link from struct][MyStruct::method], [MyStruct::clone], [MyStruct::Input]\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html\"]' 'MyStruct'\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#method.method\"]' 'link from struct'\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#method.clone\"]' 'MyStruct::clone'\n+// @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#associatedtype.Input\"]' 'MyStruct::Input'\n+pub struct MyStruct { foo: () }\n+\n+impl Clone for MyStruct {\n+    fn clone(&self) -> Self {\n+        MyStruct\n+    }\n+}\n+\n+pub trait T {\n+    type Input;\n+    fn method(i: Self::Input);\n+}\n+\n+impl T for MyStruct {\n+    type Input = usize;\n+\n+    /// [link from method][MyStruct::method] on method\n+    // @has 'intra_link_associated_items/struct.MyStruct.html' '//a[@href=\"../intra_link_associated_items/struct.MyStruct.html#method.method\"]' 'link from method'\n+    fn method(i: usize) {\n+    }\n+}\n+\n+/// Ambiguity between which trait to use\n+pub trait T1 {\n+    fn ambiguous_method();\n+}\n+\n+pub trait T2 {\n+    fn ambiguous_method();\n+}\n+\n+/// Link to [S::ambiguous_method]\n+// FIXME: there is no way to disambiguate these.\n+// Since we have `#[deny(intra_doc_failure)]`, we still know it was one or the other.\n+pub struct S;\n+\n+impl T1 for S {\n+    fn ambiguous_method() {}\n+}\n+\n+impl T2 for S {\n+    fn ambiguous_method() {}\n+}\n+\n+fn main() {}"}]}