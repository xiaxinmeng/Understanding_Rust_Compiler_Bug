{"sha": "87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NjkxODQ2ZTNjOTJmYTJjY2NkNjZmN2NlM2Q3YjAwZWUwZGUxZDQ=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-24T12:51:26Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-10-25T13:43:58Z"}, "message": "incr.comp.: Add documentation for OnDiskCache.", "tree": {"sha": "c6ca2b9b33027fa04aea04c5c18d75aff5ba92f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c6ca2b9b33027fa04aea04c5c18d75aff5ba92f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4", "html_url": "https://github.com/rust-lang/rust/commit/87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f55425dfcd2a156ff2f17e6dd4f9dcfaee9f5905", "url": "https://api.github.com/repos/rust-lang/rust/commits/f55425dfcd2a156ff2f17e6dd4f9dcfaee9f5905", "html_url": "https://github.com/rust-lang/rust/commit/f55425dfcd2a156ff2f17e6dd4f9dcfaee9f5905"}], "stats": {"total": 83, "additions": 55, "deletions": 28}, "files": [{"sha": "26581501234af1b67f0449861d52e408e7db4bc2", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=87691846e3c92fa2cccd66f7ce3d7b00ee0de1d4", "patch": "@@ -22,35 +22,42 @@ use std::mem;\n use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, NO_EXPANSION, DUMMY_SP};\n \n+/// `OnDiskCache` provides an interface to incr. comp. data cached from the\n+/// previous compilation session. This data will eventually include the results\n+/// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n+/// any diagnostics that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n+    // The diagnostics emitted during the previous compilation session.\n     prev_diagnostics: FxHashMap<SerializedDepNodeIndex, Vec<Diagnostic>>,\n \n+    // This field collects all Diagnostics emitted during the current\n+    // compilation session.\n+    current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n+\n+    // This will eventually be needed for creating Decoders that can rebase\n+    // spans.\n     _prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n     codemap: &'sess CodeMap,\n-\n-    current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n }\n \n+// This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n struct Header {\n     prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n }\n \n+// This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n struct Body {\n     diagnostics: Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)>,\n }\n \n impl<'sess> OnDiskCache<'sess> {\n-    pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n-        OnDiskCache {\n-            prev_diagnostics: FxHashMap(),\n-            _prev_filemap_starts: BTreeMap::new(),\n-            codemap,\n-            current_diagnostics: RefCell::new(FxHashMap()),\n-        }\n-    }\n-\n+    /// Create a new OnDiskCache instance from the serialized data in `data`.\n+    /// Note that the current implementation (which only deals with diagnostics\n+    /// so far) will eagerly deserialize the complete cache. Once we are\n+    /// dealing with larger amounts of data (i.e. cached query results),\n+    /// deserialization will need to happen lazily.\n     pub fn new(sess: &'sess Session, data: &[u8]) -> OnDiskCache<'sess> {\n         debug_assert!(sess.opts.incremental.is_some());\n \n@@ -75,6 +82,15 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n+    pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n+        OnDiskCache {\n+            prev_diagnostics: FxHashMap(),\n+            _prev_filemap_starts: BTreeMap::new(),\n+            codemap,\n+            current_diagnostics: RefCell::new(FxHashMap()),\n+        }\n+    }\n+\n     pub fn serialize<'a, 'tcx, E>(&self,\n                                   encoder: &mut E)\n                                   -> Result<(), E::Error>\n@@ -101,12 +117,16 @@ impl<'sess> OnDiskCache<'sess> {\n         Ok(())\n     }\n \n+    /// Load a diagnostic emitted during the previous compilation session.\n     pub fn load_diagnostics(&self,\n                             dep_node_index: SerializedDepNodeIndex)\n                             -> Vec<Diagnostic> {\n         self.prev_diagnostics.get(&dep_node_index).cloned().unwrap_or(vec![])\n     }\n \n+    /// Store a diagnostic emitted during the current compilation session.\n+    /// Anything stored like this will be available via `load_diagnostics` in\n+    /// the next compilation session.\n     pub fn store_diagnostics(&self,\n                              dep_node_index: DepNodeIndex,\n                              diagnostics: Vec<Diagnostic>) {\n@@ -115,6 +135,10 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n+    /// Store a diagnostic emitted during computation of an anonymous query.\n+    /// Since many anonymous queries can share the same `DepNode`, we aggregate\n+    /// them -- as opposed to regular queries where we assume that there is a\n+    /// 1:1 relationship between query-key and `DepNode`.\n     pub fn store_diagnostics_for_anon_node(&self,\n                                            dep_node_index: DepNodeIndex,\n                                            mut diagnostics: Vec<Diagnostic>) {\n@@ -128,23 +152,9 @@ impl<'sess> OnDiskCache<'sess> {\n     }\n }\n \n-impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n-    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n-        let lo = BytePos::decode(self)?;\n-        let hi = BytePos::decode(self)?;\n-\n-        if let Some((prev_filemap_start, filemap_id)) = self.find_filemap_prev_bytepos(lo) {\n-            if let Some(current_filemap) = self.codemap.filemap_by_stable_id(filemap_id) {\n-                let lo = (lo + current_filemap.start_pos) - prev_filemap_start;\n-                let hi = (hi + current_filemap.start_pos) - prev_filemap_start;\n-                return Ok(Span::new(lo, hi, NO_EXPANSION));\n-            }\n-        }\n-\n-        Ok(DUMMY_SP)\n-    }\n-}\n-\n+/// A decoder that can read the incr. comp. cache. It is similar to the one\n+/// we use for crate metadata decoding in that it can rebase spans and\n+/// eventually will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a> {\n     opaque: opaque::Decoder<'a>,\n     codemap: &'a CodeMap,\n@@ -202,3 +212,20 @@ impl<'sess> Decoder for CacheDecoder<'sess> {\n         self.opaque.error(err)\n     }\n }\n+\n+impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n+    fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n+        let lo = BytePos::decode(self)?;\n+        let hi = BytePos::decode(self)?;\n+\n+        if let Some((prev_filemap_start, filemap_id)) = self.find_filemap_prev_bytepos(lo) {\n+            if let Some(current_filemap) = self.codemap.filemap_by_stable_id(filemap_id) {\n+                let lo = (lo + current_filemap.start_pos) - prev_filemap_start;\n+                let hi = (hi + current_filemap.start_pos) - prev_filemap_start;\n+                return Ok(Span::new(lo, hi, NO_EXPANSION));\n+            }\n+        }\n+\n+        Ok(DUMMY_SP)\n+    }\n+}"}]}