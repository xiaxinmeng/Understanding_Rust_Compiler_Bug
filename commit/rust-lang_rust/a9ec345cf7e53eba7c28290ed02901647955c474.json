{"sha": "a9ec345cf7e53eba7c28290ed02901647955c474", "node_id": "C_kwDOAAsO6NoAKGE5ZWMzNDVjZjdlNTNlYmE3YzI4MjkwZWQwMjkwMTY0Nzk1NWM0NzQ", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-10-18T10:43:53Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-10-18T10:44:05Z"}, "message": "Fix PartialOrd codegen", "tree": {"sha": "c8232ac3ab63e1e9a24c29f5937db22fd7e61d5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8232ac3ab63e1e9a24c29f5937db22fd7e61d5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9ec345cf7e53eba7c28290ed02901647955c474", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ec345cf7e53eba7c28290ed02901647955c474", "html_url": "https://github.com/rust-lang/rust/commit/a9ec345cf7e53eba7c28290ed02901647955c474", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9ec345cf7e53eba7c28290ed02901647955c474/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91cbda43c2af82b9377eff70a21f59ade18cd23c", "url": "https://api.github.com/repos/rust-lang/rust/commits/91cbda43c2af82b9377eff70a21f59ade18cd23c", "html_url": "https://github.com/rust-lang/rust/commit/91cbda43c2af82b9377eff70a21f59ade18cd23c"}], "stats": {"total": 263, "additions": 10, "deletions": 253}, "files": [{"sha": "138c694d496b6cc14d19bdc3a893dd880d782f9e", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 3, "deletions": 116, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/a9ec345cf7e53eba7c28290ed02901647955c474/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ec345cf7e53eba7c28290ed02901647955c474/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=a9ec345cf7e53eba7c28290ed02901647955c474", "patch": "@@ -693,7 +693,7 @@ struct Foo {\n \n impl PartialOrd for Foo {\n     $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        self.bin.partial_cmp(other.bin)\n+        self.bin.partial_cmp(&other.bin)\n     }\n }\n \"#,\n@@ -722,7 +722,7 @@ struct Foo {\n \n impl PartialOrd for Foo {\n     $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        (self.bin, self.bar, self.baz).partial_cmp((other.bin, other.bar, other.baz))\n+        (self.bin, self.bar, self.baz).partial_cmp(&(other.bin, other.bar, other.baz))\n     }\n }\n \"#,\n@@ -743,120 +743,7 @@ struct Foo(usize, usize, usize);\n \n impl PartialOrd for Foo {\n     $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        (self.0, self.1, self.2).partial_cmp((other.0, other.1, other.2))\n-    }\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn add_custom_impl_partial_ord_enum() {\n-        check_assist(\n-            replace_derive_with_manual_impl,\n-            r#\"\n-//- minicore: ord\n-#[derive(Partial$0Ord)]\n-enum Foo {\n-    Bin,\n-    Bar,\n-    Baz,\n-}\n-\"#,\n-            r#\"\n-enum Foo {\n-    Bin,\n-    Bar,\n-    Baz,\n-}\n-\n-impl PartialOrd for Foo {\n-    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        core::mem::discriminant(self).partial_cmp(core::mem::discriminant(other))\n-    }\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn add_custom_impl_partial_ord_record_enum() {\n-        check_assist(\n-            replace_derive_with_manual_impl,\n-            r#\"\n-//- minicore: ord\n-#[derive(Partial$0Ord)]\n-enum Foo {\n-    Bar {\n-        bin: String,\n-    },\n-    Baz {\n-        qux: String,\n-        fez: String,\n-    },\n-    Qux {},\n-    Bin,\n-}\n-\"#,\n-            r#\"\n-enum Foo {\n-    Bar {\n-        bin: String,\n-    },\n-    Baz {\n-        qux: String,\n-        fez: String,\n-    },\n-    Qux {},\n-    Bin,\n-}\n-\n-impl PartialOrd for Foo {\n-    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        match (self, other) {\n-            (Self::Bar { bin: l_bin }, Self::Bar { bin: r_bin }) => l_bin.partial_cmp(r_bin),\n-            (Self::Baz { qux: l_qux, fez: l_fez }, Self::Baz { qux: r_qux, fez: r_fez }) => {\n-                (l_qux, l_fez).partial_cmp((r_qux, r_fez))\n-            }\n-            _ => core::mem::discriminant(self).partial_cmp(core::mem::discriminant(other)),\n-        }\n-    }\n-}\n-\"#,\n-        )\n-    }\n-\n-    #[test]\n-    fn add_custom_impl_partial_ord_tuple_enum() {\n-        check_assist(\n-            replace_derive_with_manual_impl,\n-            r#\"\n-//- minicore: ord\n-#[derive(Partial$0Ord)]\n-enum Foo {\n-    Bar(String),\n-    Baz(String, String),\n-    Qux(),\n-    Bin,\n-}\n-\"#,\n-            r#\"\n-enum Foo {\n-    Bar(String),\n-    Baz(String, String),\n-    Qux(),\n-    Bin,\n-}\n-\n-impl PartialOrd for Foo {\n-    $0fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-        match (self, other) {\n-            (Self::Bar(l0), Self::Bar(r0)) => l0.partial_cmp(r0),\n-            (Self::Baz(l0, l1), Self::Baz(r0, r1)) => {\n-                (l0, l1).partial_cmp((r0, r1))\n-            }\n-            _ => core::mem::discriminant(self).partial_cmp(core::mem::discriminant(other)),\n-        }\n+        (self.0, self.1, self.2).partial_cmp(&(other.0, other.1, other.2))\n     }\n }\n \"#,"}, {"sha": "40c3734f9dd54eab8baff4f6bd81441e31793812", "filename": "crates/ide_assists/src/utils/gen_trait_fn_body.rs", "status": "modified", "additions": 7, "deletions": 137, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/a9ec345cf7e53eba7c28290ed02901647955c474/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9ec345cf7e53eba7c28290ed02901647955c474/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Futils%2Fgen_trait_fn_body.rs?ref=a9ec345cf7e53eba7c28290ed02901647955c474", "patch": "@@ -574,154 +574,24 @@ fn gen_partial_eq(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n }\n \n fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n-    fn gen_partial_cmp_call(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n-        let method = make::name_ref(\"partial_cmp\");\n-        make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n-    }\n-    fn gen_partial_cmp_call2(mut lhs: Vec<ast::Expr>, mut rhs: Vec<ast::Expr>) -> ast::Expr {\n+    fn gen_partial_cmp_call(mut lhs: Vec<ast::Expr>, mut rhs: Vec<ast::Expr>) -> ast::Expr {\n         let (lhs, rhs) = match (lhs.len(), rhs.len()) {\n             (1, 1) => (lhs.pop().unwrap(), rhs.pop().unwrap()),\n             _ => (make::expr_tuple(lhs.into_iter()), make::expr_tuple(rhs.into_iter())),\n         };\n+        let rhs = make::expr_ref(rhs, false);\n         let method = make::name_ref(\"partial_cmp\");\n         make::expr_method_call(lhs, method, make::arg_list(Some(rhs)))\n     }\n \n-    fn gen_record_pat_field(field_name: &str, pat_name: &str) -> ast::RecordPatField {\n-        let pat = make::ext::simple_ident_pat(make::name(&pat_name));\n-        let name_ref = make::name_ref(field_name);\n-        make::record_pat_field(name_ref, pat.into())\n-    }\n-\n-    fn gen_record_pat(record_name: ast::Path, fields: Vec<ast::RecordPatField>) -> ast::RecordPat {\n-        let list = make::record_pat_field_list(fields);\n-        make::record_pat_with_fields(record_name, list)\n-    }\n-\n-    fn gen_variant_path(variant: &ast::Variant) -> Option<ast::Path> {\n-        make::ext::path_from_idents([\"Self\", &variant.name()?.to_string()])\n-    }\n-\n-    fn gen_tuple_field(field_name: &String) -> ast::Pat {\n-        ast::Pat::IdentPat(make::ident_pat(false, false, make::name(field_name)))\n-    }\n-\n     // FIXME: return `None` if the trait carries a generic type; we can only\n     // generate this code `Self` for the time being.\n \n     let body = match adt {\n-        // `Hash` cannot be derived for unions, so no default impl can be provided.\n+        // `PartialOrd` cannot be derived for unions, so no default impl can be provided.\n         ast::Adt::Union(_) => return None,\n-\n-        ast::Adt::Enum(enum_) => {\n-            // => std::mem::discriminant(self) == std::mem::discriminant(other)\n-            let lhs_name = make::expr_path(make::ext::ident_path(\"self\"));\n-            let lhs = make::expr_call(make_discriminant()?, make::arg_list(Some(lhs_name.clone())));\n-            let rhs_name = make::expr_path(make::ext::ident_path(\"other\"));\n-            let rhs = make::expr_call(make_discriminant()?, make::arg_list(Some(rhs_name.clone())));\n-            let ord_check = gen_partial_cmp_call(lhs, rhs);\n-\n-            let mut case_count = 0;\n-            let mut arms = vec![];\n-            for variant in enum_.variant_list()?.variants() {\n-                case_count += 1;\n-                match variant.field_list() {\n-                    // => (Self::Bar { bin: l_bin }, Self::Bar { bin: r_bin }) => l_bin == r_bin,\n-                    Some(ast::FieldList::RecordFieldList(list)) => {\n-                        let mut l_pat_fields = vec![];\n-                        let mut r_pat_fields = vec![];\n-                        let mut l_fields = vec![];\n-                        let mut r_fields = vec![];\n-\n-                        for field in list.fields() {\n-                            let field_name = field.name()?.to_string();\n-\n-                            let l_name = &format!(\"l_{}\", field_name);\n-                            l_pat_fields.push(gen_record_pat_field(&field_name, &l_name));\n-\n-                            let r_name = &format!(\"r_{}\", field_name);\n-                            r_pat_fields.push(gen_record_pat_field(&field_name, &r_name));\n-\n-                            let lhs = make::expr_path(make::ext::ident_path(l_name));\n-                            let rhs = make::expr_path(make::ext::ident_path(r_name));\n-                            l_fields.push(lhs);\n-                            r_fields.push(rhs);\n-                        }\n-\n-                        let left_pat = gen_record_pat(gen_variant_path(&variant)?, l_pat_fields);\n-                        let right_pat = gen_record_pat(gen_variant_path(&variant)?, r_pat_fields);\n-                        let tuple_pat = make::tuple_pat(vec![left_pat.into(), right_pat.into()]);\n-\n-                        let len = l_fields.len();\n-                        if len != 0 {\n-                            let mut expr = gen_partial_cmp_call2(l_fields, r_fields);\n-                            if len >= 2 {\n-                                expr = make::block_expr(None, Some(expr))\n-                                    .indent(ast::edit::IndentLevel(1))\n-                                    .into();\n-                            }\n-                            arms.push(make::match_arm(Some(tuple_pat.into()), None, expr));\n-                        }\n-                    }\n-\n-                    Some(ast::FieldList::TupleFieldList(list)) => {\n-                        let mut l_pat_fields = vec![];\n-                        let mut r_pat_fields = vec![];\n-                        let mut l_fields = vec![];\n-                        let mut r_fields = vec![];\n-\n-                        for (i, _) in list.fields().enumerate() {\n-                            let field_name = format!(\"{}\", i);\n-\n-                            let l_name = format!(\"l{}\", field_name);\n-                            l_pat_fields.push(gen_tuple_field(&l_name));\n-\n-                            let r_name = format!(\"r{}\", field_name);\n-                            r_pat_fields.push(gen_tuple_field(&r_name));\n-\n-                            let lhs = make::expr_path(make::ext::ident_path(&l_name));\n-                            let rhs = make::expr_path(make::ext::ident_path(&r_name));\n-                            l_fields.push(lhs);\n-                            r_fields.push(rhs);\n-                        }\n-\n-                        let left_pat =\n-                            make::tuple_struct_pat(gen_variant_path(&variant)?, l_pat_fields);\n-                        let right_pat =\n-                            make::tuple_struct_pat(gen_variant_path(&variant)?, r_pat_fields);\n-                        let tuple_pat = make::tuple_pat(vec![left_pat.into(), right_pat.into()]);\n-\n-                        let len = l_fields.len();\n-                        if len != 0 {\n-                            let mut expr = gen_partial_cmp_call2(l_fields, r_fields);\n-                            if len >= 2 {\n-                                expr = make::block_expr(None, Some(expr))\n-                                    .indent(ast::edit::IndentLevel(1))\n-                                    .into();\n-                            }\n-                            arms.push(make::match_arm(Some(tuple_pat.into()), None, expr));\n-                        }\n-                    }\n-                    None => continue,\n-                }\n-            }\n-\n-            let expr = match arms.len() {\n-                0 => ord_check,\n-                _ => {\n-                    if case_count > arms.len() {\n-                        let lhs = make::wildcard_pat().into();\n-                        arms.push(make::match_arm(Some(lhs), None, ord_check));\n-                    }\n-\n-                    let match_target = make::expr_tuple(vec![lhs_name, rhs_name]);\n-                    let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n-                    make::expr_match(match_target, list)\n-                }\n-            };\n-\n-            make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n-        }\n+        // `core::mem::Discriminant` does not implement `PartialOrd` in stable Rust today.\n+        ast::Adt::Enum(_) => return None,\n         ast::Adt::Struct(strukt) => match strukt.field_list() {\n             Some(ast::FieldList::RecordFieldList(field_list)) => {\n                 let mut l_fields = vec![];\n@@ -735,7 +605,7 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     r_fields.push(rhs);\n                 }\n \n-                let expr = gen_partial_cmp_call2(l_fields, r_fields);\n+                let expr = gen_partial_cmp_call(l_fields, r_fields);\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n             }\n \n@@ -751,7 +621,7 @@ fn gen_partial_ord(adt: &ast::Adt, func: &ast::Fn) -> Option<()> {\n                     l_fields.push(lhs);\n                     r_fields.push(rhs);\n                 }\n-                let expr = gen_partial_cmp_call2(l_fields, r_fields);\n+                let expr = gen_partial_cmp_call(l_fields, r_fields);\n                 make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1))\n             }\n "}]}