{"sha": "1ef5e14c2c072fca9792d3da7c6443850790d779", "node_id": "C_kwDOAAsO6NoAKDFlZjVlMTRjMmMwNzJmY2E5NzkyZDNkYTdjNjQ0Mzg1MDc5MGQ3Nzk", "commit": {"author": {"name": "bitgaoshu", "email": "bitgaoshu@gmail.com", "date": "2022-06-15T15:13:15Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-06-23T12:01:22Z"}, "message": "goto where trait method impl", "tree": {"sha": "5590c3556326f7a5fe304e616464cdef3a1200b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5590c3556326f7a5fe304e616464cdef3a1200b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ef5e14c2c072fca9792d3da7c6443850790d779", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef5e14c2c072fca9792d3da7c6443850790d779", "html_url": "https://github.com/rust-lang/rust/commit/1ef5e14c2c072fca9792d3da7c6443850790d779", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ef5e14c2c072fca9792d3da7c6443850790d779/comments", "author": {"login": "bitgaoshu", "id": 7943146, "node_id": "MDQ6VXNlcjc5NDMxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/7943146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitgaoshu", "html_url": "https://github.com/bitgaoshu", "followers_url": "https://api.github.com/users/bitgaoshu/followers", "following_url": "https://api.github.com/users/bitgaoshu/following{/other_user}", "gists_url": "https://api.github.com/users/bitgaoshu/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitgaoshu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitgaoshu/subscriptions", "organizations_url": "https://api.github.com/users/bitgaoshu/orgs", "repos_url": "https://api.github.com/users/bitgaoshu/repos", "events_url": "https://api.github.com/users/bitgaoshu/events{/privacy}", "received_events_url": "https://api.github.com/users/bitgaoshu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6fc5c3cd2117a29981ba9b7cef8a51c1d6804089", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fc5c3cd2117a29981ba9b7cef8a51c1d6804089", "html_url": "https://github.com/rust-lang/rust/commit/6fc5c3cd2117a29981ba9b7cef8a51c1d6804089"}], "stats": {"total": 481, "additions": 365, "deletions": 116}, "files": [{"sha": "afac92b266212933ea24ec0df802c4e9dab5fec5", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 145, "deletions": 84, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=1ef5e14c2c072fca9792d3da7c6443850790d779", "patch": "@@ -8,8 +8,9 @@ use arrayvec::ArrayVec;\n use base_db::{CrateId, Edition};\n use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n-    item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId, FunctionId,\n-    GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId, TraitId,\n+    data::ImplData, item_scope::ItemScope, nameres::DefMap, AssocItemId, BlockId, ConstId,\n+    FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, Lookup, ModuleDefId, ModuleId,\n+    TraitId,\n };\n use hir_expand::name::Name;\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -247,7 +248,7 @@ impl TraitImpls {\n         self.map\n             .get(&trait_)\n             .into_iter()\n-            .flat_map(move |map| map.get(&None).into_iter().chain(map.get(&Some(self_ty))))\n+            .flat_map(move |map| map.get(&Some(self_ty)).into_iter().chain(map.get(&None)))\n             .flat_map(|v| v.iter().copied())\n     }\n \n@@ -575,6 +576,32 @@ pub(crate) fn iterate_method_candidates<T>(\n     slot\n }\n \n+pub fn lookup_trait_m_for_self_ty(\n+    self_ty: &Ty,\n+    db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n+    implied_trait: TraitId,\n+    name: &Name,\n+) -> Option<FunctionId> {\n+    let self_ty_tp = TyFingerprint::for_trait_impl(self_ty)?;\n+    let trait_impls = TraitImpls::trait_impls_in_deps_query(db, env.krate);\n+    let impls = trait_impls.for_trait_and_self_ty(implied_trait, self_ty_tp);\n+    let mut table = InferenceTable::new(db, env.clone());\n+    if let Some(data) = Valid::valid_impl(impls, &mut table, &self_ty) {\n+        for &impl_item in data.items.iter() {\n+            if Valid::is_valid_item(&mut table, Some(name), None, impl_item, self_ty, None) {\n+                match impl_item {\n+                    AssocItemId::FunctionId(f) => {\n+                        return Some(f);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+    }\n+    None\n+}\n+\n pub fn iterate_path_candidates(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n@@ -850,7 +877,7 @@ fn iterate_trait_method_candidates(\n         for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(table, name, receiver_ty, item, self_ty, None) {\n+            if !Valid::is_valid_item(table, name, receiver_ty, item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -932,8 +959,14 @@ fn iterate_inherent_methods(\n         let impls_for_self_ty = impls.for_self_ty(self_ty);\n         for &impl_def in impls_for_self_ty {\n             for &item in &db.impl_data(impl_def).items {\n-                if !is_valid_candidate(table, name, receiver_ty, item, self_ty, visible_from_module)\n-                {\n+                if !Valid::is_valid_item(\n+                    table,\n+                    name,\n+                    receiver_ty,\n+                    item,\n+                    self_ty,\n+                    visible_from_module,\n+                ) {\n                     continue;\n                 }\n                 callback(receiver_adjustments.clone().unwrap_or_default(), item)?;\n@@ -961,97 +994,125 @@ pub fn resolve_indexing_op(\n     }\n     None\n }\n+struct Valid;\n+impl Valid {\n+    fn valid_impl(\n+        impls: impl Iterator<Item = ImplId>,\n+        table: &mut InferenceTable,\n+        self_ty: &Ty,\n+    ) -> Option<Arc<ImplData>> {\n+        let db = table.db;\n+        for impl_ in impls {\n+            let impl_data = db.impl_data(impl_);\n+            let substs =\n+                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+            let impl_ty =\n+                substs.apply(db.impl_self_ty(impl_).into_value_and_skipped_binders().0, Interner);\n+\n+            if !table.unify(self_ty, &impl_ty) {\n+                continue;\n+            }\n \n-fn is_valid_candidate(\n-    table: &mut InferenceTable,\n-    name: Option<&Name>,\n-    receiver_ty: Option<&Ty>,\n-    item: AssocItemId,\n-    self_ty: &Ty,\n-    visible_from_module: Option<ModuleId>,\n-) -> bool {\n-    let db = table.db;\n-    match item {\n-        AssocItemId::FunctionId(m) => {\n-            let data = db.function_data(m);\n-            if let Some(name) = name {\n-                if &data.name != name {\n-                    return false;\n-                }\n+            let wh_goals = crate::chalk_db::convert_where_clauses(db, impl_.into(), &substs)\n+                .into_iter()\n+                .map(|b| b.into_well_formed_goal(Interner).cast(Interner));\n+\n+            let goal = crate::Goal::all(Interner, wh_goals);\n+\n+            if table.try_obligation(goal).is_some() {\n+                return Some(impl_data);\n             }\n-            table.run_in_snapshot(|table| {\n-                let subst = TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n-                let expected_self_ty = match m.lookup(db.upcast()).container {\n-                    ItemContainerId::TraitId(_) => {\n-                        subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n-                    }\n-                    ItemContainerId::ImplId(impl_id) => {\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-                    }\n-                    // We should only get called for associated items (impl/trait)\n-                    ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                        unreachable!()\n-                    }\n-                };\n-                if !table.unify(&expected_self_ty, &self_ty) {\n+        }\n+        None\n+    }\n+\n+    fn is_valid_item(\n+        table: &mut InferenceTable,\n+        name: Option<&Name>,\n+        receiver_ty: Option<&Ty>,\n+        item: AssocItemId,\n+        self_ty: &Ty,\n+        visible_from_module: Option<ModuleId>,\n+    ) -> bool {\n+        macro_rules! assert {\n+            ($cond:expr) => {\n+                if !$cond {\n                     return false;\n                 }\n-                if let Some(receiver_ty) = receiver_ty {\n-                    if !data.has_self_param() {\n-                        return false;\n-                    }\n+            };\n+        }\n \n-                    let sig = db.callable_item_signature(m.into());\n-                    let expected_receiver =\n-                        sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n-                    let receiver_matches = table.unify(&receiver_ty, &expected_receiver);\n+        let db = table.db;\n+        match item {\n+            AssocItemId::FunctionId(m) => {\n+                let data = db.function_data(m);\n+\n+                assert!(name.map_or(true, |n| n == &data.name));\n+                assert!(visible_from_module.map_or(true, |from_module| {\n+                    let v = db.function_visibility(m).is_visible_from(db.upcast(), from_module);\n+                    if !v {\n+                        cov_mark::hit!(autoderef_candidate_not_visible);\n+                    }\n+                    v\n+                }));\n \n-                    if !receiver_matches {\n-                        return false;\n+                table.run_in_snapshot(|table| {\n+                    let subst =\n+                        TyBuilder::subst_for_def(db, m).fill_with_inference_vars(table).build();\n+                    let expect_self_ty = match m.lookup(db.upcast()).container {\n+                        ItemContainerId::TraitId(_) => {\n+                            subst.at(Interner, 0).assert_ty_ref(Interner).clone()\n+                        }\n+                        ItemContainerId::ImplId(impl_id) => {\n+                            subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n+                        }\n+                        // We should only get called for associated items (impl/trait)\n+                        ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n+                            unreachable!()\n+                        }\n+                    };\n+                    assert!(table.unify(&expect_self_ty, self_ty));\n+                    if let Some(receiver_ty) = receiver_ty {\n+                        assert!(data.has_self_param());\n+\n+                        let sig = db.callable_item_signature(m.into());\n+                        let expected_receiver =\n+                            sig.map(|s| s.params()[0].clone()).substitute(Interner, &subst);\n+\n+                        assert!(table.unify(&receiver_ty, &expected_receiver));\n                     }\n-                }\n-                if let Some(from_module) = visible_from_module {\n-                    if !db.function_visibility(m).is_visible_from(db.upcast(), from_module) {\n-                        cov_mark::hit!(autoderef_candidate_not_visible);\n+                    true\n+                })\n+            }\n+            AssocItemId::ConstId(c) => {\n+                let data = db.const_data(c);\n+                assert!(receiver_ty.is_none());\n+\n+                assert!(name.map_or(true, |n| data.name.as_ref() == Some(n)));\n+                assert!(visible_from_module.map_or(true, |from_module| {\n+                    let v = db.const_visibility(c).is_visible_from(db.upcast(), from_module);\n+                    if !v {\n+                        cov_mark::hit!(const_candidate_not_visible);\n+                    }\n+                    v\n+                }));\n+                if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n+                    let self_ty_matches = table.run_in_snapshot(|table| {\n+                        let subst =\n+                            TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n+                        let expected_self_ty =\n+                            subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                        table.unify(&expected_self_ty, &self_ty)\n+                    });\n+                    if !self_ty_matches {\n+                        cov_mark::hit!(const_candidate_self_type_mismatch);\n                         return false;\n                     }\n                 }\n-\n                 true\n-            })\n-        }\n-        AssocItemId::ConstId(c) => {\n-            let data = db.const_data(c);\n-            if receiver_ty.is_some() {\n-                return false;\n-            }\n-            if let Some(name) = name {\n-                if data.name.as_ref() != Some(name) {\n-                    return false;\n-                }\n-            }\n-            if let Some(from_module) = visible_from_module {\n-                if !db.const_visibility(c).is_visible_from(db.upcast(), from_module) {\n-                    cov_mark::hit!(const_candidate_not_visible);\n-                    return false;\n-                }\n-            }\n-            if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n-                let self_ty_matches = table.run_in_snapshot(|table| {\n-                    let subst =\n-                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n-                    let expected_self_ty =\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n-                    table.unify(&expected_self_ty, &self_ty)\n-                });\n-                if !self_ty_matches {\n-                    cov_mark::hit!(const_candidate_self_type_mismatch);\n-                    return false;\n-                }\n             }\n-            true\n+            _ => false,\n         }\n-        _ => false,\n     }\n }\n "}, {"sha": "2574adb35a53a87b800a081fce8aebc20a67199d", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=1ef5e14c2c072fca9792d3da7c6443850790d779", "patch": "@@ -348,6 +348,9 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_method_call(call).map(Function::from)\n     }\n \n+    pub fn resolve_impl_method(&self, call: &ast::Expr) -> Option<Function> {\n+        self.imp.resolve_impl_method(call).map(Function::from)\n+    }\n     pub fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         self.imp.resolve_method_call_as_callable(call)\n     }\n@@ -978,6 +981,10 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(call.syntax())?.resolve_method_call(self.db, call).map(|(id, _)| id)\n     }\n \n+    fn resolve_impl_method(&self, call: &ast::Expr) -> Option<FunctionId> {\n+        self.analyze(call.syntax())?.resolve_impl_method(self.db, call)\n+    }\n+\n     fn resolve_method_call_as_callable(&self, call: &ast::MethodCallExpr) -> Option<Callable> {\n         let source_analyzer = self.analyze(call.syntax())?;\n         let (func, subst) = source_analyzer.resolve_method_call(self.db, call)?;"}, {"sha": "4d8d6a14608f3fc0f76bca8fead711b37393f82d", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=1ef5e14c2c072fca9792d3da7c6443850790d779", "patch": "@@ -21,7 +21,8 @@ use hir_def::{\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n-    AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, Lookup, ModuleDefId, VariantId,\n+    AsMacroCall, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId, Lookup,\n+    ModuleDefId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander, hygiene::Hygiene, name::AsName, HirFileId, InFile,\n@@ -31,8 +32,8 @@ use hir_ty::{\n         record_literal_missing_fields, record_pattern_missing_fields, unsafe_expressions,\n         UnsafeExpr,\n     },\n-    Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution, TyExt,\n-    TyLoweringContext,\n+    method_resolution, Adjust, Adjustment, AutoBorrow, InferenceResult, Interner, Substitution,\n+    TyExt, TyKind, TyLoweringContext,\n };\n use smallvec::SmallVec;\n use syntax::{\n@@ -247,6 +248,60 @@ impl SourceAnalyzer {\n         self.infer.as_ref()?.method_resolution(expr_id)\n     }\n \n+    pub(crate) fn resolve_impl_method(\n+        &self,\n+        db: &dyn HirDatabase,\n+        call: &ast::Expr,\n+    ) -> Option<FunctionId> {\n+        let infered = self.infer.as_ref()?;\n+        let expr_id = self.expr_id(db, call)?;\n+\n+        let mut fun_info = None;\n+        match call {\n+            &ast::Expr::MethodCallExpr(..) => {\n+                let (func, subs) = infered.method_resolution(expr_id)?;\n+                if subs.is_empty(Interner) {\n+                    return None;\n+                }\n+                fun_info.replace((func, subs.at(Interner, 0).ty(Interner)?.clone()));\n+            }\n+            &ast::Expr::PathExpr(..) => {\n+                let func_ty = infered.type_of_expr.get(expr_id)?;\n+                if let TyKind::FnDef(fn_def, subs) = func_ty.kind(Interner) {\n+                    if subs.is_empty(Interner) {\n+                        return None;\n+                    }\n+                    if let hir_ty::CallableDefId::FunctionId(f_id) =\n+                        db.lookup_intern_callable_def(fn_def.clone().into())\n+                    {\n+                        fun_info.replace((f_id, subs.at(Interner, 0).ty(Interner)?.clone()));\n+                    }\n+                }\n+            }\n+            _ => (),\n+        };\n+        let (func, self_ty) = fun_info?;\n+        let implied_trait = match func.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(trait_id) => trait_id,\n+            _ => return None,\n+        };\n+\n+        let krate = self.resolver.krate();\n+        let trait_env = self.resolver.body_owner()?.as_generic_def_id().map_or_else(\n+            || Arc::new(hir_ty::TraitEnvironment::empty(krate)),\n+            |d| db.trait_environment(d),\n+        );\n+\n+        let fun_data = db.function_data(func);\n+        method_resolution::lookup_trait_m_for_self_ty(\n+            &self_ty,\n+            db,\n+            trait_env,\n+            implied_trait,\n+            &fun_data.name,\n+        )\n+    }\n+\n     pub(crate) fn resolve_field(\n         &self,\n         db: &dyn HirDatabase,"}, {"sha": "e5390eeb326edbd0e3f0f88ccfb74ad767e5ff26", "filename": "crates/ide-db/src/defs.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fide-db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fide-db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fdefs.rs?ref=1ef5e14c2c072fca9792d3da7c6443850790d779", "patch": "@@ -162,6 +162,22 @@ impl IdentClass {\n             .or_else(|| NameClass::classify_lifetime(sema, lifetime).map(IdentClass::NameClass))\n     }\n \n+    pub fn classify_token_to_impl(\n+        sema: &Semantics<RootDatabase>,\n+        token: &SyntaxToken,\n+    ) -> Option<Definition> {\n+        let p = token.parent()?;\n+        match_ast! {\n+            match p {\n+                ast::NameRef(name_ref) => match NameRefClass::classify_to_impl(sema, name_ref)? {\n+                    NameRefClass::Definition(d) => Some(d),\n+                    _ => None,\n+                },\n+                _ => None,\n+            }\n+        }\n+    }\n+\n     pub fn definitions(self) -> ArrayVec<Definition, 2> {\n         let mut res = ArrayVec::new();\n         match self {\n@@ -417,6 +433,35 @@ impl NameRefClass {\n         }\n     }\n \n+    fn classify_to_impl(\n+        sema: &Semantics<RootDatabase>,\n+        name_ref: ast::NameRef,\n+    ) -> Option<NameRefClass> {\n+        let parent = name_ref.syntax().parent()?;\n+        match_ast! {\n+           match parent {\n+               ast::MethodCallExpr(method_call) => {\n+                   sema.resolve_impl_method(&ast::Expr::MethodCallExpr(method_call))\n+                       .map(Definition::Function)\n+                       .map(NameRefClass::Definition)\n+               },\n+               ast::PathSegment(ps) => {\n+                   ps.syntax().parent().and_then(ast::Path::cast)\n+                   .map(|p|\n+                       p.syntax()\n+                       .parent()\n+                       .and_then(ast::PathExpr::cast)\n+                       .map(|pe|\n+                           sema.resolve_impl_method(&ast::Expr::PathExpr(pe))\n+                           .map(Definition::Function)\n+                           .map(NameRefClass::Definition)\n+                       ).flatten()\n+                   ).flatten()\n+               },\n+               _=> None\n+           }\n+        }\n+    }\n     pub fn classify_lifetime(\n         sema: &Semantics<RootDatabase>,\n         lifetime: &ast::Lifetime,"}, {"sha": "ea7fd3e07287cb978741cec848f52987facac8b9", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 110, "deletions": 29, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ef5e14c2c072fca9792d3da7c6443850790d779/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=1ef5e14c2c072fca9792d3da7c6443850790d779", "patch": "@@ -1,7 +1,7 @@\n use std::convert::TryInto;\n \n use crate::{doc_links::token_as_doc_comment, FilePosition, NavigationTarget, RangeInfo, TryToNav};\n-use hir::{AsAssocItem, Semantics};\n+use hir::{AsAssocItem, AssocItem, Semantics};\n use ide_db::{\n     base_db::{AnchoredPath, FileId, FileLoader},\n     defs::{Definition, IdentClass},\n@@ -65,7 +65,7 @@ pub(crate) fn goto_definition(\n                     .definitions()\n                     .into_iter()\n                     .flat_map(|def| {\n-                        try_find_trait_item_definition(sema.db, &def)\n+                        try_filter_trait_item_definition(sema, &def, &token)\n                             .unwrap_or_else(|| def_to_nav(sema.db, def))\n                     })\n                     .collect(),\n@@ -104,32 +104,38 @@ fn try_lookup_include_path(\n         docs: None,\n     })\n }\n-\n-/// finds the trait definition of an impl'd item\n+/// finds the trait definition of an impl'd item, except function\n /// e.g.\n /// ```rust\n-/// trait A { fn a(); }\n+/// trait A { type a; }\n /// struct S;\n-/// impl A for S { fn a(); } // <-- on this function, will get the location of a() in the trait\n+/// impl A for S { type a = i32; } // <-- on this associate type, will get the location of a in the trait\n /// ```\n-fn try_find_trait_item_definition(\n-    db: &RootDatabase,\n+fn try_filter_trait_item_definition(\n+    sema: &Semantics<RootDatabase>,\n     def: &Definition,\n+    token: &SyntaxToken,\n ) -> Option<Vec<NavigationTarget>> {\n-    let name = def.name(db)?;\n+    let db = sema.db;\n     let assoc = def.as_assoc_item(db)?;\n-\n-    let imp = match assoc.container(db) {\n-        hir::AssocItemContainer::Impl(imp) => imp,\n-        _ => return None,\n-    };\n-\n-    let trait_ = imp.trait_(db)?;\n-    trait_\n-        .items(db)\n-        .iter()\n-        .find_map(|itm| (itm.name(db)? == name).then(|| itm.try_to_nav(db)).flatten())\n-        .map(|it| vec![it])\n+    match assoc {\n+        AssocItem::Function(..) => {\n+            IdentClass::classify_token_to_impl(sema, &token).map(|def| def_to_nav(db, def))\n+        }\n+        AssocItem::Const(..) | AssocItem::TypeAlias(..) => {\n+            let imp = match assoc.container(db) {\n+                hir::AssocItemContainer::Impl(imp) => imp,\n+                _ => return None,\n+            };\n+            let trait_ = imp.trait_(db)?;\n+            let name = def.name(db)?;\n+            trait_\n+                .items(db)\n+                .iter()\n+                .find_map(|itm| (itm.name(db)? == name).then(|| itm.try_to_nav(db)).flatten())\n+                .map(|it| vec![it])\n+        }\n+    }\n }\n \n fn def_to_nav(db: &RootDatabase, def: Definition) -> Vec<NavigationTarget> {\n@@ -1331,23 +1337,98 @@ fn main() {\n \"#,\n         );\n     }\n-\n-    #[test]\n-    fn goto_def_of_trait_impl_fn() {\n-        check(\n-            r#\"\n+    #[cfg(test)]\n+    mod goto_impl_of_trait_fn {\n+        use super::check;\n+        #[test]\n+        fn cursor_on_impl() {\n+            check(\n+                r#\"\n trait Twait {\n     fn a();\n-    // ^\n }\n \n struct Stwuct;\n \n impl Twait for Stwuct {\n     fn a$0();\n+     //^\n }\n-\"#,\n-        );\n+        \"#,\n+            );\n+        }\n+        #[test]\n+        fn method_call() {\n+            check(\n+                r#\"\n+trait Twait {\n+    fn a(&self);\n+}\n+\n+struct Stwuct;\n+\n+impl Twait for Stwuct {\n+    fn a(&self){};\n+     //^\n+}\n+fn f() {\n+    let s = Stwuct;\n+    s.a$0();\n+}\n+        \"#,\n+            );\n+        }\n+        #[test]\n+        fn path_call() {\n+            check(\n+                r#\"\n+trait Twait {\n+    fn a(&self);\n+}\n+\n+struct Stwuct;\n+\n+impl Twait for Stwuct {\n+    fn a(&self){};\n+     //^\n+}\n+fn f() {\n+    let s = Stwuct;\n+    Stwuct::a$0(&s);\n+}\n+        \"#,\n+            );\n+        }\n+        #[test]\n+        fn where_clause_can_work() {\n+            check(\n+                r#\"\n+trait G {\n+    fn g(&self);\n+}\n+trait Bound{}\n+trait EA{}\n+struct Gen<T>(T);\n+impl <T:EA> G for Gen<T> {\n+    fn g(&self) {\n+    }\n+}\n+impl <T> G for Gen<T>\n+where T : Bound\n+{\n+    fn g(&self){\n+     //^\n+    }\n+}\n+struct A;\n+impl Bound for A{}\n+fn f() {\n+    let gen = Gen::<A>(A);\n+    gen.g$0();\n+}\n+                \"#,\n+            );\n+        }\n     }\n \n     #[test]"}]}