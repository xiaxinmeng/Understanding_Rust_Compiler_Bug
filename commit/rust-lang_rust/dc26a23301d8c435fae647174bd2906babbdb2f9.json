{"sha": "dc26a23301d8c435fae647174bd2906babbdb2f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMjZhMjMzMDFkOGM0MzVmYWU2NDcxNzRiZDI5MDZiYWJiZGIyZjk=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-17T07:33:47Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:05Z"}, "message": "rustc_metadata: reduce Lazy{,Seq} overhead by using a relative encoding.", "tree": {"sha": "c155d3b587c5a96c3a4182e36c3dd41db9f619a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c155d3b587c5a96c3a4182e36c3dd41db9f619a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc26a23301d8c435fae647174bd2906babbdb2f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc26a23301d8c435fae647174bd2906babbdb2f9", "html_url": "https://github.com/rust-lang/rust/commit/dc26a23301d8c435fae647174bd2906babbdb2f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc26a23301d8c435fae647174bd2906babbdb2f9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a96abca2a4ec14df912b7ebee69dbeac19d630c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96abca2a4ec14df912b7ebee69dbeac19d630c4", "html_url": "https://github.com/rust-lang/rust/commit/a96abca2a4ec14df912b7ebee69dbeac19d630c4"}], "stats": {"total": 174, "additions": 148, "deletions": 26}, "files": [{"sha": "973ef6030a3e98820a7fd8fc65e9237c30977d5b", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dc26a23301d8c435fae647174bd2906babbdb2f9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc26a23301d8c435fae647174bd2906babbdb2f9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=dc26a23301d8c435fae647174bd2906babbdb2f9", "patch": "@@ -52,8 +52,11 @@ pub struct DecodeContext<'a, 'tcx: 'a> {\n     cdata: Option<&'a CrateMetadata>,\n     from_id_range: IdRange,\n     to_id_range: IdRange,\n+\n     // Cache the last used filemap for translating spans as an optimization.\n     last_filemap_index: usize,\n+\n+    lazy_state: LazyState\n }\n \n /// Abstract over the various ways one can create metadata decoders.\n@@ -73,7 +76,8 @@ pub trait Metadata<'a, 'tcx>: Copy {\n             tcx: self.tcx(),\n             from_id_range: id_range,\n             to_id_range: id_range,\n-            last_filemap_index: 0\n+            last_filemap_index: 0,\n+            lazy_state: LazyState::NoNode\n         }\n     }\n }\n@@ -114,13 +118,16 @@ impl<'a, 'tcx> Metadata<'a, 'tcx> for (&'a CrateMetadata, TyCtxt<'a, 'tcx, 'tcx>\n \n impl<'a, 'tcx: 'a, T: Decodable> Lazy<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> T {\n-        T::decode(&mut meta.decoder(self.position)).unwrap()\n+        let mut dcx = meta.decoder(self.position);\n+        dcx.lazy_state = LazyState::NodeStart(self.position);\n+        T::decode(&mut dcx).unwrap()\n     }\n }\n \n impl<'a, 'tcx: 'a, T: Decodable> LazySeq<T> {\n     pub fn decode<M: Metadata<'a, 'tcx>>(self, meta: M) -> impl Iterator<Item=T> + 'a {\n         let mut dcx = meta.decoder(self.position);\n+        dcx.lazy_state = LazyState::NodeStart(self.position);\n         (0..self.len).map(move |_| {\n             T::decode(&mut dcx).unwrap()\n         })\n@@ -137,12 +144,33 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     }\n \n     fn with_position<F: FnOnce(&mut Self) -> R, R>(&mut self, pos: usize, f: F) -> R {\n-        let new = opaque::Decoder::new(self.opaque.data, pos);\n-        let old = mem::replace(&mut self.opaque, new);\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n+        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n+        let old_state = mem::replace(&mut self.lazy_state, LazyState::NoNode);\n         let r = f(self);\n-        self.opaque = old;\n+        self.opaque = old_opaque;\n+        self.lazy_state = old_state;\n         r\n     }\n+\n+    fn read_lazy_distance(&mut self, min_size: usize)\n+                          -> Result<usize, <Self as Decoder>::Error> {\n+        let distance = self.read_usize()?;\n+        let position = match self.lazy_state {\n+            LazyState::NoNode => {\n+                bug!(\"read_lazy_distance: outside of a metadata node\")\n+            }\n+            LazyState::NodeStart(start) => {\n+                assert!(distance + min_size <= start);\n+                start - distance - min_size\n+            }\n+            LazyState::Previous(last_min_end) => {\n+                last_min_end + distance\n+            }\n+        };\n+        self.lazy_state = LazyState::Previous(position + min_size);\n+        Ok(position)\n+    }\n }\n \n macro_rules! decoder_methods {\n@@ -185,14 +213,19 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n \n impl<'a, 'tcx, T> SpecializedDecoder<Lazy<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Lazy<T>, Self::Error> {\n-        Ok(Lazy::with_position(self.read_usize()?))\n+        Ok(Lazy::with_position(self.read_lazy_distance(Lazy::<T>::min_size())?))\n     }\n }\n \n impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<LazySeq<T>, Self::Error> {\n         let len = self.read_usize()?;\n-        Ok(LazySeq::with_position_and_length(self.read_usize()?, len))\n+        let position = if len == 0 {\n+            0\n+        } else {\n+            self.read_lazy_distance(LazySeq::<T>::min_size(len))?\n+        };\n+        Ok(LazySeq::with_position_and_length(position, len))\n     }\n }\n "}, {"sha": "0f067270b80f5cb84c67bac8fc0ae956736ea6fd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 58, "deletions": 15, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/dc26a23301d8c435fae647174bd2906babbdb2f9/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc26a23301d8c435fae647174bd2906babbdb2f9/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=dc26a23301d8c435fae647174bd2906babbdb2f9", "patch": "@@ -53,6 +53,7 @@ pub struct EncodeContext<'a, 'tcx: 'a> {\n     reachable: &'a NodeSet,\n     mir_map: &'a MirMap<'tcx>,\n \n+    lazy_state: LazyState,\n     type_shorthands: FnvHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FnvHashMap<ty::Predicate<'tcx>, usize>,\n }\n@@ -95,14 +96,17 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx, T> SpecializedEncoder<Lazy<T>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, lazy: &Lazy<T>) -> Result<(), Self::Error> {\n-        self.emit_usize(lazy.position)\n+        self.emit_lazy_distance(lazy.position, Lazy::<T>::min_size())\n     }\n }\n \n impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, seq: &LazySeq<T>) -> Result<(), Self::Error> {\n         self.emit_usize(seq.len)?;\n-        self.emit_usize(seq.position)\n+        if seq.len == 0 {\n+            return Ok(());\n+        }\n+        self.emit_lazy_distance(seq.position, LazySeq::<T>::min_size(seq.len))\n     }\n }\n \n@@ -129,24 +133,62 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.opaque.position()\n     }\n \n-    pub fn lazy<T: Encodable>(&mut self, value: &T) -> Lazy<T> {\n+    fn emit_node<F: FnOnce(&mut Self, usize) -> R, R>(&mut self, f: F) -> R {\n+        assert_eq!(self.lazy_state, LazyState::NoNode);\n         let pos = self.position();\n-        value.encode(self).unwrap();\n-        Lazy::with_position(pos)\n+        self.lazy_state = LazyState::NodeStart(pos);\n+        let r = f(self, pos);\n+        self.lazy_state = LazyState::NoNode;\n+        r\n+    }\n+\n+    fn emit_lazy_distance(&mut self, position: usize, min_size: usize)\n+                          -> Result<(), <Self as Encoder>::Error> {\n+        let min_end = position + min_size;\n+        let distance = match self.lazy_state {\n+            LazyState::NoNode => {\n+                bug!(\"emit_lazy_distance: outside of a metadata node\")\n+            }\n+            LazyState::NodeStart(start) => {\n+                assert!(min_end <= start);\n+                start - min_end\n+            }\n+            LazyState::Previous(last_min_end) => {\n+                assert!(last_min_end <= position);\n+                position - last_min_end\n+            }\n+        };\n+        self.lazy_state = LazyState::Previous(min_end);\n+        self.emit_usize(distance)\n+    }\n+\n+    pub fn lazy<T: Encodable>(&mut self, value: &T) -> Lazy<T> {\n+        self.emit_node(|ecx, pos| {\n+            value.encode(ecx).unwrap();\n+\n+            assert!(pos + Lazy::<T>::min_size() <= ecx.position());\n+            Lazy::with_position(pos)\n+        })\n     }\n \n     fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n     where I: IntoIterator<Item=T>, T: Encodable {\n-        let pos = self.position();\n-        let len = iter.into_iter().map(|value| value.encode(self).unwrap()).count();\n-        LazySeq::with_position_and_length(pos, len)\n+        self.emit_node(|ecx, pos| {\n+            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+\n+            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n+            LazySeq::with_position_and_length(pos, len)\n+        })\n     }\n \n     fn lazy_seq_ref<'b, I, T>(&mut self, iter: I) -> LazySeq<T>\n     where I: IntoIterator<Item=&'b T>, T: 'b + Encodable {\n-        let pos = self.position();\n-        let len = iter.into_iter().map(|value| value.encode(self).unwrap()).count();\n-        LazySeq::with_position_and_length(pos, len)\n+        self.emit_node(|ecx, pos| {\n+            let len = iter.into_iter().map(|value| value.encode(ecx).unwrap()).count();\n+\n+            assert!(pos + LazySeq::<T>::min_size(len) <= ecx.position());\n+            LazySeq::with_position_and_length(pos, len)\n+        })\n     }\n \n     /// Encode the given value or a previously cached shorthand.\n@@ -1262,16 +1304,16 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 None\n             },\n \n-            index: index,\n             crate_deps: crate_deps,\n             dylib_dependency_formats: dylib_dependency_formats,\n-            native_libraries: native_libraries,\n             lang_items: lang_items,\n             lang_items_missing: lang_items_missing,\n+            native_libraries: native_libraries,\n+            codemap: codemap,\n+            macro_defs: macro_defs,\n             impls: impls,\n             reachable_ids: reachable_ids,\n-            macro_defs: macro_defs,\n-            codemap: codemap\n+            index: index,\n         });\n \n         let total_bytes = self.position();\n@@ -1345,6 +1387,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         cstore: cstore,\n         reachable: reachable,\n         mir_map: mir_map,\n+        lazy_state: LazyState::NoNode,\n         type_shorthands: Default::default(),\n         predicate_shorthands: Default::default()\n     }.encode_crate_root();"}, {"sha": "956577ed8fb89af7ec1abe1b13f258b0831eb5f1", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dc26a23301d8c435fae647174bd2906babbdb2f9/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc26a23301d8c435fae647174bd2906babbdb2f9/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=dc26a23301d8c435fae647174bd2906babbdb2f9", "patch": "@@ -52,6 +52,19 @@ pub const SHORTHAND_OFFSET: usize = 0x80;\n \n /// A value of type T referred to by its absolute position\n /// in the metadata, and which can be decoded lazily.\n+///\n+/// Metadata is effective a tree, encoded in post-order,\n+/// and with the root's position written next to the header.\n+/// That means every single `Lazy` points to some previous\n+/// location in the metadata and is part of a larger node.\n+///\n+/// The first `Lazy` in a node is encoded as the backwards\n+/// distance from the position where the containing node\n+/// starts and where the `Lazy` points to, while the rest\n+/// use the forward distance from the previous `Lazy`.\n+/// Distances start at 1, as 0-byte nodes are invalid.\n+/// Also invalid are nodes being referred in a different\n+/// order than they were encoded in.\n #[must_use]\n pub struct Lazy<T> {\n     pub position: usize,\n@@ -65,6 +78,12 @@ impl<T> Lazy<T> {\n             _marker: PhantomData\n         }\n     }\n+\n+    /// Returns the minimum encoded size of a value of type `T`.\n+    // FIXME(eddyb) Give better estimates for certain types.\n+    pub fn min_size() -> usize {\n+        1\n+    }\n }\n \n impl<T> Copy for Lazy<T> {}\n@@ -77,10 +96,16 @@ impl<T> serialize::UseSpecializedDecodable for Lazy<T> {}\n \n /// A sequence of type T referred to by its absolute position\n /// in the metadata and length, and which can be decoded lazily.\n+/// The sequence is a single node for the purposes of `Lazy`.\n ///\n /// Unlike `Lazy<Vec<T>>`, the length is encoded next to the\n /// position, not at the position, which means that the length\n /// doesn't need to be known before encoding all the elements.\n+///\n+/// If the length is 0, no position is encoded, but otherwise,\n+/// the encoding is that of `Lazy`, with the distinction that\n+/// the minimal distance the length of the sequence, i.e.\n+/// it's assumed there's no 0-byte element in the sequence.\n #[must_use]\n pub struct LazySeq<T> {\n     pub len: usize,\n@@ -100,6 +125,11 @@ impl<T> LazySeq<T> {\n             _marker: PhantomData\n         }\n     }\n+\n+    /// Returns the minimum encoded size of `length` values of type `T`.\n+    pub fn min_size(length: usize) -> usize {\n+        length\n+    }\n }\n \n impl<T> Copy for LazySeq<T> {}\n@@ -110,6 +140,22 @@ impl<T> Clone for LazySeq<T> {\n impl<T> serialize::UseSpecializedEncodable for LazySeq<T> {}\n impl<T> serialize::UseSpecializedDecodable for LazySeq<T> {}\n \n+/// Encoding / decoding state for `Lazy` and `LazySeq`.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum LazyState {\n+    /// Outside of a metadata node.\n+    NoNode,\n+\n+    /// Inside a metadata node, and before any `Lazy` or `LazySeq`.\n+    /// The position is that of the node itself.\n+    NodeStart(usize),\n+\n+    /// Inside a metadata node, with a previous `Lazy` or `LazySeq`.\n+    /// The position is a conservative estimate of where that\n+    /// previous `Lazy` / `LazySeq` would end (see their comments).\n+    Previous(usize)\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub rustc_version: String,\n@@ -121,16 +167,16 @@ pub struct CrateRoot {\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,\n \n-    pub index: LazySeq<index::Index>,\n     pub crate_deps: LazySeq<CrateDep>,\n     pub dylib_dependency_formats: LazySeq<Option<LinkagePreference>>,\n-    pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n     pub lang_items: LazySeq<(DefIndex, usize)>,\n     pub lang_items_missing: LazySeq<lang_items::LangItem>,\n+    pub native_libraries: LazySeq<(NativeLibraryKind, String)>,\n+    pub codemap: LazySeq<syntax_pos::FileMap>,\n+    pub macro_defs: LazySeq<MacroDef>,\n     pub impls: LazySeq<TraitImpls>,\n     pub reachable_ids: LazySeq<DefIndex>,\n-    pub macro_defs: LazySeq<MacroDef>,\n-    pub codemap: LazySeq<syntax_pos::FileMap>\n+    pub index: LazySeq<index::Index>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]"}]}