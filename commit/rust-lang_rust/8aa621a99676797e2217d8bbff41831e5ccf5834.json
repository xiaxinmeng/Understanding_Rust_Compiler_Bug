{"sha": "8aa621a99676797e2217d8bbff41831e5ccf5834", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYTYyMWE5OTY3Njc5N2UyMjE3ZDhiYmZmNDE4MzFlNWNjZjU4MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-12T13:40:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-12T13:40:46Z"}, "message": "Auto merge of #28914 - steveklabnik:doc_iterator, r=alexcrichton\n\nThis replaces what was there with a comprehensive overview.\r\n\r\nThanks to @hoverbear for suggesting that these docs needed improvement.", "tree": {"sha": "400f917b8df251d2297c3781f617c0127f7066b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/400f917b8df251d2297c3781f617c0127f7066b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aa621a99676797e2217d8bbff41831e5ccf5834", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aa621a99676797e2217d8bbff41831e5ccf5834", "html_url": "https://github.com/rust-lang/rust/commit/8aa621a99676797e2217d8bbff41831e5ccf5834", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aa621a99676797e2217d8bbff41831e5ccf5834/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "843e528fd0c09666cc5f2896258f88c25eaacb29", "url": "https://api.github.com/repos/rust-lang/rust/commits/843e528fd0c09666cc5f2896258f88c25eaacb29", "html_url": "https://github.com/rust-lang/rust/commit/843e528fd0c09666cc5f2896258f88c25eaacb29"}, {"sha": "1fbf8bb6640e6ddea034eac32f558b428da52477", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fbf8bb6640e6ddea034eac32f558b428da52477", "html_url": "https://github.com/rust-lang/rust/commit/1fbf8bb6640e6ddea034eac32f558b428da52477"}], "stats": {"total": 300, "additions": 271, "deletions": 29}, "files": [{"sha": "2f12579d67411c74e9e27e98c4a8564d1529042c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 271, "deletions": 29, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/8aa621a99676797e2217d8bbff41831e5ccf5834/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa621a99676797e2217d8bbff41831e5ccf5834/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=8aa621a99676797e2217d8bbff41831e5ccf5834", "patch": "@@ -8,51 +8,293 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Composable external iterators\n+//! Composable external iteration\n //!\n-//! # The `Iterator` trait\n+//! If you've found yourself with a collection of some kind, and needed to\n+//! perform an operation on the elements of said collection, you'll quickly run\n+//! into 'iterators'. Iterators are heavily used in idiomatic Rust code, so\n+//! it's worth becoming familiar with them.\n //!\n-//! This module defines Rust's core iteration trait. The `Iterator` trait has\n-//! one unimplemented method, `next`. All other methods are derived through\n-//! default methods to perform operations such as `zip`, `chain`, `enumerate`,\n-//! and `fold`.\n+//! Before explaining more, let's talk about how this module is structured:\n //!\n-//! The goal of this module is to unify iteration across all containers in Rust.\n-//! An iterator can be considered as a state machine which is used to track\n-//! which element will be yielded next.\n+//! # Organization\n //!\n-//! There are various extensions also defined in this module to assist with\n-//! various types of iteration, such as the `DoubleEndedIterator` for iterating\n-//! in reverse, the `FromIterator` trait for creating a container from an\n-//! iterator, and much more.\n+//! This module is largely organized by type:\n //!\n-//! # Rust's `for` loop\n+//! * [Traits] are the core portion: these traits define what kind of iterators\n+//!   exist and what you can do with them. The methods of these traits are worth\n+//!   putting some extra study time into.\n+//! * [Functions] provide some helpful ways to create some basic iterators.\n+//! * [Structs] are often the return types of the various methods on this\n+//!   module's traits. You'll usually want to look at the method that creates\n+//!   the `struct`, rather than the `struct` itself. For more detail about why,\n+//!   see '[Implementing Iterator](#implementing-iterator)'.\n //!\n-//! The special syntax used by rust's `for` loop is based around the\n-//! `IntoIterator` trait defined in this module. `for` loops can be viewed as a\n-//! syntactical expansion into a `loop`, for example, the `for` loop in this\n-//! example is essentially translated to the `loop` below.\n+//! [Traits]: #traits\n+//! [Functions]: #functions\n+//! [Structs]: #structs\n+//!\n+//! That's it! Let's dig into iterators.\n+//!\n+//! # Iterator\n+//!\n+//! The heart and soul of this module is the [`Iterator`] trait. The core of\n+//! [`Iterator`] looks like this:\n //!\n //! ```\n-//! let values = vec![1, 2, 3];\n+//! trait Iterator {\n+//!     type Item;\n+//!     fn next(&mut self) -> Option<Self::Item>;\n+//! }\n+//! ```\n+//!\n+//! An iterator has a method, [`next()`], which when called, returns an\n+//! [`Option`]`<Item>`. [`next()`] will return `Some(Item)` as long as there\n+//! are elements, and once they've all been exhausted, will return `None` to\n+//! indicate that iteration is finished. Individual iterators may choose to\n+//! resume iteration, and so calling [`next()`] again may or may not eventually\n+//! start returning `Some(Item)` again at some point.\n+//!\n+//! [`Iterator`]'s full definition includes a number of other methods as well,\n+//! but they are default methods, built on top of [`next()`], and so you get\n+//! them for free.\n+//!\n+//! Iterators are also composable, and it's common to chain them together to do\n+//! more complex forms of processing. See the [Adapters](#adapters) section\n+//! below for more details.\n+//!\n+//! [`Iterator`]: trait.Iterator.html\n+//! [`next()`]: trait.Iterator.html#tymethod.next\n+//! [`Option`]: ../option/enum.Option.html\n+//!\n+//! # The three forms of iteration\n+//!\n+//! There are three common methods which can create iterators from a collection:\n+//!\n+//! * `iter()`, which iterates over `&T`.\n+//! * `iter_mut()`, which iterates over `&mut T`.\n+//! * `into_iter()`, which iterates over `T`.\n+//!\n+//! Various things in the standard library may implement one or more of the\n+//! three, where appropriate.\n+//!\n+//! # Implementing Iterator\n+//!\n+//! Creating an iterator of your own involves two steps: creating a `struct` to\n+//! hold the iterator's state, and then `impl`ementing [`Iterator`] for that\n+//! `struct`. This is why there are so many `struct`s in this module: there is\n+//! one for each iterator and iterator adapter.\n+//!\n+//! Let's make an iterator named `Counter` which counts from `1` to `5`:\n+//!\n+//! ```\n+//! // First, the struct:\n+//!\n+//! /// An iterator which counts from one to five\n+//! struct Counter {\n+//!     count: i32,\n+//! }\n+//!\n+//! // we want our count to start at one, so let's add a new() method to help.\n+//! // This isn't strictly necessary, but is convenient. Note that we start\n+//! // `count` at zero, we'll see why in `next()`'s implementation below.\n+//! impl Counter {\n+//!     fn new() -> Counter {\n+//!         Counter { count: 0 }\n+//!     }\n+//! }\n+//!\n+//! // Then, we implement `Iterator` for our `Counter`:\n+//!\n+//! impl Iterator for Counter {\n+//!     // we will be counting with i32\n+//!     type Item = i32;\n+//!\n+//!     // next() is the only required method\n+//!     fn next(&mut self) -> Option<i32> {\n+//!         // increment our count. This is why we started at zero.\n+//!         self.count += 1;\n+//!\n+//!         // check to see if we've finished counting or not.\n+//!         if self.count < 6 {\n+//!             Some(self.count)\n+//!         } else {\n+//!             None\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! // And now we can use it!\n+//!\n+//! let mut counter = Counter::new();\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//!\n+//! let x = counter.next().unwrap();\n+//! println!(\"{}\", x);\n+//! ```\n+//!\n+//! This will print `1` through `5`, each on their own line.\n+//!\n+//! Calling `next()` this way gets repetitive. Rust has a construct which can\n+//! call `next()` on your iterator, until it reaches `None`. Let's go over that\n+//! next.\n+//!\n+//! # for Loops and IntoIterator\n+//!\n+//! Rust's `for` loop syntax is actually sugar for iterators. Here's a basic\n+//! example of `for`:\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n //!\n //! for x in values {\n //!     println!(\"{}\", x);\n //! }\n+//! ```\n //!\n-//! // Rough translation of the iteration without a `for` iterator.\n-//! # let values = vec![1, 2, 3];\n-//! let mut it = values.into_iter();\n-//! loop {\n-//!     match it.next() {\n-//!         Some(x) => println!(\"{}\", x),\n-//!         None => break,\n-//!     }\n+//! This will print the numbers one through five, each on their own line. But\n+//! you'll notice something here: we never called anything on our vector to\n+//! produce an iterator. What gives?\n+//!\n+//! There's a trait in the standard library for converting something into an\n+//! iterator: [`IntoIterator`]. This trait has one method, [`into_iter()`],\n+//! which converts the thing implementing [`IntoIterator`] into an iterator.\n+//! Let's take a look at that `for` loop again, and what the compiler converts\n+//! it into:\n+//!\n+//! [`IntoIterator`]: trait.IntoIterator.html\n+//! [`into_iter()`]: trait.IntoIterator.html#tymethod.into_iter\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in values {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! Rust de-sugars this into:\n+//!\n+//! ```\n+//! let values = vec![1, 2, 3, 4, 5];\n+//! {\n+//!     let result = match values.into_iter() {\n+//!         mut iter => loop {\n+//!             match iter.next() {\n+//!                 Some(x) => { println!(\"{}\", x); },\n+//!                 None => break,\n+//!             }\n+//!         },\n+//!     };\n+//!     result\n+//! }\n+//! ```\n+//!\n+//! First, we call `into_iter()` on the value. Then, we match on the iterator\n+//! that returns, calling [`next()`] over and over until we see a `None`. At\n+//! that point, we `break` out of the loop, and we're done iterating.\n+//!\n+//! There's one more subtle bit here: the standard library contains an\n+//! interesting implementation of [`IntoIterator`]:\n+//!\n+//! ```ignore\n+//! impl<I> IntoIterator for I where I: Iterator\n+//! ```\n+//!\n+//! In other words, all [`Iterator`]s implement [`IntoIterator`], by just\n+//! returning themselves. This means two things:\n+//!\n+//! 1. If you're writing an [`Iterator`], you can use it with a `for` loop.\n+//! 2. If you're creating a collection, implementing [`IntoIterator`] for it\n+//!    will allow your collection to be used with the `for` loop.\n+//!\n+//! # Adapters\n+//!\n+//! Functions which take an [`Iterator`] and return another [`Iterator`] are\n+//! often called 'iterator adapters', as they're a form of the 'adapter\n+//! pattern'.\n+//!\n+//! Common iterator adapters include [`map()`], [`take()`], and [`collect()`].\n+//! For more, see their documentation.\n+//!\n+//! [`map()`]: trait.Iterator.html#method.map\n+//! [`take()`]: trait.Iterator.html#method.take\n+//! [`collect()`]: trait.Iterator.html#method.collect\n+//!\n+//! # Laziness\n+//!\n+//! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n+//! just creating an iterator doesn't _do_ a whole lot. Nothing really happens\n+//! until you call [`next()`]. This is sometimes a source of confusion when\n+//! creating an iterator solely for its side effects. For example, the [`map()`]\n+//! method calls a closure on each element it iterates over:\n+//!\n+//! ```\n+//! let v = vec![1, 2, 3, 4, 5];\n+//! v.iter().map(|x| println!(\"{}\", x));\n+//! ```\n+//!\n+//! This will not print any values, as we only created an iterator, rather than\n+//! using it. The compiler will warn us about this kind of behavior:\n+//!\n+//! ```text\n+//! warning: unused result which must be used: iterator adaptors are lazy and\n+//! do nothing unless consumed\n+//! ```\n+//!\n+//! The idiomatic way to write a [`map()`] for its side effects is to use a\n+//! `for` loop instead:\n+//!\n+//! ```\n+//! let v = vec![1, 2, 3, 4, 5];\n+//!\n+//! for x in &v {\n+//!     println!(\"{}\", x);\n+//! }\n+//! ```\n+//!\n+//! [`map()`]: trait.Iterator.html#method.map\n+//!\n+//! The two most common ways to evaluate an iterator are to use a `for` loop\n+//! like this, or using the [`collect()`] adapter to produce a new collection.\n+//!\n+//! [`collect()`]: trait.Iterator.html#method.collect\n+//!\n+//! # Infinity\n+//!\n+//! Iterators do not have to be finite. As an example, an open-ended range is\n+//! an infinite iterator:\n+//!\n+//! ```\n+//! let numbers = 0..;\n+//! ```\n+//!\n+//! It is common to use the [`take()`] iterator adapter to turn an infinite\n+//! iterator into a finite one:\n+//!\n+//! ```\n+//! let numbers = 0..;\n+//! let five_numbers = numbers.take(5);\n+//!\n+//! for number in five_numbers {\n+//!     println!(\"{}\", number);\n //! }\n //! ```\n //!\n-//! Because `Iterator`s implement `IntoIterator`, this `for` loop syntax can be\n-//! applied to any iterator over any type.\n+//! This will print the numbers `0` through `4`, each on their own line.\n+//!\n+//! [`take()`]: trait.Iterator.html#method.take\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}]}