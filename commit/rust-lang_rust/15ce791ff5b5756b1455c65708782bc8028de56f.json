{"sha": "15ce791ff5b5756b1455c65708782bc8028de56f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1Y2U3OTFmZjViNTc1NmIxNDU1YzY1NzA4NzgyYmM4MDI4ZGU1NmY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-29T22:24:33Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:18Z"}, "message": "librustc: Port the pretty printer annotation infrastructure to use traits instead of garbage collected functions.", "tree": {"sha": "a0877c4a5212f3b5048d4381dd12d4ebd571b618", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0877c4a5212f3b5048d4381dd12d4ebd571b618"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15ce791ff5b5756b1455c65708782bc8028de56f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15ce791ff5b5756b1455c65708782bc8028de56f", "html_url": "https://github.com/rust-lang/rust/commit/15ce791ff5b5756b1455c65708782bc8028de56f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15ce791ff5b5756b1455c65708782bc8028de56f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33993535efb490ddb0e3afb6e08e4f945ec28a04", "url": "https://api.github.com/repos/rust-lang/rust/commits/33993535efb490ddb0e3afb6e08e4f945ec28a04", "html_url": "https://github.com/rust-lang/rust/commit/33993535efb490ddb0e3afb6e08e4f945ec28a04"}], "stats": {"total": 241, "additions": 143, "deletions": 98}, "files": [{"sha": "a1d8f4c2639788ec24c995780ead3448ab8f6c36", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 75, "deletions": 40, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/15ce791ff5b5756b1455c65708782bc8028de56f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ce791ff5b5756b1455c65708782bc8028de56f/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=15ce791ff5b5756b1455c65708782bc8028de56f", "patch": "@@ -439,15 +439,70 @@ pub fn compile_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n     phase_6_link_output(sess, &trans, outputs);\n }\n \n-pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n-                          ppm: PpMode) {\n+struct IdentifiedAnnotation {\n+    contents: (),\n+}\n \n-    fn ann_paren_for_expr(node: pprust::ann_node) {\n+impl pprust::pp_ann for IdentifiedAnnotation {\n+    fn pre(&self, node: pprust::ann_node) {\n         match node {\n-          pprust::node_expr(s, _) => pprust::popen(s),\n-          _ => ()\n+            pprust::node_expr(s, _) => pprust::popen(s),\n+            _ => ()\n+        }\n+    }\n+    fn post(&self, node: pprust::ann_node) {\n+        match node {\n+            pprust::node_item(s, item) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, item.id.to_str());\n+            }\n+            pprust::node_block(s, ref blk) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, ~\"block \" + blk.id.to_str());\n+            }\n+            pprust::node_expr(s, expr) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, expr.id.to_str());\n+                pprust::pclose(s);\n+            }\n+            pprust::node_pat(s, pat) => {\n+                pp::space(s.s);\n+                pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n+            }\n         }\n     }\n+}\n+\n+struct TypedAnnotation {\n+    analysis: CrateAnalysis,\n+}\n+\n+impl pprust::pp_ann for TypedAnnotation {\n+    fn pre(&self, node: pprust::ann_node) {\n+        match node {\n+            pprust::node_expr(s, _) => pprust::popen(s),\n+            _ => ()\n+        }\n+    }\n+    fn post(&self, node: pprust::ann_node) {\n+        let tcx = self.analysis.ty_cx;\n+        match node {\n+            pprust::node_expr(s, expr) => {\n+                pp::space(s.s);\n+                pp::word(s.s, \"as\");\n+                pp::space(s.s);\n+                pp::word(s.s, ppaux::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n+                pprust::pclose(s);\n+            }\n+            _ => ()\n+        }\n+    }\n+}\n+\n+pub fn pretty_print_input(sess: Session,\n+                          cfg: ast::CrateConfig,\n+                          input: &input,\n+                          ppm: PpMode) {\n     fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n         match node {\n           pprust::node_expr(s, expr) => {\n@@ -460,28 +515,6 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n           _ => ()\n         }\n     }\n-    fn ann_identified_post(node: pprust::ann_node) {\n-        match node {\n-          pprust::node_item(s, item) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, item.id.to_str());\n-          }\n-          pprust::node_block(s, ref blk) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(\n-                s, ~\"block \" + blk.id.to_str());\n-          }\n-          pprust::node_expr(s, expr) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, expr.id.to_str());\n-            pprust::pclose(s);\n-          }\n-          pprust::node_pat(s, pat) => {\n-            pp::space(s.s);\n-            pprust::synth_comment(s, ~\"pat \" + pat.id.to_str());\n-          }\n-        }\n-    }\n \n     let crate = phase_1_parse_input(sess, cfg.clone(), input);\n \n@@ -494,28 +527,30 @@ pub fn pretty_print_input(sess: Session, cfg: ast::CrateConfig, input: &input,\n \n     let annotation = match ppm {\n         PpmIdentified | PpmExpandedIdentified => {\n-            pprust::pp_ann {\n-                pre: ann_paren_for_expr,\n-                post: ann_identified_post\n-            }\n+            @IdentifiedAnnotation {\n+                contents: (),\n+            } as @pprust::pp_ann\n         }\n         PpmTyped => {\n             let analysis = phase_3_run_analysis_passes(sess, crate);\n-            pprust::pp_ann {\n-                pre: ann_paren_for_expr,\n-                post: |a| ann_typed_post(analysis.ty_cx, a)\n-            }\n+            @TypedAnnotation {\n+                analysis: analysis\n+            } as @pprust::pp_ann\n         }\n-        _ => pprust::no_ann()\n+        _ => @pprust::no_ann::new() as @pprust::pp_ann,\n     };\n \n     let src = sess.codemap.get_filemap(source_name(input)).src;\n     do io::with_str_reader(src) |rdr| {\n-        pprust::print_crate(sess.codemap, token::get_ident_interner(),\n-                            sess.span_diagnostic, crate,\n+        pprust::print_crate(sess.codemap,\n+                            token::get_ident_interner(),\n+                            sess.span_diagnostic,\n+                            crate,\n                             source_name(input),\n-                            rdr, io::stdout(),\n-                            annotation, is_expanded);\n+                            rdr,\n+                            io::stdout(),\n+                            annotation,\n+                            is_expanded);\n     }\n }\n "}, {"sha": "1af39f02d82b00dd936b3c678e3e0691cf3dea88", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/15ce791ff5b5756b1455c65708782bc8028de56f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ce791ff5b5756b1455c65708782bc8028de56f/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=15ce791ff5b5756b1455c65708782bc8028de56f", "patch": "@@ -87,6 +87,42 @@ struct LoopScope<'self> {\n     break_bits: ~[uint]\n }\n \n+impl<O:DataFlowOperator> pprust::pp_ann for DataFlowContext<O> {\n+    fn pre(&self, node: pprust::ann_node) {\n+        let (ps, id) = match node {\n+            pprust::node_expr(ps, expr) => (ps, expr.id),\n+            pprust::node_block(ps, blk) => (ps, blk.id),\n+            pprust::node_item(ps, _) => (ps, 0),\n+            pprust::node_pat(ps, pat) => (ps, pat.id)\n+        };\n+\n+        if self.nodeid_to_bitset.contains_key(&id) {\n+            let (start, end) = self.compute_id_range_frozen(id);\n+            let on_entry = self.on_entry.slice(start, end);\n+            let entry_str = bits_to_str(on_entry);\n+\n+            let gens = self.gens.slice(start, end);\n+            let gens_str = if gens.iter().any(|&u| u != 0) {\n+                fmt!(\" gen: %s\", bits_to_str(gens))\n+            } else {\n+                ~\"\"\n+            };\n+\n+            let kills = self.kills.slice(start, end);\n+            let kills_str = if kills.iter().any(|&u| u != 0) {\n+                fmt!(\" kill: %s\", bits_to_str(kills))\n+            } else {\n+                ~\"\"\n+            };\n+\n+            let comment_str = fmt!(\"id %d: %s%s%s\",\n+                                   id, entry_str, gens_str, kills_str);\n+            pprust::synth_comment(ps, comment_str);\n+            pp::space(ps.s);\n+        }\n+    }\n+}\n+\n impl<O:DataFlowOperator> DataFlowContext<O> {\n     pub fn new(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n@@ -319,46 +355,9 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     }\n \n     fn pretty_print_to(@self, wr: @io::Writer, blk: &ast::Block) {\n-        let pre: @fn(pprust::ann_node) = |node| {\n-            let (ps, id) = match node {\n-                pprust::node_expr(ps, expr) => (ps, expr.id),\n-                pprust::node_block(ps, blk) => (ps, blk.id),\n-                pprust::node_item(ps, _) => (ps, 0),\n-                pprust::node_pat(ps, pat) => (ps, pat.id)\n-            };\n-\n-            if self.nodeid_to_bitset.contains_key(&id) {\n-                let (start, end) = self.compute_id_range_frozen(id);\n-                let on_entry = self.on_entry.slice(start, end);\n-                let entry_str = bits_to_str(on_entry);\n-\n-                let gens = self.gens.slice(start, end);\n-                let gens_str = if gens.iter().any(|&u| u != 0) {\n-                    fmt!(\" gen: %s\", bits_to_str(gens))\n-                } else {\n-                    ~\"\"\n-                };\n-\n-                let kills = self.kills.slice(start, end);\n-                let kills_str = if kills.iter().any(|&u| u != 0) {\n-                    fmt!(\" kill: %s\", bits_to_str(kills))\n-                } else {\n-                    ~\"\"\n-                };\n-\n-                let comment_str = fmt!(\"id %d: %s%s%s\",\n-                                       id, entry_str, gens_str, kills_str);\n-                pprust::synth_comment(ps, comment_str);\n-                pp::space(ps.s);\n-            }\n-        };\n-\n-        let post: @fn(pprust::ann_node) = |_| {\n-        };\n-\n-        let ps = pprust::rust_printer_annotated(\n-            wr, self.tcx.sess.intr(),\n-            pprust::pp_ann {pre:pre, post:post});\n+        let ps = pprust::rust_printer_annotated(wr,\n+                                                self.tcx.sess.intr(),\n+                                                self as @pprust::pp_ann);\n         pprust::cbox(ps, pprust::indent_unit);\n         pprust::ibox(ps, 0u);\n         pprust::print_block(ps, blk);"}, {"sha": "6cdd6d2517beeb20b0f5882aa42e8f809565b27b", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/15ce791ff5b5756b1455c65708782bc8028de56f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15ce791ff5b5756b1455c65708782bc8028de56f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=15ce791ff5b5756b1455c65708782bc8028de56f", "patch": "@@ -37,16 +37,26 @@ pub enum ann_node<'self> {\n     node_expr(@ps, &'self ast::Expr),\n     node_pat(@ps, &'self ast::Pat),\n }\n-pub struct pp_ann {\n-    pre: @fn(ann_node),\n-    post: @fn(ann_node)\n+\n+pub trait pp_ann {\n+    fn pre(&self, _node: ann_node) {}\n+    fn post(&self, _node: ann_node) {}\n+}\n+\n+pub struct no_ann {\n+    contents: (),\n }\n \n-pub fn no_ann() -> pp_ann {\n-    fn ignore(_node: ann_node) { }\n-    return pp_ann {pre: ignore, post: ignore};\n+impl no_ann {\n+    pub fn new() -> no_ann {\n+        no_ann {\n+            contents: (),\n+        }\n+    }\n }\n \n+impl pp_ann for no_ann {}\n+\n pub struct CurrentCommentAndLiteral {\n     cur_cmnt: uint,\n     cur_lit: uint,\n@@ -60,7 +70,7 @@ pub struct ps {\n     literals: Option<~[comments::lit]>,\n     cur_cmnt_and_lit: @mut CurrentCommentAndLiteral,\n     boxes: @mut ~[pp::breaks],\n-    ann: pp_ann\n+    ann: @pp_ann\n }\n \n pub fn ibox(s: @ps, u: uint) {\n@@ -74,12 +84,13 @@ pub fn end(s: @ps) {\n }\n \n pub fn rust_printer(writer: @io::Writer, intr: @ident_interner) -> @ps {\n-    return rust_printer_annotated(writer, intr, no_ann());\n+    return rust_printer_annotated(writer, intr, @no_ann::new() as @pp_ann);\n }\n \n pub fn rust_printer_annotated(writer: @io::Writer,\n                               intr: @ident_interner,\n-                              ann: pp_ann) -> @ps {\n+                              ann: @pp_ann)\n+                              -> @ps {\n     return @ps {\n         s: pp::mk_printer(writer, default_columns),\n         cm: None::<@CodeMap>,\n@@ -109,7 +120,7 @@ pub fn print_crate(cm: @CodeMap,\n                    filename: @str,\n                    input: @io::Reader,\n                    out: @io::Writer,\n-                   ann: pp_ann,\n+                   ann: @pp_ann,\n                    is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n@@ -484,7 +495,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     let ann_node = node_item(s, item);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     match item.node {\n       ast::item_static(ref ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n@@ -635,7 +646,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         end(s);\n       }\n     }\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n }\n \n fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n@@ -958,7 +969,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n     }\n     maybe_print_comment(s, blk.span.lo);\n     let ann_node = node_block(s, blk);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     match embedded {\n       block_block_fn => end(s),\n       block_normal => bopen(s)\n@@ -979,7 +990,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n       _ => ()\n     }\n     bclose_maybe_open(s, blk.span, indented, close_box);\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n }\n \n pub fn print_if(s: @ps, test: &ast::Expr, blk: &ast::Block,\n@@ -1121,7 +1132,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     match expr.node {\n         ast::ExprVstore(e, v) => {\n             print_expr_vstore(s, v);\n@@ -1456,7 +1467,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n           pclose(s);\n       }\n     }\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n     end(s);\n }\n \n@@ -1578,7 +1589,7 @@ pub fn print_bounded_path(s: @ps, path: &ast::Path,\n pub fn print_pat(s: @ps, pat: &ast::Pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n-    (s.ann.pre)(ann_node);\n+    s.ann.pre(ann_node);\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     match pat.node {\n@@ -1678,7 +1689,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n         word(s.s, \"]\");\n       }\n     }\n-    (s.ann.post)(ann_node);\n+    s.ann.post(ann_node);\n }\n \n pub fn explicit_self_to_str(explicit_self: &ast::explicit_self_, intr: @ident_interner) -> ~str {"}]}