{"sha": "cf7e019b42cd523d91cb350ab49acbda1b11e571", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmN2UwMTliNDJjZDUyM2Q5MWNiMzUwYWI0OWFjYmRhMWIxMWU1NzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T03:22:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-12-13T03:22:20Z"}, "message": "Auto merge of #67271 - Centril:rollup-i71iqkv, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #66341 (Match `VecDeque::extend` to `Vec::extend_desugared`)\n - #67243 (LinkedList: drop remaining items when drop panics)\n - #67247 (Don't suggest wrong snippet in closure)\n - #67250 (Remove the `DelimSpan` from `NamedMatch::MatchedSeq`.)\n - #67251 (Require `allow_internal_unstable` for stable min_const_fn using unsta\u2026)\n - #67269 (parser: recover on `&'lifetime mut? $pat`.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "72dbc966b84267daf162c1bbfb59e0dc00bb4afb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72dbc966b84267daf162c1bbfb59e0dc00bb4afb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf7e019b42cd523d91cb350ab49acbda1b11e571", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf7e019b42cd523d91cb350ab49acbda1b11e571", "html_url": "https://github.com/rust-lang/rust/commit/cf7e019b42cd523d91cb350ab49acbda1b11e571", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf7e019b42cd523d91cb350ab49acbda1b11e571/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eeb8d4f2fbae0bb1c587d00b5abeaf938da47f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eeb8d4f2fbae0bb1c587d00b5abeaf938da47f4", "html_url": "https://github.com/rust-lang/rust/commit/3eeb8d4f2fbae0bb1c587d00b5abeaf938da47f4"}, {"sha": "d25197c52d7a1b2e1f06061e0f1b274812c25a30", "url": "https://api.github.com/repos/rust-lang/rust/commits/d25197c52d7a1b2e1f06061e0f1b274812c25a30", "html_url": "https://github.com/rust-lang/rust/commit/d25197c52d7a1b2e1f06061e0f1b274812c25a30"}], "stats": {"total": 354, "additions": 287, "deletions": 67}, "files": [{"sha": "6ee22834a460e72b124a9c2c81ea3294f12b5812", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -808,7 +808,21 @@ impl<T> LinkedList<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<#[may_dangle] T> Drop for LinkedList<T> {\n     fn drop(&mut self) {\n-        while let Some(_) = self.pop_front_node() {}\n+        struct DropGuard<'a, T>(&'a mut LinkedList<T>);\n+\n+        impl<'a, T> Drop for DropGuard<'a, T> {\n+            fn drop(&mut self) {\n+                // Continue the same loop we do below. This only runs when a destructor has\n+                // panicked. If another one panics this will abort.\n+                while let Some(_) = self.0.pop_front_node() {}\n+            }\n+        }\n+\n+        while let Some(node) = self.pop_front_node() {\n+            let guard = DropGuard(self);\n+            drop(node);\n+            mem::forget(guard);\n+        }\n     }\n }\n "}, {"sha": "ebd3f0100771b64d5f7b03dbfdf91a7755897dac", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -2809,7 +2809,22 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for VecDeque<A> {\n     fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n-        iter.into_iter().for_each(move |elt| self.push_back(elt));\n+        // This function should be the moral equivalent of:\n+        //\n+        //      for item in iter.into_iter() {\n+        //          self.push_back(item);\n+        //      }\n+        let mut iter = iter.into_iter();\n+        while let Some(element) = iter.next() {\n+            if self.len() == self.capacity() {\n+                let (lower, _) = iter.size_hint();\n+                self.reserve(lower.saturating_add(1));\n+            }\n+\n+            let head = self.head;\n+            self.head = self.wrap_add(self.head, 1);\n+            unsafe { self.buffer_write(head, element); }\n+        }\n     }\n }\n "}, {"sha": "54a77d643cbe36a1c35697fa95c723821b1edee1", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -1,4 +1,5 @@\n use std::collections::LinkedList;\n+use std::panic::catch_unwind;\n \n #[test]\n fn test_basic() {\n@@ -529,3 +530,109 @@ fn drain_filter_complex() {\n         assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n }\n+\n+\n+#[test]\n+fn test_drop() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    drop(ring);\n+\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_with_pop() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+\n+    drop(ring.pop_back());\n+    drop(ring.pop_front());\n+    assert_eq!(unsafe { DROPS }, 2);\n+\n+    drop(ring);\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_clear() {\n+    static mut DROPS: i32 = 0;\n+    struct Elem;\n+    impl Drop for Elem {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+        }\n+    }\n+\n+    let mut ring = LinkedList::new();\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.push_back(Elem);\n+    ring.push_front(Elem);\n+    ring.clear();\n+    assert_eq!(unsafe { DROPS }, 4);\n+\n+    drop(ring);\n+    assert_eq!(unsafe { DROPS }, 4);\n+}\n+\n+#[test]\n+fn test_drop_panic() {\n+    static mut DROPS: i32 = 0;\n+\n+    struct D(bool);\n+\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            unsafe {\n+                DROPS += 1;\n+            }\n+\n+            if self.0 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut q = LinkedList::new();\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_back(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(false));\n+    q.push_front(D(true));\n+\n+    catch_unwind(move || drop(q)).ok();\n+\n+    assert_eq!(unsafe { DROPS }, 8);\n+}"}, {"sha": "cc634101f0adf9f6f3452f0c8c4c953a6c3d8e3d", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -223,18 +223,24 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n     fn report(&mut self, error: GroupedMoveError<'tcx>) {\n         let (mut err, err_span) = {\n-            let (span, original_path, kind): (Span, &Place<'tcx>, &IllegalMoveOriginKind<'_>) =\n+            let (span, use_spans, original_path, kind,):\n+            (\n+                Span,\n+                Option<UseSpans>,\n+                &Place<'tcx>,\n+                &IllegalMoveOriginKind<'_>,\n+            ) =\n                 match error {\n                     GroupedMoveError::MovesFromPlace { span, ref original_path, ref kind, .. } |\n                     GroupedMoveError::MovesFromValue { span, ref original_path, ref kind, .. } => {\n-                        (span, original_path, kind)\n+                        (span, None, original_path, kind)\n                     }\n                     GroupedMoveError::OtherIllegalMove {\n                         use_spans,\n                         ref original_path,\n                         ref kind\n                     } => {\n-                        (use_spans.args_or_use(), original_path, kind)\n+                        (use_spans.args_or_use(), Some(use_spans), original_path, kind)\n                     },\n                 };\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n@@ -250,6 +256,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             original_path,\n                             target_place,\n                             span,\n+                            use_spans,\n                         )\n                     }\n                     IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n@@ -296,6 +303,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         move_place: &Place<'tcx>,\n         deref_target_place: &Place<'tcx>,\n         span: Span,\n+        use_spans: Option<UseSpans>,\n     ) -> DiagnosticBuilder<'a> {\n         // Inspect the type of the content behind the\n         // borrow to provide feedback about why this\n@@ -416,7 +424,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n             let is_option = move_ty.starts_with(\"std::option::Option\");\n             let is_result = move_ty.starts_with(\"std::result::Result\");\n-            if is_option || is_result {\n+            if (is_option || is_result) && use_spans.map_or(true, |v| !v.for_closure()) {\n                 err.span_suggestion(\n                     span,\n                     &format!(\"consider borrowing the `{}`'s content\", if is_option {"}, {"sha": "1c95155e7ff1c606ee27a18d7f8a6a7c20c994e5", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -80,7 +80,7 @@ fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span, fn_def_id: DefId) -> Mc\n     for ty in ty.walk() {\n         match ty.kind {\n             ty::Ref(_, _, hir::Mutability::Mutable) => {\n-                if !tcx.features().const_mut_refs {\n+                if !feature_allowed(tcx, fn_def_id, sym::const_mut_refs) {\n                     return Err((\n                         span,\n                         \"mutable references in const fn are unstable\".into(),\n@@ -220,7 +220,7 @@ fn check_statement(\n         }\n \n         | StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _)\n-        if !tcx.features().const_if_match\n+        if !feature_allowed(tcx, def_id, sym::const_if_match)\n         => {\n             Err((span, \"loops and conditional expressions are not stable in const fn\".into()))\n         }\n@@ -272,7 +272,7 @@ fn check_place(\n     while let &[ref proj_base @ .., elem] = cursor {\n         cursor = proj_base;\n         match elem {\n-            ProjectionElem::Downcast(..) if !tcx.features().const_if_match\n+            ProjectionElem::Downcast(..) if !feature_allowed(tcx, def_id, sym::const_if_match)\n                 => return Err((span, \"`match` or `if let` in `const fn` is unstable\".into())),\n             ProjectionElem::Downcast(_symbol, _variant_index) => {}\n \n@@ -329,7 +329,7 @@ fn check_terminator(\n \n         | TerminatorKind::FalseEdges { .. }\n         | TerminatorKind::SwitchInt { .. }\n-        if !tcx.features().const_if_match\n+        if !feature_allowed(tcx, def_id, sym::const_if_match)\n         => Err((\n             span,\n             \"loops and conditional expressions are not stable in const fn\".into(),\n@@ -341,7 +341,7 @@ fn check_terminator(\n         }\n \n         // FIXME(ecstaticmorse): We probably want to allow `Unreachable` unconditionally.\n-        TerminatorKind::Unreachable if tcx.features().const_if_match => Ok(()),\n+        TerminatorKind::Unreachable if feature_allowed(tcx, def_id, sym::const_if_match) => Ok(()),\n \n         | TerminatorKind::Abort | TerminatorKind::Unreachable => {\n             Err((span, \"const fn with unreachable code is not stable\".into()))"}, {"sha": "117b92dc9a5746812fc000c943e4830fb6199223", "filename": "src/librustc_parse/parser/pat.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibrustc_parse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpat.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -459,16 +459,26 @@ impl<'a> Parser<'a> {\n     /// Parse `&pat` / `&mut pat`.\n     fn parse_pat_deref(&mut self, expected: Expected) -> PResult<'a, PatKind> {\n         self.expect_and()?;\n+        self.recover_lifetime_in_deref_pat();\n         let mutbl = self.parse_mutability();\n+        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+        Ok(PatKind::Ref(subpat, mutbl))\n+    }\n \n+    fn recover_lifetime_in_deref_pat(&mut self) {\n         if let token::Lifetime(name) = self.token.kind {\n-            let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n-            err.span_label(self.token.span, \"unexpected lifetime\");\n-            return Err(err);\n-        }\n+            self.bump(); // `'a`\n \n-        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-        Ok(PatKind::Ref(subpat, mutbl))\n+            let span = self.prev_span;\n+            self.struct_span_err(span, &format!(\"unexpected lifetime `{}` in pattern\", name))\n+                .span_suggestion(\n+                    span,\n+                    \"remove the lifetime\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n+        }\n     }\n \n     /// Parse a tuple or parenthesis pattern."}, {"sha": "1e2f3f9d1e53e7dc7935e52927faf60ddee4ef74", "filename": "src/libsyntax_expand/mbe/macro_parser.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibsyntax_expand%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibsyntax_expand%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_parser.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -83,7 +83,7 @@ use syntax::print::pprust;\n use syntax::sess::ParseSess;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::token::{self, DocComment, Nonterminal, Token};\n-use syntax::tokenstream::{DelimSpan, TokenStream};\n+use syntax::tokenstream::TokenStream;\n \n use errors::{PResult, FatalError};\n use smallvec::{smallvec, SmallVec};\n@@ -164,11 +164,6 @@ struct MatcherPos<'root, 'tt> {\n     /// The position of the \"dot\" in this matcher\n     idx: usize,\n \n-    /// The first span of source that the beginning of this matcher corresponds to. In other\n-    /// words, the token in the source whose span is `sp_open` is matched against the first token of\n-    /// the matcher.\n-    sp_open: Span,\n-\n     /// For each named metavar in the matcher, we keep track of token trees matched against the\n     /// metavar by the black box parser. In particular, there may be more than one match per\n     /// metavar if we are in a repetition (each repetition matches each of the variables).\n@@ -307,17 +302,15 @@ fn create_matches(len: usize) -> Box<[Lrc<NamedMatchVec>]> {\n }\n \n /// Generates the top-level matcher position in which the \"dot\" is before the first token of the\n-/// matcher `ms` and we are going to start matching at the span `open` in the source.\n-fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree], open: Span) -> MatcherPos<'root, 'tt> {\n+/// matcher `ms`.\n+fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree]) -> MatcherPos<'root, 'tt> {\n     let match_idx_hi = count_names(ms);\n     let matches = create_matches(match_idx_hi);\n     MatcherPos {\n         // Start with the top level matcher given to us\n         top_elts: TtSeq(ms), // \"elts\" is an abbr. for \"elements\"\n         // The \"dot\" is before the first token of the matcher\n         idx: 0,\n-        // We start matching at the span `open` in the source code\n-        sp_open: open,\n \n         // Initialize `matches` to a bunch of empty `Vec`s -- one for each metavar in `top_elts`.\n         // `match_lo` for `top_elts` is 0 and `match_hi` is `matches.len()`. `match_cur` is 0 since\n@@ -355,7 +348,7 @@ fn initial_matcher_pos<'root, 'tt>(ms: &'tt [TokenTree], open: Span) -> MatcherP\n /// token tree it was derived from.\n #[derive(Debug, Clone)]\n crate enum NamedMatch {\n-    MatchedSeq(Lrc<NamedMatchVec>, DelimSpan),\n+    MatchedSeq(Lrc<NamedMatchVec>),\n     MatchedNonterminal(Lrc<Nonterminal>),\n }\n \n@@ -497,8 +490,7 @@ fn inner_parse_loop<'root, 'tt>(\n                     // Add matches from this repetition to the `matches` of `up`\n                     for idx in item.match_lo..item.match_hi {\n                         let sub = item.matches[idx].clone();\n-                        let span = DelimSpan::from_pair(item.sp_open, token.span);\n-                        new_pos.push_match(idx, MatchedSeq(sub, span));\n+                        new_pos.push_match(idx, MatchedSeq(sub));\n                     }\n \n                     // Move the \"dot\" past the repetition in `up`\n@@ -552,7 +544,7 @@ fn inner_parse_loop<'root, 'tt>(\n                         new_item.match_cur += seq.num_captures;\n                         new_item.idx += 1;\n                         for idx in item.match_cur..item.match_cur + seq.num_captures {\n-                            new_item.push_match(idx, MatchedSeq(Lrc::new(smallvec![]), sp));\n+                            new_item.push_match(idx, MatchedSeq(Lrc::new(smallvec![])));\n                         }\n                         cur_items.push(new_item);\n                     }\n@@ -568,7 +560,6 @@ fn inner_parse_loop<'root, 'tt>(\n                         match_cur: item.match_cur,\n                         match_hi: item.match_cur + seq.num_captures,\n                         up: Some(item),\n-                        sp_open: sp.open,\n                         top_elts: Tt(TokenTree::Sequence(sp, seq)),\n                     })));\n                 }\n@@ -663,7 +654,7 @@ pub(super) fn parse(\n     //\n     // This MatcherPos instance is allocated on the stack. All others -- and\n     // there are frequently *no* others! -- are allocated on the heap.\n-    let mut initial = initial_matcher_pos(ms, parser.token.span);\n+    let mut initial = initial_matcher_pos(ms);\n     let mut cur_items = smallvec![MatcherPosHandle::Ref(&mut initial)];\n     let mut next_items = Vec::new();\n "}, {"sha": "2dd15872a9f0a002c5cedb0d67b02656dfa42d14", "filename": "src/libsyntax_expand/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Fmacro_rules.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -379,7 +379,7 @@ pub fn compile_declarative_macro(\n \n     // Extract the arguments:\n     let lhses = match argument_map[&lhs_nm] {\n-        MatchedSeq(ref s, _) => s\n+        MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {\n@@ -402,7 +402,7 @@ pub fn compile_declarative_macro(\n     };\n \n     let rhses = match argument_map[&rhs_nm] {\n-        MatchedSeq(ref s, _) => s\n+        MatchedSeq(ref s) => s\n             .iter()\n             .map(|m| {\n                 if let MatchedNonterminal(ref nt) = *m {"}, {"sha": "0605f7ff36df711d1111d7d92a3b9b17b4304c5d", "filename": "src/libsyntax_expand/mbe/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fmbe%2Ftranscribe.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -299,7 +299,7 @@ fn lookup_cur_matched<'a>(\n         for &(idx, _) in repeats {\n             match matched {\n                 MatchedNonterminal(_) => break,\n-                MatchedSeq(ref ads, _) => matched = ads.get(idx).unwrap(),\n+                MatchedSeq(ref ads) => matched = ads.get(idx).unwrap(),\n             }\n         }\n \n@@ -382,7 +382,7 @@ fn lockstep_iter_size(\n             match lookup_cur_matched(name, interpolations, repeats) {\n                 Some(matched) => match matched {\n                     MatchedNonterminal(_) => LockstepIterSize::Unconstrained,\n-                    MatchedSeq(ref ads, _) => LockstepIterSize::Constraint(ads.len(), name),\n+                    MatchedSeq(ref ads) => LockstepIterSize::Constraint(ads.len(), name),\n                 },\n                 _ => LockstepIterSize::Unconstrained,\n             }"}, {"sha": "33abfec02a87a68dfa938a1d5e62928fe8a120bb", "filename": "src/test/ui/consts/const-mut-refs/const_mut_refs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -1,6 +1,7 @@\n // run-pass\n \n #![feature(const_mut_refs)]\n+#![feature(const_fn)]\n \n struct Foo {\n     x: usize"}, {"sha": "b9ff040915863d3cd64ebe5e2e0adfb12b7cc73d", "filename": "src/test/ui/consts/control-flow/basics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fbasics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fbasics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fbasics.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -4,6 +4,7 @@\n \n #![feature(const_panic)]\n #![feature(const_if_match)]\n+#![feature(const_fn)]\n \n const X: u32 = 4;\n const Y: u32 = 5;"}, {"sha": "7887fd12e5764a2f497c4b795617b911a57b11b6", "filename": "src/test/ui/consts/control-flow/exhaustive-c-like-enum-match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fexhaustive-c-like-enum-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fexhaustive-c-like-enum-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fexhaustive-c-like-enum-match.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -3,6 +3,7 @@\n // check-pass\n \n #![feature(const_if_match)]\n+#![feature(const_fn)]\n \n enum E {\n     A,"}, {"sha": "95096723b3c95f2e3009851146b06b5a160b633e", "filename": "src/test/ui/consts/control-flow/feature-gate-const-if-match.if_match.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.if_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.if_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.if_match.stderr?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -1,5 +1,5 @@\n error: fatal error triggered by #[rustc_error]\n-  --> $DIR/feature-gate-const-if-match.rs:108:1\n+  --> $DIR/feature-gate-const-if-match.rs:109:1\n    |\n LL | / fn main() {\n LL | |     let _ = [0; {"}, {"sha": "e4b65257531fdacbd999bfb03b86755822c40d18", "filename": "src/test/ui/consts/control-flow/feature-gate-const-if-match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -6,6 +6,7 @@\n \n #![feature(rustc_attrs)]\n #![cfg_attr(if_match, feature(const_if_match))]\n+#![feature(const_fn)]\n \n const _: i32 = if true { //[stock]~ ERROR `if` is not allowed in a `const`\n     5"}, {"sha": "e846ee4ab6a41bb1ac87db7deb64da6ebd462bc5", "filename": "src/test/ui/consts/control-flow/feature-gate-const-if-match.stock.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Ffeature-gate-const-if-match.stock.stderr?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:10:16\n+  --> $DIR/feature-gate-const-if-match.rs:11:16\n    |\n LL |   const _: i32 = if true {\n    |  ________________^\n@@ -13,7 +13,7 @@ LL | | };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:16:16\n+  --> $DIR/feature-gate-const-if-match.rs:17:16\n    |\n LL |   const _: i32 = if let Some(true) = Some(false) {\n    |  ________________^\n@@ -27,7 +27,7 @@ LL | | };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:22:16\n+  --> $DIR/feature-gate-const-if-match.rs:23:16\n    |\n LL |   const _: i32 = match 1 {\n    |  ________________^\n@@ -41,7 +41,7 @@ LL | | };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static`\n-  --> $DIR/feature-gate-const-if-match.rs:29:13\n+  --> $DIR/feature-gate-const-if-match.rs:30:13\n    |\n LL |     let x = if true { 0 } else { 1 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -50,7 +50,7 @@ LL |     let x = if true { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `static`\n-  --> $DIR/feature-gate-const-if-match.rs:31:13\n+  --> $DIR/feature-gate-const-if-match.rs:32:13\n    |\n LL |     let x = match x { 0 => 1, _ => 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -59,7 +59,7 @@ LL |     let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static`\n-  --> $DIR/feature-gate-const-if-match.rs:33:5\n+  --> $DIR/feature-gate-const-if-match.rs:34:5\n    |\n LL |     if let Some(x) = Some(x) { x } else { 1 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -68,7 +68,7 @@ LL |     if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-if-match.rs:38:13\n+  --> $DIR/feature-gate-const-if-match.rs:39:13\n    |\n LL |     let x = if true { 0 } else { 1 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -77,7 +77,7 @@ LL |     let x = if true { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-if-match.rs:40:13\n+  --> $DIR/feature-gate-const-if-match.rs:41:13\n    |\n LL |     let x = match x { 0 => 1, _ => 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -86,7 +86,7 @@ LL |     let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `static mut`\n-  --> $DIR/feature-gate-const-if-match.rs:42:5\n+  --> $DIR/feature-gate-const-if-match.rs:43:5\n    |\n LL |     if let Some(x) = Some(x) { x } else { 1 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -95,7 +95,7 @@ LL |     if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:47:5\n+  --> $DIR/feature-gate-const-if-match.rs:48:5\n    |\n LL |     if true { 5 } else { 6 }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -104,7 +104,7 @@ LL |     if true { 5 } else { 6 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:51:5\n+  --> $DIR/feature-gate-const-if-match.rs:52:5\n    |\n LL | /     if let Some(true) = a {\n LL | |         0\n@@ -117,7 +117,7 @@ LL | |     }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:59:5\n+  --> $DIR/feature-gate-const-if-match.rs:60:5\n    |\n LL | /     match i {\n LL | |         i if i > 10 => i,\n@@ -130,7 +130,7 @@ LL | |     }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:90:17\n+  --> $DIR/feature-gate-const-if-match.rs:91:17\n    |\n LL |         let x = if y { 0 } else { 1 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^\n@@ -139,7 +139,7 @@ LL |         let x = if y { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:92:17\n+  --> $DIR/feature-gate-const-if-match.rs:93:17\n    |\n LL |         let x = match x { 0 => 1, _ => 0 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -148,7 +148,7 @@ LL |         let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const fn`\n-  --> $DIR/feature-gate-const-if-match.rs:94:9\n+  --> $DIR/feature-gate-const-if-match.rs:95:9\n    |\n LL |         if let Some(x) = Some(x) { x } else { 1 }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -157,7 +157,7 @@ LL |         if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:110:17\n+  --> $DIR/feature-gate-const-if-match.rs:111:17\n    |\n LL |         let x = if false { 0 } else { 1 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ LL |         let x = if false { 0 } else { 1 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:112:17\n+  --> $DIR/feature-gate-const-if-match.rs:113:17\n    |\n LL |         let x = match x { 0 => 1, _ => 0 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -175,7 +175,7 @@ LL |         let x = match x { 0 => 1, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:114:9\n+  --> $DIR/feature-gate-const-if-match.rs:115:9\n    |\n LL |         if let Some(x) = Some(x) { x } else { 1 }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -184,7 +184,7 @@ LL |         if let Some(x) = Some(x) { x } else { 1 }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:67:21\n+  --> $DIR/feature-gate-const-if-match.rs:68:21\n    |\n LL |     const IF: i32 = if true { 5 } else { 6 };\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -193,7 +193,7 @@ LL |     const IF: i32 = if true { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:70:25\n+  --> $DIR/feature-gate-const-if-match.rs:71:25\n    |\n LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -202,7 +202,7 @@ LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:73:24\n+  --> $DIR/feature-gate-const-if-match.rs:74:24\n    |\n LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -211,7 +211,7 @@ LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:78:21\n+  --> $DIR/feature-gate-const-if-match.rs:79:21\n    |\n LL |     const IF: i32 = if true { 5 } else { 6 };\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -220,7 +220,7 @@ LL |     const IF: i32 = if true { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:81:25\n+  --> $DIR/feature-gate-const-if-match.rs:82:25\n    |\n LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -229,7 +229,7 @@ LL |     const IF_LET: i32 = if let Some(true) = None { 5 } else { 6 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `match` is not allowed in a `const`\n-  --> $DIR/feature-gate-const-if-match.rs:84:24\n+  --> $DIR/feature-gate-const-if-match.rs:85:24\n    |\n LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -238,7 +238,7 @@ LL |     const MATCH: i32 = match 0 { 1 => 2, _ => 0 };\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0019]: constant contains unimplemented expression type\n-  --> $DIR/feature-gate-const-if-match.rs:114:21\n+  --> $DIR/feature-gate-const-if-match.rs:115:21\n    |\n LL |         if let Some(x) = Some(x) { x } else { 1 }\n    |                     ^"}, {"sha": "4b20a2124c356aa516a4400281f93f462a0f8e56", "filename": "src/test/ui/consts/control-flow/short-circuit-let.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit-let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit-let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fshort-circuit-let.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -4,6 +4,7 @@\n \n #![feature(const_if_match)]\n #![feature(const_panic)]\n+#![feature(const_fn)]\n \n const X: i32 = {\n     let mut x = 0;"}, {"sha": "bb0fce66c4d899e280e32ec945cbac2bea1e997a", "filename": "src/test/ui/consts/control-flow/single_variant_match_ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fsingle_variant_match_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fsingle_variant_match_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fsingle_variant_match_ice.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![feature(const_if_match)]\n+#![feature(const_if_match, const_fn)]\n \n enum Foo {\n     Prob,"}, {"sha": "7fb14b8007671b2a99912145c88e737c372bb957", "filename": "src/test/ui/parser/lifetime-in-pattern-recover.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern-recover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern-recover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern-recover.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let &'a x = &0; //~ ERROR unexpected lifetime `'a` in pattern\n+    let &'a mut y = &mut 0; //~ ERROR unexpected lifetime `'a` in pattern\n+\n+    let _recovery_witness: () = 0; //~ ERROR mismatched types\n+}"}, {"sha": "4bf7f57bfb59f2c56b5a365f00bd3768cf219a02", "filename": "src/test/ui/parser/lifetime-in-pattern-recover.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern-recover.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern-recover.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern-recover.stderr?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -0,0 +1,23 @@\n+error: unexpected lifetime `'a` in pattern\n+  --> $DIR/lifetime-in-pattern-recover.rs:2:10\n+   |\n+LL |     let &'a x = &0;\n+   |          ^^ help: remove the lifetime\n+\n+error: unexpected lifetime `'a` in pattern\n+  --> $DIR/lifetime-in-pattern-recover.rs:3:10\n+   |\n+LL |     let &'a mut y = &mut 0;\n+   |          ^^ help: remove the lifetime\n+\n+error[E0308]: mismatched types\n+  --> $DIR/lifetime-in-pattern-recover.rs:5:33\n+   |\n+LL |     let _recovery_witness: () = 0;\n+   |                            --   ^ expected `()`, found integer\n+   |                            |\n+   |                            expected due to this\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d3c638d0cd74b052bcd34bf6e5761dbb9901fbb1", "filename": "src/test/ui/parser/lifetime-in-pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -1,5 +1,6 @@\n fn test(&'a str) {\n     //~^ ERROR unexpected lifetime `'a` in pattern\n+    //~| ERROR expected one of `:`, `@`, or `|`, found `)`\n }\n \n fn main() {"}, {"sha": "71fd3cdf72370d5eab2ae27c317f4953b39390a8", "filename": "src/test/ui/parser/lifetime-in-pattern.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Flifetime-in-pattern.stderr?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -2,7 +2,13 @@ error: unexpected lifetime `'a` in pattern\n   --> $DIR/lifetime-in-pattern.rs:1:10\n    |\n LL | fn test(&'a str) {\n-   |          ^^ unexpected lifetime\n+   |          ^^ help: remove the lifetime\n \n-error: aborting due to previous error\n+error: expected one of `:`, `@`, or `|`, found `)`\n+  --> $DIR/lifetime-in-pattern.rs:1:16\n+   |\n+LL | fn test(&'a str) {\n+   |                ^ expected one of `:`, `@`, or `|`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "2beef50cdb5c64cdaf599dcad73165d0de6de747", "filename": "src/test/ui/self/self-vs-path-ambiguity.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fself%2Fself-vs-path-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fself%2Fself-vs-path-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-vs-path-ambiguity.stderr?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -2,7 +2,7 @@ error: unexpected lifetime `'a` in pattern\n   --> $DIR/self-vs-path-ambiguity.rs:9:11\n    |\n LL |     fn i(&'a self::S: &S) {}\n-   |           ^^ unexpected lifetime\n+   |           ^^ help: remove the lifetime\n \n error: aborting due to previous error\n "}, {"sha": "88e8a5b7aeef06e0293c4f52a2c4979b66e8f3b1", "filename": "src/test/ui/suggestions/option-content-move2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.rs?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -0,0 +1,16 @@\n+struct NotCopyable;\n+\n+fn func<F: FnMut() -> H, H: FnMut()>(_: F) {}\n+\n+fn parse() {\n+    let mut var = None;\n+    func(|| {\n+        // Shouldn't suggest `move ||.as_ref()` here\n+        move || {\n+        //~^ ERROR: cannot move out of `var`\n+            var = Some(NotCopyable);\n+        }\n+    });\n+}\n+\n+fn main() {}"}, {"sha": "71f745374e5acd7011c9eafe63070d9961279f1c", "filename": "src/test/ui/suggestions/option-content-move2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cf7e019b42cd523d91cb350ab49acbda1b11e571/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move2.stderr?ref=cf7e019b42cd523d91cb350ab49acbda1b11e571", "patch": "@@ -0,0 +1,18 @@\n+error[E0507]: cannot move out of `var`, a captured variable in an `FnMut` closure\n+  --> $DIR/option-content-move2.rs:9:9\n+   |\n+LL |     let mut var = None;\n+   |         ------- captured outer variable\n+...\n+LL |         move || {\n+   |         ^^^^^^^ move out of `var` occurs here\n+LL |\n+LL |             var = Some(NotCopyable);\n+   |             ---\n+   |             |\n+   |             move occurs because `var` has type `std::option::Option<NotCopyable>`, which does not implement the `Copy` trait\n+   |             move occurs due to use in closure\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}]}