{"sha": "91f128baf7704a477ab7c499143a160fb069b3ad", "node_id": "C_kwDOAAsO6NoAKDkxZjEyOGJhZjc3MDRhNDc3YWI3YzQ5OTE0M2ExNjBmYjA2OWIzYWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T04:16:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-28T04:16:29Z"}, "message": "Auto merge of #92845 - Amanieu:std_personality, r=Mark-Simulacrum\n\nMove EH personality functions to std\n\nThese were previously in the panic_unwind crate with dummy stubs in the\npanic_abort crate. However it turns out that this is insufficient: we\nstill need a proper personality function even with -C panic=abort to\nhandle the following cases:\n\n1) `extern \"C-unwind\"` still needs to catch foreign exceptions with -C\npanic=abort to turn them into aborts. This requires landing pads and a\npersonality function.\n\n2) ARM EHABI uses the personality function when creating backtraces.\nThe dummy personality function in panic_abort was causing backtrace\ngeneration to get stuck in a loop since the personality function is\nresponsible for advancing the unwind state to the next frame.\n\nFixes #41004", "tree": {"sha": "e9b630fceeee3164f04ca67f6ccb868e4ac42781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b630fceeee3164f04ca67f6ccb868e4ac42781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91f128baf7704a477ab7c499143a160fb069b3ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91f128baf7704a477ab7c499143a160fb069b3ad", "html_url": "https://github.com/rust-lang/rust/commit/91f128baf7704a477ab7c499143a160fb069b3ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91f128baf7704a477ab7c499143a160fb069b3ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e978a3627bd65064164af3548c585fb25eef9d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e978a3627bd65064164af3548c585fb25eef9d2", "html_url": "https://github.com/rust-lang/rust/commit/1e978a3627bd65064164af3548c585fb25eef9d2"}, {"sha": "a7e4794c2effd128a223ce3df0816637ac0a8d7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e4794c2effd128a223ce3df0816637ac0a8d7c", "html_url": "https://github.com/rust-lang/rust/commit/a7e4794c2effd128a223ce3df0816637ac0a8d7c"}], "stats": {"total": 718, "additions": 379, "deletions": 339}, "files": [{"sha": "32b340832ce289625a283503b9bdf090c2a608c6", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -103,18 +103,14 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             }\n         })\n         .map(|def_id| {\n-            let (export_level, used) = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name;\n-                // We won't link right if these symbols are stripped during LTO.\n-                let used = match name {\n-                    \"rust_eh_personality\"\n-                    | \"rust_eh_register_frames\"\n-                    | \"rust_eh_unregister_frames\" => true,\n-                    _ => false,\n-                };\n-                (SymbolExportLevel::Rust, used)\n+            // We won't link right if this symbol is stripped during LTO.\n+            let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name;\n+            let used = name == \"rust_eh_personality\";\n+\n+            let export_level = if special_runtime_crate {\n+                SymbolExportLevel::Rust\n             } else {\n-                (symbol_export_level(tcx, def_id.to_def_id()), false)\n+                symbol_export_level(tcx, def_id.to_def_id())\n             };\n             let codegen_attrs = tcx.codegen_fn_attrs(def_id.to_def_id());\n             debug!("}, {"sha": "cba8ef25db62687021f8eacf3f837da1fb2251a9", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -113,27 +113,11 @@ pub unsafe fn __rust_start_panic(_payload: *mut &mut dyn BoxMeUp) -> u32 {\n // binaries, but it should never be called as we don't link in an unwinding\n // runtime at all.\n pub mod personalities {\n-    #[rustc_std_internal_symbol]\n-    #[cfg(not(any(\n-        all(target_family = \"wasm\", not(target_os = \"emscripten\")),\n-        all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86_64\",),\n-    )))]\n-    pub extern \"C\" fn rust_eh_personality() {}\n-\n-    // On x86_64-pc-windows-gnu we use our own personality function that needs\n-    // to return `ExceptionContinueSearch` as we're passing on all our frames.\n-    #[rustc_std_internal_symbol]\n-    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86_64\"))]\n-    pub extern \"C\" fn rust_eh_personality(\n-        _record: usize,\n-        _frame: usize,\n-        _context: usize,\n-        _dispatcher: usize,\n-    ) -> u32 {\n-        1 // `ExceptionContinueSearch`\n-    }\n+    // In the past this module used to contain stubs for the personality\n+    // functions of various platforms, but these where removed when personality\n+    // functions were moved to std.\n \n-    // Similar to above, this corresponds to the `eh_catch_typeinfo` lang item\n+    // This corresponds to the `eh_catch_typeinfo` lang item\n     // that's only used on Emscripten currently.\n     //\n     // Since panics don't generate exceptions and foreign exceptions are\n@@ -143,13 +127,4 @@ pub mod personalities {\n     #[allow(non_upper_case_globals)]\n     #[cfg(target_os = \"emscripten\")]\n     static rust_eh_catch_typeinfo: [usize; 2] = [0; 2];\n-\n-    // These two are called by our startup objects on i686-pc-windows-gnu, but\n-    // they don't need to do anything so the bodies are nops.\n-    #[rustc_std_internal_symbol]\n-    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n-    pub extern \"C\" fn rust_eh_register_frames() {}\n-    #[rustc_std_internal_symbol]\n-    #[cfg(all(target_os = \"windows\", target_env = \"gnu\", target_arch = \"x86\"))]\n-    pub extern \"C\" fn rust_eh_unregister_frames() {}\n }"}, {"sha": "7c233c7c3a1cb0f08626653e4bd218f2ece215fe", "filename": "library/panic_unwind/src/emcc.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Femcc.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -12,7 +12,6 @@ use core::intrinsics;\n use core::mem;\n use core::ptr;\n use core::sync::atomic::{AtomicBool, Ordering};\n-use libc::{self, c_int};\n use unwind as uw;\n \n // This matches the layout of std::type_info in C++\n@@ -105,21 +104,6 @@ extern \"C\" fn exception_cleanup(ptr: *mut libc::c_void) -> *mut libc::c_void {\n     }\n }\n \n-// This is required by the compiler to exist (e.g., it's a lang item), but it's\n-// never actually called by the compiler.  Emscripten EH doesn't use a\n-// personality function at all, it instead uses __cxa_find_matching_catch.\n-// Wasm error handling would use __gxx_personality_wasm0.\n-#[lang = \"eh_personality\"]\n-unsafe extern \"C\" fn rust_eh_personality(\n-    _version: c_int,\n-    _actions: uw::_Unwind_Action,\n-    _exception_class: uw::_Unwind_Exception_Class,\n-    _exception_object: *mut uw::_Unwind_Exception,\n-    _context: *mut uw::_Unwind_Context,\n-) -> uw::_Unwind_Reason_Code {\n-    core::intrinsics::abort()\n-}\n-\n extern \"C\" {\n     fn __cxa_allocate_exception(thrown_size: libc::size_t) -> *mut libc::c_void;\n     fn __cxa_begin_catch(thrown_exception: *mut libc::c_void) -> *mut libc::c_void;"}, {"sha": "261404e8795fce31722240d700fc722485fe2047", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -39,8 +39,6 @@\n use alloc::boxed::Box;\n use core::any::Any;\n \n-use crate::dwarf::eh::{self, EHAction, EHContext};\n-use libc::{c_int, uintptr_t};\n use unwind as uw;\n \n #[repr(C)]\n@@ -89,263 +87,3 @@ fn rust_exception_class() -> uw::_Unwind_Exception_Class {\n     // M O Z \\0  R U S T -- vendor, language\n     0x4d4f5a_00_52555354\n }\n-\n-// Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n-// and TargetLowering::getExceptionSelectorRegister() for each architecture,\n-// then mapped to DWARF register numbers via register definition tables\n-// (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n-// See also https://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n-\n-#[cfg(target_arch = \"x86\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n-\n-#[cfg(target_arch = \"x86_64\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n-\n-#[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n-\n-#[cfg(target_arch = \"m68k\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // D0, D1\n-\n-#[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n-\n-#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n-\n-#[cfg(target_arch = \"s390x\")]\n-const UNWIND_DATA_REG: (i32, i32) = (6, 7); // R6, R7\n-\n-#[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (24, 25); // I0, I1\n-\n-#[cfg(target_arch = \"hexagon\")]\n-const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n-\n-#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n-const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n-\n-// The following code is based on GCC's C and C++ personality routines.  For reference, see:\n-// https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n-// https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n-\n-cfg_if::cfg_if! {\n-    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"watchos\"), not(target_os = \"netbsd\")))] {\n-        // ARM EHABI personality routine.\n-        // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n-        //\n-        // iOS uses the default routine instead since it uses SjLj unwinding.\n-        #[lang = \"eh_personality\"]\n-        unsafe extern \"C\" fn rust_eh_personality(state: uw::_Unwind_State,\n-                                                 exception_object: *mut uw::_Unwind_Exception,\n-                                                 context: *mut uw::_Unwind_Context)\n-                                                 -> uw::_Unwind_Reason_Code {\n-            let state = state as c_int;\n-            let action = state & uw::_US_ACTION_MASK as c_int;\n-            let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n-                // Backtraces on ARM will call the personality routine with\n-                // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n-                // we want to continue unwinding the stack, otherwise all our backtraces\n-                // would end at __rust_try\n-                if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n-                    return continue_unwind(exception_object, context);\n-                }\n-                true\n-            } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n-                false\n-            } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n-                return continue_unwind(exception_object, context);\n-            } else {\n-                return uw::_URC_FAILURE;\n-            };\n-\n-            // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n-            // and LSDA pointers, however ARM EHABI places them into the exception object.\n-            // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n-            // take only the context pointer, GCC personality routines stash a pointer to\n-            // exception_object in the context, using location reserved for ARM's\n-            // \"scratch register\" (r12).\n-            uw::_Unwind_SetGR(context,\n-                              uw::UNWIND_POINTER_REG,\n-                              exception_object as uw::_Unwind_Ptr);\n-            // ...A more principled approach would be to provide the full definition of ARM's\n-            // _Unwind_Context in our libunwind bindings and fetch the required data from there\n-            // directly, bypassing DWARF compatibility functions.\n-\n-            let eh_action = match find_eh_action(context) {\n-                Ok(action) => action,\n-                Err(_) => return uw::_URC_FAILURE,\n-            };\n-            if search_phase {\n-                match eh_action {\n-                    EHAction::None |\n-                    EHAction::Cleanup(_) => return continue_unwind(exception_object, context),\n-                    EHAction::Catch(_) => {\n-                        // EHABI requires the personality routine to update the\n-                        // SP value in the barrier cache of the exception object.\n-                        (*exception_object).private[5] =\n-                            uw::_Unwind_GetGR(context, uw::UNWIND_SP_REG);\n-                        return uw::_URC_HANDLER_FOUND;\n-                    }\n-                    EHAction::Terminate => return uw::_URC_FAILURE,\n-                }\n-            } else {\n-                match eh_action {\n-                    EHAction::None => return continue_unwind(exception_object, context),\n-                    EHAction::Cleanup(lpad) |\n-                    EHAction::Catch(lpad) => {\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n-                                          exception_object as uintptr_t);\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                        uw::_Unwind_SetIP(context, lpad);\n-                        return uw::_URC_INSTALL_CONTEXT;\n-                    }\n-                    EHAction::Terminate => return uw::_URC_FAILURE,\n-                }\n-            }\n-\n-            // On ARM EHABI the personality routine is responsible for actually\n-            // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n-            unsafe fn continue_unwind(exception_object: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code {\n-                if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n-                    uw::_URC_CONTINUE_UNWIND\n-                } else {\n-                    uw::_URC_FAILURE\n-                }\n-            }\n-            // defined in libgcc\n-            extern \"C\" {\n-                fn __gnu_unwind_frame(exception_object: *mut uw::_Unwind_Exception,\n-                                      context: *mut uw::_Unwind_Context)\n-                                      -> uw::_Unwind_Reason_Code;\n-            }\n-        }\n-    } else {\n-        // Default personality routine, which is used directly on most targets\n-        // and indirectly on Windows x86_64 via SEH.\n-        unsafe extern \"C\" fn rust_eh_personality_impl(version: c_int,\n-                                                      actions: uw::_Unwind_Action,\n-                                                      _exception_class: uw::_Unwind_Exception_Class,\n-                                                      exception_object: *mut uw::_Unwind_Exception,\n-                                                      context: *mut uw::_Unwind_Context)\n-                                                      -> uw::_Unwind_Reason_Code {\n-            if version != 1 {\n-                return uw::_URC_FATAL_PHASE1_ERROR;\n-            }\n-            let eh_action = match find_eh_action(context) {\n-                Ok(action) => action,\n-                Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n-            };\n-            if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n-                match eh_action {\n-                    EHAction::None |\n-                    EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n-                    EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n-                }\n-            } else {\n-                match eh_action {\n-                    EHAction::None => uw::_URC_CONTINUE_UNWIND,\n-                    EHAction::Cleanup(lpad) |\n-                    EHAction::Catch(lpad) => {\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.0,\n-                            exception_object as uintptr_t);\n-                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n-                        uw::_Unwind_SetIP(context, lpad);\n-                        uw::_URC_INSTALL_CONTEXT\n-                    }\n-                    EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n-                }\n-            }\n-        }\n-\n-        cfg_if::cfg_if! {\n-            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n-                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n-                // handler data (aka LSDA) uses GCC-compatible encoding.\n-                #[lang = \"eh_personality\"]\n-                #[allow(nonstandard_style)]\n-                unsafe extern \"C\" fn rust_eh_personality(exceptionRecord: *mut uw::EXCEPTION_RECORD,\n-                        establisherFrame: uw::LPVOID,\n-                        contextRecord: *mut uw::CONTEXT,\n-                        dispatcherContext: *mut uw::DISPATCHER_CONTEXT)\n-                        -> uw::EXCEPTION_DISPOSITION {\n-                    uw::_GCC_specific_handler(exceptionRecord,\n-                                             establisherFrame,\n-                                             contextRecord,\n-                                             dispatcherContext,\n-                                             rust_eh_personality_impl)\n-                }\n-            } else {\n-                // The personality routine for most of our targets.\n-                #[lang = \"eh_personality\"]\n-                unsafe extern \"C\" fn rust_eh_personality(version: c_int,\n-                        actions: uw::_Unwind_Action,\n-                        exception_class: uw::_Unwind_Exception_Class,\n-                        exception_object: *mut uw::_Unwind_Exception,\n-                        context: *mut uw::_Unwind_Context)\n-                        -> uw::_Unwind_Reason_Code {\n-                    rust_eh_personality_impl(version,\n-                                             actions,\n-                                             exception_class,\n-                                             exception_object,\n-                                             context)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> Result<EHAction, ()> {\n-    let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n-    let mut ip_before_instr: c_int = 0;\n-    let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n-    let eh_context = EHContext {\n-        // The return address points 1 byte past the call instruction,\n-        // which could be in the next IP range in LSDA range table.\n-        //\n-        // `ip = -1` has special meaning, so use wrapping sub to allow for that\n-        ip: if ip_before_instr != 0 { ip } else { ip.wrapping_sub(1) },\n-        func_start: uw::_Unwind_GetRegionStart(context),\n-        get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n-        get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n-    };\n-    eh::find_eh_action(lsda, &eh_context)\n-}\n-\n-// Frame unwind info registration\n-//\n-// Each module's image contains a frame unwind info section (usually\n-// \".eh_frame\").  When a module is loaded/unloaded into the process, the\n-// unwinder must be informed about the location of this section in memory. The\n-// methods of achieving that vary by the platform.  On some (e.g., Linux), the\n-// unwinder can discover unwind info sections on its own (by dynamically\n-// enumerating currently loaded modules via the dl_iterate_phdr() API and\n-// finding their \".eh_frame\" sections); Others, like Windows, require modules\n-// to actively register their unwind info sections via unwinder API.\n-//\n-// This module defines two symbols which are referenced and called from\n-// rsbegin.rs to register our information with the GCC runtime. The\n-// implementation of stack unwinding is (for now) deferred to libgcc_eh, however\n-// Rust crates use these Rust-specific entry points to avoid potential clashes\n-// with any GCC runtime.\n-#[cfg(all(target_os = \"windows\", target_arch = \"x86\", target_env = \"gnu\"))]\n-pub mod eh_frame_registry {\n-    extern \"C\" {\n-        fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n-        fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n-    }\n-\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern \"C\" fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8) {\n-        __register_frame_info(eh_frame_begin, object);\n-    }\n-\n-    #[rustc_std_internal_symbol]\n-    pub unsafe extern \"C\" fn rust_eh_unregister_frames(eh_frame_begin: *const u8, object: *mut u8) {\n-        __deregister_frame_info(eh_frame_begin, object);\n-    }\n-}"}, {"sha": "1eb4f378904a9894efcddba25f6138e5aac883c9", "filename": "library/panic_unwind/src/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Flib.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -52,9 +52,6 @@ cfg_if::cfg_if! {\n         all(target_family = \"unix\", not(target_os = \"espidf\")),\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n     ))] {\n-        // Rust runtime's startup objects depend on these symbols, so make them public.\n-        #[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n-        pub use real_imp::eh_frame_registry::*;\n         #[path = \"gcc.rs\"]\n         mod real_imp;\n     } else {\n@@ -92,8 +89,6 @@ extern \"C\" {\n     fn __rust_foreign_exception() -> !;\n }\n \n-mod dwarf;\n-\n #[rustc_std_internal_symbol]\n #[allow(improper_ctypes_definitions)]\n pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> *mut (dyn Any + Send + 'static) {"}, {"sha": "6b8d0656861130bc3535354a28d9e834928040e7", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -326,13 +326,3 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n         exception.data.take().unwrap()\n     }\n }\n-\n-// This is required by the compiler to exist (e.g., it's a lang item), but\n-// it's never actually called by the compiler because __C_specific_handler\n-// or _except_handler3 is the personality function that is always used.\n-// Hence this is just an aborting stub.\n-#[lang = \"eh_personality\"]\n-#[cfg(not(test))]\n-fn rust_eh_personality() {\n-    core::intrinsics::abort()\n-}"}, {"sha": "1df0c897053800a3636a440da1e1c5f2f98a205f", "filename": "library/rtstartup/rsbegin.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Frtstartup%2Frsbegin.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -35,6 +35,16 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n     drop_in_place(to_drop);\n }\n \n+// Frame unwind info registration\n+//\n+// Each module's image contains a frame unwind info section (usually\n+// \".eh_frame\").  When a module is loaded/unloaded into the process, the\n+// unwinder must be informed about the location of this section in memory. The\n+// methods of achieving that vary by the platform.  On some (e.g., Linux), the\n+// unwinder can discover unwind info sections on its own (by dynamically\n+// enumerating currently loaded modules via the dl_iterate_phdr() API and\n+// finding their \".eh_frame\" sections); Others, like Windows, require modules\n+// to actively register their unwind info sections via unwinder API.\n #[cfg(all(target_os = \"windows\", target_arch = \"x86\", target_env = \"gnu\"))]\n pub mod eh_frames {\n     #[no_mangle]\n@@ -62,20 +72,19 @@ pub mod eh_frames {\n     }\n \n     // Unwind info registration/deregistration routines.\n-    // See the docs of libpanic_unwind.\n     extern \"C\" {\n-        fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8);\n-        fn rust_eh_unregister_frames(eh_frame_begin: *const u8, object: *mut u8);\n+        fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n+        fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n     }\n \n     unsafe extern \"C\" fn init() {\n         // register unwind info on module startup\n-        rust_eh_register_frames(&__EH_FRAME_BEGIN__ as *const u8, &mut OBJ as *mut _ as *mut u8);\n+        __register_frame_info(&__EH_FRAME_BEGIN__ as *const u8, &mut OBJ as *mut _ as *mut u8);\n     }\n \n     unsafe extern \"C\" fn uninit() {\n         // unregister on shutdown\n-        rust_eh_unregister_frames(&__EH_FRAME_BEGIN__ as *const u8, &mut OBJ as *mut _ as *mut u8);\n+        __deregister_frame_info(&__EH_FRAME_BEGIN__ as *const u8, &mut OBJ as *mut _ as *mut u8);\n     }\n \n     // MinGW-specific init/uninit routine registration"}, {"sha": "c918c9ba818e07c47968b15d9f0a8f0978e383ea", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -594,6 +594,7 @@ pub mod alloc;\n \n // Private support modules\n mod panicking;\n+mod personality;\n \n #[path = \"../../backtrace/src/lib.rs\"]\n #[allow(dead_code, unused_attributes)]"}, {"sha": "63f0ad4f16e34f1d38f2bded34dba2b7efb0db4f", "filename": "library/std/src/personality.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -0,0 +1,46 @@\n+//! This module contains the implementation of the `eh_personality` lang item.\n+//!\n+//! The actual implementation is heavily dependent on the target since Rust\n+//! tries to use the native stack unwinding mechanism whenever possible.\n+//!\n+//! This personality function is still required with `-C panic=abort` because\n+//! it is used to catch foreign exceptions from `extern \"C-unwind\"` and turn\n+//! them into aborts.\n+//!\n+//! Additionally, ARM EHABI uses the personality function when generating\n+//! backtraces.\n+\n+mod dwarf;\n+\n+#[cfg(not(test))]\n+cfg_if::cfg_if! {\n+    if #[cfg(target_os = \"emscripten\")] {\n+        mod emcc;\n+    } else if #[cfg(target_env = \"msvc\")] {\n+        // This is required by the compiler to exist (e.g., it's a lang item),\n+        // but it's never actually called by the compiler because\n+        // _CxxFrameHandler3 is the personality function that is always used.\n+        // Hence this is just an aborting stub.\n+        #[lang = \"eh_personality\"]\n+        fn rust_eh_personality() {\n+            core::intrinsics::abort()\n+        }\n+    } else if #[cfg(any(\n+        all(target_family = \"windows\", target_env = \"gnu\"),\n+        target_os = \"psp\",\n+        target_os = \"solid_asp3\",\n+        all(target_family = \"unix\", not(target_os = \"espidf\")),\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+    ))] {\n+        mod gcc;\n+    } else {\n+        // Targets that don't support unwinding.\n+        // - family=wasm\n+        // - os=none (\"bare metal\" targets)\n+        // - os=uefi\n+        // - os=espidf\n+        // - os=hermit\n+        // - nvptx64-nvidia-cuda\n+        // - arch=avr\n+    }\n+}"}, {"sha": "8799137b78f98bc8cb1db7a7d4ddcc93b596fa8e", "filename": "library/std/src/personality/dwarf/eh.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Feh.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(unused)]\n \n-use crate::dwarf::DwarfReader;\n+use super::DwarfReader;\n use core::mem;\n \n pub const DW_EH_PE_omit: u8 = 0xFF;", "previous_filename": "library/panic_unwind/src/dwarf/eh.rs"}, {"sha": "652fbe95a14d195f39281a727d056b5f78aede60", "filename": "library/std/src/personality/dwarf/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Fmod.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "previous_filename": "library/panic_unwind/src/dwarf/mod.rs"}, {"sha": "1644f37083a5bbdaa3f7f8fc2b44f4f93b6a9982", "filename": "library/std/src/personality/dwarf/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fdwarf%2Ftests.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "previous_filename": "library/panic_unwind/src/dwarf/tests.rs"}, {"sha": "f942bdf18c1806ef55ab60733e2f2bb26a7062b5", "filename": "library/std/src/personality/emcc.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Femcc.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -0,0 +1,20 @@\n+//! On Emscripten Rust panics are wrapped in C++ exceptions, so we just forward\n+//! to `__gxx_personality_v0` which is provided by Emscripten.\n+\n+use libc::c_int;\n+use unwind as uw;\n+\n+// This is required by the compiler to exist (e.g., it's a lang item), but it's\n+// never actually called by the compiler.  Emscripten EH doesn't use a\n+// personality function at all, it instead uses __cxa_find_matching_catch.\n+// Wasm error handling would use __gxx_personality_wasm0.\n+#[lang = \"eh_personality\"]\n+unsafe extern \"C\" fn rust_eh_personality(\n+    _version: c_int,\n+    _actions: uw::_Unwind_Action,\n+    _exception_class: uw::_Unwind_Exception_Class,\n+    _exception_object: *mut uw::_Unwind_Exception,\n+    _context: *mut uw::_Unwind_Context,\n+) -> uw::_Unwind_Reason_Code {\n+    core::intrinsics::abort()\n+}"}, {"sha": "7f0b0439cf08380ba65cf316bcf542c215bedfcd", "filename": "library/std/src/personality/gcc.rs", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpersonality%2Fgcc.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -0,0 +1,279 @@\n+//! Implementation of panics backed by libgcc/libunwind (in some form).\n+//!\n+//! For background on exception handling and stack unwinding please see\n+//! \"Exception Handling in LLVM\" (llvm.org/docs/ExceptionHandling.html) and\n+//! documents linked from it.\n+//! These are also good reads:\n+//!  * <https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html>\n+//!  * <https://monoinfinito.wordpress.com/series/exception-handling-in-c/>\n+//!  * <https://www.airs.com/blog/index.php?s=exception+frames>\n+//!\n+//! ## A brief summary\n+//!\n+//! Exception handling happens in two phases: a search phase and a cleanup\n+//! phase.\n+//!\n+//! In both phases the unwinder walks stack frames from top to bottom using\n+//! information from the stack frame unwind sections of the current process's\n+//! modules (\"module\" here refers to an OS module, i.e., an executable or a\n+//! dynamic library).\n+//!\n+//! For each stack frame, it invokes the associated \"personality routine\", whose\n+//! address is also stored in the unwind info section.\n+//!\n+//! In the search phase, the job of a personality routine is to examine\n+//! exception object being thrown, and to decide whether it should be caught at\n+//! that stack frame. Once the handler frame has been identified, cleanup phase\n+//! begins.\n+//!\n+//! In the cleanup phase, the unwinder invokes each personality routine again.\n+//! This time it decides which (if any) cleanup code needs to be run for\n+//! the current stack frame. If so, the control is transferred to a special\n+//! branch in the function body, the \"landing pad\", which invokes destructors,\n+//! frees memory, etc. At the end of the landing pad, control is transferred\n+//! back to the unwinder and unwinding resumes.\n+//!\n+//! Once stack has been unwound down to the handler frame level, unwinding stops\n+//! and the last personality routine transfers control to the catch block.\n+\n+use super::dwarf::eh::{self, EHAction, EHContext};\n+use libc::{c_int, uintptr_t};\n+use unwind as uw;\n+\n+// Register ids were lifted from LLVM's TargetLowering::getExceptionPointerRegister()\n+// and TargetLowering::getExceptionSelectorRegister() for each architecture,\n+// then mapped to DWARF register numbers via register definition tables\n+// (typically <arch>RegisterInfo.td, search for \"DwarfRegNum\").\n+// See also https://llvm.org/docs/WritingAnLLVMBackend.html#defining-a-register.\n+\n+#[cfg(target_arch = \"x86\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 2); // EAX, EDX\n+\n+#[cfg(target_arch = \"x86_64\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // RAX, RDX\n+\n+#[cfg(any(target_arch = \"arm\", target_arch = \"aarch64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1 / X0, X1\n+\n+#[cfg(target_arch = \"m68k\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // D0, D1\n+\n+#[cfg(any(target_arch = \"mips\", target_arch = \"mips64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (4, 5); // A0, A1\n+\n+#[cfg(any(target_arch = \"powerpc\", target_arch = \"powerpc64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (3, 4); // R3, R4 / X3, X4\n+\n+#[cfg(target_arch = \"s390x\")]\n+const UNWIND_DATA_REG: (i32, i32) = (6, 7); // R6, R7\n+\n+#[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (24, 25); // I0, I1\n+\n+#[cfg(target_arch = \"hexagon\")]\n+const UNWIND_DATA_REG: (i32, i32) = (0, 1); // R0, R1\n+\n+#[cfg(any(target_arch = \"riscv64\", target_arch = \"riscv32\"))]\n+const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n+\n+// The following code is based on GCC's C and C++ personality routines.  For reference, see:\n+// https://github.com/gcc-mirror/gcc/blob/master/libstdc++-v3/libsupc++/eh_personality.cc\n+// https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n+\n+cfg_if::cfg_if! {\n+    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"watchos\"), not(target_os = \"netbsd\")))] {\n+        // ARM EHABI personality routine.\n+        // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n+        //\n+        // iOS uses the default routine instead since it uses SjLj unwinding.\n+        #[lang = \"eh_personality\"]\n+        unsafe extern \"C\" fn rust_eh_personality(\n+            state: uw::_Unwind_State,\n+            exception_object: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context,\n+        ) -> uw::_Unwind_Reason_Code {\n+            let state = state as c_int;\n+            let action = state & uw::_US_ACTION_MASK as c_int;\n+            let search_phase = if action == uw::_US_VIRTUAL_UNWIND_FRAME as c_int {\n+                // Backtraces on ARM will call the personality routine with\n+                // state == _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND. In those cases\n+                // we want to continue unwinding the stack, otherwise all our backtraces\n+                // would end at __rust_try\n+                if state & uw::_US_FORCE_UNWIND as c_int != 0 {\n+                    return continue_unwind(exception_object, context);\n+                }\n+                true\n+            } else if action == uw::_US_UNWIND_FRAME_STARTING as c_int {\n+                false\n+            } else if action == uw::_US_UNWIND_FRAME_RESUME as c_int {\n+                return continue_unwind(exception_object, context);\n+            } else {\n+                return uw::_URC_FAILURE;\n+            };\n+\n+            // The DWARF unwinder assumes that _Unwind_Context holds things like the function\n+            // and LSDA pointers, however ARM EHABI places them into the exception object.\n+            // To preserve signatures of functions like _Unwind_GetLanguageSpecificData(), which\n+            // take only the context pointer, GCC personality routines stash a pointer to\n+            // exception_object in the context, using location reserved for ARM's\n+            // \"scratch register\" (r12).\n+            uw::_Unwind_SetGR(context, uw::UNWIND_POINTER_REG, exception_object as uw::_Unwind_Ptr);\n+            // ...A more principled approach would be to provide the full definition of ARM's\n+            // _Unwind_Context in our libunwind bindings and fetch the required data from there\n+            // directly, bypassing DWARF compatibility functions.\n+\n+            let eh_action = match find_eh_action(context) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FAILURE,\n+            };\n+            if search_phase {\n+                match eh_action {\n+                    EHAction::None | EHAction::Cleanup(_) => {\n+                        return continue_unwind(exception_object, context);\n+                    }\n+                    EHAction::Catch(_) => {\n+                        // EHABI requires the personality routine to update the\n+                        // SP value in the barrier cache of the exception object.\n+                        (*exception_object).private[5] =\n+                            uw::_Unwind_GetGR(context, uw::UNWIND_SP_REG);\n+                        return uw::_URC_HANDLER_FOUND;\n+                    }\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => return continue_unwind(exception_object, context),\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(\n+                            context,\n+                            UNWIND_DATA_REG.0,\n+                            exception_object as uintptr_t,\n+                        );\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        return uw::_URC_INSTALL_CONTEXT;\n+                    }\n+                    EHAction::Terminate => return uw::_URC_FAILURE,\n+                }\n+            }\n+\n+            // On ARM EHABI the personality routine is responsible for actually\n+            // unwinding a single stack frame before returning (ARM EHABI Sec. 6.1).\n+            unsafe fn continue_unwind(\n+                exception_object: *mut uw::_Unwind_Exception,\n+                context: *mut uw::_Unwind_Context,\n+            ) -> uw::_Unwind_Reason_Code {\n+                if __gnu_unwind_frame(exception_object, context) == uw::_URC_NO_REASON {\n+                    uw::_URC_CONTINUE_UNWIND\n+                } else {\n+                    uw::_URC_FAILURE\n+                }\n+            }\n+            // defined in libgcc\n+            extern \"C\" {\n+                fn __gnu_unwind_frame(\n+                    exception_object: *mut uw::_Unwind_Exception,\n+                    context: *mut uw::_Unwind_Context,\n+                ) -> uw::_Unwind_Reason_Code;\n+            }\n+        }\n+    } else {\n+        // Default personality routine, which is used directly on most targets\n+        // and indirectly on Windows x86_64 via SEH.\n+        unsafe extern \"C\" fn rust_eh_personality_impl(\n+            version: c_int,\n+            actions: uw::_Unwind_Action,\n+            _exception_class: uw::_Unwind_Exception_Class,\n+            exception_object: *mut uw::_Unwind_Exception,\n+            context: *mut uw::_Unwind_Context,\n+        ) -> uw::_Unwind_Reason_Code {\n+            if version != 1 {\n+                return uw::_URC_FATAL_PHASE1_ERROR;\n+            }\n+            let eh_action = match find_eh_action(context) {\n+                Ok(action) => action,\n+                Err(_) => return uw::_URC_FATAL_PHASE1_ERROR,\n+            };\n+            if actions as i32 & uw::_UA_SEARCH_PHASE as i32 != 0 {\n+                match eh_action {\n+                    EHAction::None | EHAction::Cleanup(_) => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Catch(_) => uw::_URC_HANDLER_FOUND,\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE1_ERROR,\n+                }\n+            } else {\n+                match eh_action {\n+                    EHAction::None => uw::_URC_CONTINUE_UNWIND,\n+                    EHAction::Cleanup(lpad) | EHAction::Catch(lpad) => {\n+                        uw::_Unwind_SetGR(\n+                            context,\n+                            UNWIND_DATA_REG.0,\n+                            exception_object as uintptr_t,\n+                        );\n+                        uw::_Unwind_SetGR(context, UNWIND_DATA_REG.1, 0);\n+                        uw::_Unwind_SetIP(context, lpad);\n+                        uw::_URC_INSTALL_CONTEXT\n+                    }\n+                    EHAction::Terminate => uw::_URC_FATAL_PHASE2_ERROR,\n+                }\n+            }\n+        }\n+\n+        cfg_if::cfg_if! {\n+            if #[cfg(all(windows, target_arch = \"x86_64\", target_env = \"gnu\"))] {\n+                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind\n+                // handler data (aka LSDA) uses GCC-compatible encoding.\n+                #[lang = \"eh_personality\"]\n+                #[allow(nonstandard_style)]\n+                unsafe extern \"C\" fn rust_eh_personality(\n+                    exceptionRecord: *mut uw::EXCEPTION_RECORD,\n+                    establisherFrame: uw::LPVOID,\n+                    contextRecord: *mut uw::CONTEXT,\n+                    dispatcherContext: *mut uw::DISPATCHER_CONTEXT,\n+                ) -> uw::EXCEPTION_DISPOSITION {\n+                    uw::_GCC_specific_handler(\n+                        exceptionRecord,\n+                        establisherFrame,\n+                        contextRecord,\n+                        dispatcherContext,\n+                        rust_eh_personality_impl,\n+                    )\n+                }\n+            } else {\n+                // The personality routine for most of our targets.\n+                #[lang = \"eh_personality\"]\n+                unsafe extern \"C\" fn rust_eh_personality(\n+                    version: c_int,\n+                    actions: uw::_Unwind_Action,\n+                    exception_class: uw::_Unwind_Exception_Class,\n+                    exception_object: *mut uw::_Unwind_Exception,\n+                    context: *mut uw::_Unwind_Context,\n+                ) -> uw::_Unwind_Reason_Code {\n+                    rust_eh_personality_impl(\n+                        version,\n+                        actions,\n+                        exception_class,\n+                        exception_object,\n+                        context,\n+                    )\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> Result<EHAction, ()> {\n+    let lsda = uw::_Unwind_GetLanguageSpecificData(context) as *const u8;\n+    let mut ip_before_instr: c_int = 0;\n+    let ip = uw::_Unwind_GetIPInfo(context, &mut ip_before_instr);\n+    let eh_context = EHContext {\n+        // The return address points 1 byte past the call instruction,\n+        // which could be in the next IP range in LSDA range table.\n+        //\n+        // `ip = -1` has special meaning, so use wrapping sub to allow for that\n+        ip: if ip_before_instr != 0 { ip } else { ip.wrapping_sub(1) },\n+        func_start: uw::_Unwind_GetRegionStart(context),\n+        get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n+        get_data_start: &|| uw::_Unwind_GetDataRelBase(context),\n+    };\n+    eh::find_eh_action(lsda, &eh_context)\n+}"}, {"sha": "a54f429550e7435ed53fd6bc9f6361efceb9ee07", "filename": "src/test/run-make-fulldeps/issue-69368/a.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/src%2Ftest%2Frun-make-fulldeps%2Fissue-69368%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/src%2Ftest%2Frun-make-fulldeps%2Fissue-69368%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fissue-69368%2Fa.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -19,3 +19,8 @@ extern \"C\" fn __rust_drop_panic() -> ! {\n extern \"C\" fn __rust_foreign_exception() -> ! {\n     loop {}\n }\n+\n+#[lang = \"eh_personality\"]\n+fn eh_personality() {\n+    loop {}\n+}"}, {"sha": "4d86fe8be4e019ca7471fa0344c37381b9649c6b", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/91f128baf7704a477ab7c499143a160fb069b3ad/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91f128baf7704a477ab7c499143a160fb069b3ad/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=91f128baf7704a477ab7c499143a160fb069b3ad", "patch": "@@ -59,6 +59,8 @@ const EXCEPTION_PATHS: &[&str] = &[\n     \"library/std/src/sys_common\", // Should only contain abstractions over platforms\n     \"library/std/src/net/test.rs\", // Utility helpers for tests\n     \"library/std/src/panic.rs\",   // fuchsia-specific panic backtrace handling\n+    \"library/std/src/personality.rs\",\n+    \"library/std/src/personality/\",\n ];\n \n pub fn check(path: &Path, bad: &mut bool) {"}]}