{"sha": "0724573448a09f90d087f5341de483f9ef85a9be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MjQ1NzM0NDhhMDlmOTBkMDg3ZjUzNDFkZTQ4M2Y5ZWY4NWE5YmU=", "commit": {"author": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2020-12-12T14:25:55Z"}, "committer": {"name": "LeSeulArtichaut", "email": "leseulartichaut@gmail.com", "date": "2021-01-18T20:06:12Z"}, "message": "Move a few more types to `rustc_type_ir`", "tree": {"sha": "da7b6eb87e600af1f295513ebdb7719075cdddd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da7b6eb87e600af1f295513ebdb7719075cdddd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0724573448a09f90d087f5341de483f9ef85a9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0724573448a09f90d087f5341de483f9ef85a9be", "html_url": "https://github.com/rust-lang/rust/commit/0724573448a09f90d087f5341de483f9ef85a9be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0724573448a09f90d087f5341de483f9ef85a9be/comments", "author": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "committer": {"login": "LeSeulArtichaut", "id": 38361244, "node_id": "MDQ6VXNlcjM4MzYxMjQ0", "avatar_url": "https://avatars.githubusercontent.com/u/38361244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LeSeulArtichaut", "html_url": "https://github.com/LeSeulArtichaut", "followers_url": "https://api.github.com/users/LeSeulArtichaut/followers", "following_url": "https://api.github.com/users/LeSeulArtichaut/following{/other_user}", "gists_url": "https://api.github.com/users/LeSeulArtichaut/gists{/gist_id}", "starred_url": "https://api.github.com/users/LeSeulArtichaut/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LeSeulArtichaut/subscriptions", "organizations_url": "https://api.github.com/users/LeSeulArtichaut/orgs", "repos_url": "https://api.github.com/users/LeSeulArtichaut/repos", "events_url": "https://api.github.com/users/LeSeulArtichaut/events{/privacy}", "received_events_url": "https://api.github.com/users/LeSeulArtichaut/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e91c4ecc09312d8b63d250a432b0f3ef83f1df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e91c4ecc09312d8b63d250a432b0f3ef83f1df7", "html_url": "https://github.com/rust-lang/rust/commit/5e91c4ecc09312d8b63d250a432b0f3ef83f1df7"}], "stats": {"total": 691, "additions": 426, "deletions": 265}, "files": [{"sha": "bea1879e793b366cdb47f1eed391bc7f59cafbd3", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -4314,6 +4314,7 @@ dependencies = [\n  \"bitflags\",\n  \"rustc_data_structures\",\n  \"rustc_index\",\n+ \"rustc_macros\",\n  \"rustc_serialize\",\n ]\n "}, {"sha": "8318bdefc8e18813b2be2b8ddba50f4bafa069fa", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 3, "deletions": 50, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, FloatVarValue, InferConst, IntVarValue, Ty, TyCtxt};\n+use crate::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_data_structures::snapshot_vec;\n use rustc_data_structures::undo_log::UndoLogs;\n use rustc_data_structures::unify::{\n@@ -15,36 +15,6 @@ pub trait ToType {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n-/// Raw `TyVid` are used as the unification key for `sub_relations`;\n-/// they carry no values.\n-impl UnifyKey for ty::TyVid {\n-    type Value = ();\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::TyVid {\n-        ty::TyVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"TyVid\"\n-    }\n-}\n-\n-impl UnifyKey for ty::IntVid {\n-    type Value = Option<IntVarValue>;\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::IntVid {\n-        ty::IntVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"IntVid\"\n-    }\n-}\n-\n-impl EqUnifyValue for IntVarValue {}\n-\n #[derive(PartialEq, Copy, Clone, Debug)]\n pub struct RegionVidKey {\n     /// The minimum region vid in the unification set. This is needed\n@@ -80,7 +50,7 @@ impl UnifyKey for ty::RegionVid {\n     }\n }\n \n-impl ToType for IntVarValue {\n+impl ToType for ty::IntVarValue {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => tcx.mk_mach_int(i),\n@@ -89,24 +59,7 @@ impl ToType for IntVarValue {\n     }\n }\n \n-// Floating point type keys\n-\n-impl UnifyKey for ty::FloatVid {\n-    type Value = Option<FloatVarValue>;\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::FloatVid {\n-        ty::FloatVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"FloatVid\"\n-    }\n-}\n-\n-impl EqUnifyValue for FloatVarValue {}\n-\n-impl ToType for FloatVarValue {\n+impl ToType for ty::FloatVarValue {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n         tcx.mk_mach_float(self.0)\n     }"}, {"sha": "e386d973ee447bd2f3b9cf2f90e3e0ea2f14b8d3", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -1,8 +1,7 @@\n //! Diagnostics related methods for `TyS`.\n \n-use crate::ty::sty::InferTy;\n use crate::ty::TyKind::*;\n-use crate::ty::{TyCtxt, TyS};\n+use crate::ty::{InferTy, TyCtxt, TyS};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;"}, {"sha": "87730197da003ba2a924b02e61ff7d3a4c7cbe1d", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 81, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -65,7 +65,6 @@ use std::ptr;\n use std::str;\n \n pub use self::sty::BoundRegionKind::*;\n-pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n@@ -74,13 +73,14 @@ pub use self::sty::{BoundRegion, BoundRegionKind, EarlyBoundRegion, FreeRegion,\n pub use self::sty::{CanonicalPolyFnSig, FnSig, GenSig, PolyFnSig, PolyGenSig};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, TypeAndMut, UpvarSubsts};\n pub use self::sty::{ClosureSubstsParts, GeneratorSubstsParts};\n-pub use self::sty::{ConstVid, FloatVid, IntVid, RegionVid, TyVid};\n-pub use self::sty::{ExistentialPredicate, InferTy, ParamConst, ParamTy, ProjectionTy};\n+pub use self::sty::{ConstVid, RegionVid};\n+pub use self::sty::{ExistentialPredicate, ParamConst, ParamTy, ProjectionTy};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{PolyTraitRef, TraitRef, TyKind};\n pub use crate::ty::diagnostics::*;\n-pub use rustc_type_ir::{DebruijnIndex, TypeFlags, INNERMOST};\n+pub use rustc_type_ir::InferTy::*;\n+pub use rustc_type_ir::*;\n \n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n@@ -421,14 +421,6 @@ impl Visibility {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, TyDecodable, TyEncodable, HashStable)]\n-pub enum Variance {\n-    Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n-    Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n-    Contravariant, // T<A> <: T<B> iff B <: A -- e.g., function param type\n-    Bivariant,     // T<A> <: T<B>            -- e.g., unused type parameter\n-}\n-\n /// The crate variances map is computed during typeck and contains the\n /// variance of every item in the local crate. You should not use it\n /// directly, because to do so will make your pass dependent on the\n@@ -443,66 +435,6 @@ pub struct CrateVariancesMap<'tcx> {\n     pub variances: FxHashMap<DefId, &'tcx [ty::Variance]>,\n }\n \n-impl Variance {\n-    /// `a.xform(b)` combines the variance of a context with the\n-    /// variance of a type with the following meaning. If we are in a\n-    /// context with variance `a`, and we encounter a type argument in\n-    /// a position with variance `b`, then `a.xform(b)` is the new\n-    /// variance with which the argument appears.\n-    ///\n-    /// Example 1:\n-    ///\n-    ///     *mut Vec<i32>\n-    ///\n-    /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n-    /// invariant with respect to `T`, so the variance in which the\n-    /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n-    /// yields `Invariant`. Now, the type `Vec<T>` is covariant with\n-    /// respect to its type argument `T`, and hence the variance of\n-    /// the `i32` here is `Invariant.xform(Covariant)`, which results\n-    /// (again) in `Invariant`.\n-    ///\n-    /// Example 2:\n-    ///\n-    ///     fn(*const Vec<i32>, *mut Vec<i32)\n-    ///\n-    /// The ambient variance is covariant. A `fn` type is\n-    /// contravariant with respect to its parameters, so the variance\n-    /// within which both pointer types appear is\n-    /// `Covariant.xform(Contravariant)`, or `Contravariant`. `*const\n-    /// T` is covariant with respect to `T`, so the variance within\n-    /// which the first `Vec<i32>` appears is\n-    /// `Contravariant.xform(Covariant)` or `Contravariant`. The same\n-    /// is true for its `i32` argument. In the `*mut T` case, the\n-    /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n-    /// and hence the outermost type is `Invariant` with respect to\n-    /// `Vec<i32>` (and its `i32` argument).\n-    ///\n-    /// Source: Figure 1 of \"Taming the Wildcards:\n-    /// Combining Definition- and Use-Site Variance\" published in PLDI'11.\n-    pub fn xform(self, v: ty::Variance) -> ty::Variance {\n-        match (self, v) {\n-            // Figure 1, column 1.\n-            (ty::Covariant, ty::Covariant) => ty::Covariant,\n-            (ty::Covariant, ty::Contravariant) => ty::Contravariant,\n-            (ty::Covariant, ty::Invariant) => ty::Invariant,\n-            (ty::Covariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 2.\n-            (ty::Contravariant, ty::Covariant) => ty::Contravariant,\n-            (ty::Contravariant, ty::Contravariant) => ty::Covariant,\n-            (ty::Contravariant, ty::Invariant) => ty::Invariant,\n-            (ty::Contravariant, ty::Bivariant) => ty::Bivariant,\n-\n-            // Figure 1, column 3.\n-            (ty::Invariant, _) => ty::Invariant,\n-\n-            // Figure 1, column 4.\n-            (ty::Bivariant, _) => ty::Bivariant,\n-        }\n-    }\n-}\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -804,15 +736,6 @@ pub struct CaptureInfo<'tcx> {\n pub type UpvarListMap = FxHashMap<DefId, FxIndexMap<hir::HirId, UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n-#[derive(Clone, Copy, PartialEq, Eq)]\n-pub enum IntVarValue {\n-    IntType(ast::IntTy),\n-    UintType(ast::UintTy),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq)]\n-pub struct FloatVarValue(pub ast::FloatTy);\n-\n impl ty::EarlyBoundRegion {\n     /// Does this early bound region have a name? Early bound regions normally\n     /// always have names except when using anonymous lifetimes (`'_`)."}, {"sha": "9c7e0e60c14d6aa69f52aa805fa82016af032e6d", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -557,14 +557,19 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n+                let verbose = self.tcx().sess.verbose();\n                 if let ty::TyVar(ty_vid) = infer_ty {\n                     if let Some(name) = self.infer_ty_name(ty_vid) {\n                         p!(write(\"{}\", name))\n                     } else {\n-                        p!(write(\"{}\", infer_ty))\n+                        if verbose {\n+                            p!(write(\"{:?}\", infer_ty))\n+                        } else {\n+                            p!(write(\"{}\", infer_ty))\n+                        }\n                     }\n                 } else {\n-                    p!(write(\"{}\", infer_ty))\n+                    if verbose { p!(write(\"{:?}\", infer_ty)) } else { p!(write(\"{}\", infer_ty)) }\n                 }\n             }\n             ty::Error(_) => p!(\"[type error]\"),\n@@ -1246,7 +1251,7 @@ pub struct FmtPrinterData<'a, 'tcx, F> {\n \n     pub region_highlight_mode: RegionHighlightMode,\n \n-    pub name_resolver: Option<Box<&'a dyn Fn(ty::sty::TyVid) -> Option<String>>>,\n+    pub name_resolver: Option<Box<&'a dyn Fn(ty::TyVid) -> Option<String>>>,\n }\n \n impl<F> Deref for FmtPrinter<'a, 'tcx, F> {\n@@ -2007,21 +2012,6 @@ define_print_and_forward_display! {\n         p!(\"fn\", pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n     }\n \n-    ty::InferTy {\n-        if cx.tcx().sess.verbose() {\n-            p!(write(\"{:?}\", self));\n-            return Ok(cx);\n-        }\n-        match *self {\n-            ty::TyVar(_) => p!(\"_\"),\n-            ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n-            ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n-            ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n-            ty::FreshIntTy(v) => p!(write(\"FreshIntTy({})\", v)),\n-            ty::FreshFloatTy(v) => p!(write(\"FreshFloatTy({})\", v))\n-        }\n-    }\n-\n     ty::TraitRef<'tcx> {\n         p!(write(\"<{} as {}>\", self.self_ty(), self.print_only_trait_path()))\n     }"}, {"sha": "0ca94a9f1805df88f78008c1e94081b5fd0ea688", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 58, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -111,81 +111,24 @@ impl fmt::Debug for ty::FreeRegion {\n     }\n }\n \n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n-    }\n-}\n-\n impl fmt::Debug for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"({:?}; c_variadic: {})->{:?}\", self.inputs(), self.c_variadic, self.output())\n     }\n }\n \n-impl fmt::Debug for ty::TyVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}t\", self.index)\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::ConstVid<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"_#{}c\", self.index)\n     }\n }\n \n-impl fmt::Debug for ty::IntVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}i\", self.index)\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVid {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"_#{}f\", self.index)\n-    }\n-}\n-\n impl fmt::Debug for ty::RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"'_#{}r\", self.index())\n     }\n }\n \n-impl fmt::Debug for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::TyVar(ref v) => v.fmt(f),\n-            ty::IntVar(ref v) => v.fmt(f),\n-            ty::FloatVar(ref v) => v.fmt(f),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::IntVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::IntType(ref v) => v.fmt(f),\n-            ty::UintType(ref v) => v.fmt(f),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::FloatVarValue {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0.fmt(f)\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitRef<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_no_trimmed_paths(|| fmt::Display::fmt(self, f))\n@@ -274,7 +217,7 @@ TrivialTypeFoldableAndLiftImpls! {\n     u64,\n     String,\n     crate::middle::region::Scope,\n-    ::rustc_ast::FloatTy,\n+    crate::ty::FloatTy,\n     ::rustc_ast::InlineAsmOptions,\n     ::rustc_ast::InlineAsmTemplatePiece,\n     ::rustc_ast::NodeId,"}, {"sha": "aeba1843dbc1278b0d85cd9e168a32fc96ca11d0", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -2,11 +2,11 @@\n \n #![allow(rustc::usage_of_ty_tykind)]\n \n-use self::InferTy::*;\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n+use crate::ty::InferTy::{self, *};\n use crate::ty::{\n     self, AdtDef, DefIdTree, Discr, Ty, TyCtxt, TypeFlags, TypeFoldable, WithConstness,\n };\n@@ -1426,31 +1426,13 @@ pub struct EarlyBoundRegion {\n     pub name: Symbol,\n }\n \n-/// A **ty**pe **v**ariable **ID**.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-pub struct TyVid {\n-    pub index: u32,\n-}\n-\n /// A **`const`** **v**ariable **ID**.\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n pub struct ConstVid<'tcx> {\n     pub index: u32,\n     pub phantom: PhantomData<&'tcx ()>,\n }\n \n-/// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-pub struct IntVid {\n-    pub index: u32,\n-}\n-\n-/// An **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-pub struct FloatVid {\n-    pub index: u32,\n-}\n-\n rustc_index::newtype_index! {\n     /// A **region** (lifetime) **v**ariable **ID**.\n     pub struct RegionVid {\n@@ -1464,43 +1446,6 @@ impl Atom for RegionVid {\n     }\n }\n \n-/// A placeholder for a type that hasn't been inferred yet.\n-///\n-/// E.g., if we have an empty array (`[]`), then we create a fresh\n-/// type variable for the element type since we won't know until it's\n-/// used what the element type is supposed to be.\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable)]\n-pub enum InferTy {\n-    /// A type variable.\n-    TyVar(TyVid),\n-    /// An integral type variable (`{integer}`).\n-    ///\n-    /// These are created when the compiler sees an integer literal like\n-    /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).\n-    /// We don't know until it's used what type it's supposed to be, so\n-    /// we create a fresh type variable.\n-    IntVar(IntVid),\n-    /// A floating-point type variable (`{float}`).\n-    ///\n-    /// These are created when the compiler sees an float literal like\n-    /// `1.0` that could be either an `f32` or an `f64`.\n-    /// We don't know until it's used what type it's supposed to be, so\n-    /// we create a fresh type variable.\n-    FloatVar(FloatVid),\n-\n-    /// A [`FreshTy`][Self::FreshTy] is one that is generated as a replacement\n-    /// for an unbound type variable. This is convenient for caching etc. See\n-    /// `rustc_infer::infer::freshen` for more details.\n-    ///\n-    /// Compare with [`TyVar`][Self::TyVar].\n-    FreshTy(u32),\n-    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`IntVar`][Self::IntVar].\n-    FreshIntTy(u32),\n-    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`FloatVar`][Self::FloatVar].\n-    FreshFloatTy(u32),\n-}\n-\n rustc_index::newtype_index! {\n     pub struct BoundVar { .. }\n }"}, {"sha": "3f64bd899979f4db7fc2bbf3ef0cd8880a6b6ab7", "filename": "compiler/rustc_type_ir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_type_ir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_type_ir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2FCargo.toml?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -12,3 +12,4 @@ bitflags = \"1.2.1\"\n rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }\n+rustc_macros = { path = \"../rustc_macros\" }"}, {"sha": "7e70af21c03cdbfe1647a512814568dd14c9c941", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 406, "deletions": 0, "changes": 406, "blob_url": "https://github.com/rust-lang/rust/blob/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0724573448a09f90d087f5341de483f9ef85a9be/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=0724573448a09f90d087f5341de483f9ef85a9be", "patch": "@@ -4,8 +4,13 @@\n \n #[macro_use]\n extern crate bitflags;\n+#[macro_use]\n+extern crate rustc_macros;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::unify::{EqUnifyValue, UnifyKey};\n+use std::fmt;\n+use std::mem::discriminant;\n \n bitflags! {\n     /// Flags that we track on types. These flags are propagated upwards\n@@ -197,8 +202,409 @@ impl DebruijnIndex {\n     }\n }\n \n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub enum IntTy {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+impl IntTy {\n+    pub fn name_str(&self) -> &'static str {\n+        match *self {\n+            IntTy::Isize => \"isize\",\n+            IntTy::I8 => \"i8\",\n+            IntTy::I16 => \"i16\",\n+            IntTy::I32 => \"i32\",\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n+        }\n+    }\n+\n+    pub fn bit_width(&self) -> Option<u64> {\n+        Some(match *self {\n+            IntTy::Isize => return None,\n+            IntTy::I8 => 8,\n+            IntTy::I16 => 16,\n+            IntTy::I32 => 32,\n+            IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n+        })\n+    }\n+\n+    pub fn normalize(&self, target_width: u32) -> Self {\n+        match self {\n+            IntTy::Isize => match target_width {\n+                16 => IntTy::I16,\n+                32 => IntTy::I32,\n+                64 => IntTy::I64,\n+                _ => unreachable!(),\n+            },\n+            _ => *self,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub enum UintTy {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n+}\n+\n+impl UintTy {\n+    pub fn name_str(&self) -> &'static str {\n+        match *self {\n+            UintTy::Usize => \"usize\",\n+            UintTy::U8 => \"u8\",\n+            UintTy::U16 => \"u16\",\n+            UintTy::U32 => \"u32\",\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n+        }\n+    }\n+\n+    pub fn bit_width(&self) -> Option<u64> {\n+        Some(match *self {\n+            UintTy::Usize => return None,\n+            UintTy::U8 => 8,\n+            UintTy::U16 => 16,\n+            UintTy::U32 => 32,\n+            UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n+        })\n+    }\n+\n+    pub fn normalize(&self, target_width: u32) -> Self {\n+        match self {\n+            UintTy::Usize => match target_width {\n+                16 => UintTy::U16,\n+                32 => UintTy::U32,\n+                64 => UintTy::U64,\n+                _ => unreachable!(),\n+            },\n+            _ => *self,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Encodable, Decodable)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n+}\n+\n+impl FloatTy {\n+    pub fn name_str(self) -> &'static str {\n+        match self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n+        }\n+    }\n+\n+    pub fn bit_width(self) -> u64 {\n+        match self {\n+            FloatTy::F32 => 32,\n+            FloatTy::F64 => 64,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub enum IntVarValue {\n+    IntType(IntTy),\n+    UintType(UintTy),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+pub struct FloatVarValue(pub FloatTy);\n+\n+/// A **ty**pe **v**ariable **ID**.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub struct TyVid {\n+    pub index: u32,\n+}\n+\n+/// An **int**egral (`u32`, `i32`, `usize`, etc.) type **v**ariable **ID**.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub struct IntVid {\n+    pub index: u32,\n+}\n+\n+/// An **float**ing-point (`f32` or `f64`) type **v**ariable **ID**.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub struct FloatVid {\n+    pub index: u32,\n+}\n+\n+/// A placeholder for a type that hasn't been inferred yet.\n+///\n+/// E.g., if we have an empty array (`[]`), then we create a fresh\n+/// type variable for the element type since we won't know until it's\n+/// used what the element type is supposed to be.\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Encodable, Decodable)]\n+pub enum InferTy {\n+    /// A type variable.\n+    TyVar(TyVid),\n+    /// An integral type variable (`{integer}`).\n+    ///\n+    /// These are created when the compiler sees an integer literal like\n+    /// `1` that could be several different types (`u8`, `i32`, `u32`, etc.).\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n+    IntVar(IntVid),\n+    /// A floating-point type variable (`{float}`).\n+    ///\n+    /// These are created when the compiler sees an float literal like\n+    /// `1.0` that could be either an `f32` or an `f64`.\n+    /// We don't know until it's used what type it's supposed to be, so\n+    /// we create a fresh type variable.\n+    FloatVar(FloatVid),\n+\n+    /// A [`FreshTy`][Self::FreshTy] is one that is generated as a replacement\n+    /// for an unbound type variable. This is convenient for caching etc. See\n+    /// `rustc_infer::infer::freshen` for more details.\n+    ///\n+    /// Compare with [`TyVar`][Self::TyVar].\n+    FreshTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`IntVar`][Self::IntVar].\n+    FreshIntTy(u32),\n+    /// Like [`FreshTy`][Self::FreshTy], but as a replacement for [`FloatVar`][Self::FloatVar].\n+    FreshFloatTy(u32),\n+}\n+\n+/// Raw `TyVid` are used as the unification key for `sub_relations`;\n+/// they carry no values.\n+impl UnifyKey for TyVid {\n+    type Value = ();\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> TyVid {\n+        TyVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"TyVid\"\n+    }\n+}\n+\n+impl EqUnifyValue for IntVarValue {}\n+\n+impl UnifyKey for IntVid {\n+    type Value = Option<IntVarValue>;\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> IntVid {\n+        IntVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"IntVid\"\n+    }\n+}\n+\n+impl EqUnifyValue for FloatVarValue {}\n+\n+impl UnifyKey for FloatVid {\n+    type Value = Option<FloatVarValue>;\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> FloatVid {\n+        FloatVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"FloatVid\"\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Decodable, Encodable)]\n+pub enum Variance {\n+    Covariant,     // T<A> <: T<B> iff A <: B -- e.g., function return type\n+    Invariant,     // T<A> <: T<B> iff B == A -- e.g., type of mutable cell\n+    Contravariant, // T<A> <: T<B> iff B <: A -- e.g., function param type\n+    Bivariant,     // T<A> <: T<B>            -- e.g., unused type parameter\n+}\n+\n+impl Variance {\n+    /// `a.xform(b)` combines the variance of a context with the\n+    /// variance of a type with the following meaning. If we are in a\n+    /// context with variance `a`, and we encounter a type argument in\n+    /// a position with variance `b`, then `a.xform(b)` is the new\n+    /// variance with which the argument appears.\n+    ///\n+    /// Example 1:\n+    ///\n+    ///     *mut Vec<i32>\n+    ///\n+    /// Here, the \"ambient\" variance starts as covariant. `*mut T` is\n+    /// invariant with respect to `T`, so the variance in which the\n+    /// `Vec<i32>` appears is `Covariant.xform(Invariant)`, which\n+    /// yields `Invariant`. Now, the type `Vec<T>` is covariant with\n+    /// respect to its type argument `T`, and hence the variance of\n+    /// the `i32` here is `Invariant.xform(Covariant)`, which results\n+    /// (again) in `Invariant`.\n+    ///\n+    /// Example 2:\n+    ///\n+    ///     fn(*const Vec<i32>, *mut Vec<i32)\n+    ///\n+    /// The ambient variance is covariant. A `fn` type is\n+    /// contravariant with respect to its parameters, so the variance\n+    /// within which both pointer types appear is\n+    /// `Covariant.xform(Contravariant)`, or `Contravariant`. `*const\n+    /// T` is covariant with respect to `T`, so the variance within\n+    /// which the first `Vec<i32>` appears is\n+    /// `Contravariant.xform(Covariant)` or `Contravariant`. The same\n+    /// is true for its `i32` argument. In the `*mut T` case, the\n+    /// variance of `Vec<i32>` is `Contravariant.xform(Invariant)`,\n+    /// and hence the outermost type is `Invariant` with respect to\n+    /// `Vec<i32>` (and its `i32` argument).\n+    ///\n+    /// Source: Figure 1 of \"Taming the Wildcards:\n+    /// Combining Definition- and Use-Site Variance\" published in PLDI'11.\n+    pub fn xform(self, v: Variance) -> Variance {\n+        match (self, v) {\n+            // Figure 1, column 1.\n+            (Variance::Covariant, Variance::Covariant) => Variance::Covariant,\n+            (Variance::Covariant, Variance::Contravariant) => Variance::Contravariant,\n+            (Variance::Covariant, Variance::Invariant) => Variance::Invariant,\n+            (Variance::Covariant, Variance::Bivariant) => Variance::Bivariant,\n+\n+            // Figure 1, column 2.\n+            (Variance::Contravariant, Variance::Covariant) => Variance::Contravariant,\n+            (Variance::Contravariant, Variance::Contravariant) => Variance::Covariant,\n+            (Variance::Contravariant, Variance::Invariant) => Variance::Invariant,\n+            (Variance::Contravariant, Variance::Bivariant) => Variance::Bivariant,\n+\n+            // Figure 1, column 3.\n+            (Variance::Invariant, _) => Variance::Invariant,\n+\n+            // Figure 1, column 4.\n+            (Variance::Bivariant, _) => Variance::Bivariant,\n+        }\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for DebruijnIndex {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n         self.as_u32().hash_stable(ctx, hasher);\n     }\n }\n+\n+impl<CTX> HashStable<CTX> for IntTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for UintTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for FloatTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for InferTy {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        use InferTy::*;\n+        match self {\n+            TyVar(v) => v.index.hash_stable(ctx, hasher),\n+            IntVar(v) => v.index.hash_stable(ctx, hasher),\n+            FloatVar(v) => v.index.hash_stable(ctx, hasher),\n+            FreshTy(v) | FreshIntTy(v) | FreshFloatTy(v) => v.hash_stable(ctx, hasher),\n+        }\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for Variance {\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        discriminant(self).hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl fmt::Debug for IntVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            IntVarValue::IntType(ref v) => v.fmt(f),\n+            IntVarValue::UintType(ref v) => v.fmt(f),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for FloatVarValue {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.0.fmt(f)\n+    }\n+}\n+\n+impl fmt::Debug for TyVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}t\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for IntVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}i\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for FloatVid {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"_#{}f\", self.index)\n+    }\n+}\n+\n+impl fmt::Debug for InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InferTy::*;\n+        match *self {\n+            TyVar(ref v) => v.fmt(f),\n+            IntVar(ref v) => v.fmt(f),\n+            FloatVar(ref v) => v.fmt(f),\n+            FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v),\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for Variance {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            Variance::Covariant => \"+\",\n+            Variance::Contravariant => \"-\",\n+            Variance::Invariant => \"o\",\n+            Variance::Bivariant => \"*\",\n+        })\n+    }\n+}\n+\n+impl fmt::Display for InferTy {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InferTy::*;\n+        match *self {\n+            TyVar(_) => write!(f, \"_\"),\n+            IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+            FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v),\n+        }\n+    }\n+}"}]}