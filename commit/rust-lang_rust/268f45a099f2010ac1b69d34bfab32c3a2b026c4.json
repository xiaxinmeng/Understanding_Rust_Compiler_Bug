{"sha": "268f45a099f2010ac1b69d34bfab32c3a2b026c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2OGY0NWEwOTlmMjAxMGFjMWI2OWQzNGJmYWIzMmMzYTJiMDI2YzQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-18T18:56:37Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-03-18T18:56:37Z"}, "message": "Record custom derive helpers in `DefMap`\n\nAlso clean up proc macro attribute parsing a bit", "tree": {"sha": "8f2425e4955195b75d3fb106e613ae5acbbb75d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f2425e4955195b75d3fb106e613ae5acbbb75d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/268f45a099f2010ac1b69d34bfab32c3a2b026c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/268f45a099f2010ac1b69d34bfab32c3a2b026c4", "html_url": "https://github.com/rust-lang/rust/commit/268f45a099f2010ac1b69d34bfab32c3a2b026c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/268f45a099f2010ac1b69d34bfab32c3a2b026c4/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0805c6444e06e082465cd1a064c83c0f90faf71", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0805c6444e06e082465cd1a064c83c0f90faf71", "html_url": "https://github.com/rust-lang/rust/commit/d0805c6444e06e082465cd1a064c83c0f90faf71"}], "stats": {"total": 116, "additions": 91, "deletions": 25}, "files": [{"sha": "1ac326f971d89de09af3489e3053538186f10095", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/268f45a099f2010ac1b69d34bfab32c3a2b026c4/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f45a099f2010ac1b69d34bfab32c3a2b026c4/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=268f45a099f2010ac1b69d34bfab32c3a2b026c4", "patch": "@@ -53,11 +53,12 @@ mod path_resolution;\n \n #[cfg(test)]\n mod tests;\n+mod proc_macro;\n \n use std::sync::Arc;\n \n use base_db::{CrateId, Edition, FileId};\n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile, MacroDefId};\n use la_arena::Arena;\n use profile::Count;\n use rustc_hash::FxHashMap;\n@@ -73,6 +74,8 @@ use crate::{\n     AstId, BlockId, BlockLoc, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n+use self::proc_macro::ProcMacroDef;\n+\n /// Contains the results of (early) name resolution.\n ///\n /// A `DefMap` stores the module tree and the definitions that are in scope in every module after\n@@ -95,6 +98,12 @@ pub struct DefMap {\n     prelude: Option<ModuleId>,\n     extern_prelude: FxHashMap<Name, ModuleDefId>,\n \n+    /// Side table with additional proc. macro info, for use by name resolution in downstream\n+    /// crates.\n+    ///\n+    /// (the primary purpose is to resolve derive helpers)\n+    exported_proc_macros: FxHashMap<MacroDefId, ProcMacroDef>,\n+\n     edition: Edition,\n     diagnostics: Vec<DefDiagnostic>,\n }\n@@ -237,6 +246,7 @@ impl DefMap {\n             krate,\n             edition,\n             extern_prelude: FxHashMap::default(),\n+            exported_proc_macros: FxHashMap::default(),\n             prelude: None,\n             root,\n             modules,"}, {"sha": "dcedf7766d9c179d810853cca5b11e54bcd61588", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/268f45a099f2010ac1b69d34bfab32c3a2b026c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f45a099f2010ac1b69d34bfab32c3a2b026c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=268f45a099f2010ac1b69d34bfab32c3a2b026c4", "patch": "@@ -18,7 +18,6 @@ use hir_expand::{\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::ast;\n-use tt::{Leaf, TokenTree};\n \n use crate::{\n     attr::Attrs,\n@@ -42,6 +41,8 @@ use crate::{\n     UnresolvedMacro,\n };\n \n+use super::proc_macro::ProcMacroDef;\n+\n const GLOB_RECURSION_LIMIT: usize = 100;\n const EXPANSION_DEPTH_LIMIT: usize = 128;\n const FIXED_POINT_LIMIT: usize = 8192;\n@@ -353,9 +354,9 @@ impl DefCollector<'_> {\n     /// use a dummy expander that always errors. This comes with the drawback of macros potentially\n     /// going out of sync with what the build system sees (since we resolve using VFS state, but\n     /// Cargo builds only on-disk files). We could and probably should add diagnostics for that.\n-    fn resolve_proc_macro(&mut self, name: &Name, ast_id: AstId<ast::Fn>) {\n+    fn export_proc_macro(&mut self, def: ProcMacroDef, ast_id: AstId<ast::Fn>) {\n         self.exports_proc_macros = true;\n-        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == name) {\n+        let macro_def = match self.proc_macros.iter().find(|(n, _)| n == &def.name) {\n             Some((_, expander)) => MacroDefId {\n                 krate: self.def_map.krate,\n                 kind: MacroDefKind::ProcMacro(*expander, ast_id),\n@@ -368,7 +369,8 @@ impl DefCollector<'_> {\n             },\n         };\n \n-        self.define_proc_macro(name.clone(), macro_def);\n+        self.define_proc_macro(def.name.clone(), macro_def);\n+        self.def_map.exported_proc_macros.insert(macro_def, def);\n     }\n \n     /// Define a macro with `macro_rules`.\n@@ -1386,26 +1388,9 @@ impl ModCollector<'_, '_> {\n     /// If `attrs` registers a procedural macro, collects its definition.\n     fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n         // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n-        // FIXME: distinguish the type of macro\n-        let macro_name = if attrs.by_key(\"proc_macro\").exists()\n-            || attrs.by_key(\"proc_macro_attribute\").exists()\n-        {\n-            func_name.clone()\n-        } else {\n-            let derive = attrs.by_key(\"proc_macro_derive\");\n-            if let Some(arg) = derive.tt_values().next() {\n-                if let [TokenTree::Leaf(Leaf::Ident(trait_name)), ..] = &*arg.token_trees {\n-                    trait_name.as_name()\n-                } else {\n-                    log::trace!(\"malformed `#[proc_macro_derive]`: {}\", arg);\n-                    return;\n-                }\n-            } else {\n-                return;\n-            }\n-        };\n-\n-        self.def_collector.resolve_proc_macro(&macro_name, ast_id);\n+        if let Some(proc_macro) = attrs.parse_proc_macro_decl(func_name) {\n+            self.def_collector.export_proc_macro(proc_macro, ast_id);\n+        }\n     }\n \n     fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {"}, {"sha": "156598f1951711202d9007cc0d08c8bf26b55c57", "filename": "crates/hir_def/src/nameres/proc_macro.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/268f45a099f2010ac1b69d34bfab32c3a2b026c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/268f45a099f2010ac1b69d34bfab32c3a2b026c4/crates%2Fhir_def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=268f45a099f2010ac1b69d34bfab32c3a2b026c4", "patch": "@@ -0,0 +1,71 @@\n+//! Nameres-specific procedural macro data and helpers.\n+\n+use hir_expand::name::{AsName, Name};\n+use tt::{Leaf, TokenTree};\n+\n+use crate::attr::Attrs;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) struct ProcMacroDef {\n+    pub(super) name: Name,\n+    pub(super) kind: ProcMacroKind,\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub(super) enum ProcMacroKind {\n+    CustomDerive { helpers: Box<[Name]> },\n+    FnLike,\n+    Attr,\n+}\n+\n+impl Attrs {\n+    #[rustfmt::skip]\n+    pub(super) fn parse_proc_macro_decl(&self, func_name: &Name) -> Option<ProcMacroDef> {\n+        if self.by_key(\"proc_macro\").exists() {\n+            Some(ProcMacroDef { name: func_name.clone(), kind: ProcMacroKind::FnLike })\n+        } else if self.by_key(\"proc_macro_attribute\").exists() {\n+            Some(ProcMacroDef { name: func_name.clone(), kind: ProcMacroKind::Attr })\n+        } else if self.by_key(\"proc_macro_derive\").exists() {\n+            let derive = self.by_key(\"proc_macro_derive\").tt_values().next().unwrap();\n+\n+            match &*derive.token_trees {\n+                // `#[proc_macro_derive(Trait)]`\n+                [TokenTree::Leaf(Leaf::Ident(trait_name))] => Some(ProcMacroDef {\n+                    name: trait_name.as_name(),\n+                    kind: ProcMacroKind::CustomDerive { helpers: Box::new([]) },\n+                }),\n+\n+                // `#[proc_macro_derive(Trait, attibutes(helper1, helper2, ...))]`\n+                [\n+                    TokenTree::Leaf(Leaf::Ident(trait_name)),\n+                    TokenTree::Leaf(Leaf::Punct(comma)),\n+                    TokenTree::Leaf(Leaf::Ident(attributes)),\n+                    TokenTree::Subtree(helpers)\n+                ] if comma.char == ',' && attributes.text == \"attributes\" =>\n+                {\n+                    let helpers = helpers.token_trees.iter()\n+                        .filter(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Punct(comma)) if comma.char == ','))\n+                        .map(|tt| {\n+                            match tt {\n+                                TokenTree::Leaf(Leaf::Ident(helper)) => Some(helper.as_name()),\n+                                _ => None\n+                            }\n+                        })\n+                        .collect::<Option<Box<[_]>>>()?;\n+\n+                    Some(ProcMacroDef {\n+                        name: trait_name.as_name(),\n+                        kind: ProcMacroKind::CustomDerive { helpers },\n+                    })\n+                }\n+\n+                _ => {\n+                    log::trace!(\"malformed `#[proc_macro_derive]`: {}\", derive);\n+                    None\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}]}