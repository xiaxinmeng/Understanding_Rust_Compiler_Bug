{"sha": "d7522fec1599d99ff7cff95c53850fd72e74979f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NTIyZmVjMTU5OWQ5OWZmN2NmZjk1YzUzODUwZmQ3MmU3NDk3OWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-06-06T15:58:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-02T00:43:54Z"}, "message": "Move existing docs into doc.rs", "tree": {"sha": "cbcb8fbf46a92d3dba86caddf83a99c2c0ac087c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbcb8fbf46a92d3dba86caddf83a99c2c0ac087c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7522fec1599d99ff7cff95c53850fd72e74979f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7522fec1599d99ff7cff95c53850fd72e74979f", "html_url": "https://github.com/rust-lang/rust/commit/d7522fec1599d99ff7cff95c53850fd72e74979f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7522fec1599d99ff7cff95c53850fd72e74979f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d48a7d55015da4820ea9dada682d727cacb074c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d48a7d55015da4820ea9dada682d727cacb074c", "html_url": "https://github.com/rust-lang/rust/commit/9d48a7d55015da4820ea9dada682d727cacb074c"}], "stats": {"total": 1069, "additions": 541, "deletions": 528}, "files": [{"sha": "0a288d40fa9097e14ffe47b6c2668c9029dac233", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "added", "additions": 537, "deletions": 0, "changes": 537, "blob_url": "https://github.com/rust-lang/rust/blob/d7522fec1599d99ff7cff95c53850fd72e74979f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7522fec1599d99ff7cff95c53850fd72e74979f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=d7522fec1599d99ff7cff95c53850fd72e74979f", "patch": "@@ -0,0 +1,537 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+Region inference module.\n+\n+# Introduction\n+\n+Region inference uses a somewhat more involved algorithm than type\n+inference.  It is not the most efficient thing ever written though it\n+seems to work well enough in practice (famous last words).  The reason\n+that we use a different algorithm is because, unlike with types, it is\n+impractical to hand-annotate with regions (in some cases, there aren't\n+even the requisite syntactic forms).  So we have to get it right, and\n+it's worth spending more time on a more involved analysis.  Moreover,\n+regions are a simpler case than types: they don't have aggregate\n+structure, for example.\n+\n+Unlike normal type inference, which is similar in spirit to H-M and thus\n+works progressively, the region type inference works by accumulating\n+constraints over the course of a function.  Finally, at the end of\n+processing a function, we process and solve the constraints all at\n+once.\n+\n+The constraints are always of one of three possible forms:\n+\n+- ConstrainVarSubVar(R_i, R_j) states that region variable R_i\n+  must be a subregion of R_j\n+- ConstrainRegSubVar(R, R_i) states that the concrete region R\n+  (which must not be a variable) must be a subregion of the varibale R_i\n+- ConstrainVarSubReg(R_i, R) is the inverse\n+\n+# Building up the constraints\n+\n+Variables and constraints are created using the following methods:\n+\n+- `new_region_var()` creates a new, unconstrained region variable;\n+- `make_subregion(R_i, R_j)` states that R_i is a subregion of R_j\n+- `lub_regions(R_i, R_j) -> R_k` returns a region R_k which is\n+  the smallest region that is greater than both R_i and R_j\n+- `glb_regions(R_i, R_j) -> R_k` returns a region R_k which is\n+  the greatest region that is smaller than both R_i and R_j\n+\n+The actual region resolution algorithm is not entirely\n+obvious, though it is also not overly complex.  I'll explain\n+the algorithm as it currently works, then explain a somewhat\n+more complex variant that would probably scale better for\n+large graphs (and possibly all graphs).\n+\n+## Snapshotting\n+\n+It is also permitted to try (and rollback) changes to the graph.  This\n+is done by invoking `start_snapshot()`, which returns a value.  Then\n+later you can call `rollback_to()` which undoes the work.\n+Alternatively, you can call `commit()` which ends all snapshots.\n+Snapshots can be recursive---so you can start a snapshot when another\n+is in progress, but only the root snapshot can \"commit\".\n+\n+# Resolving constraints\n+\n+The constraint resolution algorithm is not super complex but also not\n+entirely obvious.  Here I describe the problem somewhat abstractly,\n+then describe how the current code works, and finally describe a\n+better solution that is as of yet unimplemented.  There may be other,\n+smarter ways of doing this with which I am unfamiliar and can't be\n+bothered to research at the moment. - NDM\n+\n+## The problem\n+\n+Basically our input is a directed graph where nodes can be divided\n+into two categories: region variables and concrete regions.  Each edge\n+`R -> S` in the graph represents a constraint that the region `R` is a\n+subregion of the region `S`.\n+\n+Region variable nodes can have arbitrary degree.  There is one region\n+variable node per region variable.\n+\n+Each concrete region node is associated with some, well, concrete\n+region: e.g., a free lifetime, or the region for a particular scope.\n+Note that there may be more than one concrete region node for a\n+particular region value.  Moreover, because of how the graph is built,\n+we know that all concrete region nodes have either in-degree 1 or\n+out-degree 1.\n+\n+Before resolution begins, we build up the constraints in a hashmap\n+that maps `Constraint` keys to spans.  During resolution, we construct\n+the actual `Graph` structure that we describe here.\n+\n+## Our current algorithm\n+\n+We divide region variables into two groups: Expanding and Contracting.\n+Expanding region variables are those that have a concrete region\n+predecessor (direct or indirect).  Contracting region variables are\n+all others.\n+\n+We first resolve the values of Expanding region variables and then\n+process Contracting ones.  We currently use an iterative, fixed-point\n+procedure (but read on, I believe this could be replaced with a linear\n+walk).  Basically we iterate over the edges in the graph, ensuring\n+that, if the source of the edge has a value, then this value is a\n+subregion of the target value.  If the target does not yet have a\n+value, it takes the value from the source.  If the target already had\n+a value, then the resulting value is Least Upper Bound of the old and\n+new values. When we are done, each Expanding node will have the\n+smallest region that it could possibly have and still satisfy the\n+constraints.\n+\n+We next process the Contracting nodes.  Here we again iterate over the\n+edges, only this time we move values from target to source (if the\n+source is a Contracting node).  For each contracting node, we compute\n+its value as the GLB of all its successors.  Basically contracting\n+nodes ensure that there is overlap between their successors; we will\n+ultimately infer the largest overlap possible.\n+\n+### A better algorithm\n+\n+Fixed-point iteration is not necessary.  What we ought to do is first\n+identify and remove strongly connected components (SCC) in the graph.\n+Note that such components must consist solely of region variables; all\n+of these variables can effectively be unified into a single variable.\n+\n+Once SCCs are removed, we are left with a DAG.  At this point, we can\n+walk the DAG in toplogical order once to compute the expanding nodes,\n+and again in reverse topological order to compute the contracting\n+nodes. The main reason I did not write it this way is that I did not\n+feel like implementing the SCC and toplogical sort algorithms at the\n+moment.\n+\n+# Skolemization and functions\n+\n+One of the trickiest and most subtle aspects of regions is dealing\n+with the fact that region variables are bound in function types.  I\n+strongly suggest that if you want to understand the situation, you\n+read this paper (which is, admittedly, very long, but you don't have\n+to read the whole thing):\n+\n+http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n+\n+Although my explanation will never compete with SPJ's (for one thing,\n+his is approximately 100 pages), I will attempt to explain the basic\n+problem and also how we solve it.  Note that the paper only discusses\n+subtyping, not the computation of LUB/GLB.\n+\n+The problem we are addressing is that there is a kind of subtyping\n+between functions with bound region parameters.  Consider, for\n+example, whether the following relation holds:\n+\n+    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n+\n+The answer is that of course it does.  These two types are basically\n+the same, except that in one we used the name `a` and one we used\n+the name `b`.\n+\n+In the examples that follow, it becomes very important to know whether\n+a lifetime is bound in a function type (that is, is a lifetime\n+parameter) or appears free (is defined in some outer scope).\n+Therefore, from now on I will write the bindings explicitly, using a\n+notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n+parameter.\n+\n+Now let's consider two more function types.  Here, we assume that the\n+`self` lifetime is defined somewhere outside and hence is not a\n+lifetime parameter bound by the function type (it \"appears free\"):\n+\n+    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n+\n+This subtyping relation does in fact hold.  To see why, you have to\n+consider what subtyping means.  One way to look at `T1 <: T2` is to\n+say that it means that it is always ok to treat an instance of `T1` as\n+if it had the type `T2`.  So, with our functions, it is always ok to\n+treat a function that can take pointers with any lifetime as if it\n+were a function that can only take a pointer with the specific\n+lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n+the function can take values of any lifetime.\n+\n+You can also look at subtyping as the *is a* relationship.  This amounts\n+to the same thing: a function that accepts pointers with any lifetime\n+*is a* function that accepts pointers with some specific lifetime.\n+\n+So, what if we reverse the order of the two function types, like this:\n+\n+    fn(&'self int) <: &fn<a>(&'a int)? (No)\n+\n+Does the subtyping relationship still hold?  The answer of course is\n+no.  In this case, the function accepts *only the lifetime `&self`*,\n+so it is not reasonable to treat it as if it were a function that\n+accepted any lifetime.\n+\n+What about these two examples:\n+\n+    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n+    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n+\n+Here, it is true that functions which take two pointers with any two\n+lifetimes can be treated as if they only accepted two pointers with\n+the same lifetime, but not the reverse.\n+\n+## The algorithm\n+\n+Here is the algorithm we use to perform the subtyping check:\n+\n+1. Replace all bound regions in the subtype with new variables\n+2. Replace all bound regions in the supertype with skolemized\n+   equivalents.  A \"skolemized\" region is just a new fresh region\n+   name.\n+3. Check that the parameter and return types match as normal\n+4. Ensure that no skolemized regions 'leak' into region variables\n+   visible from \"the outside\"\n+\n+Let's walk through some examples and see how this algorithm plays out.\n+\n+#### First example\n+\n+We'll start with the first example, which was:\n+\n+    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    1. fn(&'A T) <: &fn(&'x T)?\n+\n+Here the upper case `&A` indicates a *region variable*, that is, a\n+region whose value is being inferred by the system.  I also replaced\n+`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n+to indicate skolemized region names.  We can assume they don't appear\n+elsewhere.  Note that neither the sub- nor the supertype bind any\n+region names anymore (as indicated by the absence of `<` and `>`).\n+\n+The next step is to check that the parameter types match.  Because\n+parameters are contravariant, this means that we check whether:\n+\n+    &'x T <: &'A T\n+\n+Region pointers are contravariant so this implies that\n+\n+    &A <= &x\n+\n+must hold, where `<=` is the subregion relationship.  Processing\n+*this* constrain simply adds a constraint into our graph that `&A <=\n+&x` and is considered successful (it can, for example, be satisfied by\n+choosing the value `&x` for `&A`).\n+\n+So far we have encountered no error, so the subtype check succeeds.\n+\n+#### The third example\n+\n+Now let's look first at the third example, which was:\n+\n+    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    3. fn(&'self T) <: &fn(&'x T)?\n+\n+This looks pretty much the same as before, except that on the LHS\n+`&self` was not bound, and hence was left as-is and not replaced with\n+a variable.  The next step is again to check that the parameter types\n+match.  This will ultimately require (as before) that `&self` <= `&x`\n+must hold: but this does not hold.  `self` and `x` are both distinct\n+free regions.  So the subtype check fails.\n+\n+#### Checking for skolemization leaks\n+\n+You may be wondering about that mysterious last step in the algorithm.\n+So far it has not been relevant.  The purpose of that last step is to\n+catch something like *this*:\n+\n+    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n+\n+Here the function types are the same but for where the binding occurs.\n+The subtype returns a function that expects a value in precisely one\n+region.  The supertype returns a function that expects a value in any\n+region.  If we allow an instance of the subtype to be used where the\n+supertype is expected, then, someone could call the fn and think that\n+the return value has type `fn<b>(&'b T)` when it really has type\n+`fn(&'a T)` (this is case #3, above).  Bad.\n+\n+So let's step through what happens when we perform this subtype check.\n+We first replace the bound regions in the subtype (the supertype has\n+no bound regions).  This gives us:\n+\n+    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n+\n+Now we compare the return types, which are covariant, and hence we have:\n+\n+    fn(&'A T) <: &fn<b>(&'b T)?\n+\n+Here we skolemize the bound region in the supertype to yield:\n+\n+    fn(&'A T) <: &fn(&'x T)?\n+\n+And then proceed to compare the argument types:\n+\n+    &'x T <: &'A T\n+    &A <= &x\n+\n+Finally, this is where it gets interesting!  This is where an error\n+*should* be reported.  But in fact this will not happen.  The reason why\n+is that `A` is a variable: we will infer that its value is the fresh\n+region `x` and think that everything is happy.  In fact, this behavior\n+is *necessary*, it was key to the first example we walked through.\n+\n+The difference between this example and the first one is that the variable\n+`A` already existed at the point where the skolemization occurred.  In\n+the first example, you had two functions:\n+\n+    fn<a>(&'a T) <: &fn<b>(&'b T)\n+\n+and hence `&A` and `&x` were created \"together\".  In general, the\n+intention of the skolemized names is that they are supposed to be\n+fresh names that could never be equal to anything from the outside.\n+But when inference comes into play, we might not be respecting this\n+rule.\n+\n+So the way we solve this is to add a fourth step that examines the\n+constraints that refer to skolemized names.  Basically, consider a\n+non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n+set of all things reachable from a skolemized variable `x`.\n+`Tainted(x)` should not contain any regions that existed before the\n+step at which the skolemization was performed.  So this case here\n+would fail because `&x` was created alone, but is relatable to `&A`.\n+\n+## Computing the LUB and GLB\n+\n+The paper I pointed you at is written for Haskell.  It does not\n+therefore considering subtyping and in particular does not consider\n+LUB or GLB computation.  We have to consider this.  Here is the\n+algorithm I implemented.\n+\n+First though, let's discuss what we are trying to compute in more\n+detail.  The LUB is basically the \"common supertype\" and the GLB is\n+\"common subtype\"; one catch is that the LUB should be the\n+*most-specific* common supertype and the GLB should be *most general*\n+common subtype (as opposed to any common supertype or any common\n+subtype).\n+\n+Anyway, to help clarify, here is a table containing some\n+function pairs and their LUB/GLB:\n+\n+```\n+Type 1              Type 2              LUB               GLB\n+fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n+fn(&A)              fn(&X)              --                fn<a>(&a)\n+fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n+fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n+```\n+\n+### Conventions\n+\n+I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n+letters for free regions (`&A`).  Region variables written with a\n+dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n+bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n+\n+### High-level summary\n+\n+Both the LUB and the GLB algorithms work in a similar fashion.  They\n+begin by replacing all bound regions (on both sides) with fresh region\n+inference variables.  Therefore, both functions are converted to types\n+that contain only free regions.  We can then compute the LUB/GLB in a\n+straightforward way, as described in `combine.rs`.  This results in an\n+interim type T.  The algorithms then examine the regions that appear\n+in T and try to, in some cases, replace them with bound regions to\n+yield the final result.\n+\n+To decide whether to replace a region `R` that appears in `T` with a\n+bound region, the algorithms make use of two bits of information.\n+First is a set `V` that contains all region variables created as part\n+of the LUB/GLB computation. `V` will contain the region variables\n+created to replace the bound regions in the input types, but it also\n+contains 'intermediate' variables created to represent the LUB/GLB of\n+individual regions.  Basically, when asked to compute the LUB/GLB of a\n+region variable with another region, the inferencer cannot oblige\n+immediately since the valuese of that variables are not known.\n+Therefore, it creates a new variable that is related to the two\n+regions.  For example, the LUB of two variables `$x` and `$y` is a\n+fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n+<= $z`.  So `V` will contain these intermediate variables as well.\n+\n+The other important factor in deciding how to replace a region in T is\n+the function `Tainted($r)` which, for a region variable, identifies\n+all regions that the region variable is related to in some way\n+(`Tainted()` made an appearance in the subtype computation as well).\n+\n+### LUB\n+\n+The LUB algorithm proceeds in three steps:\n+\n+1. Replace all bound regions (on both sides) with fresh region\n+   inference variables.\n+2. Compute the LUB \"as normal\", meaning compute the GLB of each\n+   pair of argument types and the LUB of the return types and\n+   so forth.  Combine those to a new function type `F`.\n+3. Replace each region `R` that appears in `F` as follows:\n+   - Let `V` be the set of variables created during the LUB\n+     computational steps 1 and 2, as described in the previous section.\n+   - If `R` is not in `V`, replace `R` with itself.\n+   - If `Tainted(R)` contains a region that is not in `V`,\n+     replace `R` with itself.\n+   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n+     from the left-hand side and replace `R` with the bound region that\n+     this variable was a replacement for.\n+\n+So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n+In this case, `&a` will be replaced with `$a` and the interim LUB type\n+`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n+{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n+`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n+we leave `$b` as is.  When region inference happens, `$b` will be\n+resolved to `&A`, as we wanted.\n+\n+Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n+this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n+&h)` and a graph that looks like:\n+\n+```\n+     $a        $b     *--$x\n+       \\        \\    /  /\n+        \\        $h-*  /\n+         $g-----------*\n+```\n+\n+Here `$g` and `$h` are fresh variables that are created to represent\n+the LUB/GLB of things requiring inference.  This means that `V` and\n+`Tainted` will look like:\n+\n+```\n+V = {$a, $b, $g, $h, $x}\n+Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n+```\n+\n+Therefore we replace both `$g` and `$h` with `$a`, and end up\n+with the type `fn(&a, &a)`.\n+\n+### GLB\n+\n+The procedure for computing the GLB is similar.  The difference lies\n+in computing the replacements for the various variables. For each\n+region `R` that appears in the type `F`, we again compute `Tainted(R)`\n+and examine the results:\n+\n+1. If `R` is not in `V`, it is not replaced.\n+2. Else, if `Tainted(R)` contains only variables in `V`, and it\n+   contains exactly one variable from the LHS and one variable from\n+   the RHS, then `R` can be mapped to the bound version of the\n+   variable from the LHS.\n+3. Else, if `Tainted(R)` contains no variable from the LHS and no\n+   variable from the RHS, then `R` can be mapped to itself.\n+4. Else, `R` is mapped to a fresh bound variable.\n+\n+These rules are pretty complex.  Let's look at some examples to see\n+how they play out.\n+\n+Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n+be replaced with `$a` and we will ultimately compute a\n+(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n+Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n+replacement for `$g` we consult the rules above:\n+- Rule (1) does not apply because `$g \\in V`\n+- Rule (2) does not apply because `&X \\in Tainted($g)`\n+- Rule (3) does not apply because `$a \\in Tainted($g)`\n+- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n+So our final result is `fn(&z)`, which is correct.\n+\n+The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n+have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n+Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n+by rule (3), `$g` is mapped to itself, and hence the result is\n+`fn($g)`.  This result is correct (in this case, at least), but it is\n+indicative of a case that *can* lead us into concluding that there is\n+no GLB when in fact a GLB does exist.  See the section \"Questionable\n+Results\" below for more details.\n+\n+The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n+before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n+Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n+we'll select fresh bound variables `y` and `z` and wind up with\n+`fn(&y, &z)`.\n+\n+For the last example, let's consider what may seem trivial, but is\n+not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n+$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n+$x}`.  Both of these sets contain exactly one bound variable from each\n+side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n+is the desired result.\n+\n+### Shortcomings and correctness\n+\n+You may be wondering whether this algorithm is correct.  The answer is\n+\"sort of\".  There are definitely cases where they fail to compute a\n+result even though a correct result exists.  I believe, though, that\n+if they succeed, then the result is valid, and I will attempt to\n+convince you.  The basic argument is that the \"pre-replacement\" step\n+computes a set of constraints.  The replacements, then, attempt to\n+satisfy those constraints, using bound identifiers where needed.\n+\n+For now I will briefly go over the cases for LUB/GLB and identify\n+their intent:\n+\n+- LUB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains only values in V, then this region is unconstrained\n+    and can therefore be generalized, otherwise it cannot.\n+- GLB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains exactly one variable from each side, and\n+    only variables in V, that indicates that those two bound regions\n+    must be equated.\n+  - Otherwise, if Tainted(R) references any variables from left or right\n+    side, then it is trying to combine a bound region with a free one or\n+    multiple bound regions, so we need to select fresh bound regions.\n+\n+Sorry this is more of a shorthand to myself.  I will try to write up something\n+more convincing in the future.\n+\n+#### Where are the algorithms wrong?\n+\n+- The pre-replacement computation can fail even though using a\n+  bound-region would have succeeded.\n+- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n+  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n+  to regions without a GLB, then this is effectively a failure to compute\n+  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+\n+*/"}, {"sha": "b474b95d0fec229a1bd3528dd8c4f176ed88e7b1", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 4, "deletions": 528, "changes": 532, "blob_url": "https://github.com/rust-lang/rust/blob/d7522fec1599d99ff7cff95c53850fd72e74979f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7522fec1599d99ff7cff95c53850fd72e74979f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=d7522fec1599d99ff7cff95c53850fd72e74979f", "patch": "@@ -8,533 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n-\n-Region inference module.\n-\n-# Introduction\n-\n-Region inference uses a somewhat more involved algorithm than type\n-inference.  It is not the most efficient thing ever written though it\n-seems to work well enough in practice (famous last words).  The reason\n-that we use a different algorithm is because, unlike with types, it is\n-impractical to hand-annotate with regions (in some cases, there aren't\n-even the requisite syntactic forms).  So we have to get it right, and\n-it's worth spending more time on a more involved analysis.  Moreover,\n-regions are a simpler case than types: they don't have aggregate\n-structure, for example.\n-\n-Unlike normal type inference, which is similar in spirit to H-M and thus\n-works progressively, the region type inference works by accumulating\n-constraints over the course of a function.  Finally, at the end of\n-processing a function, we process and solve the constraints all at\n-once.\n-\n-The constraints are always of one of three possible forms:\n-\n-- ConstrainVarSubVar(R_i, R_j) states that region variable R_i\n-  must be a subregion of R_j\n-- ConstrainRegSubVar(R, R_i) states that the concrete region R\n-  (which must not be a variable) must be a subregion of the varibale R_i\n-- ConstrainVarSubReg(R_i, R) is the inverse\n-\n-# Building up the constraints\n-\n-Variables and constraints are created using the following methods:\n-\n-- `new_region_var()` creates a new, unconstrained region variable;\n-- `make_subregion(R_i, R_j)` states that R_i is a subregion of R_j\n-- `lub_regions(R_i, R_j) -> R_k` returns a region R_k which is\n-  the smallest region that is greater than both R_i and R_j\n-- `glb_regions(R_i, R_j) -> R_k` returns a region R_k which is\n-  the greatest region that is smaller than both R_i and R_j\n-\n-The actual region resolution algorithm is not entirely\n-obvious, though it is also not overly complex.  I'll explain\n-the algorithm as it currently works, then explain a somewhat\n-more complex variant that would probably scale better for\n-large graphs (and possibly all graphs).\n-\n-## Snapshotting\n-\n-It is also permitted to try (and rollback) changes to the graph.  This\n-is done by invoking `start_snapshot()`, which returns a value.  Then\n-later you can call `rollback_to()` which undoes the work.\n-Alternatively, you can call `commit()` which ends all snapshots.\n-Snapshots can be recursive---so you can start a snapshot when another\n-is in progress, but only the root snapshot can \"commit\".\n-\n-# Resolving constraints\n-\n-The constraint resolution algorithm is not super complex but also not\n-entirely obvious.  Here I describe the problem somewhat abstractly,\n-then describe how the current code works, and finally describe a\n-better solution that is as of yet unimplemented.  There may be other,\n-smarter ways of doing this with which I am unfamiliar and can't be\n-bothered to research at the moment. - NDM\n-\n-## The problem\n-\n-Basically our input is a directed graph where nodes can be divided\n-into two categories: region variables and concrete regions.  Each edge\n-`R -> S` in the graph represents a constraint that the region `R` is a\n-subregion of the region `S`.\n-\n-Region variable nodes can have arbitrary degree.  There is one region\n-variable node per region variable.\n-\n-Each concrete region node is associated with some, well, concrete\n-region: e.g., a free lifetime, or the region for a particular scope.\n-Note that there may be more than one concrete region node for a\n-particular region value.  Moreover, because of how the graph is built,\n-we know that all concrete region nodes have either in-degree 1 or\n-out-degree 1.\n-\n-Before resolution begins, we build up the constraints in a hashmap\n-that maps `Constraint` keys to spans.  During resolution, we construct\n-the actual `Graph` structure that we describe here.\n-\n-## Our current algorithm\n-\n-We divide region variables into two groups: Expanding and Contracting.\n-Expanding region variables are those that have a concrete region\n-predecessor (direct or indirect).  Contracting region variables are\n-all others.\n-\n-We first resolve the values of Expanding region variables and then\n-process Contracting ones.  We currently use an iterative, fixed-point\n-procedure (but read on, I believe this could be replaced with a linear\n-walk).  Basically we iterate over the edges in the graph, ensuring\n-that, if the source of the edge has a value, then this value is a\n-subregion of the target value.  If the target does not yet have a\n-value, it takes the value from the source.  If the target already had\n-a value, then the resulting value is Least Upper Bound of the old and\n-new values. When we are done, each Expanding node will have the\n-smallest region that it could possibly have and still satisfy the\n-constraints.\n-\n-We next process the Contracting nodes.  Here we again iterate over the\n-edges, only this time we move values from target to source (if the\n-source is a Contracting node).  For each contracting node, we compute\n-its value as the GLB of all its successors.  Basically contracting\n-nodes ensure that there is overlap between their successors; we will\n-ultimately infer the largest overlap possible.\n-\n-### A better algorithm\n-\n-Fixed-point iteration is not necessary.  What we ought to do is first\n-identify and remove strongly connected components (SCC) in the graph.\n-Note that such components must consist solely of region variables; all\n-of these variables can effectively be unified into a single variable.\n-\n-Once SCCs are removed, we are left with a DAG.  At this point, we can\n-walk the DAG in toplogical order once to compute the expanding nodes,\n-and again in reverse topological order to compute the contracting\n-nodes. The main reason I did not write it this way is that I did not\n-feel like implementing the SCC and toplogical sort algorithms at the\n-moment.\n-\n-# Skolemization and functions\n-\n-One of the trickiest and most subtle aspects of regions is dealing\n-with the fact that region variables are bound in function types.  I\n-strongly suggest that if you want to understand the situation, you\n-read this paper (which is, admittedly, very long, but you don't have\n-to read the whole thing):\n-\n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it.  Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters.  Consider, for\n-example, whether the following relation holds:\n-\n-    fn(&'a int) <: &fn(&'b int)? (Yes, a => b)\n-\n-The answer is that of course it does.  These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will write the bindings explicitly, using a\n-notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n-parameter.\n-\n-Now let's consider two more function types.  Here, we assume that the\n-`self` lifetime is defined somewhere outside and hence is not a\n-lifetime parameter bound by the function type (it \"appears free\"):\n-\n-    fn<a>(&'a int) <: &fn(&'self int)? (Yes, a => self)\n-\n-This subtyping relation does in fact hold.  To see why, you have to\n-consider what subtyping means.  One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`.  So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship.  This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'self int) <: &fn<a>(&'a int)? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no.  In this case, the function accepts *only the lifetime `&self`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    fn<a,b>(&'a int, &'b int) <: &fn<a>(&'a int, &'a int)? (Yes)\n-    fn<a>(&'a int, &'a int) <: &fn<a,b>(&'a int, &'b int)? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with skolemized\n-   equivalents.  A \"skolemized\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no skolemized regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. fn<a>(&'a T) <: &fn<b>(&'b T)?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: &fn(&'x T)?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system.  I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate skolemized region names.  We can assume they don't appear\n-elsewhere.  Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match.  Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship.  Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'self T)    <: &fn<b>(&'b T)?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'self T) <: &fn(&'x T)?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`&self` was not bound, and hence was left as-is and not replaced with\n-a variable.  The next step is again to check that the parameter types\n-match.  This will ultimately require (as before) that `&self` <= `&x`\n-must hold: but this does not hold.  `self` and `x` are both distinct\n-free regions.  So the subtype check fails.\n-\n-#### Checking for skolemization leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant.  The purpose of that last step is to\n-catch something like *this*:\n-\n-    fn<a>() -> fn(&'a T) <: &fn() -> fn<b>(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region.  The supertype returns a function that expects a value in any\n-region.  If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above).  Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions).  This gives us:\n-\n-    fn() -> fn(&'A T) <: &fn() -> fn<b>(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: &fn<b>(&'b T)?\n-\n-Here we skolemize the bound region in the supertype to yield:\n-\n-    fn(&'A T) <: &fn(&'x T)?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    &A <= &x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported.  But in fact this will not happen.  The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy.  In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the skolemization occurred.  In\n-the first example, you had two functions:\n-\n-    fn<a>(&'a T) <: &fn<b>(&'b T)\n-\n-and hence `&A` and `&x` were created \"together\".  In general, the\n-intention of the skolemized names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to skolemized names.  Basically, consider a\n-non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n-set of all things reachable from a skolemized variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the skolemization was performed.  So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell.  It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation.  We have to consider this.  Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail.  The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some\n-function pairs and their LUB/GLB:\n-\n-```\n-Type 1              Type 2              LUB               GLB\n-fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n-fn(&A)              fn(&X)              --                fn<a>(&a)\n-fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n-fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with a\n-bound region, the algorithms make use of two bits of information.\n-First is a set `V` that contains all region variables created as part\n-of the LUB/GLB computation. `V` will contain the region variables\n-created to replace the bound regions in the input types, but it also\n-contains 'intermediate' variables created to represent the LUB/GLB of\n-individual regions.  Basically, when asked to compute the LUB/GLB of a\n-region variable with another region, the inferencer cannot oblige\n-immediately since the valuese of that variables are not known.\n-Therefore, it creates a new variable that is related to the two\n-regions.  For example, the LUB of two variables `$x` and `$y` is a\n-fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-<= $z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n-\n-*/\n+/*! See doc.rs */\n \n \n use middle::ty;\n@@ -556,7 +30,9 @@ use syntax::ast;\n use syntax::opt_vec;\n use syntax::opt_vec::OptVec;\n \n-#[deriving(Eq,IterBytes)]\n+mod doc;\n+\n+#[deriving(Eq, IterBytes)]\n enum Constraint {\n     ConstrainVarSubVar(RegionVid, RegionVid),\n     ConstrainRegSubVar(Region, RegionVid),"}]}