{"sha": "ae7c534d042bb37e7e22cefabaa81b304638bc0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlN2M1MzRkMDQyYmIzN2U3ZTIyY2VmYWJhYTgxYjMwNDYzOGJjMGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T17:46:24Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-18T15:38:25Z"}, "message": "Fallout: port hashmap to use Unique", "tree": {"sha": "ab64794cf98d607986b05cd94211bfa57260c978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab64794cf98d607986b05cd94211bfa57260c978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae7c534d042bb37e7e22cefabaa81b304638bc0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae7c534d042bb37e7e22cefabaa81b304638bc0b", "html_url": "https://github.com/rust-lang/rust/commit/ae7c534d042bb37e7e22cefabaa81b304638bc0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae7c534d042bb37e7e22cefabaa81b304638bc0b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e0bb528a42a9c963d1616a86e0eb8fb80b34be8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e0bb528a42a9c963d1616a86e0eb8fb80b34be8", "html_url": "https://github.com/rust-lang/rust/commit/9e0bb528a42a9c963d1616a86e0eb8fb80b34be8"}], "stats": {"total": 62, "additions": 39, "deletions": 23}, "files": [{"sha": "aaf4cf4c445f1fb31c0f59372baad16c2139cf0f", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ae7c534d042bb37e7e22cefabaa81b304638bc0b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae7c534d042bb37e7e22cefabaa81b304638bc0b/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=ae7c534d042bb37e7e22cefabaa81b304638bc0b", "patch": "@@ -23,8 +23,8 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{self, PtrExt, copy_nonoverlapping_memory, zero_memory};\n-use rt::heap::{allocate, deallocate};\n+use ptr::{self, PtrExt, copy_nonoverlapping_memory, Unique, zero_memory};\n+use rt::heap::{allocate, deallocate, EMPTY};\n use collections::hash_state::HashState;\n \n const EMPTY_BUCKET: u64 = 0u64;\n@@ -69,10 +69,11 @@ const EMPTY_BUCKET: u64 = 0u64;\n pub struct RawTable<K, V> {\n     capacity: usize,\n     size:     usize,\n-    hashes:   *mut u64,\n+    hashes:   Unique<u64>,\n+\n     // Because K/V do not appear directly in any of the types in the struct,\n     // inform rustc that in fact instances of K and V are reachable from here.\n-    marker:   marker::CovariantType<(K,V)>,\n+    marker:   marker::PhantomData<(K,V)>,\n }\n \n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n@@ -81,7 +82,8 @@ unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n struct RawBucket<K, V> {\n     hash: *mut u64,\n     key:  *mut K,\n-    val:  *mut V\n+    val:  *mut V,\n+    _marker: marker::PhantomData<(K,V)>,\n }\n \n impl<K,V> Copy for RawBucket<K,V> {}\n@@ -170,11 +172,12 @@ fn can_alias_safehash_as_u64() {\n }\n \n impl<K, V> RawBucket<K, V> {\n-    unsafe fn offset(self, count: int) -> RawBucket<K, V> {\n+    unsafe fn offset(self, count: isize) -> RawBucket<K, V> {\n         RawBucket {\n             hash: self.hash.offset(count),\n             key:  self.key.offset(count),\n             val:  self.val.offset(count),\n+            _marker: marker::PhantomData,\n         }\n     }\n }\n@@ -567,10 +570,11 @@ impl<K, V> RawTable<K, V> {\n             return RawTable {\n                 size: 0,\n                 capacity: 0,\n-                hashes: ptr::null_mut(),\n-                marker: marker::CovariantType,\n+                hashes: Unique::new(EMPTY as *mut u64),\n+                marker: marker::PhantomData,\n             };\n         }\n+\n         // No need for `checked_mul` before a more restrictive check performed\n         // later in this method.\n         let hashes_size = capacity * size_of::<u64>();\n@@ -606,25 +610,26 @@ impl<K, V> RawTable<K, V> {\n         RawTable {\n             capacity: capacity,\n             size:     0,\n-            hashes:   hashes,\n-            marker:   marker::CovariantType,\n+            hashes:   Unique::new(hashes),\n+            marker:   marker::PhantomData,\n         }\n     }\n \n     fn first_bucket_raw(&self) -> RawBucket<K, V> {\n         let hashes_size = self.capacity * size_of::<u64>();\n         let keys_size = self.capacity * size_of::<K>();\n \n-        let buffer = self.hashes as *mut u8;\n+        let buffer = *self.hashes as *mut u8;\n         let (keys_offset, vals_offset) = calculate_offsets(hashes_size,\n                                                            keys_size, min_align_of::<K>(),\n                                                            min_align_of::<V>());\n \n         unsafe {\n             RawBucket {\n-                hash: self.hashes,\n+                hash: *self.hashes,\n                 key:  buffer.offset(keys_offset as isize) as *mut K,\n-                val:  buffer.offset(vals_offset as isize) as *mut V\n+                val:  buffer.offset(vals_offset as isize) as *mut V,\n+                _marker: marker::PhantomData,\n             }\n         }\n     }\n@@ -634,7 +639,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            zero_memory(ret.hashes, capacity);\n+            zero_memory(*ret.hashes, capacity);\n             ret\n         }\n     }\n@@ -656,7 +661,7 @@ impl<K, V> RawTable<K, V> {\n             hashes_end: unsafe {\n                 self.hashes.offset(self.capacity as isize)\n             },\n-            marker: marker::ContravariantLifetime,\n+            marker: marker::PhantomData,\n         }\n     }\n \n@@ -681,7 +686,7 @@ impl<K, V> RawTable<K, V> {\n             iter: RawBuckets {\n                 raw: raw,\n                 hashes_end: hashes_end,\n-                marker: marker::ContravariantLifetime,\n+                marker: marker::PhantomData,\n             },\n             table: self,\n         }\n@@ -694,7 +699,7 @@ impl<K, V> RawTable<K, V> {\n             iter: RawBuckets {\n                 raw: raw,\n                 hashes_end: hashes_end,\n-                marker: marker::ContravariantLifetime::<'static>,\n+                marker: marker::PhantomData,\n             },\n             table: self,\n         }\n@@ -708,7 +713,7 @@ impl<K, V> RawTable<K, V> {\n             raw: raw_bucket.offset(self.capacity as isize),\n             hashes_end: raw_bucket.hash,\n             elems_left: self.size,\n-            marker:     marker::ContravariantLifetime,\n+            marker:     marker::PhantomData,\n         }\n     }\n }\n@@ -718,7 +723,13 @@ impl<K, V> RawTable<K, V> {\n struct RawBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n     hashes_end: *mut u64,\n-    marker: marker::ContravariantLifetime<'a>,\n+\n+    // Strictly speaking, this should be &'a (K,V), but that would\n+    // require that K:'a, and we often use RawBuckets<'static...> for\n+    // move iterations, so that messes up a lot of other things. So\n+    // just use `&'a (K,V)` as this is not a publicly exposed type\n+    // anyway.\n+    marker: marker::PhantomData<&'a ()>,\n }\n \n // FIXME(#19839) Remove in favor of `#[derive(Clone)]`\n@@ -727,7 +738,7 @@ impl<'a, K, V> Clone for RawBuckets<'a, K, V> {\n         RawBuckets {\n             raw: self.raw,\n             hashes_end: self.hashes_end,\n-            marker: marker::ContravariantLifetime,\n+            marker: marker::PhantomData,\n         }\n     }\n }\n@@ -759,7 +770,11 @@ struct RevMoveBuckets<'a, K, V> {\n     raw: RawBucket<K, V>,\n     hashes_end: *mut u64,\n     elems_left: usize,\n-    marker: marker::ContravariantLifetime<'a>,\n+\n+    // As above, `&'a (K,V)` would seem better, but we often use\n+    // 'static for the lifetime, and this is not a publicly exposed\n+    // type.\n+    marker: marker::PhantomData<&'a ()>,\n }\n \n impl<'a, K, V> Iterator for RevMoveBuckets<'a, K, V> {\n@@ -966,9 +981,10 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n #[unsafe_destructor]\n impl<K, V> Drop for RawTable<K, V> {\n     fn drop(&mut self) {\n-        if self.hashes.is_null() {\n+        if self.capacity == 0 {\n             return;\n         }\n+\n         // This is done in reverse because we've likely partially taken\n         // some elements out with `.into_iter()` from the front.\n         // Check if the size is 0, so we don't do a useless scan when\n@@ -986,7 +1002,7 @@ impl<K, V> Drop for RawTable<K, V> {\n                                                     vals_size, min_align_of::<V>());\n \n         unsafe {\n-            deallocate(self.hashes as *mut u8, size, align);\n+            deallocate(*self.hashes as *mut u8, size, align);\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here.\n         }"}]}