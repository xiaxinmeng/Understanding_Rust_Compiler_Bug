{"sha": "cae3c936eb963cedc6523baeeaa9a58d13fa4c2e", "node_id": "C_kwDOAAsO6NoAKGNhZTNjOTM2ZWI5NjNjZWRjNjUyM2JhZWVhYTlhNThkMTNmYTRjMmU", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-10-20T10:11:59Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-11-12T20:02:32Z"}, "message": "linker: Factor out native library linking to a separate function", "tree": {"sha": "2f8786c8f1e3fc0bf136b4c98723fcbde18476f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f8786c8f1e3fc0bf136b4c98723fcbde18476f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae3c936eb963cedc6523baeeaa9a58d13fa4c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae3c936eb963cedc6523baeeaa9a58d13fa4c2e", "html_url": "https://github.com/rust-lang/rust/commit/cae3c936eb963cedc6523baeeaa9a58d13fa4c2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae3c936eb963cedc6523baeeaa9a58d13fa4c2e/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ef2485bd59cad3674b9c7de29316c20d7ddc6e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ef2485bd59cad3674b9c7de29316c20d7ddc6e7", "html_url": "https://github.com/rust-lang/rust/commit/8ef2485bd59cad3674b9c7de29316c20d7ddc6e7"}], "stats": {"total": 420, "additions": 207, "deletions": 213}, "files": [{"sha": "2ba8d701189fbe1ca43c868093e848e95301922f", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 207, "deletions": 213, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/cae3c936eb963cedc6523baeeaa9a58d13fa4c2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae3c936eb963cedc6523baeeaa9a58d13fa4c2e/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=cae3c936eb963cedc6523baeeaa9a58d13fa4c2e", "patch": "@@ -6,7 +6,7 @@ use rustc_data_structures::memmap::Mmap;\n use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n-use rustc_hir::def_id::CrateNum;\n+use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_metadata::find_native_static_library;\n use rustc_metadata::fs::{emit_metadata, METADATA_FILENAME};\n use rustc_middle::middle::dependency_format::Linkage;\n@@ -2007,15 +2007,9 @@ fn linker_with_args<'a>(\n     cmd.add_as_needed();\n \n     // Local native libraries of all kinds.\n-    //\n-    // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-    // external build system already has the native dependencies defined, and it\n-    // will provide them to the linker itself.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_local_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_local_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n-    // Upstream rust libraries and their (possibly bundled) static native libraries.\n+    // Upstream rust crates and their non-dynamic native libraries.\n     add_upstream_rust_crates(\n         cmd,\n         sess,\n@@ -2026,13 +2020,7 @@ fn linker_with_args<'a>(\n     );\n \n     // Dynamic native libraries from upstream crates.\n-    //\n-    // FIXME: Merge this to `add_upstream_rust_crates` so that all native libraries are linked\n-    // together with their respective upstream crates, and in their originally specified order.\n-    // This may be slightly breaking due to our use of `--as-needed` and needs a crater run.\n-    if sess.opts.unstable_opts.link_native_libraries {\n-        add_upstream_native_libraries(cmd, sess, codegen_results);\n-    }\n+    add_upstream_native_libraries(cmd, sess, archive_builder_builder, codegen_results, tmpdir);\n \n     // Link with the import library generated for any raw-dylib functions.\n     for (raw_dylib_name, raw_dylib_imports) in\n@@ -2276,42 +2264,46 @@ fn collect_natvis_visualizers(\n     visualizer_paths\n }\n \n-/// # Native library linking\n-///\n-/// User-supplied library search paths (-L on the command line). These are the same paths used to\n-/// find Rust crates, so some of them may have been added already by the previous crate linking\n-/// code. This only allows them to be found at compile time so it is still entirely up to outside\n-/// forces to make sure that library can be found at runtime.\n-///\n-/// Also note that the native libraries linked here are only the ones located in the current crate.\n-/// Upstream crates with native library dependencies may have their native library pulled in above.\n-fn add_local_native_libraries(\n+fn add_native_libs_from_crate(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+    search_paths: &OnceCell<Vec<PathBuf>>,\n+    bundled_libs: &FxHashSet<Symbol>,\n+    cnum: CrateNum,\n+    link_static: bool,\n+    link_dynamic: bool,\n ) {\n-    let filesearch = sess.target_filesearch(PathKind::All);\n-    for search_path in filesearch.search_paths() {\n-        match search_path.kind {\n-            PathKind::Framework => {\n-                cmd.framework_path(&search_path.dir);\n-            }\n-            _ => {\n-                cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir));\n-            }\n-        }\n+    if !sess.opts.unstable_opts.link_native_libraries {\n+        // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n+        // external build system already has the native dependencies defined, and it\n+        // will provide them to the linker itself.\n+        return;\n     }\n \n-    let relevant_libs =\n-        codegen_results.crate_info.used_libraries.iter().filter(|l| relevant_lib(sess, l));\n+    if sess.opts.unstable_opts.packed_bundled_libs && link_static && cnum != LOCAL_CRATE {\n+        // If rlib contains native libs as archives, unpack them to tmpdir.\n+        let rlib = &codegen_results.crate_info.used_crate_source[&cnum].rlib.as_ref().unwrap().0;\n+        archive_builder_builder\n+            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n+            .unwrap_or_else(|e| sess.emit_fatal(e));\n+    }\n+\n+    let native_libs = match cnum {\n+        LOCAL_CRATE => &codegen_results.crate_info.used_libraries,\n+        _ => &codegen_results.crate_info.native_libraries[&cnum],\n+    };\n \n-    let search_path = OnceCell::new();\n     let mut last = (None, NativeLibKind::Unspecified, None);\n-    for lib in relevant_libs {\n+    for lib in native_libs {\n         let Some(name) = lib.name else {\n             continue;\n         };\n-        let name = name.as_str();\n+        if !relevant_lib(sess, lib) {\n+            continue;\n+        }\n \n         // Skip if this library is the same as the last.\n         last = if (lib.name, lib.kind, lib.verbatim) == last {\n@@ -2320,42 +2312,119 @@ fn add_local_native_libraries(\n             (lib.name, lib.kind, lib.verbatim)\n         };\n \n+        let name = name.as_str();\n         let verbatim = lib.verbatim.unwrap_or(false);\n         match lib.kind {\n+            NativeLibKind::Static { bundle, whole_archive } => {\n+                if link_static {\n+                    let bundle = bundle.unwrap_or(true);\n+                    let whole_archive = whole_archive == Some(true)\n+                        // Backward compatibility case: this can be a rlib (so `+whole-archive`\n+                        // cannot be added explicitly if necessary, see the error in `fn link_rlib`)\n+                        // compiled as an executable due to `--test`. Use whole-archive implicitly,\n+                        // like before the introduction of native lib modifiers.\n+                        || (whole_archive == None\n+                            && bundle\n+                            && cnum == LOCAL_CRATE\n+                            && sess.opts.test);\n+\n+                    if bundle && cnum != LOCAL_CRATE {\n+                        if sess.opts.unstable_opts.packed_bundled_libs {\n+                            // If rlib contains native libs as archives, they are unpacked to tmpdir.\n+                            let path = tmpdir.join(lib.filename.unwrap().as_str());\n+                            if whole_archive {\n+                                cmd.link_whole_rlib(&path);\n+                            } else {\n+                                cmd.link_rlib(&path);\n+                            }\n+                        }\n+                    } else {\n+                        if whole_archive {\n+                            cmd.link_whole_staticlib(\n+                                name,\n+                                verbatim,\n+                                &search_paths.get_or_init(|| archive_search_paths(sess)),\n+                            );\n+                        } else {\n+                            // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n+                            // with glibc. This logic should be moved to the libc crate.\n+                            if cnum != LOCAL_CRATE\n+                                && sess.target.os == \"linux\"\n+                                && sess.target.env == \"gnu\"\n+                                && name == \"c\"\n+                            {\n+                                cmd.link_staticlib(\"gcc\", false);\n+                            }\n+                            cmd.link_staticlib(name, verbatim)\n+                        }\n+                    }\n+                }\n+            }\n             NativeLibKind::Dylib { as_needed } => {\n-                cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n+                }\n             }\n-            NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-            NativeLibKind::Framework { as_needed } => {\n-                cmd.link_framework(name, as_needed.unwrap_or(true))\n+            NativeLibKind::Unspecified => {\n+                if link_dynamic {\n+                    cmd.link_dylib(name, verbatim, true);\n+                }\n             }\n-            NativeLibKind::Static { whole_archive, bundle, .. } => {\n-                if whole_archive == Some(true)\n-                    // Backward compatibility case: this can be a rlib (so `+whole-archive` cannot\n-                    // be added explicitly if necessary, see the error in `fn link_rlib`) compiled\n-                    // as an executable due to `--test`. Use whole-archive implicitly, like before\n-                    // the introduction of native lib modifiers.\n-                    || (whole_archive == None && bundle != Some(false) && sess.opts.test)\n-                {\n-                    cmd.link_whole_staticlib(\n-                        name,\n-                        verbatim,\n-                        &search_path.get_or_init(|| archive_search_paths(sess)),\n-                    );\n-                } else {\n-                    cmd.link_staticlib(name, verbatim)\n+            NativeLibKind::Framework { as_needed } => {\n+                if link_dynamic {\n+                    cmd.link_framework(name, as_needed.unwrap_or(true))\n                 }\n             }\n             NativeLibKind::RawDylib => {\n-                // Ignore RawDylib here, they are handled separately in linker_with_args().\n+                // Handled separately in `linker_with_args`.\n             }\n             NativeLibKind::LinkArg => {\n-                cmd.arg(name);\n+                if link_static {\n+                    cmd.arg(name);\n+                }\n             }\n         }\n     }\n }\n \n+fn add_local_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n+    codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n+) {\n+    if sess.opts.unstable_opts.link_native_libraries {\n+        // User-supplied library search paths (-L on the command line). These are the same paths\n+        // used to find Rust crates, so some of them may have been added already by the previous\n+        // crate linking code. This only allows them to be found at compile time so it is still\n+        // entirely up to outside forces to make sure that library can be found at runtime.\n+        for search_path in sess.target_filesearch(PathKind::All).search_paths() {\n+            match search_path.kind {\n+                PathKind::Framework => cmd.framework_path(&search_path.dir),\n+                _ => cmd.include_path(&fix_windows_verbatim_for_gcc(&search_path.dir)),\n+            }\n+        }\n+    }\n+\n+    let search_paths = OnceCell::new();\n+    // All static and dynamic native library dependencies are linked to the local crate.\n+    let link_static = true;\n+    let link_dynamic = true;\n+    add_native_libs_from_crate(\n+        cmd,\n+        sess,\n+        archive_builder_builder,\n+        codegen_results,\n+        tmpdir,\n+        &search_paths,\n+        &Default::default(),\n+        LOCAL_CRATE,\n+        link_static,\n+        link_dynamic,\n+    );\n+}\n+\n /// # Linking Rust crates and their non-bundled static libraries\n ///\n /// Rust crates are not considered at all when creating an rlib output. All dependencies will be\n@@ -2388,14 +2457,23 @@ fn add_upstream_rust_crates<'a>(\n     let deps = &codegen_results.crate_info.used_crates;\n \n     let mut compiler_builtins = None;\n-    let search_path = OnceCell::new();\n+    let search_paths = OnceCell::new();\n \n     for &cnum in deps.iter() {\n         // We may not pass all crates through to the linker. Some crates may\n         // appear statically in an existing dylib, meaning we'll pick up all the\n         // symbols from the dylib.\n-        let src = &codegen_results.crate_info.used_crate_source[&cnum];\n-        match data[cnum.as_usize() - 1] {\n+        let linkage = data[cnum.as_usize() - 1];\n+        let bundled_libs =\n+            if sess.opts.unstable_opts.packed_bundled_libs && linkage == Linkage::Static {\n+                codegen_results.crate_info.native_libraries[&cnum]\n+                    .iter()\n+                    .filter_map(|lib| lib.filename)\n+                    .collect::<FxHashSet<_>>()\n+            } else {\n+                Default::default()\n+            };\n+        match linkage {\n             _ if codegen_results.crate_info.profiler_runtime == Some(cnum) => {\n                 add_static_crate(\n                     cmd,\n@@ -2414,108 +2492,43 @@ fn add_upstream_rust_crates<'a>(\n                 compiler_builtins = Some(cnum);\n             }\n             Linkage::NotLinked | Linkage::IncludedFromDylib => {}\n-            Linkage::Static => {\n-                let bundled_libs = if sess.opts.unstable_opts.packed_bundled_libs {\n-                    codegen_results.crate_info.native_libraries[&cnum]\n-                        .iter()\n-                        .filter_map(|lib| lib.filename)\n-                        .collect::<FxHashSet<_>>()\n-                } else {\n-                    Default::default()\n-                };\n-                add_static_crate(\n-                    cmd,\n-                    sess,\n-                    archive_builder_builder,\n-                    codegen_results,\n-                    tmpdir,\n-                    cnum,\n-                    &bundled_libs,\n-                );\n-\n-                // Link static native libs with \"-bundle\" modifier only if the crate they originate from\n-                // is being linked statically to the current crate.  If it's linked dynamically\n-                // or is an rlib already included via some other dylib crate, the symbols from\n-                // native libs will have already been included in that dylib.\n-                //\n-                // If `-Zlink-native-libraries=false` is set, then the assumption is that an\n-                // external build system already has the native dependencies defined, and it\n-                // will provide them to the linker itself.\n-                if sess.opts.unstable_opts.link_native_libraries {\n-                    if sess.opts.unstable_opts.packed_bundled_libs {\n-                        // If rlib contains native libs as archives, unpack them to tmpdir.\n-                        let rlib = &src.rlib.as_ref().unwrap().0;\n-                        archive_builder_builder\n-                            .extract_bundled_libs(rlib, tmpdir, &bundled_libs)\n-                            .unwrap_or_else(|e| sess.emit_fatal(e));\n-                    }\n-\n-                    let mut last = (None, NativeLibKind::Unspecified, None);\n-                    for lib in &codegen_results.crate_info.native_libraries[&cnum] {\n-                        let Some(name) = lib.name else {\n-                            continue;\n-                        };\n-                        let name = name.as_str();\n-                        if !relevant_lib(sess, lib) {\n-                            continue;\n-                        }\n-\n-                        // Skip if this library is the same as the last.\n-                        last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                            continue;\n-                        } else {\n-                            (lib.name, lib.kind, lib.verbatim)\n-                        };\n-\n-                        match lib.kind {\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(true),\n-                            } => {\n-                                cmd.link_whole_staticlib(\n-                                    name,\n-                                    lib.verbatim.unwrap_or(false),\n-                                    search_path.get_or_init(|| archive_search_paths(sess)),\n-                                );\n-                            }\n-                            NativeLibKind::Static {\n-                                bundle: Some(false),\n-                                whole_archive: Some(false) | None,\n-                            } => {\n-                                // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n-                                // with glibc. This logic should be moved to the libc crate.\n-                                if sess.target.os == \"linux\"\n-                                    && sess.target.env == \"gnu\"\n-                                    && name == \"c\"\n-                                {\n-                                    cmd.link_staticlib(\"gcc\", false);\n-                                }\n-                                cmd.link_staticlib(name, lib.verbatim.unwrap_or(false));\n-                            }\n-                            NativeLibKind::LinkArg => {\n-                                cmd.arg(name);\n-                            }\n-                            NativeLibKind::Dylib { .. }\n-                            | NativeLibKind::Framework { .. }\n-                            | NativeLibKind::Unspecified\n-                            | NativeLibKind::RawDylib => {}\n-                            NativeLibKind::Static { bundle: Some(true) | None, whole_archive } => {\n-                                if sess.opts.unstable_opts.packed_bundled_libs {\n-                                    // If rlib contains native libs as archives, they are unpacked to tmpdir.\n-                                    let path = tmpdir.join(lib.filename.unwrap().as_str());\n-                                    if whole_archive == Some(true) {\n-                                        cmd.link_whole_rlib(&path);\n-                                    } else {\n-                                        cmd.link_rlib(&path);\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+            Linkage::Static => add_static_crate(\n+                cmd,\n+                sess,\n+                archive_builder_builder,\n+                codegen_results,\n+                tmpdir,\n+                cnum,\n+                &bundled_libs,\n+            ),\n+            Linkage::Dynamic => {\n+                let src = &codegen_results.crate_info.used_crate_source[&cnum];\n+                add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0);\n             }\n-            Linkage::Dynamic => add_dynamic_crate(cmd, sess, &src.dylib.as_ref().unwrap().0),\n         }\n+\n+        // Static libraries are linked for a subset of linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we do not link\n+        // the native library because it is already linked into the dylib, and even if\n+        // inline/const/generic functions from the dylib can refer to symbols from the native\n+        // library, those symbols should be exported and available from the dylib anyway.\n+        let link_static = linkage == Linkage::Static;\n+        // Dynamic libraries are not linked here, see the FIXME in `add_upstream_native_libraries`.\n+        let link_dynamic = false;\n+        add_native_libs_from_crate(\n+            cmd,\n+            sess,\n+            archive_builder_builder,\n+            codegen_results,\n+            tmpdir,\n+            &search_paths,\n+            &bundled_libs,\n+            cnum,\n+            link_static,\n+            link_dynamic,\n+        );\n     }\n \n     // compiler-builtins are always placed last to ensure that they're\n@@ -2668,60 +2681,41 @@ fn add_upstream_rust_crates<'a>(\n     }\n }\n \n-/// Link in all of our upstream crates' native dependencies. Remember that all of these upstream\n-/// native dependencies are all non-static dependencies. We've got two cases then:\n-///\n-/// 1. The upstream crate is an rlib. In this case we *must* link in the native dependency because\n-/// the rlib is just an archive.\n-///\n-/// 2. The upstream crate is a dylib. In order to use the dylib, we have to have the dependency\n-/// present on the system somewhere. Thus, we don't gain a whole lot from not linking in the\n-/// dynamic dependency to this crate as well.\n-///\n-/// The use case for this is a little subtle. In theory the native dependencies of a crate are\n-/// purely an implementation detail of the crate itself, but the problem arises with generic and\n-/// inlined functions. If a generic function calls a native function, then the generic function\n-/// must be instantiated in the target crate, meaning that the native symbol must also be resolved\n-/// in the target crate.\n fn add_upstream_native_libraries(\n     cmd: &mut dyn Linker,\n     sess: &Session,\n+    archive_builder_builder: &dyn ArchiveBuilderBuilder,\n     codegen_results: &CodegenResults,\n+    tmpdir: &Path,\n ) {\n-    let mut last = (None, NativeLibKind::Unspecified, None);\n+    let search_path = OnceCell::new();\n     for &cnum in &codegen_results.crate_info.used_crates {\n-        for lib in codegen_results.crate_info.native_libraries[&cnum].iter() {\n-            let Some(name) = lib.name else {\n-                continue;\n-            };\n-            let name = name.as_str();\n-            if !relevant_lib(sess, &lib) {\n-                continue;\n-            }\n-\n-            // Skip if this library is the same as the last.\n-            last = if (lib.name, lib.kind, lib.verbatim) == last {\n-                continue;\n-            } else {\n-                (lib.name, lib.kind, lib.verbatim)\n-            };\n-\n-            let verbatim = lib.verbatim.unwrap_or(false);\n-            match lib.kind {\n-                NativeLibKind::Dylib { as_needed } => {\n-                    cmd.link_dylib(name, verbatim, as_needed.unwrap_or(true))\n-                }\n-                NativeLibKind::Unspecified => cmd.link_dylib(name, verbatim, true),\n-                NativeLibKind::Framework { as_needed } => {\n-                    cmd.link_framework(name, as_needed.unwrap_or(true))\n-                }\n-                // ignore static native libraries here as we've\n-                // already included them in add_local_native_libraries and\n-                // add_upstream_rust_crates\n-                NativeLibKind::Static { .. } => {}\n-                NativeLibKind::RawDylib | NativeLibKind::LinkArg => {}\n-            }\n-        }\n+        // Static libraries are not linked here, they are linked in `add_upstream_rust_crates`.\n+        // FIXME: Merge this function to `add_upstream_rust_crates` so that all native libraries\n+        // are linked together with their respective upstream crates, and in their originally\n+        // specified order. This is slightly breaking due to our use of `--as-needed` (see crater\n+        // results in https://github.com/rust-lang/rust/pull/102832#issuecomment-1279772306).\n+        let link_static = false;\n+        // Dynamic libraries are linked for all linked upstream crates.\n+        // 1. If the upstream crate is a directly linked rlib then we must link the native library\n+        // because the rlib is just an archive.\n+        // 2. If the upstream crate is a dylib or a rlib linked through dylib, then we have to link\n+        // the native library too because inline/const/generic functions from the dylib can refer\n+        // to symbols from the native library, so the native library providing those symbols should\n+        // be available when linking our final binary.\n+        let link_dynamic = true;\n+        add_native_libs_from_crate(\n+            cmd,\n+            sess,\n+            archive_builder_builder,\n+            codegen_results,\n+            tmpdir,\n+            &search_path,\n+            &Default::default(),\n+            cnum,\n+            link_static,\n+            link_dynamic,\n+        );\n     }\n }\n "}]}