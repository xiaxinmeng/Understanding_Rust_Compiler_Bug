{"sha": "3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMzBiYWQ2ZGU5MmZkMDBmMjRiOGJhOTU0Nzc5OGNiMWFmYTFiYTM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-24T18:17:27Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-06T08:52:16Z"}, "message": "Use `Ident` instead of `Name` in `MetaItem`", "tree": {"sha": "07ccbbb3d1690546c1f0ad75136aafaf08a84e62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07ccbbb3d1690546c1f0ad75136aafaf08a84e62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "html_url": "https://github.com/rust-lang/rust/commit/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "303298b1d53186c17b2466ac8678de77ea2a15fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/303298b1d53186c17b2466ac8678de77ea2a15fb", "html_url": "https://github.com/rust-lang/rust/commit/303298b1d53186c17b2466ac8678de77ea2a15fb"}], "stats": {"total": 302, "additions": 138, "deletions": 164}, "files": [{"sha": "b13c289394a7bf92ce83d11a714fcec10425f5a9", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -3503,12 +3503,10 @@ impl<'a> LoweringContext<'a> {\n                 let attr = {\n                     // allow(unreachable_code)\n                     let allow = {\n-                        let allow_ident = self.str_to_ident(\"allow\");\n-                        let uc_ident = self.str_to_ident(\"unreachable_code\");\n-                        let uc_meta_item = attr::mk_spanned_word_item(e.span, uc_ident);\n-                        let uc_nested = NestedMetaItemKind::MetaItem(uc_meta_item);\n-                        let uc_spanned = respan(e.span, uc_nested);\n-                        attr::mk_spanned_list_item(e.span, allow_ident, vec![uc_spanned])\n+                        let allow_ident = Ident::from_str(\"allow\").with_span_pos(e.span);\n+                        let uc_ident = Ident::from_str(\"unreachable_code\").with_span_pos(e.span);\n+                        let uc_nested = attr::mk_nested_word_item(uc_ident);\n+                        attr::mk_list_item(e.span, allow_ident, vec![uc_nested])\n                     };\n                     attr::mk_spanned_attr_outer(e.span, attr::mk_attr_id(), allow)\n                 };"}, {"sha": "3bb4c86e7c22ca23578fb58cef8898d38ce5c00b", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -341,7 +341,7 @@ impl_stable_hash_for!(enum ::syntax::ast::NestedMetaItemKind {\n });\n \n impl_stable_hash_for!(struct ::syntax::ast::MetaItem {\n-    name,\n+    ident,\n     node,\n     span\n });"}, {"sha": "e8b536d52676382e356f723d64564451376c2e27", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -221,7 +221,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue\n                     }\n                 };\n-                let name = word.name();\n+                let name = word.ident.name;\n                 match store.check_lint_name(&name.as_str()) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span);"}, {"sha": "8cb87e7e080b8c005fc3f3fdb02854a87081a442", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -1683,12 +1683,12 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> ast::CrateConfig {\n             } else if meta_item.is_meta_item_list() {\n                 let msg = format!(\n                     \"invalid predicate in --cfg command line argument: `{}`\",\n-                    meta_item.name()\n+                    meta_item.ident\n                 );\n                 early_error(ErrorOutputType::default(), &msg)\n             }\n \n-            (meta_item.name(), meta_item.value_str())\n+            (meta_item.ident.name, meta_item.value_str())\n         })\n         .collect::<ast::CrateConfig>()\n }"}, {"sha": "a1018cb946a018eb9bc9a0c41e8db854b46bd855", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -190,7 +190,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n             if let Some(ref condition) = command.condition {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n-                    options.contains(&(c.name().as_str().to_string(),\n+                    options.contains(&(c.ident.name.as_str().to_string(),\n                                       match c.value_str().map(|s| s.as_str().to_string()) {\n                                           Some(s) => Some(s),\n                                           None => None"}, {"sha": "6f88b0aecb6b674e935619c37aecb9b6be3ae9b5", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -1045,7 +1045,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            name,\n+                            ident: ast::Ident::with_empty_ctxt(name),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "57311a7b588a049fdf3580c25ae63503475fa286", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -110,7 +110,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n         for list_item in attr.meta_item_list().unwrap_or_default() {\n             match list_item.word() {\n                 Some(word) if value.is_none() =>\n-                    value = Some(word.name().clone()),\n+                    value = Some(word.ident.name),\n                 _ =>\n                     // FIXME better-encapsulate meta_item (don't directly access `node`)\n                     span_bug!(list_item.span(), \"unexpected meta-item {:?}\", list_item.node),"}, {"sha": "454b6cbd27df1e93b20952c3964b32ef8507d02a", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -152,7 +152,7 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a, BD> DataflowAnalysis<'a, 'tcx, BD> where BD: BitD\n                 } else {\n                     sess.span_err(\n                         item.span,\n-                        &format!(\"{} attribute requires a path\", item.name()));\n+                        &format!(\"{} attribute requires a path\", item.ident));\n                     return None;\n                 }\n             }"}, {"sha": "0542ca6fb24c271c18fa282b459e5a0e6af78140", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -717,7 +717,7 @@ impl<'a> Resolver<'a> {\n                 match attr.meta_item_list() {\n                     Some(names) => for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.imports.push((word.name(), attr.span()));\n+                            imports.imports.push((word.ident.name, attr.span()));\n                         } else {\n                             span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n                         }\n@@ -731,7 +731,7 @@ impl<'a> Resolver<'a> {\n                 if let Some(names) = attr.meta_item_list() {\n                     for attr in names {\n                         if let Some(word) = attr.word() {\n-                            imports.reexports.push((word.name(), attr.span()));\n+                            imports.reexports.push((word.ident.name, attr.span()));\n                         } else {\n                             bad_macro_reexport(self, attr.span());\n                         }"}, {"sha": "a87e1df5efc2c1d8258d68557294daf518e82982", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -171,7 +171,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             let mut segments = path.segments.into_vec();\n             let last = segments.pop().unwrap();\n \n-            let real_name = name.as_ref().map(|n| Symbol::from(n.as_str()));\n+            let real_name = name.map(|name| Symbol::intern(&name));\n \n             segments.push(hir::PathSegment::new(\n                 real_name.unwrap_or(last.name),"}, {"sha": "7f89b3e6b3a2aad64c6f3a343f8b8e6bfc2d2532", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -67,7 +67,7 @@ impl Cfg {\n     /// If the content is not properly formatted, it will return an error indicating what and where\n     /// the error is.\n     pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n-        let name = cfg.name();\n+        let name = cfg.ident.name;\n         match cfg.node {\n             MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n             MetaItemKind::NameValue(ref lit) => match lit.node {\n@@ -562,14 +562,14 @@ mod test {\n     fn test_parse_ok() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::Word,\n                 span: DUMMY_SP,\n             };\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n                     Symbol::intern(\"done\"),\n                     StrStyle::Cooked,\n@@ -579,15 +579,15 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -597,15 +597,15 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"any\"),\n+                ident: Ident::from_str(\"any\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -615,10 +615,10 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -628,26 +628,26 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"any\"),\n+                        ident: Ident::from_str(\"any\"),\n                         node: MetaItemKind::List(vec![\n                             dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                name: Symbol::intern(\"a\"),\n+                                ident: Ident::from_str(\"a\"),\n                                 node: MetaItemKind::Word,\n                                 span: DUMMY_SP,\n                             })),\n                             dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                name: Symbol::intern(\"all\"),\n+                                ident: Ident::from_str(\"all\"),\n                                 node: MetaItemKind::List(vec![\n                                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        name: Symbol::intern(\"b\"),\n+                                        ident: Ident::from_str(\"b\"),\n                                         node: MetaItemKind::Word,\n                                         span: DUMMY_SP,\n                                     })),\n                                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                                        name: Symbol::intern(\"c\"),\n+                                        ident: Ident::from_str(\"c\"),\n                                         node: MetaItemKind::Word,\n                                         span: DUMMY_SP,\n                                     })),\n@@ -663,20 +663,20 @@ mod test {\n             assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"c\"),\n+                        ident: Ident::from_str(\"c\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -691,22 +691,22 @@ mod test {\n     fn test_parse_err() {\n         with_globals(|| {\n             let mi = MetaItem {\n-                name: Symbol::intern(\"foo\"),\n+                ident: Ident::from_str(\"foo\"),\n                 node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -716,17 +716,17 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![]),\n                 span: DUMMY_SP,\n             };\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"foo\"),\n+                ident: Ident::from_str(\"foo\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -736,15 +736,15 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"all\"),\n+                ident: Ident::from_str(\"all\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"foo\"),\n+                        ident: Ident::from_str(\"foo\"),\n                         node: MetaItemKind::List(vec![]),\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"b\"),\n+                        ident: Ident::from_str(\"b\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n@@ -754,15 +754,15 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"any\"),\n+                ident: Ident::from_str(\"any\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"a\"),\n+                        ident: Ident::from_str(\"a\"),\n                         node: MetaItemKind::Word,\n                         span: DUMMY_SP,\n                     })),\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"foo\"),\n+                        ident: Ident::from_str(\"foo\"),\n                         node: MetaItemKind::List(vec![]),\n                         span: DUMMY_SP,\n                     })),\n@@ -772,10 +772,10 @@ mod test {\n             assert!(Cfg::parse(&mi).is_err());\n \n             let mi = MetaItem {\n-                name: Symbol::intern(\"not\"),\n+                ident: Ident::from_str(\"not\"),\n                 node: MetaItemKind::List(vec![\n                     dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n-                        name: Symbol::intern(\"foo\"),\n+                        ident: Ident::from_str(\"foo\"),\n                         node: MetaItemKind::List(vec![]),\n                         span: DUMMY_SP,\n                     })),"}, {"sha": "b57c9589afabc7792c3d1d7a782817d010fa0c53", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -21,9 +21,9 @@ pub use self::Visibility::*;\n \n use syntax;\n use syntax::abi::Abi;\n-use syntax::ast::{self, AttrStyle};\n+use syntax::ast::{self, AttrStyle, Ident};\n use syntax::attr;\n-use syntax::codemap::Spanned;\n+use syntax::codemap::{dummy_spanned, Spanned};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n@@ -840,7 +840,8 @@ impl Attributes {\n         for attr in attrs.lists(\"target_feature\") {\n             if attr.check_name(\"enable\") {\n                 if let Some(feat) = attr.value_str() {\n-                    let meta = attr::mk_name_value_item_str(\"target_feature\".into(), feat);\n+                    let meta = attr::mk_name_value_item_str(Ident::from_str(\"target_feature\"),\n+                                                            dummy_spanned(feat));\n                     if let Ok(feat_cfg) = Cfg::parse(&meta) {\n                         cfg &= feat_cfg;\n                     }\n@@ -1146,7 +1147,7 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n     use syntax::ext::base::{MacroKind, SyntaxExtension};\n     use syntax::ext::hygiene::Mark;\n-    let segment = ast::PathSegment::from_ident(ast::Ident::from_str(path_str));\n+    let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     let mut resolver = cx.resolver.borrow_mut();\n     let mark = Mark::root();\n@@ -1158,7 +1159,7 @@ fn macro_resolve(cx: &DocContext, path_str: &str) -> Option<Def> {\n         } else {\n             None\n         }\n-    } else if let Some(def) = resolver.all_macros.get(&path_str.into()) {\n+    } else if let Some(def) = resolver.all_macros.get(&Symbol::intern(path_str)) {\n         Some(*def)\n     } else {\n         None"}, {"sha": "1c9ea2618411347e78c22f2d50625f0dfdf6f351", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -2966,7 +2966,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n }\n \n fn render_attribute(attr: &ast::MetaItem) -> Option<String> {\n-    let name = attr.name();\n+    let name = attr.ident.name;\n \n     if attr.is_word() {\n         Some(format!(\"{}\", name))"}, {"sha": "e7900af7f121dca4869c8a32cbfb3ca4e9402000", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -477,7 +477,7 @@ pub enum NestedMetaItemKind {\n /// E.g. `#[test]`, `#[derive(..)]` or `#[feature = \"foo\"]`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MetaItem {\n-    pub name: Name,\n+    pub ident: Ident,\n     pub node: MetaItemKind,\n     pub span: Span,\n }"}, {"sha": "2812e1238e9a0fd98fb39887879b1752ae33f6a6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 43, "deletions": 63, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -19,7 +19,7 @@ use ast::{AttrId, Attribute, Name, Ident};\n use ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind};\n use ast::{Lit, LitKind, Expr, ExprKind, Item, Local, Stmt, StmtKind};\n use codemap::{Spanned, respan, dummy_spanned};\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n use errors::Handler;\n use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n@@ -137,7 +137,7 @@ impl NestedMetaItem {\n     /// Returns the name of the meta item, e.g. `foo` in `#[foo]`,\n     /// `#[foo=\"bar\"]` and `#[foo(bar)]`, if self is a MetaItem\n     pub fn name(&self) -> Option<Name> {\n-        self.meta_item().and_then(|meta_item| Some(meta_item.name()))\n+        self.meta_item().and_then(|meta_item| Some(meta_item.ident.name))\n     }\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n@@ -154,7 +154,7 @@ impl NestedMetaItem {\n                     if meta_item_list.len() == 1 {\n                         let nested_item = &meta_item_list[0];\n                         if nested_item.is_literal() {\n-                            Some((meta_item.name(), nested_item.literal().unwrap()))\n+                            Some((meta_item.ident.name, nested_item.literal().unwrap()))\n                         } else {\n                             None\n                         }\n@@ -250,10 +250,6 @@ impl Attribute {\n }\n \n impl MetaItem {\n-    pub fn name(&self) -> Name {\n-        self.name\n-    }\n-\n     pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n@@ -283,7 +279,7 @@ impl MetaItem {\n     pub fn span(&self) -> Span { self.span }\n \n     pub fn check_name(&self, name: &str) -> bool {\n-        self.name() == name\n+        self.ident.name == name\n     }\n \n     pub fn is_value_str(&self) -> bool {\n@@ -300,8 +296,8 @@ impl Attribute {\n     pub fn meta(&self) -> Option<MetaItem> {\n         let mut tokens = self.tokens.trees().peekable();\n         Some(MetaItem {\n-            name: match self.path.segments.len() {\n-                1 => self.path.segments[0].ident.name,\n+            ident: match self.path.segments.len() {\n+                1 => self.path.segments[0].ident,\n                 _ => return None,\n             },\n             node: if let Some(node) = MetaItemKind::from_tokens(&mut tokens) {\n@@ -353,7 +349,7 @@ impl Attribute {\n         }\n \n         Ok(MetaItem {\n-            name: self.path.segments.last().unwrap().ident.name,\n+            ident: self.path.segments.last().unwrap().ident,\n             node: self.parse(sess, |parser| parser.parse_meta_item_kind())?,\n             span: self.span,\n         })\n@@ -368,8 +364,8 @@ impl Attribute {\n         if self.is_sugared_doc {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n-                Symbol::intern(\"doc\"),\n-                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())));\n+                Ident::from_str(\"doc\"),\n+                dummy_spanned(Symbol::intern(&strip_doc_comment_decoration(&comment.as_str()))));\n             let mut attr = if self.style == ast::AttrStyle::Outer {\n                 mk_attr_outer(self.span, self.id, meta)\n             } else {\n@@ -385,37 +381,24 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n-    let value_lit = dummy_spanned(LitKind::Str(value, ast::StrStyle::Cooked));\n-    mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n+pub fn mk_name_value_item_str(ident: Ident, value: Spanned<Symbol>) -> MetaItem {\n+    let value = respan(value.span, LitKind::Str(value.node, ast::StrStyle::Cooked));\n+    mk_name_value_item(ident.span.to(value.span), ident, value)\n }\n \n-pub fn mk_name_value_item(name: Name, value: ast::Lit) -> MetaItem {\n-    mk_spanned_name_value_item(DUMMY_SP, name, value)\n+pub fn mk_name_value_item(span: Span, ident: Ident, value: ast::Lit) -> MetaItem {\n+    MetaItem { ident, span, node: MetaItemKind::NameValue(value) }\n }\n \n-pub fn mk_list_item(name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n-    mk_spanned_list_item(DUMMY_SP, name, items)\n+pub fn mk_list_item(span: Span, ident: Ident, items: Vec<NestedMetaItem>) -> MetaItem {\n+    MetaItem { ident, span, node: MetaItemKind::List(items) }\n }\n \n-pub fn mk_list_word_item(name: Name) -> ast::NestedMetaItem {\n-    dummy_spanned(NestedMetaItemKind::MetaItem(mk_spanned_word_item(DUMMY_SP, name)))\n+pub fn mk_word_item(ident: Ident) -> MetaItem {\n+    MetaItem { ident, span: ident.span, node: MetaItemKind::Word }\n }\n-\n-pub fn mk_word_item(name: Name) -> MetaItem {\n-    mk_spanned_word_item(DUMMY_SP, name)\n-}\n-\n-pub fn mk_spanned_name_value_item(sp: Span, name: Name, value: ast::Lit) -> MetaItem {\n-    MetaItem { span: sp, name: name, node: MetaItemKind::NameValue(value) }\n-}\n-\n-pub fn mk_spanned_list_item(sp: Span, name: Name, items: Vec<NestedMetaItem>) -> MetaItem {\n-    MetaItem { span: sp, name: name, node: MetaItemKind::List(items) }\n-}\n-\n-pub fn mk_spanned_word_item(sp: Span, name: Name) -> MetaItem {\n-    MetaItem { span: sp, name: name, node: MetaItemKind::Word }\n+pub fn mk_nested_word_item(ident: Ident) -> NestedMetaItem {\n+    respan(ident.span, NestedMetaItemKind::MetaItem(mk_word_item(ident)))\n }\n \n pub fn mk_attr_id() -> AttrId {\n@@ -436,11 +419,10 @@ pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n \n /// Returns an inner attribute with the given value and span.\n pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n-    let ident = ast::Ident::with_empty_ctxt(item.name).with_span_pos(item.span);\n     Attribute {\n         id,\n         style: ast::AttrStyle::Inner,\n-        path: ast::Path::from_ident(ident),\n+        path: ast::Path::from_ident(item.ident),\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -455,11 +437,10 @@ pub fn mk_attr_outer(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n \n /// Returns an outer attribute with the given value and span.\n pub fn mk_spanned_attr_outer(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n-    let ident = ast::Ident::with_empty_ctxt(item.name).with_span_pos(item.span);\n     Attribute {\n         id,\n         style: ast::AttrStyle::Outer,\n-        path: ast::Path::from_ident(ident),\n+        path: ast::Path::from_ident(item.ident),\n         tokens: item.node.tokens(item.span),\n         is_sugared_doc: false,\n         span: sp,\n@@ -472,7 +453,7 @@ pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, span: Span) -> Attribute {\n     Attribute {\n         id,\n         style,\n-        path: ast::Path::from_ident(ast::Ident::from_str(\"doc\").with_span_pos(span)),\n+        path: ast::Path::from_ident(Ident::from_str(\"doc\").with_span_pos(span)),\n         tokens: MetaItemKind::NameValue(lit).tokens(span),\n         is_sugared_doc: true,\n         span,\n@@ -508,7 +489,7 @@ pub fn contains_feature_attr(attrs: &[Attribute], feature_name: &str) -> bool {\n         item.check_name(\"feature\") &&\n         item.meta_item_list().map(|list| {\n             list.iter().any(|mi| {\n-                mi.word().map(|w| w.name() == feature_name)\n+                mi.word().map(|w| w.ident.name == feature_name)\n                          .unwrap_or(false)\n             })\n         }).unwrap_or(false)\n@@ -581,7 +562,7 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n         if let (Some(feats), Some(gated_cfg)) = (features, GatedCfg::gate(cfg)) {\n             gated_cfg.check_and_emit(sess, feats);\n         }\n-        sess.config.contains(&(cfg.name(), cfg.value_str()))\n+        sess.config.contains(&(cfg.ident.name, cfg.value_str()))\n     })\n }\n \n@@ -602,7 +583,7 @@ pub fn eval_condition<F>(cfg: &ast::MetaItem, sess: &ParseSess, eval: &mut F)\n \n             // The unwraps below may look dangerous, but we've already asserted\n             // that they won't fail with the loop above.\n-            match &*cfg.name.as_str() {\n+            match &*cfg.ident.name.as_str() {\n                 \"any\" => mis.iter().any(|mi| {\n                     eval_condition(mi.meta_item().unwrap(), sess, eval)\n                 }),\n@@ -695,7 +676,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n             let meta = meta.as_ref().unwrap();\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -714,14 +695,14 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     )+\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n+                            match &*mi.ident.name.as_str() {\n                                 $(\n                                     stringify!($name)\n                                         => if !get(mi, &mut $name) { continue 'outer },\n                                 )+\n                                 _ => {\n                                     handle_errors(diagnostic, mi.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                                  AttrError::UnknownMetaItem(mi.ident.name));\n                                     continue 'outer\n                                 }\n                             }\n@@ -733,7 +714,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                 }\n             }\n \n-            match &*meta.name.as_str() {\n+            match &*meta.ident.name.as_str() {\n                 \"rustc_deprecated\" => {\n                     if rustc_depr.is_some() {\n                         span_err!(diagnostic, item_sp, E0540,\n@@ -788,13 +769,13 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut issue = None;\n                     for meta in metas {\n                         if let Some(mi) = meta.meta_item() {\n-                            match &*mi.name().as_str() {\n+                            match &*mi.ident.name.as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"reason\" => if !get(mi, &mut reason) { continue 'outer },\n                                 \"issue\" => if !get(mi, &mut issue) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                                  AttrError::UnknownMetaItem(mi.ident.name));\n                                     continue 'outer\n                                 }\n                             }\n@@ -844,12 +825,12 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                     let mut since = None;\n                     for meta in metas {\n                         if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                            match &*mi.name().as_str() {\n+                            match &*mi.ident.name.as_str() {\n                                 \"feature\" => if !get(mi, &mut feature) { continue 'outer },\n                                 \"since\" => if !get(mi, &mut since) { continue 'outer },\n                                 _ => {\n                                     handle_errors(diagnostic, meta.span,\n-                                                  AttrError::UnknownMetaItem(mi.name()));\n+                                                  AttrError::UnknownMetaItem(mi.ident.name));\n                                     continue 'outer\n                                 }\n                             }\n@@ -936,7 +917,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         depr = if let Some(metas) = attr.meta_item_list() {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n-                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n+                    handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.ident.name));\n                     return false\n                 }\n                 if let Some(v) = meta.value_str() {\n@@ -952,12 +933,12 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n             let mut note = None;\n             for meta in metas {\n                 if let NestedMetaItemKind::MetaItem(ref mi) = meta.node {\n-                    match &*mi.name().as_str() {\n+                    match &*mi.ident.name.as_str() {\n                         \"since\" => if !get(mi, &mut since) { continue 'outer },\n                         \"note\" => if !get(mi, &mut note) { continue 'outer },\n                         _ => {\n                             handle_errors(diagnostic, meta.span,\n-                                          AttrError::UnknownMetaItem(mi.name()));\n+                                          AttrError::UnknownMetaItem(mi.ident.name));\n                             continue 'outer\n                         }\n                     }\n@@ -1009,7 +990,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n \n                 let mut recognised = false;\n                 if let Some(mi) = item.word() {\n-                    let word = &*mi.name().as_str();\n+                    let word = &*mi.ident.name.as_str();\n                     let hint = match word {\n                         \"C\" => Some(ReprC),\n                         \"packed\" => Some(ReprPacked),\n@@ -1108,18 +1089,17 @@ impl IntType {\n \n impl MetaItem {\n     fn tokens(&self) -> TokenStream {\n-        let ident = TokenTree::Token(self.span,\n-                                     Token::from_ast_ident(Ident::with_empty_ctxt(self.name)));\n+        let ident = TokenTree::Token(self.span, Token::from_ast_ident(self.ident));\n         TokenStream::concat(vec![ident.into(), self.node.tokens(self.span)])\n     }\n \n     fn from_tokens<I>(tokens: &mut iter::Peekable<I>) -> Option<MetaItem>\n         where I: Iterator<Item = TokenTree>,\n     {\n-        let (span, name) = match tokens.next() {\n-            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident.name),\n+        let (span, ident) = match tokens.next() {\n+            Some(TokenTree::Token(span, Token::Ident(ident, _))) => (span, ident),\n             Some(TokenTree::Token(_, Token::Interpolated(ref nt))) => match nt.0 {\n-                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident.name),\n+                token::Nonterminal::NtIdent(ident, _) => (ident.span, ident),\n                 token::Nonterminal::NtMeta(ref meta) => return Some(meta.clone()),\n                 _ => return None,\n             },\n@@ -1132,7 +1112,7 @@ impl MetaItem {\n             MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi()),\n             _ => span.hi(),\n         };\n-        Some(MetaItem { name, node, span: span.with_hi(hi) })\n+        Some(MetaItem { ident, node, span: span.with_hi(hi) })\n     }\n }\n "}, {"sha": "062f3ce112752cec5d82a474bd0b8aec469f4584", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -1129,21 +1129,22 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn meta_word(&self, sp: Span, w: ast::Name) -> ast::MetaItem {\n-        attr::mk_spanned_word_item(sp, w)\n+        attr::mk_word_item(Ident::with_empty_ctxt(w).with_span_pos(sp))\n     }\n \n     fn meta_list_item_word(&self, sp: Span, w: ast::Name) -> ast::NestedMetaItem {\n-        respan(sp, ast::NestedMetaItemKind::MetaItem(attr::mk_spanned_word_item(sp, w)))\n+        attr::mk_nested_word_item(Ident::with_empty_ctxt(w).with_span_pos(sp))\n     }\n \n     fn meta_list(&self, sp: Span, name: ast::Name, mis: Vec<ast::NestedMetaItem>)\n                  -> ast::MetaItem {\n-        attr::mk_spanned_list_item(sp, name, mis)\n+        attr::mk_list_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp), mis)\n     }\n \n     fn meta_name_value(&self, sp: Span, name: ast::Name, value: ast::LitKind)\n                        -> ast::MetaItem {\n-        attr::mk_spanned_name_value_item(sp, name, respan(sp, value))\n+        attr::mk_name_value_item(sp, Ident::with_empty_ctxt(name).with_span_pos(sp),\n+                                 respan(sp, value))\n     }\n \n     fn item_use(&self, sp: Span,"}, {"sha": "678c20402d6f47aab78e99f35b0234f61d2846eb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 invoc.expansion_data.mark.set_expn_info(expn_info);\n                 let span = span.with_ctxt(self.cx.backtrace());\n                 let dummy = ast::MetaItem { // FIXME(jseyfried) avoid this\n-                    name: keywords::Invalid.name(),\n+                    ident: keywords::Invalid.ident(),\n                     span: DUMMY_SP,\n                     node: ast::MetaItemKind::Word,\n                 };\n@@ -1279,15 +1279,16 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n \n                             let include_info = vec![\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_name_value_item_str(\"file\".into(),\n-                                                                     file))),\n+                                        attr::mk_name_value_item_str(Ident::from_str(\"file\"),\n+                                                                     dummy_spanned(file)))),\n                                 dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_name_value_item_str(\"contents\".into(),\n-                                                                     (&*src).into()))),\n+                                        attr::mk_name_value_item_str(Ident::from_str(\"contents\"),\n+                                                            dummy_spanned(Symbol::intern(&src))))),\n                             ];\n \n-                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(\n-                                        attr::mk_list_item(\"include\".into(), include_info))));\n+                            let include_ident = Ident::from_str(\"include\");\n+                            let item = attr::mk_list_item(DUMMY_SP, include_ident, include_info);\n+                            items.push(dummy_spanned(ast::NestedMetaItemKind::MetaItem(item)));\n                         }\n                         Err(_) => {\n                             self.cx.span_err(at.span,\n@@ -1300,7 +1301,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 }\n             }\n \n-            let meta = attr::mk_list_item(\"doc\".into(), items);\n+            let meta = attr::mk_list_item(DUMMY_SP, Ident::from_str(\"doc\"), items);\n             match at.style {\n                 ast::AttrStyle::Inner =>\n                     Some(attr::mk_spanned_attr_inner(at.span, at.id, meta)),"}, {"sha": "24bfb5d9088f72b7c93891ade56032054100bc4c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -1054,7 +1054,7 @@ pub struct GatedCfg {\n \n impl GatedCfg {\n     pub fn gate(cfg: &ast::MetaItem) -> Option<GatedCfg> {\n-        let name = cfg.name().as_str();\n+        let name = cfg.ident.name.as_str();\n         GATED_CFGS.iter()\n                   .position(|info| info.0 == name)\n                   .map(|idx| {\n@@ -1811,7 +1811,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                 for mi in list {\n \n                     let name = if let Some(word) = mi.word() {\n-                        word.name()\n+                        word.ident.name\n                     } else {\n                         span_err!(span_handler, mi.span, E0556,\n                                   \"malformed feature, expected just one word\");"}, {"sha": "ba6703b9c74406ee24db0cc8b83e24074e47520f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -543,7 +543,7 @@ pub fn noop_fold_meta_list_item<T: Folder>(li: NestedMetaItem, fld: &mut T)\n \n pub fn noop_fold_meta_item<T: Folder>(mi: MetaItem, fld: &mut T) -> MetaItem {\n     MetaItem {\n-        name: mi.name,\n+        ident: mi.ident,\n         node: match mi.node {\n             MetaItemKind::Word => MetaItemKind::Word,\n             MetaItemKind::List(mis) => {"}, {"sha": "90f08ab1468e212ca37cce4df7ae0f7bf6e669c0", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -149,8 +149,7 @@ impl<'a> Parser<'a> {\n         };\n         Ok(if let Some(meta) = meta {\n             self.bump();\n-            (ast::Path::from_ident(ast::Ident::with_empty_ctxt(meta.name).with_span_pos(meta.span)),\n-             meta.node.tokens(meta.span))\n+            (ast::Path::from_ident(meta.ident), meta.node.tokens(meta.span))\n         } else {\n             (self.parse_path(PathStyle::Mod)?, self.parse_tokens())\n         })\n@@ -228,7 +227,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span;\n         let ident = self.parse_ident()?;\n         let node = self.parse_meta_item_kind()?;\n-        Ok(ast::MetaItem { name: ident.name, node: node, span: lo.to(self.prev_span) })\n+        Ok(ast::MetaItem { ident, node: node, span: lo.to(self.prev_span) })\n     }\n \n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {"}, {"sha": "e6da5bcaa3ae6cc61a8bd84b9445211274fcb2e8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -1957,7 +1957,7 @@ impl<'a> Parser<'a> {\n         let meta_ident = match self.token {\n             token::Interpolated(ref nt) => match nt.0 {\n                 token::NtMeta(ref meta) => match meta.node {\n-                    ast::MetaItemKind::Word => Some(ast::Ident::with_empty_ctxt(meta.name)),\n+                    ast::MetaItemKind::Word => Some(meta.ident),\n                     _ => None,\n                 },\n                 _ => None,\n@@ -1966,7 +1966,7 @@ impl<'a> Parser<'a> {\n         };\n         if let Some(ident) = meta_ident {\n             self.bump();\n-            return Ok(ast::Path::from_ident(ident.with_span_pos(self.prev_span)));\n+            return Ok(ast::Path::from_ident(ident));\n         }\n         self.parse_path(style)\n     }"}, {"sha": "8d42206c5ccffa4c62c8c0f48ea123942aa5154f", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -26,7 +26,7 @@ use print::pp::{self, Breaks};\n use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n-use symbol::{Symbol, keywords};\n+use symbol::keywords;\n use syntax_pos::{DUMMY_SP, FileName};\n use tokenstream::{self, TokenStream, TokenTree};\n \n@@ -101,13 +101,13 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n         // of the feature gate, so we fake them up here.\n \n         // #![feature(prelude_import)]\n-        let prelude_import_meta = attr::mk_list_word_item(Symbol::intern(\"prelude_import\"));\n-        let list = attr::mk_list_item(Symbol::intern(\"feature\"), vec![prelude_import_meta]);\n+        let pi_nested = attr::mk_nested_word_item(ast::Ident::from_str(\"prelude_import\"));\n+        let list = attr::mk_list_item(DUMMY_SP, ast::Ident::from_str(\"feature\"), vec![pi_nested]);\n         let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), list);\n         s.print_attribute(&fake_attr)?;\n \n         // #![no_std]\n-        let no_std_meta = attr::mk_word_item(Symbol::intern(\"no_std\"));\n+        let no_std_meta = attr::mk_word_item(ast::Ident::from_str(\"no_std\"));\n         let fake_attr = attr::mk_attr_inner(DUMMY_SP, attr::mk_attr_id(), no_std_meta);\n         s.print_attribute(&fake_attr)?;\n     }\n@@ -768,15 +768,15 @@ pub trait PrintState<'a> {\n         self.ibox(INDENT_UNIT)?;\n         match item.node {\n             ast::MetaItemKind::Word => {\n-                self.writer().word(&item.name.as_str())?;\n+                self.writer().word(&item.ident.name.as_str())?;\n             }\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.word_space(&item.name.as_str())?;\n+                self.word_space(&item.ident.name.as_str())?;\n                 self.word_space(\"=\")?;\n                 self.print_literal(value)?;\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.writer().word(&item.name.as_str())?;\n+                self.writer().word(&item.ident.name.as_str())?;\n                 self.popen()?;\n                 self.commasep(Consistent,\n                               &items[..],"}, {"sha": "63d7b3336a861a9158d5c26aa3fa0f594a33a79a", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -57,7 +57,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<&str>\n     krate.module.items.insert(0, P(ast::Item {\n         attrs: vec![attr::mk_attr_outer(DUMMY_SP,\n                                         attr::mk_attr_id(),\n-                                        attr::mk_word_item(Symbol::intern(\"macro_use\")))],\n+                                        attr::mk_word_item(ast::Ident::from_str(\"macro_use\")))],\n         vis: dummy_spanned(ast::VisibilityKind::Inherited),\n         node: ast::ItemKind::ExternCrate(alt_std_name.map(Symbol::intern)),\n         ident: ast::Ident::from_str(name),"}, {"sha": "fd2e760e9bee0ab5108d76eb779735280dcf909b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -195,10 +195,10 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 folded.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_str = Symbol::intern(\"allow\");\n-                    let dead_code_str = Symbol::intern(\"dead_code\");\n-                    let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n-                    let allow_dead_code_item = attr::mk_list_item(allow_str, word_vec);\n+                    let allow_ident = Ident::from_str(\"allow\");\n+                    let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n+                    let allow_dead_code_item = attr::mk_list_item(DUMMY_SP, allow_ident,\n+                                                                  vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(DUMMY_SP,\n                                                               attr::mk_attr_id(),\n                                                               allow_dead_code_item);"}, {"sha": "331b0fe5481d5c0d0593626b21dcce8288b241e3", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -47,7 +47,7 @@ impl Ident {\n     }\n \n     pub fn without_first_quote(self) -> Ident {\n-        Ident::new(Symbol::from(self.name.as_str().trim_left_matches('\\'')), self.span)\n+        Ident::new(Symbol::intern(self.name.as_str().trim_left_matches('\\'')), self.span)\n     }\n \n     pub fn modern(self) -> Ident {\n@@ -147,12 +147,6 @@ impl Symbol {\n     }\n }\n \n-impl<'a> From<&'a str> for Symbol {\n-    fn from(string: &'a str) -> Symbol {\n-        Symbol::intern(string)\n-    }\n-}\n-\n impl fmt::Debug for Symbol {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let is_gensymed = with_interner(|interner| interner.is_gensymed(*self));"}, {"sha": "040f0b661be14fab1b21698a682b0e837f29dad7", "filename": "src/test/compile-fail-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -117,7 +117,7 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                ast::Ident::with_empty_ctxt(word.name())\n+                word.ident\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}, {"sha": "2f80408ac1ce98833c65cefe424f84039810e961", "filename": "src/test/run-pass-fulldeps/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a30bad6de92fd00f24b8ba9547798cb1afa1ba3/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fmacro_crate_test.rs?ref=3a30bad6de92fd00f24b8ba9547798cb1afa1ba3", "patch": "@@ -112,7 +112,7 @@ fn expand_duplicate(cx: &mut ExtCtxt,\n     let copy_name = match mi.node {\n         ast::MetaItemKind::List(ref xs) => {\n             if let Some(word) = xs[0].word() {\n-                ast::Ident::with_empty_ctxt(word.name())\n+                word.ident\n             } else {\n                 cx.span_err(mi.span, \"Expected word\");\n                 return;"}]}