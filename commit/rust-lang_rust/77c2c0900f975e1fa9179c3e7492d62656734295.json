{"sha": "77c2c0900f975e1fa9179c3e7492d62656734295", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3YzJjMDkwMGY5NzVlMWZhOTE3OWMzZTc0OTJkNjI2NTY3MzQyOTU=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-17T16:41:04Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:31Z"}, "message": "add renaming and sctable funs", "tree": {"sha": "c15d8875dfb763d945dbef0c8c5da769a99fa9e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c15d8875dfb763d945dbef0c8c5da769a99fa9e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77c2c0900f975e1fa9179c3e7492d62656734295", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77c2c0900f975e1fa9179c3e7492d62656734295", "html_url": "https://github.com/rust-lang/rust/commit/77c2c0900f975e1fa9179c3e7492d62656734295", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77c2c0900f975e1fa9179c3e7492d62656734295/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "38b1d60e0d86bc9b252bb09c1e4cb1ca9f8b2921", "url": "https://api.github.com/repos/rust-lang/rust/commits/38b1d60e0d86bc9b252bb09c1e4cb1ca9f8b2921", "html_url": "https://github.com/rust-lang/rust/commit/38b1d60e0d86bc9b252bb09c1e4cb1ca9f8b2921"}], "stats": {"total": 49, "additions": 48, "deletions": 1}, "files": [{"sha": "6ea1160c267d82c7276cda373f8f284c3f23c349", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/77c2c0900f975e1fa9179c3e7492d62656734295/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77c2c0900f975e1fa9179c3e7492d62656734295/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=77c2c0900f975e1fa9179c3e7492d62656734295", "patch": "@@ -15,10 +15,12 @@ use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n use ast::{SCTable, illegal_ctxt};\n use ast;\n-use ast_util::{new_rename, new_mark, resolve};\n+use ast_util::{new_rename, new_mark, resolve, new_sctable};\n use attr;\n use codemap;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n+use core::cast;\n+use core::local_data;\n use ext::base::*;\n use fold::*;\n use parse;\n@@ -395,6 +397,51 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n     }\n }\n \n+// given a mutable list of renames, return a tree-folder that applies those\n+// renames.\n+fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n+    let table = local_sctable_get();\n+    let afp = default_ast_fold();\n+    let f_pre = @AstFoldFns {\n+        fold_ident: |id,_| {\n+            // the individual elements are memoized... it would\n+            // also be possible to memoize on the whole list at once.\n+            let new_ctxt = renames.foldl(id.ctxt,|ctxt,&(from,to)| {\n+                new_rename(from,to,*ctxt,table)\n+            });\n+            ast::ident{repr:id.repr,ctxt:new_ctxt}\n+        },\n+        .. *afp\n+    };\n+    make_fold(f_pre)\n+}\n+\n+// perform a bunch of renames\n+fn apply_pending_renames(folder : @ast_fold, stmt : ast::stmt) -> @ast::stmt {\n+    match folder.fold_stmt(&stmt) {\n+        Some(s) => s,\n+        None => fail!(fmt!(\"renaming of stmt produced None\"))\n+    }\n+}\n+\n+// fetch the SCTable from TLS, create one if it doesn't yet exist.\n+fn local_sctable_get() -> @mut SCTable {\n+    unsafe {\n+        let sctable_key = (cast::transmute::<(uint, uint),\n+                           &fn(v: @@mut SCTable)>(\n+                               (-4 as uint, 0u)));\n+        match local_data::local_data_get(sctable_key) {\n+            None => {\n+                let new_table = @@mut new_sctable();\n+                local_data::local_data_set(sctable_key,new_table);\n+                *new_table\n+            },\n+            Some(intr) => *intr\n+        }\n+    }\n+}\n+\n+\n pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};"}]}