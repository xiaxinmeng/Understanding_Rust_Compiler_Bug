{"sha": "6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjNmE0N2JmMjIyMTJiYTZhYWExZTA1ODJlNGM3YjhlMmViMzE1ZTM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-17T20:27:08Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-23T05:29:17Z"}, "message": "std: splitting out tcp server API + tests\n\n- we now have two interfaces for the TCP/IP server/listener workflow,\nbased on different user approaches surrounding how to deal with the\nflow of accept a new tcp connection:\n\n1. the \"original\" API closely mimics the low-level libuv API, in that we\nhave an on_connect_cb that the user provides *that is ran on the libuv\nthread*. In this callback, the user can accept() a connection, turning it\ninto a tcp_socket.. of course, before accepting, they have the option\nof passing it to a new task, provided they *make the cb block until\nthe accept is done* .. this is because, in libuv, you have to do the\nuv_accept call in the span of that on_connect_cb callback that gets fired\nwhen a new connection comes in. thems the breaks..\n\nI wanted to just get rid of this API, because the general proposition of\nusers always running code on the libuv thread sounds like an invitation\nfor many future headaches. the API restriction to have to choose to\nimmediately accept a connection (and allow the user to block libuv as\nneeded) isn't too bad for power users who could conceive of circumstances\nwhere they would drop an incoming TCP connection and know what they're\ndoing, in general.\n\nbut as a general API, I thought this was a bit cumbersome, so I ended up\ndevising..\n\n2. an API that is initiated with a call to `net::tcp::new_listener()` ..\nhas a similar signature to `net::tcp::listen()`, except that is just\nreturns an object that sort of behaves like a `comm::port`. Users can\nblock on the `tcp_conn_port` to receive new connections, either in the\ncurrent task or in a new task, depending on which API route they take\n(`net::tcp::conn_recv` or `net::tcp::conn_recv_spawn` respectively).. there\nis also a `net::tcp::conn_peek` function that will do a peek on the\nunderlying port to see if there are pending connections.\n\nThe main difference, with this API, is that the low-level libuv glue is\ngoing to *accept every connection attempt*, along with the overhead that\nthat brings. But, this is a much more hassle-free API for 95% of use\ncases and will probably be the one that most users will want to reach for.", "tree": {"sha": "e20b4bd934c488fe525ffc44d8b55fa827ba27e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e20b4bd934c488fe525ffc44d8b55fa827ba27e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3", "html_url": "https://github.com/rust-lang/rust/commit/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9c6416df6ca16263806116e2e63a7fe03d76935", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c6416df6ca16263806116e2e63a7fe03d76935", "html_url": "https://github.com/rust-lang/rust/commit/e9c6416df6ca16263806116e2e63a7fe03d76935"}], "stats": {"total": 330, "additions": 228, "deletions": 102}, "files": [{"sha": "4ba1eec36e5a6370bd7f4a590216ced4d62b6f1b", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 226, "deletions": 100, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3", "patch": "@@ -12,33 +12,33 @@ export tcp_socket, tcp_conn_port, tcp_err_data;\n // operations on a tcp_socket\n export write, read_start, read_stop;\n // tcp server stuff\n-export new_listener, listen_for_conn, accept;\n+export new_listener, listen_for_conn, accept, conn_recv;\n // tcp client stuff\n export connect;\n-// misc util\n-export is_responding;\n \n #[nolink]\n native mod rustrt {\n-    fn rust_uv_current_kernel_malloc(size: libc::size_t) -> *libc::c_void;\n+    fn rust_uv_current_kernel_malloc(size: libc::c_uint) -> *libc::c_void;\n     fn rust_uv_current_kernel_free(mem: *libc::c_void);\n+    fn rust_uv_helper_uv_tcp_t_size() -> libc::c_uint;\n }\n \n #[doc=\"\n Encapsulates an open TCP/IP connection through libuv\n \n-`tcp_socket` non-sendable and handles automatically closing the underlying libuv data structures when it goes out of scope.\n+`tcp_socket` is non-copyable/sendable and automagically handles closing the\n+underlying libuv data structures when it goes out of scope. This is the\n+data structure that is used for read/write operations over a TCP stream.\n \"]\n-resource tcp_socket(socket_data_wrap: @{data:*mut tcp_socket_data})\n+resource tcp_socket(socket_data: @tcp_socket_data)\n     unsafe {\n     let closed_po = comm::port::<()>();\n     let closed_ch = comm::chan(closed_po);\n     let close_data = {\n         closed_ch: closed_ch\n     };\n-    let socket_data = (*socket_data_wrap).data;\n     let close_data_ptr = ptr::addr_of(close_data);\n-    let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n         log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n             stream_handle_ptr, loop_ptr));\n@@ -48,7 +48,8 @@ resource tcp_socket(socket_data_wrap: @{data:*mut tcp_socket_data})\n     };\n     comm::recv(closed_po);\n     log(debug, #fmt(\"about to free socket_data at %?\", socket_data));\n-    rustrt::rust_uv_current_kernel_free(socket_data as *libc::c_void);\n+    rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                       as *libc::c_void);\n     log(debug, \"exiting dtor for tcp_socket\");\n }\n \n@@ -98,24 +99,24 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n     let conn_data_ptr = ptr::addr_of(conn_data);\n     let hl_loop = uv::global_loop::get();\n     let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n-    let socket_data_ptr = new_socket_data();\n-    *socket_data_ptr = {\n+    let stream_handle_ptr = malloc_uv_tcp_t();\n+    *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n+    let socket_data = @{\n         reader_po: reader_po,\n         reader_ch: comm::chan(reader_po),\n-        stream_handle : uv::ll::tcp_t(),\n+        stream_handle_ptr : stream_handle_ptr,\n         connect_req : uv::ll::connect_t(),\n         write_req : uv::ll::write_t(),\n         hl_loop: hl_loop\n     };\n+    let socket_data_ptr = ptr::addr_of(*socket_data);\n     log(debug, #fmt(\"tcp_connect result_ch %?\", conn_data.result_ch));\n     // get an unsafe representation of our stream_handle_ptr that\n     // we can send into the interact cb to be handled in libuv..\n     log(debug, #fmt(\"stream_handl_ptr outside interact %?\",\n-        ptr::addr_of((*socket_data_ptr).stream_handle)));\n+        stream_handle_ptr));\n     uv::hl::interact(hl_loop) {|loop_ptr|\n         log(debug, \"in interact cb for tcp client connect..\");\n-        let stream_handle_ptr =\n-            ptr::addr_of((*socket_data_ptr).stream_handle);\n         log(debug, #fmt(\"stream_handl_ptr in interact %?\",\n             stream_handle_ptr));\n         alt uv::ll::tcp_init( loop_ptr, stream_handle_ptr) {\n@@ -174,7 +175,7 @@ fn connect(input_ip: ip::ip_addr, port: uint)\n     alt comm::recv(result_po) {\n       conn_success {\n         log(debug, \"tcp::connect - received success on result_po\");\n-        result::ok(tcp_socket(@{data:socket_data_ptr}))\n+        result::ok(tcp_socket(socket_data))\n       }\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n@@ -200,10 +201,10 @@ A `result` object with a `()` value, in the event of success, or a\n \"]\n fn write(sock: tcp_socket, raw_write_data: [[u8]])\n     -> result::result<(), tcp_err_data> unsafe {\n-    let socket_data_ptr = ((**sock).data);\n+    let socket_data_ptr = ptr::addr_of(**sock);\n     let write_req_ptr = ptr::addr_of((*socket_data_ptr).write_req);\n     let stream_handle_ptr =\n-        ptr::addr_of((*socket_data_ptr).stream_handle);\n+        (*socket_data_ptr).stream_handle_ptr;\n     let write_buf_vec = iter::map_to_vec(raw_write_data) {|raw_bytes|\n         uv::ll::buf_init(vec::unsafe::to_ptr(raw_bytes),\n                          vec::len(raw_bytes))\n@@ -254,8 +255,8 @@ on) from until `read_stop` is called, or a `tcp_err_data` record\n fn read_start(sock: tcp_socket)\n     -> result::result<comm::port<\n         result::result<[u8], tcp_err_data>>, tcp_err_data> unsafe {\n-    let socket_data = (**sock).data;\n-    let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n+    let socket_data = ptr::addr_of(**sock);\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n     let start_ch = comm::chan(start_po);\n     log(debug, \"in tcp::read_start before interact loop\");\n@@ -290,8 +291,8 @@ Stop reading from an open TCP connection.\n \"]\n fn read_stop(sock: tcp_socket) ->\n     result::result<(), tcp_err_data> unsafe {\n-    let socket_data = (**sock).data;\n-    let stream_handle_ptr = ptr::addr_of((*socket_data).stream_handle);\n+    let socket_data = ptr::addr_of(**sock);\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n     let stop_po = comm::port::<option<tcp_err_data>>();\n     let stop_ch = comm::chan(stop_po);\n     uv::hl::interact((*socket_data).hl_loop) {|loop_ptr|\n@@ -406,6 +407,58 @@ fn new_listener(host_ip: ip::ip_addr, port: uint, backlog: uint)\n     }\n }\n \n+#[doc=\"\n+Block on a `net::tcp::tcp_conn_port` until a new connection arrives\n+\n+# Arguments\n+\n+* server_port -- a `net::tcp::tcp_conn_port` that you wish to listen\n+on for an incoming connection\n+\n+# Returns\n+\n+A `result` object containing a `net::tcp::tcp_socket`, ready for immediate\n+use, as the `ok` varient, or a `net::tcp::tcp_err_data` for the `err`\n+variant\n+\"]\n+fn conn_recv(server_port: tcp_conn_port)\n+    -> result::result<tcp_socket, tcp_err_data> {\n+    let new_conn_po = (**server_port).new_conn_po;\n+    let hl_loop = (**server_port).hl_loop;\n+    let new_conn_result = comm::recv(new_conn_po);\n+    alt new_conn_result {\n+      ok(client_stream_ptr) {\n+        conn_port_new_tcp_socket(client_stream_ptr, hl_loop)\n+      }\n+      err(err_data) {\n+        result::err(err_data)\n+      }\n+    }\n+}\n+\n+fn conn_recv_spawn(server_port: tcp_conn_port,\n+                   cb: fn~(result::result<tcp_socket, tcp_err_data>)) {\n+    let new_conn_po = (**server_port).new_conn_po;\n+    let hl_loop = (**server_port).hl_loop;\n+    let new_conn_result = comm::recv(new_conn_po);\n+    task::spawn {||\n+        let sock_create_result = alt new_conn_result {\n+          ok(client_stream_ptr) {\n+            conn_port_new_tcp_socket(client_stream_ptr, hl_loop)\n+          }\n+          err(err_data) {\n+            result::err(err_data)\n+          }\n+        };\n+        cb(sock_create_result);\n+    };\n+}\n+\n+fn conn_peek(server_port: tcp_conn_port) -> bool {\n+    let new_conn_po = (**server_port).new_conn_po;\n+    comm::peek(new_conn_po)\n+}\n+\n #[doc=\"\n Bind an incoming client connection to a `net::tcp::tcp_socket`\n \n@@ -477,17 +530,19 @@ fn accept(new_conn: tcp_new_connection)\n             server_handle_ptr) as *tcp_listen_fc_data;\n         let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n         let hl_loop = (*server_data_ptr).hl_loop;\n-        let client_socket_data_ptr = new_socket_data();\n-        *client_socket_data_ptr = {\n+        let stream_handle_ptr = malloc_uv_tcp_t();\n+        *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n+        let client_socket_data = @{\n             reader_po: reader_po,\n             reader_ch: comm::chan(reader_po),\n-            stream_handle : uv::ll::tcp_t(),\n+            stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n             hl_loop: hl_loop\n         };\n-        let client_stream_handle_ptr = ptr::addr_of(\n-            (*client_socket_data_ptr).stream_handle);\n+        let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n+        let client_stream_handle_ptr =\n+            (*client_socket_data_ptr).stream_handle_ptr;\n \n         let result_po = comm::port::<option<tcp_err_data>>();\n         let result_ch = comm::chan(result_po);\n@@ -533,59 +588,13 @@ fn accept(new_conn: tcp_new_connection)\n             result::err(err_data)\n           }\n           none {\n-            result::ok(tcp_socket(@{data: client_socket_data_ptr }))\n+            result::ok(tcp_socket(client_socket_data))\n           }\n         }\n       }\n     }\n }\n \n-#[doc=\"\n-Attempt to open a TCP/IP connection on a remote host\n-\n-The connection will (attempt to) be successfully established and then\n-disconnect immediately. It is useful to determine, simply, if a remote\n-host is responding, and that is all.\n-\n-# Arguments\n-\n-* `remote_ip` - an IP address (versions 4 or 6) for the remote host\n-* `remote_port` - a uint representing the port on the remote host to\n-connect to\n-* `timeout_msecs` - a timeout period, in miliseconds, to wait before\n-aborting the connection attempt\n-\n-# Returns\n-\n-A `bool` indicating success or failure. If a connection was established\n-to the remote host in the alloted timeout, `true` is returned. If the\n-host refused the connection, timed out or had some other error condition,\n-`false` is returned.\n-\"]\n-fn is_responding(remote_ip: ip::ip_addr, remote_port: uint,\n-                timeout_msecs: uint) -> bool {\n-    log(debug, \"entering is_responding\");\n-    let connected_po = comm::port::<bool>();\n-    let connected_ch = comm::chan(connected_po);\n-    task::spawn {||\n-        log(debug, \"in is_responding nested task\");\n-        let connect_result = connect(remote_ip, remote_port);\n-        let connect_succeeded = result::is_success(connect_result);\n-        log(debug, #fmt(\"leaving is_responding nested task .. result %?\",\n-           connect_succeeded));\n-        comm::send(connected_ch, connect_succeeded);\n-    };\n-    log(debug, \"exiting is_responding\");\n-    alt timer::recv_timeout(timeout_msecs, connected_po) {\n-      some(connect_succeeded) {\n-        log(debug, #fmt(\"connect succedded? %?\", connect_succeeded));\n-        connect_succeeded }\n-      none {\n-        log(debug, \"is_responding timed out on waiting to connect\");\n-        false }\n-    }\n-}\n-\n #[doc=\"\n Bind to a given IP/port and listen for new connections\n \n@@ -609,9 +618,9 @@ callback's arguments are:\n \n # returns\n \n-a `result` instance containing empty data of type `()` on a successful\n-or normal shutdown, and a `tcp_err_data` record in the event of listen\n-exiting because of an error\n+a `result` instance containing empty data of type `()` on a\n+successful/normal shutdown, and a `tcp_err_data` record in the event\n+of listen exiting because of an error\n \"]\n fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n           on_establish_cb: fn~(comm::chan<option<tcp_err_data>>),\n@@ -704,7 +713,36 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n     }\n }\n \n-// internal api\n+// INTERNAL API\n+\n+// various recv_* can use a tcp_conn_port can re-use this..\n+fn conn_port_new_tcp_socket(\n+    stream_handle_ptr: *uv::ll::uv_tcp_t,\n+    hl_loop: uv::hl::high_level_loop)\n+    -> result::result<tcp_socket,tcp_err_data> unsafe {\n+    // tcp_nl_on_connection_cb\n+    let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n+    let client_socket_data = @{\n+        reader_po : reader_po,\n+        reader_ch : comm::chan(reader_po),\n+        stream_handle_ptr : stream_handle_ptr,\n+        connect_req : uv::ll::connect_t(),\n+        write_req : uv::ll::write_t(),\n+        hl_loop : hl_loop\n+    };\n+    let client_socket_data_ptr = ptr::addr_of(*client_socket_data);\n+    comm::listen {|cont_ch|\n+        uv::hl::interact(hl_loop) {|loop_ptr|\n+            log(debug, #fmt(\"in interact cb 4 conn_port_new_tcp.. loop %?\",\n+                loop_ptr));\n+            uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                           client_socket_data_ptr);\n+            cont_ch.send(());\n+        };\n+        cont_ch.recv()\n+    };\n+    result::ok(tcp_socket(client_socket_data))\n+}\n \n enum tcp_new_connection {\n     new_tcp_conn(*uv::ll::uv_tcp_t)\n@@ -716,7 +754,7 @@ type tcp_conn_port_data = {\n     stream_closed_ch: comm::chan<()>,\n     hl_loop: uv::hl::high_level_loop,\n     new_conn_po: comm::port<result::result<*uv::ll::uv_tcp_t,\n-                                           tcp_err_data>>,\n+                                            tcp_err_data>>,\n     new_conn_ch: comm::chan<result::result<*uv::ll::uv_tcp_t,\n                                            tcp_err_data>>\n };\n@@ -769,10 +807,9 @@ crust fn tcp_nl_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     comm::send((*conn_data_ptr).stream_closed_ch, ());\n }\n \n-fn new_socket_data() -> *mut tcp_socket_data unsafe {\n+fn malloc_uv_tcp_t() -> *uv::ll::uv_tcp_t unsafe {\n     rustrt::rust_uv_current_kernel_malloc(\n-        sys::size_of::<tcp_socket_data>()) as\n-    *mut tcp_socket_data\n+        rustrt::rust_uv_helper_uv_tcp_t_size()) as *uv::ll::uv_tcp_t\n }\n \n crust fn tcp_nl_on_connection_cb(server_handle_ptr: *uv::ll::uv_tcp_t,\n@@ -783,19 +820,9 @@ crust fn tcp_nl_on_connection_cb(server_handle_ptr: *uv::ll::uv_tcp_t,\n     let loop_ptr = uv::ll::get_loop_for_uv_handle(server_handle_ptr);\n     alt status {\n       0i32 {\n-        let hl_loop = (*server_data_ptr).hl_loop;\n-        let reader_po = comm::port::<result::result<[u8], tcp_err_data>>();\n-        let client_socket_data_ptr = new_socket_data();\n-        *client_socket_data_ptr = {\n-            reader_po: reader_po,\n-            reader_ch: comm::chan(reader_po),\n-            stream_handle : uv::ll::tcp_t(),\n-            connect_req : uv::ll::connect_t(),\n-            write_req : uv::ll::write_t(),\n-            hl_loop: hl_loop\n-        }; \n-        let client_stream_handle_ptr = ptr::addr_of(\n-            (*client_socket_data_ptr).stream_handle);\n+        let client_stream_handle_ptr = malloc_uv_tcp_t();\n+        *(client_stream_handle_ptr as *mut uv::ll::uv_tcp_t) =\n+            uv::ll::tcp_t();\n         alt uv::ll::tcp_init(loop_ptr, client_stream_handle_ptr) {\n           0i32 {\n             log(debug, \"uv_tcp_init successful for client stream\");\n@@ -804,9 +831,6 @@ crust fn tcp_nl_on_connection_cb(server_handle_ptr: *uv::ll::uv_tcp_t,\n                 client_stream_handle_ptr as *libc::c_void) {\n               0i32 {\n                 log(debug, \"successfully accepted client connection\");\n-                uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n-                                               client_socket_data_ptr as\n-                                               *libc::c_void);\n                 comm::send(new_conn_ch,\n                            result::ok(client_stream_handle_ptr));\n               }\n@@ -1002,7 +1026,7 @@ enum conn_attempt {\n type tcp_socket_data = {\n     reader_po: comm::port<result::result<[u8], tcp_err_data>>,\n     reader_ch: comm::chan<result::result<[u8], tcp_err_data>>,\n-    stream_handle: uv::ll::uv_tcp_t,\n+    stream_handle_ptr: *uv::ll::uv_tcp_t,\n     connect_req: uv::ll::uv_connect_t,\n     write_req: uv::ll::uv_write_t,\n     hl_loop: uv::hl::high_level_loop\n@@ -1035,6 +1059,10 @@ mod test {\n             fn test_gl_tcp_server_and_client_ipv4() unsafe {\n                 impl_gl_tcp_ipv4_server_and_client();\n             }\n+            #[test]\n+            fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n+                impl_gl_tcp_ipv4_server_listener_and_client();\n+            }\n         }\n         #[cfg(target_arch=\"x86\")]\n         mod impl32 {\n@@ -1043,6 +1071,11 @@ mod test {\n             fn test_gl_tcp_server_and_client_ipv4() unsafe {\n                 impl_gl_tcp_ipv4_server_and_client();\n             }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n+                impl_gl_tcp_ipv4_server_listener_and_client();\n+            }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_and_client() {\n@@ -1086,6 +1119,47 @@ mod test {\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n+    fn impl_gl_tcp_ipv4_server_listener_and_client() {\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8889u;\n+        let expected_req = \"ping\";\n+        let expected_resp = \"pong\";\n+\n+        let server_result_po = comm::port::<str>();\n+        let server_result_ch = comm::chan(server_result_po);\n+\n+        let cont_po = comm::port::<()>();\n+        let cont_ch = comm::chan(cont_po);\n+        // server\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let actual_req = comm::listen {|server_ch|\n+                run_tcp_test_server_listener(\n+                    server_ip,\n+                    server_port,\n+                    expected_resp,\n+                    server_ch,\n+                    cont_ch)\n+            };\n+            server_result_ch.send(actual_req);\n+        };\n+        comm::recv(cont_po);\n+        // client\n+        log(debug, \"server started, firing up client..\");\n+        let actual_resp = comm::listen {|client_ch|\n+            run_tcp_test_client(\n+                server_ip,\n+                server_port,\n+                expected_req,\n+                client_ch)\n+        };\n+        let actual_req = comm::recv(server_result_po);\n+        log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n+                       expected_req, actual_req));\n+        log(debug, #fmt(\"RESP: expected: '%s' actual: '%s'\",\n+                       expected_resp, actual_resp));\n+        assert str::contains(actual_req, expected_req);\n+        assert str::contains(actual_resp, expected_resp);\n+    }\n \n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n@@ -1161,7 +1235,59 @@ mod test {\n         log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n         ret_val\n     }\n-    \n+\n+    fn run_tcp_test_server_listener(server_ip: str,\n+                                    server_port: uint, resp: str,\n+                                    server_ch: comm::chan<str>,\n+                                    cont_ch: comm::chan<()>) -> str {\n+\n+        task::spawn_sched(task::manual_threads(1u)) {||\n+            let server_ip_addr = ip::v4::parse_addr(server_ip);\n+            let new_listener_result =\n+                new_listener(server_ip_addr, server_port, 128u);\n+            if result::is_failure(new_listener_result) {\n+                let err_data = result::get_err(new_listener_result);\n+                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n+                                err_data.err_name, err_data.err_msg));\n+                fail \"couldn't set up new listener\";\n+            }\n+            let server_port = result::unwrap(new_listener_result);\n+            cont_ch.send(());\n+            // receive a single new connection.. normally this'd be\n+            // in a loop {}, but we're just going to take a single\n+            // client.. get their req, write a resp and then exit\n+            let new_conn_result = conn_recv(server_port);\n+            if result::is_failure(new_conn_result) {\n+                let err_data = result::get_err(new_conn_result);\n+                log(debug, #fmt(\"SERVER: exited abnormally name %s msg %s\",\n+                                err_data.err_name, err_data.err_msg));\n+                fail \"couldn't recv new conn\";\n+            }\n+            else {\n+                let sock = result::unwrap(new_conn_result);\n+                log(debug, \"SERVER: successfully accepted\"+\n+                    \"connection!\");\n+                let received_req_bytes =\n+                    tcp_read_single(sock);\n+                alt received_req_bytes {\n+                  result::ok(data) {\n+                    server_ch.send(\n+                        str::from_bytes(data));\n+                    log(debug, \"SERVER: before write\");\n+                    tcp_write_single(sock, str::bytes(resp));\n+                    log(debug, \"SERVER: after write.. die\");\n+                  }\n+                  result::err(err_data) {\n+                    server_ch.send(\"\");\n+                  }\n+                }\n+            }\n+        };\n+        let ret_val = server_ch.recv();\n+        log(debug, #fmt(\"SERVER: exited and got ret val: '%s'\", ret_val));\n+        ret_val\n+    }\n+\n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n                           client_ch: comm::chan<str>) -> str {\n "}, {"sha": "0ad59a7316170ce982c588b607fbce48b1822664", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=6c6a47bf22212ba6aaa1e0582e4c7b8e2eb315e3", "patch": "@@ -453,10 +453,10 @@ rust_uv_get_kernel_global_chan_ptr() {\n \n extern \"C\" void*\n rust_uv_current_kernel_malloc(size_t size) {\n-\treturn current_kernel_malloc(size, \"rust_uv_current_kernel_malloc\");\n+    return current_kernel_malloc(size, \"rust_uv_current_kernel_malloc\");\n }\n \n extern \"C\" void\n rust_uv_current_kernel_free(void* mem) {\n-\tcurrent_kernel_free(mem);\n+    current_kernel_free(mem);\n }"}]}