{"sha": "2091142f5d91f802b964d54abad414d3df5c2e98", "node_id": "C_kwDOAAsO6NoAKDIwOTExNDJmNWQ5MWY4MDJiOTY0ZDU0YWJhZDQxNGQzZGY1YzJlOTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T18:30:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-19T18:30:13Z"}, "message": "Auto merge of #9258 - Serial-ATA:unused-peekable, r=Alexendoo\n\nAdd [`unused_peekable`] lint\n\nchangelog: Add [`unused_peekable`] lint\ncloses: #854", "tree": {"sha": "23c914826e3e360b54310c2d7dbbe4fde6c3c573", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23c914826e3e360b54310c2d7dbbe4fde6c3c573"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2091142f5d91f802b964d54abad414d3df5c2e98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2091142f5d91f802b964d54abad414d3df5c2e98", "html_url": "https://github.com/rust-lang/rust/commit/2091142f5d91f802b964d54abad414d3df5c2e98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2091142f5d91f802b964d54abad414d3df5c2e98/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a54117ffcb4ac496ebcc53a3b52bf26656775fd", "html_url": "https://github.com/rust-lang/rust/commit/3a54117ffcb4ac496ebcc53a3b52bf26656775fd"}, {"sha": "0efafa4a6e2d96f55584fe77782c289199a560b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0efafa4a6e2d96f55584fe77782c289199a560b1", "html_url": "https://github.com/rust-lang/rust/commit/0efafa4a6e2d96f55584fe77782c289199a560b1"}], "stats": {"total": 445, "additions": 444, "deletions": 1}, "files": [{"sha": "c42a03c04a00f09d073bd7a448f0a13c466207c8", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -4152,6 +4152,7 @@ Released 2018-09-13\n [`unused_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_collect\n [`unused_io_amount`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_io_amount\n [`unused_label`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_label\n+[`unused_peekable`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_peekable\n [`unused_rounding`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_rounding\n [`unused_self`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_self\n [`unused_unit`]: https://rust-lang.github.io/rust-clippy/master/index.html#unused_unit"}, {"sha": "f1cab77672aade1c7465138c79e02bd12d501464", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -339,6 +339,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),\n+    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(unwrap::PANICKING_UNWRAP),\n     LintId::of(unwrap::UNNECESSARY_UNWRAP),"}, {"sha": "55a80b6b9165a95b8adf0b288408b55f06883386", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -575,6 +575,7 @@ store.register_lints(&[\n     unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME,\n     unused_async::UNUSED_ASYNC,\n     unused_io_amount::UNUSED_IO_AMOUNT,\n+    unused_peekable::UNUSED_PEEKABLE,\n     unused_rounding::UNUSED_ROUNDING,\n     unused_self::UNUSED_SELF,\n     unused_unit::UNUSED_UNIT,"}, {"sha": "369d4b4eed697ca0384764bce81b7e7bb783fb65", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -32,5 +32,6 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n     LintId::of(swap_ptr_to_ref::SWAP_PTR_TO_REF),\n+    LintId::of(unused_peekable::UNUSED_PEEKABLE),\n     LintId::of(write::POSITIONAL_NAMED_FORMAT_PARAMETERS),\n ])"}, {"sha": "64c43d9acc44ea3d2e1cf45275e47a442d1cbda3", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -381,6 +381,7 @@ mod unnested_or_patterns;\n mod unsafe_removed_from_name;\n mod unused_async;\n mod unused_io_amount;\n+mod unused_peekable;\n mod unused_rounding;\n mod unused_self;\n mod unused_unit;\n@@ -894,6 +895,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(manual_instant_elapsed::ManualInstantElapsed));\n     store.register_late_pass(|| Box::new(partialeq_to_none::PartialeqToNone));\n     store.register_late_pass(|| Box::new(manual_empty_string_creations::ManualEmptyStringCreations));\n+    store.register_late_pass(|| Box::new(unused_peekable::UnusedPeekable));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n "}, {"sha": "c060d767e2340fe7ad9b6e67aa4c626595e68634", "filename": "clippy_lints/src/unused_peekable.rs", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_lints%2Fsrc%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_peekable.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -0,0 +1,225 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::{match_type, peel_mid_ty_refs_is_mutable};\n+use clippy_utils::{fn_def_id, is_trait_method, path_to_local_id, paths, peel_ref_operators};\n+use rustc_ast::Mutability;\n+use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::lang_items::LangItem;\n+use rustc_hir::{Block, Expr, ExprKind, HirId, Local, Node, PatKind, PathSegment, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the creation of a `peekable` iterator that is never `.peek()`ed\n+    ///\n+    /// ### Why is this bad?\n+    /// Creating a peekable iterator without using any of its methods is likely a mistake,\n+    /// or just a leftover after a refactor.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let collection = vec![1, 2, 3];\n+    /// let iter = collection.iter().peekable();\n+    ///\n+    /// for item in iter {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    ///\n+    /// Use instead:\n+    /// ```rust\n+    /// let collection = vec![1, 2, 3];\n+    /// let iter = collection.iter();\n+    ///\n+    /// for item in iter {\n+    ///     // ...\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.64.0\"]\n+    pub UNUSED_PEEKABLE,\n+    suspicious,\n+    \"creating a peekable iterator without using any of its methods\"\n+}\n+\n+declare_lint_pass!(UnusedPeekable => [UNUSED_PEEKABLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnusedPeekable {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &Block<'tcx>) {\n+        // Don't lint `Peekable`s returned from a block\n+        if let Some(expr) = block.expr\n+            && let Some(ty) = cx.typeck_results().expr_ty_opt(peel_ref_operators(cx, expr))\n+            && match_type(cx, ty, &paths::PEEKABLE)\n+        {\n+            return;\n+        }\n+\n+        for (idx, stmt) in block.stmts.iter().enumerate() {\n+            if !stmt.span.from_expansion()\n+                && let StmtKind::Local(local) = stmt.kind\n+                && let PatKind::Binding(_, binding, ident, _) = local.pat.kind\n+                && let Some(init) = local.init\n+                && !init.span.from_expansion()\n+                && let Some(ty) = cx.typeck_results().expr_ty_opt(init)\n+                && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+                && match_type(cx, ty, &paths::PEEKABLE)\n+            {\n+                let mut vis = PeekableVisitor::new(cx, binding);\n+\n+                if idx + 1 == block.stmts.len() && block.expr.is_none() {\n+                    return;\n+                }\n+\n+                for stmt in &block.stmts[idx..] {\n+                    vis.visit_stmt(stmt);\n+                }\n+\n+                if let Some(expr) = block.expr {\n+                    vis.visit_expr(expr);\n+                }\n+\n+                if !vis.found_peek_call {\n+                    span_lint_and_help(\n+                        cx,\n+                        UNUSED_PEEKABLE,\n+                        ident.span,\n+                        \"`peek` never called on `Peekable` iterator\",\n+                        None,\n+                        \"consider removing the call to `peekable`\"\n+                   );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+struct PeekableVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    expected_hir_id: HirId,\n+    found_peek_call: bool,\n+}\n+\n+impl<'a, 'tcx> PeekableVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, expected_hir_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            expected_hir_id,\n+            found_peek_call: false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'_> for PeekableVisitor<'_, 'tcx> {\n+    fn visit_expr(&mut self, ex: &'_ Expr<'_>) {\n+        if self.found_peek_call {\n+            return;\n+        }\n+\n+        if path_to_local_id(ex, self.expected_hir_id) {\n+            for (_, node) in self.cx.tcx.hir().parent_iter(ex.hir_id) {\n+                match node {\n+                    Node::Expr(expr) => {\n+                        match expr.kind {\n+                            // some_function(peekable)\n+                            //\n+                            // If the Peekable is passed to a function, stop\n+                            ExprKind::Call(_, args) => {\n+                                if let Some(func_did) = fn_def_id(self.cx, expr)\n+                                    && let Ok(into_iter_did) = self\n+                                        .cx\n+                                        .tcx\n+                                        .lang_items()\n+                                        .require(LangItem::IntoIterIntoIter)\n+                                    && func_did == into_iter_did\n+                                {\n+                                    // Probably a for loop desugar, stop searching\n+                                    return;\n+                                }\n+\n+                                if args.iter().any(|arg| {\n+                                    matches!(arg.kind, ExprKind::Path(_)) && arg_is_mut_peekable(self.cx, arg)\n+                                }) {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+                            },\n+                            // Catch anything taking a Peekable mutably\n+                            ExprKind::MethodCall(\n+                                PathSegment {\n+                                    ident: method_name_ident,\n+                                    ..\n+                                },\n+                                [self_arg, remaining_args @ ..],\n+                                _,\n+                            ) => {\n+                                let method_name = method_name_ident.name.as_str();\n+\n+                                // `Peekable` methods\n+                                if matches!(method_name, \"peek\" | \"peek_mut\" | \"next_if\" | \"next_if_eq\")\n+                                    && arg_is_mut_peekable(self.cx, self_arg)\n+                                {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+\n+                                // foo.some_method() excluding Iterator methods\n+                                if remaining_args.iter().any(|arg| arg_is_mut_peekable(self.cx, arg))\n+                                    && !is_trait_method(self.cx, expr, sym::Iterator)\n+                                {\n+                                    self.found_peek_call = true;\n+                                    return;\n+                                }\n+\n+                                // foo.by_ref(), keep checking for `peek`\n+                                if method_name == \"by_ref\" {\n+                                    continue;\n+                                }\n+\n+                                return;\n+                            },\n+                            ExprKind::AddrOf(_, Mutability::Mut, _) | ExprKind::Unary(..) | ExprKind::DropTemps(_) => {\n+                            },\n+                            ExprKind::AddrOf(_, Mutability::Not, _) => return,\n+                            _ => {\n+                                self.found_peek_call = true;\n+                                return;\n+                            },\n+                        }\n+                    },\n+                    Node::Local(Local { init: Some(init), .. }) => {\n+                        if arg_is_mut_peekable(self.cx, init) {\n+                            self.found_peek_call = true;\n+                            return;\n+                        }\n+\n+                        break;\n+                    },\n+                    Node::Stmt(stmt) => match stmt.kind {\n+                        StmtKind::Expr(_) | StmtKind::Semi(_) => {},\n+                        _ => {\n+                            self.found_peek_call = true;\n+                            return;\n+                        },\n+                    },\n+                    Node::Block(_) => {},\n+                    _ => {\n+                        break;\n+                    },\n+                }\n+            }\n+        }\n+\n+        walk_expr(self, ex);\n+    }\n+}\n+\n+fn arg_is_mut_peekable(cx: &LateContext<'_>, arg: &Expr<'_>) -> bool {\n+    if let Some(ty) = cx.typeck_results().expr_ty_opt(arg)\n+        && let (ty, _, Mutability::Mut) = peel_mid_ty_refs_is_mutable(ty)\n+        && match_type(cx, ty, &paths::PEEKABLE)\n+    {\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "fb0d34e02eece6b1d67c0ff67f498c36ee137d74", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -95,6 +95,7 @@ pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwL\n pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n+pub const PEEKABLE: [&str; 5] = [\"core\", \"iter\", \"adapters\", \"peekable\", \"Peekable\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];\n #[cfg_attr(not(unix), allow(clippy::invalid_paths))]\n pub const PERMISSIONS_FROM_MODE: [&str; 6] = [\"std\", \"os\", \"unix\", \"fs\", \"PermissionsExt\", \"from_mode\"];"}, {"sha": "edbe9c5a8970ebb2bb0d0a982ff1e5c6c90a714a", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -410,7 +410,7 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     peel(ty, 0)\n }\n \n-/// Peels off all references on the type.Returns the underlying type, the number of references\n+/// Peels off all references on the type. Returns the underlying type, the number of references\n /// removed, and whether the pointer is ultimately mutable or not.\n pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n     fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {"}, {"sha": "153457e367165c6ce2fa6d3370a4c81a2645d265", "filename": "tests/ui/unused_peekable.rs", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/tests%2Fui%2Funused_peekable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/tests%2Fui%2Funused_peekable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_peekable.rs?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -0,0 +1,144 @@\n+#![warn(clippy::unused_peekable)]\n+#![allow(clippy::no_effect)]\n+\n+use std::iter::Empty;\n+use std::iter::Peekable;\n+\n+fn main() {\n+    invalid();\n+    valid();\n+}\n+\n+#[allow(clippy::unused_unit)]\n+fn invalid() {\n+    let peekable = std::iter::empty::<u32>().peekable();\n+\n+    // Only lint `new_local`\n+    let old_local = std::iter::empty::<u32>().peekable();\n+    let new_local = old_local;\n+\n+    // Behind mut ref\n+    let mut by_mut_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_mut_ref = &mut by_mut_ref_test;\n+\n+    // Explicitly returns `Peekable`\n+    fn returns_peekable() -> Peekable<Empty<u32>> {\n+        std::iter::empty().peekable()\n+    }\n+\n+    let peekable_from_fn = returns_peekable();\n+\n+    // Using a method not exclusive to `Peekable`\n+    let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n+    peekable_using_iterator_method.next();\n+\n+    // Passed by ref to another function\n+    fn takes_ref(_peek: &Peekable<Empty<u32>>) {}\n+    let passed_along_ref = std::iter::empty::<u32>().peekable();\n+    takes_ref(&passed_along_ref);\n+\n+    // `by_ref` without `peek`\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let _by_ref = by_ref_test.by_ref();\n+\n+    let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n+    for x in peekable_in_for_loop {}\n+}\n+\n+fn valid() {\n+    fn takes_peekable(_peek: Peekable<Empty<u32>>) {}\n+\n+    // Passed to another function\n+    let passed_along = std::iter::empty::<u32>().peekable();\n+    takes_peekable(passed_along);\n+\n+    // Passed to another method\n+    struct PeekableConsumer;\n+    impl PeekableConsumer {\n+        fn consume(&self, _: Peekable<Empty<u32>>) {}\n+        fn consume_mut_ref(&self, _: &mut Peekable<Empty<u32>>) {}\n+    }\n+\n+    let peekable_consumer = PeekableConsumer;\n+    let mut passed_along_to_method = std::iter::empty::<u32>().peekable();\n+    peekable_consumer.consume_mut_ref(&mut passed_along_to_method);\n+    peekable_consumer.consume(passed_along_to_method);\n+\n+    // `peek` called in another block\n+    let mut peekable_in_block = std::iter::empty::<u32>().peekable();\n+    {\n+        peekable_in_block.peek();\n+    }\n+\n+    // Check the other `Peekable` methods :)\n+    {\n+        let mut peekable_with_peek_mut = std::iter::empty::<u32>().peekable();\n+        peekable_with_peek_mut.peek_mut();\n+\n+        let mut peekable_with_next_if = std::iter::empty::<u32>().peekable();\n+        peekable_with_next_if.next_if(|_| true);\n+\n+        let mut peekable_with_next_if_eq = std::iter::empty::<u32>().peekable();\n+        peekable_with_next_if_eq.next_if_eq(&3);\n+    }\n+\n+    let mut peekable_in_closure = std::iter::empty::<u32>().peekable();\n+    let call_peek = |p: &mut Peekable<Empty<u32>>| {\n+        p.peek();\n+    };\n+    call_peek(&mut peekable_in_closure);\n+\n+    // From a macro\n+    macro_rules! make_me_a_peekable_please {\n+        () => {\n+            std::iter::empty::<u32>().peekable()\n+        };\n+    }\n+\n+    let _unsuspecting_macro_user = make_me_a_peekable_please!();\n+\n+    // Generic Iterator returned\n+    fn return_an_iter() -> impl Iterator<Item = u32> {\n+        std::iter::empty::<u32>().peekable()\n+    }\n+\n+    let _unsuspecting_user = return_an_iter();\n+\n+    // Call `peek` in a macro\n+    macro_rules! peek_iter {\n+        ($iter:ident) => {\n+            $iter.peek();\n+        };\n+    }\n+\n+    let mut peek_in_macro = std::iter::empty::<u32>().peekable();\n+    peek_iter!(peek_in_macro);\n+\n+    // Behind mut ref\n+    let mut by_mut_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_mut_ref = &mut by_mut_ref_test;\n+    by_mut_ref.peek();\n+\n+    // Behind ref\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let by_ref = &by_ref_test;\n+    by_ref_test.peek();\n+\n+    // In struct\n+    struct PeekableWrapper {\n+        f: Peekable<Empty<u32>>,\n+    }\n+\n+    let struct_test = std::iter::empty::<u32>().peekable();\n+    PeekableWrapper { f: struct_test };\n+\n+    // `by_ref` before `peek`\n+    let mut by_ref_test = std::iter::empty::<u32>().peekable();\n+    let peeked_val = by_ref_test.by_ref().peek();\n+\n+    // `peek` called in another block as the last expression\n+    let mut peekable_last_expr = std::iter::empty::<u32>().peekable();\n+    {\n+        peekable_last_expr.peek();\n+    }\n+}"}, {"sha": "d557f54179dbaf680ccf899b14e9e3b242393935", "filename": "tests/ui/unused_peekable.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2091142f5d91f802b964d54abad414d3df5c2e98/tests%2Fui%2Funused_peekable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2091142f5d91f802b964d54abad414d3df5c2e98/tests%2Fui%2Funused_peekable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funused_peekable.stderr?ref=2091142f5d91f802b964d54abad414d3df5c2e98", "patch": "@@ -0,0 +1,67 @@\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:14:9\n+   |\n+LL |     let peekable = std::iter::empty::<u32>().peekable();\n+   |         ^^^^^^^^\n+   |\n+   = note: `-D clippy::unused-peekable` implied by `-D warnings`\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:18:9\n+   |\n+LL |     let new_local = old_local;\n+   |         ^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:22:9\n+   |\n+LL |     let by_mut_ref = &mut by_mut_ref_test;\n+   |         ^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:29:9\n+   |\n+LL |     let peekable_from_fn = returns_peekable();\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:32:13\n+   |\n+LL |     let mut peekable_using_iterator_method = std::iter::empty::<u32>().peekable();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:37:9\n+   |\n+LL |     let passed_along_ref = std::iter::empty::<u32>().peekable();\n+   |         ^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:42:9\n+   |\n+LL |     let _by_ref = by_ref_test.by_ref();\n+   |         ^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: `peek` never called on `Peekable` iterator\n+  --> $DIR/unused_peekable.rs:44:13\n+   |\n+LL |     let mut peekable_in_for_loop = std::iter::empty::<u32>().peekable();\n+   |             ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider removing the call to `peekable`\n+\n+error: aborting due to 8 previous errors\n+"}]}