{"sha": "4de3c97b2afea55834cd16368f950133459d8c73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkZTNjOTdiMmFmZWE1NTgzNGNkMTYzNjhmOTUwMTMzNDU5ZDhjNzM=", "commit": {"author": {"name": "Christopher Durham", "email": "cad97@cad97.com", "date": "2018-01-27T23:31:23Z"}, "committer": {"name": "Christopher Durham", "email": "cad97@cad97.com", "date": "2018-01-27T23:31:23Z"}, "message": "Enforce rustfmt format", "tree": {"sha": "9091b5dc1b116e5cbb47a535ffa922e66776c800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9091b5dc1b116e5cbb47a535ffa922e66776c800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4de3c97b2afea55834cd16368f950133459d8c73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4de3c97b2afea55834cd16368f950133459d8c73", "html_url": "https://github.com/rust-lang/rust/commit/4de3c97b2afea55834cd16368f950133459d8c73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4de3c97b2afea55834cd16368f950133459d8c73/comments", "author": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CAD97", "id": 5992217, "node_id": "MDQ6VXNlcjU5OTIyMTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5992217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CAD97", "html_url": "https://github.com/CAD97", "followers_url": "https://api.github.com/users/CAD97/followers", "following_url": "https://api.github.com/users/CAD97/following{/other_user}", "gists_url": "https://api.github.com/users/CAD97/gists{/gist_id}", "starred_url": "https://api.github.com/users/CAD97/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CAD97/subscriptions", "organizations_url": "https://api.github.com/users/CAD97/orgs", "repos_url": "https://api.github.com/users/CAD97/repos", "events_url": "https://api.github.com/users/CAD97/events{/privacy}", "received_events_url": "https://api.github.com/users/CAD97/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "357cd3358167daa38f3ff34d225e1501faff6015", "url": "https://api.github.com/repos/rust-lang/rust/commits/357cd3358167daa38f3ff34d225e1501faff6015", "html_url": "https://github.com/rust-lang/rust/commit/357cd3358167daa38f3ff34d225e1501faff6015"}], "stats": {"total": 536, "additions": 280, "deletions": 256}, "files": [{"sha": "afca18deaa4947aa81fd01bc866bbd3e034caf1e", "filename": ".travis.yml", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,3 +1,14 @@\n language: rust\n rust:\n   - stable\n+\n+matrix:\n+  include:\n+    - rust: nightly-2018-01-26\n+      before_script:\n+        - rustup component add rustfmt-preview\n+      script:\n+        - cargo fmt -- --write-mode=diff\n+\n+script:\n+  - cargo test"}, {"sha": "e5caa5d122fb96aece9d8a14f33edeac75009472", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -13,4 +13,4 @@ file = \"1.1.1\"\n ron = \"0.1.5\"\n \n [dev-dependencies]\n-testutils = { path = \"./tests/testutils\" }\n\\ No newline at end of file\n+testutils = { path = \"./tests/testutils\" }"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "rustfmt.toml", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=4de3c97b2afea55834cd16368f950133459d8c73"}, {"sha": "8f6402f5c997286f006bfabc71121cb28c191c91", "filename": "src/bin/gen.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fbin%2Fgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fbin%2Fgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fgen.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -2,8 +2,8 @@ extern crate serde;\n #[macro_use]\n extern crate serde_derive;\n \n-extern crate ron;\n extern crate file;\n+extern crate ron;\n \n use std::path::PathBuf;\n use std::fmt::Write;\n@@ -33,11 +33,12 @@ impl Grammar {\n         acc.push_str(\"use tree::{SyntaxKind, SyntaxInfo};\\n\");\n         acc.push_str(\"\\n\");\n \n-        let syntax_kinds: Vec<String> =\n-            self.keywords.iter().map(|kw| kw_token(kw))\n-                .chain(self.tokens.iter().cloned())\n-                .chain(self.nodes.iter().cloned())\n-                .collect();\n+        let syntax_kinds: Vec<String> = self.keywords\n+            .iter()\n+            .map(|kw| kw_token(kw))\n+            .chain(self.tokens.iter().cloned())\n+            .chain(self.nodes.iter().cloned())\n+            .collect();\n \n         for (idx, kind) in syntax_kinds.iter().enumerate() {\n             let sname = scream(kind);\n@@ -48,7 +49,11 @@ impl Grammar {\n             ).unwrap();\n         }\n         acc.push_str(\"\\n\");\n-        write!(acc, \"static INFOS: [SyntaxInfo; {}] = [\\n\", syntax_kinds.len()).unwrap();\n+        write!(\n+            acc,\n+            \"static INFOS: [SyntaxInfo; {}] = [\\n\",\n+            syntax_kinds.len()\n+        ).unwrap();\n         for kind in syntax_kinds.iter() {\n             let sname = scream(kind);\n             write!(\n@@ -91,4 +96,4 @@ fn scream(word: &str) -> String {\n \n fn kw_token(keyword: &str) -> String {\n     format!(\"{}_KW\", scream(keyword))\n-}\n\\ No newline at end of file\n+}"}, {"sha": "af1325bfcae3d5bbf7314f13c221586f0243cd87", "filename": "src/bin/parse-rust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fbin%2Fparse-rust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fbin%2Fparse-rust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fparse-rust.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -2,7 +2,7 @@ extern crate libsyntax2;\n \n use std::io::Read;\n \n-use libsyntax2::{tokenize, parse};\n+use libsyntax2::{parse, tokenize};\n use libsyntax2::utils::dump_tree;\n \n fn main() {"}, {"sha": "7fed008af2b7453ae447b14d96e2ad7b0c51a5a6", "filename": "src/lexer/classes.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fclasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fclasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fclasses.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,17 +1,12 @@\n use unicode_xid::UnicodeXID;\n \n pub fn is_ident_start(c: char) -> bool {\n-    (c >= 'a' && c <= 'z')\n-        || (c >= 'A' && c <= 'Z')\n-        || c == '_'\n+    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '_'\n         || (c > '\\x7f' && UnicodeXID::is_xid_start(c))\n }\n \n pub fn is_ident_continue(c: char) -> bool {\n-    (c >= 'a' && c <= 'z')\n-        || (c >= 'A' && c <= 'Z')\n-        || (c >= '0' && c <= '9')\n-        || c == '_'\n+    (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_'\n         || (c > '\\x7f' && UnicodeXID::is_xid_continue(c))\n }\n "}, {"sha": "b70f2c6c677bce4928ce2e756279bb89f03d174e", "filename": "src/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fcomments.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,6 +1,6 @@\n use lexer::ptr::Ptr;\n \n-use {SyntaxKind};\n+use SyntaxKind;\n use syntax_kinds::*;\n \n pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n@@ -23,7 +23,6 @@ pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n     }\n }\n \n-\n fn bump_until_eol(ptr: &mut Ptr) {\n     loop {\n         if ptr.next_is('\\n') || ptr.next_is('\\r') && ptr.nnext_is('\\n') {\n@@ -33,4 +32,4 @@ fn bump_until_eol(ptr: &mut Ptr) {\n             break;\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "f62dfc5071340cf06ed8202b5c1223a6b20309f7", "filename": "src/lexer/mod.rs", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fmod.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,4 +1,4 @@\n-use {Token, SyntaxKind};\n+use {SyntaxKind, Token};\n use syntax_kinds::*;\n \n mod ptr;\n@@ -11,10 +11,11 @@ mod numbers;\n use self::numbers::scan_number;\n \n mod strings;\n-use self::strings::{is_string_literal_start, scan_char, scan_byte_char_or_string, scan_string, scan_raw_string};\n+use self::strings::{is_string_literal_start, scan_byte_char_or_string, scan_char, scan_raw_string,\n+                    scan_string};\n \n mod comments;\n-use self::comments::{scan_shebang, scan_comment};\n+use self::comments::{scan_comment, scan_shebang};\n \n pub fn tokenize(text: &str) -> Vec<Token> {\n     let mut text = text;\n@@ -45,10 +46,10 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     match c {\n         '#' => if scan_shebang(ptr) {\n             return SHEBANG;\n-        }\n+        },\n         '/' => if let Some(kind) = scan_comment(ptr) {\n             return kind;\n-        }\n+        },\n         _ => (),\n     }\n \n@@ -89,79 +90,91 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         '%' => return PERCENT,\n \n         // Multi-byte tokens.\n-        '.' => return match (ptr.next(), ptr.nnext()) {\n-            (Some('.'), Some('.')) => {\n-                ptr.bump();\n-                ptr.bump();\n-                DOTDOTDOT\n-            },\n-            (Some('.'), Some('=')) => {\n-                ptr.bump();\n-                ptr.bump();\n-                DOTDOTEQ\n-            },\n-            (Some('.'), _) => {\n-                ptr.bump();\n-                DOTDOT\n-            },\n-            _ => DOT\n-        },\n-        ':' => return match ptr.next() {\n-            Some(':') => {\n-                ptr.bump();\n-                COLONCOLON\n+        '.' => {\n+            return match (ptr.next(), ptr.nnext()) {\n+                (Some('.'), Some('.')) => {\n+                    ptr.bump();\n+                    ptr.bump();\n+                    DOTDOTDOT\n+                }\n+                (Some('.'), Some('=')) => {\n+                    ptr.bump();\n+                    ptr.bump();\n+                    DOTDOTEQ\n+                }\n+                (Some('.'), _) => {\n+                    ptr.bump();\n+                    DOTDOT\n+                }\n+                _ => DOT,\n             }\n-            _ => COLON\n-        },\n-        '=' => return match ptr.next() {\n-            Some('=') => {\n-                ptr.bump();\n-                EQEQ\n+        }\n+        ':' => {\n+            return match ptr.next() {\n+                Some(':') => {\n+                    ptr.bump();\n+                    COLONCOLON\n+                }\n+                _ => COLON,\n             }\n-            Some('>') => {\n-                ptr.bump();\n-                FAT_ARROW\n+        }\n+        '=' => {\n+            return match ptr.next() {\n+                Some('=') => {\n+                    ptr.bump();\n+                    EQEQ\n+                }\n+                Some('>') => {\n+                    ptr.bump();\n+                    FAT_ARROW\n+                }\n+                _ => EQ,\n             }\n-            _ => EQ,\n-        },\n-        '!' => return match ptr.next() {\n-            Some('=') => {\n+        }\n+        '!' => {\n+            return match ptr.next() {\n+                Some('=') => {\n+                    ptr.bump();\n+                    NEQ\n+                }\n+                _ => EXCL,\n+            }\n+        }\n+        '-' => {\n+            return if ptr.next_is('>') {\n                 ptr.bump();\n-                NEQ\n+                THIN_ARROW\n+            } else {\n+                MINUS\n             }\n-            _ => EXCL,\n-        },\n-        '-' => return if ptr.next_is('>') {\n-            ptr.bump();\n-            THIN_ARROW\n-        } else {\n-            MINUS\n-        },\n+        }\n \n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n-        '\\'' => return if ptr.next_is_p(is_ident_start) && !ptr.nnext_is('\\'') {\n-            ptr.bump();\n-            while ptr.next_is_p(is_ident_continue) {\n+        '\\'' => {\n+            return if ptr.next_is_p(is_ident_start) && !ptr.nnext_is('\\'') {\n                 ptr.bump();\n+                while ptr.next_is_p(is_ident_continue) {\n+                    ptr.bump();\n+                }\n+                // lifetimes shouldn't end with a single quote\n+                // if we find one, then this is an invalid character literal\n+                if ptr.next_is('\\'') {\n+                    ptr.bump();\n+                    return CHAR; // TODO: error reporting\n+                }\n+                LIFETIME\n+            } else {\n+                scan_char(ptr);\n+                scan_literal_suffix(ptr);\n+                CHAR\n             }\n-            // lifetimes shouldn't end with a single quote\n-            // if we find one, then this is an invalid character literal\n-            if ptr.next_is('\\'') {\n-                ptr.bump();\n-                return CHAR; // TODO: error reporting\n-            }\n-            LIFETIME\n-        } else {\n-            scan_char(ptr);\n-            scan_literal_suffix(ptr);\n-            CHAR\n-        },\n+        }\n         'b' => {\n             let kind = scan_byte_char_or_string(ptr);\n             scan_literal_suffix(ptr);\n-            return kind\n-        },\n+            return kind;\n+        }\n         '\"' => {\n             scan_string(ptr);\n             scan_literal_suffix(ptr);"}, {"sha": "95e42246fe412f0d2a683a3913901cdb77180e07", "filename": "src/lexer/numbers.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fnumbers.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,7 +1,7 @@\n use lexer::ptr::Ptr;\n use lexer::classes::*;\n \n-use {SyntaxKind};\n+use SyntaxKind;\n use syntax_kinds::*;\n \n pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n@@ -49,10 +49,10 @@ fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n             '_' | '0'...'9' => {\n                 ptr.bump();\n             }\n-            'a'...'f' | 'A' ... 'F' if allow_hex => {\n+            'a'...'f' | 'A'...'F' if allow_hex => {\n                 ptr.bump();\n             }\n-            _ => return\n+            _ => return,\n         }\n     }\n }"}, {"sha": "99d55b283c5fe772e9559b7830d453a5935259d4", "filename": "src/lexer/ptr.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fptr.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,4 +1,4 @@\n-use {TextUnit};\n+use TextUnit;\n \n use std::str::Chars;\n \n@@ -9,7 +9,10 @@ pub(crate) struct Ptr<'s> {\n \n impl<'s> Ptr<'s> {\n     pub fn new(text: &'s str) -> Ptr<'s> {\n-        Ptr { text, len: TextUnit::new(0) }\n+        Ptr {\n+            text,\n+            len: TextUnit::new(0),\n+        }\n     }\n \n     pub fn into_len(self) -> TextUnit {\n@@ -53,7 +56,7 @@ impl<'s> Ptr<'s> {\n             match self.next() {\n                 Some(c) if pred(c) => {\n                     self.bump();\n-                },\n+                }\n                 _ => return,\n             }\n         }\n@@ -66,6 +69,6 @@ impl<'s> Ptr<'s> {\n \n     fn chars(&self) -> Chars {\n         let len: u32 = self.len.into();\n-        self.text[len as usize ..].chars()\n+        self.text[len as usize..].chars()\n     }\n }"}, {"sha": "00a84ec858c9d8159eee3e4489369fcad145258e", "filename": "src/lexer/strings.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flexer%2Fstrings.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,17 +1,17 @@\n-use {SyntaxKind};\n+use SyntaxKind;\n use syntax_kinds::*;\n \n use lexer::ptr::Ptr;\n \n pub(crate) fn is_string_literal_start(c: char, c1: Option<char>, c2: Option<char>) -> bool {\n     match (c, c1, c2) {\n-        ('r', Some('\"'), _) |\n-        ('r', Some('#'), _) |\n-        ('b', Some('\"'), _) |\n-        ('b', Some('\\''), _) |\n-        ('b', Some('r'), Some('\"')) |\n-        ('b', Some('r'), Some('#')) => true,\n-        _ => false\n+        ('r', Some('\"'), _)\n+        | ('r', Some('#'), _)\n+        | ('b', Some('\"'), _)\n+        | ('b', Some('\\''), _)\n+        | ('b', Some('r'), Some('\"'))\n+        | ('b', Some('r'), Some('#')) => true,\n+        _ => false,\n     }\n }\n \n@@ -50,53 +50,53 @@ pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n pub(crate) fn scan_string(ptr: &mut Ptr) {\n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n-            return\n+            return;\n         }\n     }\n }\n \n pub(crate) fn scan_raw_string(ptr: &mut Ptr) {\n     if !ptr.next_is('\"') {\n-        return\n+        return;\n     }\n     ptr.bump();\n \n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n-            return\n+            return;\n         }\n     }\n }\n \n fn scan_byte(ptr: &mut Ptr) {\n     if ptr.next_is('\\'') {\n         ptr.bump();\n-        return\n+        return;\n     }\n     ptr.bump();\n     if ptr.next_is('\\'') {\n         ptr.bump();\n-        return\n+        return;\n     }\n }\n \n fn scan_byte_string(ptr: &mut Ptr) {\n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n-            return\n+            return;\n         }\n     }\n }\n \n fn scan_raw_byte_string(ptr: &mut Ptr) {\n     if !ptr.next_is('\"') {\n-        return\n+        return;\n     }\n     ptr.bump();\n \n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n-            return\n+            return;\n         }\n     }\n }\n@@ -105,4 +105,3 @@ fn scan_char_or_byte(ptr: &mut Ptr) {\n     //FIXME: deal with escape sequencies\n     ptr.bump();\n }\n-"}, {"sha": "39b01a1cb38afb9a356fc292d528bc9ca9bbc15e", "filename": "src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -5,9 +5,10 @@ mod tree;\n mod lexer;\n mod parser;\n \n+#[cfg_attr(rustfmt, rustfmt_skip)]\n pub mod syntax_kinds;\n-pub use text::{TextUnit, TextRange};\n-pub use tree::{SyntaxKind, Token, FileBuilder, Sink, File, Node};\n+pub use text::{TextRange, TextUnit};\n+pub use tree::{File, FileBuilder, Node, Sink, SyntaxKind, Token};\n pub use lexer::{next_token, tokenize};\n pub use parser::parse;\n \n@@ -25,7 +26,8 @@ pub mod utils {\n             buff.push_str(&String::from(\"  \").repeat(level));\n             write!(buff, \"{:?}\\n\", node).unwrap();\n             let my_errors = node.errors().filter(|e| e.after_child().is_none());\n-            let parent_errors = node.parent().into_iter()\n+            let parent_errors = node.parent()\n+                .into_iter()\n                 .flat_map(|n| n.errors())\n                 .filter(|e| e.after_child() == Some(node));\n "}, {"sha": "8bf04afced1ce7df454bcf97dce6409c4d0a8559", "filename": "src/parser/event_parser/grammar/attributes.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fattributes.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -12,8 +12,7 @@ pub(super) fn outer_attributes(p: &mut Parser) {\n     }\n }\n \n-\n-fn attribute(p: &mut Parser, inner: bool){\n+fn attribute(p: &mut Parser, inner: bool) {\n     let attr = p.start();\n     assert!(p.at(POUND));\n     p.bump();\n@@ -38,19 +37,15 @@ fn meta_item(p: &mut Parser) {\n             EQ => {\n                 p.bump();\n                 if !expressions::literal(p) {\n-                    p.error()\n-                        .message(\"expected literal\")\n-                        .emit();\n+                    p.error().message(\"expected literal\").emit();\n                 }\n             }\n             L_PAREN => meta_item_arg_list(p),\n             _ => (),\n         }\n         meta_item.complete(p, META_ITEM);\n     } else {\n-        p.error()\n-            .message(\"expected attribute value\")\n-            .emit()\n+        p.error().message(\"expected attribute value\").emit()\n     }\n }\n \n@@ -73,8 +68,8 @@ fn meta_item_arg_list(p: &mut Parser) {\n                 p.error().message(message).emit();\n                 p.bump();\n                 err.complete(p, ERROR);\n-                continue\n-            }\n+                continue;\n+            },\n         }\n         if !p.at(R_PAREN) {\n             p.expect(COMMA);"}, {"sha": "c81dc6c35fe2417b30f0053107421c84b17d464e", "filename": "src/parser/event_parser/grammar/expressions.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fexpressions.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -2,15 +2,13 @@ use super::*;\n \n pub(super) fn literal(p: &mut Parser) -> bool {\n     match p.current() {\n-        TRUE_KW | FALSE_KW |\n-        INT_NUMBER | FLOAT_NUMBER |\n-        BYTE | CHAR |\n-        STRING | RAW_STRING | BYTE_STRING | RAW_BYTE_STRING => {\n+        TRUE_KW | FALSE_KW | INT_NUMBER | FLOAT_NUMBER | BYTE | CHAR | STRING | RAW_STRING\n+        | BYTE_STRING | RAW_BYTE_STRING => {\n             let lit = p.start();\n             p.bump();\n             lit.complete(p, LITERAL);\n             true\n         }\n-        _ => false\n+        _ => false,\n     }\n }"}, {"sha": "e569e50479352bb6b3848ede7a520f8461b30800", "filename": "src/parser/event_parser/grammar/items.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -7,15 +7,8 @@ pub(super) fn mod_contents(p: &mut Parser) {\n     }\n }\n \n-pub(super) const ITEM_FIRST: TokenSet = token_set![\n-    EXTERN_KW,\n-    MOD_KW,\n-    USE_KW,\n-    STRUCT_KW,\n-    FN_KW,\n-    PUB_KW,\n-    POUND,\n-];\n+pub(super) const ITEM_FIRST: TokenSet =\n+    token_set![EXTERN_KW, MOD_KW, USE_KW, STRUCT_KW, FN_KW, PUB_KW, POUND,];\n \n fn item(p: &mut Parser) {\n     let item = p.start();\n@@ -48,7 +41,7 @@ fn item(p: &mut Parser) {\n             let message = if err_token == SEMI {\n                 //TODO: if the item is incomplete, this message is misleading\n                 \"expected item, found `;`\\n\\\n-                consider removing this semicolon\"\n+                 consider removing this semicolon\"\n             } else {\n                 \"expected item\"\n             };\n@@ -76,10 +69,9 @@ fn struct_item(p: &mut Parser) {\n                     return;\n                 }\n                 L_CURLY => named_fields(p),\n-                _ => { //TODO: special case `(` error message\n-                    p.error()\n-                        .message(\"expected `;` or `{`\")\n-                        .emit();\n+                _ => {\n+                    //TODO: special case `(` error message\n+                    p.error().message(\"expected `;` or `{`\").emit();\n                     return;\n                 }\n             }\n@@ -94,9 +86,7 @@ fn struct_item(p: &mut Parser) {\n             p.expect(SEMI);\n         }\n         _ => {\n-            p.error()\n-                .message(\"expected `;`, `{`, or `(`\")\n-                .emit();\n+            p.error().message(\"expected `;`, `{`, or `(`\").emit();\n             return;\n         }\n     }\n@@ -177,7 +167,7 @@ fn use_item(p: &mut Parser) {\n     use_tree(p);\n     p.expect(SEMI);\n \n-    fn use_tree(p: &mut Parser){\n+    fn use_tree(p: &mut Parser) {\n         let la = p.raw_lookahead(1);\n         let m = p.start();\n         match (p.current(), la) {\n@@ -209,9 +199,7 @@ fn use_item(p: &mut Parser) {\n                             L_CURLY => nested_trees(p),\n                             _ => {\n                                 // is this unreachable?\n-                                p.error()\n-                                    .message(\"expected `{` or `*`\")\n-                                    .emit();\n+                                p.error().message(\"expected `{` or `*`\").emit();\n                             }\n                         }\n                     }\n@@ -222,7 +210,7 @@ fn use_item(p: &mut Parser) {\n                 m.abandon(p);\n                 p.err_and_bump(\"expected one of `*`, `::`, `{`, `self`, `super`, `indent`\");\n                 return;\n-            },\n+            }\n         }\n         m.complete(p, USE_TREE);\n     }\n@@ -240,13 +228,9 @@ fn use_item(p: &mut Parser) {\n     }\n }\n \n-\n fn fn_item(p: &mut Parser) {\n     assert!(p.at(FN_KW));\n     p.bump();\n \n-    p.expect(IDENT) && p.expect(L_PAREN) && p.expect(R_PAREN)\n-        && p.curly_block(|_| ());\n+    p.expect(IDENT) && p.expect(L_PAREN) && p.expect(R_PAREN) && p.curly_block(|_| ());\n }\n-\n-"}, {"sha": "c6ab1fbe26eb3a68163f20ac82318a210bb74a34", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,5 +1,5 @@\n use super::parser::{Parser, TokenSet};\n-use {SyntaxKind};\n+use SyntaxKind;\n use tree::EOF;\n use syntax_kinds::*;\n \n@@ -29,7 +29,7 @@ fn visibility(p: &mut Parser) {\n                     }\n                     p.expect(R_PAREN);\n                 }\n-                _ => ()\n+                _ => (),\n             }\n         }\n         vis.complete(p, VISIBILITY);\n@@ -53,9 +53,7 @@ impl<'p> Parser<'p> {\n \n     fn err_and_bump(&mut self, message: &str) {\n         let err = self.start();\n-        self.error()\n-            .message(message)\n-            .emit();\n+        self.error().message(message).emit();\n         self.bump();\n         err.complete(self, ERROR);\n     }\n@@ -65,15 +63,16 @@ impl<'p> Parser<'p> {\n             self.bump();\n             true\n         } else {\n-            self.error()\n-                .message(format!(\"expected {:?}\", kind))\n-                .emit();\n+            self.error().message(format!(\"expected {:?}\", kind)).emit();\n             false\n         }\n     }\n \n     fn eat(&mut self, kind: SyntaxKind) -> bool {\n-        self.current() == kind && { self.bump(); true }\n+        self.current() == kind && {\n+            self.bump();\n+            true\n+        }\n     }\n }\n \n@@ -94,8 +93,7 @@ impl Lookahead for SyntaxKind {\n \n impl Lookahead for [SyntaxKind; 2] {\n     fn is_ahead(self, p: &Parser) -> bool {\n-        p.current() == self[0]\n-        && p.raw_lookahead(1) == self[1]\n+        p.current() == self[0] && p.raw_lookahead(1) == self[1]\n     }\n \n     fn consume(p: &mut Parser) {\n@@ -106,9 +104,7 @@ impl Lookahead for [SyntaxKind; 2] {\n \n impl Lookahead for [SyntaxKind; 3] {\n     fn is_ahead(self, p: &Parser) -> bool {\n-        p.current() == self[0]\n-        && p.raw_lookahead(1) == self[1]\n-        && p.raw_lookahead(2) == self[2]\n+        p.current() == self[0] && p.raw_lookahead(1) == self[1] && p.raw_lookahead(2) == self[2]\n     }\n \n     fn consume(p: &mut Parser) {\n@@ -130,5 +126,4 @@ impl<'a> Lookahead for AnyOf<'a> {\n     fn consume(p: &mut Parser) {\n         p.bump();\n     }\n-\n }"}, {"sha": "4e028073a0dad946973130d212b390d3bce4ace0", "filename": "src/parser/event_parser/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -34,9 +34,7 @@ fn path_segment(p: &mut Parser, first: bool) {\n             p.bump();\n         }\n         _ => {\n-            p.error()\n-                .message(\"expected identifier\")\n-                .emit();\n+            p.error().message(\"expected identifier\").emit();\n         }\n     };\n     segment.complete(p, PATH_SEGMENT);"}, {"sha": "1a3d44a0ab9ded0dd85a4639a8435360132196d2", "filename": "src/parser/event_parser/grammar/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftypes.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -2,4 +2,4 @@ use super::*;\n \n pub(super) fn type_ref(p: &mut Parser) {\n     p.expect(IDENT);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "65aea017b1931a28216b1109c7b3154e2a636eea", "filename": "src/parser/event_parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fmod.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,4 +1,4 @@\n-use {Token, SyntaxKind};\n+use {SyntaxKind, Token};\n \n #[macro_use]\n mod parser;"}, {"sha": "5ba3071cb8eeae43b71ad001acb725c993f68c08", "filename": "src/parser/event_parser/parser.rs", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fevent_parser%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fparser.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,17 +1,19 @@\n-use {Token, SyntaxKind, TextUnit};\n+use {SyntaxKind, TextUnit, Token};\n use super::Event;\n use super::super::is_insignificant;\n-use syntax_kinds::{L_CURLY, R_CURLY, ERROR};\n+use syntax_kinds::{ERROR, L_CURLY, R_CURLY};\n use tree::{EOF, TOMBSTONE};\n \n pub(crate) struct Marker {\n-    pos: u32\n+    pos: u32,\n }\n \n impl Marker {\n     pub fn complete(self, p: &mut Parser, kind: SyntaxKind) -> CompleteMarker {\n         match self.event(p) {\n-            &mut Event::Start { kind: ref mut slot, ..} => {\n+            &mut Event::Start {\n+                kind: ref mut slot, ..\n+            } => {\n                 *slot = kind;\n             }\n             _ => unreachable!(),\n@@ -26,8 +28,11 @@ impl Marker {\n         let idx = self.pos as usize;\n         if idx == p.events.len() - 1 {\n             match p.events.pop() {\n-                Some(Event::Start { kind: TOMBSTONE, forward_parent: None }) => (),\n-                _ => unreachable!()\n+                Some(Event::Start {\n+                    kind: TOMBSTONE,\n+                    forward_parent: None,\n+                }) => (),\n+                _ => unreachable!(),\n             }\n         }\n         ::std::mem::forget(self);\n@@ -51,14 +56,17 @@ impl Drop for Marker {\n }\n \n pub(crate) struct CompleteMarker {\n-    pos: u32\n+    pos: u32,\n }\n \n impl CompleteMarker {\n     pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n         let m = p.start();\n         match p.events[self.pos as usize] {\n-            Event::Start { ref mut forward_parent, ..} => {\n+            Event::Start {\n+                ref mut forward_parent,\n+                ..\n+            } => {\n                 *forward_parent = Some(m.pos - self.pos);\n             }\n             _ => unreachable!(),\n@@ -68,7 +76,7 @@ impl CompleteMarker {\n }\n \n pub(crate) struct TokenSet {\n-    pub tokens: &'static [SyntaxKind]\n+    pub tokens: &'static [SyntaxKind],\n }\n \n impl TokenSet {\n@@ -90,7 +98,6 @@ macro_rules! token_set {\n     };\n }\n \n-\n pub(crate) struct Parser<'t> {\n     #[allow(unused)]\n     text: &'t str,\n@@ -150,8 +157,13 @@ impl<'t> Parser<'t> {\n     }\n \n     pub(crate) fn start(&mut self) -> Marker {\n-        let m = Marker { pos: self.events.len() as u32 };\n-        self.event(Event::Start { kind: TOMBSTONE, forward_parent: None });\n+        let m = Marker {\n+            pos: self.events.len() as u32,\n+        };\n+        self.event(Event::Start {\n+            kind: TOMBSTONE,\n+            forward_parent: None,\n+        });\n         m\n     }\n \n@@ -168,7 +180,10 @@ impl<'t> Parser<'t> {\n             _ => (),\n         }\n         self.pos += 1;\n-        self.event(Event::Token { kind, n_raw_tokens: 1 });\n+        self.event(Event::Token {\n+            kind,\n+            n_raw_tokens: 1,\n+        });\n         kind\n     }\n \n@@ -210,7 +225,10 @@ pub(crate) struct ErrorBuilder<'p, 't: 'p> {\n \n impl<'t, 'p> ErrorBuilder<'p, 't> {\n     fn new(parser: &'p mut Parser<'t>) -> Self {\n-        ErrorBuilder { message: None, parser }\n+        ErrorBuilder {\n+            message: None,\n+            parser,\n+        }\n     }\n \n     pub fn message<M: Into<String>>(mut self, m: M) -> Self {"}, {"sha": "d04ed1e75c93723d4f5c89f7244f0ebc822a6024", "filename": "src/parser/mod.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fmod.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,22 +1,17 @@\n-use {Token, File, FileBuilder, Sink, SyntaxKind};\n+use {File, FileBuilder, Sink, SyntaxKind, Token};\n \n use syntax_kinds::*;\n use tree::TOMBSTONE;\n \n mod event_parser;\n use self::event_parser::Event;\n \n-\n pub fn parse(text: String, tokens: &[Token]) -> File {\n     let events = event_parser::parse(&text, tokens);\n     from_events_to_file(text, tokens, events)\n }\n \n-fn from_events_to_file(\n-    text: String,\n-    tokens: &[Token],\n-    events: Vec<Event>,\n-) -> File {\n+fn from_events_to_file(text: String, tokens: &[Token], events: Vec<Event>) -> File {\n     let mut builder = FileBuilder::new(text);\n     let mut idx = 0;\n \n@@ -26,18 +21,23 @@ fn from_events_to_file(\n     for (i, event) in events.iter().enumerate() {\n         if holes.last() == Some(&i) {\n             holes.pop();\n-            continue\n+            continue;\n         }\n \n         match event {\n-            &Event::Start { kind: TOMBSTONE, .. } => (),\n+            &Event::Start {\n+                kind: TOMBSTONE, ..\n+            } => (),\n \n             &Event::Start { .. } => {\n                 forward_parents.clear();\n                 let mut idx = i;\n                 loop {\n                     let (kind, fwd) = match events[idx] {\n-                        Event::Start { kind, forward_parent } => (kind, forward_parent),\n+                        Event::Start {\n+                            kind,\n+                            forward_parent,\n+                        } => (kind, forward_parent),\n                         _ => unreachable!(),\n                     };\n                     forward_parents.push((idx, kind));\n@@ -64,8 +64,11 @@ fn from_events_to_file(\n                     }\n                 }\n                 builder.finish_internal()\n-            },\n-            &Event::Token { kind: _, mut n_raw_tokens } => loop {\n+            }\n+            &Event::Token {\n+                kind: _,\n+                mut n_raw_tokens,\n+            } => loop {\n                 let token = tokens[idx];\n                 if !is_insignificant(token.kind) {\n                     n_raw_tokens -= 1;\n@@ -76,8 +79,7 @@ fn from_events_to_file(\n                     break;\n                 }\n             },\n-            &Event::Error { ref message } =>\n-                builder.error().message(message.clone()).emit(),\n+            &Event::Error { ref message } => builder.error().message(message.clone()).emit(),\n         }\n     }\n     builder.finish()"}, {"sha": "ac1a54a7582025381f02fa4446043f0e36542eea", "filename": "src/text.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Ftext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Ftext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftext.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -64,7 +64,6 @@ impl ops::SubAssign<TextUnit> for TextUnit {\n     }\n }\n \n-\n #[derive(Clone, Copy, PartialEq, Eq)]\n pub struct TextRange {\n     start: TextUnit,\n@@ -83,15 +82,17 @@ impl fmt::Display for TextRange {\n     }\n }\n \n-\n impl TextRange {\n     pub fn empty() -> TextRange {\n         TextRange::from_to(TextUnit::new(0), TextUnit::new(0))\n     }\n \n     pub fn from_to(from: TextUnit, to: TextUnit) -> TextRange {\n         assert!(from <= to, \"Invalid text range [{}; {})\", from, to);\n-        TextRange { start: from, end: to }\n+        TextRange {\n+            start: from,\n+            end: to,\n+        }\n     }\n \n     pub fn from_len(from: TextUnit, len: TextUnit) -> TextRange {\n@@ -121,4 +122,4 @@ impl ops::Index<TextRange> for str {\n     fn index(&self, index: TextRange) -> &str {\n         &self[index.start().0 as usize..index.end().0 as usize]\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "939922cb2a8f6f989fdb236e750f87c77578e296", "filename": "src/tree/file_builder.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Ftree%2Ffile_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Ftree%2Ffile_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Ffile_builder.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,5 +1,5 @@\n-use {SyntaxKind, TextUnit, TextRange};\n-use super::{NodeData, SyntaxErrorData, NodeIdx, File};\n+use {SyntaxKind, TextRange, TextUnit};\n+use super::{File, NodeData, NodeIdx, SyntaxErrorData};\n \n pub trait Sink {\n     fn leaf(&mut self, kind: SyntaxKind, len: TextUnit);\n@@ -8,7 +8,6 @@ pub trait Sink {\n     fn error(&mut self) -> ErrorBuilder;\n }\n \n-\n pub struct FileBuilder {\n     text: String,\n     nodes: Vec<NodeData>,\n@@ -48,9 +47,9 @@ impl Sink for FileBuilder {\n     }\n \n     fn finish_internal(&mut self) {\n-        let (id, _) = self.in_progress.pop().expect(\n-            \"trying to complete a node, but there are no in-progress nodes\"\n-        );\n+        let (id, _) = self.in_progress\n+            .pop()\n+            .expect(\"trying to complete a node, but there are no in-progress nodes\");\n         if !self.in_progress.is_empty() {\n             self.add_len(id);\n         }\n@@ -76,11 +75,14 @@ impl FileBuilder {\n         assert!(\n             self.in_progress.is_empty(),\n             \"some nodes in FileBuilder are unfinished: {:?}\",\n-            self.in_progress.iter().map(|&(idx, _)| self.nodes[idx].kind)\n+            self.in_progress\n+                .iter()\n+                .map(|&(idx, _)| self.nodes[idx].kind)\n                 .collect::<Vec<_>>()\n         );\n         assert_eq!(\n-            self.pos, (self.text.len() as u32).into(),\n+            self.pos,\n+            (self.text.len() as u32).into(),\n             \"nodes in FileBuilder do not cover the whole file\"\n         );\n         File {\n@@ -100,7 +102,6 @@ impl FileBuilder {\n         child.parent = Some(self.current_id());\n         let id = self.new_node(child);\n         {\n-\n             let (parent, sibling) = *self.in_progress.last().unwrap();\n             let slot = if let Some(idx) = sibling {\n                 &mut self.nodes[idx].next_sibling\n@@ -140,12 +141,15 @@ fn grow(left: &mut TextRange, right: TextRange) {\n \n pub struct ErrorBuilder<'f> {\n     message: Option<String>,\n-    builder: &'f mut FileBuilder\n+    builder: &'f mut FileBuilder,\n }\n \n impl<'f> ErrorBuilder<'f> {\n     fn new(builder: &'f mut FileBuilder) -> Self {\n-        ErrorBuilder { message: None, builder }\n+        ErrorBuilder {\n+            message: None,\n+            builder,\n+        }\n     }\n \n     pub fn message<M: Into<String>>(mut self, m: M) -> Self {\n@@ -156,6 +160,10 @@ impl<'f> ErrorBuilder<'f> {\n     pub fn emit(self) {\n         let message = self.message.expect(\"Error message not set\");\n         let &(node, after_child) = self.builder.in_progress.last().unwrap();\n-        self.builder.errors.push(SyntaxErrorData { node, message, after_child })\n+        self.builder.errors.push(SyntaxErrorData {\n+            node,\n+            message,\n+            after_child,\n+        })\n     }\n }"}, {"sha": "a330caf54fe538d1de7a1cc086e0cfa1e3044401", "filename": "src/tree/mod.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/src%2Ftree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/src%2Ftree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftree%2Fmod.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -1,4 +1,4 @@\n-use text::{TextUnit, TextRange};\n+use text::{TextRange, TextUnit};\n use syntax_kinds::syntax_info;\n \n use std::fmt;\n@@ -11,15 +11,10 @@ pub use self::file_builder::{FileBuilder, Sink};\n pub struct SyntaxKind(pub(crate) u32);\n \n pub(crate) const EOF: SyntaxKind = SyntaxKind(!0);\n-pub(crate) const EOF_INFO: SyntaxInfo = SyntaxInfo {\n-    name: \"EOF\"\n-};\n+pub(crate) const EOF_INFO: SyntaxInfo = SyntaxInfo { name: \"EOF\" };\n \n pub(crate) const TOMBSTONE: SyntaxKind = SyntaxKind(!0 - 1);\n-pub(crate) const TOMBSTONE_INFO: SyntaxInfo = SyntaxInfo {\n-    name: \"TOMBSTONE\"\n-};\n-\n+pub(crate) const TOMBSTONE_INFO: SyntaxInfo = SyntaxInfo { name: \"TOMBSTONE\" };\n \n impl SyntaxKind {\n     fn info(self) -> &'static SyntaxInfo {\n@@ -38,7 +33,6 @@ impl fmt::Debug for SyntaxKind {\n     }\n }\n \n-\n pub(crate) struct SyntaxInfo {\n     pub name: &'static str,\n }\n@@ -58,7 +52,10 @@ pub struct File {\n impl File {\n     pub fn root<'f>(&'f self) -> Node<'f> {\n         assert!(!self.nodes.is_empty());\n-        Node { file: self, idx: NodeIdx(0) }\n+        Node {\n+            file: self,\n+            idx: NodeIdx(0),\n+        }\n     }\n }\n \n@@ -86,14 +83,17 @@ impl<'f> Node<'f> {\n     }\n \n     pub fn children(&self) -> Children<'f> {\n-        Children { next: self.as_node(self.data().first_child) }\n+        Children {\n+            next: self.as_node(self.data().first_child),\n+        }\n     }\n \n     pub fn errors(&self) -> SyntaxErrors<'f> {\n         let pos = self.file.errors.iter().position(|e| e.node == self.idx);\n-        let next = pos\n-            .map(|i| ErrorIdx(i as u32))\n-            .map(|idx| SyntaxError { file: self.file, idx });\n+        let next = pos.map(|i| ErrorIdx(i as u32)).map(|idx| SyntaxError {\n+            file: self.file,\n+            idx,\n+        });\n         SyntaxErrors { next }\n     }\n \n@@ -102,7 +102,10 @@ impl<'f> Node<'f> {\n     }\n \n     fn as_node(&self, idx: Option<NodeIdx>) -> Option<Node<'f>> {\n-        idx.map(|idx| Node { file: self.file, idx })\n+        idx.map(|idx| Node {\n+            file: self.file,\n+            idx,\n+        })\n     }\n }\n \n@@ -118,8 +121,7 @@ impl<'f> cmp::PartialEq<Node<'f>> for Node<'f> {\n     }\n }\n \n-impl<'f> cmp::Eq for Node<'f> {\n-}\n+impl<'f> cmp::Eq for Node<'f> {}\n \n #[derive(Clone, Copy)]\n pub struct SyntaxError<'f> {\n@@ -134,7 +136,10 @@ impl<'f> SyntaxError<'f> {\n \n     pub fn after_child(&self) -> Option<Node<'f>> {\n         let idx = self.data().after_child?;\n-        Some(Node { file: self.file, idx })\n+        Some(Node {\n+            file: self.file,\n+            idx,\n+        })\n     }\n \n     fn data(&self) -> &'f SyntaxErrorData {\n@@ -148,7 +153,7 @@ impl<'f> SyntaxError<'f> {\n         }\n         let result = SyntaxError {\n             file: self.file,\n-            idx: ErrorIdx(next_idx)\n+            idx: ErrorIdx(next_idx),\n         };\n         if result.data().node != self.data().node {\n             return None;\n@@ -185,7 +190,6 @@ impl<'f> Iterator for SyntaxErrors<'f> {\n     }\n }\n \n-\n #[derive(Clone, Copy, PartialEq, Eq)]\n struct NodeIdx(u32);\n "}, {"sha": "397ebafddebbd8b6096b342230d557a8e6c572a7", "filename": "tests/lexer.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/tests%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/tests%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flexer.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -4,18 +4,15 @@ extern crate testutils;\n \n use std::fmt::Write;\n \n-use libsyntax2::{Token, tokenize};\n+use libsyntax2::{tokenize, Token};\n use testutils::dir_tests;\n \n #[test]\n fn lexer_tests() {\n-    dir_tests(\n-        &[\"lexer\"],\n-        |text| {\n-            let tokens = tokenize(text);\n-            dump_tokens(&tokens, text)\n-        }\n-    )\n+    dir_tests(&[\"lexer\"], |text| {\n+        let tokens = tokenize(text);\n+        dump_tokens(&tokens, text)\n+    })\n }\n \n fn dump_tokens(tokens: &[Token], text: &str) -> String {\n@@ -29,4 +26,4 @@ fn dump_tokens(tokens: &[Token], text: &str) -> String {\n         write!(acc, \"{:?} {} {:?}\\n\", token.kind, token.len, token_text).unwrap()\n     }\n     acc\n-}\n\\ No newline at end of file\n+}"}, {"sha": "37c9021eff297e2b18422a47f6f4c0028ff52a26", "filename": "tests/parser.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4de3c97b2afea55834cd16368f950133459d8c73/tests%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4de3c97b2afea55834cd16368f950133459d8c73/tests%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fparser.rs?ref=4de3c97b2afea55834cd16368f950133459d8c73", "patch": "@@ -2,18 +2,15 @@ extern crate file;\n extern crate libsyntax2;\n extern crate testutils;\n \n-use libsyntax2::{tokenize, parse};\n+use libsyntax2::{parse, tokenize};\n use libsyntax2::utils::dump_tree;\n use testutils::dir_tests;\n \n #[test]\n fn parser_tests() {\n-    dir_tests(\n-        &[\"parser/ok\", \"parser/err\"],\n-        |text| {\n-            let tokens = tokenize(text);\n-            let file = parse(text.to_string(), &tokens);\n-            dump_tree(&file)\n-        }\n-    )\n+    dir_tests(&[\"parser/ok\", \"parser/err\"], |text| {\n+        let tokens = tokenize(text);\n+        let file = parse(text.to_string(), &tokens);\n+        dump_tree(&file)\n+    })\n }"}]}