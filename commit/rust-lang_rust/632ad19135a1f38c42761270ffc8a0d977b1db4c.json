{"sha": "632ad19135a1f38c42761270ffc8a0d977b1db4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMmFkMTkxMzVhMWYzOGM0Mjc2MTI3MGZmYzhhMGQ5NzdiMWRiNGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-06T10:36:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-06T10:36:09Z"}, "message": "Auto merge of #46192 - arielb1:locally-coherent, r=nikomatsakis\n\ncoherence: fix is_knowable logic\n\nA trait-ref that passes the orphan-check rules can still be implemented in a crate downstream from our crate (for example, `LocalType for LocalTrait<_>` might be matched by a `LocalType for LocalTrait<TypeFromDownstreamCrate>`), and this should be known by the `is_knowable`  logic.\n\nTrait selection had a hackfix for this, but it's an hacky fix that does not handle all cases. This patch removes it.\n\nfixes #43355.\n\nr? @nikomatsakis\n\nNeeds a crater run", "tree": {"sha": "ea05ba7afb0b82c803ffe7cad03fe010a6a8b299", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea05ba7afb0b82c803ffe7cad03fe010a6a8b299"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/632ad19135a1f38c42761270ffc8a0d977b1db4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/632ad19135a1f38c42761270ffc8a0d977b1db4c", "html_url": "https://github.com/rust-lang/rust/commit/632ad19135a1f38c42761270ffc8a0d977b1db4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/632ad19135a1f38c42761270ffc8a0d977b1db4c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a62910baca04512daa08d0f3867e47a65ab0fdcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a62910baca04512daa08d0f3867e47a65ab0fdcd", "html_url": "https://github.com/rust-lang/rust/commit/a62910baca04512daa08d0f3867e47a65ab0fdcd"}, {"sha": "425c2c3606c275851da2b78465323a342ab5b2f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/425c2c3606c275851da2b78465323a342ab5b2f9", "html_url": "https://github.com/rust-lang/rust/commit/425c2c3606c275851da2b78465323a342ab5b2f9"}], "stats": {"total": 594, "additions": 453, "deletions": 141}, "files": [{"sha": "d352d359e2021f123952fc2a59d0a638e063b057", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -204,6 +204,12 @@ declare_lint! {\n     \"detects generic lifetime arguments in path segments with late bound lifetime parameters\"\n }\n \n+declare_lint! {\n+    pub INCOHERENT_FUNDAMENTAL_IMPLS,\n+    Warn,\n+    \"potentially-conflicting impls were erroneously allowed\"\n+}\n+\n declare_lint! {\n     pub DEPRECATED,\n     Warn,\n@@ -267,6 +273,7 @@ impl LintPass for HardwiredLints {\n             MISSING_FRAGMENT_SPECIFIER,\n             PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n             LATE_BOUND_LIFETIME_ARGUMENTS,\n+            INCOHERENT_FUNDAMENTAL_IMPLS,\n             DEPRECATED,\n             UNUSED_UNSAFE,\n             UNUSED_MUT,"}, {"sha": "7d1f3b31bfc27141be5e0a5147d06b67a0f70eda", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 192, "deletions": 57, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -13,14 +13,27 @@\n use hir::def_id::{DefId, LOCAL_CRATE};\n use syntax_pos::DUMMY_SP;\n use traits::{self, Normalized, SelectionContext, Obligation, ObligationCause, Reveal};\n+use traits::IntercrateMode;\n use traits::select::IntercrateAmbiguityCause;\n use ty::{self, Ty, TyCtxt};\n+use ty::fold::TypeFoldable;\n use ty::subst::Subst;\n \n use infer::{InferCtxt, InferOk};\n \n-#[derive(Copy, Clone)]\n-struct InferIsLocal(bool);\n+/// Whether we do the orphan check relative to this crate or\n+/// to some remote crate.\n+#[derive(Copy, Clone, Debug)]\n+enum InCrate {\n+    Local,\n+    Remote\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+pub enum Conflict {\n+    Upstream,\n+    Downstream { used_to_be_broken: bool }\n+}\n \n pub struct OverlapResult<'tcx> {\n     pub impl_header: ty::ImplHeader<'tcx>,\n@@ -31,16 +44,19 @@ pub struct OverlapResult<'tcx> {\n /// `ImplHeader` with those types substituted\n pub fn overlapping_impls<'cx, 'gcx, 'tcx>(infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n                                           impl1_def_id: DefId,\n-                                          impl2_def_id: DefId)\n+                                          impl2_def_id: DefId,\n+                                          intercrate_mode: IntercrateMode)\n                                           -> Option<OverlapResult<'tcx>>\n {\n     debug!(\"impl_can_satisfy(\\\n            impl1_def_id={:?}, \\\n-           impl2_def_id={:?})\",\n+           impl2_def_id={:?},\n+           intercrate_mode={:?})\",\n            impl1_def_id,\n-           impl2_def_id);\n+           impl2_def_id,\n+           intercrate_mode);\n \n-    let selcx = &mut SelectionContext::intercrate(infcx);\n+    let selcx = &mut SelectionContext::intercrate(infcx, intercrate_mode);\n     overlap(selcx, impl1_def_id, impl2_def_id)\n }\n \n@@ -126,32 +142,49 @@ fn overlap<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, 'tcx>,\n }\n \n pub fn trait_ref_is_knowable<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                             trait_ref: ty::TraitRef<'tcx>) -> bool\n+                                             trait_ref: ty::TraitRef<'tcx>)\n+                                             -> Option<Conflict>\n {\n     debug!(\"trait_ref_is_knowable(trait_ref={:?})\", trait_ref);\n-\n-    // if the orphan rules pass, that means that no ancestor crate can\n-    // impl this, so it's up to us.\n-    if orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false)).is_ok() {\n-        debug!(\"trait_ref_is_knowable: orphan check passed\");\n-        return true;\n+    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Remote).is_ok() {\n+        // A downstream or cousin crate is allowed to implement some\n+        // substitution of this trait-ref.\n+\n+        // A trait can be implementable for a trait ref by both the current\n+        // crate and crates downstream of it. Older versions of rustc\n+        // were not aware of this, causing incoherence (issue #43355).\n+        let used_to_be_broken =\n+            orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok();\n+        if used_to_be_broken {\n+            debug!(\"trait_ref_is_knowable({:?}) - USED TO BE BROKEN\", trait_ref);\n+        }\n+        return Some(Conflict::Downstream { used_to_be_broken });\n     }\n \n-    // if the trait is not marked fundamental, then it's always possible that\n-    // an ancestor crate will impl this in the future, if they haven't\n-    // already\n-    if !trait_ref_is_local_or_fundamental(tcx, trait_ref) {\n-        debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n-        return false;\n+    if trait_ref_is_local_or_fundamental(tcx, trait_ref) {\n+        // This is a local or fundamental trait, so future-compatibility\n+        // is no concern. We know that downstream/cousin crates are not\n+        // allowed to implement a substitution of this trait ref, which\n+        // means impls could only come from dependencies of this crate,\n+        // which we already know about.\n+        return None;\n     }\n \n-    // find out when some downstream (or cousin) crate could impl this\n-    // trait-ref, presuming that all the parameters were instantiated\n-    // with downstream types. If not, then it could only be\n-    // implemented by an upstream crate, which means that the impl\n-    // must be visible to us, and -- since the trait is fundamental\n-    // -- we can test.\n-    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(true)).is_err()\n+    // This is a remote non-fundamental trait, so if another crate\n+    // can be the \"final owner\" of a substitution of this trait-ref,\n+    // they are allowed to implement it future-compatibly.\n+    //\n+    // However, if we are a final owner, then nobody else can be,\n+    // and if we are an intermediate owner, then we don't care\n+    // about future-compatibility, which means that we're OK if\n+    // we are an owner.\n+    if orphan_check_trait_ref(tcx, trait_ref, InCrate::Local).is_ok() {\n+        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+        return None;\n+    } else {\n+        debug!(\"trait_ref_is_knowable: nonlocal, nonfundamental, unowned\");\n+        return Some(Conflict::Upstream);\n+    }\n }\n \n pub fn trait_ref_is_local_or_fundamental<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -189,30 +222,123 @@ pub fn orphan_check<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         return Ok(());\n     }\n \n-    orphan_check_trait_ref(tcx, trait_ref, InferIsLocal(false))\n+    orphan_check_trait_ref(tcx, trait_ref, InCrate::Local)\n }\n \n+/// Check whether a trait-ref is potentially implementable by a crate.\n+///\n+/// The current rule is that a trait-ref orphan checks in a crate C:\n+///\n+/// 1. Order the parameters in the trait-ref in subst order - Self first,\n+///    others linearly (e.g. `<U as Foo<V, W>>` is U < V < W).\n+/// 2. Of these type parameters, there is at least one type parameter\n+///    in which, walking the type as a tree, you can reach a type local\n+///    to C where all types in-between are fundamental types. Call the\n+///    first such parameter the \"local key parameter\".\n+///     - e.g. `Box<LocalType>` is OK, because you can visit LocalType\n+///       going through `Box`, which is fundamental.\n+///     - similarly, `FundamentalPair<Vec<()>, Box<LocalType>>` is OK for\n+///       the same reason.\n+///     - but (knowing that `Vec<T>` is non-fundamental, and assuming it's\n+///       not local), `Vec<LocalType>` is bad, because `Vec<->` is between\n+///       the local type and the type parameter.\n+/// 3. Every type parameter before the local key parameter is fully known in C.\n+///     - e.g. `impl<T> T: Trait<LocalType>` is bad, because `T` might be\n+///       an unknown type.\n+///     - but `impl<T> LocalType: Trait<T>` is OK, because `LocalType`\n+///       occurs before `T`.\n+/// 4. Every type in the local key parameter not known in C, going\n+///    through the parameter's type tree, must appear only as a subtree of\n+///    a type local to C, with only fundamental types between the type\n+///    local to C and the local key parameter.\n+///     - e.g. `Vec<LocalType<T>>>` (or equivalently `Box<Vec<LocalType<T>>>`)\n+///     is bad, because the only local type with `T` as a subtree is\n+///     `LocalType<T>`, and `Vec<->` is between it and the type parameter.\n+///     - similarly, `FundamentalPair<LocalType<T>, T>` is bad, because\n+///     the second occurence of `T` is not a subtree of *any* local type.\n+///     - however, `LocalType<Vec<T>>` is OK, because `T` is a subtree of\n+///     `LocalType<Vec<T>>`, which is local and has no types between it and\n+///     the type parameter.\n+///\n+/// The orphan rules actually serve several different purposes:\n+///\n+/// 1. They enable link-safety - i.e. 2 mutually-unknowing crates (where\n+///    every type local to one crate is unknown in the other) can't implement\n+///    the same trait-ref. This follows because it can be seen that no such\n+///    type can orphan-check in 2 such crates.\n+///\n+///    To check that a local impl follows the orphan rules, we check it in\n+///    InCrate::Local mode, using type parameters for the \"generic\" types.\n+///\n+/// 2. They ground negative reasoning for coherence. If a user wants to\n+///    write both a conditional blanket impl and a specific impl, we need to\n+///    make sure they do not overlap. For example, if we write\n+///    ```\n+///    impl<T> IntoIterator for Vec<T>\n+///    impl<T: Iterator> IntoIterator for T\n+///    ```\n+///    We need to be able to prove that `Vec<$0>: !Iterator` for every type $0.\n+///    We can observe that this holds in the current crate, but we need to make\n+///    sure this will also hold in all unknown crates (both \"independent\" crates,\n+///    which we need for link-safety, and also child crates, because we don't want\n+///    child crates to get error for impl conflicts in a *dependency*).\n+///\n+///    For that, we only allow negative reasoning if, for every assignment to the\n+///    inference variables, every unknown crate would get an orphan error if they\n+///    try to implement this trait-ref. To check for this, we use InCrate::Remote\n+///    mode. That is sound because we already know all the impls from known crates.\n+///\n+/// 3. For non-#[fundamental] traits, they guarantee that parent crates can\n+///    add \"non-blanket\" impls without breaking negative reasoning in dependent\n+///    crates. This is the \"rebalancing coherence\" (RFC 1023) restriction.\n+///\n+///    For that, we only a allow crate to perform negative reasoning on\n+///    non-local-non-#[fundamental] only if there's a local key parameter as per (2).\n+///\n+///    Because we never perform negative reasoning generically (coherence does\n+///    not involve type parameters), this can be interpreted as doing the full\n+///    orphan check (using InCrate::Local mode), substituting non-local known\n+///    types for all inference variables.\n+///\n+///    This allows for crates to future-compatibly add impls as long as they\n+///    can't apply to types with a key parameter in a child crate - applying\n+///    the rules, this basically means that every type parameter in the impl\n+///    must appear behind a non-fundamental type (because this is not a\n+///    type-system requirement, crate owners might also go for \"semantic\n+///    future-compatibility\" involving things such as sealed traits, but\n+///    the above requirement is sufficient, and is necessary in \"open world\"\n+///    cases).\n+///\n+/// Note that this function is never called for types that have both type\n+/// parameters and inference variables.\n fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n                                 trait_ref: ty::TraitRef<'tcx>,\n-                                infer_is_local: InferIsLocal)\n+                                in_crate: InCrate)\n                                 -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"orphan_check_trait_ref(trait_ref={:?}, infer_is_local={})\",\n-           trait_ref, infer_is_local.0);\n+    debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\",\n+           trait_ref, in_crate);\n+\n+    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+        bug!(\"can't orphan check a trait ref with both params and inference variables {:?}\",\n+             trait_ref);\n+    }\n \n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     // Find the first input type that either references a type parameter OR\n     // some local type.\n     for input_ty in trait_ref.input_types() {\n-        if ty_is_local(tcx, input_ty, infer_is_local) {\n+        if ty_is_local(tcx, input_ty, in_crate) {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n \n             // First local input type. Check that there are no\n             // uncovered type parameters.\n-            let uncovered_tys = uncovered_tys(tcx, input_ty, infer_is_local);\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, in_crate);\n             for uncovered_ty in uncovered_tys {\n-                if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n+                if let Some(param) = uncovered_ty.walk()\n+                    .find(|t| is_possibly_remote_type(t, in_crate))\n+                {\n                     debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n                     return Err(OrphanCheckErr::UncoveredTy(param));\n                 }\n@@ -224,11 +350,11 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n \n         // Otherwise, enforce invariant that there are no type\n         // parameters reachable.\n-        if !infer_is_local.0 {\n-            if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n-                debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n-                return Err(OrphanCheckErr::UncoveredTy(param));\n-            }\n+        if let Some(param) = input_ty.walk()\n+            .find(|t| is_possibly_remote_type(t, in_crate))\n+        {\n+            debug!(\"orphan_check_trait_ref: uncovered type `{:?}`\", param);\n+            return Err(OrphanCheckErr::UncoveredTy(param));\n         }\n     }\n \n@@ -237,29 +363,29 @@ fn orphan_check_trait_ref<'tcx>(tcx: TyCtxt,\n     return Err(OrphanCheckErr::NoLocalInputType);\n }\n \n-fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, infer_is_local: InferIsLocal)\n+fn uncovered_tys<'tcx>(tcx: TyCtxt, ty: Ty<'tcx>, in_crate: InCrate)\n                        -> Vec<Ty<'tcx>> {\n-    if ty_is_local_constructor(ty, infer_is_local) {\n+    if ty_is_local_constructor(ty, in_crate) {\n         vec![]\n     } else if fundamental_ty(tcx, ty) {\n         ty.walk_shallow()\n-          .flat_map(|t| uncovered_tys(tcx, t, infer_is_local))\n+          .flat_map(|t| uncovered_tys(tcx, t, in_crate))\n           .collect()\n     } else {\n         vec![ty]\n     }\n }\n \n-fn is_type_parameter(ty: Ty) -> bool {\n+fn is_possibly_remote_type(ty: Ty, _in_crate: InCrate) -> bool {\n     match ty.sty {\n         ty::TyProjection(..) | ty::TyParam(..) => true,\n         _ => false,\n     }\n }\n \n-fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n-    ty_is_local_constructor(ty, infer_is_local) ||\n-        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, infer_is_local))\n+fn ty_is_local(tcx: TyCtxt, ty: Ty, in_crate: InCrate) -> bool {\n+    ty_is_local_constructor(ty, in_crate) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, in_crate))\n }\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n@@ -273,7 +399,16 @@ fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     }\n }\n \n-fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n+fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n+    match in_crate {\n+        // The type is local to *this* crate - it will not be\n+        // local in any other crate.\n+        InCrate::Remote => false,\n+        InCrate::Local => def_id.is_local()\n+    }\n+}\n+\n+fn ty_is_local_constructor(ty: Ty, in_crate: InCrate) -> bool {\n     debug!(\"ty_is_local_constructor({:?})\", ty);\n \n     match ty.sty {\n@@ -296,20 +431,20 @@ fn ty_is_local_constructor(ty: Ty, infer_is_local: InferIsLocal)-> bool {\n             false\n         }\n \n-        ty::TyInfer(..) => {\n-            infer_is_local.0\n-        }\n+        ty::TyInfer(..) => match in_crate {\n+            InCrate::Local => false,\n+            // The inference variable might be unified with a local\n+            // type in that remote crate.\n+            InCrate::Remote => true,\n+        },\n \n-        ty::TyAdt(def, _) => {\n-            def.did.is_local()\n-        }\n-\n-        ty::TyForeign(did) => {\n-            did.is_local()\n-        }\n+        ty::TyAdt(def, _) => def_id_is_local(def.did, in_crate),\n+        ty::TyForeign(did) => def_id_is_local(did, in_crate),\n \n         ty::TyDynamic(ref tt, ..) => {\n-            tt.principal().map_or(false, |p| p.def_id().is_local())\n+            tt.principal().map_or(false, |p| {\n+                def_id_is_local(p.def_id(), in_crate)\n+            })\n         }\n \n         ty::TyError => {"}, {"sha": "94605d895a5545c399843428bbe9b8aacc25b0fe", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -60,6 +60,13 @@ mod structural_impls;\n pub mod trans;\n mod util;\n \n+// Whether to enable bug compatibility with issue #43355\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum IntercrateMode {\n+    Issue43355,\n+    Fixed\n+}\n+\n /// An `Obligation` represents some trait reference (e.g. `int:Eq`) for\n /// which the vtable must be found.  The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of"}, {"sha": "0c4071b8b5d9c6d9861e7fb0c3e268d20c465f2b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -13,8 +13,9 @@\n use self::SelectionCandidate::*;\n use self::EvaluationResult::*;\n \n-use super::coherence;\n+use super::coherence::{self, Conflict};\n use super::DerivedObligationCause;\n+use super::IntercrateMode;\n use super::project;\n use super::project::{normalize_with_depth, Normalized, ProjectionCacheKey};\n use super::{PredicateObligation, TraitObligation, ObligationCause};\n@@ -87,7 +88,7 @@ pub struct SelectionContext<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     /// other words, we consider `$0 : Bar` to be unimplemented if\n     /// there is no type that the user could *actually name* that\n     /// would satisfy it. This avoids crippling inference, basically.\n-    intercrate: bool,\n+    intercrate: Option<IntercrateMode>,\n \n     inferred_obligations: SnapshotVec<InferredObligationsSnapshotVecDelegate<'tcx>>,\n \n@@ -111,21 +112,24 @@ impl IntercrateAmbiguityCause {\n     /// See #23980 for details.\n     pub fn add_intercrate_ambiguity_hint<'a, 'tcx>(&self,\n                                                    err: &mut ::errors::DiagnosticBuilder) {\n+        err.note(&self.intercrate_ambiguity_hint());\n+    }\n+\n+    pub fn intercrate_ambiguity_hint(&self) -> String {\n         match self {\n             &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n                 let self_desc = if let &Some(ref ty) = self_desc {\n                     format!(\" for type `{}`\", ty)\n                 } else { \"\".to_string() };\n-                err.note(&format!(\"downstream crates may implement trait `{}`{}\",\n-                                  trait_desc, self_desc));\n+                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n             }\n             &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n                 let self_desc = if let &Some(ref ty) = self_desc {\n                     format!(\" for type `{}`\", ty)\n                 } else { \"\".to_string() };\n-                err.note(&format!(\"upstream crates may add new impl of trait `{}`{} \\\n-                                  in future versions\",\n-                                  trait_desc, self_desc));\n+                format!(\"upstream crates may add new impl of trait `{}`{} \\\n+                         in future versions\",\n+                        trait_desc, self_desc)\n             }\n         }\n     }\n@@ -417,17 +421,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: false,\n+            intercrate: None,\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: Vec::new(),\n         }\n     }\n \n-    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+    pub fn intercrate(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+                      mode: IntercrateMode) -> SelectionContext<'cx, 'gcx, 'tcx> {\n+        debug!(\"intercrate({:?})\", mode);\n         SelectionContext {\n             infcx,\n             freshener: infcx.freshener(),\n-            intercrate: true,\n+            intercrate: Some(mode),\n             inferred_obligations: SnapshotVec::new(),\n             intercrate_ambiguity_causes: Vec::new(),\n         }\n@@ -758,7 +764,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         debug!(\"evaluate_trait_predicate_recursively({:?})\",\n                obligation);\n \n-        if !self.intercrate && obligation.is_global() {\n+        if !self.intercrate.is_some() && obligation.is_global() {\n             // If a param env is consistent, global obligations do not depend on its particular\n             // value in order to work, so we can clear out the param env and get better\n             // caching. (If the current param env is inconsistent, we don't care what happens).\n@@ -814,7 +820,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n         let unbound_input_types = stack.fresh_trait_ref.input_types().any(|ty| ty.is_fresh());\n-        if unbound_input_types && self.intercrate {\n+        // this check was an imperfect workaround for a bug n the old\n+        // intercrate mode, it should be removed when that goes away.\n+        if unbound_input_types &&\n+            self.intercrate == Some(IntercrateMode::Issue43355)\n+        {\n             debug!(\"evaluate_stack({:?}) --> unbound argument, intercrate -->  ambiguous\",\n                    stack.fresh_trait_ref);\n             // Heuristics: show the diagnostics when there are no candidates in crate.\n@@ -1077,28 +1087,32 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return Ok(None);\n         }\n \n-        if !self.is_knowable(stack) {\n-            debug!(\"coherence stage: not knowable\");\n-            // Heuristics: show the diagnostics when there are no candidates in crate.\n-            let candidate_set = self.assemble_candidates(stack)?;\n-            if !candidate_set.ambiguous && candidate_set.vec.is_empty() {\n-                let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n-                let self_ty = trait_ref.self_ty();\n-                let trait_desc = trait_ref.to_string();\n-                let self_desc = if self_ty.has_concrete_skeleton() {\n-                    Some(self_ty.to_string())\n-                } else {\n-                    None\n-                };\n-                let cause = if !coherence::trait_ref_is_local_or_fundamental(self.tcx(),\n-                                                                             trait_ref) {\n-                    IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n-                } else {\n-                    IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n-                };\n-                self.intercrate_ambiguity_causes.push(cause);\n+        match self.is_knowable(stack) {\n+            None => {}\n+            Some(conflict) => {\n+                debug!(\"coherence stage: not knowable\");\n+                // Heuristics: show the diagnostics when there are no candidates in crate.\n+                let candidate_set = self.assemble_candidates(stack)?;\n+                if !candidate_set.ambiguous && candidate_set.vec.iter().all(|c| {\n+                    !self.evaluate_candidate(stack, &c).may_apply()\n+                }) {\n+                    let trait_ref = stack.obligation.predicate.skip_binder().trait_ref;\n+                    let self_ty = trait_ref.self_ty();\n+                    let trait_desc = trait_ref.to_string();\n+                    let self_desc = if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    };\n+                    let cause = if let Conflict::Upstream = conflict {\n+                        IntercrateAmbiguityCause::UpstreamCrateUpdate { trait_desc, self_desc }\n+                    } else {\n+                        IntercrateAmbiguityCause::DownstreamCrate { trait_desc, self_desc }\n+                    };\n+                    self.intercrate_ambiguity_causes.push(cause);\n+                }\n+                return Ok(None);\n             }\n-            return Ok(None);\n         }\n \n         let candidate_set = self.assemble_candidates(stack)?;\n@@ -1205,12 +1219,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n     fn is_knowable<'o>(&mut self,\n                        stack: &TraitObligationStack<'o, 'tcx>)\n-                       -> bool\n+                       -> Option<Conflict>\n     {\n-        debug!(\"is_knowable(intercrate={})\", self.intercrate);\n+        debug!(\"is_knowable(intercrate={:?})\", self.intercrate);\n \n-        if !self.intercrate {\n-            return true;\n+        if !self.intercrate.is_some() {\n+            return None;\n         }\n \n         let obligation = &stack.obligation;\n@@ -1221,7 +1235,14 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // bound regions\n         let trait_ref = predicate.skip_binder().trait_ref;\n \n-        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n+        let result = coherence::trait_ref_is_knowable(self.tcx(), trait_ref);\n+        if let (Some(Conflict::Downstream { used_to_be_broken: true }),\n+                Some(IntercrateMode::Issue43355)) = (result, self.intercrate) {\n+            debug!(\"is_knowable: IGNORING conflict to be bug-compatible with #43355\");\n+            None\n+        } else {\n+            result\n+        }\n     }\n \n     /// Returns true if the global caches can be used.\n@@ -1246,7 +1267,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // the master cache. Since coherence executes pretty quickly,\n         // it's not worth going to more trouble to increase the\n         // hit-rate I don't think.\n-        if self.intercrate {\n+        if self.intercrate.is_some() {\n             return false;\n         }\n "}, {"sha": "6a96d01d5f92a498c272e82cb3ecb34b4de47f54", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -30,6 +30,8 @@ use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n use std::rc::Rc;\n \n+use lint;\n+\n pub mod specialization_graph;\n \n /// Information pertinent to an overlapping impl error.\n@@ -325,16 +327,33 @@ pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx\n             // This is where impl overlap checking happens:\n             let insert_result = sg.insert(tcx, impl_def_id);\n             // Report error if there was one.\n-            if let Err(overlap) = insert_result {\n-                let mut err = struct_span_err!(tcx.sess,\n-                                               tcx.span_of_impl(impl_def_id).unwrap(),\n-                                               E0119,\n-                                               \"conflicting implementations of trait `{}`{}:\",\n-                                               overlap.trait_desc,\n-                                               overlap.self_desc.clone().map_or(String::new(),\n-                                                                                |ty| {\n-                    format!(\" for type `{}`\", ty)\n-                }));\n+            let (overlap, used_to_be_allowed) = match insert_result {\n+                Err(overlap) => (Some(overlap), false),\n+                Ok(opt_overlap) => (opt_overlap, true)\n+            };\n+\n+            if let Some(overlap) = overlap {\n+                let msg = format!(\"conflicting implementations of trait `{}`{}:{}\",\n+                    overlap.trait_desc,\n+                    overlap.self_desc.clone().map_or(\n+                        String::new(), |ty| {\n+                            format!(\" for type `{}`\", ty)\n+                        }),\n+                    if used_to_be_allowed { \" (E0119)\" } else { \"\" }\n+                );\n+                let mut err = if used_to_be_allowed {\n+                    tcx.struct_span_lint_node(\n+                        lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                        tcx.hir.as_local_node_id(impl_def_id).unwrap(),\n+                        tcx.span_of_impl(impl_def_id).unwrap(),\n+                        &msg)\n+                } else {\n+                    struct_span_err!(tcx.sess,\n+                                     tcx.span_of_impl(impl_def_id).unwrap(),\n+                                     E0119,\n+                                     \"{}\",\n+                                     msg)\n+                };\n \n                 match tcx.span_of_impl(overlap.with_impl) {\n                     Ok(span) => {"}, {"sha": "834389e5d009c62145d41e7fd88b2d0698e62265", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 45, "deletions": 23, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -68,7 +68,7 @@ struct Children {\n /// The result of attempting to insert an impl into a group of children.\n enum Inserted {\n     /// The impl was inserted as a new child in this group of children.\n-    BecameNewSibling,\n+    BecameNewSibling(Option<OverlapError>),\n \n     /// The impl replaced an existing impl that specializes it.\n     Replaced(DefId),\n@@ -105,17 +105,39 @@ impl<'a, 'gcx, 'tcx> Children {\n               simplified_self: Option<SimplifiedType>)\n               -> Result<Inserted, OverlapError>\n     {\n+        let mut last_lint = None;\n+\n         for slot in match simplified_self {\n             Some(sty) => self.filtered_mut(sty),\n             None => self.iter_mut(),\n         } {\n             let possible_sibling = *slot;\n \n+            let overlap_error = |overlap: traits::coherence::OverlapResult| {\n+                // overlap, but no specialization; error out\n+                let trait_ref = overlap.impl_header.trait_ref.unwrap();\n+                let self_ty = trait_ref.self_ty();\n+                OverlapError {\n+                    with_impl: possible_sibling,\n+                    trait_desc: trait_ref.to_string(),\n+                    // only report the Self type if it has at least\n+                    // some outer concrete shell; otherwise, it's\n+                    // not adding much information.\n+                    self_desc: if self_ty.has_concrete_skeleton() {\n+                        Some(self_ty.to_string())\n+                    } else {\n+                        None\n+                    },\n+                    intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n+                }\n+            };\n+\n             let tcx = tcx.global_tcx();\n             let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n-                                                        impl_def_id);\n+                                                        impl_def_id,\n+                                                        traits::IntercrateMode::Issue43355);\n                 if let Some(overlap) = overlap {\n                     if tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n                         return Ok((false, false));\n@@ -125,22 +147,7 @@ impl<'a, 'gcx, 'tcx> Children {\n                     let ge = tcx.specializes((possible_sibling, impl_def_id));\n \n                     if le == ge {\n-                        // overlap, but no specialization; error out\n-                        let trait_ref = overlap.impl_header.trait_ref.unwrap();\n-                        let self_ty = trait_ref.self_ty();\n-                        Err(OverlapError {\n-                            with_impl: possible_sibling,\n-                            trait_desc: trait_ref.to_string(),\n-                            // only report the Self type if it has at least\n-                            // some outer concrete shell; otherwise, it's\n-                            // not adding much information.\n-                            self_desc: if self_ty.has_concrete_skeleton() {\n-                                Some(self_ty.to_string())\n-                            } else {\n-                                None\n-                            },\n-                            intercrate_ambiguity_causes: overlap.intercrate_ambiguity_causes,\n-                        })\n+                        Err(overlap_error(overlap))\n                     } else {\n                         Ok((le, ge))\n                     }\n@@ -163,14 +170,27 @@ impl<'a, 'gcx, 'tcx> Children {\n                     *slot = impl_def_id;\n                 return Ok(Inserted::Replaced(possible_sibling));\n             } else {\n+                if !tcx.impls_are_allowed_to_overlap(impl_def_id, possible_sibling) {\n+                    tcx.infer_ctxt().enter(|infcx| {\n+                        if let Some(overlap) = traits::overlapping_impls(\n+                            &infcx,\n+                            possible_sibling,\n+                            impl_def_id,\n+                            traits::IntercrateMode::Fixed)\n+                        {\n+                            last_lint = Some(overlap_error(overlap));\n+                        }\n+                    });\n+                }\n+\n                 // no overlap (error bailed already via ?)\n             }\n         }\n \n         // no overlap with any potential siblings, so add as a new sibling\n         debug!(\"placing as new sibling\");\n         self.insert_blindly(tcx, impl_def_id);\n-        Ok(Inserted::BecameNewSibling)\n+        Ok(Inserted::BecameNewSibling(last_lint))\n     }\n \n     fn iter_mut(&'a mut self) -> Box<Iterator<Item = &'a mut DefId> + 'a> {\n@@ -199,7 +219,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n     pub fn insert(&mut self,\n                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                   impl_def_id: DefId)\n-                  -> Result<(), OverlapError> {\n+                  -> Result<Option<OverlapError>, OverlapError> {\n         assert!(impl_def_id.is_local());\n \n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -220,10 +240,11 @@ impl<'a, 'gcx, 'tcx> Graph {\n             self.parent.insert(impl_def_id, trait_def_id);\n             self.children.entry(trait_def_id).or_insert(Children::new())\n                 .insert_blindly(tcx, impl_def_id);\n-            return Ok(());\n+            return Ok(None);\n         }\n \n         let mut parent = trait_def_id;\n+        let mut last_lint = None;\n         let simplified = fast_reject::simplify_type(tcx, trait_ref.self_ty(), false);\n \n         // Descend the specialization tree, where `parent` is the current parent node\n@@ -234,7 +255,8 @@ impl<'a, 'gcx, 'tcx> Graph {\n                 .insert(tcx, impl_def_id, simplified)?;\n \n             match insert_result {\n-                BecameNewSibling => {\n+                BecameNewSibling(opt_lint) => {\n+                    last_lint = opt_lint;\n                     break;\n                 }\n                 Replaced(new_child) => {\n@@ -251,7 +273,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n         }\n \n         self.parent.insert(impl_def_id, parent);\n-        Ok(())\n+        Ok(last_lint)\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent."}, {"sha": "8b41dd62742ce278fe51f92ed5f570b330daa810", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -247,11 +247,14 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             id: LintId::of(SAFE_PACKED_BORROWS),\n             reference: \"issue #46043 <https://github.com/rust-lang/rust/issues/46043>\",\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(INCOHERENT_FUNDAMENTAL_IMPLS),\n+            reference: \"issue #46205 <https://github.com/rust-lang/rust/issues/46205>\",\n+        },\n         FutureIncompatibleInfo {\n             id: LintId::of(COERCE_NEVER),\n             reference: \"issue #46325 <https://github.com/rust-lang/rust/issues/46325>\",\n         },\n-\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "07d5f813cbbce76977700c569af80bdd868a8ea3", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -12,9 +12,11 @@ use namespace::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n-use rustc::traits;\n+use rustc::traits::{self, IntercrateMode};\n use rustc::ty::TyCtxt;\n \n+use lint;\n+\n pub fn crate_inherent_impls_overlap_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                     crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);\n@@ -28,7 +30,8 @@ struct InherentOverlapChecker<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId,\n-                                       overlap: traits::OverlapResult) {\n+                                       overlap: traits::OverlapResult,\n+                                       used_to_be_allowed: bool) {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n@@ -43,11 +46,21 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n             for &item2 in &impl_items2[..] {\n                 if (name, namespace) == name_and_namespace(item2) {\n-                    let mut err = struct_span_err!(self.tcx.sess,\n-                                                   self.tcx.span_of_impl(item1).unwrap(),\n-                                                   E0592,\n-                                                   \"duplicate definitions with name `{}`\",\n-                                                   name);\n+                    let node_id = self.tcx.hir.as_local_node_id(impl1);\n+                    let mut err = if used_to_be_allowed && node_id.is_some() {\n+                        self.tcx.struct_span_lint_node(\n+                            lint::builtin::INCOHERENT_FUNDAMENTAL_IMPLS,\n+                            node_id.unwrap(),\n+                            self.tcx.span_of_impl(item1).unwrap(),\n+                            &format!(\"duplicate definitions with name `{}` (E0592)\", name)\n+                        )\n+                    } else {\n+                        struct_span_err!(self.tcx.sess,\n+                                         self.tcx.span_of_impl(item1).unwrap(),\n+                                         E0592,\n+                                         \"duplicate definitions with name `{}`\",\n+                                         name)\n+                    };\n \n                     err.span_label(self.tcx.span_of_impl(item1).unwrap(),\n                                    format!(\"duplicate definitions for `{}`\", name));\n@@ -69,12 +82,30 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt().enter(|infcx| {\n+                let used_to_be_allowed = self.tcx.infer_ctxt().enter(|infcx| {\n                     if let Some(overlap) =\n-                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id) {\n-                        self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id, overlap)\n+                        traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n+                                                  IntercrateMode::Issue43355)\n+                    {\n+                        self.check_for_common_items_in_impls(\n+                            impl1_def_id, impl2_def_id, overlap, false);\n+                        false\n+                    } else {\n+                        true\n                     }\n                 });\n+\n+                if used_to_be_allowed {\n+                    self.tcx.infer_ctxt().enter(|infcx| {\n+                        if let Some(overlap) =\n+                            traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id,\n+                                                      IntercrateMode::Fixed)\n+                        {\n+                            self.check_for_common_items_in_impls(\n+                                impl1_def_id, impl2_def_id, overlap, true);\n+                        }\n+                    });\n+                }\n             }\n         }\n     }\n@@ -100,4 +131,3 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentOverlapChecker<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }\n-"}, {"sha": "4db5c84df9a63d6f43d170da9fccb52170f8da00", "filename": "src/test/compile-fail/issue-43355.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43355.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(incoherent_fundamental_impls)]\n+\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+\n+pub trait Trait2<X> {}\n+\n+pub struct A;\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+\n+impl<X> Trait1<Box<X>> for A {\n+//~^ ERROR conflicting implementations of trait\n+//~| hard error\n+//~| downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n+    type Output = i32;\n+}\n+\n+fn main() {}"}, {"sha": "19431a6a429239eb98eb03f52047701a5ac2be2f", "filename": "src/test/run-pass/issue-43355.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Ftest%2Frun-pass%2Fissue-43355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/632ad19135a1f38c42761270ffc8a0d977b1db4c/src%2Ftest%2Frun-pass%2Fissue-43355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43355.rs?ref=632ad19135a1f38c42761270ffc8a0d977b1db4c", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that the code for issue #43355 can run without an ICE, please remove\n+// this test when it becomes an hard error.\n+\n+pub trait Trait1<X> {\n+    type Output;\n+}\n+pub trait Trait2<X> {}\n+\n+impl<X, T> Trait1<X> for T where T: Trait2<X> {\n+    type Output = ();\n+}\n+impl<X> Trait1<Box<X>> for A {\n+    type Output = i32;\n+}\n+\n+pub struct A;\n+\n+fn f<X, T: Trait1<Box<X>>>() {\n+    println!(\"k: {}\", ::std::mem::size_of::<<T as Trait1<Box<X>>>::Output>());\n+}\n+\n+pub fn g<X, T: Trait2<Box<X>>>() {\n+    f::<X, T>();\n+}\n+\n+fn main() {}"}]}