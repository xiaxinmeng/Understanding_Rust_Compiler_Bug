{"sha": "d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "node_id": "C_kwDOAAsO6NoAKGQzYjdlOTRkMGE0NDNhNGRmMTNlYjZhZWNjNzI0ZDM2YWU4MGEyOWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T13:46:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-22T13:46:23Z"}, "message": "Auto merge of #13460 - emilio:scip-cleanups, r=Veykril\n\nscip: minor clean-ups\n\nAvoids a couple redundant hash map lookups and so.", "tree": {"sha": "51b5e634a6effbc7ee74ba0d20ca1743e82644bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51b5e634a6effbc7ee74ba0d20ca1743e82644bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "html_url": "https://github.com/rust-lang/rust/commit/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b643dd6ea601aafbb636cac7792fa4fe3b6f948e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b643dd6ea601aafbb636cac7792fa4fe3b6f948e", "html_url": "https://github.com/rust-lang/rust/commit/b643dd6ea601aafbb636cac7792fa4fe3b6f948e"}, {"sha": "ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "html_url": "https://github.com/rust-lang/rust/commit/ec6d72baa104fd5428af2d5b6c09ed5546a8af40"}], "stats": {"total": 107, "additions": 38, "deletions": 69}, "files": [{"sha": "8b77ccde0ee4aaf94a4a9cfb0da3830fd44e951e", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 38, "deletions": 69, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3b7e94d0a443a4df13eb6aecc724d36ae80a29d/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=d3b7e94d0a443a4df13eb6aecc724d36ae80a29d", "patch": "@@ -8,8 +8,8 @@ use std::{\n use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n use hir::Name;\n use ide::{\n-    LineCol, MonikerDescriptorKind, MonikerResult, StaticIndex, StaticIndexedFile, TextRange,\n-    TokenId,\n+    LineCol, MonikerDescriptorKind, StaticIndex, StaticIndexedFile, TextRange, TokenId,\n+    TokenStaticData,\n };\n use ide_db::LineIndexDatabase;\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n@@ -75,7 +75,7 @@ impl flags::Scip {\n         let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n         let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n \n-        for file in si.files {\n+        for StaticIndexedFile { file_id, tokens, .. } in si.files {\n             let mut local_count = 0;\n             let mut new_local_symbol = || {\n                 let new_symbol = scip::types::Symbol::new_local(local_count);\n@@ -84,7 +84,6 @@ impl flags::Scip {\n                 new_symbol\n             };\n \n-            let StaticIndexedFile { file_id, tokens, .. } = file;\n             let relative_path = match get_relative_filepath(&vfs, &rootpath, file_id) {\n                 Some(relative_path) => relative_path,\n                 None => continue,\n@@ -107,28 +106,20 @@ impl flags::Scip {\n \n                 let mut occurrence = scip_types::Occurrence::default();\n                 occurrence.range = text_range_to_scip_range(&line_index, range);\n-                occurrence.symbol = match tokens_to_symbol.get(&id) {\n-                    Some(symbol) => symbol.clone(),\n-                    None => {\n-                        let symbol = match &token.moniker {\n-                            Some(moniker) => moniker_to_symbol(&moniker),\n-                            None => new_local_symbol(),\n-                        };\n-\n-                        let symbol = scip::symbol::format_symbol(symbol);\n-                        tokens_to_symbol.insert(id, symbol.clone());\n-                        symbol\n-                    }\n-                };\n+                occurrence.symbol = tokens_to_symbol\n+                    .entry(id)\n+                    .or_insert_with(|| {\n+                        let symbol = token_to_symbol(&token).unwrap_or_else(&mut new_local_symbol);\n+                        scip::symbol::format_symbol(symbol)\n+                    })\n+                    .clone();\n \n                 if let Some(def) = token.definition {\n                     if def.range == range {\n                         occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n                     }\n \n-                    if !symbols_emitted.contains(&id) {\n-                        symbols_emitted.insert(id);\n-\n+                    if symbols_emitted.insert(id) {\n                         let mut symbol_info = scip_types::SymbolInformation::default();\n                         symbol_info.symbol = occurrence.symbol.clone();\n                         if let Some(hover) = &token.hover {\n@@ -207,9 +198,11 @@ fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_ty\n ///\n /// Only returns a Symbol when it's a non-local symbol.\n ///     So if the visibility isn't outside of a document, then it will return None\n-fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n+fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n     use scip_types::descriptor::Suffix::*;\n \n+    let moniker = token.moniker.as_ref()?;\n+\n     let package_name = moniker.package_information.name.clone();\n     let version = moniker.package_information.version.clone();\n     let descriptors = moniker\n@@ -233,7 +226,7 @@ fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n         })\n         .collect();\n \n-    scip_types::Symbol {\n+    Some(scip_types::Symbol {\n         scheme: \"rust-analyzer\".into(),\n         package: Some(scip_types::Package {\n             manager: \"cargo\".to_string(),\n@@ -244,19 +237,15 @@ fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n         .into(),\n         descriptors,\n         ..Default::default()\n-    }\n+    })\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n-    use hir::Semantics;\n-    use ide::{AnalysisHost, FilePosition};\n-    use ide_db::defs::IdentClass;\n-    use ide_db::{base_db::fixture::ChangeFixture, helpers::pick_best_token};\n+    use ide::{AnalysisHost, FilePosition, StaticIndex, TextSize};\n+    use ide_db::base_db::fixture::ChangeFixture;\n     use scip::symbol::format_symbol;\n-    use syntax::SyntaxKind::*;\n-    use syntax::{AstNode, T};\n \n     fn position(ra_fixture: &str) -> (AnalysisHost, FilePosition) {\n         let mut host = AnalysisHost::default();\n@@ -273,53 +262,33 @@ mod test {\n     fn check_symbol(ra_fixture: &str, expected: &str) {\n         let (host, position) = position(ra_fixture);\n \n+        let analysis = host.analysis();\n+        let si = StaticIndex::compute(&analysis);\n+\n         let FilePosition { file_id, offset } = position;\n \n-        let db = host.raw_database();\n-        let sema = &Semantics::new(db);\n-        let file = sema.parse(file_id).syntax().clone();\n-        let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-            IDENT\n-            | INT_NUMBER\n-            | LIFETIME_IDENT\n-            | T![self]\n-            | T![super]\n-            | T![crate]\n-            | T![Self]\n-            | COMMENT => 2,\n-            kind if kind.is_trivia() => 0,\n-            _ => 1,\n-        })\n-        .expect(\"OK OK\");\n-\n-        let navs = sema\n-            .descend_into_macros(original_token.clone())\n-            .into_iter()\n-            .filter_map(|token| {\n-                IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n-                    it.into_iter().flat_map(|def| {\n-                        let module = def.module(db).unwrap();\n-                        let current_crate = module.krate();\n-\n-                        match MonikerResult::from_def(sema.db, def, current_crate) {\n-                            Some(moniker_result) => Some(moniker_to_symbol(&moniker_result)),\n-                            None => None,\n-                        }\n-                    })\n-                })\n-            })\n-            .flatten()\n-            .collect::<Vec<_>>();\n+        let mut found_symbol = None;\n+        for file in &si.files {\n+            if file.file_id != file_id {\n+                continue;\n+            }\n+            for &(range, id) in &file.tokens {\n+                if range.contains(offset - TextSize::from(1)) {\n+                    let token = si.tokens.get(id).unwrap();\n+                    found_symbol = token_to_symbol(token);\n+                    break;\n+                }\n+            }\n+        }\n \n         if expected == \"\" {\n-            assert_eq!(0, navs.len(), \"must have no symbols {:?}\", navs);\n+            assert!(found_symbol.is_none(), \"must have no symbols {:?}\", found_symbol);\n             return;\n         }\n \n-        assert_eq!(1, navs.len(), \"must have one symbol {:?}\", navs);\n-\n-        let res = navs.get(0).unwrap();\n-        let formatted = format_symbol(res.clone());\n+        assert!(found_symbol.is_some(), \"must have one symbol {:?}\", found_symbol);\n+        let res = found_symbol.unwrap();\n+        let formatted = format_symbol(res);\n         assert_eq!(formatted, expected);\n     }\n "}]}