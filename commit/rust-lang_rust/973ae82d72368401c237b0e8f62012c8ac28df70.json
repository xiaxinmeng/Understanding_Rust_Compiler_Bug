{"sha": "973ae82d72368401c237b0e8f62012c8ac28df70", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3M2FlODJkNzIzNjg0MDFjMjM3YjBlOGY2MjAxMmM4YWMyOGRmNzA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-18T07:43:35Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-18T07:43:35Z"}, "message": "Merge branch 'pr-942'", "tree": {"sha": "aa23974ae84301011260d33535631059b9c1fae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa23974ae84301011260d33535631059b9c1fae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/973ae82d72368401c237b0e8f62012c8ac28df70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/973ae82d72368401c237b0e8f62012c8ac28df70", "html_url": "https://github.com/rust-lang/rust/commit/973ae82d72368401c237b0e8f62012c8ac28df70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/973ae82d72368401c237b0e8f62012c8ac28df70/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a309af2f3855ed16f4f914ccbe13bce7de6c59a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a309af2f3855ed16f4f914ccbe13bce7de6c59a", "html_url": "https://github.com/rust-lang/rust/commit/6a309af2f3855ed16f4f914ccbe13bce7de6c59a"}, {"sha": "86a2c9440dff5d09d149d7e3d5922da987ab92c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/86a2c9440dff5d09d149d7e3d5922da987ab92c9", "html_url": "https://github.com/rust-lang/rust/commit/86a2c9440dff5d09d149d7e3d5922da987ab92c9"}], "stats": {"total": 203, "additions": 99, "deletions": 104}, "files": [{"sha": "017e24b1034684a5f262ed302076fff2e8151ecb", "filename": "CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/973ae82d72368401c237b0e8f62012c8ac28df70/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/973ae82d72368401c237b0e8f62012c8ac28df70/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=973ae82d72368401c237b0e8f62012c8ac28df70", "patch": "@@ -1,6 +1,10 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.68 \u2014 2016-05-17\n+* Rustup to *rustc 1.10.0-nightly (cd6a40017 2016-05-16)*\n+* New lint: [`unnecessary_operation`]\n+\n ## 0.0.67 \u2014 2016-05-12\n * Rustup to *rustc 1.10.0-nightly (22ac88f1a 2016-05-11)*\n "}, {"sha": "49053ea1e4f07dbff23d1c514afc52db9ad6f211", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/973ae82d72368401c237b0e8f62012c8ac28df70/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/973ae82d72368401c237b0e8f62012c8ac28df70/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=973ae82d72368401c237b0e8f62012c8ac28df70", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.67\"\n+version = \"0.0.68\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\","}, {"sha": "b6dea8316901c083ed1f78ed90a8732c1019aaf9", "filename": "src/len_zero.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/973ae82d72368401c237b0e8f62012c8ac28df70/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973ae82d72368401c237b0e8f62012c8ac28df70/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=973ae82d72368401c237b0e8f62012c8ac28df70", "patch": "@@ -126,10 +126,10 @@ fn check_impl_items(cx: &LateContext, item: &Item, impl_items: &[ImplItem]) {\n }\n \n fn is_self_sig(sig: &MethodSig) -> bool {\n-    if let SelfStatic = sig.explicit_self.node {\n-        false\n-    } else {\n+    if sig.decl.has_self() {\n         sig.decl.inputs.len() == 1\n+    } else {\n+        false\n     }\n }\n "}, {"sha": "797e9708b60900eb0e7e33931fad0257b39cea53", "filename": "src/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/973ae82d72368401c237b0e8f62012c8ac28df70/src%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973ae82d72368401c237b0e8f62012c8ac28df70/src%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flifetimes.rs?ref=973ae82d72368401c237b0e8f62012c8ac28df70", "patch": "@@ -46,19 +46,19 @@ impl LintPass for LifetimePass {\n impl LateLintPass for LifetimePass {\n     fn check_item(&mut self, cx: &LateContext, item: &Item) {\n         if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n-            check_fn_inner(cx, decl, None, generics, item.span);\n+            check_fn_inner(cx, decl, generics, item.span);\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n-            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self), &sig.generics, item.span);\n+            check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n-            check_fn_inner(cx, &sig.decl, Some(&sig.explicit_self), &sig.generics, item.span);\n+            check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n     }\n }\n@@ -87,7 +87,7 @@ fn bound_lifetimes(bound: &TyParamBound) -> Option<HirVec<&Lifetime>> {\n     }\n }\n \n-fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, generics: &Generics, span: Span) {\n+fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Span) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n@@ -96,16 +96,16 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, slf: Option<&ExplicitSelf>, g\n                              .iter()\n                              .flat_map(|ref typ| typ.bounds.iter().filter_map(bound_lifetimes).flat_map(|lts| lts));\n \n-    if could_use_elision(cx, decl, slf, &generics.lifetimes, bounds_lts) {\n+    if could_use_elision(cx, decl, &generics.lifetimes, bounds_lts) {\n         span_lint(cx,\n                   NEEDLESS_LIFETIMES,\n                   span,\n                   \"explicit lifetimes given in parameter types where they could be elided\");\n     }\n-    report_extra_lifetimes(cx, decl, generics, slf);\n+    report_extra_lifetimes(cx, decl, generics);\n }\n \n-fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl, slf: Option<&ExplicitSelf>,\n+fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl,\n                                                            named_lts: &[LifetimeDef], bounds_lts: T)\n                                                            -> bool {\n     // There are two scenarios where elision works:\n@@ -121,15 +121,6 @@ fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, fun\n     let mut input_visitor = RefVisitor::new(cx);\n     let mut output_visitor = RefVisitor::new(cx);\n \n-    // extract lifetime in \"self\" argument for methods (there is a \"self\" argument\n-    // in func.inputs, but its type is TyInfer)\n-    if let Some(slf) = slf {\n-        match slf.node {\n-            SelfRegion(ref opt_lt, _, _) => input_visitor.record(opt_lt),\n-            SelfExplicit(ref ty, _) => walk_ty(&mut input_visitor, ty),\n-            _ => (),\n-        }\n-    }\n     // extract lifetimes in input argument types\n     for arg in &func.inputs {\n         input_visitor.visit_ty(&arg.ty);\n@@ -340,7 +331,7 @@ impl<'v> Visitor<'v> for LifetimeChecker {\n     }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics, slf: Option<&ExplicitSelf>) {\n+fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics) {\n     let hs = generics.lifetimes\n                      .iter()\n                      .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n@@ -350,14 +341,6 @@ fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics,\n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n \n-    if let Some(slf) = slf {\n-        match slf.node {\n-            SelfRegion(Some(ref lt), _, _) => checker.visit_lifetime(lt),\n-            SelfExplicit(ref t, _) => walk_ty(&mut checker, t),\n-            _ => (),\n-        }\n-    }\n-\n     for &v in checker.0.values() {\n         span_lint(cx, UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n     }"}, {"sha": "ecbdb62f05ed467f7a97db76dc3515a0e4234273", "filename": "src/methods.rs", "status": "modified", "additions": 77, "deletions": 75, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/973ae82d72368401c237b0e8f62012c8ac28df70/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973ae82d72368401c237b0e8f62012c8ac28df70/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=973ae82d72368401c237b0e8f62012c8ac28df70", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::*;\n+use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::const_qualif::ConstQualif;\n@@ -335,13 +335,13 @@ impl LintPass for MethodsPass {\n }\n \n impl LateLintPass for MethodsPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n \n         match expr.node {\n-            ExprMethodCall(name, _, ref args) => {\n+            hir::ExprMethodCall(name, _, ref args) => {\n                 // Chain calls\n                 if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                     lint_unwrap(cx, expr, arglists[0]);\n@@ -384,90 +384,92 @@ impl LateLintPass for MethodsPass {\n                     _ => (),\n                 }\n             }\n-            ExprBinary(op, ref lhs, ref rhs) if op.node == BiEq || op.node == BiNe => {\n-                if !lint_chars_next(cx, expr, lhs, rhs, op.node == BiEq) {\n-                    lint_chars_next(cx, expr, rhs, lhs, op.node == BiEq);\n+            hir::ExprBinary(op, ref lhs, ref rhs) if op.node == hir::BiEq || op.node == hir::BiNe => {\n+                if !lint_chars_next(cx, expr, lhs, rhs, op.node == hir::BiEq) {\n+                    lint_chars_next(cx, expr, rhs, lhs, op.node == hir::BiEq);\n                 }\n             }\n             _ => (),\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n         if in_external_macro(cx, item.span) {\n             return;\n         }\n \n-        if let ItemImpl(_, _, _, None, _, ref items) = item.node {\n+        if let hir::ItemImpl(_, _, _, None, _, ref items) = item.node {\n             for implitem in items {\n                 let name = implitem.name;\n-                if let ImplItemKind::Method(ref sig, _) = implitem.node {\n+                if_let_chain! {[\n+                    let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n+                    let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n+                ], {\n                     // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                        if_let_chain! {\n-                            [\n-                                name.as_str() == method_name,\n-                                sig.decl.inputs.len() == n_args,\n-                                out_type.matches(&sig.decl.output),\n-                                self_kind.matches(&sig.explicit_self.node, false)\n-                            ], {\n-                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n-                                    \"defining a method called `{}` on this type; consider implementing \\\n-                                     the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                            }\n+                        if name.as_str() == method_name &&\n+                           sig.decl.inputs.len() == n_args &&\n+                           out_type.matches(&sig.decl.output) &&\n+                           self_kind.matches(&explicit_self, false) {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n+                                \"defining a method called `{}` on this type; consider implementing \\\n+                                 the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n                         }\n                     }\n \n                     // check conventions w.r.t. conversion method names and predicates\n                     let ty = cx.tcx.lookup_item_type(cx.tcx.map.local_def_id(item.id)).ty;\n                     let is_copy = is_copy(cx, ty, item);\n                     for &(ref conv, self_kinds) in &CONVENTIONS {\n-                        if conv.check(&name.as_str()) &&\n-                           !self_kinds.iter().any(|k| k.matches(&sig.explicit_self.node, is_copy)) {\n-                            let lint = if item.vis == Visibility::Public {\n+                        if_let_chain! {[\n+                            conv.check(&name.as_str()),\n+                            let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n+                            !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n+                        ], {\n+                            let lint = if item.vis == hir::Visibility::Public {\n                                 WRONG_PUB_SELF_CONVENTION\n                             } else {\n                                 WRONG_SELF_CONVENTION\n                             };\n                             span_lint(cx,\n                                       lint,\n-                                      sig.explicit_self.span,\n+                                      explicit_self.span,\n                                       &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n                                                 ambiguous name\",\n                                                conv,\n                                                &self_kinds.iter()\n                                                           .map(|k| k.description())\n                                                           .collect::<Vec<_>>()\n                                                           .join(\" or \")));\n-                        }\n+                        }}\n                     }\n \n                     let ret_ty = return_ty(cx, implitem.id);\n                     if &name.as_str() == &\"new\" &&\n                        !ret_ty.map_or(false, |ret_ty| ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id))) {\n                         span_lint(cx,\n                                   NEW_RET_NO_SELF,\n-                                  sig.explicit_self.span,\n+                                  explicit_self.span,\n                                   \"methods called `new` usually return `Self`\");\n                     }\n                 }\n-            }\n+            }}\n         }\n     }\n }\n \n /// Checks for the `OR_FUN_CALL` lint.\n-fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n+fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[P<hir::Expr>]) {\n     /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n-    fn check_unwrap_or_default(cx: &LateContext, name: &str, fun: &Expr, self_expr: &Expr, arg: &Expr,\n+    fn check_unwrap_or_default(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr,\n                                or_has_args: bool, span: Span)\n                                -> bool {\n         if or_has_args {\n             return false;\n         }\n \n         if name == \"unwrap_or\" {\n-            if let ExprPath(_, ref path) = fun.node {\n+            if let hir::ExprPath(_, ref path) = fun.node {\n                 let path: &str = &path.segments\n                                       .last()\n                                       .expect(\"A path must have at least one segment\")\n@@ -501,7 +503,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n     }\n \n     /// Check for `*or(foo())`.\n-    fn check_general_case(cx: &LateContext, name: &str, fun: &Expr, self_expr: &Expr, arg: &Expr, or_has_args: bool,\n+    fn check_general_case(cx: &LateContext, name: &str, fun: &hir::Expr, self_expr: &hir::Expr, arg: &hir::Expr, or_has_args: bool,\n                           span: Span) {\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n@@ -545,7 +547,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n     }\n \n     if args.len() == 2 {\n-        if let ExprCall(ref fun, ref or_args) = args[1].node {\n+        if let hir::ExprCall(ref fun, ref or_args) = args[1].node {\n             let or_has_args = !or_args.is_empty();\n             if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n                 check_general_case(cx, name, fun, &args[0], &args[1], or_has_args, expr.span);\n@@ -555,7 +557,7 @@ fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>])\n }\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-fn lint_clone_on_copy(cx: &LateContext, expr: &Expr) {\n+fn lint_clone_on_copy(cx: &LateContext, expr: &hir::Expr) {\n     let ty = cx.tcx.expr_ty(expr);\n     let parent = cx.tcx.map.get_parent(expr.id);\n     let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n@@ -566,7 +568,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &Expr) {\n }\n \n /// Checks for the `CLONE_DOUBLE_REF` lint.\n-fn lint_clone_double_ref(cx: &LateContext, expr: &Expr, arg: &Expr, ty: ty::Ty) {\n+fn lint_clone_double_ref(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, ty: ty::Ty) {\n     if let ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) = ty.sty {\n         if let ty::TyRef(..) = inner.sty {\n             let mut db = span_lint(cx,\n@@ -582,7 +584,7 @@ fn lint_clone_double_ref(cx: &LateContext, expr: &Expr, arg: &Expr, ty: ty::Ty)\n     }\n }\n \n-fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n+fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&args[0]));\n     if !match_type(cx, obj_ty, &paths::VEC) {\n         return;\n@@ -599,11 +601,11 @@ fn lint_extend(cx: &LateContext, expr: &Expr, args: &MethodArgs) {\n     }\n }\n \n-fn lint_cstring_as_ptr(cx: &LateContext, expr: &Expr, new: &Expr, unwrap: &Expr) {\n+fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n     if_let_chain!{[\n-        let ExprCall(ref fun, ref args) = new.node,\n+        let hir::ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n-        let ExprPath(None, ref path) = fun.node,\n+        let hir::ExprPath(None, ref path) = fun.node,\n         match_path(path, &paths::CSTRING_NEW),\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n@@ -615,7 +617,7 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &Expr, new: &Expr, unwrap: &Expr)\n     }}\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span, &'static str)> {\n+fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: &ty::Ty) -> Option<(Span, &'static str)> {\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n@@ -626,7 +628,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span,\n             _ => false,\n         }\n     }\n-    if let ExprMethodCall(name, _, ref args) = expr.node {\n+    if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n         if &name.node.as_str() == &\"iter\" && may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n             Some((args[0].span, \"&\"))\n         } else {\n@@ -651,7 +653,7 @@ fn derefs_to_slice(cx: &LateContext, expr: &Expr, ty: &ty::Ty) -> Option<(Span,\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s\n-fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n+fn lint_unwrap(cx: &LateContext, expr: &hir::Expr, unwrap_args: &MethodArgs) {\n     let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.expr_ty(&unwrap_args[0]));\n \n     let mess = if match_type(cx, obj_ty, &paths::OPTION) {\n@@ -677,7 +679,7 @@ fn lint_unwrap(cx: &LateContext, expr: &Expr, unwrap_args: &MethodArgs) {\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `ok().expect()` for `Result`s\n-fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n+fn lint_ok_expect(cx: &LateContext, expr: &hir::Expr, ok_args: &MethodArgs) {\n     // lint if the caller of `ok()` is a `Result`\n     if match_type(cx, cx.tcx.expr_ty(&ok_args[0]), &paths::RESULT) {\n         let result_type = cx.tcx.expr_ty(&ok_args[0]);\n@@ -695,7 +697,7 @@ fn lint_ok_expect(cx: &LateContext, expr: &Expr, ok_args: &MethodArgs) {\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or()` for `Option`s\n-fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n+fn lint_map_unwrap_or(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n@@ -726,7 +728,7 @@ fn lint_map_unwrap_or(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwr\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `map().unwrap_or_else()` for `Option`s\n-fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n+fn lint_map_unwrap_or_else(cx: &LateContext, expr: &hir::Expr, map_args: &MethodArgs, unwrap_args: &MethodArgs) {\n     // lint if the caller of `map()` is an `Option`\n     if match_type(cx, cx.tcx.expr_ty(&map_args[0]), &paths::OPTION) {\n         // lint message\n@@ -757,7 +759,7 @@ fn lint_map_unwrap_or_else(cx: &LateContext, expr: &Expr, map_args: &MethodArgs,\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `filter().next() for Iterators`\n-fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n+fn lint_filter_next(cx: &LateContext, expr: &hir::Expr, filter_args: &MethodArgs) {\n     // lint if caller of `.filter().next()` is an Iterator\n     if match_trait_method(cx, expr, &paths::ITERATOR) {\n         let msg = \"called `filter(p).next()` on an Iterator. This is more succinctly expressed by calling `.find(p)` \\\n@@ -780,7 +782,7 @@ fn lint_filter_next(cx: &LateContext, expr: &Expr, filter_args: &MethodArgs) {\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint searching an Iterator followed by `is_some()`\n-fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, search_args: &MethodArgs,\n+fn lint_search_is_some(cx: &LateContext, expr: &hir::Expr, search_method: &str, search_args: &MethodArgs,\n                        is_some_args: &MethodArgs) {\n     // lint if caller of search is an Iterator\n     if match_trait_method(cx, &*is_some_args[0], &paths::ITERATOR) {\n@@ -803,12 +805,12 @@ fn lint_search_is_some(cx: &LateContext, expr: &Expr, search_method: &str, searc\n }\n \n /// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next(cx: &LateContext, expr: &Expr, chain: &Expr, other: &Expr, eq: bool) -> bool {\n+fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other: &hir::Expr, eq: bool) -> bool {\n     if_let_chain! {[\n         let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n-        let ExprCall(ref fun, ref arg_char) = other.node,\n+        let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n-        let ExprPath(None, ref path) = fun.node,\n+        let hir::ExprPath(None, ref path) = fun.node,\n         path.segments.len() == 1 && path.segments[0].identifier.name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.expr_ty_adjusted(&args[0][0]));\n@@ -838,7 +840,7 @@ fn lint_chars_next(cx: &LateContext, expr: &Expr, chain: &Expr, other: &Expr, eq\n }\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-fn lint_single_char_pattern(cx: &LateContext, expr: &Expr, arg: &Expr) {\n+fn lint_single_char_pattern(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr) {\n     if let Ok(ConstVal::Str(r)) = eval_const_expr_partial(cx.tcx, arg, ExprTypeChecked, None) {\n         if r.len() == 1 {\n             let hint = snippet(cx, expr.span, \"..\").replace(&format!(\"\\\"{}\\\"\", r), &format!(\"'{}'\", r));\n@@ -954,26 +956,26 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(&self, slf: &ExplicitSelf_, allow_value_for_ref: bool) -> bool {\n-        match (self, slf) {\n-            (&SelfKind::Value, &SelfValue(_)) |\n-            (&SelfKind::Ref, &SelfRegion(_, Mutability::MutImmutable, _)) |\n-            (&SelfKind::RefMut, &SelfRegion(_, Mutability::MutMutable, _)) |\n-            (&SelfKind::No, &SelfStatic) => true,\n-            (&SelfKind::Ref, &SelfValue(_)) |\n-            (&SelfKind::RefMut, &SelfValue(_)) => allow_value_for_ref,\n-            (_, &SelfExplicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n+    fn matches(self, slf: &hir::ExplicitSelf, allow_value_for_ref: bool) -> bool {\n+        match (self, &slf.node) {\n+            (SelfKind::Value, &hir::SelfKind::Value(_)) |\n+            (SelfKind::Ref, &hir::SelfKind::Region(_, hir::Mutability::MutImmutable)) |\n+            (SelfKind::RefMut, &hir::SelfKind::Region(_, hir::Mutability::MutMutable)) => true,\n+            (SelfKind::Ref, &hir::SelfKind::Value(_)) |\n+            (SelfKind::RefMut, &hir::SelfKind::Value(_)) => allow_value_for_ref,\n+            (_, &hir::SelfKind::Explicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n+\n             _ => false,\n         }\n     }\n \n-    fn matches_explicit_type(&self, ty: &Ty, allow_value_for_ref: bool) -> bool {\n+    fn matches_explicit_type(self, ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n         match (self, &ty.node) {\n-            (&SelfKind::Value, &TyPath(..)) |\n-            (&SelfKind::Ref, &TyRptr(_, MutTy { mutbl: Mutability::MutImmutable, .. })) |\n-            (&SelfKind::RefMut, &TyRptr(_, MutTy { mutbl: Mutability::MutMutable, .. })) => true,\n-            (&SelfKind::Ref, &TyPath(..)) |\n-            (&SelfKind::RefMut, &TyPath(..)) => allow_value_for_ref,\n+            (SelfKind::Value, &hir::TyPath(..)) |\n+            (SelfKind::Ref, &hir::TyRptr(_, hir::MutTy { mutbl: hir::Mutability::MutImmutable, .. })) |\n+            (SelfKind::RefMut, &hir::TyRptr(_, hir::MutTy { mutbl: hir::Mutability::MutMutable, .. })) => true,\n+            (SelfKind::Ref, &hir::TyPath(..)) |\n+            (SelfKind::RefMut, &hir::TyPath(..)) => allow_value_for_ref,\n             _ => false,\n         }\n     }\n@@ -1015,14 +1017,14 @@ enum OutType {\n }\n \n impl OutType {\n-    fn matches(&self, ty: &FunctionRetTy) -> bool {\n+    fn matches(&self, ty: &hir::FunctionRetTy) -> bool {\n         match (self, ty) {\n-            (&OutType::Unit, &DefaultReturn(_)) => true,\n-            (&OutType::Unit, &Return(ref ty)) if ty.node == TyTup(vec![].into()) => true,\n-            (&OutType::Bool, &Return(ref ty)) if is_bool(ty) => true,\n-            (&OutType::Any, &Return(ref ty)) if ty.node != TyTup(vec![].into()) => true,\n-            (&OutType::Ref, &Return(ref ty)) => {\n-                if let TyRptr(_, _) = ty.node {\n+            (&OutType::Unit, &hir::DefaultReturn(_)) => true,\n+            (&OutType::Unit, &hir::Return(ref ty)) if ty.node == hir::TyTup(vec![].into()) => true,\n+            (&OutType::Bool, &hir::Return(ref ty)) if is_bool(ty) => true,\n+            (&OutType::Any, &hir::Return(ref ty)) if ty.node != hir::TyTup(vec![].into()) => true,\n+            (&OutType::Ref, &hir::Return(ref ty)) => {\n+                if let hir::TyRptr(_, _) = ty.node {\n                     true\n                 } else {\n                     false\n@@ -1033,16 +1035,16 @@ impl OutType {\n     }\n }\n \n-fn is_bool(ty: &Ty) -> bool {\n-    if let TyPath(None, ref p) = ty.node {\n+fn is_bool(ty: &hir::Ty) -> bool {\n+    if let hir::TyPath(None, ref p) = ty.node {\n         if match_path(p, &[\"bool\"]) {\n             return true;\n         }\n     }\n     false\n }\n \n-fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, item: &Item) -> bool {\n+fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, item: &hir::Item) -> bool {\n     let env = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n     !ty.subst(cx.tcx, env.free_substs).moves_by_default(cx.tcx.global_tcx(), &env, item.span)\n }"}, {"sha": "19502720993b641a5be782c161d6cb8dc364d60f", "filename": "tests/compile-fail/unused_lt.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/973ae82d72368401c237b0e8f62012c8ac28df70/tests%2Fcompile-fail%2Funused_lt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/973ae82d72368401c237b0e8f62012c8ac28df70/tests%2Fcompile-fail%2Funused_lt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funused_lt.rs?ref=973ae82d72368401c237b0e8f62012c8ac28df70", "patch": "@@ -44,6 +44,12 @@ impl<'a> Foo<'a> for u8 {\n     }\n }\n \n+struct Bar;\n+\n+impl Bar {\n+    fn x<'a>(&self) {} //~ ERROR this lifetime\n+}\n+\n // test for #489 (used lifetimes in bounds)\n pub fn parse<'a, I: Iterator<Item=&'a str>>(_it: &mut I) {\n     unimplemented!()"}]}