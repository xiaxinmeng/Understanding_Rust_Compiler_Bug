{"sha": "f3990feb2e411d0826dfb83aa7078468da5d1907", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzOTkwZmViMmU0MTFkMDgyNmRmYjgzYWE3MDc4NDY4ZGE1ZDE5MDc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-15T01:16:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:58Z"}, "message": "create a trait to ensure that data is tracked\n\nAlso write a comment explaining the system.", "tree": {"sha": "322e36b567dc89923a6f127940c314c1489ec82d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322e36b567dc89923a6f127940c314c1489ec82d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3990feb2e411d0826dfb83aa7078468da5d1907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3990feb2e411d0826dfb83aa7078468da5d1907", "html_url": "https://github.com/rust-lang/rust/commit/f3990feb2e411d0826dfb83aa7078468da5d1907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3990feb2e411d0826dfb83aa7078468da5d1907/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00e699faf3ec39715477b8386fba9deab2e2c925", "url": "https://api.github.com/repos/rust-lang/rust/commits/00e699faf3ec39715477b8386fba9deab2e2c925", "html_url": "https://github.com/rust-lang/rust/commit/00e699faf3ec39715477b8386fba9deab2e2c925"}], "stats": {"total": 139, "additions": 117, "deletions": 22}, "files": [{"sha": "494699af7ba1a4f3ea9d920823d76a18db057407", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f3990feb2e411d0826dfb83aa7078468da5d1907/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3990feb2e411d0826dfb83aa7078468da5d1907/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f3990feb2e411d0826dfb83aa7078468da5d1907", "patch": "@@ -53,7 +53,7 @@ use rustc::hir::intravisit::Visitor;\n use rustc::hir::intravisit;\n use rustc::hir::map::DefKey;\n \n-use super::index_builder::{IndexBuilder, ItemContentBuilder, XRef};\n+use super::index_builder::{FromId, IndexBuilder, ItemContentBuilder, XRef};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n@@ -198,24 +198,23 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n \n impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n     fn encode_enum_variant_infos(&mut self,\n-                                 enum_did: DefId,\n-                                 vis: &hir::Visibility) {\n+                                 enum_did: DefId) {\n         debug!(\"encode_enum_variant_info(enum_did={:?})\", enum_did);\n         let ecx = self.ecx();\n         let def = ecx.tcx.lookup_adt_def(enum_did);\n         self.encode_fields(enum_did);\n         for (i, variant) in def.variants.iter().enumerate() {\n             self.record(variant.did,\n                         ItemContentBuilder::encode_enum_variant_info,\n-                        (enum_did, i, vis));\n+                        (enum_did, i));\n         }\n     }\n }\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_enum_variant_info(&mut self,\n-                                (enum_did, index, vis):\n-                                (DefId, usize, &hir::Visibility)) {\n+                                (enum_did, index):\n+                                (DefId, usize)) {\n         let ecx = self.ecx;\n         let def = ecx.tcx.lookup_adt_def(enum_did);\n         let variant = &def.variants[index];\n@@ -229,7 +228,10 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n         });\n         encode_name(self.rbml_w, variant.name);\n         self.encode_parent_item(enum_did);\n-        self.encode_visibility(vis);\n+\n+        let enum_id = ecx.tcx.map.as_local_node_id(enum_did).unwrap();\n+        let enum_vis = &ecx.tcx.map.expect_item(enum_id).vis;\n+        self.encode_visibility(enum_vis);\n \n         let attrs = ecx.tcx.get_attrs(vid);\n         encode_attributes(self.rbml_w, &attrs);\n@@ -294,8 +296,8 @@ fn encode_reexports(ecx: &EncodeContext,\n \n impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     fn encode_info_for_mod(&mut self,\n-                           (md, attrs, id, name, vis):\n-                           (&hir::Mod, &[ast::Attribute], NodeId, Name, &hir::Visibility)) {\n+                           FromId(id, (md, attrs, name, vis)):\n+                           FromId<(&hir::Mod, &[ast::Attribute], Name, &hir::Visibility)>) {\n         let ecx = self.ecx();\n \n         encode_def_id_and_key(ecx, self.rbml_w, ecx.tcx.map.local_def_id(id));\n@@ -936,7 +938,7 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n                 self.encode_method_argument_names(&decl);\n             }\n             hir::ItemMod(ref m) => {\n-                self.encode_info_for_mod((m, &item.attrs, item.id, item.name, &item.vis));\n+                self.encode_info_for_mod(FromId(item.id, (m, &item.attrs, item.name, &item.vis)));\n             }\n             hir::ItemForeignMod(ref fm) => {\n                 encode_def_id_and_key(ecx, self.rbml_w, def_id);\n@@ -1166,7 +1168,7 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                 // no sub-item recording needed in these cases\n             }\n             hir::ItemEnum(..) => {\n-                self.encode_enum_variant_infos(def_id, &item.vis);\n+                self.encode_enum_variant_infos(def_id);\n             }\n             hir::ItemStruct(ref struct_def, _) => {\n                 self.encode_addl_struct_info(def_id, struct_def.id(), item);\n@@ -1395,11 +1397,10 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n         let mut index = IndexBuilder::new(ecx, rbml_w);\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      ItemContentBuilder::encode_info_for_mod,\n-                     (&krate.module,\n-                      &[],\n-                      CRATE_NODE_ID,\n-                      syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                      &hir::Public));\n+                     FromId(CRATE_NODE_ID, (&krate.module,\n+                                            &[],\n+                                            syntax::parse::token::intern(&ecx.link_meta.crate_name),\n+                                            &hir::Public)));\n         krate.visit_all_items(&mut EncodeVisitor {\n             index: &mut index,\n         });"}, {"sha": "c7ee3efaa81d3253d5dd6db9a79754404441fcce", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 100, "deletions": 6, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/f3990feb2e411d0826dfb83aa7078468da5d1907/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3990feb2e411d0826dfb83aa7078468da5d1907/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=f3990feb2e411d0826dfb83aa7078468da5d1907", "patch": "@@ -13,9 +13,11 @@ use encoder::EncodeContext;\n use index::IndexData;\n use rbml::writer::Encoder;\n use rustc::dep_graph::DepNode;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fnv::FnvHashMap;\n+use syntax::ast;\n use std::ops::{Deref, DerefMut};\n \n /// Builder that can encode new items, adding them into the index.\n@@ -51,21 +53,34 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n         }\n     }\n \n-    /// Records that `id` is being emitted at the current offset.\n-    /// This data is later used to construct the item index in the\n-    /// metadata so we can quickly find the data for a given item.\n+    /// Emit the data for a def-id to the metadata. The function to\n+    /// emit the data is `op`, and it will be given `data` as\n+    /// arguments. This `record` function will start/end an RBML tag\n+    /// and record the current offset for use in the index, calling\n+    /// `op` to generate the data in the RBML tag.\n     ///\n-    /// Returns a dep-graph task that you should keep live as long as\n-    /// the data for this item is being emitted.\n+    /// In addition, it will setup a dep-graph task to track what data\n+    /// `op` accesses to generate the metadata, which is later used by\n+    /// incremental compilation to compute a hash for the metadata and\n+    /// track changes.\n+    ///\n+    /// The reason that `op` is a function pointer, and not a closure,\n+    /// is that we want to be able to completely track all data it has\n+    /// access to, so that we can be sure that `DATA: DepGraphRead`\n+    /// holds, and that it is therefore not gaining \"secret\" access to\n+    /// bits of HIR or other state that would not be trackd by the\n+    /// content system.\n     pub fn record<DATA>(&mut self,\n                         id: DefId,\n                         op: fn(&mut ItemContentBuilder<'a, 'tcx, 'encoder>, DATA),\n                         data: DATA)\n+        where DATA: DepGraphRead\n     {\n         let position = self.rbml_w.mark_stable_position();\n         self.items.record(id, position);\n         let _task = self.ecx.tcx.dep_graph.in_task(DepNode::MetaData(id));\n         self.rbml_w.start_tag(tag_items_data_item).unwrap();\n+        data.read(self.ecx.tcx);\n         op(self, data);\n         self.rbml_w.end_tag().unwrap();\n     }\n@@ -100,3 +115,82 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n+/// Trait that registers reads for types that are tracked in the\n+/// dep-graph. Mostly it is implemented for indices like DefId etc\n+/// which do not need to register a read.\n+pub trait DepGraphRead {\n+    fn read(&self, tcx: TyCtxt);\n+}\n+\n+impl DepGraphRead for usize {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n+impl DepGraphRead for DefId {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n+impl DepGraphRead for ast::NodeId {\n+    fn read(&self, _tcx: TyCtxt) { }\n+}\n+\n+impl<T> DepGraphRead for Option<T>\n+    where T: DepGraphRead\n+{\n+    fn read(&self, tcx: TyCtxt) {\n+        match *self {\n+            Some(ref v) => v.read(tcx),\n+            None => (),\n+        }\n+    }\n+}\n+\n+impl<T> DepGraphRead for [T]\n+    where T: DepGraphRead\n+{\n+    fn read(&self, tcx: TyCtxt) {\n+        for i in self {\n+            i.read(tcx);\n+        }\n+    }\n+}\n+\n+macro_rules! read_tuple {\n+    ($($name:ident),*) => {\n+        impl<$($name),*> DepGraphRead for ($($name),*)\n+            where $($name: DepGraphRead),*\n+        {\n+            #[allow(non_snake_case)]\n+            fn read(&self, tcx: TyCtxt) {\n+                let &($(ref $name),*) = self;\n+                $($name.read(tcx);)*\n+            }\n+        }\n+    }\n+}\n+read_tuple!(A,B);\n+read_tuple!(A,B,C);\n+\n+macro_rules! read_hir {\n+    ($t:ty) => {\n+        impl<'tcx> DepGraphRead for &'tcx $t {\n+            fn read(&self, tcx: TyCtxt) {\n+                tcx.map.read(self.id);\n+            }\n+        }\n+    }\n+}\n+read_hir!(hir::Item);\n+read_hir!(hir::ImplItem);\n+read_hir!(hir::TraitItem);\n+read_hir!(hir::ForeignItem);\n+\n+/// You can use `FromId(X, ...)` to indicate that `...` came from node\n+/// `X`; so we will add a read from the suitable `Hir` node.\n+pub struct FromId<T>(pub ast::NodeId, pub T);\n+\n+impl<T> DepGraphRead for FromId<T> {\n+    fn read(&self, tcx: TyCtxt) {\n+        tcx.map.read(self.0);\n+    }\n+}"}]}