{"sha": "705a7667c5e14c7155145041ca2abe45c2863ea7", "node_id": "C_kwDOAAsO6NoAKDcwNWE3NjY3YzVlMTRjNzE1NTE0NTA0MWNhMmFiZTQ1YzI4NjNlYTc", "commit": {"author": {"name": "Doug Cook (WINDOWS)", "email": "dcook@windows.microsoft.com", "date": "2022-09-11T02:37:07Z"}, "committer": {"name": "Doug Cook (WINDOWS)", "email": "dcook@windows.microsoft.com", "date": "2022-09-11T02:37:07Z"}, "message": "array docs - advertise how to get array from slice\n\nOn my first Rust project, I spent more time than I care to admit\nfiguring out how to efficiently get an array from a slice. Update the\narray documentation to explain this a bit more clearly.\n\n(As a side note, it's a bit unfortunate that get-array-from-slice is\nonly available via trait since that means it can't be used from const\nfunctions yet.)", "tree": {"sha": "fb32f2f482a1a7f878f48891f57c6a6cd12bcad1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb32f2f482a1a7f878f48891f57c6a6cd12bcad1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/705a7667c5e14c7155145041ca2abe45c2863ea7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/705a7667c5e14c7155145041ca2abe45c2863ea7", "html_url": "https://github.com/rust-lang/rust/commit/705a7667c5e14c7155145041ca2abe45c2863ea7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/705a7667c5e14c7155145041ca2abe45c2863ea7/comments", "author": null, "committer": null, "parents": [{"sha": "4a6ac3c225d6322caaf0ef86623cddc74e5260c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a6ac3c225d6322caaf0ef86623cddc74e5260c6", "html_url": "https://github.com/rust-lang/rust/commit/4a6ac3c225d6322caaf0ef86623cddc74e5260c6"}], "stats": {"total": 94, "additions": 92, "deletions": 2}, "files": [{"sha": "165b9d24d934bfcfbaeeb4ced4b105fdc470b146", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/705a7667c5e14c7155145041ca2abe45c2863ea7/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705a7667c5e14c7155145041ca2abe45c2863ea7/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=705a7667c5e14c7155145041ca2abe45c2863ea7", "patch": "@@ -184,6 +184,18 @@ impl<T, const N: usize> const BorrowMut<[T]> for [T; N] {\n     }\n }\n \n+/// Tries to create an array `[T; N]` by copying from a slice `&[T]`. Succeeds if\n+/// `slice.len() == N`.\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: [u8; 2] = <[u8; 2]>::try_from(&bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(bytes_head));\n+///\n+/// let bytes_tail: [u8; 2] = bytes[1..3].try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(bytes_tail));\n+/// ```\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<T, const N: usize> TryFrom<&[T]> for [T; N]\n where\n@@ -196,6 +208,18 @@ where\n     }\n }\n \n+/// Tries to create an array `[T; N]` by copying from a mutable slice `&mut [T]`.\n+/// Succeeds if `slice.len() == N`.\n+///\n+/// ```\n+/// let mut bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: [u8; 2] = <[u8; 2]>::try_from(&mut bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(bytes_head));\n+///\n+/// let bytes_tail: [u8; 2] = (&mut bytes[1..3]).try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(bytes_tail));\n+/// ```\n #[stable(feature = \"try_from_mut_slice_to_array\", since = \"1.59.0\")]\n impl<T, const N: usize> TryFrom<&mut [T]> for [T; N]\n where\n@@ -208,6 +232,18 @@ where\n     }\n }\n \n+/// Tries to create an array ref `&[T; N]` from a slice ref `&[T]`. Succeeds if\n+/// `slice.len() == N`.\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: &[u8; 2] = <&[u8; 2]>::try_from(&bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(*bytes_head));\n+///\n+/// let bytes_tail: &[u8; 2] = bytes[1..3].try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(*bytes_tail));\n+/// ```\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n     type Error = TryFromSliceError;\n@@ -223,6 +259,18 @@ impl<'a, T, const N: usize> TryFrom<&'a [T]> for &'a [T; N] {\n     }\n }\n \n+/// Tries to create a mutable array ref `&mut [T; N]` from a mutable slice ref\n+/// `&mut [T]`. Succeeds if `slice.len() == N`.\n+///\n+/// ```\n+/// let mut bytes: [u8; 3] = [1, 0, 2];\n+///\n+/// let bytes_head: &mut [u8; 2] = <&mut [u8; 2]>::try_from(&mut bytes[0..2]).unwrap();\n+/// assert_eq!(1, u16::from_le_bytes(*bytes_head));\n+///\n+/// let bytes_tail: &mut [u8; 2] = (&mut bytes[1..3]).try_into().unwrap();\n+/// assert_eq!(512, u16::from_le_bytes(*bytes_tail));\n+/// ```\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n impl<'a, T, const N: usize> TryFrom<&'a mut [T]> for &'a mut [T; N] {\n     type Error = TryFromSliceError;"}, {"sha": "331714a993c609210adb04bfdbdd35c053408e70", "filename": "library/core/src/primitive_docs.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/705a7667c5e14c7155145041ca2abe45c2863ea7/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705a7667c5e14c7155145041ca2abe45c2863ea7/library%2Fcore%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fprimitive_docs.rs?ref=705a7667c5e14c7155145041ca2abe45c2863ea7", "patch": "@@ -611,7 +611,19 @@ mod prim_pointer {}\n ///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n-/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// Slices have a dynamic size and do not coerce to arrays. Instead, use\n+/// `slice.try_into().unwrap()` or `<ArrayType>::try_from(slice).unwrap()`.\n+///\n+/// Array's `try_from(slice)` implementations (and the corresponding `slice.try_into()`\n+/// array implementations) succeed if the input slice length is the same as the result\n+/// array length. They optimize especially well when the optimizer can easily determine\n+/// the slice length, e.g. `<[u8; 4]>::try_from(&slice[4..8]).unwrap()`. Array implements\n+/// [TryFrom](crate::convert::TryFrom) returning:\n+///\n+/// - `[T; N]` copies from the slice's elements\n+/// - `&[T; N]` references the original slice's elements\n+/// - `&mut [T; N]` references the original slice's elements\n ///\n /// You can move elements out of an array with a [slice pattern]. If you want\n /// one element, see [`mem::replace`].\n@@ -640,6 +652,15 @@ mod prim_pointer {}\n /// for x in &array { }\n /// ```\n ///\n+/// You can use `<ArrayType>::try_from(slice)` or `slice.try_into()` to get an array from\n+/// a slice:\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+/// assert_eq!(1, u16::from_le_bytes(<[u8; 2]>::try_from(&bytes[0..2]).unwrap()));\n+/// assert_eq!(512, u16::from_le_bytes(bytes[1..3].try_into().unwrap()));\n+/// ```\n+///\n /// You can use a [slice pattern] to move elements out of an array:\n ///\n /// ```"}, {"sha": "331714a993c609210adb04bfdbdd35c053408e70", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/705a7667c5e14c7155145041ca2abe45c2863ea7/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/705a7667c5e14c7155145041ca2abe45c2863ea7/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=705a7667c5e14c7155145041ca2abe45c2863ea7", "patch": "@@ -611,7 +611,19 @@ mod prim_pointer {}\n ///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n-/// Slices have a dynamic size and do not coerce to arrays.\n+///\n+/// Slices have a dynamic size and do not coerce to arrays. Instead, use\n+/// `slice.try_into().unwrap()` or `<ArrayType>::try_from(slice).unwrap()`.\n+///\n+/// Array's `try_from(slice)` implementations (and the corresponding `slice.try_into()`\n+/// array implementations) succeed if the input slice length is the same as the result\n+/// array length. They optimize especially well when the optimizer can easily determine\n+/// the slice length, e.g. `<[u8; 4]>::try_from(&slice[4..8]).unwrap()`. Array implements\n+/// [TryFrom](crate::convert::TryFrom) returning:\n+///\n+/// - `[T; N]` copies from the slice's elements\n+/// - `&[T; N]` references the original slice's elements\n+/// - `&mut [T; N]` references the original slice's elements\n ///\n /// You can move elements out of an array with a [slice pattern]. If you want\n /// one element, see [`mem::replace`].\n@@ -640,6 +652,15 @@ mod prim_pointer {}\n /// for x in &array { }\n /// ```\n ///\n+/// You can use `<ArrayType>::try_from(slice)` or `slice.try_into()` to get an array from\n+/// a slice:\n+///\n+/// ```\n+/// let bytes: [u8; 3] = [1, 0, 2];\n+/// assert_eq!(1, u16::from_le_bytes(<[u8; 2]>::try_from(&bytes[0..2]).unwrap()));\n+/// assert_eq!(512, u16::from_le_bytes(bytes[1..3].try_into().unwrap()));\n+/// ```\n+///\n /// You can use a [slice pattern] to move elements out of an array:\n ///\n /// ```"}]}