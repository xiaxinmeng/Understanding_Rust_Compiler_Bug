{"sha": "a96cea4f5a713eb357bde3d395c5453058be88c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5NmNlYTRmNWE3MTNlYjM1N2JkZTNkMzk1YzU0NTMwNThiZTg4YzU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-16T13:52:58Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-17T12:53:49Z"}, "message": "str: provide lossy UTF-16 support.\n\nThis replaces the iterator with one that handles lone surrogates\ngracefully and uses that to implement `from_utf16_lossy` which replaces\ninvalid `u16`s with U+FFFD.", "tree": {"sha": "0b55ef8a568546b199679249b1701dd99c4042dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b55ef8a568546b199679249b1701dd99c4042dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a96cea4f5a713eb357bde3d395c5453058be88c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a96cea4f5a713eb357bde3d395c5453058be88c5", "html_url": "https://github.com/rust-lang/rust/commit/a96cea4f5a713eb357bde3d395c5453058be88c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a96cea4f5a713eb357bde3d395c5453058be88c5/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7656d048feb828af12278a6028c17b0c86241b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7656d048feb828af12278a6028c17b0c86241b3", "html_url": "https://github.com/rust-lang/rust/commit/b7656d048feb828af12278a6028c17b0c86241b3"}], "stats": {"total": 156, "additions": 133, "deletions": 23}, "files": [{"sha": "1ef622002c3108ea5b7fac595537f2acb8d24881", "filename": "src/libstd/str.rs", "status": "modified", "additions": 133, "deletions": 23, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/a96cea4f5a713eb357bde3d395c5453058be88c5/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a96cea4f5a713eb357bde3d395c5453058be88c5/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a96cea4f5a713eb357bde3d395c5453058be88c5", "patch": "@@ -826,50 +826,142 @@ pub fn is_utf16(v: &[u16]) -> bool {\n \n /// An iterator that decodes UTF-16 encoded codepoints from a vector\n /// of `u16`s.\n-///\n-/// Fails when it encounters invalid UTF-16 data.\n-pub struct UTF16Chars<'a> {\n+#[deriving(Clone)]\n+pub struct UTF16Items<'a> {\n     priv iter: vec::Items<'a, u16>\n }\n-impl<'a> Iterator<char> for UTF16Chars<'a> {\n-    fn next(&mut self) -> Option<char> {\n+/// The possibilities for values decoded from a `u16` stream.\n+#[deriving(Eq, TotalEq, Clone)]\n+pub enum UTF16Item {\n+    /// A valid codepoint.\n+    ScalarValue(char),\n+    /// An invalid surrogate without its pair.\n+    LoneSurrogate(u16)\n+}\n+\n+impl UTF16Item {\n+    /// Convert `self` to a `char`, taking `LoneSurrogate`s to the\n+    /// replacement character (U+FFFD).\n+    #[inline]\n+    pub fn to_char_lossy(&self) -> char {\n+        match *self {\n+            ScalarValue(c) => c,\n+            LoneSurrogate(_) => '\\uFFFD'\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator<UTF16Item> for UTF16Items<'a> {\n+    fn next(&mut self) -> Option<UTF16Item> {\n         let u = match self.iter.next() {\n             Some(u) => *u,\n             None => return None\n         };\n-        match char::from_u32(u as u32) {\n-            Some(c) => Some(c),\n-            None => {\n-                let u2 = *self.iter.next().expect(\"UTF16Chars: unmatched lead surrogate\");\n-                if u < 0xD7FF || u > 0xDBFF ||\n-                    u2 < 0xDC00 || u2 > 0xDFFF {\n-                    fail!(\"UTF16Chars: invalid surrogate pair\")\n-                }\n \n-                let mut c = (u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32 | 0x1_0000;\n-                char::from_u32(c)\n+        if u < 0xD800 || 0xDFFF < u {\n+            // not a surrogate\n+            Some(ScalarValue(unsafe {cast::transmute(u as u32)}))\n+        } else if u >= 0xDC00 {\n+            // a trailing surrogate\n+            Some(LoneSurrogate(u))\n+        } else {\n+            // preserve state for rewinding.\n+            let old = self.iter;\n+\n+            let u2 = match self.iter.next() {\n+                Some(u2) => *u2,\n+                // eof\n+                None => return Some(LoneSurrogate(u))\n+            };\n+            if u2 < 0xDC00 || u2 > 0xDFFF {\n+                // not a trailing surrogate so we're not a valid\n+                // surrogate pair, so rewind to redecode u2 next time.\n+                self.iter = old;\n+                return Some(LoneSurrogate(u))\n             }\n+\n+            // all ok, so lets decode it.\n+            let c = (u - 0xD800) as u32 << 10 | (u2 - 0xDC00) as u32 | 0x1_0000;\n+            Some(ScalarValue(unsafe {cast::transmute(c)}))\n         }\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         let (low, high) = self.iter.size_hint();\n-        // we could be entirely surrogates (2 elements per char), or\n-        // entirely non-surrogates (1 element per char)\n+        // we could be entirely valid surrogates (2 elements per\n+        // char), or entirely non-surrogates (1 element per char)\n         (low / 2, high)\n     }\n }\n \n-/// Create an iterator over the UTF-16 encoded codepoints in `v`.\n+/// Create an iterator over the UTF-16 encoded codepoints in `v`,\n+/// returning invalid surrogates as `LoneSurrogate`s.\n ///\n-/// The iterator fails if it attempts to decode invalid UTF-16 data.\n-pub fn utf16_chars<'a>(v: &'a [u16]) -> UTF16Chars<'a> {\n-    UTF16Chars { iter : v.iter() }\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+/// use std::str::{ScalarValue, LoneSurrogate};\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::utf16_items(v).to_owned_vec(),\n+///            ~[ScalarValue('\ud834\udd1e'),\n+///              ScalarValue('m'), ScalarValue('u'), ScalarValue('s'),\n+///              LoneSurrogate(0xDD1E),\n+///              ScalarValue('i'), ScalarValue('c'),\n+///              LoneSurrogate(0xD834)]);\n+/// ```\n+pub fn utf16_items<'a>(v: &'a [u16]) -> UTF16Items<'a> {\n+    UTF16Items { iter : v.iter() }\n }\n \n-/// Allocates a new string from the utf-16 slice provided\n+/// Decode a UTF-16 encoded vector `v` into a string.\n+///\n+/// # Failure\n+///\n+/// Fails on invalid UTF-16 data.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \ud834\udd1emusic\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0x0069, 0x0063];\n+/// assert_eq!(str::from_utf16(v), ~\"\ud834\udd1emusic\");\n+/// ```\n pub fn from_utf16(v: &[u16]) -> ~str {\n-    utf16_chars(v).collect()\n+    utf16_items(v).map(|c| {\n+            match c {\n+                ScalarValue(c) => c,\n+                LoneSurrogate(u) => fail!(\"from_utf16: found lone surrogate {}\", u)\n+            }\n+        }).collect()\n+}\n+\n+/// Decode a UTF-16 encoded vector `v` into a string, replacing\n+/// invalid data with the replacement character (U+FFFD).\n+///\n+/// # Example\n+/// ```rust\n+/// use std::str;\n+///\n+/// // \ud834\udd1emus<invalid>ic<invalid>\n+/// let v = [0xD834, 0xDD1E, 0x006d, 0x0075,\n+///          0x0073, 0xDD1E, 0x0069, 0x0063,\n+///          0xD834];\n+///\n+/// assert_eq!(str::from_utf16_lossy(v),\n+///            ~\"\ud834\udd1emus\\uFFFDic\\uFFFD\");\n+/// ```\n+pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n+    utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n /// Allocates a new string with the specified capacity. The string returned is\n@@ -3738,12 +3830,30 @@ mod tests {\n             let (s, u) = (*p).clone();\n             assert!(is_utf16(u));\n             assert_eq!(s.to_utf16(), u);\n+\n             assert_eq!(from_utf16(u), s);\n+            assert_eq!(from_utf16_lossy(u), s);\n+\n             assert_eq!(from_utf16(s.to_utf16()), s);\n             assert_eq!(from_utf16(u).to_utf16(), u);\n         }\n     }\n \n+    #[test]\n+    fn test_utf16_lossy() {\n+        // completely positive cases tested above.\n+        // lead + eof\n+        assert_eq!(from_utf16_lossy([0xD800]), ~\"\\uFFFD\");\n+        // lead + lead\n+        assert_eq!(from_utf16_lossy([0xD800, 0xD800]), ~\"\\uFFFD\\uFFFD\");\n+\n+        // isolated trail\n+        assert_eq!(from_utf16_lossy([0x0061, 0xDC00]), ~\"a\\uFFFD\");\n+\n+        // general\n+        assert_eq!(from_utf16_lossy([0xD800, 0xd801, 0xdc8b, 0xD800]), ~\"\\uFFFD\ud801\udc8b\\uFFFD\");\n+    }\n+\n     #[test]\n     fn test_char_at() {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";"}]}