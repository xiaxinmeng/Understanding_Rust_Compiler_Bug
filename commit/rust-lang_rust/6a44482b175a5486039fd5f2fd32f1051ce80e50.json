{"sha": "6a44482b175a5486039fd5f2fd32f1051ce80e50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNDQ0ODJiMTc1YTU0ODYwMzlmZDVmMmZkMzJmMTA1MWNlODBlNTA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-03T21:20:34Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-05-09T00:03:59Z"}, "message": "libcore: Remove mutable fields from pipes", "tree": {"sha": "818881a061a2ece4bc5d1fe86952b0fbc5a981f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/818881a061a2ece4bc5d1fe86952b0fbc5a981f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a44482b175a5486039fd5f2fd32f1051ce80e50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a44482b175a5486039fd5f2fd32f1051ce80e50", "html_url": "https://github.com/rust-lang/rust/commit/6a44482b175a5486039fd5f2fd32f1051ce80e50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a44482b175a5486039fd5f2fd32f1051ce80e50/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "803a4f45fa5b581155e638143afb97195cfa9f2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/803a4f45fa5b581155e638143afb97195cfa9f2e", "html_url": "https://github.com/rust-lang/rust/commit/803a4f45fa5b581155e638143afb97195cfa9f2e"}], "stats": {"total": 448, "additions": 246, "deletions": 202}, "files": [{"sha": "56c301cd1c75afa9024e37bc2700aa97ca527b6a", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=6a44482b175a5486039fd5f2fd32f1051ce80e50", "patch": "@@ -12,6 +12,7 @@\n Message passing\n */\n \n+use cast::transmute;\n use cast;\n use either::{Either, Left, Right};\n use kinds::Owned;\n@@ -192,20 +193,20 @@ impl<T: Owned> Peekable<T> for Port<T> {\n     fn peek(&self) -> bool {\n         let mut endp = None;\n         endp <-> self.endp;\n-        let peek = match &endp {\n-            &Some(ref endp) => peek(endp),\n-            &None => fail!(~\"peeking empty stream\")\n+        let peek = match endp {\n+            Some(ref mut endp) => peek(endp),\n+            None => fail!(~\"peeking empty stream\")\n         };\n         self.endp <-> endp;\n         peek\n     }\n }\n \n impl<T: Owned> Selectable for Port<T> {\n-    fn header(&self) -> *PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader {\n         unsafe {\n             match self.endp {\n-                Some(ref endp) => endp.header(),\n+                Some(ref mut endp) => endp.header(),\n                 None => fail!(~\"peeking empty stream\")\n             }\n         }\n@@ -327,23 +328,20 @@ impl<T: Owned> ::clone::Clone for SharedChan<T> {\n #[allow(non_camel_case_types)]\n pub mod oneshot {\n     priv use core::kinds::Owned;\n-    use ptr::to_unsafe_ptr;\n+    use ptr::to_mut_unsafe_ptr;\n \n     pub fn init<T: Owned>() -> (client::Oneshot<T>, server::Oneshot<T>) {\n         pub use core::pipes::HasBuffer;\n \n-        let buffer =\n-            ~::core::pipes::Buffer{\n+        let mut buffer = ~::core::pipes::Buffer {\n             header: ::core::pipes::BufferHeader(),\n-            data: __Buffer{\n+            data: __Buffer {\n                 Oneshot: ::core::pipes::mk_packet::<Oneshot<T>>()\n             },\n         };\n         do ::core::pipes::entangle_buffer(buffer) |buffer, data| {\n-            {\n-                data.Oneshot.set_buffer(buffer);\n-                to_unsafe_ptr(&data.Oneshot)\n-            }\n+            data.Oneshot.set_buffer(buffer);\n+            to_mut_unsafe_ptr(&mut data.Oneshot)\n         }\n     }\n     #[allow(non_camel_case_types)]\n@@ -497,48 +495,66 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n \n \n /// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T: Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T: Selectable>(endpoints: &mut [T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A: Selectable, B: Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n+pub fn select2i<A:Selectable, B:Selectable>(a: &mut A, b: &mut B)\n+                                            -> Either<(), ()> {\n+    let mut endpoints = [ a.header(), b.header() ];\n+    match wait_many(endpoints) {\n+        0 => Left(()),\n+        1 => Right(()),\n+        _ => fail!(~\"wait returned unexpected index\"),\n     }\n }\n \n /// Receive a message from one of two endpoints.\n pub trait Select2<T: Owned, U: Owned> {\n     /// Receive a message or return `None` if a connection closes.\n-    fn try_select(&self) -> Either<Option<T>, Option<U>>;\n+    fn try_select(&mut self) -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n-    fn select(&self) -> Either<T, U>;\n+    fn select(&mut self) -> Either<T, U>;\n }\n \n-impl<T: Owned, U: Owned,\n-     Left: Selectable + GenericPort<T>,\n-     Right: Selectable + GenericPort<U>>\n-    Select2<T, U> for (Left, Right) {\n-\n-    fn select(&self) -> Either<T, U> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.recv()),\n-            Right(()) => Right(rp.recv())\n-          }\n+impl<T:Owned,\n+     U:Owned,\n+     Left:Selectable + GenericPort<T>,\n+     Right:Selectable + GenericPort<U>>\n+     Select2<T, U>\n+     for (Left, Right) {\n+    fn select(&mut self) -> Either<T, U> {\n+        // XXX: Bad borrow check workaround.\n+        unsafe {\n+            let this: &(Left, Right) = transmute(self);\n+            match *this {\n+                (ref lp, ref rp) => {\n+                    let lp: &mut Left = transmute(lp);\n+                    let rp: &mut Right = transmute(rp);\n+                    match select2i(lp, rp) {\n+                        Left(()) => Left(lp.recv()),\n+                        Right(()) => Right(rp.recv()),\n+                    }\n+                }\n+            }\n         }\n     }\n \n-    fn try_select(&self) -> Either<Option<T>, Option<U>> {\n-        match *self {\n-          (ref lp, ref rp) => match select2i(lp, rp) {\n-            Left(()) => Left (lp.try_recv()),\n-            Right(()) => Right(rp.try_recv())\n-          }\n+    fn try_select(&mut self) -> Either<Option<T>, Option<U>> {\n+        // XXX: Bad borrow check workaround.\n+        unsafe {\n+            let this: &(Left, Right) = transmute(self);\n+            match *this {\n+                (ref lp, ref rp) => {\n+                    let lp: &mut Left = transmute(lp);\n+                    let rp: &mut Right = transmute(rp);\n+                    match select2i(lp, rp) {\n+                        Left(()) => Left (lp.try_recv()),\n+                        Right(()) => Right(rp.try_recv()),\n+                    }\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "1fda5a97a375ae2df9a665c169ab72d48ced6ca6", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 169, "deletions": 148, "changes": 317, "blob_url": "https://github.com/rust-lang/rust/blob/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=6a44482b175a5486039fd5f2fd32f1051ce80e50", "patch": "@@ -111,7 +111,7 @@ enum State {\n pub struct BufferHeader {\n     // Tracks whether this buffer needs to be freed. We can probably\n     // get away with restricting it to 0 or 1, if we're careful.\n-    mut ref_count: int,\n+    ref_count: int,\n \n     // We may want a drop, and to be careful about stringing this\n     // thing along.\n@@ -130,12 +130,12 @@ pub struct Buffer<T> {\n }\n \n pub struct PacketHeader {\n-    mut state: State,\n-    mut blocked_task: *rust_task,\n+    state: State,\n+    blocked_task: *rust_task,\n \n     // This is a transmute_copy of a ~buffer, that can also be cast\n     // to a buffer_header if need be.\n-    mut buffer: *libc::c_void,\n+    buffer: *libc::c_void,\n }\n \n pub fn PacketHeader() -> PacketHeader {\n@@ -148,14 +148,14 @@ pub fn PacketHeader() -> PacketHeader {\n \n pub impl PacketHeader {\n     // Returns the old state.\n-    unsafe fn mark_blocked(&self, this: *rust_task) -> State {\n+    unsafe fn mark_blocked(&mut self, this: *rust_task) -> State {\n         rustrt::rust_task_ref(this);\n         let old_task = swap_task(&mut self.blocked_task, this);\n         assert!(old_task.is_null());\n         swap_state_acq(&mut self.state, Blocked)\n     }\n \n-    unsafe fn unblock(&self) {\n+    unsafe fn unblock(&mut self) {\n         let old_task = swap_task(&mut self.blocked_task, ptr::null());\n         if !old_task.is_null() {\n             rustrt::rust_task_deref(old_task)\n@@ -169,13 +169,13 @@ pub impl PacketHeader {\n \n     // unsafe because this can do weird things to the space/time\n     // continuum. It ends making multiple unique pointers to the same\n-    // thing. You'll proobably want to forget them when you're done.\n-    unsafe fn buf_header(&self) -> ~BufferHeader {\n+    // thing. You'll probably want to forget them when you're done.\n+    unsafe fn buf_header(&mut self) -> ~BufferHeader {\n         assert!(self.buffer.is_not_null());\n         transmute_copy(&self.buffer)\n     }\n \n-    fn set_buffer<T:Owned>(&self, b: ~Buffer<T>) {\n+    fn set_buffer<T:Owned>(&mut self, b: ~Buffer<T>) {\n         unsafe {\n             self.buffer = transmute_copy(&b);\n         }\n@@ -184,15 +184,15 @@ pub impl PacketHeader {\n \n pub struct Packet<T> {\n     header: PacketHeader,\n-    mut payload: Option<T>,\n+    payload: Option<T>,\n }\n \n pub trait HasBuffer {\n-    fn set_buffer(&self, b: *libc::c_void);\n+    fn set_buffer(&mut self, b: *libc::c_void);\n }\n \n impl<T:Owned> HasBuffer for Packet<T> {\n-    fn set_buffer(&self, b: *libc::c_void) {\n+    fn set_buffer(&mut self, b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n@@ -204,7 +204,7 @@ pub fn mk_packet<T:Owned>() -> Packet<T> {\n     }\n }\n fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n-    let b = ~Buffer {\n+    let mut b = ~Buffer {\n         header: BufferHeader(),\n         data: Packet {\n             header: PacketHeader(),\n@@ -218,22 +218,25 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     b\n }\n \n-pub fn packet<T>() -> *Packet<T> {\n-    let b = unibuffer();\n-    let p = ptr::to_unsafe_ptr(&(b.data));\n+pub fn packet<T>() -> *mut Packet<T> {\n+    let mut b = unibuffer();\n+    let p = ptr::to_mut_unsafe_ptr(&mut b.data);\n     // We'll take over memory management from here.\n-    unsafe { forget(b) }\n+    unsafe {\n+        forget(b);\n+    }\n     p\n }\n \n pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n-    buffer: ~Buffer<T>,\n-    init: &fn(*libc::c_void, x: &T) -> *Packet<Tstart>)\n-    -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>)\n-{\n-    let p = init(unsafe { transmute_copy(&buffer) }, &buffer.data);\n-    unsafe { forget(buffer) }\n-    (SendPacketBuffered(p), RecvPacketBuffered(p))\n+    mut buffer: ~Buffer<T>,\n+    init: &fn(*libc::c_void, x: &mut T) -> *mut Packet<Tstart>)\n+    -> (SendPacketBuffered<Tstart, T>, RecvPacketBuffered<Tstart, T>) {\n+    unsafe {\n+        let p = init(transmute_copy(&buffer), &mut buffer.data);\n+        forget(buffer);\n+        (SendPacketBuffered(p), RecvPacketBuffered(p))\n+    }\n }\n \n pub fn swap_task(dst: &mut *rust_task, src: *rust_task) -> *rust_task {\n@@ -292,7 +295,7 @@ fn swap_state_rel(dst: &mut State, src: State) -> State {\n     }\n }\n \n-pub unsafe fn get_buffer<T>(p: *PacketHeader) -> ~Buffer<T> {\n+pub unsafe fn get_buffer<T>(p: *mut PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n@@ -306,10 +309,14 @@ struct BufferResource<T> {\n impl<T> Drop for BufferResource<T> {\n     fn finalize(&self) {\n         unsafe {\n-            let b = move_it!(self.buffer);\n+            let this: &mut BufferResource<T> = transmute(self);\n+\n+            let mut b = move_it!(this.buffer);\n             //let p = ptr::to_unsafe_ptr(*b);\n             //error!(\"drop %?\", p);\n-            let old_count = intrinsics::atomic_xsub_rel(&mut b.header.ref_count, 1);\n+            let old_count = intrinsics::atomic_xsub_rel(\n+                &mut b.header.ref_count,\n+                1);\n             //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n             if old_count == 1 {\n                 // The new count is 0.\n@@ -323,21 +330,25 @@ impl<T> Drop for BufferResource<T> {\n     }\n }\n \n-fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n+fn BufferResource<T>(mut b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::to_unsafe_ptr(*b);\n     //error!(\"take %?\", p);\n-    unsafe { intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1) };\n+    unsafe {\n+        intrinsics::atomic_xadd_acq(&mut b.header.ref_count, 1);\n+    }\n \n     BufferResource {\n         // tjc: ????\n         buffer: b\n     }\n }\n \n-pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n+pub fn send<T,Tbuffer>(mut p: SendPacketBuffered<T,Tbuffer>,\n+                       payload: T)\n+                       -> bool {\n     let header = p.header();\n-    let p_ = p.unwrap();\n-    let p = unsafe { &*p_ };\n+    let mut p_ = p.unwrap();\n+    let p = unsafe { &mut *p_ };\n     assert!(ptr::to_unsafe_ptr(&(p.header)) == header);\n     assert!(p.payload.is_none());\n     p.payload = Some(payload);\n@@ -391,11 +402,12 @@ Returns `None` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n-    -> Option<T>\n-{\n-    let p_ = p.unwrap();\n-    let p = unsafe { &*p_ };\n+pub fn try_recv<T:Owned,Tbuffer:Owned>(mut p: RecvPacketBuffered<T, Tbuffer>)\n+                                       -> Option<T> {\n+    let mut p_ = p.unwrap();\n+    let mut p = unsafe {\n+        &mut *p_\n+    };\n \n     do (|| {\n         try_recv_(p)\n@@ -412,7 +424,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(p: RecvPacketBuffered<T, Tbuffer>)\n     }\n }\n \n-fn try_recv_<T:Owned>(p: &Packet<T>) -> Option<T> {\n+fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n     // optimistic path\n     match p.header.state {\n       Full => {\n@@ -498,16 +510,20 @@ fn try_recv_<T:Owned>(p: &Packet<T>) -> Option<T> {\n }\n \n /// Returns true if messages are available.\n-pub fn peek<T:Owned,Tb:Owned>(p: &RecvPacketBuffered<T, Tb>) -> bool {\n-    match unsafe {(*p.header()).state} {\n-      Empty | Terminated => false,\n-      Blocked => fail!(~\"peeking on blocked packet\"),\n-      Full => true\n+pub fn peek<T:Owned,Tb:Owned>(p: &mut RecvPacketBuffered<T, Tb>) -> bool {\n+    unsafe {\n+        match (*p.header()).state {\n+            Empty | Terminated => false,\n+            Blocked => fail!(~\"peeking on blocked packet\"),\n+            Full => true\n+        }\n     }\n }\n \n-fn sender_terminate<T:Owned>(p: *Packet<T>) {\n-    let p = unsafe { &*p };\n+fn sender_terminate<T:Owned>(p: *mut Packet<T>) {\n+    let p = unsafe {\n+        &mut *p\n+    };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n         // The receiver will eventually clean up.\n@@ -536,8 +552,10 @@ fn sender_terminate<T:Owned>(p: *Packet<T>) {\n     }\n }\n \n-fn receiver_terminate<T:Owned>(p: *Packet<T>) {\n-    let p = unsafe { &*p };\n+fn receiver_terminate<T:Owned>(p: *mut Packet<T>) {\n+    let p = unsafe {\n+        &mut *p\n+    };\n     match swap_state_rel(&mut p.header.state, Terminated) {\n       Empty => {\n         assert!(p.header.blocked_task.is_null());\n@@ -569,36 +587,45 @@ that vector. The index points to an endpoint that has either been\n closed by the sender or has a message waiting to be received.\n \n */\n-pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n-    let this = unsafe { rustrt::rust_get_task() };\n+pub fn wait_many<T: Selectable>(pkts: &mut [T]) -> uint {\n+    let this = unsafe {\n+        rustrt::rust_get_task()\n+    };\n \n     unsafe {\n         rustrt::task_clear_event_reject(this);\n     }\n \n     let mut data_avail = false;\n     let mut ready_packet = pkts.len();\n-    for pkts.eachi |i, p| {\n+    for vec::eachi_mut(pkts) |i, p| {\n         unsafe {\n-            let p = &*p.header();\n+            let p = &mut *p.header();\n             let old = p.mark_blocked(this);\n             match old {\n-              Full | Terminated => {\n-                data_avail = true;\n-                ready_packet = i;\n-                (*p).state = old;\n-                break;\n-              }\n-              Blocked => fail!(~\"blocking on blocked packet\"),\n-              Empty => ()\n+                Full | Terminated => {\n+                    data_avail = true;\n+                    ready_packet = i;\n+                    (*p).state = old;\n+                    break;\n+                }\n+                Blocked => fail!(~\"blocking on blocked packet\"),\n+                Empty => ()\n             }\n         }\n     }\n \n     while !data_avail {\n         debug!(\"sleeping on %? packets\", pkts.len());\n         let event = wait_event(this) as *PacketHeader;\n-        let pos = vec::position(pkts, |p| p.header() == event);\n+\n+        let mut pos = None;\n+        for vec::eachi_mut(pkts) |i, p| {\n+            if p.header() == event {\n+                pos = Some(i);\n+                break;\n+            }\n+        };\n \n         match pos {\n           Some(i) => {\n@@ -609,11 +636,15 @@ pub fn wait_many<T: Selectable>(pkts: &[T]) -> uint {\n         }\n     }\n \n-    debug!(\"%?\", pkts[ready_packet]);\n+    debug!(\"%?\", &mut pkts[ready_packet]);\n \n-    for pkts.each |p| { unsafe{ (*p.header()).unblock()} }\n+    for vec::each_mut(pkts) |p| {\n+        unsafe {\n+            (*p.header()).unblock()\n+        }\n+    }\n \n-    debug!(\"%?, %?\", ready_packet, pkts[ready_packet]);\n+    debug!(\"%?, %?\", ready_packet, &mut pkts[ready_packet]);\n \n     unsafe {\n         assert!((*pkts[ready_packet].header()).state == Full\n@@ -629,65 +660,58 @@ message.\n */\n pub type SendPacket<T> = SendPacketBuffered<T, Packet<T>>;\n \n-pub fn SendPacket<T>(p: *Packet<T>) -> SendPacket<T> {\n+pub fn SendPacket<T>(p: *mut Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n pub struct SendPacketBuffered<T, Tbuffer> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n+    p: Option<*mut Packet<T>>,\n+    buffer: Option<BufferResource<Tbuffer>>,\n }\n \n #[unsafe_destructor]\n impl<T:Owned,Tbuffer:Owned> Drop for SendPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n-        //if self.p != none {\n-        //    debug!(\"drop send %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            sender_terminate(p.unwrap())\n+        unsafe {\n+            let this: &mut SendPacketBuffered<T,Tbuffer> = transmute(self);\n+            if this.p != None {\n+                let mut p = None;\n+                p <-> this.p;\n+                sender_terminate(p.unwrap())\n+            }\n         }\n-        //unsafe { error!(\"send_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n     }\n }\n \n-pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n-    -> SendPacketBuffered<T, Tbuffer> {\n-        //debug!(\"take send %?\", p);\n+pub fn SendPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n+                                     -> SendPacketBuffered<T,Tbuffer> {\n     SendPacketBuffered {\n         p: Some(p),\n         buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n+            Some(BufferResource(get_buffer(&mut (*p).header)))\n         }\n     }\n }\n \n pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n-    fn unwrap(&self) -> *Packet<T> {\n+    fn unwrap(&mut self) -> *mut Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         p.unwrap()\n     }\n \n-    fn header(&self) -> *PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader {\n         match self.p {\n-          Some(packet) => unsafe {\n-            let packet = &*packet;\n-            let header = ptr::to_unsafe_ptr(&(packet.header));\n-            //forget(packet);\n-            header\n-          },\n-          None => fail!(~\"packet already consumed\")\n+            Some(packet) => unsafe {\n+                let packet = &mut *packet;\n+                let header = ptr::to_mut_unsafe_ptr(&mut packet.header);\n+                header\n+            },\n+            None => fail!(~\"packet already consumed\")\n         }\n     }\n \n-    fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n+    fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         //error!(\"send reuse_buffer\");\n         let mut tmp = None;\n         tmp <-> self.buffer;\n@@ -699,69 +723,62 @@ pub impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n /// message.\n pub type RecvPacket<T> = RecvPacketBuffered<T, Packet<T>>;\n \n-pub fn RecvPacket<T>(p: *Packet<T>) -> RecvPacket<T> {\n+pub fn RecvPacket<T>(p: *mut Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n+\n pub struct RecvPacketBuffered<T, Tbuffer> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n+    p: Option<*mut Packet<T>>,\n+    buffer: Option<BufferResource<Tbuffer>>,\n }\n \n #[unsafe_destructor]\n impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n     fn finalize(&self) {\n-        //if self.p != none {\n-        //    debug!(\"drop recv %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            receiver_terminate(p.unwrap())\n+        unsafe {\n+            let this: &mut RecvPacketBuffered<T,Tbuffer> = transmute(self);\n+            if this.p != None {\n+                let mut p = None;\n+                p <-> this.p;\n+                receiver_terminate(p.unwrap())\n+            }\n         }\n-        //unsafe { error!(\"recv_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n     }\n }\n \n pub impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n-    fn unwrap(&self) -> *Packet<T> {\n+    fn unwrap(&mut self) -> *mut Packet<T> {\n         let mut p = None;\n         p <-> self.p;\n         p.unwrap()\n     }\n \n-    fn reuse_buffer(&self) -> BufferResource<Tbuffer> {\n-        //error!(\"recv reuse_buffer\");\n+    fn reuse_buffer(&mut self) -> BufferResource<Tbuffer> {\n         let mut tmp = None;\n         tmp <-> self.buffer;\n         tmp.unwrap()\n     }\n }\n \n impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n-    fn header(&self) -> *PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader {\n         match self.p {\n-          Some(packet) => unsafe {\n-            let packet = &*packet;\n-            let header = ptr::to_unsafe_ptr(&(packet.header));\n-            //forget(packet);\n-            header\n-          },\n-          None => fail!(~\"packet already consumed\")\n+            Some(packet) => unsafe {\n+                let packet = &mut *packet;\n+                let header = ptr::to_mut_unsafe_ptr(&mut packet.header);\n+                header\n+            },\n+            None => fail!(~\"packet already consumed\")\n         }\n     }\n }\n \n-pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n-    -> RecvPacketBuffered<T,Tbuffer> {\n-    //debug!(\"take recv %?\", p);\n+pub fn RecvPacketBuffered<T,Tbuffer>(p: *mut Packet<T>)\n+                                     -> RecvPacketBuffered<T,Tbuffer> {\n     RecvPacketBuffered {\n         p: Some(p),\n         buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::to_unsafe_ptr(&((*p).header)))))\n+            Some(BufferResource(get_buffer(&mut (*p).header)))\n         }\n     }\n }\n@@ -800,51 +817,55 @@ this case, `select2` may return either `left` or `right`.\n \n */\n pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n-    a: RecvPacketBuffered<A, Ab>,\n-    b: RecvPacketBuffered<B, Bb>)\n+    mut a: RecvPacketBuffered<A, Ab>,\n+    mut b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n-              (RecvPacketBuffered<A, Ab>, Option<B>)>\n-{\n-    let i = wait_many([a.header(), b.header()]);\n-\n+              (RecvPacketBuffered<A, Ab>, Option<B>)> {\n+    let mut endpoints = [ a.header(), b.header() ];\n+    let i = wait_many(endpoints);\n     match i {\n-      0 => Left((try_recv(a), b)),\n-      1 => Right((a, try_recv(b))),\n-      _ => fail!(~\"select2 return an invalid packet\")\n+        0 => Left((try_recv(a), b)),\n+        1 => Right((a, try_recv(b))),\n+        _ => fail!(~\"select2 return an invalid packet\")\n     }\n }\n \n pub trait Selectable {\n-    fn header(&self) -> *PacketHeader;\n+    fn header(&mut self) -> *mut PacketHeader;\n }\n \n-impl Selectable for *PacketHeader {\n-    fn header(&self) -> *PacketHeader { *self }\n+impl Selectable for *mut PacketHeader {\n+    fn header(&mut self) -> *mut PacketHeader { *self }\n }\n \n /// Returns the index of an endpoint that is ready to receive.\n-pub fn selecti<T:Selectable>(endpoints: &[T]) -> uint {\n+pub fn selecti<T:Selectable>(endpoints: &mut [T]) -> uint {\n     wait_many(endpoints)\n }\n \n /// Returns 0 or 1 depending on which endpoint is ready to receive\n-pub fn select2i<A:Selectable,B:Selectable>(a: &A, b: &B) ->\n-        Either<(), ()> {\n-    match wait_many([a.header(), b.header()]) {\n-      0 => Left(()),\n-      1 => Right(()),\n-      _ => fail!(~\"wait returned unexpected index\")\n+pub fn select2i<A:Selectable,B:Selectable>(a: &mut A, b: &mut B)\n+                                           -> Either<(), ()> {\n+    let mut endpoints = [ a.header(), b.header() ];\n+    match wait_many(endpoints) {\n+        0 => Left(()),\n+        1 => Right(()),\n+        _ => fail!(~\"wait returned unexpected index\")\n     }\n }\n \n-/** Waits on a set of endpoints. Returns a message, its index, and a\n- list of the remaining endpoints.\n+/// Waits on a set of endpoints. Returns a message, its index, and a\n+/// list of the remaining endpoints.\n+pub fn select<T:Owned,Tb:Owned>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n+                                -> (uint,\n+                                    Option<T>,\n+                                    ~[RecvPacketBuffered<T, Tb>]) {\n+    let mut endpoint_headers = ~[];\n+    for vec::each_mut(endpoints) |endpoint| {\n+        endpoint_headers.push(endpoint.header());\n+    }\n \n-*/\n-pub fn select<T:Owned,Tb:Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n-    -> (uint, Option<T>, ~[RecvPacketBuffered<T, Tb>])\n-{\n-    let ready = wait_many(endpoints.map(|p| p.header()));\n+    let ready = wait_many(endpoint_headers);\n     let mut remaining = endpoints;\n     let port = remaining.swap_remove(ready);\n     let result = try_recv(port);"}, {"sha": "20ab2d61ecc0793e632f8f676cd52f462be465d1", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=6a44482b175a5486039fd5f2fd32f1051ce80e50", "patch": "@@ -72,7 +72,7 @@ impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n }\n \n impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n-    fn header(&self) -> *pipes::PacketHeader {\n+    fn header(&mut self) -> *mut pipes::PacketHeader {\n         self.port.header()\n     }\n }"}, {"sha": "76aa4d615e1dc744da045caae0358bf4266fd704", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a44482b175a5486039fd5f2fd32f1051ce80e50/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=6a44482b175a5486039fd5f2fd32f1051ce80e50", "patch": "@@ -14,10 +14,11 @@ use uv;\n use uv::iotask;\n use uv::iotask::IoTask;\n \n-use core::libc;\n-use core::libc::c_void;\n use core::cast::transmute;\n+use core::cast;\n use core::comm::{stream, Chan, SharedChan, Port, select2i};\n+use core::libc::c_void;\n+use core::libc;\n \n /**\n  * Wait for timeout period then send provided value over a channel\n@@ -120,22 +121,28 @@ pub fn sleep(iotask: &IoTask, msecs: uint) {\n pub fn recv_timeout<T:Copy + Owned>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: &Port<T>)\n-                                -> Option<T> {\n-    let (timeout_po, timeout_ch) = stream::<()>();\n+                                   -> Option<T> {\n+    let mut (timeout_po, timeout_ch) = stream::<()>();\n     delayed_send(iotask, msecs, &timeout_ch, ());\n-    // FIXME: This could be written clearer (#2618)\n-    either::either(\n-        |_| {\n-            None\n-        }, |_| {\n-            Some(wait_po.recv())\n-        }, &select2i(&timeout_po, wait_po)\n-    )\n+\n+    // XXX: Workaround due to ports and channels not being &mut. They should\n+    // be.\n+    unsafe {\n+        let wait_po = cast::transmute_mut(wait_po);\n+\n+        // FIXME: This could be written clearer (#2618)\n+        either::either(\n+            |_| {\n+                None\n+            }, |_| {\n+                Some(wait_po.recv())\n+            }, &select2i(&mut timeout_po, wait_po)\n+        )\n+    }\n }\n \n // INTERNAL API\n-extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n-                                status: libc::c_int) {\n+extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t, status: libc::c_int) {\n     unsafe {\n         debug!(\n             \"delayed_send_cb handle %? status %?\", handle, status);"}]}