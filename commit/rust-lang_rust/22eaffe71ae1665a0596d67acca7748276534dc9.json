{"sha": "22eaffe71ae1665a0596d67acca7748276534dc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZWFmZmU3MWFlMTY2NWEwNTk2ZDY3YWNjYTc3NDgyNzY1MzRkYzk=", "commit": {"author": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-02-25T23:03:41Z"}, "committer": {"name": "Roxane", "email": "roxane.fruytier@hotmail.com", "date": "2021-03-15T17:16:04Z"}, "message": "Add comments with examples and tests", "tree": {"sha": "644db5df1b85cac402ebfb71e169f3895d171a11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/644db5df1b85cac402ebfb71e169f3895d171a11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22eaffe71ae1665a0596d67acca7748276534dc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22eaffe71ae1665a0596d67acca7748276534dc9", "html_url": "https://github.com/rust-lang/rust/commit/22eaffe71ae1665a0596d67acca7748276534dc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22eaffe71ae1665a0596d67acca7748276534dc9/comments", "author": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "roxelo", "id": 12419401, "node_id": "MDQ6VXNlcjEyNDE5NDAx", "avatar_url": "https://avatars.githubusercontent.com/u/12419401?v=4", "gravatar_id": "", "url": "https://api.github.com/users/roxelo", "html_url": "https://github.com/roxelo", "followers_url": "https://api.github.com/users/roxelo/followers", "following_url": "https://api.github.com/users/roxelo/following{/other_user}", "gists_url": "https://api.github.com/users/roxelo/gists{/gist_id}", "starred_url": "https://api.github.com/users/roxelo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/roxelo/subscriptions", "organizations_url": "https://api.github.com/users/roxelo/orgs", "repos_url": "https://api.github.com/users/roxelo/repos", "events_url": "https://api.github.com/users/roxelo/events{/privacy}", "received_events_url": "https://api.github.com/users/roxelo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb3b77a8c858b7bf673472a99737cd18f5ddbe17", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb3b77a8c858b7bf673472a99737cd18f5ddbe17", "html_url": "https://github.com/rust-lang/rust/commit/fb3b77a8c858b7bf673472a99737cd18f5ddbe17"}], "stats": {"total": 924, "additions": 788, "deletions": 136}, "files": [{"sha": "00c03d75380305f797cb79d7833dd9661fabc191", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -431,7 +431,29 @@ pub struct TypeckResults<'tcx> {\n     /// see `MinCaptureInformationMap` for more details.\n     pub closure_min_captures: ty::MinCaptureInformationMap<'tcx>,\n \n-    pub closure_fake_reads: FxHashMap<DefId, Vec<(HirPlace<'tcx>, FakeReadCause)>>,\n+    /// Tracks the fake reads required for a closure and the reason for the fake read.\n+    /// When performing pattern matching for closures, there are times we don't end up\n+    /// reading places that are mentioned in a closure (because of _ patterns). However,\n+    /// to ensure the places are initialized, we introduce fake reads.\n+    /// Consider these two examples:\n+    /// ``` (discriminant matching with only wildcard arm)\n+    /// let x: u8;\n+    /// let c = || match x { _ => () };\n+    /// ```\n+    /// In this example, we don't need to actually read/borrow `x` in `c`, and so we don't\n+    /// want to capture it. However, we do still want an error here, because `x` should have\n+    /// to be initialized at the point where c is created. Therefore, we add a \"fake read\"\n+    /// instead.\n+    /// ``` (destructured assignments)\n+    /// let c = || {\n+    ///     let (t1, t2) = t;\n+    /// }\n+    /// ```\n+    /// In the second example, we capture the disjoint fields of `t` (`t.0` & `t.1`), but\n+    /// we never capture `t`. This becomes an issue when we build MIR as we require\n+    /// information on `t` in order to create place `t.0` and `t.1`. We can solve this\n+    /// issue by fake reading `t`.\n+    pub closure_fake_reads: FxHashMap<DefId, Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>>,\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator)."}, {"sha": "fbc9c30fe539c59645616852c9ba780c5b554462", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -90,15 +90,13 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n         let hir_projection = match mir_projection {\n             ProjectionElem::Deref => HirProjectionKind::Deref,\n             ProjectionElem::Field(field, _) => {\n-                // We will never encouter this for multivariant enums,\n-                // read the comment for `Downcast`.\n                 let variant = variant.unwrap_or(VariantIdx::new(0));\n                 HirProjectionKind::Field(field.index() as u32, variant)\n             }\n             ProjectionElem::Downcast(.., idx) => {\n-                // This projections exist for enums that have\n-                // single and multiple variants.\n-                // For single variants, enums are not captured completely.\n+                // We don't expect to see multi-variant enums here, as earlier\n+                // phases will have truncated them already. However, there can\n+                // still be downcasts, thanks to single-variant enums.\n                 // We keep track of VariantIdx so we can use this information\n                 // if the next ProjectionElem is a Field.\n                 variant = Some(*idx);\n@@ -200,7 +198,7 @@ fn find_capture_matching_projections<'a, 'tcx>(\n /// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n /// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n-/// Returns a Result with the error being the HirId of the Upvar that was not found.\n+/// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n fn to_upvars_resolved_place_builder<'a, 'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n     tcx: TyCtxt<'tcx>,\n@@ -305,15 +303,23 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n     }\n \n+    /// Attempts to resolve the `PlaceBuilder`.\n+    /// On success, it will return the resolved `PlaceBuilder`.\n+    /// On failure, it will return itself.\n+    ///\n+    /// Upvars resolve may fail for a `PlaceBuilder` when attempting to\n+    /// resolve a disjoint field whose root variable is not captured\n+    /// (destructured assignments) or when attempting to resolve a root\n+    /// variable (discriminant matching with only wildcard arm) that is\n+    /// not captured. This can happen because the final mir that will be\n+    /// generated doesn't require a read for this place. Failures will only\n+    /// happen inside closures.\n     crate fn try_upvars_resolved<'a>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         typeck_results: &'a ty::TypeckResults<'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        match to_upvars_resolved_place_builder(self, tcx, typeck_results) {\n-            Ok(upvars_resolved) => Ok(upvars_resolved),\n-            Err(upvars_unresolved) => Err(upvars_unresolved),\n-        }\n+        to_upvars_resolved_place_builder(self, tcx, typeck_results)\n     }\n \n     crate fn base(&self) -> PlaceBase {\n@@ -662,7 +668,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             block,\n             source_info,\n             len,\n-            Rvalue::Len(slice.clone().into_place(self.tcx, self.typeck_results)),\n+            Rvalue::Len(slice.into_place(self.tcx, self.typeck_results)),\n         );\n         // lt = idx < len\n         self.cfg.push_assign("}, {"sha": "53c87d71e138bc6901324fa2b3d7b717a1ea3215", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -165,13 +165,42 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n                 block.and(Rvalue::Aggregate(box AggregateKind::Tuple, fields))\n             }\n-            ExprKind::Closure {\n-                closure_id,\n-                substs,\n-                upvars,\n-                movability,\n-                fake_reads: opt_fake_reads,\n-            } => {\n+            ExprKind::Closure { closure_id, substs, upvars, movability, fake_reads } => {\n+                // Convert the closure fake reads, if any, from `ExprRef` to mir `Place`\n+                // and push the fake reads.\n+                // This must come before creating the operands. This is required in case\n+                // there is a fake read and a borrow of the same path, since otherwise the\n+                // fake read might interfere with the borrow. Consider an example like this\n+                // one:\n+                // ```\n+                // let mut x = 0;\n+                // let c = || {\n+                //     &mut x; // mutable borrow of `x`\n+                //     match x { _ => () } // fake read of `x`\n+                // };\n+                // ```\n+\n+                // FIXME(RFC2229): Remove feature gate once diagnostics are improved\n+                if this.tcx.features().capture_disjoint_fields {\n+                    for (thir_place, cause, hir_id) in fake_reads.into_iter() {\n+                        let place_builder =\n+                            unpack!(block = this.as_place_builder(block, thir_place));\n+\n+                        if let Ok(place_builder_resolved) =\n+                            place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n+                        {\n+                            let mir_place =\n+                                place_builder_resolved.into_place(this.tcx, this.typeck_results);\n+                            this.cfg.push_fake_read(\n+                                block,\n+                                this.source_info(this.tcx.hir().span(hir_id)),\n+                                cause,\n+                                mir_place,\n+                            );\n+                        }\n+                    }\n+                }\n+\n                 // see (*) above\n                 let operands: Vec<_> = upvars\n                     .into_iter()\n@@ -210,21 +239,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n-                if let Some(fake_reads) = opt_fake_reads {\n-                    for (thir_place, cause) in fake_reads.into_iter() {\n-                        let place_builder =\n-                            unpack!(block = this.as_place_builder(block, thir_place));\n-\n-                        if let Ok(place_builder_resolved) =\n-                            place_builder.clone().try_upvars_resolved(this.tcx, this.typeck_results)\n-                        {\n-                            let mir_place = place_builder_resolved\n-                                .clone()\n-                                .into_place(this.tcx, this.typeck_results);\n-                            this.cfg.push_fake_read(block, source_info, cause, mir_place);\n-                        }\n-                    }\n-                }\n \n                 let result = match substs {\n                     UpvarSubsts::Generator(substs) => {"}, {"sha": "6e8b25c91628b953cb7412dd90a1fe858edb66f4", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -146,8 +146,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if let Ok(scrutinee_builder) =\n             scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n         {\n-            let scrutinee_place =\n-                scrutinee_builder.clone().into_place(self.tcx, self.typeck_results);\n+            let scrutinee_place = scrutinee_builder.into_place(self.tcx, self.typeck_results);\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -245,7 +244,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let arm_source_info = self.source_info(arm.span);\n                 let arm_scope = (arm.scope, arm_source_info);\n                 self.in_scope(arm_scope, arm.lint_level, |this| {\n-                    let body = arm.body.clone();\n+                    let body = arm.body;\n+\n+                    // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                    // `PlaceBuilder` inside a closure. In this case, we don't want to include\n+                    // a scrutinee place. `scrutinee_place_builder` will fail to be resolved\n+                    // if the only match arm is a wildcard (`_`).\n+                    // Example:\n+                    // ```\n+                    // let foo = (0, 1);\n+                    // let c = || {\n+                    //    match foo { _ => () };\n+                    // };\n+                    // ```\n                     let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n                     let scrutinee_place: Place<'tcx>;\n                     if let Ok(scrutinee_builder) = scrutinee_place_builder\n@@ -496,6 +507,20 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n                     )))) = self.local_decls[local].local_info\n                     {\n+                        // `try_upvars_resolved` may fail if it is unable to resolve the given\n+                        // `PlaceBuilder` inside a closure. In this case, we don't want to include\n+                        // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n+                        // assignments. This is because a closure only captures the precise places\n+                        // that it will read and as a result a closure may not capture the entire\n+                        // tuple/struct and rather have individual places that will be read in the\n+                        // final MIR.\n+                        // Example:\n+                        // ```\n+                        // let foo = (0, 1);\n+                        // let c = || {\n+                        //    let (v1, v2) = foo;\n+                        // };\n+                        // ```\n                         if let Ok(match_pair_resolved) =\n                             initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n                         {"}, {"sha": "b13a0ef82015749bba349d3262d04f05abd4740c", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -160,7 +160,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if let Ok(test_place_builder) =\n             place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n         {\n-            place = test_place_builder.clone().into_place(self.tcx, self.typeck_results);\n+            place = test_place_builder.into_place(self.tcx, self.typeck_results);\n         } else {\n             return;\n         }"}, {"sha": "2f58f2975b11552eaaf777512dcb5759fa1462c4", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -454,20 +454,20 @@ impl<'thir, 'tcx> Cx<'thir, 'tcx> {\n                         .map(|(captured_place, ty)| self.capture_upvar(expr, captured_place, ty)),\n                 );\n \n+                // Convert the closure fake reads, if any, from hir `Place` to ExprRef\n                 let fake_reads = match self.typeck_results().closure_fake_reads.get(&def_id) {\n-                    Some(vals) => Some(\n-                        vals.iter()\n-                            .map(|(place, cause)| {\n-                                (\n-                                    self.arena.alloc(\n-                                        self.convert_captured_hir_place(expr, place.clone()),\n-                                    ),\n-                                    *cause,\n-                                )\n-                            })\n-                            .collect(),\n-                    ),\n-                    None => None,\n+                    Some(fake_reads) => fake_reads\n+                        .iter()\n+                        .map(|(place, cause, hir_id)| {\n+                            (\n+                                self.arena\n+                                    .alloc(self.convert_captured_hir_place(expr, place.clone())),\n+                                *cause,\n+                                *hir_id,\n+                            )\n+                        })\n+                        .collect(),\n+                    None => Vec::new(),\n                 };\n \n                 ExprKind::Closure {"}, {"sha": "71d3093854d6c00188c88f4911f4986957d5957a", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -281,7 +281,7 @@ pub enum ExprKind<'thir, 'tcx> {\n         substs: UpvarSubsts<'tcx>,\n         upvars: &'thir [Expr<'thir, 'tcx>],\n         movability: Option<hir::Movability>,\n-        fake_reads: Option<Vec<(&'thir mut Expr<'thir, 'tcx>, FakeReadCause)>>,\n+        fake_reads: Vec<(&'thir mut Expr<'thir, 'tcx>, FakeReadCause, hir::HirId)>,\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,"}, {"sha": "e79349796d226338d5c3557db02a139b97e8cbba", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -248,8 +248,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let final_tupled_upvars_type = self.tcx.mk_tup(final_upvar_tys.iter());\n         self.demand_suptype(span, substs.tupled_upvars_ty(), final_tupled_upvars_type);\n \n-        let fake_reads =\n-            delegate.fake_reads.into_iter().map(|(place, cause)| (place, cause)).collect();\n+        let fake_reads = delegate\n+            .fake_reads\n+            .into_iter()\n+            .map(|(place, cause, hir_id)| (place, cause, hir_id))\n+            .collect();\n         self.typeck_results.borrow_mut().closure_fake_reads.insert(closure_def_id, fake_reads);\n \n         // If we are also inferred the closure kind here,\n@@ -1154,7 +1157,7 @@ struct InferBorrowKind<'a, 'tcx> {\n     /// Place { V1, [ProjectionKind::Field(Index=1, Variant=0)] } : CaptureKind { E2, MutableBorrow }\n     /// ```\n     capture_information: InferredCaptureInformation<'tcx>,\n-    fake_reads: Vec<(Place<'tcx>, FakeReadCause)>,\n+    fake_reads: Vec<(Place<'tcx>, FakeReadCause, hir::HirId)>,\n }\n \n impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n@@ -1416,9 +1419,9 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n-    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause) {\n+    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId) {\n         if let PlaceBase::Upvar(_) = place.base {\n-            self.fake_reads.push((place, cause));\n+            self.fake_reads.push((place, cause, diag_expr_id));\n         }\n     }\n "}, {"sha": "b88a96de6987e84f4dde01a3062bee736def10e1", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -371,18 +371,18 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_fake_reads_map(&mut self) {\n         let mut resolved_closure_fake_reads: FxHashMap<\n             DefId,\n-            Vec<(HirPlace<'tcx>, FakeReadCause)>,\n+            Vec<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>,\n         > = Default::default();\n         for (closure_def_id, fake_reads) in\n             self.fcx.typeck_results.borrow().closure_fake_reads.iter()\n         {\n-            let mut resolved_fake_reads = Vec::<(HirPlace<'tcx>, FakeReadCause)>::new();\n-            for (place, cause) in fake_reads.iter() {\n+            let mut resolved_fake_reads = Vec::<(HirPlace<'tcx>, FakeReadCause, hir::HirId)>::new();\n+            for (place, cause, hir_id) in fake_reads.iter() {\n                 let locatable =\n                     self.tcx().hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n \n                 let resolved_fake_read = self.resolve(place.clone(), &locatable);\n-                resolved_fake_reads.push((resolved_fake_read, *cause));\n+                resolved_fake_reads.push((resolved_fake_read, *cause, *hir_id));\n             }\n             resolved_closure_fake_reads.insert(*closure_def_id, resolved_fake_reads);\n         }"}, {"sha": "dced4aac049adc7fd6a58f36f9a863d1887278bd", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 76, "deletions": 20, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -7,11 +7,11 @@ pub use self::ConsumeMode::*;\n // Export these here so that Clippy can use them.\n pub use rustc_middle::hir::place::{Place, PlaceBase, PlaceWithHirId, Projection};\n \n+use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n-//use rustc_hir::QPath;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::ProjectionKind;\n@@ -54,7 +54,8 @@ pub trait Delegate<'tcx> {\n     // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n-    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause);\n+    // The `place` should be a fake read because of specified `cause`.\n+    fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -241,20 +242,33 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 let ExprUseVisitor { ref mc, body_owner: _, delegate: _ } = *self;\n                 let mut needs_to_be_read = false;\n                 for arm in arms.iter() {\n-                    return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |_place, pat| {\n+                    return_if_err!(mc.cat_pattern(discr_place.clone(), &arm.pat, |place, pat| {\n                         match &pat.kind {\n-                            PatKind::Binding(_, _, _, opt_sub_pat) => {\n+                            PatKind::Binding(.., opt_sub_pat) => {\n                                 // If the opt_sub_pat is None, than the binding does not count as\n-                                // a wildcard for the purpose of borrowing discr\n-                                if let None = opt_sub_pat {\n+                                // a wildcard for the purpose of borrowing discr.\n+                                if opt_sub_pat.is_none() {\n                                     needs_to_be_read = true;\n                                 }\n                             }\n-                            PatKind::TupleStruct(_, _, _)\n-                            | PatKind::Struct(_, _, _)\n-                            | PatKind::Lit(_) => {\n-                                // If the PatKind is a TupleStruct, Struct, or Lit then we want\n-                                // to borrow discr\n+                            PatKind::TupleStruct(..)\n+                            | PatKind::Path(..)\n+                            | PatKind::Struct(..)\n+                            | PatKind::Tuple(..) => {\n+                                // If the PatKind is a TupleStruct, Struct or Tuple then we want to check\n+                                // whether the Variant is a MultiVariant or a SingleVariant. We only want\n+                                // to borrow discr if it is a MultiVariant.\n+                                // If it is a SingleVariant and creates a binding we will handle that when\n+                                // this callback gets called again.\n+                                if let ty::Adt(def, _) = place.place.base_ty.kind() {\n+                                    if def.variants.len() > 1 {\n+                                        needs_to_be_read = true;\n+                                    }\n+                                }\n+                            }\n+                            PatKind::Lit(_) => {\n+                                // If the PatKind is a Lit then we want\n+                                // to borrow discr.\n                                 needs_to_be_read = true;\n                             }\n                             _ => {}\n@@ -264,6 +278,16 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n \n                 if needs_to_be_read {\n                     self.borrow_expr(&discr, ty::ImmBorrow);\n+                } else {\n+                    self.delegate.fake_read(\n+                        discr_place.place.clone(),\n+                        FakeReadCause::ForMatchedPlace,\n+                        discr_place.hir_id,\n+                    );\n+\n+                    // We always want to walk the discriminant. We want to make sure, for instance,\n+                    // that the discriminant has been initialized.\n+                    self.walk_expr(&discr);\n                 }\n \n                 // treatment of the discriminant is handled while walking the arms.\n@@ -553,7 +577,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     }\n \n     fn walk_arm(&mut self, discr_place: &PlaceWithHirId<'tcx>, arm: &hir::Arm<'_>) {\n-        self.delegate.fake_read(discr_place.place.clone(), FakeReadCause::ForMatchedPlace);\n+        self.delegate.fake_read(\n+            discr_place.place.clone(),\n+            FakeReadCause::ForMatchedPlace,\n+            discr_place.hir_id,\n+        );\n         self.walk_pat(discr_place, &arm.pat);\n \n         if let Some(hir::Guard::If(ref e)) = arm.guard {\n@@ -566,7 +594,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// Walks a pat that occurs in isolation (i.e., top-level of fn argument or\n     /// let binding, and *not* a match arm or nested pat.)\n     fn walk_irrefutable_pat(&mut self, discr_place: &PlaceWithHirId<'tcx>, pat: &hir::Pat<'_>) {\n-        self.delegate.fake_read(discr_place.place.clone(), FakeReadCause::ForLet);\n+        self.delegate.fake_read(\n+            discr_place.place.clone(),\n+            FakeReadCause::ForLet,\n+            discr_place.hir_id,\n+        );\n         self.walk_pat(discr_place, pat);\n     }\n \n@@ -634,6 +666,14 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     /// - When reporting the Place back to the Delegate, ensure that the UpvarId uses the enclosing\n     /// closure as the DefId.\n     fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n+        fn upvar_is_local_variable(\n+            upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n+            upvar_id: &hir::HirId,\n+            body_owner_is_closure: bool,\n+        ) -> bool {\n+            upvars.map(|upvars| !upvars.contains_key(upvar_id)).unwrap_or(body_owner_is_closure)\n+        }\n+\n         debug!(\"walk_captures({:?})\", closure_expr);\n \n         let closure_def_id = self.tcx().hir().local_def_id(closure_expr.hir_id).to_def_id();\n@@ -645,16 +685,32 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Closure(..) | ty::Generator(..)\n         );\n \n+        // If we have a nested closure, we want to include the fake reads present in the nested closure.\n         if let Some(fake_reads) = self.mc.typeck_results.closure_fake_reads.get(&closure_def_id) {\n-            for (fake_read, cause) in fake_reads.iter() {\n+            for (fake_read, cause, hir_id) in fake_reads.iter() {\n                 match fake_read.base {\n                     PlaceBase::Upvar(upvar_id) => {\n-                        if upvars.map_or(body_owner_is_closure, |upvars| {\n-                            !upvars.contains_key(&upvar_id.var_path.hir_id)\n-                        }) {\n+                        if upvar_is_local_variable(\n+                            upvars,\n+                            &upvar_id.var_path.hir_id,\n+                            body_owner_is_closure,\n+                        ) {\n                             // The nested closure might be fake reading the current (enclosing) closure's local variables.\n-                            // We check if the root variable is ever mentioned within the enclosing closure, if not\n-                            // then for the current body (if it's a closure) these do not require fake_read, we will ignore them.\n+                            // The only places we want to fake read before creating the parent closure are the ones that\n+                            // are not local to it/ defined by it.\n+                            //\n+                            // ```rust,ignore(cannot-test-this-because-pseduo-code)\n+                            // let v1 = (0, 1);\n+                            // let c = || { // fake reads: v1\n+                            //    let v2 = (0, 1);\n+                            //    let e = || { // fake reads: v1, v2\n+                            //       let (_, t1) = v1;\n+                            //       let (_, t2) = v2;\n+                            //    }\n+                            // }\n+                            // ```\n+                            // This check is performed when visiting the body of the outermost closure (`c`) and ensures\n+                            // that we don't add a fake read of v2 in c.\n                             continue;\n                         }\n                     }\n@@ -665,7 +721,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         );\n                     }\n                 };\n-                self.delegate.fake_read(fake_read.clone(), *cause);\n+                self.delegate.fake_read(fake_read.clone(), *cause, *hir_id);\n             }\n         }\n "}, {"sha": "609a11a578ae81eca6f8b79c7a18e77a5195ff0c", "filename": "src/test/ui/closures/2229_closure_analysis/pattern-matching-should-fail.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,84 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(never_type)]\n+\n+// Should fake read the discriminant and throw an error\n+fn test1() {\n+    let x: !;\n+    let c1 = || match x { };\n+    //~^ ERROR: use of possibly-uninitialized variable: `x`\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test2() {\n+    let x: !;\n+    let c2 = || match x { _ => () };\n+    //~^ ERROR: borrow of possibly-uninitialized variable: `x`\n+}\n+\n+// Testing single variant patterns\n+enum SingleVariant {\n+    Points(u32)\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test3() {\n+    let variant: !;\n+    let c = || {\n+    //~^ ERROR: borrow of possibly-uninitialized variable: `variant`\n+        match variant {\n+            SingleVariant::Points(_) => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test4() {\n+    let variant: !;\n+    let c = || {\n+    //~^ ERROR: borrow of possibly-uninitialized variable: `variant`\n+        match variant {\n+            SingleVariant::Points(a) => {\n+                println!(\"{:?}\", a);\n+            }\n+        }\n+    };\n+    c();\n+}\n+\n+fn test5() {\n+    let t: !;\n+    let g: !;\n+\n+    let a = || {\n+        match g { };\n+        //~^ ERROR: use of possibly-uninitialized variable: `g`\n+        let c = ||  {\n+            match t { };\n+            //~^ ERROR: use of possibly-uninitialized variable: `t`\n+        };\n+\n+        c();\n+    };\n+\n+}\n+\n+// Should fake read the discriminant and throw an error\n+fn test6() {\n+    let x: u8;\n+    let c1 = || match x { };\n+    //~^ ERROR: use of possibly-uninitialized variable: `x`\n+    //~| ERROR: non-exhaustive patterns: type `u8` is non-empty\n+}\n+\n+fn main() {\n+    test1();\n+    test2();\n+    test3();\n+    test4();\n+    test5();\n+    test6();\n+}"}, {"sha": "c225abb58b7311a625fb70332510bb5f9eb57fdf", "filename": "src/test/ui/closures/2229_closure_analysis/pattern-matching-should-fail.stderr", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpattern-matching-should-fail.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,72 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/pattern-matching-should-fail.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n+  --> $DIR/pattern-matching-should-fail.rs:72:23\n+   |\n+LL |     let c1 = || match x { };\n+   |                       ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n+\n+error[E0381]: use of possibly-uninitialized variable: `x`\n+  --> $DIR/pattern-matching-should-fail.rs:10:23\n+   |\n+LL |     let c1 = || match x { };\n+   |                       ^ use of possibly-uninitialized `x`\n+\n+error[E0381]: borrow of possibly-uninitialized variable: `x`\n+  --> $DIR/pattern-matching-should-fail.rs:17:14\n+   |\n+LL |     let c2 = || match x { _ => () };\n+   |              ^^       - borrow occurs due to use in closure\n+   |              |\n+   |              use of possibly-uninitialized `x`\n+\n+error[E0381]: borrow of possibly-uninitialized variable: `variant`\n+  --> $DIR/pattern-matching-should-fail.rs:29:13\n+   |\n+LL |     let c = || {\n+   |             ^^ use of possibly-uninitialized `variant`\n+LL |\n+LL |         match variant {\n+   |               ------- borrow occurs due to use in closure\n+\n+error[E0381]: borrow of possibly-uninitialized variable: `variant`\n+  --> $DIR/pattern-matching-should-fail.rs:41:13\n+   |\n+LL |     let c = || {\n+   |             ^^ use of possibly-uninitialized `variant`\n+LL |\n+LL |         match variant {\n+   |               ------- borrow occurs due to use in closure\n+\n+error[E0381]: use of possibly-uninitialized variable: `g`\n+  --> $DIR/pattern-matching-should-fail.rs:57:15\n+   |\n+LL |         match g { };\n+   |               ^ use of possibly-uninitialized `g`\n+\n+error[E0381]: use of possibly-uninitialized variable: `t`\n+  --> $DIR/pattern-matching-should-fail.rs:60:19\n+   |\n+LL |             match t { };\n+   |                   ^ use of possibly-uninitialized `t`\n+\n+error[E0381]: use of possibly-uninitialized variable: `x`\n+  --> $DIR/pattern-matching-should-fail.rs:72:23\n+   |\n+LL |     let c1 = || match x { };\n+   |                       ^ use of possibly-uninitialized `x`\n+\n+error: aborting due to 8 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0004, E0381.\n+For more information about an error, try `rustc --explain E0004`."}, {"sha": "0a877dd366c7fc93952567df43b1f0f04b9caaa1", "filename": "src/test/ui/closures/2229_closure_analysis/patterns-capture-analysis.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,139 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| NOTE: `#[warn(incomplete_features)]` on by default\n+//~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+#![feature(rustc_attrs)]\n+\n+// Should capture the discriminant since a variant of a multivariant enum is\n+// mentioned in the match arm; the discriminant is captured by the closure regardless\n+// of if it creates a binding\n+fn test_1_should_capture() {\n+    let variant = Some(2229);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match variant {\n+        //~^ NOTE: Capturing variant[] -> ImmBorrow\n+        //~| NOTE: Min Capture variant[] -> ImmBorrow\n+            Some(_) => {}\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Should not capture the discriminant since only a wildcard is mentioned in the\n+// match arm\n+fn test_2_should_not_capture() {\n+    let variant = Some(2229);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+        match variant {\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Testing single variant patterns\n+enum SingleVariant {\n+    Points(u32)\n+}\n+\n+// Should not capture the discriminant since the single variant mentioned\n+// in the match arm does not trigger a binding\n+fn test_3_should_not_capture_single_variant() {\n+    let variant = SingleVariant::Points(1);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+        match variant {\n+            SingleVariant::Points(_) => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Should not capture the discriminant since the single variant mentioned\n+// in the match arm does not trigger a binding\n+fn test_6_should_capture_single_variant() {\n+    let variant = SingleVariant::Points(1);\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match variant {\n+            //~^ NOTE: Capturing variant[] -> ImmBorrow\n+            //~| NOTE: Capturing variant[(0, 0)] -> ImmBorrow\n+            //~| NOTE: Min Capture variant[] -> ImmBorrow\n+            SingleVariant::Points(a) => {\n+                println!(\"{:?}\", a);\n+            }\n+        }\n+    };\n+    c();\n+}\n+\n+// Should not capture the discriminant since only wildcards are mentioned in the\n+// match arm\n+fn test_4_should_not_capture_array() {\n+    let array: [i32; 3] = [0; 3];\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+        match array {\n+            [_,_,_] => {}\n+        }\n+    };\n+    c();\n+}\n+\n+// Testing MultiVariant patterns\n+enum MVariant {\n+    A,\n+    B,\n+    C,\n+}\n+\n+// Should capture the discriminant since a variant of the multi variant enum is\n+// mentioned in the match arm; the discriminant is captured by the closure\n+// regardless of if it creates a binding\n+fn test_5_should_capture_multi_variant() {\n+    let variant = MVariant::A;\n+    let c =  #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    || {\n+    //~^ First Pass analysis includes:\n+    //~| Min Capture analysis includes:\n+        match variant {\n+        //~^ NOTE: Capturing variant[] -> ImmBorrow\n+        //~| NOTE: Min Capture variant[] -> ImmBorrow\n+            MVariant::A => {}\n+            _ => {}\n+        }\n+    };\n+    c();\n+}\n+\n+fn main() {\n+    test_1_should_capture();\n+    test_2_should_not_capture();\n+    test_3_should_not_capture_single_variant();\n+    test_6_should_capture_single_variant();\n+    test_4_should_not_capture_array();\n+    test_5_should_capture_multi_variant();\n+}"}, {"sha": "ad3e96a5753e337c58e0c6ecb66184b83f12c5ed", "filename": "src/test/ui/closures/2229_closure_analysis/patterns-capture-analysis.stderr", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fpatterns-capture-analysis.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,212 @@\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:12:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:33:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:54:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:70:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:92:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/patterns-capture-analysis.rs:116:14\n+   |\n+LL |     let c =  #[rustc_capture_analysis]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/patterns-capture-analysis.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:16:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:19:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:16:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:19:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:36:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match variant {\n+LL | |             _ => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:57:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match variant {\n+LL | |             SingleVariant::Points(_) => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:73:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:76:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+note: Capturing variant[(0, 0)] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:76:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:73:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:76:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:95:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |         match array {\n+LL | |             [_,_,_] => {}\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:119:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:122:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/patterns-capture-analysis.rs:119:5\n+   |\n+LL | /     || {\n+LL | |\n+LL | |\n+LL | |         match variant {\n+...  |\n+LL | |         }\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture variant[] -> ImmBorrow\n+  --> $DIR/patterns-capture-analysis.rs:122:15\n+   |\n+LL |         match variant {\n+   |               ^^^^^^^\n+\n+error: aborting due to 15 previous errors; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "eaea0dbfb5e8c4d4f141a386808f7f17bade1891", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture_with_wildcard_match.rs", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -3,20 +3,23 @@\n //~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n \n fn test1() {\n-    let foo = [1, 2, 3];\n+    let foo : [Vec<u8>; 3] = [\"String\".into(), \"String\".into(), \"String\".into()];\n     let c = || {\n         match foo { _ => () };\n     };\n+    drop(foo);\n+    c();\n }\n \n fn test2() {\n-    let foo = Some([1, 2, 3]);\n+    let foo : Option<[Vec<u8>; 3]> = Some([\"String\".into(), \"String\".into(), \"String\".into()]);\n     let c = || {\n         match foo {\n             Some(_) => 1,\n             _ => 2\n         };\n     };\n+    c();\n }\n \n fn main() {", "previous_filename": "src/test/ui/closures/2229_closure_analysis/run_pass/no_capture_with_wildcard_match.rs"}, {"sha": "2c17a189afbbc9b9b118f030e7d3a2aa70f66dde", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/capture_with_wildcard_match.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fcapture_with_wildcard_match.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/no_capture_with_wildcard_match.rs:2:12\n+  --> $DIR/capture_with_wildcard_match.rs:2:12\n    |\n LL | #![feature(capture_disjoint_fields)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/closures/2229_closure_analysis/run_pass/no_capture_with_wildcard_match.stderr"}, {"sha": "3ad083a92d569690522072d3b28c47ec83eecdaf", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure-pattern-closure-within-closure.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -4,7 +4,6 @@\n #![warn(unused)]\n \n fn main() {\n-    let _z = 9;\n     let t = (String::from(\"Hello\"), String::from(\"World\"));\n     let g = (String::from(\"Mr\"), String::from(\"Goose\"));\n "}, {"sha": "c4abf934123b376e9b9efd669c167f06afb6b43f", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure-pattern-closure-within-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure-pattern-closure-within-closure.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -8,7 +8,7 @@ LL | #![feature(capture_disjoint_fields)]\n    = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n \n warning: unused variable: `t2`\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:15:21\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:14:21\n    |\n LL |             let (_, t2) = t;\n    |                     ^^ help: if this is intentional, prefix it with an underscore: `_t2`\n@@ -21,7 +21,7 @@ LL | #![warn(unused)]\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n \n warning: unused variable: `g2`\n-  --> $DIR/destructure-pattern-closure-within-closure.rs:12:17\n+  --> $DIR/destructure-pattern-closure-within-closure.rs:11:17\n    |\n LL |         let (_, g2) = g;\n    |                 ^^ help: if this is intentional, prefix it with an underscore: `_g2`"}, {"sha": "65527648b2c991e7f185bdadd27434b25e91fb72", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -80,7 +80,6 @@ fn test7() {\n     };\n }\n \n-// [FIXME] RFC2229 Add an explanation for test\n fn test8() {\n     let x = 0;\n     //~^ WARN unused variable: `x`\n@@ -90,10 +89,10 @@ fn test8() {\n \n     let c = || {\n         let _ = x;\n-        let Point { x, y } = p; // 1\n+        let Point { x, y } = p;\n         //~^ WARN unused variable: `x`\n         println!(\"{}\", y);\n-        let (_, _) = tup; // 2\n+        let (_, _) = tup;\n     };\n \n     c();"}, {"sha": "fcfe9ee95f185726d7377bd894c864dc2e5cae49", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/destructure_patterns.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdestructure_patterns.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -45,19 +45,19 @@ LL |     let t = (String::from(\"Hello\"), String::from(\"World\"));\n    |         ^ help: if this is intentional, prefix it with an underscore: `_t`\n \n warning: unused variable: `x`\n-  --> $DIR/destructure_patterns.rs:93:21\n+  --> $DIR/destructure_patterns.rs:92:21\n    |\n-LL |         let Point { x, y } = p; // 1\n+LL |         let Point { x, y } = p;\n    |                     ^ help: try ignoring the field: `x: _`\n \n warning: unused variable: `x`\n-  --> $DIR/destructure_patterns.rs:85:9\n+  --> $DIR/destructure_patterns.rs:84:9\n    |\n LL |     let x = 0;\n    |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n \n warning: unused variable: `tup`\n-  --> $DIR/destructure_patterns.rs:87:9\n+  --> $DIR/destructure_patterns.rs:86:9\n    |\n LL |     let tup = (1, 2);\n    |         ^^^ help: if this is intentional, prefix it with an underscore: `_tup`"}, {"sha": "dae50854d82fb1b8982515f0bbb3f6da7e4cca5b", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/drop_then_use_fake_reads.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,12 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut x = 1;\n+    let c = || {\n+        drop(&mut x);\n+        match x { _ => () }\n+    };\n+}"}, {"sha": "7f811875d1363c425d65caf565b8b19319ef1eb6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/drop_then_use_fake_reads.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fdrop_then_use_fake_reads.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/struct_update_syntax.rs:2:12\n+  --> $DIR/drop_then_use_fake_reads.rs:2:12\n    |\n LL | #![feature(capture_disjoint_fields)]\n    |            ^^^^^^^^^^^^^^^^^^^^^^^", "previous_filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct_update_syntax.stderr"}, {"sha": "9c086fe4bdfe780650ab2c6f2717a5142e4b6f03", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/lit-pattern-matching-with-methods.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Flit-pattern-matching-with-methods.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -21,4 +21,11 @@ fn main() {\n         assert!(matches!(result, Ok(None)));\n     }\n \n+    {\n+        let mut it = map.drain_filter(|_, _| true);\n+        catch_unwind(AssertUnwindSafe(|| while let Some(_) = it.next() {})).unwrap_err();\n+        let result = catch_unwind(AssertUnwindSafe(|| it.next()));\n+        assert!(matches!(result, Ok(None)));\n+    }\n+\n }"}, {"sha": "d260a448926d63cf7b2f1be0c53254e6f76923a2", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct-pattern-matching-with-methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct-pattern-matching-with-methods.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -11,6 +11,7 @@ enum PointType {\n     ThreeD{ x: u32, y: u32, z: u32 }\n }\n \n+// Testing struct patterns\n struct Points {\n     points: Vec<PointType>,\n }"}, {"sha": "34710e69b965952ff037c9faff381c17494478c4", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/struct_update_syntax.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb3b77a8c858b7bf673472a99737cd18f5ddbe17/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3b77a8c858b7bf673472a99737cd18f5ddbe17/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fstruct_update_syntax.rs?ref=fb3b77a8c858b7bf673472a99737cd18f5ddbe17", "patch": "@@ -1,25 +0,0 @@\n-//check-pass\n-#![feature(capture_disjoint_fields)]\n-//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n-#![feature(rustc_attrs)]\n-\n-struct S {\n-    a: String,\n-    b: String,\n-}\n-\n-fn main() {\n-    let s = S {\n-        a: String::new(),\n-        b: String::new(),\n-    };\n-\n-    let c = || {\n-        let s2 = S {\n-            a: format!(\"New a\"),\n-            ..s\n-        };\n-    };\n-\n-    c();\n-}"}, {"sha": "b3bee79254ec4b2cc9ea2a2af877fb27719ba3d6", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/tuple-struct-pattern-matching-with-methods.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Ftuple-struct-pattern-matching-with-methods.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -8,6 +8,7 @@ enum PointType {\n     ThreeD(u32, u32, u32)\n }\n \n+// Testing tuple struct patterns\n struct Points {\n     points: Vec<PointType>,\n }"}, {"sha": "0e6da8f4f18894c2205ca7e1ff3d32b62391edfd", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/use_of_mutable_borrow_and_fake_reads.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,12 @@\n+//check-pass\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+#![feature(rustc_attrs)]\n+\n+fn main() {\n+    let mut x = 0;\n+    let c = || {\n+        &mut x; // mutable borrow of `x`\n+        match x { _ => () } // fake read of `x`\n+    };\n+}"}, {"sha": "7d16d77bf737ec6c94e2ece89fcd9c69877a075a", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/use_of_mutable_borrow_and_fake_reads.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fuse_of_mutable_borrow_and_fake_reads.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -0,0 +1,11 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/use_of_mutable_borrow_and_fake_reads.rs:2:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+warning: 1 warning emitted\n+"}, {"sha": "285c203f382df3b75e69c6e415741122779b937a", "filename": "src/test/ui/pattern/move-ref-patterns/borrowck-move-ref-pattern.stderr", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fmove-ref-patterns%2Fborrowck-move-ref-pattern.stderr?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -189,19 +189,18 @@ LL |     drop(_x3);\n error[E0382]: use of moved value: `tup`\n   --> $DIR/borrowck-move-ref-pattern.rs:43:14\n    |\n-LL |       let mut tup = (U, U, U);\n-   |           ------- move occurs because `tup` has type `(U, U, U)`, which does not implement the `Copy` trait\n-LL |       let c1 = || {\n-   |                -- value moved into closure here\n-LL |           let (ref _x0, _x1, _) = tup;\n-   |                                   --- variable moved due to use in closure\n-LL |       };\n-LL |       let c2 = || {\n-   |  ______________^\n-LL | |\n-LL | |         let (ref mut _x0, _, _x2) = tup;\n-LL | |     };\n-   | |_____^ value used here after move\n+LL |     let mut tup = (U, U, U);\n+   |         ------- move occurs because `tup` has type `(U, U, U)`, which does not implement the `Copy` trait\n+LL |     let c1 = || {\n+   |              -- value moved into closure here\n+LL |         let (ref _x0, _x1, _) = tup;\n+   |                                 --- variable moved due to use in closure\n+LL |     };\n+LL |     let c2 = || {\n+   |              ^^ value used here after move\n+LL |\n+LL |         let (ref mut _x0, _, _x2) = tup;\n+   |                                     --- use occurs due to use in closure\n \n error: aborting due to 18 previous errors\n "}, {"sha": "972167575475e6048f101cee80594eecc1f6d034", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause) { }\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) { }\n }\n \n impl<'a, 'tcx> EscapeDelegate<'a, 'tcx> {"}, {"sha": "d439577f9c33b9918dbf0e1d6fda38924c842a85", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -335,5 +335,5 @@ impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n \n     fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: HirId) {}\n \n-    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause) { }\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _: HirId) { }\n }"}, {"sha": "0b1ab6b7ea188407e64ea32271737365e7903ef6", "filename": "src/tools/clippy/clippy_utils/src/usage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22eaffe71ae1665a0596d67acca7748276534dc9/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fusage.rs?ref=22eaffe71ae1665a0596d67acca7748276534dc9", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n         self.update(&cmt)\n     }\n \n-    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause) { }\n+    fn fake_read(&mut self, _: rustc_typeck::expr_use_visitor::Place<'tcx>, _: FakeReadCause, _:HirId) { }\n }\n \n pub struct ParamBindingIdCollector {"}]}