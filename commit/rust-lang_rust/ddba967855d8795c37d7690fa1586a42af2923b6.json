{"sha": "ddba967855d8795c37d7690fa1586a42af2923b6", "node_id": "C_kwDOAAsO6NoAKGRkYmE5Njc4NTVkODc5NWMzN2Q3NjkwZmExNTg2YTQyYWYyOTIzYjY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-11T06:48:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-11T06:48:06Z"}, "message": "Rollup merge of #93853 - steffahn:map_by_value, r=wesleywiser\n\nMake all `hir::Map` methods consistently by-value\n\n`hir::Map` only consists of a single reference (as part of the contained `TyCtxt`) anyways, so copying is literally zero overhead compared to passing a reference", "tree": {"sha": "f331faedee26b74ad21ee316fbb6848eb63ad3c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f331faedee26b74ad21ee316fbb6848eb63ad3c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddba967855d8795c37d7690fa1586a42af2923b6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiBgamCRBK7hj4Ov3rIwAAbhYIAK8D3k34p1sRJA7uq3zGmLGP\nINRicWS/be5Yyc1k7z4ROj+CJy00FGRBV0Wp6DAFuheff2FoeCmOIDsJSCe2KljT\nTJFPKMBF4gj2DnokqKtdO/ugKBXxlfuV6zuOcca1whTsw76yFj8j2SYN+vX4+LsQ\nreNXVQHVH4JUufpAlotiQOjVwhmPpIIkL5aGkAX4G3h1y8YrmRzUVidQDojpsvuV\naz9ewfg7fJfgZOG64PHyssPtmgyjDDaUVvPyAkghMZrBwN0S/EE0M839quQmoV2r\n4v8hFIXEMVZWeTy1b51lt5hwf5FDZrCwCSsIlQY6bSTfAtBrHkwb29eHClH1eu4=\n=5rjP\n-----END PGP SIGNATURE-----\n", "payload": "tree f331faedee26b74ad21ee316fbb6848eb63ad3c7\nparent b97ccebc7c3189f3cd0f725a14b163836b0a7b22\nparent 7eff2feb62be2ab39b110a434acdc3f852b5a7a3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1644562086 +0100\ncommitter GitHub <noreply@github.com> 1644562086 +0100\n\nRollup merge of #93853 - steffahn:map_by_value, r=wesleywiser\n\nMake all `hir::Map` methods consistently by-value\n\n`hir::Map` only consists of a single reference (as part of the contained `TyCtxt`) anyways, so copying is literally zero overhead compared to passing a reference\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddba967855d8795c37d7690fa1586a42af2923b6", "html_url": "https://github.com/rust-lang/rust/commit/ddba967855d8795c37d7690fa1586a42af2923b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddba967855d8795c37d7690fa1586a42af2923b6/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b97ccebc7c3189f3cd0f725a14b163836b0a7b22", "url": "https://api.github.com/repos/rust-lang/rust/commits/b97ccebc7c3189f3cd0f725a14b163836b0a7b22", "html_url": "https://github.com/rust-lang/rust/commit/b97ccebc7c3189f3cd0f725a14b163836b0a7b22"}, {"sha": "7eff2feb62be2ab39b110a434acdc3f852b5a7a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7eff2feb62be2ab39b110a434acdc3f852b5a7a3", "html_url": "https://github.com/rust-lang/rust/commit/7eff2feb62be2ab39b110a434acdc3f852b5a7a3"}], "stats": {"total": 219, "additions": 108, "deletions": 111}, "files": [{"sha": "e6c057cc8eea5daf2d9e15b1af58ed8502cfde25", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -763,7 +763,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             HirId, ImplItem, ImplItemKind, Item, ItemKind,\n         };\n \n-        fn maybe_body_id_of_fn(hir_map: &Map<'_>, id: HirId) -> Option<BodyId> {\n+        fn maybe_body_id_of_fn(hir_map: Map<'_>, id: HirId) -> Option<BodyId> {\n             match hir_map.find(id) {\n                 Some(Node::Item(Item { kind: ItemKind::Fn(_, _, body_id), .. }))\n                 | Some(Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(_, body_id), .. })) => {\n@@ -774,7 +774,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         }\n         let hir_map = self.infcx.tcx.hir();\n         let mir_body_hir_id = self.mir_hir_id();\n-        if let Some(fn_body_id) = maybe_body_id_of_fn(&hir_map, mir_body_hir_id) {\n+        if let Some(fn_body_id) = maybe_body_id_of_fn(hir_map, mir_body_hir_id) {\n             if let Block(\n                 hir::Block {\n                     expr:"}, {"sha": "c55f2a7b03941461ed0e9ca824d69da656f99532", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -141,22 +141,22 @@ pub trait Map<'hir> {\n // Used when no map is actually available, forcing manual implementation of nested visitors.\n impl<'hir> Map<'hir> for ! {\n     fn find(&self, _: HirId) -> Option<Node<'hir>> {\n-        unreachable!()\n+        *self;\n     }\n     fn body(&self, _: BodyId) -> &'hir Body<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn item(&self, _: ItemId) -> &'hir Item<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn trait_item(&self, _: TraitItemId) -> &'hir TraitItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn impl_item(&self, _: ImplItemId) -> &'hir ImplItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n     fn foreign_item(&self, _: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        unreachable!()\n+        *self;\n     }\n }\n "}, {"sha": "b2de440084cc4e938a9b2a471cdfc432f2ea33c9", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -2226,7 +2226,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         bound_kind: GenericKind<'tcx>,\n         sub: Region<'tcx>,\n     ) -> DiagnosticBuilder<'a> {\n-        let hir = &self.tcx.hir();\n+        let hir = self.tcx.hir();\n         // Attempt to obtain the span of the parameter so we can\n         // suggest adding an explicit lifetime bound to it.\n         let generics = self"}, {"sha": "f36847c778109249544df0d16fc5b77532854aa4", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -149,35 +149,35 @@ impl<'hir> Iterator for ParentOwnerIterator<'hir> {\n }\n \n impl<'hir> Map<'hir> {\n-    pub fn krate(&self) -> &'hir Crate<'hir> {\n+    pub fn krate(self) -> &'hir Crate<'hir> {\n         self.tcx.hir_crate(())\n     }\n \n-    pub fn root_module(&self) -> &'hir Mod<'hir> {\n+    pub fn root_module(self) -> &'hir Mod<'hir> {\n         match self.tcx.hir_owner(CRATE_DEF_ID).map(|o| o.node) {\n             Some(OwnerNode::Crate(item)) => item,\n             _ => bug!(),\n         }\n     }\n \n-    pub fn items(&self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n+    pub fn items(self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n         let krate = self.krate();\n         krate.owners.iter().filter_map(|owner| match owner.as_owner()?.node() {\n             OwnerNode::Item(item) => Some(item),\n             _ => None,\n         })\n     }\n \n-    pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n+    pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         self.tcx.untracked_resolutions.definitions.def_key(def_id)\n     }\n \n-    pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n+    pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n         self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n     }\n \n-    pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n+    pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         self.tcx.untracked_resolutions.definitions.def_path(def_id)\n     }\n@@ -189,7 +189,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id(&self, hir_id: HirId) -> LocalDefId {\n+    pub fn local_def_id(self, hir_id: HirId) -> LocalDefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n             bug!(\n                 \"local_def_id: no entry for `{:?}`, which has a map of `{:?}`\",\n@@ -200,7 +200,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<LocalDefId> {\n+    pub fn opt_local_def_id(self, hir_id: HirId) -> Option<LocalDefId> {\n         if hir_id.local_id == ItemLocalId::new(0) {\n             Some(hir_id.owner)\n         } else {\n@@ -214,18 +214,18 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n+    pub fn local_def_id_to_hir_id(self, def_id: LocalDefId) -> HirId {\n         self.tcx.local_def_id_to_hir_id(def_id)\n     }\n \n-    pub fn iter_local_def_id(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n+    pub fn iter_local_def_id(self) -> impl Iterator<Item = LocalDefId> + 'hir {\n         // Create a dependency to the crate to be sure we reexcute this when the amount of\n         // definitions change.\n         self.tcx.ensure().hir_crate(());\n         self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n     }\n \n-    pub fn opt_def_kind(&self, local_def_id: LocalDefId) -> Option<DefKind> {\n+    pub fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n         let hir_id = self.local_def_id_to_hir_id(local_def_id);\n         let def_kind = match self.find(hir_id)? {\n             Node::Item(item) => match item.kind {\n@@ -312,12 +312,12 @@ impl<'hir> Map<'hir> {\n         Some(def_kind)\n     }\n \n-    pub fn def_kind(&self, local_def_id: LocalDefId) -> DefKind {\n+    pub fn def_kind(self, local_def_id: LocalDefId) -> DefKind {\n         self.opt_def_kind(local_def_id)\n             .unwrap_or_else(|| bug!(\"def_kind: unsupported node: {:?}\", local_def_id))\n     }\n \n-    pub fn find_parent_node(&self, id: HirId) -> Option<HirId> {\n+    pub fn find_parent_node(self, id: HirId) -> Option<HirId> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             Some(self.tcx.hir_owner_parent(id.owner))\n         } else {\n@@ -328,12 +328,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_parent_node(&self, hir_id: HirId) -> HirId {\n+    pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n         self.find_parent_node(hir_id).unwrap()\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n-    pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n+    pub fn find(self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             let owner = self.tcx.hir_owner(id.owner)?;\n             Some(owner.node.into())\n@@ -346,26 +346,26 @@ impl<'hir> Map<'hir> {\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n     #[inline]\n-    pub fn find_by_def_id(&self, id: LocalDefId) -> Option<Node<'hir>> {\n+    pub fn find_by_def_id(self, id: LocalDefId) -> Option<Node<'hir>> {\n         self.find(self.local_def_id_to_hir_id(id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n-    pub fn get(&self, id: HirId) -> Node<'hir> {\n+    pub fn get(self, id: HirId) -> Node<'hir> {\n         self.find(id).unwrap_or_else(|| bug!(\"couldn't find hir id {} in the HIR map\", id))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, panicking if it cannot be found.\n     #[inline]\n-    pub fn get_by_def_id(&self, id: LocalDefId) -> Node<'hir> {\n+    pub fn get_by_def_id(self, id: LocalDefId) -> Node<'hir> {\n         self.find_by_def_id(id).unwrap_or_else(|| bug!(\"couldn't find {:?} in the HIR map\", id))\n     }\n \n-    pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n+    pub fn get_if_local(self, id: DefId) -> Option<Node<'hir>> {\n         id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn get_generics(&self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n+    pub fn get_generics(self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n         let node = self.tcx.hir_owner(id)?;\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n@@ -386,43 +386,43 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n+    pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n     }\n \n-    pub fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n+    pub fn trait_item(self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n     }\n \n-    pub fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n+    pub fn impl_item(self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n     }\n \n-    pub fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n+    pub fn foreign_item(self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n         self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n     }\n \n-    pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n+    pub fn body(self, id: BodyId) -> &'hir Body<'hir> {\n         self.tcx.hir_owner_nodes(id.hir_id.owner).unwrap().bodies[&id.hir_id.local_id]\n     }\n \n-    pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n+    pub fn fn_decl_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             fn_decl(node)\n         } else {\n             bug!(\"no node for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn fn_sig_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n+    pub fn fn_sig_by_hir_id(self, hir_id: HirId) -> Option<&'hir FnSig<'hir>> {\n         if let Some(node) = self.find(hir_id) {\n             fn_sig(node)\n         } else {\n             bug!(\"no node for hir_id `{}`\", hir_id)\n         }\n     }\n \n-    pub fn enclosing_body_owner(&self, hir_id: HirId) -> HirId {\n+    pub fn enclosing_body_owner(self, hir_id: HirId) -> HirId {\n         for (parent, _) in self.parent_iter(hir_id) {\n             if let Some(body) = self.maybe_body_owned_by(parent) {\n                 return self.body_owner(body);\n@@ -435,24 +435,24 @@ impl<'hir> Map<'hir> {\n     /// Returns the `HirId` that corresponds to the definition of\n     /// which this is the body of, i.e., a `fn`, `const` or `static`\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n-    pub fn body_owner(&self, BodyId { hir_id }: BodyId) -> HirId {\n+    pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.get_parent_node(hir_id);\n         assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)));\n         parent\n     }\n \n-    pub fn body_owner_def_id(&self, id: BodyId) -> LocalDefId {\n+    pub fn body_owner_def_id(self, id: BodyId) -> LocalDefId {\n         self.local_def_id(self.body_owner(id))\n     }\n \n     /// Given a `HirId`, returns the `BodyId` associated with it,\n     /// if the node is a body owner, otherwise returns `None`.\n-    pub fn maybe_body_owned_by(&self, hir_id: HirId) -> Option<BodyId> {\n+    pub fn maybe_body_owned_by(self, hir_id: HirId) -> Option<BodyId> {\n         self.find(hir_id).map(associated_body).flatten()\n     }\n \n     /// Given a body owner's id, returns the `BodyId` associated with it.\n-    pub fn body_owned_by(&self, id: HirId) -> BodyId {\n+    pub fn body_owned_by(self, id: HirId) -> BodyId {\n         self.maybe_body_owned_by(id).unwrap_or_else(|| {\n             span_bug!(\n                 self.span(id),\n@@ -462,7 +462,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn body_param_names(&self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n+    pub fn body_param_names(self, id: BodyId) -> impl Iterator<Item = Ident> + 'hir {\n         self.body(id).params.iter().map(|arg| match arg.pat.kind {\n             PatKind::Binding(_, _, ident, _) => ident,\n             _ => Ident::empty(),\n@@ -472,7 +472,7 @@ impl<'hir> Map<'hir> {\n     /// Returns the `BodyOwnerKind` of this `LocalDefId`.\n     ///\n     /// Panics if `LocalDefId` does not have an associated body.\n-    pub fn body_owner_kind(&self, id: HirId) -> BodyOwnerKind {\n+    pub fn body_owner_kind(self, id: HirId) -> BodyOwnerKind {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Const(..), .. })\n             | Node::TraitItem(&TraitItem { kind: TraitItemKind::Const(..), .. })\n@@ -495,7 +495,7 @@ impl<'hir> Map<'hir> {\n     /// This should only be used for determining the context of a body, a return\n     /// value of `Some` does not always suggest that the owner of the body is `const`,\n     /// just that it has to be checked as if it were.\n-    pub fn body_const_context(&self, did: LocalDefId) -> Option<ConstContext> {\n+    pub fn body_const_context(self, did: LocalDefId) -> Option<ConstContext> {\n         let hir_id = self.local_def_id_to_hir_id(did);\n         let ccx = match self.body_owner_kind(hir_id) {\n             BodyOwnerKind::Const => ConstContext::Const,\n@@ -549,7 +549,7 @@ impl<'hir> Map<'hir> {\n         });\n     }\n \n-    pub fn ty_param_owner(&self, id: HirId) -> LocalDefId {\n+    pub fn ty_param_owner(self, id: HirId) -> LocalDefId {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 id.expect_owner()\n@@ -559,7 +559,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn ty_param_name(&self, id: HirId) -> Symbol {\n+    pub fn ty_param_name(self, id: HirId) -> Symbol {\n         match self.get(id) {\n             Node::Item(&Item { kind: ItemKind::Trait(..) | ItemKind::TraitAlias(..), .. }) => {\n                 kw::SelfUpper\n@@ -569,18 +569,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn trait_impls(&self, trait_did: DefId) -> &'hir [LocalDefId] {\n+    pub fn trait_impls(self, trait_did: DefId) -> &'hir [LocalDefId] {\n         self.tcx.all_local_trait_impls(()).get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     /// Gets the attributes on the crate. This is preferable to\n     /// invoking `krate.attrs` because it registers a tighter\n     /// dep-graph access.\n-    pub fn krate_attrs(&self) -> &'hir [ast::Attribute] {\n+    pub fn krate_attrs(self) -> &'hir [ast::Attribute] {\n         self.attrs(CRATE_HIR_ID)\n     }\n \n-    pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n+    pub fn get_module(self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n         let hir_id = HirId::make_owner(module);\n         match self.tcx.hir_owner(module).map(|o| o.node) {\n             Some(OwnerNode::Item(&Item { span, kind: ItemKind::Mod(ref m), .. })) => {\n@@ -620,7 +620,7 @@ impl<'hir> Map<'hir> {\n     /// follows lexical scoping rules -- then you want a different\n     /// approach. You should override `visit_nested_item` in your\n     /// visitor and then call `intravisit::walk_crate` instead.\n-    pub fn visit_all_item_likes<V>(&self, visitor: &mut V)\n+    pub fn visit_all_item_likes<V>(self, visitor: &mut V)\n     where\n         V: itemlikevisit::ItemLikeVisitor<'hir>,\n     {\n@@ -637,7 +637,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// A parallel version of `visit_all_item_likes`.\n-    pub fn par_visit_all_item_likes<V>(&self, visitor: &V)\n+    pub fn par_visit_all_item_likes<V>(self, visitor: &V)\n     where\n         V: itemlikevisit::ParItemLikeVisitor<'hir> + Sync + Send,\n     {\n@@ -653,7 +653,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn visit_item_likes_in_module<V>(&self, module: LocalDefId, visitor: &mut V)\n+    pub fn visit_item_likes_in_module<V>(self, module: LocalDefId, visitor: &mut V)\n     where\n         V: ItemLikeVisitor<'hir>,\n     {\n@@ -676,7 +676,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn for_each_module(&self, f: impl Fn(LocalDefId)) {\n+    pub fn for_each_module(self, f: impl Fn(LocalDefId)) {\n         let mut queue = VecDeque::new();\n         queue.push_back(CRATE_DEF_ID);\n \n@@ -689,12 +689,12 @@ impl<'hir> Map<'hir> {\n \n     #[cfg(not(parallel_compiler))]\n     #[inline]\n-    pub fn par_for_each_module(&self, f: impl Fn(LocalDefId)) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId)) {\n         self.for_each_module(f)\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub fn par_for_each_module(&self, f: impl Fn(LocalDefId) + Sync) {\n+    pub fn par_for_each_module(self, f: impl Fn(LocalDefId) + Sync) {\n         use rustc_data_structures::sync::{par_iter, ParallelIterator};\n         par_iter_submodules(self.tcx, CRATE_DEF_ID, &f);\n \n@@ -721,7 +721,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Checks if the node is left-hand side of an assignment.\n-    pub fn is_lhs(&self, id: HirId) -> bool {\n+    pub fn is_lhs(self, id: HirId) -> bool {\n         match self.find(self.get_parent_node(id)) {\n             Some(Node::Expr(expr)) => match expr.kind {\n                 ExprKind::Assign(lhs, _rhs, _span) => lhs.hir_id == id,\n@@ -733,7 +733,7 @@ impl<'hir> Map<'hir> {\n \n     /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n     /// Used exclusively for diagnostics, to avoid suggestion function calls.\n-    pub fn is_inside_const_context(&self, hir_id: HirId) -> bool {\n+    pub fn is_inside_const_context(self, hir_id: HirId) -> bool {\n         self.body_const_context(self.local_def_id(self.enclosing_body_owner(hir_id))).is_some()\n     }\n \n@@ -759,7 +759,7 @@ impl<'hir> Map<'hir> {\n     ///     false\n     /// }\n     /// ```\n-    pub fn get_return_block(&self, id: HirId) -> Option<HirId> {\n+    pub fn get_return_block(self, id: HirId) -> Option<HirId> {\n         let mut iter = self.parent_iter(id).peekable();\n         let mut ignore_tail = false;\n         if let Some(node) = self.find(id) {\n@@ -799,7 +799,7 @@ impl<'hir> Map<'hir> {\n     /// parent item is in this map. The \"parent item\" is the closest parent node\n     /// in the HIR which is recorded by the map and is an item, either an item\n     /// in a module, trait, or impl.\n-    pub fn get_parent_item(&self, hir_id: HirId) -> LocalDefId {\n+    pub fn get_parent_item(self, hir_id: HirId) -> LocalDefId {\n         if let Some((def_id, _node)) = self.parent_owner_iter(hir_id).next() {\n             def_id\n         } else {\n@@ -809,7 +809,7 @@ impl<'hir> Map<'hir> {\n \n     /// Returns the `HirId` of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    pub(super) fn get_module_parent_node(&self, hir_id: HirId) -> LocalDefId {\n+    pub(super) fn get_module_parent_node(self, hir_id: HirId) -> LocalDefId {\n         for (def_id, node) in self.parent_owner_iter(hir_id) {\n             if let OwnerNode::Item(&Item { kind: ItemKind::Mod(_), .. }) = node {\n                 return def_id;\n@@ -823,7 +823,7 @@ impl<'hir> Map<'hir> {\n     ///\n     /// Used by error reporting when there's a type error in an if or match arm caused by the\n     /// expression needing to be unit.\n-    pub fn get_if_cause(&self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n+    pub fn get_if_cause(self, hir_id: HirId) -> Option<&'hir Expr<'hir>> {\n         for (_, node) in self.parent_iter(hir_id) {\n             match node {\n                 Node::Item(_)\n@@ -841,7 +841,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the nearest enclosing scope. A scope is roughly an item or block.\n-    pub fn get_enclosing_scope(&self, hir_id: HirId) -> Option<HirId> {\n+    pub fn get_enclosing_scope(self, hir_id: HirId) -> Option<HirId> {\n         for (hir_id, node) in self.parent_iter(hir_id) {\n             if let Node::Item(Item {\n                 kind:\n@@ -868,7 +868,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Returns the defining scope for an opaque type definition.\n-    pub fn get_defining_scope(&self, id: HirId) -> HirId {\n+    pub fn get_defining_scope(self, id: HirId) -> HirId {\n         let mut scope = id;\n         loop {\n             scope = self.get_enclosing_scope(scope).unwrap_or(CRATE_HIR_ID);\n@@ -878,7 +878,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn get_foreign_abi(&self, hir_id: HirId) -> Abi {\n+    pub fn get_foreign_abi(self, hir_id: HirId) -> Abi {\n         let parent = self.get_parent_item(hir_id);\n         if let Some(node) = self.tcx.hir_owner(parent) {\n             if let OwnerNode::Item(Item { kind: ItemKind::ForeignMod { abi, .. }, .. }) = node.node\n@@ -892,35 +892,35 @@ impl<'hir> Map<'hir> {\n         )\n     }\n \n-    pub fn expect_item(&self, id: LocalDefId) -> &'hir Item<'hir> {\n+    pub fn expect_item(self, id: LocalDefId) -> &'hir Item<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::Item(item), .. }) => item,\n             _ => bug!(\"expected item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_impl_item(&self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n+    pub fn expect_impl_item(self, id: LocalDefId) -> &'hir ImplItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ImplItem(item), .. }) => item,\n             _ => bug!(\"expected impl item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_trait_item(&self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n+    pub fn expect_trait_item(self, id: LocalDefId) -> &'hir TraitItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::TraitItem(item), .. }) => item,\n             _ => bug!(\"expected trait item, found {}\", self.node_to_string(HirId::make_owner(id))),\n         }\n     }\n \n-    pub fn expect_variant(&self, id: HirId) -> &'hir Variant<'hir> {\n+    pub fn expect_variant(self, id: HirId) -> &'hir Variant<'hir> {\n         match self.find(id) {\n             Some(Node::Variant(variant)) => variant,\n             _ => bug!(\"expected variant, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn expect_foreign_item(&self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n+    pub fn expect_foreign_item(self, id: LocalDefId) -> &'hir ForeignItem<'hir> {\n         match self.tcx.hir_owner(id) {\n             Some(Owner { node: OwnerNode::ForeignItem(item), .. }) => item,\n             _ => {\n@@ -929,14 +929,14 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n+    pub fn expect_expr(self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             Some(Node::Expr(expr)) => expr,\n             _ => bug!(\"expected expr, found {}\", self.node_to_string(id)),\n         }\n     }\n \n-    pub fn opt_name(&self, id: HirId) -> Option<Symbol> {\n+    pub fn opt_name(self, id: HirId) -> Option<Symbol> {\n         Some(match self.get(id) {\n             Node::Item(i) => i.ident.name,\n             Node::ForeignItem(fi) => fi.ident.name,\n@@ -952,7 +952,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n-    pub fn name(&self, id: HirId) -> Symbol {\n+    pub fn name(self, id: HirId) -> Symbol {\n         match self.opt_name(id) {\n             Some(name) => name,\n             None => bug!(\"no name for {}\", self.node_to_string(id)),\n@@ -961,18 +961,18 @@ impl<'hir> Map<'hir> {\n \n     /// Given a node ID, gets a list of attributes associated with the AST\n     /// corresponding to the node-ID.\n-    pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n+    pub fn attrs(self, id: HirId) -> &'hir [ast::Attribute] {\n         self.tcx.hir_attrs(id.owner).get(id.local_id)\n     }\n \n     /// Gets the span of the definition of the specified HIR node.\n     /// This is used by `tcx.get_span`\n-    pub fn span(&self, hir_id: HirId) -> Span {\n+    pub fn span(self, hir_id: HirId) -> Span {\n         self.opt_span(hir_id)\n             .unwrap_or_else(|| bug!(\"hir::map::Map::span: id not in map: {:?}\", hir_id))\n     }\n \n-    pub fn opt_span(&self, hir_id: HirId) -> Option<Span> {\n+    pub fn opt_span(self, hir_id: HirId) -> Option<Span> {\n         let span = match self.find(hir_id)? {\n             Node::Param(param) => param.span,\n             Node::Item(item) => match &item.kind {\n@@ -1021,7 +1021,7 @@ impl<'hir> Map<'hir> {\n \n     /// Like `hir.span()`, but includes the body of function items\n     /// (instead of just the function header)\n-    pub fn span_with_body(&self, hir_id: HirId) -> Span {\n+    pub fn span_with_body(self, hir_id: HirId) -> Span {\n         match self.find(hir_id) {\n             Some(Node::TraitItem(item)) => item.span,\n             Some(Node::ImplItem(impl_item)) => impl_item.span,\n@@ -1031,11 +1031,11 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n+    pub fn span_if_local(self, id: DefId) -> Option<Span> {\n         id.as_local().and_then(|id| self.opt_span(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn res_span(&self, res: Res) -> Option<Span> {\n+    pub fn res_span(self, res: Res) -> Option<Span> {\n         match res {\n             Res::Err => None,\n             Res::Local(id) => Some(self.span(id)),\n@@ -1045,13 +1045,13 @@ impl<'hir> Map<'hir> {\n \n     /// Get a representation of this `id` for debugging purposes.\n     /// NOTE: Do NOT use this in diagnostics!\n-    pub fn node_to_string(&self, id: HirId) -> String {\n+    pub fn node_to_string(self, id: HirId) -> String {\n         hir_id_to_string(self, id)\n     }\n \n     /// Returns the HirId of `N` in `struct Foo<const N: usize = { ... }>` when\n     /// called with the HirId for the `{ ... }` anon const\n-    pub fn opt_const_param_default_param_hir_id(&self, anon_const: HirId) -> Option<HirId> {\n+    pub fn opt_const_param_default_param_hir_id(self, anon_const: HirId) -> Option<HirId> {\n         match self.get(self.get_parent_node(anon_const)) {\n             Node::GenericParam(GenericParam {\n                 hir_id: param_id,\n@@ -1065,27 +1065,27 @@ impl<'hir> Map<'hir> {\n \n impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n     fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n-        self.find(hir_id)\n+        (*self).find(hir_id)\n     }\n \n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.body(id)\n+        (*self).body(id)\n     }\n \n     fn item(&self, id: ItemId) -> &'hir Item<'hir> {\n-        self.item(id)\n+        (*self).item(id)\n     }\n \n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.trait_item(id)\n+        (*self).trait_item(id)\n     }\n \n     fn impl_item(&self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.impl_item(id)\n+        (*self).impl_item(id)\n     }\n \n     fn foreign_item(&self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.foreign_item(id)\n+        (*self).foreign_item(id)\n     }\n }\n \n@@ -1154,7 +1154,7 @@ fn upstream_crates(tcx: TyCtxt<'_>) -> Vec<(StableCrateId, Svh)> {\n     upstream_crates\n }\n \n-fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n+fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n     let id_str = format!(\" (hir_id={})\", id);\n \n     let path_str = || {"}, {"sha": "5a1378a3686b359146f22ddaf9053977209a9b93", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -41,9 +41,9 @@ pub enum LifetimeUseSet<'tcx> {\n }\n \n trait RegionExt {\n-    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n \n-    fn late(index: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n@@ -59,7 +59,7 @@ trait RegionExt {\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n@@ -68,7 +68,7 @@ impl RegionExt for Region {\n         (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id(), origin))\n     }\n \n-    fn late(idx: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n@@ -817,7 +817,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                            Some(Region::early(self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -888,7 +888,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n                     .enumerate()\n                     .map(|(late_bound_idx, param)| {\n-                        let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                        let pair = Region::late(late_bound_idx as u32, self.tcx.hir(), param);\n                         let r = late_region_as_bound_region(self.tcx, &pair.1);\n                         (pair, r)\n                     })\n@@ -1045,7 +1045,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(&self.tcx.hir(), &mut index, &param);\n+                            let (name, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             let Region::EarlyBound(_, def_id, _) = reg else {\n                                 bug!();\n                             };\n@@ -1145,7 +1145,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                            Some(Region::early(self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n                             non_lifetime_count += 1;\n@@ -1214,7 +1214,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                            Some(Region::early(self.tcx.hir(), &mut index, param))\n                         }\n                         GenericParamKind::Const { .. } | GenericParamKind::Type { .. } => {\n                             non_lifetime_count += 1;\n@@ -1368,7 +1368,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                 .enumerate()\n                                 .map(|(late_bound_idx, param)| {\n                                     let pair =\n-                                        Region::late(late_bound_idx as u32, &this.tcx.hir(), param);\n+                                        Region::late(late_bound_idx as u32, this.tcx.hir(), param);\n                                     let r = late_region_as_bound_region(this.tcx, &pair.1);\n                                     (pair, r)\n                                 })\n@@ -1463,11 +1463,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(\n-                    initial_bound_vars + late_bound_idx as u32,\n-                    &self.tcx.hir(),\n-                    param,\n-                );\n+                let pair =\n+                    Region::late(initial_bound_vars + late_bound_idx as u32, self.tcx.hir(), param);\n                 let r = late_region_as_bound_region(self.tcx, &pair.1);\n                 lifetimes.insert(pair.0, pair.1);\n                 r\n@@ -2194,9 +2191,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     if self.map.late_bound.contains(&param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n+                        Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(&self.tcx.hir(), &mut next_early_index, param))\n+                        Some(Region::early(self.tcx.hir(), &mut next_early_index, param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -2216,7 +2213,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n-                let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                let pair = Region::late(late_bound_idx as u32, self.tcx.hir(), param);\n                 late_region_as_bound_region(self.tcx, &pair.1)\n             })\n             .collect();"}, {"sha": "79d55b297fd30b308cc0b4d7849db9a5009d6b5d", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -262,7 +262,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         debug!(\"process_method: {:?}:{}\", def_id, ident);\n \n-        let map = &self.tcx.hir();\n+        let map = self.tcx.hir();\n         let hir_id = map.local_def_id_to_hir_id(def_id);\n         self.nest_typeck_results(def_id, |v| {\n             if let Some(mut method_data) = v.save_ctxt.get_method_data(hir_id, ident, span) {\n@@ -361,7 +361,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         ty_params: &'tcx hir::Generics<'tcx>,\n         body: hir::BodyId,\n     ) {\n-        let map = &self.tcx.hir();\n+        let map = self.tcx.hir();\n         self.nest_typeck_results(item.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n@@ -626,7 +626,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             }\n         }\n \n-        let map = &self.tcx.hir();\n+        let map = self.tcx.hir();\n         self.nest_typeck_results(item.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n@@ -716,7 +716,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         // walk generics and methods\n         self.process_generic_params(generics, &qualname, item.hir_id());\n         for method in methods {\n-            let map = &self.tcx.hir();\n+            let map = self.tcx.hir();\n             self.process_trait_item(map.trait_item(method.id), item.def_id.to_def_id())\n         }\n     }"}, {"sha": "4e7a34d5951113f7474180891ad2f2f58c9bfde0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// Used to set on_unimplemented's `ItemContext`\n     /// to be the enclosing (async) block/function/closure\n     fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str> {\n-        let hir = &self.tcx.hir();\n+        let hir = self.tcx.hir();\n         let node = hir.find(hir_id)?;\n         match &node {\n             hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. }) => {"}, {"sha": "a17553b920f03971056c1532fb49b300e822d0e4", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddba967855d8795c37d7690fa1586a42af2923b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ddba967855d8795c37d7690fa1586a42af2923b6", "patch": "@@ -1663,7 +1663,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let table_owner = table.borrow().hir_owner;\n                 let generics = self.tcx.generics_of(table_owner.to_def_id());\n                 let type_param = generics.type_param(param, self.tcx);\n-                let hir = &self.tcx.hir();\n+                let hir = self.tcx.hir();\n                 if let Some(def_id) = type_param.def_id.as_local() {\n                     let id = hir.local_def_id_to_hir_id(def_id);\n                     // Get the `hir::Param` to verify whether it already has any bounds."}]}