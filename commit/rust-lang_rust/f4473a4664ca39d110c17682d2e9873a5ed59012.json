{"sha": "f4473a4664ca39d110c17682d2e9873a5ed59012", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NDczYTQ2NjRjYTM5ZDExMGMxNzY4MmQyZTk4NzNhNWVkNTkwMTI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-29T12:03:34Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-02-16T15:13:47Z"}, "message": "rustc_trans: promote constant rvalues in functions as an optimization.", "tree": {"sha": "2dd8e662d6946e5b6c0ed8d4e28634e6487b5587", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2dd8e662d6946e5b6c0ed8d4e28634e6487b5587"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4473a4664ca39d110c17682d2e9873a5ed59012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4473a4664ca39d110c17682d2e9873a5ed59012", "html_url": "https://github.com/rust-lang/rust/commit/f4473a4664ca39d110c17682d2e9873a5ed59012", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4473a4664ca39d110c17682d2e9873a5ed59012/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df3cc0c55f2f5f40564517accd27294c0d159187", "url": "https://api.github.com/repos/rust-lang/rust/commits/df3cc0c55f2f5f40564517accd27294c0d159187", "html_url": "https://github.com/rust-lang/rust/commit/df3cc0c55f2f5f40564517accd27294c0d159187"}], "stats": {"total": 1655, "additions": 879, "deletions": 776}, "files": [{"sha": "e73b626e6efdcf579c368a6bd66cfcfe745a30e6", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -881,6 +881,7 @@ extern {\n \n \n     /* Operations on global variables */\n+    pub fn LLVMIsAGlobalVariable(GlobalVar: ValueRef) -> ValueRef;\n     pub fn LLVMAddGlobal(M: ModuleRef, Ty: TypeRef, Name: *const c_char)\n                          -> ValueRef;\n     pub fn LLVMAddGlobalInAddressSpace(M: ModuleRef,"}, {"sha": "5ece5e59299a07bf8fb0b963b3d691f2264295bb", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -278,14 +278,14 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-                let (llval, _) = consts::const_expr(ccx, &*lit_expr);\n+                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let (l1, _) = consts::const_expr(ccx, &**l1);\n-                let (l2, _) = consts::const_expr(ccx, &**l2);\n+                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs);\n+                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {\n@@ -832,8 +832,8 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n \n     let _icx = push_ctxt(\"compare_values\");\n     if ty::type_is_scalar(rhs_t) {\n-        let rs = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n-        return Result::new(rs.bcx, rs.val);\n+        let cmp = compare_scalar_types(cx, lhs, rhs, rhs_t, ast::BiEq, debug_loc);\n+        return Result::new(cx, cmp);\n     }\n \n     match rhs_t.sty {\n@@ -1163,29 +1163,16 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                             }\n                             RangeResult(Result { val: vbegin, .. },\n                                         Result { bcx, val: vend }) => {\n-                                let Result { bcx, val: llge } =\n-                                    compare_scalar_types(bcx,\n-                                                         test_val,\n-                                                         vbegin,\n-                                                         t,\n-                                                         ast::BiGe,\n-                                                         debug_loc);\n-                                let Result { bcx, val: llle } =\n-                                    compare_scalar_types(bcx,\n-                                                         test_val,\n-                                                         vend,\n-                                                         t,\n-                                                         ast::BiLe,\n-                                                         debug_loc);\n-                                Result::new(bcx, And(bcx, llge, llle, debug_loc))\n+                                let llge = compare_scalar_types(bcx, test_val, vbegin,\n+                                                                t, ast::BiGe, debug_loc);\n+                                let llle = compare_scalar_types(bcx, test_val, vend,\n+                                                                t, ast::BiLe, debug_loc);\n+                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n-                                compare_scalar_types(bcx,\n-                                                     test_val,\n-                                                     val,\n-                                                     t,\n-                                                     ast::BiGe,\n-                                                     debug_loc)\n+                                Result::new(bcx, compare_scalar_types(bcx, test_val,\n+                                                                      val, t, ast::BiGe,\n+                                                                      debug_loc))\n                             }\n                         }\n                     };"}, {"sha": "7f7b5cd800660abd835bd50e5b458d674cbab961", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 116, "deletions": 141, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -26,7 +26,6 @@\n #![allow(non_camel_case_types)]\n \n pub use self::ValueOrigin::*;\n-pub use self::scalar_type::*;\n \n use super::CrateTranslation;\n use super::ModuleTranslation;\n@@ -40,7 +39,6 @@ use metadata::{csearch, encoder, loader};\n use middle::astencode;\n use middle::cfg;\n use middle::lang_items::{LangItem, ExchangeMallocFnLangItem, StartFnLangItem};\n-use middle::subst;\n use middle::weak_lang_items;\n use middle::subst::{Subst, Substs};\n use middle::ty::{self, Ty, ClosureTyper};\n@@ -498,7 +496,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               did: ast::DefId,\n                               t: Ty<'tcx>,\n                               parent_id: ast::DefId,\n-                              substs: &subst::Substs<'tcx>)\n+                              substs: &Substs<'tcx>)\n                               -> ValueRef {\n     let _icx = push_ctxt(\"trans_res_dtor\");\n     let did = inline::maybe_instantiate_inline(ccx, did);\n@@ -507,9 +505,9 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         assert_eq!(did.krate, ast::LOCAL_CRATE);\n \n         // Since we're in trans we don't care for any region parameters\n-        let substs = subst::Substs::erased(substs.types.clone());\n+        let substs = ccx.tcx().mk_substs(Substs::erased(substs.types.clone()));\n \n-        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, &substs, None);\n+        let (val, _, _) = monomorphize::monomorphic_fn(ccx, did, substs, None);\n \n         val\n     } else if did.krate == ast::LOCAL_CRATE {\n@@ -532,137 +530,100 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n-// Used only for creating scalar comparison glue.\n-#[derive(Copy)]\n-pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n+pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: ast::BinOp_, signed: bool)\n+                                -> llvm::IntPredicate {\n+    match op {\n+        ast::BiEq => llvm::IntEQ,\n+        ast::BiNe => llvm::IntNE,\n+        ast::BiLt => if signed { llvm::IntSLT } else { llvm::IntULT },\n+        ast::BiLe => if signed { llvm::IntSLE } else { llvm::IntULE },\n+        ast::BiGt => if signed { llvm::IntSGT } else { llvm::IntUGT },\n+        ast::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n+        op => {\n+            ccx.sess().bug(&format!(\"comparison_op_to_icmp_predicate: expected \\\n+                                     comparison operator, found {:?}\", op)[]);\n+        }\n+    }\n+}\n+\n+pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: ast::BinOp_)\n+                                -> llvm::RealPredicate {\n+    match op {\n+        ast::BiEq => llvm::RealOEQ,\n+        ast::BiNe => llvm::RealUNE,\n+        ast::BiLt => llvm::RealOLT,\n+        ast::BiLe => llvm::RealOLE,\n+        ast::BiGt => llvm::RealOGT,\n+        ast::BiGe => llvm::RealOGE,\n+        op => {\n+            ccx.sess().bug(&format!(\"comparison_op_to_fcmp_predicate: expected \\\n+                                     comparison operator, found {:?}\", op)[]);\n+        }\n+    }\n+}\n \n-pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n+pub fn compare_scalar_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                         lhs: ValueRef,\n                                         rhs: ValueRef,\n                                         t: Ty<'tcx>,\n                                         op: ast::BinOp_,\n                                         debug_loc: DebugLoc)\n-                                        -> Result<'blk, 'tcx> {\n-    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op, debug_loc));\n-\n+                                        -> ValueRef {\n     match t.sty {\n-        ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n-        ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n-        ty::ty_ptr(mt) if common::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n-        ty::ty_int(_) => f(signed_int),\n-        ty::ty_float(_) => f(floating_point),\n-            // Should never get here, because t is scalar.\n-        _ => cx.sess().bug(\"non-scalar type passed to compare_scalar_types\")\n-    }\n-}\n-\n-\n-// A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n-                                         lhs: ValueRef,\n-                                         rhs: ValueRef,\n-                                         nt: scalar_type,\n-                                         op: ast::BinOp_,\n-                                         debug_loc: DebugLoc)\n-                                         -> ValueRef {\n-    let _icx = push_ctxt(\"compare_scalar_values\");\n-    fn die(cx: Block) -> ! {\n-        cx.sess().bug(\"compare_scalar_values: must be a comparison operator\");\n-    }\n-    match nt {\n-      nil_type => {\n-        // We don't need to do actual comparisons for nil.\n-        // () == () holds but () < () does not.\n-        match op {\n-          ast::BiEq | ast::BiLe | ast::BiGe => return C_bool(cx.ccx(), true),\n-          ast::BiNe | ast::BiLt | ast::BiGt => return C_bool(cx.ccx(), false),\n-          // refinements would be nice\n-          _ => die(cx)\n+        ty::ty_tup(ref tys) if tys.is_empty() => {\n+            // We don't need to do actual comparisons for nil.\n+            // () == () holds but () < () does not.\n+            match op {\n+                ast::BiEq | ast::BiLe | ast::BiGe => return C_bool(bcx.ccx(), true),\n+                ast::BiNe | ast::BiLt | ast::BiGt => return C_bool(bcx.ccx(), false),\n+                // refinements would be nice\n+                _ => bcx.sess().bug(\"compare_scalar_types: must be a comparison operator\")\n+            }\n         }\n-      }\n-      floating_point => {\n-        let cmp = match op {\n-          ast::BiEq => llvm::RealOEQ,\n-          ast::BiNe => llvm::RealUNE,\n-          ast::BiLt => llvm::RealOLT,\n-          ast::BiLe => llvm::RealOLE,\n-          ast::BiGt => llvm::RealOGT,\n-          ast::BiGe => llvm::RealOGE,\n-          _ => die(cx)\n-        };\n-        return FCmp(cx, cmp, lhs, rhs, debug_loc);\n-      }\n-      signed_int => {\n-        let cmp = match op {\n-          ast::BiEq => llvm::IntEQ,\n-          ast::BiNe => llvm::IntNE,\n-          ast::BiLt => llvm::IntSLT,\n-          ast::BiLe => llvm::IntSLE,\n-          ast::BiGt => llvm::IntSGT,\n-          ast::BiGe => llvm::IntSGE,\n-          _ => die(cx)\n-        };\n-        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n-      }\n-      unsigned_int => {\n-        let cmp = match op {\n-          ast::BiEq => llvm::IntEQ,\n-          ast::BiNe => llvm::IntNE,\n-          ast::BiLt => llvm::IntULT,\n-          ast::BiLe => llvm::IntULE,\n-          ast::BiGt => llvm::IntUGT,\n-          ast::BiGe => llvm::IntUGE,\n-          _ => die(cx)\n-        };\n-        return ICmp(cx, cmp, lhs, rhs, debug_loc);\n-      }\n+        ty::ty_bool | ty::ty_uint(_) | ty::ty_char => {\n+            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n+        }\n+        ty::ty_ptr(mt) if common::type_is_sized(bcx.tcx(), mt.ty) => {\n+            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, false), lhs, rhs, debug_loc)\n+        }\n+        ty::ty_int(_) => {\n+            ICmp(bcx, bin_op_to_icmp_predicate(bcx.ccx(), op, true), lhs, rhs, debug_loc)\n+        }\n+        ty::ty_float(_) => {\n+            FCmp(bcx, bin_op_to_fcmp_predicate(bcx.ccx(), op), lhs, rhs, debug_loc)\n+        }\n+        // Should never get here, because t is scalar.\n+        _ => bcx.sess().bug(\"non-scalar type passed to compare_scalar_types\")\n     }\n }\n \n-pub fn compare_simd_types<'blk, 'tcx>(\n-                    cx: Block<'blk, 'tcx>,\n-                    lhs: ValueRef,\n-                    rhs: ValueRef,\n-                    t: Ty<'tcx>,\n-                    size: uint,\n-                    op: ast::BinOp_,\n-                    debug_loc: DebugLoc)\n-                    -> ValueRef {\n-    let cmp = match t.sty {\n+pub fn compare_simd_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                      lhs: ValueRef,\n+                                      rhs: ValueRef,\n+                                      t: Ty<'tcx>,\n+                                      op: ast::BinOp_,\n+                                      debug_loc: DebugLoc)\n+                                      -> ValueRef {\n+    let signed = match t.sty {\n         ty::ty_float(_) => {\n             // The comparison operators for floating point vectors are challenging.\n             // LLVM outputs a `< size x i1 >`, but if we perform a sign extension\n             // then bitcast to a floating point vector, the result will be `-NaN`\n             // for each truth value. Because of this they are unsupported.\n-            cx.sess().bug(\"compare_simd_types: comparison operators \\\n-                           not supported for floating point SIMD types\")\n-        },\n-        ty::ty_uint(_) => match op {\n-            ast::BiEq => llvm::IntEQ,\n-            ast::BiNe => llvm::IntNE,\n-            ast::BiLt => llvm::IntULT,\n-            ast::BiLe => llvm::IntULE,\n-            ast::BiGt => llvm::IntUGT,\n-            ast::BiGe => llvm::IntUGE,\n-            _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n-        },\n-        ty::ty_int(_) => match op {\n-            ast::BiEq => llvm::IntEQ,\n-            ast::BiNe => llvm::IntNE,\n-            ast::BiLt => llvm::IntSLT,\n-            ast::BiLe => llvm::IntSLE,\n-            ast::BiGt => llvm::IntSGT,\n-            ast::BiGe => llvm::IntSGE,\n-            _ => cx.sess().bug(\"compare_simd_types: must be a comparison operator\"),\n+            bcx.sess().bug(\"compare_simd_types: comparison operators \\\n+                            not supported for floating point SIMD types\")\n         },\n-        _ => cx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n+        ty::ty_uint(_) => false,\n+        ty::ty_int(_) => true,\n+        _ => bcx.sess().bug(\"compare_simd_types: invalid SIMD type\"),\n     };\n-    let return_ty = Type::vector(&type_of(cx.ccx(), t), size as u64);\n+\n+    let cmp = bin_op_to_icmp_predicate(bcx.ccx(), op, signed);\n     // LLVM outputs an `< size x i1 >`, so we need to perform a sign extension\n     // to get the correctly sized type. This will compile to a single instruction\n     // once the IR is converted to assembly if the SIMD instruction is supported\n     // by the target architecture.\n-    SExt(cx, ICmp(cx, cmp, lhs, rhs, debug_loc), return_ty)\n+    SExt(bcx, ICmp(bcx, cmp, lhs, rhs, debug_loc), val_ty(lhs))\n }\n \n // Iterates through the elements of a structural type.\n@@ -679,7 +640,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                    repr: &adt::Repr<'tcx>,\n                                    av: ValueRef,\n                                    variant: &ty::VariantInfo<'tcx>,\n-                                   substs: &subst::Substs<'tcx>,\n+                                   substs: &Substs<'tcx>,\n                                    f: &mut F)\n                                    -> Block<'blk, 'tcx> where\n         F: FnMut(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n@@ -1034,21 +995,39 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                            ptr: ValueRef, t: Ty<'tcx>) -> ValueRef {\n     if type_is_zero_size(cx.ccx(), t) {\n         C_undef(type_of::type_of(cx.ccx(), t))\n-    } else if ty::type_is_bool(t) {\n-        Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n     } else if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n         // We want to pass small aggregates as immediate values, but using an aggregate LLVM type\n         // for this leads to bad optimizations, so its arg type is an appropriately sized integer\n         // and we have to convert it\n         Load(cx, BitCast(cx, ptr, type_of::arg_type_of(cx.ccx(), t).ptr_to()))\n-    } else if ty::type_is_region_ptr(t) || ty::type_is_unique(t) {\n-        LoadNonNull(cx, ptr)\n-    } else if ty::type_is_char(t) {\n-        // a char is a Unicode codepoint, and so takes values from 0\n-        // to 0x10FFFF inclusive only.\n-        LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n     } else {\n-        Load(cx, ptr)\n+        unsafe {\n+            let global = llvm::LLVMIsAGlobalVariable(ptr);\n+            if !global.is_null() && llvm::LLVMIsGlobalConstant(global) == llvm::True {\n+                let val = llvm::LLVMGetInitializer(global);\n+                if !val.is_null() {\n+                    // This could go into its own function, for DRY.\n+                    // (something like \"pre-store packing/post-load unpacking\")\n+                    if ty::type_is_bool(t) {\n+                        return Trunc(cx, val, Type::i1(cx.ccx()));\n+                    } else {\n+                        return val;\n+                    }\n+                }\n+            }\n+        }\n+        if ty::type_is_bool(t) {\n+            Trunc(cx, LoadRangeAssert(cx, ptr, 0, 2, llvm::False), Type::i1(cx.ccx()))\n+        } else if ty::type_is_char(t) {\n+            // a char is a Unicode codepoint, and so takes values from 0\n+            // to 0x10FFFF inclusive only.\n+            LoadRangeAssert(cx, ptr, 0, 0x10FFFF + 1, llvm::False)\n+        } else if (ty::type_is_region_ptr(t) || ty::type_is_unique(t))\n+                  && !common::type_is_fat_ptr(cx.tcx(), t) {\n+            LoadNonNull(cx, ptr)\n+        } else {\n+            Load(cx, ptr)\n+        }\n     }\n }\n \n@@ -1064,7 +1043,7 @@ pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t\n         Store(cx, v, BitCast(cx, dst, type_of::arg_type_of(cx.ccx(), t).ptr_to()));\n     } else {\n         Store(cx, v, dst);\n-    };\n+    }\n }\n \n pub fn init_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, local: &ast::Local)\n@@ -1162,7 +1141,7 @@ pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let llalign = type_of::align_of(ccx, t);\n         call_memcpy(bcx, dst, src, llsz, llalign as u32);\n     } else {\n-        store_ty(bcx, Load(bcx, src), dst, t);\n+        store_ty(bcx, load_ty(bcx, src, t), dst, t);\n     }\n }\n \n@@ -1425,7 +1404,7 @@ pub fn new_fn_ctxt<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n                              id: ast::NodeId,\n                              has_env: bool,\n                              output_type: ty::FnOutput<'tcx>,\n-                             param_substs: &'a Substs<'tcx>,\n+                             param_substs: &'tcx Substs<'tcx>,\n                              sp: Option<Span>,\n                              block_arena: &'a TypedArena<common::BlockS<'a, 'tcx>>)\n                              -> FunctionContext<'a, 'tcx> {\n@@ -1793,7 +1772,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                    decl: &ast::FnDecl,\n                                    body: &ast::Block,\n                                    llfndecl: ValueRef,\n-                                   param_substs: &Substs<'tcx>,\n+                                   param_substs: &'tcx Substs<'tcx>,\n                                    fn_ast_id: ast::NodeId,\n                                    _attributes: &[ast::Attribute],\n                                    output_type: ty::FnOutput<'tcx>,\n@@ -1942,7 +1921,7 @@ pub fn trans_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                           decl: &ast::FnDecl,\n                           body: &ast::Block,\n                           llfndecl: ValueRef,\n-                          param_substs: &Substs<'tcx>,\n+                          param_substs: &'tcx Substs<'tcx>,\n                           id: ast::NodeId,\n                           attrs: &[ast::Attribute]) {\n     let _s = StatRecorder::new(ccx, ccx.tcx().map.path_to_string(id).to_string());\n@@ -1968,7 +1947,7 @@ pub fn trans_enum_variant<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     variant: &ast::Variant,\n                                     _args: &[ast::VariantArg],\n                                     disr: ty::Disr,\n-                                    param_substs: &Substs<'tcx>,\n+                                    param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_enum_variant\");\n \n@@ -2049,7 +2028,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     _fields: &[ast::StructField],\n                                     ctor_id: ast::NodeId,\n-                                    param_substs: &Substs<'tcx>,\n+                                    param_substs: &'tcx Substs<'tcx>,\n                                     llfndecl: ValueRef) {\n     let _icx = push_ctxt(\"trans_tuple_struct\");\n \n@@ -2064,7 +2043,7 @@ pub fn trans_tuple_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                      ctor_id: ast::NodeId,\n                                                      disr: ty::Disr,\n-                                                     param_substs: &Substs<'tcx>,\n+                                                     param_substs: &'tcx Substs<'tcx>,\n                                                      llfndecl: ValueRef) {\n     let ctor_ty = ty::node_id_to_type(ccx.tcx(), ctor_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs, &ctor_ty);\n@@ -2302,21 +2281,22 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n             // translated everywhere it's needed.\n             for (ref ccx, is_origin) in ccx.maybe_iter(!from_external && trans_everywhere) {\n                 let llfn = get_item_val(ccx, item.id);\n+                let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                 if abi != Rust {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n                                                             &item.attrs[],\n                                                             llfn,\n-                                                            &Substs::trans_empty(),\n+                                                            empty_substs,\n                                                             item.id,\n                                                             None);\n                 } else {\n                     trans_fn(ccx,\n                              &**decl,\n                              &**body,\n                              llfn,\n-                             &Substs::trans_empty(),\n+                             empty_substs,\n                              item.id,\n                              &item.attrs[]);\n                 }\n@@ -2792,7 +2772,8 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n-                    let (v, ty) = consts::const_expr(ccx, &**expr);\n+                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs);\n                     ccx.static_values().borrow_mut().insert(id, v);\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -2820,12 +2801,6 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     }\n                 }\n \n-                ast::ItemConst(_, ref expr) => {\n-                    let (v, _) = consts::const_expr(ccx, &**expr);\n-                    ccx.const_values().borrow_mut().insert(id, v);\n-                    v\n-                }\n-\n                 ast::ItemFn(_, _, abi, _, _) => {\n                     let sym = sym();\n                     let llfn = if abi == Rust {"}, {"sha": "bda8b8938b76cb623b023a1afe7c3db7a7b0be0c", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -226,7 +226,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n pub fn trans_fn_ref<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               def_id: ast::DefId,\n                               node: ExprOrMethodCall,\n-                              param_substs: &subst::Substs<'tcx>)\n+                              param_substs: &'tcx subst::Substs<'tcx>)\n                               -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_fn_ref\");\n \n@@ -326,15 +326,15 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                               &function_name[]);\n \n     //\n-    let empty_substs = Substs::trans_empty();\n+    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       llfn,\n                       ast::DUMMY_NODE_ID,\n                       false,\n                       sig.output,\n-                      &empty_substs,\n+                      empty_substs,\n                       None,\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n@@ -386,7 +386,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     ccx: &CrateContext<'a, 'tcx>,\n     def_id: ast::DefId,\n     node: ExprOrMethodCall,\n-    param_substs: &subst::Substs<'tcx>,\n+    param_substs: &'tcx subst::Substs<'tcx>,\n     substs: subst::Substs<'tcx>)\n     -> Datum<'tcx, Rvalue>\n {\n@@ -416,7 +416,9 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n     let (is_default, def_id, substs) = match ty::provided_source(tcx, def_id) {\n-        None => (false, def_id, substs),\n+        None => {\n+            (false, def_id, tcx.mk_substs(substs))\n+        }\n         Some(source_id) => {\n             // There are two relevant substitutions when compiling\n             // default methods. First, there is the substitution for\n@@ -444,7 +446,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n                         .erase_regions();\n \n                     // And compose them\n-                    let new_substs = first_subst.subst(tcx, &substs);\n+                    let new_substs = tcx.mk_substs(first_subst.subst(tcx, &substs));\n \n                     debug!(\"trans_fn_with_vtables - default method: \\\n                             substs = {}, trait_subst = {}, \\\n@@ -463,7 +465,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n     };\n \n     // If this is a closure, redirect to it.\n-    match closure::get_or_create_declaration_if_closure(ccx, def_id, &substs) {\n+    match closure::get_or_create_declaration_if_closure(ccx, def_id, substs) {\n         None => {}\n         Some(llfn) => return llfn,\n     }\n@@ -505,7 +507,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n         };\n \n         let (val, fn_ty, must_cast) =\n-            monomorphize::monomorphic_fn(ccx, def_id, &substs, opt_ref_id);\n+            monomorphize::monomorphic_fn(ccx, def_id, substs, opt_ref_id);\n         if must_cast && node != ExprId(0) {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)"}, {"sha": "f92df999e6049a3da4c189da516a2cbe925c98d4", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use back::link::mangle_internal_name_by_path_and_seq;\n+use llvm::ValueRef;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n@@ -137,7 +138,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_closure(_, _, ref substs) => substs.types.clone(),\n+        ty::ty_closure(_, _, substs) => &substs.types,\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {\n@@ -171,41 +172,51 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     Some(Datum::new(llfn, function_type, Rvalue::new(ByValue)))\n }\n \n-pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                                      decl: &ast::FnDecl,\n-                                      body: &ast::Block,\n-                                      id: ast::NodeId,\n-                                      dest: expr::Dest)\n-                                      -> Block<'blk, 'tcx>\n+pub enum Dest<'a, 'tcx: 'a> {\n+    SaveIn(Block<'a, 'tcx>, ValueRef),\n+    Ignore(&'a CrateContext<'a, 'tcx>)\n+}\n+\n+pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n+                                    decl: &ast::FnDecl,\n+                                    body: &ast::Block,\n+                                    id: ast::NodeId,\n+                                    param_substs: &'tcx Substs<'tcx>)\n+                                    -> Option<Block<'a, 'tcx>>\n {\n+    let ccx = match dest {\n+        Dest::SaveIn(bcx, _) => bcx.ccx(),\n+        Dest::Ignore(ccx) => ccx\n+    };\n+    let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"closure::trans_closure\");\n \n     debug!(\"trans_closure()\");\n \n     let closure_id = ast_util::local_def(id);\n     let llfn = get_or_create_declaration_if_closure(\n-        bcx.ccx(),\n+        ccx,\n         closure_id,\n-        bcx.fcx.param_substs).unwrap();\n+        param_substs).unwrap();\n \n     // Get the type of this closure. Use the current `param_substs` as\n     // the closure substitutions. This makes sense because the closure\n     // takes the same set of type arguments as the enclosing fn, and\n     // this function (`trans_closure`) is invoked at the point\n     // of the closure expression.\n-    let typer = NormalizingClosureTyper::new(bcx.tcx());\n-    let function_type = typer.closure_type(closure_id, bcx.fcx.param_substs);\n+    let typer = NormalizingClosureTyper::new(tcx);\n+    let function_type = typer.closure_type(closure_id, param_substs);\n \n     let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(bcx.tcx(), id, |fv| fv.iter().map(|&fv| fv).collect());\n+        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n \n-    let sig = ty::erase_late_bound_regions(bcx.tcx(), &function_type.sig);\n+    let sig = ty::erase_late_bound_regions(tcx, &function_type.sig);\n \n-    trans_closure(bcx.ccx(),\n+    trans_closure(ccx,\n                   decl,\n                   body,\n                   llfn.val,\n-                  bcx.fcx.param_substs,\n+                  param_substs,\n                   id,\n                   &[],\n                   sig.output,\n@@ -215,15 +226,15 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Don't hoist this to the top of the function. It's perfectly legitimate\n     // to have a zero-size closure (in which case dest will be `Ignore`) and\n     // we must still generate the closure body.\n-    let dest_addr = match dest {\n-        expr::SaveIn(p) => p,\n-        expr::Ignore => {\n+    let (mut bcx, dest_addr) = match dest {\n+        Dest::SaveIn(bcx, p) => (bcx, p),\n+        Dest::Ignore(_) => {\n             debug!(\"trans_closure() ignoring result\");\n-            return bcx\n+            return None;\n         }\n     };\n \n-    let repr = adt::represent_type(bcx.ccx(), node_id_type(bcx, id));\n+    let repr = adt::represent_type(ccx, node_id_type(bcx, id));\n \n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n@@ -235,8 +246,7 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                    i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n                                      closure_expr_id: id };\n-        let upvar_capture = bcx.tcx().upvar_capture(upvar_id).unwrap();\n-        match upvar_capture {\n+        match tcx.upvar_capture(upvar_id).unwrap() {\n             ty::UpvarCapture::ByValue => {\n                 bcx = datum.store_to(bcx, upvar_slot_dest);\n             }\n@@ -247,6 +257,6 @@ pub fn trans_closure_expr<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n     adt::trans_set_discr(bcx, &*repr, dest_addr, 0);\n \n-    bcx\n+    Some(bcx)\n }\n "}, {"sha": "d658003702dcaabbb90924dd1e326774dbad7a8e", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 7, "deletions": 20, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -410,7 +410,7 @@ pub struct FunctionContext<'a, 'tcx: 'a> {\n \n     // If this function is being monomorphized, this contains the type\n     // substitutions used.\n-    pub param_substs: &'a Substs<'tcx>,\n+    pub param_substs: &'tcx Substs<'tcx>,\n \n     // The source span and nesting context where this function comes from, for\n     // error reporting and symbol generation.\n@@ -858,25 +858,6 @@ pub fn C_str_slice(cx: &CrateContext, s: InternedString) -> ValueRef {\n     C_named_struct(cx.tn().find_type(\"str_slice\").unwrap(), &[cs, C_uint(cx, len)])\n }\n \n-pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n-    unsafe {\n-        let len = data.len();\n-        let lldata = C_bytes(cx, data);\n-\n-        let gsym = token::gensym(\"binary\");\n-        let name = format!(\"binary{}\", gsym.usize());\n-        let name = CString::from_vec(name.into_bytes());\n-        let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n-                                    name.as_ptr());\n-        llvm::LLVMSetInitializer(g, lldata);\n-        llvm::LLVMSetGlobalConstant(g, True);\n-        llvm::SetLinkage(g, llvm::InternalLinkage);\n-\n-        let cs = consts::ptrcast(g, Type::i8p(cx));\n-        C_struct(cx, &[cs, C_uint(cx, len)], false)\n-    }\n-}\n-\n pub fn C_struct(cx: &CrateContext, elts: &[ValueRef], packed: bool) -> ValueRef {\n     C_struct_in_context(cx.llcx(), elts, packed)\n }\n@@ -901,6 +882,12 @@ pub fn C_array(ty: Type, elts: &[ValueRef]) -> ValueRef {\n     }\n }\n \n+pub fn C_vector(elts: &[ValueRef]) -> ValueRef {\n+    unsafe {\n+        return llvm::LLVMConstVector(elts.as_ptr(), elts.len() as c_uint);\n+    }\n+}\n+\n pub fn C_bytes(cx: &CrateContext, bytes: &[u8]) -> ValueRef {\n     C_bytes_in_context(cx.llcx(), bytes)\n }"}, {"sha": "e4cbfc9a186e3da6c8b8a7402906da77a4fdd9d4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 316, "deletions": 237, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -11,13 +11,13 @@\n \n use back::abi;\n use llvm;\n-use llvm::{ConstFCmp, ConstICmp, SetLinkage, PrivateLinkage, ValueRef, Bool, True, False};\n-use llvm::{IntEQ, IntNE, IntUGT, IntUGE, IntULT, IntULE, IntSGT, IntSGE, IntSLT, IntSLE,\n-           RealOEQ, RealOGT, RealOGE, RealOLT, RealOLE, RealONE};\n-use middle::{const_eval, def};\n-use trans::{adt, consts, debuginfo, expr, inline, machine};\n+use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n+use llvm::{PrivateLinkage, ValueRef, Bool, True};\n+use middle::{check_const, const_eval, def};\n+use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::*;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n use middle::subst::Substs;\n@@ -74,7 +74,16 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, &data[]),\n+        ast::LitBinary(ref data) => {\n+            let g = addr_of(cx, C_bytes(cx, &data[]), \"binary\", e.id);\n+            let base = ptrcast(g, Type::i8p(cx));\n+            let prev_const = cx.const_unsized().borrow_mut()\n+                               .insert(base, g);\n+            assert!(prev_const.is_none() || prev_const == Some(g));\n+            assert_eq!(abi::FAT_PTR_ADDR, 0);\n+            assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+            C_struct(cx, &[base, C_uint(cx, data.len())], false)\n+        }\n     }\n }\n \n@@ -84,36 +93,41 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n-fn const_vec(cx: &CrateContext, e: &ast::Expr,\n-             es: &[P<ast::Expr>]) -> (ValueRef, Type) {\n-    let vec_ty = ty::expr_ty(cx.tcx(), e);\n-    let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n-    let llunitty = type_of::type_of(cx, unit_ty);\n-    let vs = es.iter().map(|e| const_expr(cx, &**e).0)\n-                      .collect::<Vec<_>>();\n-    // If the vector contains enums, an LLVM array won't work.\n-    let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, &vs[], false)\n-    } else {\n-        C_array(llunitty, &vs[])\n-    };\n-    (v, llunitty)\n-}\n-\n-pub fn const_addr_of(cx: &CrateContext, cv: ValueRef, mutbl: ast::Mutability) -> ValueRef {\n+fn addr_of_mut(ccx: &CrateContext,\n+               cv: ValueRef,\n+               kind: &str,\n+               id: ast::NodeId)\n+               -> ValueRef {\n     unsafe {\n-        let gv = llvm::LLVMAddGlobal(cx.llmod(), val_ty(cv).to_ref(),\n-                                     \"const\\0\".as_ptr() as *const _);\n+        let name = format!(\"{}{}\\0\", kind, id);\n+        let gv = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(cv).to_ref(),\n+                                     name.as_ptr() as *const _);\n         llvm::LLVMSetInitializer(gv, cv);\n-        llvm::LLVMSetGlobalConstant(gv,\n-                                    if mutbl == ast::MutImmutable {True} else {False});\n         SetLinkage(gv, PrivateLinkage);\n+        SetUnnamedAddr(gv, true);\n         gv\n     }\n }\n \n+pub fn addr_of(ccx: &CrateContext,\n+               cv: ValueRef,\n+               kind: &str,\n+               id: ast::NodeId)\n+               -> ValueRef {\n+    match ccx.const_globals().borrow().get(&cv) {\n+        Some(&gv) => return gv,\n+        None => {}\n+    }\n+    let gv = addr_of_mut(ccx, cv, kind, id);\n+    unsafe {\n+        llvm::LLVMSetGlobalConstant(gv, True);\n+    }\n+    ccx.const_globals().borrow_mut().insert(cv, gv);\n+    gv\n+}\n+\n fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n-    let v = match cx.const_globals().borrow().get(&(v as int)) {\n+    let v = match cx.const_unsized().borrow().get(&v) {\n         Some(&v) => v,\n         None => v\n     };\n@@ -122,155 +136,209 @@ fn const_deref_ptr(cx: &CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-fn const_deref_newtype<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef, t: Ty<'tcx>)\n-    -> ValueRef {\n-    let repr = adt::represent_type(cx, t);\n-    adt::const_get_field(cx, &*repr, v, 0, 0)\n-}\n-\n-fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n-                         t: Ty<'tcx>, explicit: bool)\n+fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                         v: ValueRef,\n+                         ty: Ty<'tcx>)\n                          -> (ValueRef, Ty<'tcx>) {\n-    match ty::deref(t, explicit) {\n-        Some(ref mt) => {\n-            match t.sty {\n-                ty::ty_ptr(mt) | ty::ty_rptr(_, mt) => {\n-                    if type_is_sized(cx.tcx(), mt.ty) {\n-                        (const_deref_ptr(cx, v), mt.ty)\n-                    } else {\n-                        // Derefing a fat pointer does not change the representation,\n-                        // just the type to ty_open.\n-                        (v, ty::mk_open(cx.tcx(), mt.ty))\n-                    }\n-                }\n-                ty::ty_enum(..) | ty::ty_struct(..) => {\n-                    assert!(mt.mutbl != ast::MutMutable);\n-                    (const_deref_newtype(cx, v, t), mt.ty)\n-                }\n-                _ => {\n-                    cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t))[])\n-                }\n+    match ty::deref(ty, true) {\n+        Some(mt) => {\n+            if type_is_sized(cx.tcx(), mt.ty) {\n+                (const_deref_ptr(cx, v), mt.ty)\n+            } else {\n+                // Derefing a fat pointer does not change the representation,\n+                // just the type to ty_open.\n+                (v, ty::mk_open(cx.tcx(), mt.ty))\n             }\n         }\n         None => {\n-            cx.sess().bug(&format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t))[])\n+            cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n+                                   ty_to_string(cx.tcx(), ty))[])\n         }\n     }\n }\n \n-pub fn get_const_val(cx: &CrateContext,\n-                     mut def_id: ast::DefId) -> ValueRef {\n-    let contains_key = cx.const_values().borrow().contains_key(&def_id.node);\n-    if !ast_util::is_local(def_id) || !contains_key {\n-        if !ast_util::is_local(def_id) {\n-            def_id = inline::maybe_instantiate_inline(cx, def_id);\n-        }\n+pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                def_id: ast::DefId,\n+                                ref_expr: &ast::Expr)\n+                                -> &'tcx ast::Expr {\n+    let def_id = inline::maybe_instantiate_inline(ccx, def_id);\n+\n+    if def_id.krate != ast::LOCAL_CRATE {\n+        ccx.sess().span_bug(ref_expr.span,\n+                            \"cross crate constant could not be inlined\");\n+    }\n+\n+    let item = ccx.tcx().map.expect_item(def_id.node);\n+    if let ast::ItemConst(_, ref expr) = item.node {\n+        &**expr\n+    } else {\n+        ccx.sess().span_bug(ref_expr.span,\n+                            &format!(\"get_const_val given non-constant item {}\",\n+                                     item.repr(ccx.tcx()))[]);\n+    }\n+}\n \n-        if let ast::ItemConst(..) = cx.tcx().map.expect_item(def_id.node).node {\n-            base::get_item_val(cx, def_id.node);\n+fn get_const_val(ccx: &CrateContext,\n+                 def_id: ast::DefId,\n+                 ref_expr: &ast::Expr) -> ValueRef {\n+    let expr = get_const_expr(ccx, def_id, ref_expr);\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+    get_const_expr_as_global(ccx, expr, check_const::PURE_CONST, empty_substs)\n+}\n+\n+pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                          expr: &ast::Expr,\n+                                          qualif: check_const::ConstQualif,\n+                                          param_substs: &'tcx Substs<'tcx>)\n+                                          -> ValueRef {\n+    // Special-case constants to cache a common global for all uses.\n+    match expr.node {\n+        ast::ExprPath(_) => {\n+            let def = ccx.tcx().def_map.borrow()[expr.id];\n+            match def {\n+                def::DefConst(def_id) => {\n+                    if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n+                        return get_const_val(ccx, def_id, expr);\n+                    }\n+                }\n+                _ => {}\n+            }\n         }\n+        _ => {}\n+    }\n+\n+    let key = (expr.id, param_substs);\n+    match ccx.const_values().borrow().get(&key) {\n+        Some(&val) => return val,\n+        None => {}\n     }\n+    let val = if qualif.intersects(check_const::NON_STATIC_BORROWS) {\n+        // Avoid autorefs as they would create global instead of stack\n+        // references, even when only the latter are correct.\n+        let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n+                                                  &ty::expr_ty(ccx.tcx(), expr));\n+        const_expr_unadjusted(ccx, expr, ty, param_substs)\n+    } else {\n+        const_expr(ccx, expr, param_substs).0\n+    };\n \n-    cx.const_values().borrow()[def_id.node].clone()\n+    // boolean SSA values are i1, but they have to be stored in i8 slots,\n+    // otherwise some LLVM optimization passes don't work as expected\n+    let val = unsafe {\n+        if llvm::LLVMTypeOf(val) == Type::i1(ccx).to_ref() {\n+            llvm::LLVMConstZExt(val, Type::i8(ccx).to_ref())\n+        } else {\n+            val\n+        }\n+    };\n+\n+    let lvalue = addr_of(ccx, val, \"const\", expr.id);\n+    ccx.const_values().borrow_mut().insert(key, lvalue);\n+    lvalue\n }\n \n-pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n+pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                            e: &ast::Expr,\n+                            param_substs: &'tcx Substs<'tcx>)\n                             -> (ValueRef, Ty<'tcx>) {\n-    let llconst = const_expr_unadjusted(cx, e);\n+    let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n+                                               &ty::expr_ty(cx.tcx(), e));\n+    let llconst = const_expr_unadjusted(cx, e, ety, param_substs);\n     let mut llconst = llconst;\n-    let ety = ty::expr_ty(cx.tcx(), e);\n-    let mut ety_adjusted = ty::expr_ty_adjusted(cx.tcx(), e);\n+    let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n+                                                            &ty::expr_ty_adjusted(cx.tcx(), e));\n     let opt_adj = cx.tcx().adjustments.borrow().get(&e.id).cloned();\n     match opt_adj {\n-        None => { }\n-        Some(adj) => {\n-            match adj {\n-               ty::AdjustReifyFnPointer(_def_id) => {\n-                    // FIXME(#19925) once fn item types are\n-                    // zero-sized, we'll need to do something here\n+        Some(ty::AdjustReifyFnPointer(_def_id)) => {\n+            // FIXME(#19925) once fn item types are\n+            // zero-sized, we'll need to do something here\n+        }\n+        Some(ty::AdjustDerefRef(adj)) => {\n+            let mut ty = ety;\n+            // Save the last autoderef in case we can avoid it.\n+            if adj.autoderefs > 0 {\n+                for _ in 0..adj.autoderefs-1 {\n+                    let (dv, dt) = const_deref(cx, llconst, ty);\n+                    llconst = dv;\n+                    ty = dt;\n                 }\n-                ty::AdjustDerefRef(ref adj) => {\n-                    let mut ty = ety;\n-                    // Save the last autoderef in case we can avoid it.\n-                    if adj.autoderefs > 0 {\n-                        for _ in 0..adj.autoderefs-1 {\n-                            let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                            llconst = dv;\n-                            ty = dt;\n-                        }\n-                    }\n+            }\n \n-                    match adj.autoref {\n-                        None => {\n-                            let (dv, dt) = const_deref(cx, llconst, ty, false);\n-                            llconst = dv;\n+            let second_autoref = match adj.autoref {\n+                None => {\n+                    let (dv, dt) = const_deref(cx, llconst, ty);\n+                    llconst = dv;\n \n-                            // If we derefed a fat pointer then we will have an\n-                            // open type here. So we need to update the type with\n-                            // the one returned from const_deref.\n-                            ety_adjusted = dt;\n-                        }\n-                        Some(ref autoref) => {\n-                            match *autoref {\n-                                ty::AutoUnsafe(_, None) |\n-                                ty::AutoPtr(ty::ReStatic, _, None) => {\n-                                    // Don't copy data to do a deref+ref\n-                                    // (i.e., skip the last auto-deref).\n-                                    if adj.autoderefs == 0 {\n-                                        llconst = const_addr_of(cx, llconst, ast::MutImmutable);\n-                                    }\n-                                }\n-                                ty::AutoPtr(ty::ReStatic, _, Some(box ty::AutoUnsize(..))) => {\n-                                    if adj.autoderefs > 0 {\n-                                        // Seeing as we are deref'ing here and take a reference\n-                                        // again to make the pointer part of the far pointer below,\n-                                        // we just skip the whole thing. We still need the type\n-                                        // though. This works even if we don't need to deref\n-                                        // because of byref semantics. Note that this is not just\n-                                        // an optimisation, it is necessary for mutable vectors to\n-                                        // work properly.\n-                                        let (_, dt) = const_deref(cx, llconst, ty, false);\n-                                        ty = dt;\n-                                    } else {\n-                                        llconst = const_addr_of(cx, llconst, ast::MutImmutable)\n-                                    }\n-\n-                                    match ty.sty {\n-                                        ty::ty_vec(unit_ty, Some(len)) => {\n-                                            let llunitty = type_of::type_of(cx, unit_ty);\n-                                            let llptr = ptrcast(llconst, llunitty.ptr_to());\n-                                            let prev_const = cx.const_globals().borrow_mut()\n-                                                             .insert(llptr as int, llconst);\n-                                            assert!(prev_const.is_none() ||\n-                                                    prev_const == Some(llconst));\n-                                            assert_eq!(abi::FAT_PTR_ADDR, 0);\n-                                            assert_eq!(abi::FAT_PTR_EXTRA, 1);\n-                                            llconst = C_struct(cx, &[\n-                                                llptr,\n-                                                C_uint(cx, len)\n-                                            ], false);\n-                                        }\n-                                        _ => cx.sess().span_bug(e.span,\n-                                            &format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty))[])\n-                                    }\n-                                }\n-                                _ => {\n-                                    cx.sess()\n-                                      .span_bug(e.span,\n-                                                &format!(\"unimplemented const \\\n-                                                         autoref {:?}\",\n-                                                        autoref)[])\n+                    // If we derefed a fat pointer then we will have an\n+                    // open type here. So we need to update the type with\n+                    // the one returned from const_deref.\n+                    ety_adjusted = dt;\n+                    None\n+                }\n+                Some(ty::AutoUnsafe(_, opt_autoref)) |\n+                Some(ty::AutoPtr(_, _, opt_autoref)) => {\n+                    if adj.autoderefs == 0 {\n+                        // Don't copy data to do a deref+ref\n+                        // (i.e., skip the last auto-deref).\n+                        llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                    } else {\n+                        // Seeing as we are deref'ing here and take a reference\n+                        // again to make the pointer part of the far pointer below,\n+                        // we just skip the whole thing. We still need the type\n+                        // though. This works even if we don't need to deref\n+                        // because of byref semantics. Note that this is not just\n+                        // an optimisation, it is necessary for mutable vectors to\n+                        // work properly.\n+                        ty = match ty::deref(ty, true) {\n+                            Some(mt) => {\n+                                if type_is_sized(cx.tcx(), mt.ty) {\n+                                    mt.ty\n+                                } else {\n+                                    // Derefing a fat pointer does not change the representation,\n+                                    // just the type to ty_open.\n+                                    ty::mk_open(cx.tcx(), mt.ty)\n                                 }\n                             }\n+                            None => {\n+                                cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n+                                                       ty_to_string(cx.tcx(), ty))[])\n+                            }\n                         }\n                     }\n+                    opt_autoref\n+                }\n+                Some(autoref) => {\n+                    cx.sess().span_bug(e.span,\n+                        &format!(\"unimplemented const first autoref {:?}\", autoref)[])\n+                }\n+            };\n+            match second_autoref {\n+                None => {}\n+                Some(box ty::AutoUnsafe(_, None)) |\n+                Some(box ty::AutoPtr(_, _, None)) => {\n+                    llconst = addr_of(cx, llconst, \"autoref\", e.id);\n+                }\n+                Some(box ty::AutoUnsize(ref k)) => {\n+                    let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);\n+                    let info = expr::unsized_info(cx, k, e.id, ty, param_substs,\n+                        |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t));\n+\n+                    let base = ptrcast(llconst, type_of::type_of(cx, unsized_ty).ptr_to());\n+                    let prev_const = cx.const_unsized().borrow_mut()\n+                                       .insert(base, llconst);\n+                    assert!(prev_const.is_none() || prev_const == Some(llconst));\n+                    assert_eq!(abi::FAT_PTR_ADDR, 0);\n+                    assert_eq!(abi::FAT_PTR_EXTRA, 1);\n+                    llconst = C_struct(cx, &[base, info], false);\n+                }\n+                Some(autoref) => {\n+                    cx.sess().span_bug(e.span,\n+                        &format!(\"unimplemented const second autoref {:?}\", autoref)[])\n                 }\n             }\n         }\n-    }\n+        None => {}\n+    };\n \n     let llty = type_of::sizing_type_of(cx, ety_adjusted);\n     let csize = machine::llsize_of_alloc(cx, val_ty(llconst));\n@@ -282,36 +350,42 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n         cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n-                         e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n+                         e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety_adjusted),\n                          csize, tsize)[]);\n     }\n     (llconst, ety_adjusted)\n }\n \n-// the bool returned is whether this expression can be inlined into other crates\n-// if it's assigned to a static.\n-fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n+fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n+                                   e: &ast::Expr,\n+                                   ety: Ty<'tcx>,\n+                                   param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n     let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e).0)\n+        exprs.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n              .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n         return match e.node {\n           ast::ExprLit(ref lit) => {\n-              consts::const_lit(cx, e, &**lit)\n+              const_lit(cx, e, &**lit)\n           }\n           ast::ExprBinary(b, ref e1, ref e2) => {\n-            let (te1, _) = const_expr(cx, &**e1);\n-            let (te2, _) = const_expr(cx, &**e2);\n+            /* Neither type is bottom, and we expect them to be unified\n+             * already, so the following is safe. */\n+            let (te1, ty) = const_expr(cx, &**e1, param_substs);\n+            let is_simd = ty::type_is_simd(cx.tcx(), ty);\n+            let intype = if is_simd {\n+                ty::simd_type(cx.tcx(), ty)\n+            } else {\n+                ty\n+            };\n+            let is_float = ty::type_is_fp(intype);\n+            let signed = ty::type_is_signed(intype);\n \n+            let (te2, _) = const_expr(cx, &**e2, param_substs);\n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n-            /* Neither type is bottom, and we expect them to be unified\n-             * already, so the following is safe. */\n-            let ty = ty::expr_ty(cx.tcx(), &**e1);\n-            let is_float = ty::type_is_fp(ty);\n-            let signed = ty::type_is_signed(ty);\n             return match b.node {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n@@ -345,52 +419,30 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                 if signed { llvm::LLVMConstAShr(te1, te2) }\n                 else      { llvm::LLVMConstLShr(te1, te2) }\n               }\n-              ast::BiEq     => {\n-                  if is_float { ConstFCmp(RealOEQ, te1, te2) }\n-                  else        { ConstICmp(IntEQ, te1, te2)   }\n-              },\n-              ast::BiLt     => {\n-                  if is_float { ConstFCmp(RealOLT, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSLT, te1, te2) }\n-                      else      { ConstICmp(IntULT, te1, te2) }\n-                  }\n-              },\n-              ast::BiLe     => {\n-                  if is_float { ConstFCmp(RealOLE, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSLE, te1, te2) }\n-                      else      { ConstICmp(IntULE, te1, te2) }\n-                  }\n-              },\n-              ast::BiNe     => {\n-                  if is_float { ConstFCmp(RealONE, te1, te2) }\n-                  else        { ConstICmp(IntNE, te1, te2) }\n-              },\n-              ast::BiGe     => {\n-                  if is_float { ConstFCmp(RealOGE, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSGE, te1, te2) }\n-                      else      { ConstICmp(IntUGE, te1, te2) }\n-                  }\n-              },\n-              ast::BiGt     => {\n-                  if is_float { ConstFCmp(RealOGT, te1, te2) }\n-                  else        {\n-                      if signed { ConstICmp(IntSGT, te1, te2) }\n-                      else      { ConstICmp(IntUGT, te1, te2) }\n+              ast::BiEq | ast::BiNe | ast::BiLt | ast::BiLe | ast::BiGt | ast::BiGe => {\n+                  if is_float {\n+                      let cmp = base::bin_op_to_fcmp_predicate(cx, b.node);\n+                      ConstFCmp(cmp, te1, te2)\n+                  } else {\n+                      let cmp = base::bin_op_to_icmp_predicate(cx, b.node, signed);\n+                      let bool_val = ConstICmp(cmp, te1, te2);\n+                      if is_simd {\n+                          // LLVM outputs an `< size x i1 >`, so we need to perform\n+                          // a sign extension to get the correctly sized type.\n+                          llvm::LLVMConstIntCast(bool_val, val_ty(te1).to_ref(), True)\n+                      } else {\n+                          bool_val\n+                      }\n                   }\n-              },\n+              }\n             }\n           },\n           ast::ExprUnary(u, ref e) => {\n-            let (te, _) = const_expr(cx, &**e);\n-            let ty = ty::expr_ty(cx.tcx(), &**e);\n+            let (te, ty) = const_expr(cx, &**e, param_substs);\n             let is_float = ty::type_is_fp(ty);\n             return match u {\n               ast::UnUniq | ast::UnDeref => {\n-                let (dv, _dt) = const_deref(cx, te, ty, true);\n-                dv\n+                const_deref(cx, te, ty).0\n               }\n               ast::UnNot    => llvm::LLVMConstNot(te),\n               ast::UnNeg    => {\n@@ -400,23 +452,23 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             }\n           }\n           ast::ExprField(ref base, field) => {\n-              let (bv, bt) = const_expr(cx, &**base);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n           ast::ExprTupField(ref base, idx) => {\n-              let (bv, bt) = const_expr(cx, &**base);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n                   adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let (bv, bt) = const_expr(cx, &**base);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs);\n               let iv = match const_eval::eval_const_expr(cx.tcx(), &**index) {\n                   const_eval::const_int(i) => i as u64,\n                   const_eval::const_uint(u) => u,\n@@ -470,9 +522,11 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               const_get_elt(cx, arr, &[iv as c_uint])\n           }\n           ast::ExprCast(ref base, _) => {\n-            let ety = ty::expr_ty(cx.tcx(), e);\n             let llty = type_of::type_of(cx, ety);\n-            let (v, basety) = const_expr(cx, &**base);\n+            let (v, basety) = const_expr(cx, &**base, param_substs);\n+            if expr::cast_is_noop(basety, ety) {\n+                return v;\n+            }\n             return match (expr::cast_type_kind(cx.tcx(), basety),\n                            expr::cast_type_kind(cx.tcx(), ety)) {\n \n@@ -523,49 +577,56 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n               }\n             }\n           }\n-          ast::ExprAddrOf(mutbl, ref sub) => {\n+          ast::ExprAddrOf(ast::MutImmutable, ref sub) => {\n               // If this is the address of some static, then we need to return\n               // the actual address of the static itself (short circuit the rest\n               // of const eval).\n               let mut cur = sub;\n               loop {\n                   match cur.node {\n                       ast::ExprParen(ref sub) => cur = sub,\n+                      ast::ExprBlock(ref blk) => {\n+                        if let Some(ref sub) = blk.expr {\n+                            cur = sub;\n+                        } else {\n+                            break;\n+                        }\n+                      }\n                       _ => break,\n                   }\n               }\n               let opt_def = cx.tcx().def_map.borrow().get(&cur.id).cloned();\n               if let Some(def::DefStatic(def_id, _)) = opt_def {\n-                  let ty = ty::expr_ty(cx.tcx(), e);\n-                  return get_static_val(cx, def_id, ty);\n+                  return get_static_val(cx, def_id, ety);\n               }\n \n               // If this isn't the address of a static, then keep going through\n               // normal constant evaluation.\n-              let (e, _) = const_expr(cx, &**sub);\n-              const_addr_of(cx, e, mutbl)\n+              let (v, _) = const_expr(cx, &**sub, param_substs);\n+              addr_of(cx, v, \"ref\", e.id)\n+          }\n+          ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n+              let (v, _) = const_expr(cx, &**sub, param_substs);\n+              addr_of_mut(cx, v, \"ref_mut_slice\", e.id)\n           }\n           ast::ExprTup(ref es) => {\n-              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n               let vals = map_list(&es[]);\n               adt::trans_const(cx, &*repr, 0, &vals[])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n-              let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let tcx = cx.tcx();\n \n               let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base)),\n+                Some(ref base) => Some(const_expr(cx, &**base, param_substs)),\n                 None => None\n               };\n \n-              expr::with_field_tys(tcx, ety, Some(e.id), |discr, field_tys| {\n+              expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr).0,\n+                          Some(ref f) => const_expr(cx, &*f.expr, param_substs).0,\n                           None => {\n                               match base_val {\n                                   Some((bv, _)) => {\n@@ -580,23 +641,36 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, &cs[])\n+                  if ty::type_is_simd(cx.tcx(), ety) {\n+                      C_vector(&cs[])\n+                  } else {\n+                      adt::trans_const(cx, &*repr, discr, &cs[])\n+                  }\n               })\n           }\n           ast::ExprVec(ref es) => {\n-            const_vec(cx, e, es).0\n+            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n+            let llunitty = type_of::type_of(cx, unit_ty);\n+            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n+                              .collect::<Vec<_>>();\n+            // If the vector contains enums, an LLVM array won't work.\n+            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+                C_struct(cx, &vs[], false)\n+            } else {\n+                C_array(llunitty, &vs[])\n+            }\n           }\n           ast::ExprRepeat(ref elem, ref count) => {\n-            let vec_ty = ty::expr_ty(cx.tcx(), e);\n-            let unit_ty = ty::sequence_element_type(cx.tcx(), vec_ty);\n+            let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = match const_eval::eval_const_expr(cx.tcx(), &**count) {\n                 const_eval::const_int(i)  => i as uint,\n                 const_eval::const_uint(i) => i as uint,\n                 _ => cx.sess().span_bug(count.span, \"count must be integral const expression.\")\n             };\n-            let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n-            if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n+            let unit_val = const_expr(cx, &**elem, param_substs).0;\n+            let vs: Vec<_> = repeat(unit_val).take(n).collect();\n+            if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[], false)\n             } else {\n                 C_array(llunitty, &vs[])\n@@ -606,30 +680,28 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             let def = cx.tcx().def_map.borrow()[e.id];\n             match def {\n                 def::DefFn(..) | def::DefStaticMethod(..) | def::DefMethod(..) => {\n-                    expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                    expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n                 def::DefConst(def_id) => {\n-                    get_const_val(cx, def_id)\n+                    const_deref_ptr(cx, get_const_val(cx, def_id, e))\n                 }\n                 def::DefVariant(enum_did, variant_did, _) => {\n                     let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                          enum_did,\n                                                          variant_did);\n                     if vinfo.args.len() > 0 {\n                         // N-ary variant.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {\n                         // Nullary variant.\n-                        let ety = ty::expr_ty(cx.tcx(), e);\n                         let repr = adt::represent_type(cx, ety);\n                         adt::trans_const(cx, &*repr, vinfo.disr_val, &[])\n                     }\n                 }\n                 def::DefStruct(_) => {\n-                    let ety = ty::expr_ty(cx.tcx(), e);\n                     if let ty::ty_bare_fn(..) = ety.sty {\n                         // Tuple struct.\n-                        expr::trans_def_fn_unadjusted(cx, e, def, &Substs::trans_empty()).val\n+                        expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                     } else {\n                         // Unit struct.\n                         C_null(type_of::type_of(cx, ety))\n@@ -643,20 +715,21 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           }\n           ast::ExprCall(ref callee, ref args) => {\n               let opt_def = cx.tcx().def_map.borrow().get(&callee.id).cloned();\n+              let arg_vals = map_list(&args[]);\n               match opt_def {\n                   Some(def::DefStruct(_)) => {\n-                      let ety = ty::expr_ty(cx.tcx(), e);\n-                      let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(&args[]);\n-                      adt::trans_const(cx, &*repr, 0, &arg_vals[])\n+                      if ty::type_is_simd(cx.tcx(), ety) {\n+                          C_vector(&arg_vals[])\n+                      } else {\n+                          let repr = adt::represent_type(cx, ety);\n+                          adt::trans_const(cx, &*repr, 0, &arg_vals[])\n+                      }\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n-                      let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(&args[]);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n@@ -665,13 +738,19 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }\n           }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e).0,\n+          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs).0,\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr).0,\n+                Some(ref expr) => const_expr(cx, &**expr, param_substs).0,\n                 None => C_nil(cx)\n             }\n           }\n+          ast::ExprClosure(_, ref decl, ref body) => {\n+            closure::trans_closure_expr(closure::Dest::Ignore(cx),\n+                                        &**decl, &**body, e.id,\n+                                        param_substs);\n+            C_null(type_of::type_of(cx, ety))\n+          }\n           _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n         };"}, {"sha": "96506291b5aae65e22e4db7c30f60f2abeb3c8e4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -22,6 +22,7 @@ use trans::common::{ExternMap,tydesc_info,BuilderRef_res};\n use trans::debuginfo;\n use trans::monomorphize::MonoId;\n use trans::type_::{Type, TypeNames};\n+use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use session::config::NoDebugInfo;\n use session::Session;\n@@ -105,17 +106,20 @@ pub struct LocalCrateContext<'tcx> {\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n     /// Reverse-direction for const ptrs cast from globals.\n-    /// Key is an int, cast from a ValueRef holding a *T,\n+    /// Key is a ValueRef holding a *T,\n     /// Val is a ValueRef holding a *[T].\n     ///\n     /// Needed because LLVM loses pointer->pointee association\n     /// when we ptrcast, and we have to ptrcast during translation\n-    /// of a [T] const because we form a slice, a [*T,int] pair, not\n-    /// a pointer to an LLVM array type.\n-    const_globals: RefCell<FnvHashMap<int, ValueRef>>,\n+    /// of a [T] const because we form a slice, a (*T,usize) pair, not\n+    /// a pointer to an LLVM array type. Similar for trait objects.\n+    const_unsized: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n+\n+    /// Cache of emitted const globals (value -> global)\n+    const_globals: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n     /// Cache of emitted const values\n-    const_values: RefCell<NodeMap<ValueRef>>,\n+    const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n     /// Cache of emitted static values\n     static_values: RefCell<NodeMap<ValueRef>>,\n@@ -400,8 +404,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 monomorphizing: RefCell::new(DefIdMap()),\n                 vtables: RefCell::new(FnvHashMap()),\n                 const_cstr_cache: RefCell::new(FnvHashMap()),\n+                const_unsized: RefCell::new(FnvHashMap()),\n                 const_globals: RefCell::new(FnvHashMap()),\n-                const_values: RefCell::new(NodeMap()),\n+                const_values: RefCell::new(FnvHashMap()),\n                 static_values: RefCell::new(NodeMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n                 impl_method_cache: RefCell::new(FnvHashMap()),\n@@ -615,11 +620,16 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.const_cstr_cache\n     }\n \n-    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<int, ValueRef>> {\n+    pub fn const_unsized<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n+        &self.local.const_unsized\n+    }\n+\n+    pub fn const_globals<'a>(&'a self) -> &'a RefCell<FnvHashMap<ValueRef, ValueRef>> {\n         &self.local.const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n+    pub fn const_values<'a>(&'a self) -> &'a RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n+                                                                ValueRef>> {\n         &self.local.const_values\n     }\n "}, {"sha": "ea5eef48257d3bc89dce546803215306a78e5850", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -372,7 +372,8 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n-    let expr_file_line = consts::const_addr_of(ccx, expr_file_line_const, ast::MutImmutable);\n+    let expr_file_line = consts::addr_of(ccx, expr_file_line_const,\n+                                         \"panic_loc\", call_info.id);\n     let args = vec!(expr_file_line);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n@@ -400,7 +401,8 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let filename = C_str_slice(ccx,  filename);\n     let line = C_uint(ccx, loc.line);\n     let file_line_const = C_struct(ccx, &[filename, line], false);\n-    let file_line = consts::const_addr_of(ccx, file_line_const, ast::MutImmutable);\n+    let file_line = consts::addr_of(ccx, file_line_const,\n+                                    \"panic_bounds_check_loc\", call_info.id);\n     let args = vec!(file_line, index, len);\n     let did = langcall(bcx, Some(call_info.span), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,"}, {"sha": "480679f43cb767567481f4593343aeddae89cc28", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 223, "deletions": 210, "changes": 433, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -54,6 +54,7 @@ use self::lazy_binop_ty::*;\n \n use back::abi;\n use llvm::{self, ValueRef};\n+use middle::check_const;\n use middle::def;\n use middle::mem_categorization::Typer;\n use middle::subst::{self, Substs};\n@@ -68,7 +69,6 @@ use trans::glue;\n use trans::machine;\n use trans::meth;\n use trans::monomorphize;\n-use trans::inline;\n use trans::tvec;\n use trans::type_of;\n use middle::ty::{struct_fields, tup_fields};\n@@ -84,8 +84,9 @@ use trans::type_::Type;\n use syntax::{ast, ast_util, codemap};\n use syntax::ptr::P;\n use syntax::parse::token;\n-use std::rc::Rc;\n use std::iter::repeat;\n+use std::mem;\n+use std::rc::Rc;\n \n // Destinations\n \n@@ -115,11 +116,56 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;\n \n+    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n+\n     if bcx.tcx().adjustments.borrow().contains_key(&expr.id) {\n         // use trans, which may be less efficient but\n         // which will perform the adjustments:\n         let datum = unpack_datum!(bcx, trans(bcx, expr));\n-        return datum.store_to_dest(bcx, dest, expr.id)\n+        return datum.store_to_dest(bcx, dest, expr.id);\n+    }\n+\n+    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+        if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n+            if let SaveIn(lldest) = dest {\n+                let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n+                                                            bcx.fcx.param_substs);\n+                // Cast pointer to destination, because constants\n+                // have different types.\n+                let lldest = PointerCast(bcx, lldest, val_ty(global));\n+                memcpy_ty(bcx, lldest, global, expr_ty_adjusted(bcx, expr));\n+            }\n+            // Don't do anything in the Ignore case, consts don't need drop.\n+            return bcx;\n+        } else {\n+            // The only way we're going to see a `const` at this point is if\n+            // it prefers in-place instantiation, likely because it contains\n+            // `[x; N]` somewhere within.\n+            match expr.node {\n+                ast::ExprPath(_) | ast::ExprQPath(_) => {\n+                    match bcx.def(expr.id) {\n+                        def::DefConst(did) => {\n+                            let expr = consts::get_const_expr(bcx.ccx(), did, expr);\n+                            // Temporarily get cleanup scopes out of the way,\n+                            // as they require sub-expressions to be contained\n+                            // inside the current AST scope.\n+                            // These should record no cleanups anyways, `const`\n+                            // can't have destructors.\n+                            let scopes = mem::replace(&mut *bcx.fcx.scopes.borrow_mut(),\n+                                                      vec![]);\n+                            bcx = trans_into(bcx, expr, dest);\n+                            let scopes = mem::replace(&mut *bcx.fcx.scopes.borrow_mut(),\n+                                                      scopes);\n+                            assert!(scopes.is_empty());\n+                            return bcx;\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n     }\n \n     debug!(\"trans_into() expr={}\", expr.repr(bcx.tcx()));\n@@ -130,7 +176,6 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                                           false);\n     bcx.fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n \n-    debuginfo::set_source_location(bcx.fcx, expr.id, expr.span);\n     let kind = ty::expr_kind(bcx.tcx(), expr);\n     bcx = match kind {\n         ty::LvalueExpr | ty::RvalueDatumExpr => {\n@@ -157,14 +202,70 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n+    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n+    let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n+        let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n+                                                      bcx.fcx.param_substs);\n+\n+        if qualif.intersects(check_const::HAS_STATIC_BORROWS) {\n+            // Is borrowed as 'static, must return lvalue.\n+\n+            // Cast pointer to global, because constants have different types.\n+            let const_ty = expr_ty_adjusted(bcx, expr);\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            let global = PointerCast(bcx, global, llty.ptr_to());\n+            let datum = Datum::new(global, const_ty, Lvalue);\n+            return DatumBlock::new(bcx, datum.to_expr_datum());\n+        }\n+\n+        // Otherwise, keep around and perform adjustments, if needed.\n+        let const_ty = if adjusted_global {\n+            expr_ty_adjusted(bcx, expr)\n+        } else {\n+            expr_ty(bcx, expr)\n+        };\n+\n+        // This could use a better heuristic.\n+        Some(if type_is_immediate(bcx.ccx(), const_ty) {\n+            // Cast pointer to global, because constants have different types.\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            let global = PointerCast(bcx, global, llty.ptr_to());\n+            // Maybe just get the value directly, instead of loading it?\n+            immediate_rvalue(load_ty(bcx, global, const_ty), const_ty)\n+        } else {\n+            let llty = type_of::type_of(bcx.ccx(), const_ty);\n+            // HACK(eddyb) get around issues with lifetime intrinsics.\n+            let scratch = alloca_no_lifetime(bcx, llty, \"const\");\n+            let lldest = if !ty::type_is_structural(const_ty) {\n+                // Cast pointer to slot, because constants have different types.\n+                PointerCast(bcx, scratch, val_ty(global))\n+            } else {\n+                // In this case, memcpy_ty calls llvm.memcpy after casting both\n+                // source and destination to i8*, so we don't need any casts.\n+                scratch\n+            };\n+            memcpy_ty(bcx, lldest, global, const_ty);\n+            Datum::new(scratch, const_ty, Rvalue::new(ByRef))\n+        })\n+    } else {\n+        None\n+    };\n \n     let cleanup_debug_loc = debuginfo::get_cleanup_debug_loc_for_ast_node(bcx.ccx(),\n                                                                           expr.id,\n                                                                           expr.span,\n                                                                           false);\n     fcx.push_ast_cleanup_scope(cleanup_debug_loc);\n-    let datum = unpack_datum!(bcx, trans_unadjusted(bcx, expr));\n-    let datum = unpack_datum!(bcx, apply_adjustments(bcx, expr, datum));\n+    let datum = match global {\n+        Some(rvalue) => rvalue.to_expr_datum(),\n+        None => unpack_datum!(bcx, trans_unadjusted(bcx, expr))\n+    };\n+    let datum = if adjusted_global {\n+        datum // trans::consts already performed adjustments.\n+    } else {\n+        unpack_datum!(bcx, apply_adjustments(bcx, expr, datum))\n+    };\n     bcx = fcx.pop_and_trans_ast_cleanup_scope(bcx, expr.id);\n     return DatumBlock::new(bcx, datum);\n }\n@@ -177,6 +278,54 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n     GEPi(bcx, fat_ptr, &[0, abi::FAT_PTR_ADDR])\n }\n \n+// Retrieve the information we are losing (making dynamic) in an unsizing\n+// adjustment.\n+// When making a dtor, we need to do different things depending on the\n+// ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n+// into a type to be destructed. If we want to end up with a Box pointer,\n+// then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n+// borrowed reference then it should be T -> &T.\n+pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n+                                 kind: &ty::UnsizeKind<'tcx>,\n+                                 id: ast::NodeId,\n+                                 unadjusted_ty: Ty<'tcx>,\n+                                 param_substs: &'tcx subst::Substs<'tcx>,\n+                                 mk_ty: F) -> ValueRef where\n+    F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+{\n+    // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n+    fn identity<T>(t: T) -> T { t }\n+\n+    debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n+           kind, id, unadjusted_ty.repr(ccx.tcx()));\n+    match kind {\n+        &ty::UnsizeLength(len) => C_uint(ccx, len),\n+        &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n+            ty::ty_struct(_, ref substs) => {\n+                let ty_substs = substs.types.get_slice(subst::TypeSpace);\n+                // The dtor for a field treats it like a value, so mk_ty\n+                // should just be the identity function.\n+                unsized_info(ccx, k, id, ty_substs[tp_index], param_substs, identity)\n+            }\n+            _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n+                                         unadjusted_ty.repr(ccx.tcx()))[])\n+        },\n+        &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n+            // Note that we preserve binding levels here:\n+            let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n+            let substs = ccx.tcx().mk_substs(substs);\n+            let trait_ref = ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n+                                                             substs: substs }));\n+            let trait_ref = monomorphize::apply_param_substs(ccx.tcx(),\n+                                                             param_substs,\n+                                                             &trait_ref);\n+            let box_ty = mk_ty(unadjusted_ty);\n+            consts::ptrcast(meth::get_vtable(ccx, box_ty, trait_ref, param_substs),\n+                            Type::vtable_ptr(ccx))\n+        }\n+    }\n+}\n+\n /// Helper for trans that apply adjustments from `expr` to `datum`, which should be the unadjusted\n /// translation of `expr`.\n fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -262,13 +411,17 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum = match autoref {\n             &AutoPtr(_, _, ref a) | &AutoUnsafe(_, ref a) => {\n                 debug!(\"  AutoPtr\");\n-                match a {\n-                    &Some(box ref a) => {\n-                        datum = unpack_datum!(bcx, apply_autoref(a, bcx, expr, datum));\n-                    }\n-                    &None => {}\n+                if let &Some(box ref a) = a {\n+                    datum = unpack_datum!(bcx, apply_autoref(a, bcx, expr, datum));\n+                }\n+                if !type_is_sized(bcx.tcx(), datum.ty) {\n+                    // Arrange cleanup\n+                    let lval = unpack_datum!(bcx,\n+                        datum.to_lvalue_datum(bcx, \"ref_fat_ptr\", expr.id));\n+                    unpack_datum!(bcx, ref_fat_ptr(bcx, lval))\n+                } else {\n+                    unpack_datum!(bcx, auto_ref(bcx, datum, expr))\n                 }\n-                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n             }\n             &ty::AutoUnsize(ref k) => {\n                 debug!(\"  AutoUnsize\");\n@@ -288,139 +441,35 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         DatumBlock::new(bcx, datum)\n     }\n \n-    fn ref_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                           expr: &ast::Expr,\n-                           datum: Datum<'tcx, Expr>)\n-                           -> DatumBlock<'blk, 'tcx, Expr> {\n-        debug!(\"ref_ptr(expr={}, datum={})\",\n-               expr.repr(bcx.tcx()),\n-               datum.to_string(bcx.ccx()));\n-\n-        if !type_is_sized(bcx.tcx(), datum.ty) {\n-            debug!(\"Taking address of unsized type {}\",\n-                   bcx.ty_to_string(datum.ty));\n-            ref_fat_ptr(bcx, expr, datum)\n-        } else {\n-            debug!(\"Taking address of sized type {}\",\n-                   bcx.ty_to_string(datum.ty));\n-            auto_ref(bcx, datum, expr)\n-        }\n-    }\n-\n-    // Retrieve the information we are losing (making dynamic) in an unsizing\n-    // adjustment.\n-    // When making a dtor, we need to do different things depending on the\n-    // ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n-    // into a type to be destructed. If we want to end up with a Box pointer,\n-    // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n-    // borrowed reference then it should be T -> &T.\n-    fn unsized_info<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                   kind: &ty::UnsizeKind<'tcx>,\n-                                   id: ast::NodeId,\n-                                   unadjusted_ty: Ty<'tcx>,\n-                                   mk_ty: F) -> ValueRef where\n-        F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n-    {\n-        // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n-        fn identity<T>(t: T) -> T { t }\n-\n-        debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n-               kind, id, unadjusted_ty.repr(bcx.tcx()));\n-        match kind {\n-            &ty::UnsizeLength(len) => C_uint(bcx.ccx(), len),\n-            &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n-                ty::ty_struct(_, ref substs) => {\n-                    let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                    // The dtor for a field treats it like a value, so mk_ty\n-                    // should just be the identity function.\n-                    unsized_info(bcx, k, id, ty_substs[tp_index], identity)\n-                }\n-                _ => bcx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty))[])\n-            },\n-            &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                // Note that we preserve binding levels here:\n-                let substs = principal.0.substs.with_self_ty(unadjusted_ty).erase_regions();\n-                let substs = bcx.tcx().mk_substs(substs);\n-                let trait_ref =\n-                    ty::Binder(Rc::new(ty::TraitRef { def_id: principal.def_id(),\n-                                                      substs: substs }));\n-                let trait_ref = bcx.monomorphize(&trait_ref);\n-                let box_ty = mk_ty(unadjusted_ty);\n-                PointerCast(bcx,\n-                            meth::get_vtable(bcx, box_ty, trait_ref),\n-                            Type::vtable_ptr(bcx.ccx()))\n-            }\n-        }\n-    }\n-\n     fn unsize_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                expr: &ast::Expr,\n                                datum: Datum<'tcx, Expr>,\n                                k: &ty::UnsizeKind<'tcx>)\n                                -> DatumBlock<'blk, 'tcx, Expr> {\n+        let mut bcx = bcx;\n         let tcx = bcx.tcx();\n         let datum_ty = datum.ty;\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n         let dest_ty = ty::mk_open(tcx, unsized_ty);\n         debug!(\"dest_ty={}\", unsized_ty.repr(bcx.tcx()));\n-        // Closures for extracting and manipulating the data and payload parts of\n-        // the fat pointer.\n-        let info = |bcx, _val| unsized_info(bcx,\n-                                              k,\n-                                              expr.id,\n-                                              datum_ty,\n-                                              |t| ty::mk_rptr(tcx,\n-                                                              tcx.mk_region(ty::ReStatic),\n-                                                              ty::mt{\n-                                                                  ty: t,\n-                                                                  mutbl: ast::MutImmutable\n-                                                              }));\n-        match *k {\n-            ty::UnsizeStruct(..) =>\n-                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n-                    PointerCast(bcx, val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n-                }, info),\n-            ty::UnsizeLength(..) =>\n-                into_fat_ptr(bcx, expr, datum, dest_ty, |bcx, val| {\n-                    GEPi(bcx, val, &[0, 0])\n-                }, info),\n-            ty::UnsizeVtable(..) =>\n-                into_fat_ptr(bcx, expr, datum, dest_ty, |_bcx, val| {\n-                    PointerCast(bcx, val, Type::i8p(bcx.ccx()))\n-                }, info),\n-        }\n-    }\n \n-    fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr: &ast::Expr,\n-                               datum: Datum<'tcx, Expr>)\n-                               -> DatumBlock<'blk, 'tcx, Expr> {\n-        let tcx = bcx.tcx();\n-        let dest_ty = ty::close_type(tcx, datum.ty);\n-        let base = |bcx, val| Load(bcx, get_dataptr(bcx, val));\n-        let len = |bcx, val| Load(bcx, get_len(bcx, val));\n-        into_fat_ptr(bcx, expr, datum, dest_ty, base, len)\n-    }\n-\n-    fn into_fat_ptr<'blk, 'tcx, F, G>(bcx: Block<'blk, 'tcx>,\n-                                      expr: &ast::Expr,\n-                                      datum: Datum<'tcx, Expr>,\n-                                      dest_ty: Ty<'tcx>,\n-                                      base: F,\n-                                      info: G)\n-                                      -> DatumBlock<'blk, 'tcx, Expr> where\n-        F: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n-        G: FnOnce(Block<'blk, 'tcx>, ValueRef) -> ValueRef,\n-    {\n-        let mut bcx = bcx;\n+        let info = unsized_info(bcx.ccx(), k, expr.id, datum_ty, bcx.fcx.param_substs,\n+                                |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n \n         // Arrange cleanup\n         let lval = unpack_datum!(bcx,\n                                  datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n-        let base = base(bcx, lval.val);\n-        let info = info(bcx, lval.val);\n+        // Compute the base pointer. This doesn't change the pointer value,\n+        // but merely its type.\n+        let base = match *k {\n+            ty::UnsizeStruct(..) | ty::UnsizeVtable(..) => {\n+                PointerCast(bcx, lval.val, type_of::type_of(bcx.ccx(), unsized_ty).ptr_to())\n+            }\n+            ty::UnsizeLength(..) => {\n+                GEPi(bcx, lval.val, &[0u, 0u])\n+            }\n+        };\n \n         let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n         Store(bcx, base, get_dataptr(bcx, scratch.val));\n@@ -490,7 +539,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n         bcx = datum.store_to(bcx, base);\n \n-        let info = unsized_info(bcx, k, expr.id, unboxed_ty, |t| ty::mk_uniq(tcx, t));\n+        let info = unsized_info(bcx.ccx(), k, expr.id, unboxed_ty, bcx.fcx.param_substs,\n+                                |t| ty::mk_uniq(tcx, t));\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -847,53 +897,25 @@ fn trans_def<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             //     pointer to that.\n             let const_ty = expr_ty(bcx, ref_expr);\n \n-            fn get_val<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, did: ast::DefId,\n-                                   const_ty: Ty<'tcx>) -> ValueRef {\n-                // For external constants, we don't inline.\n-                if did.krate == ast::LOCAL_CRATE {\n-                    // Case 1.\n-\n-                    // The LLVM global has the type of its initializer,\n-                    // which may not be equal to the enum's type for\n-                    // non-C-like enums.\n-                    let val = base::get_item_val(bcx.ccx(), did.node);\n-                    let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n-                    PointerCast(bcx, val, pty)\n-                } else {\n-                    // Case 2.\n-                    base::get_extern_const(bcx.ccx(), did, const_ty)\n-                }\n-            }\n-            let val = get_val(bcx, did, const_ty);\n+            // For external constants, we don't inline.\n+            let val = if did.krate == ast::LOCAL_CRATE {\n+                // Case 1.\n+\n+                // The LLVM global has the type of its initializer,\n+                // which may not be equal to the enum's type for\n+                // non-C-like enums.\n+                let val = base::get_item_val(bcx.ccx(), did.node);\n+                let pty = type_of::type_of(bcx.ccx(), const_ty).ptr_to();\n+                PointerCast(bcx, val, pty)\n+            } else {\n+                // Case 2.\n+                base::get_extern_const(bcx.ccx(), did, const_ty)\n+            };\n             DatumBlock::new(bcx, Datum::new(val, const_ty, LvalueExpr))\n         }\n-        def::DefConst(did) => {\n-            // First, inline any external constants into the local crate so we\n-            // can be sure to get the LLVM value corresponding to it.\n-            let did = inline::maybe_instantiate_inline(bcx.ccx(), did);\n-            if did.krate != ast::LOCAL_CRATE {\n-                bcx.tcx().sess.span_bug(ref_expr.span,\n-                                        \"cross crate constant could not \\\n-                                         be inlined\");\n-            }\n-            let val = base::get_item_val(bcx.ccx(), did.node);\n-\n-            // Next, we need to crate a ByRef rvalue datum to return. We can't\n-            // use the normal .to_ref_datum() function because the type of\n-            // `val` is not actually the same as `const_ty`.\n-            //\n-            // To get around this, we make a custom alloca slot with the\n-            // appropriate type (const_ty), and then we cast it to a pointer of\n-            // typeof(val), store the value, and then hand this slot over to\n-            // the datum infrastructure.\n-            let const_ty = expr_ty(bcx, ref_expr);\n-            let llty = type_of::type_of(bcx.ccx(), const_ty);\n-            let slot = alloca(bcx, llty, \"const\");\n-            let pty = Type::from_ref(unsafe { llvm::LLVMTypeOf(val) }).ptr_to();\n-            Store(bcx, val, PointerCast(bcx, slot, pty));\n-\n-            let datum = Datum::new(slot, const_ty, Rvalue::new(ByRef));\n-            DatumBlock::new(bcx, datum.to_expr_datum())\n+        def::DefConst(_) => {\n+            bcx.sess().span_bug(ref_expr.span,\n+                \"constant expression should not reach expr::trans_def\")\n         }\n         _ => {\n             DatumBlock::new(bcx, trans_local_var(bcx, def).to_expr_datum())\n@@ -1119,7 +1141,12 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n         ast::ExprClosure(_, ref decl, ref body) => {\n-            closure::trans_closure_expr(bcx, &**decl, &**body, expr.id, dest)\n+            let dest = match dest {\n+                SaveIn(lldest) => closure::Dest::SaveIn(bcx, lldest),\n+                Ignore => closure::Dest::Ignore(bcx.ccx())\n+            };\n+            closure::trans_closure_expr(dest, &**decl, &**body, expr.id, bcx.fcx.param_substs)\n+                .unwrap_or(bcx)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n@@ -1247,7 +1274,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                          ref_expr: &ast::Expr,\n                                          def: def::Def,\n-                                         param_substs: &subst::Substs<'tcx>)\n+                                         param_substs: &'tcx subst::Substs<'tcx>)\n                                          -> Datum<'tcx, Rvalue> {\n     let _icx = push_ctxt(\"trans_def_datum_unadjusted\");\n \n@@ -1641,6 +1668,16 @@ fn trans_uniq_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     immediate_rvalue_bcx(bcx, val, box_ty).to_expr_datumblock()\n }\n \n+fn ref_fat_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                           lval: Datum<'tcx, Lvalue>)\n+                           -> DatumBlock<'blk, 'tcx, Expr> {\n+    let dest_ty = ty::close_type(bcx.tcx(), lval.ty);\n+    let scratch = rvalue_scratch_datum(bcx, dest_ty, \"__fat_ptr\");\n+    memcpy_ty(bcx, scratch.val, lval.val, scratch.ty);\n+\n+    DatumBlock::new(bcx, scratch.to_expr_datum())\n+}\n+\n fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              expr: &ast::Expr,\n                              subexpr: &ast::Expr)\n@@ -1651,18 +1688,7 @@ fn trans_addr_of<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match sub_datum.ty.sty {\n         ty::ty_open(_) => {\n             // Opened DST value, close to a fat pointer\n-            debug!(\"Closing fat pointer {}\", bcx.ty_to_string(sub_datum.ty));\n-\n-            let scratch = rvalue_scratch_datum(bcx,\n-                                               ty::close_type(bcx.tcx(), sub_datum.ty),\n-                                               \"fat_addr_of\");\n-            let base = Load(bcx, get_dataptr(bcx, sub_datum.val));\n-            Store(bcx, base, get_dataptr(bcx, scratch.val));\n-\n-            let len = Load(bcx, get_len(bcx, sub_datum.val));\n-            Store(bcx, len, get_len(bcx, scratch.val));\n-\n-            DatumBlock::new(bcx, scratch.to_expr_datum())\n+            ref_fat_ptr(bcx, sub_datum)\n         }\n         _ => {\n             // Sized value, ref to a thin pointer\n@@ -1687,9 +1713,10 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let tcx = bcx.tcx();\n     let is_simd = ty::type_is_simd(tcx, lhs_t);\n-    let intype = {\n-        if is_simd { ty::simd_type(tcx, lhs_t) }\n-        else { lhs_t }\n+    let intype = if is_simd {\n+        ty::simd_type(tcx, lhs_t)\n+    } else {\n+        lhs_t\n     };\n     let is_float = ty::type_is_fp(intype);\n     let is_signed = ty::type_is_signed(intype);\n@@ -1766,24 +1793,10 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n-        if ty::type_is_scalar(rhs_t) {\n-            unpack_result!(bcx,\n-                           base::compare_scalar_types(bcx,\n-                                                      lhs,\n-                                                      rhs,\n-                                                      rhs_t,\n-                                                      op.node,\n-                                                      binop_debug_loc))\n-        } else if is_simd {\n-            base::compare_simd_types(bcx,\n-                                     lhs,\n-                                     rhs,\n-                                     intype,\n-                                     ty::simd_size(tcx, lhs_t),\n-                                     op.node,\n-                                     binop_debug_loc)\n+        if is_simd {\n+            base::compare_simd_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n         } else {\n-            bcx.tcx().sess.span_bug(binop_expr.span, \"comparison operator unsupported for type\")\n+            base::compare_scalar_types(bcx, lhs, rhs, intype, op.node, binop_debug_loc)\n         }\n       }\n       _ => {\n@@ -1997,7 +2010,7 @@ pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n     }\n }\n \n-fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n+pub fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n     match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out"}, {"sha": "8f0e4e647b5b3d1c8cceb646416d418b027ec037", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -557,7 +557,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                 body: &ast::Block,\n                                                 attrs: &[ast::Attribute],\n                                                 llwrapfn: ValueRef,\n-                                                param_substs: &Substs<'tcx>,\n+                                                param_substs: &'tcx Substs<'tcx>,\n                                                 id: ast::NodeId,\n                                                 hash: Option<&str>) {\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n@@ -577,7 +577,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     fn build_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                decl: &ast::FnDecl,\n                                body: &ast::Block,\n-                               param_substs: &Substs<'tcx>,\n+                               param_substs: &'tcx Substs<'tcx>,\n                                attrs: &[ast::Attribute],\n                                id: ast::NodeId,\n                                hash: Option<&str>)"}, {"sha": "af90e1ec5c5dd47cb85ee6c152386f2c4eb06bea", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -558,12 +558,12 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n     let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx(), t));\n     let _s = StatRecorder::new(ccx, glue_name);\n \n-    let empty_param_substs = Substs::trans_empty();\n+    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n     arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, false,\n                       ty::FnConverging(ty::mk_nil(ccx.tcx())),\n-                      &empty_param_substs, None, &arena);\n+                      empty_substs, None, &arena);\n \n     let bcx = init_function(&fcx, false, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n "}, {"sha": "56fda20e0e8dcdc79d666da21b94e4f10247fc32", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -159,13 +159,14 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                     let unparameterized = impl_tpt.generics.types.is_empty() &&\n                             mth.pe_generics().ty_params.is_empty();\n \n+                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n                     if unparameterized {\n                         let llfn = get_item_val(ccx, mth.id);\n                         trans_fn(ccx,\n                                  &*mth.pe_fn_decl(),\n                                  &*mth.pe_body(),\n                                  llfn,\n-                                 &Substs::trans_empty(),\n+                                 empty_substs,\n                                  mth.id,\n                                  &[]);\n                         // Use InternalLinkage so LLVM can optimize more"}, {"sha": "1d5d24a64036dd6d69760ae564c7ce8dc6595f49", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 46, "deletions": 69, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -11,7 +11,7 @@\n use arena::TypedArena;\n use back::abi;\n use back::link;\n-use llvm::{self, ValueRef, get_param};\n+use llvm::{ValueRef, get_param};\n use metadata::csearch;\n use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n@@ -23,6 +23,7 @@ use trans::callee::*;\n use trans::callee;\n use trans::cleanup;\n use trans::common::*;\n+use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::expr::{SaveIn, Ignore};\n@@ -36,7 +37,6 @@ use middle::ty::{self, Ty};\n use middle::ty::MethodCall;\n use util::ppaux::Repr;\n \n-use std::ffi::CString;\n use std::rc::Rc;\n use syntax::abi::{Rust, RustCall};\n use syntax::parse::token;\n@@ -82,11 +82,12 @@ pub fn trans_impl(ccx: &CrateContext,\n                     let trans_everywhere = attr::requests_inline(&method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n+                        let empty_substs = tcx.mk_substs(Substs::trans_empty());\n                         trans_fn(ccx,\n                                  method.pe_fn_decl(),\n                                  method.pe_body(),\n                                  llfn,\n-                                 &Substs::trans_empty(),\n+                                 empty_substs,\n                                  method.id,\n                                  &[]);\n                         update_linkage(ccx,\n@@ -174,7 +175,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                             method_id: ast::DefId,\n                                             trait_id: ast::DefId,\n                                             expr_id: ast::NodeId,\n-                                            param_substs: &subst::Substs<'tcx>)\n+                                            param_substs: &'tcx subst::Substs<'tcx>)\n                                             -> Datum<'tcx, Rvalue>\n {\n     let _icx = push_ctxt(\"meth::trans_static_method_callee\");\n@@ -599,15 +600,15 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     let sig = ty::erase_late_bound_regions(ccx.tcx(), &fty.sig);\n \n-    let empty_substs = Substs::trans_empty();\n+    let empty_substs = tcx.mk_substs(Substs::trans_empty());\n     let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n     block_arena = TypedArena::new();\n     fcx = new_fn_ctxt(ccx,\n                       llfn,\n                       ast::DUMMY_NODE_ID,\n                       false,\n                       sig.output,\n-                      &empty_substs,\n+                      empty_substs,\n                       None,\n                       &block_arena);\n     let mut bcx = init_function(&fcx, false, sig.output);\n@@ -689,19 +690,19 @@ pub fn trans_object_shim<'a, 'tcx>(\n /// `trait_ref` would map `T:Trait`, but `box_ty` would be\n /// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n /// This will hopefully change now that DST is underway.\n-pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              box_ty: Ty<'tcx>,\n-                              trait_ref: ty::PolyTraitRef<'tcx>)\n-                              -> ValueRef\n+pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                            box_ty: Ty<'tcx>,\n+                            trait_ref: ty::PolyTraitRef<'tcx>,\n+                            param_substs: &'tcx subst::Substs<'tcx>)\n+                            -> ValueRef\n {\n-    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n-           box_ty.repr(bcx.tcx()),\n-           trait_ref.repr(bcx.tcx()));\n-\n-    let tcx = bcx.tcx();\n-    let ccx = bcx.ccx();\n+    let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n+    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n+           box_ty.repr(tcx),\n+           trait_ref.repr(tcx));\n+\n     // Check the cache.\n     let cache_key = (box_ty, trait_ref.clone());\n     match ccx.vtables().borrow().get(&cache_key) {\n@@ -711,9 +712,7 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Not in the cache. Build it.\n     let methods = traits::supertraits(tcx, trait_ref.clone()).flat_map(|trait_ref| {\n-        let vtable = fulfill_obligation(bcx.ccx(),\n-                                        DUMMY_SP,\n-                                        trait_ref.clone());\n+        let vtable = fulfill_obligation(ccx, DUMMY_SP, trait_ref.clone());\n         match vtable {\n             traits::VtableBuiltin(_) => {\n                 Vec::new().into_iter()\n@@ -723,83 +722,61 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     impl_def_id: id,\n                     substs,\n                     nested: _ }) => {\n-                emit_vtable_methods(bcx, id, substs).into_iter()\n+                emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n             }\n             traits::VtableClosure(closure_def_id, substs) => {\n                 let llfn = trans_fn_ref_with_substs(\n-                    bcx.ccx(),\n+                    ccx,\n                     closure_def_id,\n                     ExprId(0),\n-                    bcx.fcx.param_substs,\n-                    substs.clone()).val;\n+                    param_substs,\n+                    substs).val;\n \n-                (vec!(llfn)).into_iter()\n+                vec![llfn].into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n-                let llfn = vec![trans_fn_pointer_shim(bcx.ccx(), bare_fn_ty)];\n-                llfn.into_iter()\n+                vec![trans_fn_pointer_shim(ccx, bare_fn_ty)].into_iter()\n             }\n             traits::VtableObject(ref data) => {\n                 // this would imply that the Self type being erased is\n                 // an object type; this cannot happen because we\n                 // cannot cast an unsized type into a trait object\n-                bcx.sess().bug(\n+                tcx.sess.bug(\n                     &format!(\"cannot get vtable for an object type: {}\",\n-                             data.repr(bcx.tcx())));\n+                            data.repr(tcx)));\n             }\n             traits::VtableParam(..) => {\n-                bcx.sess().bug(\n+                tcx.sess.bug(\n                     &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n-                            trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx()))[]);\n+                            trait_ref.repr(tcx),\n+                            vtable.repr(tcx))[]);\n             }\n         }\n     });\n \n     let size_ty = sizing_type_of(ccx, trait_ref.self_ty());\n     let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let ll_size = C_uint(ccx, size);\n     let align = align_of(ccx, trait_ref.self_ty());\n-    let ll_align = C_uint(ccx, align);\n \n-    // Generate a destructor for the vtable.\n-    let drop_glue = glue::get_drop_glue(ccx, box_ty);\n-    let vtable = make_vtable(ccx, drop_glue, ll_size, ll_align, methods);\n+    let components: Vec<_> = vec![\n+        // Generate a destructor for the vtable.\n+        glue::get_drop_glue(ccx, box_ty),\n+        C_uint(ccx, size),\n+        C_uint(ccx, align)\n+    ].into_iter().chain(methods).collect();\n+\n+    let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false),\n+                                 \"vtable\", trait_ref.def_id().node);\n \n     ccx.vtables().borrow_mut().insert(cache_key, vtable);\n     vtable\n }\n \n-/// Helper function to declare and initialize the vtable.\n-pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n-                                          drop_glue: ValueRef,\n-                                          size: ValueRef,\n-                                          align: ValueRef,\n-                                          ptrs: I)\n-                                          -> ValueRef {\n-    let _icx = push_ctxt(\"meth::make_vtable\");\n-\n-    let head = vec![drop_glue, size, align];\n-    let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n-\n-    unsafe {\n-        let tbl = C_struct(ccx, &components[], false);\n-        let sym = token::gensym(\"vtable\");\n-        let buf = CString::from_vec(format!(\"vtable{}\", sym.usize()).into_bytes());\n-        let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),\n-                                          buf.as_ptr());\n-        llvm::LLVMSetInitializer(vt_gvar, tbl);\n-        llvm::LLVMSetGlobalConstant(vt_gvar, llvm::True);\n-        llvm::SetLinkage(vt_gvar, llvm::InternalLinkage);\n-        vt_gvar\n-    }\n-}\n-\n-fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                   impl_id: ast::DefId,\n-                                   substs: subst::Substs<'tcx>)\n-                                   -> Vec<ValueRef> {\n-    let ccx = bcx.ccx();\n+fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                 impl_id: ast::DefId,\n+                                 substs: subst::Substs<'tcx>,\n+                                 param_substs: &'tcx subst::Substs<'tcx>)\n+                                 -> Vec<ValueRef> {\n     let tcx = ccx.tcx();\n \n     let trt_id = match ty::impl_trait_ref(tcx, impl_id) {\n@@ -808,7 +785,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                       make a vtable for a type impl!\")\n     };\n \n-    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trt_id);\n \n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n     trait_item_def_ids.iter().flat_map(|method_def_id| {\n@@ -835,7 +812,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         ccx,\n                         m_id,\n                         ExprId(0),\n-                        bcx.fcx.param_substs,\n+                        param_substs,\n                         substs.clone()).val;\n \n                     // currently, at least, by-value self is not object safe\n@@ -882,7 +859,7 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let vtable = get_vtable(bcx, datum_ty, trait_ref);\n+    let vtable = get_vtable(bcx.ccx(), datum_ty, trait_ref, bcx.fcx.param_substs);\n     let llvtabledest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "30797344da810889e235e2f761ae876a60c3d795", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -36,7 +36,7 @@ use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n-                                psubsts: &subst::Substs<'tcx>,\n+                                psubsts: &'tcx subst::Substs<'tcx>,\n                                 ref_id: Option<ast::NodeId>)\n     -> (ValueRef, Ty<'tcx>, bool) {\n     debug!(\"monomorphic_fn(\\\n@@ -55,7 +55,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let hash_id = MonoId {\n         def: fn_id,\n-        params: psubsts.types.clone()\n+        params: &psubsts.types\n     };\n \n     let item_ty = ty::lookup_item_type(ccx.tcx(), fn_id).ty;\n@@ -289,7 +289,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct MonoId<'tcx> {\n     pub def: ast::DefId,\n-    pub params: subst::VecPerParamSpace<Ty<'tcx>>\n+    pub params: &'tcx subst::VecPerParamSpace<Ty<'tcx>>\n }\n \n /// Monomorphizes a type from the AST by first applying the in-scope"}, {"sha": "8f10865ae32bc4f19e4bae7b6599c87060ba950f", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -309,8 +309,6 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                     |set_bcx, lleltptr, _| {\n                                                         elem.shallow_copy(set_bcx, lleltptr)\n                                                     });\n-\n-                            elem.add_clean_if_rvalue(bcx, element.id);\n                             bcx\n                         }\n                     }"}, {"sha": "01bed69fb1de9e23cc3f05ee9172be050c161d95", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::{int, i8, i16, i32, i64};\n+use std::thread::Thread;\n+\n+fn main() {\n+    assert!(Thread::scoped(move|| int::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i8::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i16::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i32::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i64::MIN / -1).join().is_err());\n+    //~^ ERROR attempted to divide with overflow in a constant expression\n+    assert!(Thread::scoped(move|| 1is / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i8 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i16 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i32 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i64 / 0).join().is_err());\n+    //~^ ERROR attempted to divide by zero in a constant expression\n+    assert!(Thread::scoped(move|| int::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i8::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i16::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i32::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| i64::MIN % -1).join().is_err());\n+    //~^ ERROR attempted remainder with overflow in a constant expression\n+    assert!(Thread::scoped(move|| 1is % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i8 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i16 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i32 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+    assert!(Thread::scoped(move|| 1i64 % 0).join().is_err());\n+    //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n+}"}, {"sha": "ce5a0aa96e3d308493653125406e769e10e8bce1", "filename": "src/test/run-pass/issue-17216.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Ftest%2Frun-pass%2Fissue-17216.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Ftest%2Frun-pass%2Fissue-17216.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17216.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -25,7 +25,9 @@ fn main() {\n     let mut dropped = false;\n     {\n         let leak = Leak { dropped: &mut dropped };\n-        for ((), leaked) in Some(((),leak)).into_iter() {}\n+        // FIXME(#21721) \"hack\" used to be () but that can cause\n+        // certain LLVM versions to abort during optimizations.\n+        for (_, leaked) in Some((\"hack\", leak)).into_iter() {}\n     }\n \n     assert!(dropped);"}, {"sha": "4b9ed44c7cd7a93754e5a9cc8874fb69e9d8f769", "filename": "src/test/run-pass/issue-8460.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4473a4664ca39d110c17682d2e9873a5ed59012/src%2Ftest%2Frun-pass%2Fissue-8460.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8460.rs?ref=f4473a4664ca39d110c17682d2e9873a5ed59012", "patch": "@@ -8,28 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{int, i8, i16, i32, i64};\n+use std::num::Int;\n use std::thread::Thread;\n \n+// Avoid using constants, which would trigger compile-time errors.\n+fn min_val<T: Int>() -> T { Int::min_value() }\n+fn zero<T: Int>() -> T { Int::zero() }\n+\n fn main() {\n-    assert!(Thread::scoped(move|| int::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i8::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i16::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i32::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| i64::MIN / -1).join().is_err());\n-    assert!(Thread::scoped(move|| 1 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i8 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i16 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i32 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i64 / 0).join().is_err());\n-    assert!(Thread::scoped(move|| int::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i8::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i16::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i32::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| i64::MIN % -1).join().is_err());\n-    assert!(Thread::scoped(move|| 1 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i8 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i16 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i32 % 0).join().is_err());\n-    assert!(Thread::scoped(move|| 1i64 % 0).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<isize>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i8>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i16>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i32>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i64>() / -1).join().is_err());\n+    assert!(Thread::scoped(move|| 1is / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i8 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i16 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i32 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i64 / zero()).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<isize>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i8>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i16>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i32>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| min_val::<i64>() % -1).join().is_err());\n+    assert!(Thread::scoped(move|| 1is % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i8 % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i16 % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i32 % zero()).join().is_err());\n+    assert!(Thread::scoped(move|| 1i64 % zero()).join().is_err());\n }"}]}