{"sha": "e1cce06e4ff5206daf397e1dcf91ed53653be171", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxY2NlMDZlNGZmNTIwNmRhZjM5N2UxZGNmOTFlZDUzNjUzYmUxNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-15T04:06:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-15T04:06:51Z"}, "message": "Auto merge of #77700 - bugadani:rustdoc-link-cache, r=jyn514\n\nRustdoc: Cache resolved links in current module\n\nA step towards #77681", "tree": {"sha": "9e30144690c68c893a4bb39aaa0834d53dc3758f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e30144690c68c893a4bb39aaa0834d53dc3758f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1cce06e4ff5206daf397e1dcf91ed53653be171", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1cce06e4ff5206daf397e1dcf91ed53653be171", "html_url": "https://github.com/rust-lang/rust/commit/e1cce06e4ff5206daf397e1dcf91ed53653be171", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1cce06e4ff5206daf397e1dcf91ed53653be171/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d77fc8d0db3b69f3a3691d86eba23e4cdc390e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d77fc8d0db3b69f3a3691d86eba23e4cdc390e1", "html_url": "https://github.com/rust-lang/rust/commit/5d77fc8d0db3b69f3a3691d86eba23e4cdc390e1"}, {"sha": "fa64c272c8253c9df01fa4c28e34095735411e0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa64c272c8253c9df01fa4c28e34095735411e0e", "html_url": "https://github.com/rust-lang/rust/commit/fa64c272c8253c9df01fa4c28e34095735411e0e"}], "stats": {"total": 181, "additions": 134, "deletions": 47}, "files": [{"sha": "167eb07a690bc89b50a5fd8345ffbf11108e39c8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 120, "deletions": 47, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/e1cce06e4ff5206daf397e1dcf91ed53653be171/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cce06e4ff5206daf397e1dcf91ed53653be171/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e1cce06e4ff5206daf397e1dcf91ed53653be171", "patch": "@@ -3,7 +3,7 @@\n //! [RFC 1946]: https://github.com/rust-lang/rfcs/blob/master/text/1946-intra-rustdoc-links.md\n \n use rustc_ast as ast;\n-use rustc_data_structures::stable_set::FxHashSet;\n+use rustc_data_structures::{fx::FxHashMap, stable_set::FxHashSet};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtensionKind;\n use rustc_hir as hir;\n@@ -168,6 +168,27 @@ enum AnchorFailure {\n     RustdocAnchorConflict(Res),\n }\n \n+#[derive(Clone, Debug, Hash, PartialEq, Eq)]\n+struct ResolutionInfo {\n+    module_id: DefId,\n+    dis: Option<Disambiguator>,\n+    path_str: String,\n+    extra_fragment: Option<String>,\n+}\n+\n+struct DiagnosticInfo<'a> {\n+    item: &'a Item,\n+    dox: &'a str,\n+    ori_link: &'a str,\n+    link_range: Option<Range<usize>>,\n+}\n+\n+#[derive(Clone, Debug, Hash)]\n+struct CachedLink {\n+    pub res: (Res, Option<String>),\n+    pub side_channel: Option<(DefKind, DefId)>,\n+}\n+\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     /// A stack of modules used to decide what scope to resolve in.\n@@ -179,11 +200,18 @@ struct LinkCollector<'a, 'tcx> {\n     /// because `clean` and the disambiguator code expect them to be different.\n     /// See the code for associated items on inherent impls for details.\n     kind_side_channel: Cell<Option<(DefKind, DefId)>>,\n+    /// Cache the resolved links so we can avoid resolving (and emitting errors for) the same link\n+    visited_links: FxHashMap<ResolutionInfo, CachedLink>,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        LinkCollector { cx, mod_ids: Vec::new(), kind_side_channel: Cell::new(None) }\n+        LinkCollector {\n+            cx,\n+            mod_ids: Vec::new(),\n+            kind_side_channel: Cell::new(None),\n+            visited_links: FxHashMap::default(),\n+        }\n     }\n \n     /// Given a full link, parse it as an [enum struct variant].\n@@ -937,7 +965,7 @@ impl LinkCollector<'_, '_> {\n     ///\n     /// FIXME(jynelson): this is way too many arguments\n     fn resolve_link(\n-        &self,\n+        &mut self,\n         item: &Item,\n         dox: &str,\n         self_name: &Option<String>,\n@@ -962,6 +990,7 @@ impl LinkCollector<'_, '_> {\n         let link = ori_link.replace(\"`\", \"\");\n         let parts = link.split('#').collect::<Vec<_>>();\n         let (link, extra_fragment) = if parts.len() > 2 {\n+            // A valid link can't have multiple #'s\n             anchor_failure(cx, &item, &link, dox, link_range, AnchorFailure::MultipleAnchors);\n             return None;\n         } else if parts.len() == 2 {\n@@ -1075,16 +1104,15 @@ impl LinkCollector<'_, '_> {\n             return None;\n         }\n \n-        let (mut res, mut fragment) = self.resolve_with_disambiguator(\n-            disambiguator,\n-            item,\n-            dox,\n-            path_str,\n+        let key = ResolutionInfo {\n             module_id,\n+            dis: disambiguator,\n+            path_str: path_str.to_owned(),\n             extra_fragment,\n-            &ori_link,\n-            link_range.clone(),\n-        )?;\n+        };\n+        let diag =\n+            DiagnosticInfo { item, dox, ori_link: &ori_link, link_range: link_range.clone() };\n+        let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(key, diag)?;\n \n         // Check for a primitive which might conflict with a module\n         // Report the ambiguity and require that the user specify which one they meant.\n@@ -1192,22 +1220,49 @@ impl LinkCollector<'_, '_> {\n         }\n     }\n \n+    fn resolve_with_disambiguator_cached(\n+        &mut self,\n+        key: ResolutionInfo,\n+        diag: DiagnosticInfo<'_>,\n+    ) -> Option<(Res, Option<String>)> {\n+        // Try to look up both the result and the corresponding side channel value\n+        if let Some(ref cached) = self.visited_links.get(&key) {\n+            self.kind_side_channel.set(cached.side_channel.clone());\n+            return Some(cached.res.clone());\n+        }\n+\n+        let res = self.resolve_with_disambiguator(&key, diag);\n+\n+        // Cache only if resolved successfully - don't silence duplicate errors\n+        if let Some(res) = &res {\n+            // Store result for the actual namespace\n+            self.visited_links.insert(\n+                key,\n+                CachedLink {\n+                    res: res.clone(),\n+                    side_channel: self.kind_side_channel.clone().into_inner(),\n+                },\n+            );\n+        }\n+\n+        res\n+    }\n+\n     /// After parsing the disambiguator, resolve the main part of the link.\n     // FIXME(jynelson): wow this is just so much\n     fn resolve_with_disambiguator(\n         &self,\n-        disambiguator: Option<Disambiguator>,\n-        item: &Item,\n-        dox: &str,\n-        path_str: &str,\n-        base_node: DefId,\n-        extra_fragment: Option<String>,\n-        ori_link: &str,\n-        link_range: Option<Range<usize>>,\n+        key: &ResolutionInfo,\n+        diag: DiagnosticInfo<'_>,\n     ) -> Option<(Res, Option<String>)> {\n+        let disambiguator = key.dis;\n+        let path_str = &key.path_str;\n+        let base_node = key.module_id;\n+        let extra_fragment = &key.extra_fragment;\n+\n         match disambiguator.map(Disambiguator::ns) {\n             Some(ns @ (ValueNS | TypeNS)) => {\n-                match self.resolve(path_str, ns, base_node, &extra_fragment) {\n+                match self.resolve(path_str, ns, base_node, extra_fragment) {\n                     Ok(res) => Some(res),\n                     Err(ErrorKind::Resolve(box mut kind)) => {\n                         // We only looked in one namespace. Try to give a better error if possible.\n@@ -1216,24 +1271,21 @@ impl LinkCollector<'_, '_> {\n                             // FIXME: really it should be `resolution_failure` that does this, not `resolve_with_disambiguator`\n                             // See https://github.com/rust-lang/rust/pull/76955#discussion_r493953382 for a good approach\n                             for &new_ns in &[other_ns, MacroNS] {\n-                                if let Some(res) = self.check_full_res(\n-                                    new_ns,\n-                                    path_str,\n-                                    base_node,\n-                                    &extra_fragment,\n-                                ) {\n+                                if let Some(res) =\n+                                    self.check_full_res(new_ns, path_str, base_node, extra_fragment)\n+                                {\n                                     kind = ResolutionFailure::WrongNamespace(res, ns);\n                                     break;\n                                 }\n                             }\n                         }\n                         resolution_failure(\n                             self,\n-                            &item,\n+                            diag.item,\n                             path_str,\n                             disambiguator,\n-                            dox,\n-                            link_range,\n+                            diag.dox,\n+                            diag.link_range,\n                             smallvec![kind],\n                         );\n                         // This could just be a normal link or a broken link\n@@ -1242,7 +1294,14 @@ impl LinkCollector<'_, '_> {\n                         return None;\n                     }\n                     Err(ErrorKind::AnchorFailure(msg)) => {\n-                        anchor_failure(self.cx, &item, &ori_link, dox, link_range, msg);\n+                        anchor_failure(\n+                            self.cx,\n+                            diag.item,\n+                            diag.ori_link,\n+                            diag.dox,\n+                            diag.link_range,\n+                            msg,\n+                        );\n                         return None;\n                     }\n                 }\n@@ -1253,21 +1312,35 @@ impl LinkCollector<'_, '_> {\n                     macro_ns: self\n                         .resolve_macro(path_str, base_node)\n                         .map(|res| (res, extra_fragment.clone())),\n-                    type_ns: match self.resolve(path_str, TypeNS, base_node, &extra_fragment) {\n+                    type_ns: match self.resolve(path_str, TypeNS, base_node, extra_fragment) {\n                         Ok(res) => {\n                             debug!(\"got res in TypeNS: {:?}\", res);\n                             Ok(res)\n                         }\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            anchor_failure(\n+                                self.cx,\n+                                diag.item,\n+                                diag.ori_link,\n+                                diag.dox,\n+                                diag.link_range,\n+                                msg,\n+                            );\n                             return None;\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n                     },\n-                    value_ns: match self.resolve(path_str, ValueNS, base_node, &extra_fragment) {\n+                    value_ns: match self.resolve(path_str, ValueNS, base_node, extra_fragment) {\n                         Ok(res) => Ok(res),\n                         Err(ErrorKind::AnchorFailure(msg)) => {\n-                            anchor_failure(self.cx, &item, ori_link, dox, link_range, msg);\n+                            anchor_failure(\n+                                self.cx,\n+                                diag.item,\n+                                diag.ori_link,\n+                                diag.dox,\n+                                diag.link_range,\n+                                msg,\n+                            );\n                             return None;\n                         }\n                         Err(ErrorKind::Resolve(box kind)) => Err(kind),\n@@ -1278,7 +1351,7 @@ impl LinkCollector<'_, '_> {\n                             Res::Def(DefKind::Ctor(..), _) | Res::SelfCtor(..) => {\n                                 Err(ResolutionFailure::WrongNamespace(res, TypeNS))\n                             }\n-                            _ => match (fragment, extra_fragment) {\n+                            _ => match (fragment, extra_fragment.clone()) {\n                                 (Some(fragment), Some(_)) => {\n                                     // Shouldn't happen but who knows?\n                                     Ok((res, Some(fragment)))\n@@ -1294,11 +1367,11 @@ impl LinkCollector<'_, '_> {\n                 if len == 0 {\n                     resolution_failure(\n                         self,\n-                        &item,\n+                        diag.item,\n                         path_str,\n                         disambiguator,\n-                        dox,\n-                        link_range,\n+                        diag.dox,\n+                        diag.link_range,\n                         candidates.into_iter().filter_map(|res| res.err()).collect(),\n                     );\n                     // this could just be a normal link\n@@ -1317,35 +1390,35 @@ impl LinkCollector<'_, '_> {\n                     let candidates = candidates.map(|candidate| candidate.ok().map(|(res, _)| res));\n                     ambiguity_error(\n                         self.cx,\n-                        &item,\n+                        diag.item,\n                         path_str,\n-                        dox,\n-                        link_range,\n+                        diag.dox,\n+                        diag.link_range,\n                         candidates.present_items().collect(),\n                     );\n                     return None;\n                 }\n             }\n             Some(MacroNS) => {\n                 match self.resolve_macro(path_str, base_node) {\n-                    Ok(res) => Some((res, extra_fragment)),\n+                    Ok(res) => Some((res, extra_fragment.clone())),\n                     Err(mut kind) => {\n                         // `resolve_macro` only looks in the macro namespace. Try to give a better error if possible.\n                         for &ns in &[TypeNS, ValueNS] {\n                             if let Some(res) =\n-                                self.check_full_res(ns, path_str, base_node, &extra_fragment)\n+                                self.check_full_res(ns, path_str, base_node, extra_fragment)\n                             {\n                                 kind = ResolutionFailure::WrongNamespace(res, MacroNS);\n                                 break;\n                             }\n                         }\n                         resolution_failure(\n                             self,\n-                            &item,\n+                            diag.item,\n                             path_str,\n                             disambiguator,\n-                            dox,\n-                            link_range,\n+                            diag.dox,\n+                            diag.link_range,\n                             smallvec![kind],\n                         );\n                         return None;\n@@ -1356,7 +1429,7 @@ impl LinkCollector<'_, '_> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n /// Disambiguators for a link.\n enum Disambiguator {\n     /// `prim@`"}, {"sha": "add1530a5a675b7c71a7430c67159691f34115a2", "filename": "src/test/rustdoc/intra-link-self-cache.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1cce06e4ff5206daf397e1dcf91ed53653be171/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1cce06e4ff5206daf397e1dcf91ed53653be171/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-self-cache.rs?ref=e1cce06e4ff5206daf397e1dcf91ed53653be171", "patch": "@@ -0,0 +1,14 @@\n+#![crate_name = \"foo\"]\n+// @has foo/enum.E1.html '//a/@href' '../foo/enum.E1.html#variant.A'\n+\n+/// [Self::A::b]\n+pub enum E1 {\n+    A { b: usize }\n+}\n+\n+// @has foo/enum.E2.html '//a/@href' '../foo/enum.E2.html#variant.A'\n+\n+/// [Self::A::b]\n+pub enum E2 {\n+    A { b: usize }\n+}"}]}