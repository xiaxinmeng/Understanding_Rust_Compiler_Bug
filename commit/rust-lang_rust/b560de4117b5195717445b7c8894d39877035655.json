{"sha": "b560de4117b5195717445b7c8894d39877035655", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NjBkZTQxMTdiNTE5NTcxNzQ0NWI3Yzg4OTRkMzk4NzcwMzU2NTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-19T13:33:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-19T13:33:30Z"}, "message": "Merge #3234\n\n3234: Don't store deriveable Module info in NameDefinition r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "384bb98ea93bfd7dddee5a2ba0c713ec38c2dde0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384bb98ea93bfd7dddee5a2ba0c713ec38c2dde0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b560de4117b5195717445b7c8894d39877035655", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeTTkqCRBK7hj4Ov3rIwAAdHIIAHGKiItwcbbvhYumPXd3UKCn\nMgYQ0GvRASgR8CpgLbC/ggFl5mZADNhk/ouHbbPN2hcKi4fBwEBIiHXYbr9XZsJN\nwilKZjFyepnMhWLb4txo+BG6Otpg2z6GokzrB/xtixQesGT2qHhE4jgpjTWEhKRo\nHASSI/CdhdwW26bCO4YkFlkR7nf5Vc3gWGesaTvNulMpN2FiWYNglArsJg03JUhS\nbYUHLb5A8nLKjTqMEGpqdPJ/1TlowOAv/C5Avp0drWyxT0hPagb+jme8K01b6ty3\ns7Z0coyNoQJ6kBbN0yHY0rH5OTqmfTv6vSdS0trigYZ7Vq6kCYAbru4gVCXka9I=\n=oysr\n-----END PGP SIGNATURE-----\n", "payload": "tree 384bb98ea93bfd7dddee5a2ba0c713ec38c2dde0\nparent 61fdcc5ded44d4a7300b19cf946acc30367dcbd2\nparent 86b66067f6321382cd72ec29c49d166da46fc3f8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1582119210 +0000\ncommitter GitHub <noreply@github.com> 1582119210 +0000\n\nMerge #3234\n\n3234: Don't store deriveable Module info in NameDefinition r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b560de4117b5195717445b7c8894d39877035655", "html_url": "https://github.com/rust-lang/rust/commit/b560de4117b5195717445b7c8894d39877035655", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b560de4117b5195717445b7c8894d39877035655/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61fdcc5ded44d4a7300b19cf946acc30367dcbd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/61fdcc5ded44d4a7300b19cf946acc30367dcbd2", "html_url": "https://github.com/rust-lang/rust/commit/61fdcc5ded44d4a7300b19cf946acc30367dcbd2"}, {"sha": "86b66067f6321382cd72ec29c49d166da46fc3f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/86b66067f6321382cd72ec29c49d166da46fc3f8", "html_url": "https://github.com/rust-lang/rust/commit/86b66067f6321382cd72ec29c49d166da46fc3f8"}], "stats": {"total": 144, "additions": 84, "deletions": 60}, "files": [{"sha": "efc3502d0c92b66ef0a1b2241d58a4d5e0cbe52f", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=b560de4117b5195717445b7c8894d39877035655", "patch": "@@ -30,6 +30,7 @@ use ra_syntax::{\n     ast::{self, AttrsOwner},\n     AstNode,\n };\n+use rustc_hash::FxHashSet;\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n@@ -123,10 +124,25 @@ impl_froms!(\n     BuiltinType\n );\n \n+impl ModuleDef {\n+    pub fn module(self, db: &impl HirDatabase) -> Option<Module> {\n+        match self {\n+            ModuleDef::Module(it) => it.parent(db),\n+            ModuleDef::Function(it) => Some(it.module(db)),\n+            ModuleDef::Adt(it) => Some(it.module(db)),\n+            ModuleDef::EnumVariant(it) => Some(it.module(db)),\n+            ModuleDef::Const(it) => Some(it.module(db)),\n+            ModuleDef::Static(it) => Some(it.module(db)),\n+            ModuleDef::Trait(it) => Some(it.module(db)),\n+            ModuleDef::TypeAlias(it) => Some(it.module(db)),\n+            ModuleDef::BuiltinType(_) => None,\n+        }\n+    }\n+}\n+\n pub use hir_def::{\n     attr::Attrs, item_scope::ItemInNs, visibility::Visibility, AssocItemId, AssocItemLoc,\n };\n-use rustc_hash::FxHashSet;\n \n impl Module {\n     pub(crate) fn new(krate: Crate, crate_module_id: LocalModuleId) -> Module {\n@@ -649,6 +665,17 @@ pub struct MacroDef {\n     pub(crate) id: MacroDefId,\n }\n \n+impl MacroDef {\n+    /// FIXME: right now, this just returns the root module of the crate that\n+    /// defines this macro. The reasons for this is that macros are expanded\n+    /// early, in `ra_hir_expand`, where modules simply do not exist yet.\n+    pub fn module(self, db: &impl HirDatabase) -> Option<Module> {\n+        let krate = self.id.krate?;\n+        let module_id = db.crate_def_map(krate).root;\n+        Some(Module::new(Crate { id: krate }, module_id))\n+    }\n+}\n+\n /// Invariant: `inner.as_assoc_item(db).is_some()`\n /// We do not actively enforce this invariant.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]"}, {"sha": "2394e68d1c5cd73df10331505b93d8a5f9208429", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=b560de4117b5195717445b7c8894d39877035655", "patch": "@@ -22,7 +22,7 @@ pub(crate) fn classify_name_ref(\n     if let Some(method_call) = ast::MethodCallExpr::cast(parent.clone()) {\n         tested_by!(goto_def_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(from_module_def(sb.db, func.into(), None));\n+            return Some(from_module_def(sb.db, func.into()));\n         }\n     }\n \n@@ -43,48 +43,44 @@ pub(crate) fn classify_name_ref(\n \n     // FIXME: find correct container and visibility for each case\n     let visibility = None;\n-    let container = sb.to_module_def(name_ref.file_id.original_file(sb.db))?;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n         if let Some(macro_def) =\n             analyzer.resolve_macro_call(sb.db, name_ref.with_value(&macro_call))\n         {\n             let kind = NameKind::Macro(macro_def);\n-            return Some(NameDefinition { kind, container, visibility });\n+            return Some(NameDefinition { kind, visibility });\n         }\n     }\n \n     let path = name_ref.value.syntax().ancestors().find_map(ast::Path::cast)?;\n     let resolved = analyzer.resolve_path(sb.db, &path)?;\n     let res = match resolved {\n-        PathResolution::Def(def) => from_module_def(sb.db, def, Some(container)),\n+        PathResolution::Def(def) => from_module_def(sb.db, def),\n         PathResolution::AssocItem(item) => {\n             let def = match item {\n                 hir::AssocItem::Function(it) => it.into(),\n                 hir::AssocItem::Const(it) => it.into(),\n                 hir::AssocItem::TypeAlias(it) => it.into(),\n             };\n-            from_module_def(sb.db, def, Some(container))\n+            from_module_def(sb.db, def)\n         }\n         PathResolution::Local(local) => {\n             let kind = NameKind::Local(local);\n-            let container = local.module(sb.db);\n-            NameDefinition { kind, container, visibility: None }\n+            NameDefinition { kind, visibility: None }\n         }\n         PathResolution::TypeParam(par) => {\n             let kind = NameKind::TypeParam(par);\n-            let container = par.module(sb.db);\n-            NameDefinition { kind, container, visibility }\n+            NameDefinition { kind, visibility }\n         }\n         PathResolution::Macro(def) => {\n             let kind = NameKind::Macro(def);\n-            NameDefinition { kind, container, visibility }\n+            NameDefinition { kind, visibility }\n         }\n         PathResolution::SelfType(impl_block) => {\n             let kind = NameKind::SelfType(impl_block);\n-            let container = impl_block.module(sb.db);\n-            NameDefinition { kind, container, visibility }\n+            NameDefinition { kind, visibility }\n         }\n     };\n     Some(res)"}, {"sha": "f9bbe64a4468fbab0c204dfcf6776615b8c450c3", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=b560de4117b5195717445b7c8894d39877035655", "patch": "@@ -19,10 +19,17 @@ pub struct SearchScope {\n }\n \n impl SearchScope {\n+    fn empty() -> SearchScope {\n+        SearchScope { entries: FxHashMap::default() }\n+    }\n+\n     pub(crate) fn for_def(def: &NameDefinition, db: &RootDatabase) -> SearchScope {\n         let _p = profile(\"search_scope\");\n-\n-        let module_src = def.container.definition_source(db);\n+        let module = match def.module(db) {\n+            Some(it) => it,\n+            None => return SearchScope::empty(),\n+        };\n+        let module_src = module.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n         if let NameKind::Local(var) = def.kind {\n@@ -39,7 +46,7 @@ impl SearchScope {\n         let vis = def.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n \n         if vis.as_str() == \"pub(super)\" {\n-            if let Some(parent_module) = def.container.parent(db) {\n+            if let Some(parent_module) = module.parent(db) {\n                 let mut res = FxHashMap::default();\n                 let parent_src = parent_module.definition_source(db);\n                 let file_id = parent_src.file_id.original_file(db);\n@@ -72,7 +79,7 @@ impl SearchScope {\n                 return SearchScope::new(res);\n             }\n             if vis.as_str() == \"pub\" {\n-                let krate = def.container.krate();\n+                let krate = module.krate();\n                 for rev_dep in krate.reverse_dependencies(db) {\n                     let root_file = rev_dep.root_file(db);\n                     let source_root_id = db.file_source_root(root_file);"}, {"sha": "cc772de516a1194b870a81b1e25dfed7ce4832f2", "filename": "crates/ra_ide_db/src/defs.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b560de4117b5195717445b7c8894d39877035655/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=b560de4117b5195717445b7c8894d39877035655", "patch": "@@ -32,10 +32,22 @@ pub struct NameDefinition {\n     pub visibility: Option<ast::Visibility>,\n     /// FIXME: this doesn't really make sense. For example, builtin types don't\n     /// really have a module.\n-    pub container: Module,\n     pub kind: NameKind,\n }\n \n+impl NameDefinition {\n+    pub fn module(&self, db: &RootDatabase) -> Option<Module> {\n+        match self.kind {\n+            NameKind::Macro(it) => it.module(db),\n+            NameKind::StructField(it) => Some(it.parent_def(db).module(db)),\n+            NameKind::ModuleDef(it) => it.module(db),\n+            NameKind::SelfType(it) => Some(it.module(db)),\n+            NameKind::Local(it) => Some(it.module(db)),\n+            NameKind::TypeParam(it) => Some(it.module(db)),\n+        }\n+    }\n+}\n+\n pub fn classify_name(\n     sb: &mut SourceBinder<RootDatabase>,\n     name: InFile<&ast::Name>,\n@@ -50,7 +62,6 @@ pub fn classify_name(\n                 let local = sb.to_def(src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: local.module(sb.db),\n                     kind: NameKind::Local(local),\n                 })\n             },\n@@ -61,57 +72,54 @@ pub fn classify_name(\n             },\n             ast::Module(it) => {\n                 let def = sb.to_def(name.with_value(it))?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::StructDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Struct = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::EnumDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Enum = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::TraitDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Trait = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::StaticDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Static = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::EnumVariant(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::EnumVariant = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::FnDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Function = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::ConstDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::Const = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::TypeAliasDef(it) => {\n                 let src = name.with_value(it);\n                 let def: hir::TypeAlias = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n+                Some(from_module_def(sb.db, def.into()))\n             },\n             ast::MacroCall(it) => {\n                 let src = name.with_value(it);\n                 let def = sb.to_def(src.clone())?;\n \n-                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n-\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: module,\n                     kind: NameKind::Macro(def),\n                 })\n             },\n@@ -120,7 +128,6 @@ pub fn classify_name(\n                 let def = sb.to_def(src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n-                    container: def.module(sb.db),\n                     kind: NameKind::TypeParam(def),\n                 })\n             },\n@@ -132,41 +139,28 @@ pub fn classify_name(\n pub fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n     let kind = NameKind::StructField(field);\n     let parent = field.parent_def(db);\n-    let container = parent.module(db);\n     let visibility = match parent {\n         VariantDef::Struct(s) => s.source(db).value.visibility(),\n         VariantDef::Union(e) => e.source(db).value.visibility(),\n         VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n     };\n-    NameDefinition { kind, container, visibility }\n+    NameDefinition { kind, visibility }\n }\n \n-pub fn from_module_def(\n-    db: &RootDatabase,\n-    def: ModuleDef,\n-    module: Option<Module>,\n-) -> NameDefinition {\n+pub fn from_module_def(db: &RootDatabase, def: ModuleDef) -> NameDefinition {\n     let kind = NameKind::ModuleDef(def);\n-    let (container, visibility) = match def {\n-        ModuleDef::Module(it) => {\n-            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n-            (container, visibility)\n-        }\n-        ModuleDef::EnumVariant(it) => {\n-            let container = it.module(db);\n-            let visibility = it.source(db).value.parent_enum().visibility();\n-            (container, visibility)\n-        }\n-        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n+    let visibility = match def {\n+        ModuleDef::Module(it) => it.declaration_source(db).and_then(|s| s.value.visibility()),\n+        ModuleDef::EnumVariant(it) => it.source(db).value.parent_enum().visibility(),\n+        ModuleDef::Function(it) => it.source(db).value.visibility(),\n+        ModuleDef::Const(it) => it.source(db).value.visibility(),\n+        ModuleDef::Static(it) => it.source(db).value.visibility(),\n+        ModuleDef::Trait(it) => it.source(db).value.visibility(),\n+        ModuleDef::TypeAlias(it) => it.source(db).value.visibility(),\n+        ModuleDef::Adt(Adt::Struct(it)) => it.source(db).value.visibility(),\n+        ModuleDef::Adt(Adt::Union(it)) => it.source(db).value.visibility(),\n+        ModuleDef::Adt(Adt::Enum(it)) => it.source(db).value.visibility(),\n+        ModuleDef::BuiltinType(..) => None,\n     };\n-    NameDefinition { kind, container, visibility }\n+    NameDefinition { kind, visibility }\n }"}]}