{"sha": "752544b28411540d7beb6fe4d1e2f1d8c775e05b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1MjU0NGIyODQxMTU0MGQ3YmViNmZlNGQxZTJmMWQ4Yzc3NWUwNWI=", "commit": {"author": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-23T12:59:02Z"}, "committer": {"name": "Saleem Jaffer", "email": "saleem@acko.com", "date": "2019-03-23T14:48:52Z"}, "message": "adding mir::StaticKind enum for static and promoted", "tree": {"sha": "cb9af976b10ef93971b1eff8f30f979057621c70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb9af976b10ef93971b1eff8f30f979057621c70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/752544b28411540d7beb6fe4d1e2f1d8c775e05b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/752544b28411540d7beb6fe4d1e2f1d8c775e05b", "html_url": "https://github.com/rust-lang/rust/commit/752544b28411540d7beb6fe4d1e2f1d8c775e05b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/752544b28411540d7beb6fe4d1e2f1d8c775e05b/comments", "author": null, "committer": null, "parents": [{"sha": "cf2f1bb072c76ed45882e1a69ed7b8ec96bad0e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2f1bb072c76ed45882e1a69ed7b8ec96bad0e9", "html_url": "https://github.com/rust-lang/rust/commit/cf2f1bb072c76ed45882e1a69ed7b8ec96bad0e9"}], "stats": {"total": 404, "additions": 238, "deletions": 166}, "files": [{"sha": "12f14cfbb9afaacd459a59a236cb8d89160a9137", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -1915,19 +1915,22 @@ pub enum PlaceBase<'tcx> {\n     Static(Box<Static<'tcx>>),\n }\n \n-/// The `DefId` of a static, along with its normalized type (which is\n-/// stored to avoid requiring normalization when reading MIR).\n+/// We store the normalized type to avoid requiring normalization when reading MIR\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n-    pub def_id: DefId,\n     pub ty: Ty<'tcx>,\n-    pub promoted: Option<Promoted>,\n+    pub kind: StaticKind,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable)]\n+pub enum StaticKind {\n+    Promoted(Promoted),\n+    Static(DefId),\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n-    def_id,\n     ty,\n-    promoted\n+    kind\n });\n \n /// The `Projection` data structure defines things of the form `B.x`\n@@ -2058,21 +2061,23 @@ impl<'tcx> Debug for Place<'tcx> {\n \n         match *self {\n             Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n-            Base(PlaceBase::Static(box self::Static { def_id, ty, promoted })) => {\n-                match promoted {\n-                    None => write!(\n-                        fmt,\n-                        \"({}: {:?})\",\n-                        ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n-                        ty\n-                    ),\n-                    Some(pr) => write!(\n-                        fmt,\n-                        \"({:?}: {:?})\",\n-                        pr,\n-                        ty\n-                    ),\n-                }\n+            Base(PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) })) => {\n+                write!(\n+                    fmt,\n+                    \"({}: {:?})\",\n+                    ty::tls::with(|tcx| tcx.def_path_str(def_id)),\n+                    ty\n+                )\n+            },\n+            Base(PlaceBase::Static(\n+                box self::Static { ty, kind: StaticKind::Promoted(promoted) })\n+            ) => {\n+                write!(\n+                    fmt,\n+                    \"({:?}: {:?})\",\n+                    promoted,\n+                    ty\n+                )\n             },\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {"}, {"sha": "b1e2df0ae986bda69415646ee69222c387952147", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -725,15 +725,18 @@ macro_rules! make_mir_visitor {\n                             place: & $($mutability)? Place<'tcx>,\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n+                use crate::mir::{Static, StaticKind};\n                 match place {\n                     Place::Base(PlaceBase::Local(local)) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Base(PlaceBase::Static(static_)) => {\n-                        if static_.promoted.is_none() {\n-                            self.visit_def_id(& $($mutability)? static_.def_id, location);\n-                        }\n-                        self.visit_ty(& $($mutability)? static_.ty, TyContext::Location(location));\n+                    Place::Base(\n+                        PlaceBase::Static(box Static{kind: StaticKind::Static(def_id), ..})\n+                    ) => {\n+                        self.visit_def_id(& $($mutability)? *def_id, location)\n+                    }\n+                    Place::Base(PlaceBase::Static(box Static{ty, ..})) => {\n+                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n                     Place::Projection(proj) => {\n                         self.visit_projection(proj, context, location);"}, {"sha": "4774f8fe5a380b97bc4aad9a406e50bd8d27d8bf", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -1,7 +1,7 @@\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutOf, HasTyCtxt};\n-use rustc::mir::{self, Place, PlaceBase};\n+use rustc::mir::{self, Place, PlaceBase, Static, StaticKind};\n use rustc::mir::interpret::EvalErrorKind;\n use rustc_target::abi::call::{ArgType, FnType, PassMode, IgnoreMode};\n use rustc_target::spec::abi::Abi;\n@@ -621,14 +621,18 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n                         mir::Operand::Copy(\n-                            Place::Base(PlaceBase::Static(\n-                                box mir::Static {promoted: Some(promoted), ty, ..}\n-                            ))\n+                            Place::Base(\n+                                PlaceBase::Static(\n+                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n+                                )\n+                            )\n                         ) |\n                         mir::Operand::Move(\n-                            Place::Base(PlaceBase::Static(\n-                                box mir::Static {promoted: Some(promoted), ty, ..}\n-                            ))\n+                            Place::Base(\n+                                PlaceBase::Static(\n+                                    box Static { kind: StaticKind::Promoted(promoted), ty }\n+                                )\n+                            )\n                         ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n                             let cid = mir::interpret::GlobalId {"}, {"sha": "7cafa0088a01270961b763c7827f0822fb7f8f5f", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -409,7 +409,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let result = match *place {\n             mir::Place::Base(mir::PlaceBase::Local(_)) => bug!(), // handled above\n             mir::Place::Base(\n-                mir::PlaceBase::Static(box mir::Static { def_id: _, ty, promoted: Some(promoted) })\n+                mir::PlaceBase::Static(\n+                    box mir::Static { ty, kind: mir::StaticKind::Promoted(promoted) }\n+                )\n             ) => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let cid = mir::interpret::GlobalId {\n@@ -438,7 +440,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 }\n             }\n             mir::Place::Base(\n-                mir::PlaceBase::Static(box mir::Static { def_id, ty, promoted: None })\n+                mir::PlaceBase::Static(\n+                    box mir::Static { ty, kind: mir::StaticKind::Static(def_id) }\n+                )\n             ) => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type."}, {"sha": "fac75989aa59034d7f0e15fc4eea912a2f15222a", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -10,7 +10,7 @@ use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Constant,\n     ConstraintCategory, Field, Local, LocalDecl, LocalKind, Location, Operand,\n     Place, PlaceBase, PlaceProjection, ProjectionElem, Rvalue, Statement, StatementKind,\n-    TerminatorKind, VarBindingForm,\n+    Static, StaticKind, TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n use rustc::ty::print::Print;\n@@ -1601,12 +1601,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Place::Base(PlaceBase::Local(local)) => {\n                 self.append_local_to_string(local, buf)?;\n             }\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                if static_.promoted.is_some() {\n-                    buf.push_str(\"promoted\");\n-                } else {\n-                    buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n-                }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                buf.push_str(\"promoted\");\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                buf.push_str(&self.infcx.tcx.item_name(def_id).to_string());\n             }\n             Place::Projection(ref proj) => {\n                 match proj.elem {\n@@ -1808,8 +1807,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Checks if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n-        if let Place::Base(PlaceBase::Static(statik)) = place {\n-            let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n+        if let Place::Base(\n+            PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })\n+        ) = place {\n+            let attrs = self.infcx.tcx.get_attrs(*def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n             debug!("}, {"sha": "40b329c1084016625efcbaae7741cfe4be0341a1", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -8,7 +8,9 @@ use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase};\n+use rustc::mir::{\n+    ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase, Static, StaticKind\n+};\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n@@ -1308,8 +1310,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n-            Place::Base(PlaceBase::Static(st)) => {\n-                (true, st.promoted.is_none() && self.is_place_thread_local(&root_place))\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {\n+                (true, false)\n+            }\n+            Place::Base(PlaceBase::Static(box Static{ kind: _, .. })) => {\n+                // Thread-locals might be dropped after the function exits, but\n+                // \"true\" statics will never be.\n+                (true, self.is_place_thread_local(&root_place))\n             }\n             Place::Base(PlaceBase::Local(_)) => {\n                 // Locals are always dropped at function exit, and if they\n@@ -1982,18 +1989,19 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            Place::Base(PlaceBase::Static(ref static_)) => {\n-                if static_.promoted.is_some() ||\n-                    (static_.promoted.is_none() &&\n-                        self.infcx.tcx.is_static(static_.def_id)\n-                            == Some(hir::Mutability::MutMutable)\n-                    ){\n+            Place::Base(PlaceBase::Static(box Static{kind: StaticKind::Promoted(_), ..})) =>\n+                Ok(RootPlace {\n+                    place,\n+                    is_local_mutation_allowed,\n+                }),\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                if self.infcx.tcx.is_static(def_id) != Some(hir::Mutability::MutMutable) {\n+                    Err(place)\n+                } else {\n                     Ok(RootPlace {\n                         place,\n                         is_local_mutation_allowed,\n                     })\n-                } else {\n-                    Err(place)\n                 }\n             }\n             Place::Projection(ref proj) => {"}, {"sha": "f351212e9d5876f990c4d2d1896c05faa3450534", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -1,7 +1,9 @@\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Mir};\n-use rustc::mir::{Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static};\n+use rustc::mir::{\n+    Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind,\n+};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::{self, Const, DefIdTree, TyS, TyKind, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n@@ -129,8 +131,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: _, promoted })) => {\n-                assert!(promoted.is_none());\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) =>\n+                unreachable!(),\n+\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })) => {\n                 if let Place::Base(PlaceBase::Static(_)) = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();"}, {"sha": "e12077fd5f7ae497dce25e7f46445f6a4c3ef88a", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 35, "deletions": 27, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -453,45 +453,53 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n-            Place::Base(PlaceBase::Static(box Static { def_id, ty: sty, promoted })) => {\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), ty: sty })\n+            ) => {\n                 let sty = self.sanitize_type(place, sty);\n-                let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx> ,\n-                     place: &Place<'tcx>,\n-                     ty,\n-                     sty| {\n-                    if let Err(terr) = verifier.cx.eq_types(\n+\n+                if !self.errors_reported {\n+                    let promoted_mir = &self.mir.promoted[promoted];\n+                    self.sanitize_promoted(promoted_mir, location);\n+\n+                    let promoted_ty = promoted_mir.return_ty();\n+\n+                    if let Err(terr) = self.cx.eq_types(\n                         sty,\n-                        ty,\n+                        promoted_ty,\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n                         span_mirbug!(\n-                            verifier,\n+                            self,\n                             place,\n                             \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            ty,\n+                            promoted_ty,\n                             sty,\n                             terr\n                         );\n                     };\n-                };\n-                match promoted {\n-                    Some(pr) => {\n-                        if !self.errors_reported {\n-                            let promoted_mir = &self.mir.promoted[pr];\n-                            self.sanitize_promoted(promoted_mir, location);\n-\n-                            let promoted_ty = promoted_mir.return_ty();\n-                            check_err(self, place, promoted_ty, sty);\n-                        }\n-                    }\n-                    None => {\n-                        let ty = self.tcx().type_of(def_id);\n-                        let ty = self.cx.normalize(ty, location);\n-\n-                        check_err(self, place, ty, sty);\n-                    }\n+                }\n+                PlaceTy::Ty { ty: sty }\n+            }\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), ty: sty })\n+            ) => {\n+                let sty = self.sanitize_type(place, sty);\n+                let ty = self.tcx().type_of(def_id);\n+                let ty = self.cx.normalize(ty, location);\n+                if let Err(terr) =\n+                    self.cx\n+                        .eq_types(ty, sty, location.to_locations(), ConstraintCategory::Boring)\n+                {\n+                    span_mirbug!(\n+                        self,\n+                        place,\n+                        \"bad static type ({:?}: {:?}): {:?}\",\n+                        ty,\n+                        sty,\n+                        terr\n+                    );\n                 }\n                 PlaceTy::Ty { ty: sty }\n             }"}, {"sha": "6bc56ab721f985711792ff270cd5bb920c5a8657", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability};\n+use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability, Static, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -49,9 +49,10 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     }\n                 }\n             }\n-            Place::Base(PlaceBase::Static(static_)) => {\n-                static_.promoted.is_none() &&\n-                    (tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable))\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n+                false,\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n+                tcx.is_static(*def_id) == Some(hir::Mutability::MutMutable)\n             }\n             Place::Projection(proj) => match proj.elem {\n                 ProjectionElem::Field(..)"}, {"sha": "dc9b059de4657e581a04999cc598effc561d208d", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 62, "deletions": 38, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -2,7 +2,7 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem};\n+use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem, Static, StaticKind};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -370,47 +370,71 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Static(s1)), Place::Base(PlaceBase::Static(s2))) => {\n-            match (s1.promoted, s2.promoted) {\n-                (None, None) => {\n-                    if s1.def_id != s2.def_id {\n-                        debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                        Overlap::Disjoint\n-                    } else if tcx.is_static(s1.def_id) == Some(hir::Mutability::MutMutable) {\n-                        // We ignore mutable statics - they can only be unsafe code.\n-                        debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                        Overlap::Disjoint\n-                    } else {\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                        Overlap::EqualOrDisjoint\n-                    }\n-                },\n-                (Some(p1), Some(p2)) => {\n-                    if p1 == p2 {\n-                        if let ty::Array(_, size) = s1.ty.sty {\n-                            if size.unwrap_usize(tcx) == 0 {\n-                                // Ignore conflicts with promoted [T; 0].\n-                                debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n-                                return Overlap::Disjoint;\n-                            }\n-                        }\n-                        // the same promoted - base case, equal\n-                        debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n-                        Overlap::EqualOrDisjoint\n-                    } else {\n-                        // different promoteds - base case, disjoint\n-                        debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n-                        Overlap::Disjoint\n+        (\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id_1), .. })),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id_2), .. })),\n+        ) => {\n+            if *def_id_1 != *def_id_2 {\n+                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n+                Overlap::Disjoint\n+            } else if tcx.is_static(*def_id_1) == Some(hir::Mutability::MutMutable) {\n+                // We ignore mutable statics - they can only be unsafe code.\n+                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n+                Overlap::Disjoint\n+            } else {\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n+                Overlap::EqualOrDisjoint\n+            }\n+        }\n+        (\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted_1), ty })\n+            ),\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted_2), .. })\n+            ),\n+        ) => {\n+            if *promoted_1 == *promoted_2 {\n+                if let ty::Array(_, size) = ty.sty {\n+                    if size.unwrap_usize(tcx) == 0 {\n+                        // Ignore conflicts with promoted [T; 0].\n+                        debug!(\"place_element_conflict: IGNORE-LEN-0-PROMOTED\");\n+                        return Overlap::Disjoint;\n                     }\n-                },\n-                (_, _) => {\n-                    debug!(\"place_element_conflict: DISJOINT-STATIC-PROMOTED\");\n-                    Overlap::Disjoint\n                 }\n+                // the same promoted - base case, equal\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-PROMOTED\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // different promoteds - base case, disjoint\n+                debug!(\"place_element_conflict: DISJOINT-PROMOTED\");\n+                Overlap::Disjoint\n             }\n         }\n-        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n-        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n+        (\n+            Place::Base(PlaceBase::Local(_)),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }))\n+        ) |\n+        (\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })),\n+            Place::Base(PlaceBase::Local(_))\n+        ) |\n+        (\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. }))\n+        ) |\n+        (\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. }))\n+        ) |\n+        (\n+            Place::Base(PlaceBase::Local(_)),\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. }))\n+        ) |\n+        (\n+            Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })),\n+            Place::Base(PlaceBase::Local(_))\n+        ) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n             Overlap::Disjoint\n         }"}, {"sha": "199d03ac445ba51441bcd877e9d5b392a81a5ac0", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -126,9 +126,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 block.and(place)\n             }\n             ExprKind::StaticRef { id } => block.and(Place::Base(PlaceBase::Static(Box::new(Static {\n-                def_id: id,\n                 ty: expr.ty,\n-                promoted: None,\n+                kind: StaticKind::Static(id),\n             })))),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {"}, {"sha": "d2c279e48fe280669638c817e7fab7c76216157d", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -582,17 +582,17 @@ where\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n         use rustc::mir::PlaceBase;\n-        use rustc::mir::Static;\n+        use rustc::mir::{Static, StaticKind};\n         Ok(match *mir_place {\n-            Base(PlaceBase::Static(box Static {promoted: Some(promoted), ty: _, ..})) => {\n+            Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })) => {\n                 let instance = self.frame().instance;\n                 self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: Some(promoted),\n                 })?\n             }\n \n-            Base(PlaceBase::Static(box Static {promoted: None, ty, def_id})) => {\n+            Base(PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), ty })) => {\n                 assert!(!ty.needs_subst());\n                 let layout = self.layout_of(ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, def_id);"}, {"sha": "0ad6962cc4ac57b6fdd495650bcab44785395dac", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -184,7 +184,7 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, TypeFoldable, Ty, TyCtxt, GenericParamDefKind};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::session::config::EntryFnType;\n-use rustc::mir::{self, Location, Promoted};\n+use rustc::mir::{self, Location, Place, PlaceBase, Promoted, Static, StaticKind};\n use rustc::mir::visit::Visitor as MirVisitor;\n use rustc::mir::mono::MonoItem;\n use rustc::mir::interpret::{Scalar, GlobalId, AllocKind, ErrorHandled};\n@@ -655,8 +655,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n                     context: mir::visit::PlaceContext<'tcx>,\n                     location: Location) {\n         match place {\n-            mir::Place::Base(\n-                mir::PlaceBase::Static(box mir::Static{def_id, promoted:None, ..})\n+            Place::Base(\n+                PlaceBase::Static(box Static{ kind:StaticKind::Static(def_id), .. })\n             ) => {\n                 debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n "}, {"sha": "0e31515e4af9038fc7a6dbc75e28fccc3a112d2a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -300,9 +300,12 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             &Place::Base(PlaceBase::Local(..)) => {\n                 // locals are safe\n             }\n-            &Place::Base(PlaceBase::Static(box Static { def_id, ty: _, promoted })) => {\n-                assert!(promoted.is_none(), \"unsafety checking should happen before promotion\");\n-\n+            &Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => {\n+                bug!(\"unsafety checking should happen before promotion\")\n+            }\n+            &Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Static(def_id), .. })\n+            ) => {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\",\n                         \"mutable statics can be mutated by multiple threads: aliasing violations \\"}, {"sha": "c2d594ba7b7fe19e4c04ba9862e975a8c05120a0", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -4,7 +4,7 @@\n \n use rustc::hir::def::Def;\n use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local};\n-use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n+use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind, Static, StaticKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::interpret::{EvalErrorKind, Scalar, GlobalId, EvalResult};\n@@ -266,7 +266,6 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n     }\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n-        use rustc::mir::Static;\n         match *place {\n             Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n             Place::Projection(ref proj) => match proj.elem {\n@@ -283,7 +282,9 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n-            Place::Base(PlaceBase::Static(box Static {promoted: Some(promoted), ..})) => {\n+            Place::Base(\n+                PlaceBase::Static(box Static {kind: StaticKind::Promoted(promoted), ..})\n+            ) => {\n                 let generics = self.tcx.generics_of(self.source.def_id());\n                 if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics"}, {"sha": "1063381d6aa57899fac01a7c113399fa3953c9a7", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -692,7 +692,9 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place::Base(PlaceBase::Static(box Static { promoted: Some(promoted), .. })) => {\n+            Place::Base(\n+                PlaceBase::Static(box Static { kind: StaticKind::Promoted(promoted), .. })\n+            ) => {\n                 if let Some(p) = self.promoted_map.get(*promoted).cloned() {\n                     *promoted = p;\n                 }"}, {"sha": "92039618d85d9c686e3e2b614822daf899964836", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -12,7 +12,6 @@\n //! initialization and can otherwise silence errors, if\n //! move analysis runs after promotion on broken MIR.\n \n-use rustc::hir::def_id::DefId;\n use rustc::mir::*;\n use rustc::mir::visit::{PlaceContext, MutatingUseContext, MutVisitor, Visitor};\n use rustc::mir::traversal::ReversePostorder;\n@@ -152,8 +151,7 @@ struct Promoter<'a, 'tcx: 'a> {\n \n     /// If true, all nested temps are also kept in the\n     /// source MIR, not moved to the promoted MIR.\n-    keep_original: bool,\n-    def_id: DefId,\n+    keep_original: bool\n }\n \n impl<'a, 'tcx> Promoter<'a, 'tcx> {\n@@ -289,16 +287,16 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n     }\n \n     fn promote_candidate(mut self, candidate: Candidate) {\n-        use rustc::mir::Static;\n         let mut operand = {\n-            let def_id = self.def_id;\n             let promoted = &mut self.promoted;\n             let promoted_id = Promoted::new(self.source.promoted.len());\n             let mut promoted_place = |ty, span| {\n                 promoted.span = span;\n-                promoted.local_decls[RETURN_PLACE] = LocalDecl::new_return_place(ty, span);\n+                promoted.local_decls[RETURN_PLACE] =\n+                    LocalDecl::new_return_place(ty, span);\n                 Place::Base(\n-                    PlaceBase::Static(Box::new(Static { def_id, ty, promoted: Some(promoted_id) })))\n+                    PlaceBase::Static(box Static{ kind: StaticKind::Promoted(promoted_id), ty })\n+                )\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n@@ -371,8 +369,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                                     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     mut temps: IndexVec<Local, TempState>,\n-                                    candidates: Vec<Candidate>,\n-                                    def_id: DefId) {\n+                                    candidates: Vec<Candidate>) {\n     // Visit candidates in reverse, in case they're nested.\n     debug!(\"promote_candidates({:?})\", candidates);\n \n@@ -417,8 +414,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n             tcx,\n             source: mir,\n             temps: &mut temps,\n-            keep_original: false,\n-            def_id,\n+            keep_original: false\n         };\n         promoter.promote_candidate(candidate);\n     }"}, {"sha": "c35bf80bb2eda24b82af33f6503106b14897a8f0", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -188,8 +188,9 @@ trait Qualif {\n     fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n         match *place {\n             Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n+            Place::Base(PlaceBase::Static(box Static {kind: StaticKind::Promoted(_), .. })) =>\n+                bug!(\"qualifying already promoted MIR\"),\n             Place::Base(PlaceBase::Static(ref static_)) => {\n-                assert!(static_.promoted.is_none(), \"qualifying already promoted MIR\");\n                 Self::in_static(cx, static_)\n             },\n             Place::Projection(ref proj) => Self::in_projection(cx, proj),\n@@ -372,11 +373,18 @@ impl Qualif for IsNotConst {\n     const IDX: usize = 2;\n \n     fn in_static(cx: &ConstCx<'_, 'tcx>, static_: &Static<'tcx>) -> bool {\n-        // Only allow statics (not consts) to refer to other statics.\n-        let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n+        match static_.kind {\n+            StaticKind::Promoted(_) => unreachable!(),\n+            StaticKind::Static(def_id) => {\n+                // Only allow statics (not consts) to refer to other statics.\n+                let allowed = cx.mode == Mode::Static || cx.mode == Mode::StaticMut;\n \n-        !allowed ||\n-            cx.tcx.get_attrs(static_.def_id).iter().any(|attr| attr.check_name(\"thread_local\"))\n+                !allowed ||\n+                    cx.tcx.get_attrs(def_id).iter().any(\n+                        |attr| attr.check_name(\"thread_local\"\n+                    ))\n+            }\n+        }\n     }\n \n     fn in_projection(cx: &ConstCx<'_, 'tcx>, proj: &PlaceProjection<'tcx>) -> bool {\n@@ -770,8 +778,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     );\n                     dest = &proj.base;\n                 },\n-                Place::Base(PlaceBase::Static(st)) => {\n-                    assert!(st.promoted.is_none(), \"promoteds don't exist yet during promotion\");\n+                Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) =>\n+                    bug!(\"promoteds don't exist yet during promotion\"),\n+                Place::Base(PlaceBase::Static(box Static{ kind: _, .. })) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n                     self.visit_place(\n@@ -921,10 +930,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         self.super_place(place, context, location);\n         match *place {\n             Place::Base(PlaceBase::Local(_)) => {}\n-            Place::Base(PlaceBase::Static(ref global)) => {\n-                assert!(global.promoted.is_none());\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Promoted(_), .. })) => {}\n+            Place::Base(PlaceBase::Static(box Static{ kind: StaticKind::Static(def_id), .. })) => {\n                 if self.tcx\n-                       .get_attrs(global.def_id)\n+                       .get_attrs(def_id)\n                        .iter()\n                        .any(|attr| attr.check_name(\"thread_local\")) {\n                     if self.mode != Mode::Fn {\n@@ -1516,7 +1525,7 @@ impl MirPass for QualifyAndPromoteConstants {\n             };\n \n             // Do the actual promotion, now that we know what's viable.\n-            promote_consts::promote_candidates(mir, tcx, temps, candidates, def_id);\n+            promote_consts::promote_candidates(mir, tcx, temps, candidates);\n         } else {\n             if !mir.control_flow_destroyed.is_empty() {\n                 let mut locals = mir.vars_iter();"}, {"sha": "8742c5d759c8f33feace505aee318a8d5c336a78", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/752544b28411540d7beb6fe4d1e2f1d8c775e05b/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=752544b28411540d7beb6fe4d1e2f1d8c775e05b", "patch": "@@ -257,8 +257,8 @@ fn check_place(\n     match place {\n         Place::Base(PlaceBase::Local(_)) => Ok(()),\n         // promoteds are always fine, they are essentially constants\n-        Place::Base(PlaceBase::Static(box Static {def_id: _, ty: _, promoted: Some(_)})) => Ok(()),\n-        Place::Base(PlaceBase::Static(box Static {def_id: _, ty: _, promoted: None})) =>\n+        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Promoted(_), .. })) => Ok(()),\n+        Place::Base(PlaceBase::Static(box Static { kind: StaticKind::Static(_), .. })) =>\n             Err((span, \"cannot access `static` items in const fn\".into())),\n         Place::Projection(proj) => {\n             match proj.elem {"}]}