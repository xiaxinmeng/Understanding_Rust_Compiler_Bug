{"sha": "8fea5260c2f62fe24e9d86b461d5580d3f217952", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZWE1MjYwYzJmNjJmZTI0ZTlkODZiNDYxZDU1ODBkM2YyMTc5NTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-09T05:03:26Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-09T06:00:59Z"}, "message": "core: Don't deadlock on io streams in run::program_output\n\nWe can't just read all of stdout before stderr or it will cause\ndeadlocks for children that want to write a lot to stderr\n\nI could not come up with an obvious cross-platform way to easily\ntest this.", "tree": {"sha": "d47740a7483bce80b706c8701d759a95bbd353d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d47740a7483bce80b706c8701d759a95bbd353d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fea5260c2f62fe24e9d86b461d5580d3f217952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fea5260c2f62fe24e9d86b461d5580d3f217952", "html_url": "https://github.com/rust-lang/rust/commit/8fea5260c2f62fe24e9d86b461d5580d3f217952", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fea5260c2f62fe24e9d86b461d5580d3f217952/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c91d5aa95c98066c96ede105fa80d84ca9062192", "url": "https://api.github.com/repos/rust-lang/rust/commits/c91d5aa95c98066c96ede105fa80d84ca9062192", "html_url": "https://github.com/rust-lang/rust/commit/c91d5aa95c98066c96ede105fa80d84ca9062192"}], "stats": {"total": 99, "additions": 73, "deletions": 26}, "files": [{"sha": "1d8096042b3f76396aa2cd9cacdde10990716831", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8fea5260c2f62fe24e9d86b461d5580d3f217952/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fea5260c2f62fe24e9d86b461d5580d3f217952/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=8fea5260c2f62fe24e9d86b461d5580d3f217952", "patch": "@@ -32,6 +32,7 @@ fn target_env(_lib_path: str, _prog: str) -> [(str,str)] {\n }\n \n \n+// FIXME: This code is duplicated in core::run::program_output\n fn run(lib_path: str,\n        prog: str,\n        args: [str],"}, {"sha": "56534d0075c4ba25e4afaa07e95915413353db77", "filename": "src/libcore/run.rs", "status": "modified", "additions": 72, "deletions": 26, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/8fea5260c2f62fe24e9d86b461d5580d3f217952/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fea5260c2f62fe24e9d86b461d5580d3f217952/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=8fea5260c2f62fe24e9d86b461d5580d3f217952", "patch": "@@ -265,11 +265,78 @@ the contents of stdout and the contents of stderr.\n \"]\n fn program_output(prog: str, args: [str]) ->\n    {status: int, out: str, err: str} {\n-    let pr = start_program(prog, args);\n-    pr.close_input();\n-    let out = read_all(pr.output());\n-    let err = read_all(pr.err());\n-    ret {status: pr.finish(), out: out, err: err};\n+\n+    let pipe_in = os::pipe();\n+    let pipe_out = os::pipe();\n+    let pipe_err = os::pipe();\n+    let pid = spawn_process(prog, args, none, none,\n+                            pipe_in.in, pipe_out.out, pipe_err.out);\n+\n+    os::close(pipe_in.in);\n+    os::close(pipe_out.out);\n+    os::close(pipe_err.out);\n+    if pid == -1i32 {\n+        os::close(pipe_in.out);\n+        os::close(pipe_out.in);\n+        os::close(pipe_err.in);\n+        fail;\n+    }\n+\n+    os::close(pipe_in.out);\n+\n+    // Spawn two entire schedulers to read both stdout and sterr\n+    // in parallel so we don't deadlock while blocking on one\n+    // or the other. FIXME: Surely there's a much more clever way\n+    // to do this.\n+    let p = comm::port();\n+    let ch = comm::chan(p);\n+    task::spawn_sched(task::single_threaded) {||\n+        let errput = readclose(pipe_err.in);\n+        comm::send(ch, (2, errput));\n+    };\n+    task::spawn_sched(task::single_threaded) {||\n+        let output = readclose(pipe_out.in);\n+        comm::send(ch, (1, output));\n+    };\n+    let status = run::waitpid(pid);\n+    let mut errs = \"\";\n+    let mut outs = \"\";\n+    let mut count = 2;\n+    while count > 0 {\n+        let stream = comm::recv(p);\n+        alt check stream {\n+            (1, s) {\n+                outs = s;\n+            }\n+            (2, s) {\n+                errs = s;\n+            }\n+        };\n+        count -= 1;\n+    };\n+    ret {status: status, out: outs, err: errs};\n+}\n+\n+fn writeclose(fd: c_int, s: str) {\n+    import io::writer_util;\n+\n+    #error(\"writeclose %d, %s\", fd as int, s);\n+    let writer = io::fd_writer(fd, false);\n+    writer.write_str(s);\n+\n+    os::close(fd);\n+}\n+\n+fn readclose(fd: c_int) -> str {\n+    let file = os::fdopen(fd);\n+    let reader = io::FILE_reader(file, false);\n+    let mut buf = \"\";\n+    while !reader.eof() {\n+        let bytes = reader.read_bytes(4096u);\n+        buf += str::from_bytes(bytes);\n+    }\n+    os::fclose(file);\n+    ret buf;\n }\n \n #[doc =\"Waits for a process to exit and returns the exit code\"]\n@@ -351,27 +418,6 @@ mod tests {\n         log(debug, expected);\n         log(debug, actual);\n         assert (expected == actual);\n-\n-        fn writeclose(fd: c_int, s: str) {\n-            #error(\"writeclose %d, %s\", fd as int, s);\n-            let writer = io::fd_writer(fd, false);\n-            writer.write_str(s);\n-\n-            os::close(fd);\n-        }\n-\n-        fn readclose(fd: c_int) -> str {\n-            // Copied from run::program_output\n-            let file = os::fdopen(fd);\n-            let reader = io::FILE_reader(file, false);\n-            let mut buf = \"\";\n-            while !reader.eof() {\n-                let bytes = reader.read_bytes(4096u);\n-                buf += str::from_bytes(bytes);\n-            }\n-            os::fclose(file);\n-            ret buf;\n-        }\n     }\n \n     #[test]"}]}