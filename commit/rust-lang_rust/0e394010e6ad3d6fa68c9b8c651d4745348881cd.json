{"sha": "0e394010e6ad3d6fa68c9b8c651d4745348881cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlMzk0MDEwZTZhZDNkNmZhNjhjOWI4YzY1MWQ0NzQ1MzQ4ODgxY2Q=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2018-02-13T23:58:14Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2018-02-20T07:28:33Z"}, "message": "core::iter::Flatten: update FlatMap & Flatten according to discussion", "tree": {"sha": "cf7d74301f4cc8fb16e50d7a8257abcf0c0f469f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf7d74301f4cc8fb16e50d7a8257abcf0c0f469f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e394010e6ad3d6fa68c9b8c651d4745348881cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e394010e6ad3d6fa68c9b8c651d4745348881cd", "html_url": "https://github.com/rust-lang/rust/commit/0e394010e6ad3d6fa68c9b8c651d4745348881cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e394010e6ad3d6fa68c9b8c651d4745348881cd/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36be763d0e5b0e6ceb7cbf55097427a269caec1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/36be763d0e5b0e6ceb7cbf55097427a269caec1a", "html_url": "https://github.com/rust-lang/rust/commit/36be763d0e5b0e6ceb7cbf55097427a269caec1a"}], "stats": {"total": 314, "additions": 294, "deletions": 20}, "files": [{"sha": "879696ba8e7937fdeb5a88a14031fc4d47682186", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=0e394010e6ad3d6fa68c9b8c651d4745348881cd", "patch": "@@ -12,7 +12,8 @@ use cmp::Ordering;\n use ops::Try;\n \n use super::{AlwaysOk, LoopState};\n-use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Flatten, FlatMap, Fuse};\n+use super::{Chain, Cycle, Cloned, Enumerate, Filter, FilterMap, Fuse};\n+use super::{Flatten, FlatMap, flatten_compat};\n use super::{Inspect, Map, Peekable, Scan, Skip, SkipWhile, StepBy, Take, TakeWhile, Rev};\n use super::{Zip, Sum, Product};\n use super::{ChainState, FromIterator, ZipImpl};\n@@ -997,8 +998,8 @@ pub trait Iterator {\n     /// an extra layer of indirection. `flat_map()` will remove this extra layer\n     /// on its own.\n     ///\n-    /// You can think of [`flat_map(f)`][flat_map] as the equivalent of\n-    /// [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.\n+    /// You can think of [`flat_map(f)`][flat_map] as the semantic equivalent\n+    /// of [`map`]ping, and then [`flatten`]ing as in `map(f).flatten()`.\n     ///\n     /// Another way of thinking about `flat_map()`: [`map`]'s closure returns\n     /// one item for each element, and `flat_map()`'s closure returns an\n@@ -1025,7 +1026,7 @@ pub trait Iterator {\n     fn flat_map<U, F>(self, f: F) -> FlatMap<Self, U, F>\n         where Self: Sized, U: IntoIterator, F: FnMut(Self::Item) -> U,\n     {\n-        self.map(f).flatten()\n+        FlatMap { inner: flatten_compat(self.map(f)) }\n     }\n \n     /// Creates an iterator that flattens nested structure.\n@@ -1060,11 +1061,24 @@ pub trait Iterator {\n     ///                           .collect();\n     /// assert_eq!(merged, \"alphabetagamma\");\n     /// ```\n+    ///\n+    /// You can also rewrite this in terms of [`flat_map()`] which is preferable\n+    /// in this case since that conveys intent clearer:\n+    ///\n+    /// ```\n+    /// let words = [\"alpha\", \"beta\", \"gamma\"];\n+    ///\n+    /// // chars() returns an iterator\n+    /// let merged: String = words.iter()\n+    ///                           .flat_map(|s| s.chars())\n+    ///                           .collect();\n+    /// assert_eq!(merged, \"alphabetagamma\");\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n-    fn flatten(self) -> Flatten<Self, <Self::Item as IntoIterator>::IntoIter>\n+    fn flatten(self) -> Flatten<Self>\n     where Self: Sized, Self::Item: IntoIterator {\n-        Flatten { iter: self, frontiter: None, backiter: None }\n+        Flatten { inner: flatten_compat(self) }\n     }\n \n     /// Creates an iterator which ends after the first [`None`]."}, {"sha": "e498f7d1b93c5d2cc4e5ec69988fde269205961c", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 166, "deletions": 12, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=0e394010e6ad3d6fa68c9b8c651d4745348881cd", "patch": "@@ -2403,14 +2403,87 @@ impl<B, I, St, F> Iterator for Scan<I, St, F> where\n /// An iterator that maps each element to an iterator, and yields the elements\n /// of the produced iterators.\n ///\n-/// This `type` is created by the [`flat_map`] method on [`Iterator`]. See its\n+/// This `struct` is created by the [`flat_map`] method on [`Iterator`]. See its\n /// documentation for more.\n ///\n /// [`flat_map`]: trait.Iterator.html#method.flat_map\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-type FlatMap<I, U, F> = Flatten<Map<I, F>, <U as IntoIterator>::IntoIter>;\n+pub struct FlatMap<I, U: IntoIterator, F> {\n+    inner: FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Clone, U: Clone + IntoIterator, F: Clone> Clone for FlatMap<I, U, F>\n+    where <U as IntoIterator>::IntoIter: Clone\n+{\n+    fn clone(&self) -> Self { FlatMap { inner: self.inner.clone() } }\n+}\n+\n+#[stable(feature = \"core_impl_debug\", since = \"1.9.0\")]\n+impl<I: fmt::Debug, U: IntoIterator, F> fmt::Debug for FlatMap<I, U, F>\n+    where U::IntoIter: fmt::Debug\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"FlatMap\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator, U: IntoIterator, F> Iterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: DoubleEndedIterator, U, F> DoubleEndedIterator for FlatMap<I, U, F>\n+    where F: FnMut(I::Item) -> U,\n+          U: IntoIterator,\n+          U::IntoIter: DoubleEndedIterator\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<I, U, F> FusedIterator for FlatMap<I, U, F>\n+    where I: FusedIterator, U: IntoIterator, F: FnMut(I::Item) -> U {}\n \n /// An iterator that flattens one level of nesting in an iterator of things\n /// that can be turned into iterators.\n@@ -2422,16 +2495,102 @@ type FlatMap<I, U, F> = Flatten<Map<I, F>, <U as IntoIterator>::IntoIter>;\n /// [`Iterator`]: trait.Iterator.html\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n+pub struct Flatten<I: Iterator>\n+where I::Item: IntoIterator {\n+    inner: FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>,\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n+impl<I, U> fmt::Debug for Flatten<I>\n+    where I: Iterator + fmt::Debug, U: Iterator + fmt::Debug,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Flatten\").field(\"inner\", &self.inner).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n+impl<I, U> Clone for Flatten<I>\n+    where I: Iterator + Clone, U: Iterator + Clone,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>,\n+{\n+    fn clone(&self) -> Self { Flatten { inner: self.inner.clone() } }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n+impl<I, U> Iterator for Flatten<I>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    type Item = U::Item;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<U::Item> { self.inner.next() }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+\n+    #[inline]\n+    fn try_fold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_fold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn fold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.fold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n+impl<I, U> DoubleEndedIterator for Flatten<I>\n+    where I: DoubleEndedIterator, U: DoubleEndedIterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<U::Item> { self.inner.next_back() }\n+\n+    #[inline]\n+    fn try_rfold<Acc, Fold, R>(&mut self, init: Acc, fold: Fold) -> R where\n+        Self: Sized, Fold: FnMut(Acc, Self::Item) -> R, R: Try<Ok=Acc>\n+    {\n+        self.inner.try_rfold(init, fold)\n+    }\n+\n+    #[inline]\n+    fn rfold<Acc, Fold>(self, init: Acc, fold: Fold) -> Acc\n+        where Fold: FnMut(Acc, Self::Item) -> Acc,\n+    {\n+        self.inner.rfold(init, fold)\n+    }\n+}\n+\n+#[unstable(feature = \"fused\", issue = \"35602\")]\n+impl<I, U> FusedIterator for Flatten<I>\n+    where I: FusedIterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n+\n+/// Adapts an iterator by flattening it, for use in `flatten()` and `flat_map()`.\n+fn flatten_compat<I, U>(iter: I) -> FlattenCompat<I, U> {\n+    FlattenCompat { iter, frontiter: None, backiter: None }\n+}\n+\n+/// Real logic of both `Flatten` and `FlatMap` which simply delegate to\n+/// this type.\n #[derive(Clone, Debug)]\n-pub struct Flatten<I, U> {\n+struct FlattenCompat<I, U> {\n     iter: I,\n     frontiter: Option<U>,\n     backiter: Option<U>,\n }\n \n-#[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n-impl<I: Iterator, U: Iterator> Iterator for Flatten<I, U>\n-    where I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n+impl<I, U> Iterator for FlattenCompat<I, U>\n+    where I: Iterator, U: Iterator,\n+          I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n {\n     type Item = U::Item;\n \n@@ -2498,8 +2657,7 @@ impl<I: Iterator, U: Iterator> Iterator for Flatten<I, U>\n     }\n }\n \n-#[unstable(feature = \"iterator_flatten\", issue = \"0\")]\n-impl<I, U> DoubleEndedIterator for Flatten<I, U>\n+impl<I, U> DoubleEndedIterator for FlattenCompat<I, U>\n     where I: DoubleEndedIterator, U: DoubleEndedIterator,\n           I::Item: IntoIterator<IntoIter = U, Item = U::Item>\n {\n@@ -2555,10 +2713,6 @@ impl<I, U> DoubleEndedIterator for Flatten<I, U>\n     }\n }\n \n-#[unstable(feature = \"fused\", issue = \"35602\")]\n-impl<I: FusedIterator, U: Iterator> FusedIterator for Flatten<I, U>\n-    where I::Item: IntoIterator<IntoIter = U, Item = U::Item> {}\n-\n /// An iterator that yields `None` forever after the underlying iterator\n /// yields `None` once.\n ///"}, {"sha": "edd75f7795ed7cf18ec33575b142feff40070367", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 106, "deletions": 2, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=0e394010e6ad3d6fa68c9b8c651d4745348881cd", "patch": "@@ -836,8 +836,6 @@ fn test_iterator_scan() {\n     assert_eq!(i, ys.len());\n }\n \n-// Note: We test flatten() by testing flat_map().\n-\n #[test]\n fn test_iterator_flat_map() {\n     let xs = [0, 3, 6];\n@@ -876,6 +874,44 @@ fn test_iterator_flat_map_fold() {\n     assert_eq!(i, 0);\n }\n \n+#[test]\n+fn test_iterator_flatten() {\n+    let xs = [0, 3, 6];\n+    let ys = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n+    let it = xs.iter().map(|&x| (x..).step_by(1).take(3)).flatten();\n+    let mut i = 0;\n+    for x in it {\n+        assert_eq!(x, ys[i]);\n+        i += 1;\n+    }\n+    assert_eq!(i, ys.len());\n+}\n+\n+/// Test `Flatten::fold` with items already picked off the front and back,\n+/// to make sure all parts of the `Flatten` are folded correctly.\n+#[test]\n+fn test_iterator_flatten_fold() {\n+    let xs = [0, 3, 6];\n+    let ys = [1, 2, 3, 4, 5, 6, 7];\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.fold(0, |i, x| {\n+        assert_eq!(x, ys[i]);\n+        i + 1\n+    });\n+    assert_eq!(i, ys.len());\n+\n+    let mut it = xs.iter().map(|&x| x..x+3).flatten();\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.next_back(), Some(8));\n+    let i = it.rfold(ys.len(), |i, x| {\n+        assert_eq!(x, ys[i - 1]);\n+        i - 1\n+    });\n+    assert_eq!(i, 0);\n+}\n+\n #[test]\n fn test_inspect() {\n     let xs = [1, 2, 3, 4];\n@@ -1289,6 +1325,23 @@ fn test_double_ended_flat_map() {\n     assert_eq!(it.next_back(), None);\n }\n \n+#[test]\n+fn test_double_ended_flatten() {\n+    let u = [0,1];\n+    let v = [5,6,7,8];\n+    let mut it = u.iter().map(|x| &v[*x..v.len()]).flatten();\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back().unwrap(), &6);\n+    assert_eq!(it.next_back().unwrap(), &8);\n+    assert_eq!(it.next().unwrap(),      &6);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(),      None);\n+    assert_eq!(it.next_back(), None);\n+}\n+\n #[test]\n fn test_double_ended_range() {\n     assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n@@ -1980,3 +2033,54 @@ fn test_flat_map_try_folds() {\n     assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n     assert_eq!(iter.next_back(), Some(35));\n }\n+\n+#[test]\n+fn test_flatten_try_folds() {\n+    let f = &|acc, x| i32::checked_add(acc*2/3, x);\n+    let mr = &|x| (5*x)..(5*x + 5);\n+    assert_eq!((0..10).map(mr).flatten().try_fold(7, f), (0..50).try_fold(7, f));\n+    assert_eq!((0..10).map(mr).flatten().try_rfold(7, f), (0..50).try_rfold(7, f));\n+    let mut iter = (0..10).map(mr).flatten();\n+    iter.next(); iter.next_back(); // have front and back iters in progress\n+    assert_eq!(iter.try_rfold(7, f), (1..49).try_rfold(7, f));\n+\n+    let mut iter = (0..10).map(|x| (4*x)..(4*x + 4)).flatten();\n+    assert_eq!(iter.try_fold(0, i8::checked_add), None);\n+    assert_eq!(iter.next(), Some(17));\n+    assert_eq!(iter.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(iter.next_back(), Some(35));\n+}\n+\n+#[test]\n+fn test_functor_laws() {\n+    // identity:\n+    fn identity<T>(x: T) -> T { x }\n+    assert_eq!((0..10).map(identity).sum::<usize>(), (0..10).sum());\n+\n+    // composition:\n+    fn f(x: usize) -> usize { x + 3 }\n+    fn g(x: usize) -> usize { x * 2 }\n+    fn h(x: usize) -> usize { g(f(x)) }\n+    assert_eq!((0..10).map(f).map(g).sum::<usize>(), (0..10).map(h).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_left_identity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> {\n+        (0..10).map(move |y| x * y)\n+    }\n+    assert_eq!(once(42).flat_map(f.clone()).sum::<usize>(), f(42).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_right_identity() {\n+    assert_eq!((0..10).flat_map(|x| once(x)).sum::<usize>(), (0..10).sum());\n+}\n+\n+#[test]\n+fn test_monad_laws_associativity() {\n+    fn f(x: usize) -> impl Iterator<Item = usize> { 0..x }\n+    fn g(x: usize) -> impl Iterator<Item = usize> { (0..x).rev() }\n+    assert_eq!((0..10).flat_map(f).flat_map(g).sum::<usize>(),\n+                (0..10).flat_map(|x| f(x).flat_map(g)).sum::<usize>());\n+}"}, {"sha": "7954d52f6b1e368f64b4a309fe08b4baea5f6d15", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e394010e6ad3d6fa68c9b8c651d4745348881cd/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=0e394010e6ad3d6fa68c9b8c651d4745348881cd", "patch": "@@ -25,6 +25,8 @@\n #![feature(inclusive_range)]\n #![feature(inclusive_range_syntax)]\n #![feature(iterator_try_fold)]\n+#![feature(iterator_flatten)]\n+#![feature(conservative_impl_trait)]\n #![feature(iter_rfind)]\n #![feature(iter_rfold)]\n #![feature(iterator_repeat_with)]"}]}