{"sha": "ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNWIyZTljOWJlM2MwY2Q5MGJlZDRkNjc1ZmIwOWRjNmFhMTc4OWE=", "commit": {"author": {"name": "Ruben Schmidmeister", "email": "ruben.schmidmeister@icloud.com", "date": "2019-04-24T17:40:21Z"}, "committer": {"name": "Ruben Schmidmeister", "email": "ruben.schmidmeister@icloud.com", "date": "2019-04-24T19:01:09Z"}, "message": "Extract applying of newline style into own mod", "tree": {"sha": "f7d825367676368e834910de555f97e55e4cec78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7d825367676368e834910de555f97e55e4cec78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEEU0FXzFYkrmfOhhqxKTh7Wnqvhj8FAlzAsnUACgkQKTh7Wnqv\nhj/JqQgAkAg6+a2YeXou7mjXWIHKQP2QiLjtksb0jHhA5kSxw9zGhmMkj9Y4C2MM\ne1o5CXd1szJD8kCKkXLC74PSeJXTOzCNdJEtStnqLVhZoaSmSuvV6nl7w7Lcw1CA\nmqatAGbbGh7uiEccJ3OyvpcCdpoQDLpno9JgrnDX4X7o8KniskK/wmJb1A0fj+wc\nXq6DgJ8jStaw7JNLqPUqyKLOXMP4IPNTz5ybjKBZXhEE+y34Q3AAk8o7UGzIjfL/\nMAGA6VFwE0TtWGydCSa4o8ud/0aSMd2hhvgAXUIfi+EiL6nPlfWQD2GMHgNQL8LG\nitxAutPuU+RlrfmKDMsBsl9h2vaclw==\n=T4g2\n-----END PGP SIGNATURE-----", "payload": "tree f7d825367676368e834910de555f97e55e4cec78\nparent 5274b49caa1a7db6ac10c76bf1a3d5710ccef569\nauthor Ruben Schmidmeister <ruben.schmidmeister@icloud.com> 1556127621 +0200\ncommitter Ruben Schmidmeister <ruben.schmidmeister@icloud.com> 1556132469 +0200\n\nExtract applying of newline style into own mod\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "html_url": "https://github.com/rust-lang/rust/commit/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/comments", "author": {"login": "bash", "id": 4602612, "node_id": "MDQ6VXNlcjQ2MDI2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/4602612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bash", "html_url": "https://github.com/bash", "followers_url": "https://api.github.com/users/bash/followers", "following_url": "https://api.github.com/users/bash/following{/other_user}", "gists_url": "https://api.github.com/users/bash/gists{/gist_id}", "starred_url": "https://api.github.com/users/bash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bash/subscriptions", "organizations_url": "https://api.github.com/users/bash/orgs", "repos_url": "https://api.github.com/users/bash/repos", "events_url": "https://api.github.com/users/bash/events{/privacy}", "received_events_url": "https://api.github.com/users/bash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bash", "id": 4602612, "node_id": "MDQ6VXNlcjQ2MDI2MTI=", "avatar_url": "https://avatars.githubusercontent.com/u/4602612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bash", "html_url": "https://github.com/bash", "followers_url": "https://api.github.com/users/bash/followers", "following_url": "https://api.github.com/users/bash/following{/other_user}", "gists_url": "https://api.github.com/users/bash/gists{/gist_id}", "starred_url": "https://api.github.com/users/bash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bash/subscriptions", "organizations_url": "https://api.github.com/users/bash/orgs", "repos_url": "https://api.github.com/users/bash/repos", "events_url": "https://api.github.com/users/bash/events{/privacy}", "received_events_url": "https://api.github.com/users/bash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5274b49caa1a7db6ac10c76bf1a3d5710ccef569", "url": "https://api.github.com/repos/rust-lang/rust/commits/5274b49caa1a7db6ac10c76bf1a3d5710ccef569", "html_url": "https://github.com/rust-lang/rust/commit/5274b49caa1a7db6ac10c76bf1a3d5710ccef569"}], "stats": {"total": 232, "additions": 120, "deletions": 112}, "files": [{"sha": "dc5d0a47a33e142d35fbe8c2722c52a985bfce88", "filename": "src/config/options.rs", "status": "modified", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "patch": "@@ -132,62 +132,6 @@ configuration_option_enum! { NewlineStyle:\n     Native, // \\r\\n in Windows, \\n on other platforms\n }\n \n-impl NewlineStyle {\n-    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n-        if let Some(pos) = raw_input_text.find('\\n') {\n-            let pos = pos.saturating_sub(1);\n-            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n-                NewlineStyle::Windows\n-            } else {\n-                NewlineStyle::Unix\n-            }\n-        } else {\n-            NewlineStyle::Native\n-        }\n-    }\n-\n-    fn native() -> NewlineStyle {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n-        } else {\n-            NewlineStyle::Unix\n-        }\n-    }\n-\n-    /// Apply this newline style to the formatted text. When the style is set\n-    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n-    /// endings.\n-    ///\n-    /// If the style is set to `Auto` and `raw_input_text` contains no\n-    /// newlines, the `Native` style will be used.\n-    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n-        use crate::NewlineStyle::*;\n-        let mut style = self;\n-        if style == Auto {\n-            style = Self::auto_detect(raw_input_text);\n-        }\n-        if style == Native {\n-            style = Self::native();\n-        }\n-        match style {\n-            Windows => {\n-                let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n-                for c in formatted_text.chars() {\n-                    match c {\n-                        '\\n' => transformed.push_str(\"\\r\\n\"),\n-                        '\\r' => continue,\n-                        c => transformed.push(c),\n-                    }\n-                }\n-                *formatted_text = transformed;\n-            }\n-            Unix => return,\n-            Native => unreachable!(\"NewlineStyle::Native\"),\n-            Auto => unreachable!(\"NewlineStyle::Auto\"),\n-        }\n-    }\n-}\n-\n configuration_option_enum! { BraceStyle:\n     AlwaysNextLine,\n     PreferSameLine,\n@@ -493,59 +437,3 @@ impl Edition {\n         }\n     }\n }\n-\n-#[test]\n-fn test_newline_style_auto_detect() {\n-    let lf = \"One\\nTwo\\nThree\";\n-    let crlf = \"One\\r\\nTwo\\r\\nThree\";\n-    let none = \"One Two Three\";\n-\n-    assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n-    assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n-    assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n-}\n-\n-#[test]\n-fn test_newline_style_auto_apply() {\n-    let auto = NewlineStyle::Auto;\n-\n-    let formatted_text = \"One\\nTwo\\nThree\";\n-    let raw_input_text = \"One\\nTwo\\nThree\";\n-\n-    let mut out = String::from(formatted_text);\n-    auto.apply(&mut out, raw_input_text);\n-    assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n-\n-    let formatted_text = \"One\\nTwo\\nThree\";\n-    let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n-\n-    let mut out = String::from(formatted_text);\n-    auto.apply(&mut out, raw_input_text);\n-    assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n-\n-    #[cfg(not(windows))]\n-    {\n-        let formatted_text = \"One\\nTwo\\nThree\";\n-        let raw_input_text = \"One Two Three\";\n-\n-        let mut out = String::from(formatted_text);\n-        auto.apply(&mut out, raw_input_text);\n-        assert_eq!(\n-            \"One\\nTwo\\nThree\", &out,\n-            \"auto-native-unix should detect 'lf'\"\n-        );\n-    }\n-\n-    #[cfg(windows)]\n-    {\n-        let formatted_text = \"One\\nTwo\\nThree\";\n-        let raw_input_text = \"One Two Three\";\n-\n-        let mut out = String::from(formatted_text);\n-        auto.apply(&mut out, raw_input_text);\n-        assert_eq!(\n-            \"One\\r\\nTwo\\r\\nThree\", &out,\n-            \"auto-native-windows should detect 'crlf'\"\n-        );\n-    }\n-}"}, {"sha": "e4875d7df4ca71079e4088648f13f2916cfdea52", "filename": "src/formatting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "patch": "@@ -20,6 +20,8 @@ use crate::utils::{count_newlines, get_skip_macro_names};\n use crate::visitor::{FmtVisitor, SnippetProvider};\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n+mod newline_style;\n+\n // A map of the files of a crate, with their new content\n pub(crate) type SourceFile = Vec<FileRecord>;\n pub(crate) type FileRecord = (FileName, String);"}, {"sha": "3cf66f83ed61c4190c25b948a753a904924839d7", "filename": "src/formatting/newline_style.rs", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/src%2Fformatting%2Fnewline_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a/src%2Fformatting%2Fnewline_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting%2Fnewline_style.rs?ref=ba5b2e9c9be3c0cd90bed4d675fb09dc6aa1789a", "patch": "@@ -0,0 +1,118 @@\n+use crate::NewlineStyle;\n+\n+impl NewlineStyle {\n+    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n+        if let Some(pos) = raw_input_text.find('\\n') {\n+            let pos = pos.saturating_sub(1);\n+            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n+                NewlineStyle::Windows\n+            } else {\n+                NewlineStyle::Unix\n+            }\n+        } else {\n+            NewlineStyle::Native\n+        }\n+    }\n+\n+    fn native() -> NewlineStyle {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    }\n+\n+    /// Apply this newline style to the formatted text. When the style is set\n+    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n+    /// endings.\n+    ///\n+    /// If the style is set to `Auto` and `raw_input_text` contains no\n+    /// newlines, the `Native` style will be used.\n+    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n+        use crate::NewlineStyle::*;\n+        let mut style = self;\n+        if style == Auto {\n+            style = Self::auto_detect(raw_input_text);\n+        }\n+        if style == Native {\n+            style = Self::native();\n+        }\n+        match style {\n+            Windows => {\n+                let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n+                for c in formatted_text.chars() {\n+                    match c {\n+                        '\\n' => transformed.push_str(\"\\r\\n\"),\n+                        '\\r' => continue,\n+                        c => transformed.push(c),\n+                    }\n+                }\n+                *formatted_text = transformed;\n+            }\n+            Unix => return,\n+            Native => unreachable!(\"NewlineStyle::Native\"),\n+            Auto => unreachable!(\"NewlineStyle::Auto\"),\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_newline_style_auto_detect() {\n+        let lf = \"One\\nTwo\\nThree\";\n+        let crlf = \"One\\r\\nTwo\\r\\nThree\";\n+        let none = \"One Two Three\";\n+\n+        assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n+        assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n+        assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n+    }\n+\n+    #[test]\n+    fn test_newline_style_auto_apply() {\n+        let auto = NewlineStyle::Auto;\n+\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One\\nTwo\\nThree\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n+\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n+\n+        #[cfg(not(windows))]\n+        {\n+            let formatted_text = \"One\\nTwo\\nThree\";\n+            let raw_input_text = \"One Two Three\";\n+\n+            let mut out = String::from(formatted_text);\n+            auto.apply(&mut out, raw_input_text);\n+            assert_eq!(\n+                \"One\\nTwo\\nThree\", &out,\n+                \"auto-native-unix should detect 'lf'\"\n+            );\n+        }\n+\n+        #[cfg(windows)]\n+        {\n+            let formatted_text = \"One\\nTwo\\nThree\";\n+            let raw_input_text = \"One Two Three\";\n+\n+            let mut out = String::from(formatted_text);\n+            auto.apply(&mut out, raw_input_text);\n+            assert_eq!(\n+                \"One\\r\\nTwo\\r\\nThree\", &out,\n+                \"auto-native-windows should detect 'crlf'\"\n+            );\n+        }\n+    }\n+}"}]}