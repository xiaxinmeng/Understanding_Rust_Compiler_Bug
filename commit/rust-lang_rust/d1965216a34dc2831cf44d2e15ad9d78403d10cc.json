{"sha": "d1965216a34dc2831cf44d2e15ad9d78403d10cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxOTY1MjE2YTM0ZGMyODMxY2Y0NGQyZTE1YWQ5ZDc4NDAzZDEwY2M=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-01-30T20:28:16Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-02T21:46:29Z"}, "message": "Improve needs_drop query\n\n* Handle cycles in `needs_drop` correctly\n* Normalize types when computing `needs_drop`\n* Move queries from rustc to rustc_ty", "tree": {"sha": "cc42a2fe1c5bec2050372663f468291f5a4996f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc42a2fe1c5bec2050372663f468291f5a4996f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1965216a34dc2831cf44d2e15ad9d78403d10cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1965216a34dc2831cf44d2e15ad9d78403d10cc", "html_url": "https://github.com/rust-lang/rust/commit/d1965216a34dc2831cf44d2e15ad9d78403d10cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1965216a34dc2831cf44d2e15ad9d78403d10cc/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39733223fc817efba52a4204dd697192bf5da185", "url": "https://api.github.com/repos/rust-lang/rust/commits/39733223fc817efba52a4204dd697192bf5da185", "html_url": "https://github.com/rust-lang/rust/commit/39733223fc817efba52a4204dd697192bf5da185"}], "stats": {"total": 457, "additions": 304, "deletions": 153}, "files": [{"sha": "c705956f4540ab88f559467d4b5ae7e91f89e579", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -651,26 +651,27 @@ rustc_queries! {\n             no_force\n             desc { \"computing whether `{}` is `Copy`\", env.value }\n         }\n+        /// Query backing `TyS::is_sized`.\n         query is_sized_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` is `Sized`\", env.value }\n         }\n+        /// Query backing `TyS::is_freeze`.\n         query is_freeze_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` is freeze\", env.value }\n         }\n-\n-        // The cycle error here should be reported as an error by `check_representable`.\n-        // We consider the type as not needing drop in the meanwhile to avoid\n-        // further errors (done in impl Value for NeedsDrop).\n-        // Use `cycle_delay_bug` to delay the cycle error here to be emitted later\n-        // in case we accidentally otherwise don't emit an error.\n-        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-            cycle_delay_bug\n+        /// Query backing `TyS::needs_drop`.\n+        query needs_drop_raw(env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n             no_force\n             desc { \"computing whether `{}` needs drop\", env.value }\n         }\n \n+        /// A list of types where the ADT requires drop if and only if any of\n+        /// those types require drop. If the ADT is known to always need drop\n+        /// then `Err(AlwaysRequiresDrop)` is returned.\n+        query adt_drop_tys(_: DefId) -> Result<&'tcx ty::List<Ty<'tcx>>, AlwaysRequiresDrop> {}\n+\n         query layout_raw(\n             env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n         ) -> Result<&'tcx ty::layout::LayoutDetails, ty::layout::LayoutError<'tcx>> {"}, {"sha": "3fd0d12c626aa9de6132e1ed26d8473f815395c9", "filename": "src/librustc/traits/misc.rs", "status": "modified", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmisc.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -1,12 +1,9 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::middle::lang_items;\n use crate::traits::{self, ObligationCause};\n-use crate::ty::util::NeedsDrop;\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc_hir as hir;\n-use rustc_span::DUMMY_SP;\n \n #[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {\n@@ -71,132 +68,3 @@ pub fn can_type_implement_copy(\n         Ok(())\n     })\n }\n-\n-fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n-}\n-\n-fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n-}\n-\n-fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n-    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n-}\n-\n-fn is_item_raw<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    item: lang_items::LangItem,\n-) -> bool {\n-    let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(item, None);\n-    tcx.infer_ctxt().enter(|infcx| {\n-        traits::type_known_to_meet_bound_modulo_regions(\n-            &infcx,\n-            param_env,\n-            ty,\n-            trait_def_id,\n-            DUMMY_SP,\n-        )\n-    })\n-}\n-\n-fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> NeedsDrop {\n-    let (param_env, ty) = query.into_parts();\n-\n-    let needs_drop = |ty: Ty<'tcx>| -> bool { tcx.needs_drop_raw(param_env.and(ty)).0 };\n-\n-    assert!(!ty.needs_infer());\n-\n-    NeedsDrop(match ty.kind {\n-        // Fast-path for primitive types\n-        ty::Infer(ty::FreshIntTy(_))\n-        | ty::Infer(ty::FreshFloatTy(_))\n-        | ty::Bool\n-        | ty::Int(_)\n-        | ty::Uint(_)\n-        | ty::Float(_)\n-        | ty::Never\n-        | ty::FnDef(..)\n-        | ty::FnPtr(_)\n-        | ty::Char\n-        | ty::GeneratorWitness(..)\n-        | ty::RawPtr(_)\n-        | ty::Ref(..)\n-        | ty::Str => false,\n-\n-        // Foreign types can never have destructors\n-        ty::Foreign(..) => false,\n-\n-        // `ManuallyDrop` doesn't have a destructor regardless of field types.\n-        ty::Adt(def, _) if Some(def.did) == tcx.lang_items().manually_drop() => false,\n-\n-        // Issue #22536: We first query `is_copy_modulo_regions`.  It sees a\n-        // normalized version of the type, and therefore will definitely\n-        // know whether the type implements Copy (and thus needs no\n-        // cleanup/drop/zeroing) ...\n-        _ if ty.is_copy_modulo_regions(tcx, param_env, DUMMY_SP) => false,\n-\n-        // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking for the structural \"may drop\".\n-\n-        // FIXME(#22815): Note that this is a conservative heuristic;\n-        // it may report that the type \"may drop\" when actual type does\n-        // not actually have a destructor associated with it. But since\n-        // the type absolutely did not have the `Copy` bound attached\n-        // (see above), it is sound to treat it as having a destructor.\n-\n-        // User destructors are the only way to have concrete drop types.\n-        ty::Adt(def, _) if def.has_dtor(tcx) => true,\n-\n-        // Can refer to a type which may drop.\n-        // FIXME(eddyb) check this against a ParamEnv.\n-        ty::Dynamic(..)\n-        | ty::Projection(..)\n-        | ty::Param(_)\n-        | ty::Bound(..)\n-        | ty::Placeholder(..)\n-        | ty::Opaque(..)\n-        | ty::Infer(_)\n-        | ty::Error => true,\n-\n-        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-\n-        // Zero-length arrays never contain anything to drop.\n-        ty::Array(_, len) if len.try_eval_usize(tcx, param_env) == Some(0) => false,\n-\n-        // Structural recursion.\n-        ty::Array(ty, _) | ty::Slice(ty) => needs_drop(ty),\n-\n-        ty::Closure(def_id, ref substs) => {\n-            substs.as_closure().upvar_tys(def_id, tcx).any(needs_drop)\n-        }\n-\n-        // Pessimistically assume that all generators will require destructors\n-        // as we don't know if a destructor is a noop or not until after the MIR\n-        // state transformation pass\n-        ty::Generator(..) => true,\n-\n-        ty::Tuple(..) => ty.tuple_fields().any(needs_drop),\n-\n-        // unions don't have destructors because of the child types,\n-        // only if they manually implement `Drop` (handled above).\n-        ty::Adt(def, _) if def.is_union() => false,\n-\n-        ty::Adt(def, substs) => def\n-            .variants\n-            .iter()\n-            .any(|variant| variant.fields.iter().any(|field| needs_drop(field.ty(tcx, substs)))),\n-    })\n-}\n-\n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    *providers = ty::query::Providers {\n-        is_copy_raw,\n-        is_sized_raw,\n-        is_freeze_raw,\n-        needs_drop_raw,\n-        ..*providers\n-    };\n-}"}, {"sha": "f6c939c1ce5a238cd02fc7aaf3feb4678b89950d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -1255,7 +1255,6 @@ impl<'tcx> TraitObligation<'tcx> {\n }\n \n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    misc::provide(providers);\n     *providers = ty::query::Providers {\n         is_object_safe: object_safety::is_object_safe_provider,\n         specialization_graph_of: specialize::specialization_graph_provider,"}, {"sha": "4126b161a821b9f7169dac2e53844659a02f32ea", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -33,7 +33,7 @@ use crate::traits::Clauses;\n use crate::traits::{self, Vtable};\n use crate::ty::steal::Steal;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::util::NeedsDrop;\n+use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use crate::util::common::ErrorReported;\n use rustc_data_structures::fingerprint::Fingerprint;"}, {"sha": "b01d15c29b2db7612ec265c9529941a222a5f932", "filename": "src/librustc/ty/query/values.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fvalues.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -1,4 +1,3 @@\n-use crate::ty::util::NeedsDrop;\n use crate::ty::{self, AdtSizedConstraint, Ty, TyCtxt};\n \n use rustc_span::symbol::Symbol;\n@@ -26,12 +25,6 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n     }\n }\n \n-impl<'tcx> Value<'tcx> for NeedsDrop {\n-    fn from_cycle_error(_: TyCtxt<'tcx>) -> Self {\n-        NeedsDrop(false)\n-    }\n-}\n-\n impl<'tcx> Value<'tcx> for AdtSizedConstraint<'tcx> {\n     fn from_cycle_error(tcx: TyCtxt<'tcx>) -> Self {\n         AdtSizedConstraint(tcx.intern_type_list(&[tcx.types.err]))"}, {"sha": "eaa7a43b091747a7f8b6f675c08e051dd5f62bba", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 77, "deletions": 4, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -18,6 +18,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_macros::HashStable;\n use rustc_span::Span;\n+use smallvec::SmallVec;\n use std::{cmp, fmt};\n use syntax::ast;\n \n@@ -724,7 +725,23 @@ impl<'tcx> ty::TyS<'tcx> {\n     /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        tcx.needs_drop_raw(param_env.and(self)).0\n+        // Avoid querying in simple cases.\n+        match needs_drop_components(self) {\n+            Err(AlwaysRequiresDrop) => true,\n+            Ok(components) => {\n+                let query_ty = match *components {\n+                    [] => return false,\n+                    // If we've got a single component, call the query with that\n+                    // to increase the chance that we hit the query cache.\n+                    [component_ty] => component_ty,\n+                    _ => self,\n+                };\n+                // This doesn't depend on regions, so try to minimize distinct.\n+                // query keys used.\n+                let erased = tcx.normalize_erasing_regions(param_env, query_ty);\n+                tcx.needs_drop_raw(param_env.and(erased))\n+            }\n+        }\n     }\n \n     pub fn same_type(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n@@ -923,9 +940,6 @@ impl<'tcx> ty::TyS<'tcx> {\n     }\n }\n \n-#[derive(Clone, HashStable)]\n-pub struct NeedsDrop(pub bool);\n-\n pub enum ExplicitSelf<'tcx> {\n     ByValue,\n     ByReference(ty::Region<'tcx>, hir::Mutability),\n@@ -974,3 +988,62 @@ impl<'tcx> ExplicitSelf<'tcx> {\n         }\n     }\n }\n+\n+/// Returns a list of types such that the given type needs drop if and only if\n+/// *any* of the returned types need drop. Returns `Err(AlwaysRequiresDrop)` if\n+/// this type always needs drop.\n+pub fn needs_drop_components(ty: Ty<'tcx>) -> Result<SmallVec<[Ty<'tcx>; 4]>, AlwaysRequiresDrop> {\n+    match ty.kind {\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str => Ok(SmallVec::new()),\n+\n+        // Foreign types can never have destructors\n+        ty::Foreign(..) => Ok(SmallVec::new()),\n+\n+        // Pessimistically assume that all generators will require destructors\n+        // as we don't know if a destructor is a noop or not until after the MIR\n+        // state transformation pass\n+        ty::Generator(..) | ty::Dynamic(..) | ty::Error => Err(AlwaysRequiresDrop),\n+\n+        ty::Slice(ty) => needs_drop_components(ty),\n+        ty::Array(elem_ty, ..) => {\n+            match needs_drop_components(elem_ty) {\n+                Ok(v) if v.is_empty() => Ok(v),\n+                // Arrays of size zero don't need drop, even if their element\n+                // type does.\n+                _ => Ok(smallvec![ty]),\n+            }\n+        }\n+        // If any field needs drop, then the whole tuple does.\n+        ty::Tuple(..) => ty.tuple_fields().try_fold(SmallVec::new(), |mut acc, elem| {\n+            acc.extend(needs_drop_components(elem)?);\n+            Ok(acc)\n+        }),\n+\n+        // These require checking for `Copy` bounds or `Adt` destructors.\n+        ty::Adt(..)\n+        | ty::Projection(..)\n+        | ty::UnnormalizedProjection(..)\n+        | ty::Param(_)\n+        | ty::Bound(..)\n+        | ty::Placeholder(..)\n+        | ty::Opaque(..)\n+        | ty::Infer(_)\n+        | ty::Closure(..) => Ok(smallvec![ty]),\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub struct AlwaysRequiresDrop;"}, {"sha": "9fe8a19311fb67e58a0ce2718048d4aae16608be", "filename": "src/librustc_ty/common_traits.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc_ty%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc_ty%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fcommon_traits.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -0,0 +1,40 @@\n+//! Queries for checking whether a type implements one of a few common traits.\n+\n+use rustc::middle::lang_items;\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_span::DUMMY_SP;\n+\n+fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::CopyTraitLangItem)\n+}\n+\n+fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::SizedTraitLangItem)\n+}\n+\n+fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    is_item_raw(tcx, query, lang_items::FreezeTraitLangItem)\n+}\n+\n+fn is_item_raw<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    item: lang_items::LangItem,\n+) -> bool {\n+    let (param_env, ty) = query.into_parts();\n+    let trait_def_id = tcx.require_lang_item(item, None);\n+    tcx.infer_ctxt().enter(|infcx| {\n+        traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        )\n+    })\n+}\n+\n+pub(crate) fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers { is_copy_raw, is_sized_raw, is_freeze_raw, ..*providers };\n+}"}, {"sha": "7eef19b94e40129fa2549ae4f4dacdd7c390a273", "filename": "src/librustc_ty/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc_ty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc_ty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Flib.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -16,8 +16,12 @@ extern crate log;\n \n use rustc::ty::query::Providers;\n \n+mod common_traits;\n+mod needs_drop;\n mod ty;\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    common_traits::provide(providers);\n+    needs_drop::provide(providers);\n     ty::provide(providers);\n }"}, {"sha": "1a65acb1f984b34c4ae3c37dbde76cd0e6137a11", "filename": "src/librustc_ty/needs_drop.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc_ty%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Flibrustc_ty%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fneeds_drop.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -0,0 +1,171 @@\n+//! Check whether a type has (potentially) non-trivial drop glue.\n+\n+use rustc::ty::subst::Subst;\n+use rustc::ty::util::{needs_drop_components, AlwaysRequiresDrop};\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::DUMMY_SP;\n+\n+type NeedsDropResult<T> = Result<T, AlwaysRequiresDrop>;\n+\n+fn needs_drop_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n+    let adt_fields =\n+        move |adt_def: &ty::AdtDef| tcx.adt_drop_tys(adt_def.did).map(|tys| tys.iter().copied());\n+    // If we don't know a type doesn't need drop, say it's a type parameter\n+    // without a `Copy` bound, then we conservatively return that it needs\n+    // drop.\n+    let res = NeedsDropTypes::new(tcx, query.param_env, query.value, adt_fields).next().is_some();\n+    debug!(\"needs_drop_raw({:?}) = {:?}\", query, res);\n+    res\n+}\n+\n+struct NeedsDropTypes<'tcx, F> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    query_ty: Ty<'tcx>,\n+    seen_tys: FxHashSet<Ty<'tcx>>,\n+    /// A stack of types left to process. Each round, we pop something from the\n+    /// stack and check if it needs drop. If the result depends on whether some\n+    /// other types need drop we push them onto the stack.\n+    unchecked_tys: Vec<(Ty<'tcx>, usize)>,\n+    recursion_limit: usize,\n+    adt_components: F,\n+}\n+\n+impl<'tcx, F> NeedsDropTypes<'tcx, F> {\n+    fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        adt_components: F,\n+    ) -> Self {\n+        let mut seen_tys = FxHashSet::default();\n+        seen_tys.insert(ty);\n+        let recursion_limit = *tcx.sess.recursion_limit.get();\n+        Self {\n+            tcx,\n+            param_env,\n+            seen_tys,\n+            query_ty: ty,\n+            unchecked_tys: vec![(ty, 0)],\n+            recursion_limit,\n+            adt_components,\n+        }\n+    }\n+}\n+\n+impl<'tcx, F, I> Iterator for NeedsDropTypes<'tcx, F>\n+where\n+    F: Fn(&ty::AdtDef) -> NeedsDropResult<I>,\n+    I: Iterator<Item = Ty<'tcx>>,\n+{\n+    type Item = NeedsDropResult<Ty<'tcx>>;\n+\n+    fn next(&mut self) -> Option<NeedsDropResult<Ty<'tcx>>> {\n+        let tcx = self.tcx;\n+\n+        while let Some((ty, level)) = self.unchecked_tys.pop() {\n+            if level > self.recursion_limit {\n+                // Not having a `Span` isn't great. But there's hopefully some other\n+                // recursion limit error as well.\n+                tcx.sess.span_err(\n+                    DUMMY_SP,\n+                    &format!(\"overflow while checking whether `{}` requires drop\", self.query_ty),\n+                );\n+                return Some(Err(AlwaysRequiresDrop));\n+            }\n+\n+            let components = match needs_drop_components(ty) {\n+                Err(e) => return Some(Err(e)),\n+                Ok(components) => components,\n+            };\n+            debug!(\"needs_drop_components({:?}) = {:?}\", ty, components);\n+\n+            for component in components {\n+                match component.kind {\n+                    _ if component.is_copy_modulo_regions(tcx, self.param_env, DUMMY_SP) => (),\n+\n+                    ty::Array(elem_ty, len) => {\n+                        // Zero-length arrays never contain anything to drop.\n+                        if len.try_eval_usize(tcx, self.param_env) != Some(0) {\n+                            if self.seen_tys.insert(elem_ty) {\n+                                self.unchecked_tys.push((elem_ty, level + 1));\n+                            }\n+                        }\n+                    }\n+\n+                    ty::Closure(def_id, substs) => {\n+                        for upvar_ty in substs.as_closure().upvar_tys(def_id, tcx) {\n+                            if self.seen_tys.insert(upvar_ty) {\n+                                self.unchecked_tys.push((upvar_ty, level + 1));\n+                            }\n+                        }\n+                    }\n+\n+                    // Check for a `Drop` impl and whether this is a union or\n+                    // `ManuallyDrop`. If it's a struct or enum without a `Drop`\n+                    // impl then check whether the field types need `Drop`.\n+                    ty::Adt(adt_def, substs) => {\n+                        let tys = match (self.adt_components)(adt_def) {\n+                            Err(e) => return Some(Err(e)),\n+                            Ok(tys) => tys,\n+                        };\n+                        for required_ty in tys {\n+                            let subst_ty = tcx.normalize_erasing_regions(\n+                                self.param_env,\n+                                required_ty.subst(tcx, substs),\n+                            );\n+                            if self.seen_tys.insert(subst_ty) {\n+                                self.unchecked_tys.push((subst_ty, level + 1));\n+                            }\n+                        }\n+                    }\n+                    ty::Opaque(..) | ty::Projection(..) | ty::Param(_) => {\n+                        if ty == component {\n+                            // Return the type to the caller so they can decide\n+                            // what to do with it.\n+                            return Some(Ok(component));\n+                        } else if self.seen_tys.insert(component) {\n+                            // Store the type for later. We can't return here\n+                            // because we would then lose any other components\n+                            // of the type.\n+                            self.unchecked_tys.push((component, level + 1));\n+                        }\n+                    }\n+                    _ => return Some(Err(AlwaysRequiresDrop)),\n+                }\n+            }\n+        }\n+\n+        return None;\n+    }\n+}\n+\n+fn adt_drop_tys(tcx: TyCtxt<'_>, def_id: DefId) -> Result<&ty::List<Ty<'_>>, AlwaysRequiresDrop> {\n+    let adt_components = move |adt_def: &ty::AdtDef| {\n+        if adt_def.is_manually_drop() {\n+            debug!(\"adt_drop_tys: `{:?}` is manually drop\", adt_def);\n+            return Ok(Vec::new().into_iter());\n+        } else if adt_def.destructor(tcx).is_some() {\n+            debug!(\"adt_drop_tys: `{:?}` implements `Drop`\", adt_def);\n+            return Err(AlwaysRequiresDrop);\n+        } else if adt_def.is_union() {\n+            debug!(\"adt_drop_tys: `{:?}` is a union\", adt_def);\n+            return Ok(Vec::new().into_iter());\n+        }\n+        Ok(adt_def.all_fields().map(|field| tcx.type_of(field.did)).collect::<Vec<_>>().into_iter())\n+    };\n+\n+    let adt_ty = tcx.type_of(def_id);\n+    let param_env = tcx.param_env(def_id);\n+    let res: Result<Vec<_>, _> =\n+        NeedsDropTypes::new(tcx, param_env, adt_ty, adt_components).collect();\n+\n+    debug!(\"adt_drop_tys(`{}`) = `{:?}`\", tcx.def_path_str(def_id), res);\n+    res.map(|components| tcx.intern_type_list(&components))\n+}\n+\n+pub(crate) fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers { needs_drop_raw, adt_drop_tys, ..*providers };\n+}"}, {"sha": "4ba778d53ac08a2fb4bca339155cd1d38c58a950", "filename": "src/test/ui/type-alias-impl-trait/issue-65918.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65918.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1965216a34dc2831cf44d2e15ad9d78403d10cc/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65918.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-65918.rs?ref=d1965216a34dc2831cf44d2e15ad9d78403d10cc", "patch": "@@ -1,3 +1,5 @@\n+// ignore-test: This now ICEs again.\n+\n // build-pass\n \n #![feature(type_alias_impl_trait)]"}]}