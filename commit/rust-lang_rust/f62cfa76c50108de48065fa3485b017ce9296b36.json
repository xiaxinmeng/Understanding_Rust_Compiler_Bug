{"sha": "f62cfa76c50108de48065fa3485b017ce9296b36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MmNmYTc2YzUwMTA4ZGU0ODA2NWZhMzQ4NWIwMTdjZTkyOTZiMzY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-03-31T17:29:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-31T17:29:26Z"}, "message": "Rollup merge of #69425 - lcnr:make_contiguous, r=Amanieu\n\nadd fn make_contiguous to VecDeque\n\nAdds the following method to VecDeque:\n\n```rust\npub fn make_contiguous(&mut self) -> &mut [T];\n```\n\nTaken from https://github.com/rust-lang/rust/pull/69400, after a suggestion by @CryZe https://github.com/rust-lang/rust/pull/69400#issuecomment-590216089\n\nI am in favor of merging this instead of https://github.com/rust-lang/rust/pull/69400.", "tree": {"sha": "264b0ea8db20abd263bcbbf805b97f1220c9a44d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264b0ea8db20abd263bcbbf805b97f1220c9a44d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f62cfa76c50108de48065fa3485b017ce9296b36", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeg332CRBK7hj4Ov3rIwAAdHIIAFMKcOLybCDR9bKhQmkh8opM\n13UqhPHoX+Y7+6VItxt+DbTiYhZIuoHadI6m4mRSmd0ZYoeTZiSG/Spav72WjySd\naArxO/98qzoAvfZkM9O3E6hCieLn7I4rdCwEzfcsPe8PNZuPiVCtnDn8uSRdegty\nYckfW3qXMR3A+dtSl/SJk9A68g9cEPjFCWhCDhhZRcTAZzC/woaIJmUBOF3hdB2E\nuqOionVEIHdazo7ApMxHM4BLmZC1rcj5W/Br3bJiVx7YjEA8OSLnhivFtrMSsE8O\ncpboC7aTT553jYCl98+/9X1xbg0VGy8LubWu0PRx1ZZOrECT64MGgKuK1JVQUAA=\n=+ar6\n-----END PGP SIGNATURE-----\n", "payload": "tree 264b0ea8db20abd263bcbbf805b97f1220c9a44d\nparent 75ff3110ac6d8a0259023b83fd20d7ab295f8dd6\nparent e1afd26c524dbc8b90e7f1cdb00891f0b63b244d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1585675766 +0200\ncommitter GitHub <noreply@github.com> 1585675766 +0200\n\nRollup merge of #69425 - lcnr:make_contiguous, r=Amanieu\n\nadd fn make_contiguous to VecDeque\n\nAdds the following method to VecDeque:\n\n```rust\npub fn make_contiguous(&mut self) -> &mut [T];\n```\n\nTaken from https://github.com/rust-lang/rust/pull/69400, after a suggestion by @CryZe https://github.com/rust-lang/rust/pull/69400#issuecomment-590216089\n\nI am in favor of merging this instead of https://github.com/rust-lang/rust/pull/69400.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f62cfa76c50108de48065fa3485b017ce9296b36", "html_url": "https://github.com/rust-lang/rust/commit/f62cfa76c50108de48065fa3485b017ce9296b36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f62cfa76c50108de48065fa3485b017ce9296b36/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6", "html_url": "https://github.com/rust-lang/rust/commit/75ff3110ac6d8a0259023b83fd20d7ab295f8dd6"}, {"sha": "e1afd26c524dbc8b90e7f1cdb00891f0b63b244d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1afd26c524dbc8b90e7f1cdb00891f0b63b244d", "html_url": "https://github.com/rust-lang/rust/commit/e1afd26c524dbc8b90e7f1cdb00891f0b63b244d"}], "stats": {"total": 288, "additions": 235, "deletions": 53}, "files": [{"sha": "94532521a9066150bf3452466625847e5ddcceea", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 153, "deletions": 52, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/f62cfa76c50108de48065fa3485b017ce9296b36/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62cfa76c50108de48065fa3485b017ce9296b36/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=f62cfa76c50108de48065fa3485b017ce9296b36", "patch": "@@ -959,6 +959,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -989,6 +992,9 @@ impl<T> VecDeque<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `VecDeque`.\n     ///\n+    /// If [`make_contiguous`](#method.make_contiguous) was previously called, all elements\n+    /// of the `VecDeque` will be in the first slice and the second slice will be empty.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -2044,6 +2050,148 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Rearranges the internal storage of this deque so it is one contiguous slice, which is then returned.\n+    ///\n+    /// This method does not allocate and does not change the order of the inserted elements.\n+    /// As it returns a mutable slice, this can be used to sort or binary search a deque.\n+    ///\n+    /// Once the internal storage is contiguous, the [`as_slices`](#method.as_slices) and\n+    /// [`as_mut_slices`](#method.as_mut_slices) methods will return the entire contents of the\n+    /// `VecDeque` in a single slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Sorting the content of a deque.\n+    ///\n+    /// ```\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::with_capacity(15);\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// // sorting the deque\n+    /// buf.make_contiguous().sort();\n+    /// assert_eq!(buf.as_slices(), (&[1, 2, 3] as &[_], &[] as &[_]));\n+    ///\n+    /// // sorting it in reverse order\n+    /// buf.make_contiguous().sort_by(|a, b| b.cmp(a));\n+    /// assert_eq!(buf.as_slices(), (&[3, 2, 1] as &[_], &[] as &[_]));\n+    /// ```\n+    ///\n+    /// Getting immutable access to the contiguous slice.\n+    ///\n+    /// ```rust\n+    /// #![feature(deque_make_contiguous)]\n+    ///\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    ///\n+    /// buf.push_back(2);\n+    /// buf.push_back(1);\n+    /// buf.push_front(3);\n+    ///\n+    /// buf.make_contiguous();\n+    /// if let (slice, &[]) = buf.as_slices() {\n+    ///     // we can now be sure that `slice` contains all elements of the deque,\n+    ///     // while still having immutable access to `buf`.\n+    ///     assert_eq!(buf.len(), slice.len());\n+    ///     assert_eq!(slice, &[3, 2, 1] as &[_]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"deque_make_contiguous\", issue = \"none\")]\n+    pub fn make_contiguous(&mut self) -> &mut [T] {\n+        if self.is_contiguous() {\n+            let tail = self.tail;\n+            let head = self.head;\n+            return unsafe { &mut self.buffer_as_mut_slice()[tail..head] };\n+        }\n+\n+        let buf = self.buf.ptr();\n+        let cap = self.cap();\n+        let len = self.len();\n+\n+        let free = self.tail - self.head;\n+        let tail_len = cap - self.tail;\n+\n+        if free >= tail_len {\n+            // there is enough free space to copy the tail in one go,\n+            // this means that we first shift the head backwards, and then\n+            // copy the tail to the correct position.\n+            //\n+            // from: DEFGH....ABC\n+            // to:   ABCDEFGH....\n+            unsafe {\n+                ptr::copy(buf, buf.add(tail_len), self.head);\n+                // ...DEFGH.ABC\n+                ptr::copy_nonoverlapping(buf.add(self.tail), buf, tail_len);\n+                // ABCDEFGH....\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        } else if free >= self.head {\n+            // there is enough free space to copy the head in one go,\n+            // this means that we first shift the tail forwards, and then\n+            // copy the head to the correct position.\n+            //\n+            // from: FGH....ABCDE\n+            // to:   ...ABCDEFGH.\n+            unsafe {\n+                ptr::copy(buf.add(self.tail), buf.add(self.head), tail_len);\n+                // FGHABCDE....\n+                ptr::copy_nonoverlapping(buf, buf.add(self.head + tail_len), self.head);\n+                // ...ABCDEFGH.\n+\n+                self.tail = self.head;\n+                self.head = self.tail + len;\n+            }\n+        } else {\n+            // free is smaller than both head and tail,\n+            // this means we have to slowly \"swap\" the tail and the head.\n+            //\n+            // from: EFGHI...ABCD or HIJK.ABCDEFG\n+            // to:   ABCDEFGHI... or ABCDEFGHIJK.\n+            let mut left_edge: usize = 0;\n+            let mut right_edge: usize = self.tail;\n+            unsafe {\n+                // The general problem looks like this\n+                // GHIJKLM...ABCDEF - before any swaps\n+                // ABCDEFM...GHIJKL - after 1 pass of swaps\n+                // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n+                //                  - then restart the algorithm with a new (smaller) store\n+                // Sometimes the temp store is reached when the right edge is at the end\n+                // of the buffer - this means we've hit the right order with fewer swaps!\n+                // E.g\n+                // EF..ABCD\n+                // ABCDEF.. - after four only swaps we've finished\n+                while left_edge < len && right_edge != cap {\n+                    let mut right_offset = 0;\n+                    for i in left_edge..right_edge {\n+                        right_offset = (i - left_edge) % (cap - right_edge);\n+                        let src: isize = (right_edge + right_offset) as isize;\n+                        ptr::swap(buf.add(i), buf.offset(src));\n+                    }\n+                    let n_ops = right_edge - left_edge;\n+                    left_edge += n_ops;\n+                    right_edge += right_offset + 1;\n+                }\n+\n+                self.tail = 0;\n+                self.head = len;\n+            }\n+        }\n+\n+        let tail = self.tail;\n+        let head = self.head;\n+        unsafe { &mut self.buffer_as_mut_slice()[tail..head] }\n+    }\n+\n     /// Rotates the double-ended queue `mid` places to the left.\n     ///\n     /// Equivalently,\n@@ -2803,63 +2951,16 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n     /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n     /// assert_eq!(vec.as_ptr(), ptr);\n     /// ```\n-    fn from(other: VecDeque<T>) -> Self {\n+    fn from(mut other: VecDeque<T>) -> Self {\n+        other.make_contiguous();\n+\n         unsafe {\n             let buf = other.buf.ptr();\n             let len = other.len();\n-            let tail = other.tail;\n-            let head = other.head;\n             let cap = other.cap();\n \n-            // Need to move the ring to the front of the buffer, as vec will expect this.\n-            if other.is_contiguous() {\n-                ptr::copy(buf.add(tail), buf, len);\n-            } else {\n-                if (tail - head) >= cmp::min(cap - tail, head) {\n-                    // There is enough free space in the centre for the shortest block so we can\n-                    // do this in at most three copy moves.\n-                    if (cap - tail) > head {\n-                        // right hand block is the long one; move that enough for the left\n-                        ptr::copy(buf.add(tail), buf.add(tail - head), cap - tail);\n-                        // copy left in the end\n-                        ptr::copy(buf, buf.add(cap - head), head);\n-                        // shift the new thing to the start\n-                        ptr::copy(buf.add(tail - head), buf, len);\n-                    } else {\n-                        // left hand block is the long one, we can do it in two!\n-                        ptr::copy(buf, buf.add(cap - tail), head);\n-                        ptr::copy(buf.add(tail), buf, cap - tail);\n-                    }\n-                } else {\n-                    // Need to use N swaps to move the ring\n-                    // We can use the space at the end of the ring as a temp store\n-\n-                    let mut left_edge: usize = 0;\n-                    let mut right_edge: usize = tail;\n-\n-                    // The general problem looks like this\n-                    // GHIJKLM...ABCDEF - before any swaps\n-                    // ABCDEFM...GHIJKL - after 1 pass of swaps\n-                    // ABCDEFGHIJM...KL - swap until the left edge reaches the temp store\n-                    //                  - then restart the algorithm with a new (smaller) store\n-                    // Sometimes the temp store is reached when the right edge is at the end\n-                    // of the buffer - this means we've hit the right order with fewer swaps!\n-                    // E.g\n-                    // EF..ABCD\n-                    // ABCDEF.. - after four only swaps we've finished\n-\n-                    while left_edge < len && right_edge != cap {\n-                        let mut right_offset = 0;\n-                        for i in left_edge..right_edge {\n-                            right_offset = (i - left_edge) % (cap - right_edge);\n-                            let src: isize = (right_edge + right_offset) as isize;\n-                            ptr::swap(buf.add(i), buf.offset(src));\n-                        }\n-                        let n_ops = right_edge - left_edge;\n-                        left_edge += n_ops;\n-                        right_edge += right_offset + 1;\n-                    }\n-                }\n+            if other.head != 0 {\n+                ptr::copy(buf.add(other.tail), buf, len);\n             }\n             let out = Vec::from_raw_parts(buf, len, cap);\n             mem::forget(other);"}, {"sha": "8ef5ec78e056e8a2d72b3402a4d73503b0e4f3c2", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/f62cfa76c50108de48065fa3485b017ce9296b36/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f62cfa76c50108de48065fa3485b017ce9296b36/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=f62cfa76c50108de48065fa3485b017ce9296b36", "patch": "@@ -1,6 +1,6 @@\n use super::*;\n \n-use ::test;\n+use test;\n \n #[bench]\n #[cfg_attr(miri, ignore)] // Miri does not support benchmarks\n@@ -130,6 +130,87 @@ fn test_insert() {\n     }\n }\n \n+#[test]\n+fn make_contiguous_big_tail() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..3 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 3..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 012......9876543\n+    assert_eq!(tester.capacity(), 15);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3] as &[_], &[0, 1, 2] as &[_]), tester.as_slices());\n+\n+    let expected_start = tester.head;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 7, 6, 5, 4, 3, 0, 1, 2] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_big_head() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 0..8 {\n+        tester.push_back(i);\n+    }\n+\n+    for i in 8..10 {\n+        tester.push_front(i);\n+    }\n+\n+    // 01234567......98\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!((&[9, 8, 0, 1, 2, 3, 4, 5, 6, 7] as &[_], &[] as &[_]), tester.as_slices());\n+}\n+\n+#[test]\n+fn make_contiguous_small_free() {\n+    let mut tester = VecDeque::with_capacity(15);\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // ABCDEFGH...MLKJI\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['M', 'L', 'K', 'J', 'I', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+\n+    tester.clear();\n+    for i in 'I' as u8..'N' as u8 {\n+        tester.push_back(i as char);\n+    }\n+\n+    for i in 'A' as u8..'I' as u8 {\n+        tester.push_front(i as char);\n+    }\n+\n+    // IJKLM...HGFEDCBA\n+    let expected_start = 0;\n+    tester.make_contiguous();\n+    assert_eq!(tester.tail, expected_start);\n+    assert_eq!(\n+        (&['H', 'G', 'F', 'E', 'D', 'C', 'B', 'A', 'I', 'J', 'K', 'L', 'M'] as &[_], &[] as &[_]),\n+        tester.as_slices()\n+    );\n+}\n+\n #[test]\n fn test_remove() {\n     // This test checks that every single combination of tail position, length, and"}]}