{"sha": "c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "node_id": "C_kwDOAAsO6NoAKGMxYWFlNGQyNzkwMmFhYWEwZDhlN2QxYTc2ZDAzMGI0ZmM5MGYzMjk", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2022-05-13T14:06:36Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2022-08-04T14:29:32Z"}, "message": "std::io: migrate ReadBuf to BorrowBuf/BorrowCursor\n\nSigned-off-by: Nick Cameron <nrc@ncameron.org>", "tree": {"sha": "44dc113fd12021053c076685896c6b96ecf6f2b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44dc113fd12021053c076685896c6b96ecf6f2b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "html_url": "https://github.com/rust-lang/rust/commit/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f18f0a9d4548bc87afff1e4c0fe9081c35002c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f18f0a9d4548bc87afff1e4c0fe9081c35002c2", "html_url": "https://github.com/rust-lang/rust/commit/6f18f0a9d4548bc87afff1e4c0fe9081c35002c2"}], "stats": {"total": 714, "additions": 324, "deletions": 390}, "files": [{"sha": "d41f32b5b3f219620db9263d6f4f5960fd9b890a", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -13,7 +13,7 @@ mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n-use crate::io::{self, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write};\n+use crate::io::{self, BorrowCursor, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write};\n use crate::path::{Path, PathBuf};\n use crate::sys::fs as fs_imp;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n@@ -703,8 +703,8 @@ impl Read for File {\n         self.inner.read_vectored(bufs)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.inner.read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        self.inner.read_buf(cursor)\n     }\n \n     #[inline]\n@@ -755,8 +755,8 @@ impl Read for &File {\n         self.inner.read(buf)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.inner.read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        self.inner.read_buf(cursor)\n     }\n \n     fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {"}, {"sha": "1f19ac11bf1012ef58ff8cd6f5f4b3d875623e9b", "filename": "library/std/src/io/buffered/bufreader.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Fbufreader.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -2,7 +2,8 @@ mod buffer;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, DEFAULT_BUF_SIZE,\n+    self, BorrowBuf, BorrowCursor, BufRead, IoSliceMut, Read, Seek, SeekFrom, SizeHint,\n+    DEFAULT_BUF_SIZE,\n };\n use buffer::Buffer;\n \n@@ -266,21 +267,21 @@ impl<R: Read> Read for BufReader<R> {\n         Ok(nread)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, mut cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.pos() == self.buf.filled() && buf.remaining() >= self.capacity() {\n+        if self.buf.pos() == self.buf.filled() && cursor.capacity() >= self.capacity() {\n             self.discard_buffer();\n-            return self.inner.read_buf(buf);\n+            return self.inner.read_buf(cursor);\n         }\n \n-        let prev = buf.filled_len();\n+        let prev = cursor.written();\n \n         let mut rem = self.fill_buf()?;\n-        rem.read_buf(buf)?;\n+        rem.read_buf(cursor.clone())?;\n \n-        self.consume(buf.filled_len() - prev); //slice impl of read_buf known to never unfill buf\n+        self.consume(cursor.written() - prev); //slice impl of read_buf known to never unfill buf\n \n         Ok(())\n     }"}, {"sha": "c93b69bf1f7c16b22a0af4da8d9075ebbecbb717", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -1,5 +1,5 @@\n use crate::io::prelude::*;\n-use crate::io::{self, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowBuf, BufReader, BufWriter, ErrorKind, IoSlice, LineWriter, SeekFrom};\n use crate::mem::MaybeUninit;\n use crate::panic;\n use crate::sync::atomic::{AtomicUsize, Ordering};\n@@ -61,48 +61,48 @@ fn test_buffered_reader_read_buf() {\n     let inner: &[u8] = &[5, 6, 7, 0, 1, 2, 3, 4];\n     let mut reader = BufReader::with_capacity(2, inner);\n \n-    let mut buf = [MaybeUninit::uninit(); 3];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 3];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [5, 6, 7]);\n     assert_eq!(reader.buffer(), []);\n \n-    let mut buf = [MaybeUninit::uninit(); 2];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 2];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [0, 1]);\n     assert_eq!(reader.buffer(), []);\n \n-    let mut buf = [MaybeUninit::uninit(); 1];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [2]);\n     assert_eq!(reader.buffer(), [3]);\n \n-    let mut buf = [MaybeUninit::uninit(); 3];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 3];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [3]);\n     assert_eq!(reader.buffer(), []);\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n     assert_eq!(buf.filled(), [3, 4]);\n     assert_eq!(reader.buffer(), []);\n \n     buf.clear();\n \n-    reader.read_buf(&mut buf).unwrap();\n+    reader.read_buf(buf.unfilled()).unwrap();\n \n-    assert_eq!(buf.filled_len(), 0);\n+    assert!(buf.filled().is_empty());\n }\n \n #[test]"}, {"sha": "193bcd47467c1e2ff7ec0ff550756521f0521482", "filename": "library/std/src/io/copy.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcopy.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -1,4 +1,4 @@\n-use super::{BufWriter, ErrorKind, Read, ReadBuf, Result, Write, DEFAULT_BUF_SIZE};\n+use super::{BorrowBuf, BufWriter, ErrorKind, Read, Result, Write, DEFAULT_BUF_SIZE};\n use crate::mem::MaybeUninit;\n \n /// Copies the entire contents of a reader into a writer.\n@@ -97,37 +97,39 @@ impl<I: Write> BufferedCopySpec for BufWriter<I> {\n \n         loop {\n             let buf = writer.buffer_mut();\n-            let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+            let mut read_buf: BorrowBuf<'_> = buf.spare_capacity_mut().into();\n \n-            // SAFETY: init is either 0 or the initialized_len of the previous iteration\n             unsafe {\n-                read_buf.assume_init(init);\n+                // SAFETY: init is either 0 or the init_len from the previous iteration.\n+                read_buf.set_init(init);\n             }\n \n             if read_buf.capacity() >= DEFAULT_BUF_SIZE {\n-                match reader.read_buf(&mut read_buf) {\n+                let mut cursor = read_buf.unfilled();\n+                match reader.read_buf(cursor.clone()) {\n                     Ok(()) => {\n-                        let bytes_read = read_buf.filled_len();\n+                        let bytes_read = cursor.written();\n \n                         if bytes_read == 0 {\n                             return Ok(len);\n                         }\n \n-                        init = read_buf.initialized_len() - bytes_read;\n+                        init = read_buf.init_len() - bytes_read;\n+                        len += bytes_read as u64;\n \n-                        // SAFETY: ReadBuf guarantees all of its filled bytes are init\n+                        // SAFETY: BorrowBuf guarantees all of its filled bytes are init\n                         unsafe { buf.set_len(buf.len() + bytes_read) };\n-                        len += bytes_read as u64;\n+\n                         // Read again if the buffer still has enough capacity, as BufWriter itself would do\n                         // This will occur if the reader returns short reads\n-                        continue;\n                     }\n-                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n+                    Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                     Err(e) => return Err(e),\n                 }\n+            } else {\n+                writer.flush_buf()?;\n+                init = 0;\n             }\n-\n-            writer.flush_buf()?;\n         }\n     }\n }\n@@ -136,13 +138,13 @@ fn stack_buffer_copy<R: Read + ?Sized, W: Write + ?Sized>(\n     reader: &mut R,\n     writer: &mut W,\n ) -> Result<u64> {\n-    let mut buf = [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); DEFAULT_BUF_SIZE];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n \n     let mut len = 0;\n \n     loop {\n-        match reader.read_buf(&mut buf) {\n+        match reader.read_buf(buf.unfilled()) {\n             Ok(()) => {}\n             Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),"}, {"sha": "460b1504ffbfc45a475bb2c738bb8170ea4e0edf", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -5,7 +5,7 @@ use crate::io::prelude::*;\n \n use crate::alloc::Allocator;\n use crate::cmp;\n-use crate::io::{self, ErrorKind, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowCursor, ErrorKind, IoSlice, IoSliceMut, SeekFrom};\n \n /// A `Cursor` wraps an in-memory buffer and provides it with a\n /// [`Seek`] implementation.\n@@ -323,12 +323,12 @@ where\n         Ok(n)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let prev_filled = buf.filled_len();\n+    fn read_buf(&mut self, mut cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        let prev_written = cursor.written();\n \n-        Read::read_buf(&mut self.fill_buf()?, buf)?;\n+        Read::read_buf(&mut self.fill_buf()?, cursor.clone())?;\n \n-        self.pos += (buf.filled_len() - prev_filled) as u64;\n+        self.pos += (cursor.written() - prev_written) as u64;\n \n         Ok(())\n     }"}, {"sha": "eee5ab6ec1050f8da9dfc9c5bf3de6c00db520b1", "filename": "library/std/src/io/impls.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fimpls.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -6,7 +6,7 @@ use crate::cmp;\n use crate::collections::VecDeque;\n use crate::fmt;\n use crate::io::{\n-    self, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, Write,\n+    self, BorrowCursor, BufRead, ErrorKind, IoSlice, IoSliceMut, Read, Seek, SeekFrom, Write,\n };\n use crate::mem;\n \n@@ -21,8 +21,8 @@ impl<R: Read + ?Sized> Read for &mut R {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        (**self).read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n     }\n \n     #[inline]\n@@ -125,8 +125,8 @@ impl<R: Read + ?Sized> Read for Box<R> {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        (**self).read_buf(buf)\n+    fn read_buf(&mut self, cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        (**self).read_buf(cursor)\n     }\n \n     #[inline]\n@@ -249,11 +249,11 @@ impl Read for &[u8] {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        let amt = cmp::min(buf.remaining(), self.len());\n+    fn read_buf(&mut self, mut cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        let amt = cmp::min(cursor.capacity(), self.len());\n         let (a, b) = self.split_at(amt);\n \n-        buf.append(a);\n+        cursor.append(a);\n \n         *self = b;\n         Ok(())"}, {"sha": "b3218b2831d3f6d515a6c7ebd623953d0a469ad1", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -278,7 +278,7 @@ pub use self::{\n };\n \n #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-pub use self::readbuf::ReadBuf;\n+pub use self::readbuf::{BorrowBuf, BorrowCursor};\n pub(crate) use error::const_io_error;\n \n mod buffered;\n@@ -362,29 +362,30 @@ pub(crate) fn default_read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>\n             buf.reserve(32); // buf is full, need more space\n         }\n \n-        let mut read_buf = ReadBuf::uninit(buf.spare_capacity_mut());\n+        let mut read_buf: BorrowBuf<'_> = buf.spare_capacity_mut().into();\n \n         // SAFETY: These bytes were initialized but not filled in the previous loop\n         unsafe {\n-            read_buf.assume_init(initialized);\n+            read_buf.set_init(initialized);\n         }\n \n-        match r.read_buf(&mut read_buf) {\n+        let mut cursor = read_buf.unfilled();\n+        match r.read_buf(cursor.clone()) {\n             Ok(()) => {}\n             Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n             Err(e) => return Err(e),\n         }\n \n-        if read_buf.filled_len() == 0 {\n+        if cursor.written() == 0 {\n             return Ok(buf.len() - start_len);\n         }\n \n         // store how much was initialized but not filled\n-        initialized = read_buf.initialized_len() - read_buf.filled_len();\n-        let new_len = read_buf.filled_len() + buf.len();\n+        initialized = cursor.init_ref().len();\n \n-        // SAFETY: ReadBuf's invariants mean this much memory is init\n+        // SAFETY: BorrowBuf's invariants mean this much memory is initialized.\n         unsafe {\n+            let new_len = read_buf.filled().len() + buf.len();\n             buf.set_len(new_len);\n         }\n \n@@ -461,12 +462,15 @@ pub(crate) fn default_read_exact<R: Read + ?Sized>(this: &mut R, mut buf: &mut [\n     }\n }\n \n-pub(crate) fn default_read_buf<F>(read: F, buf: &mut ReadBuf<'_>) -> Result<()>\n+pub(crate) fn default_read_buf<F>(read: F, mut cursor: BorrowCursor<'_, '_>) -> Result<()>\n where\n     F: FnOnce(&mut [u8]) -> Result<usize>,\n {\n-    let n = read(buf.initialize_unfilled())?;\n-    buf.add_filled(n);\n+    let n = read(cursor.ensure_init().init_mut())?;\n+    unsafe {\n+        // SAFETY: we initialised using `ensure_init` so there is no uninit data to advance to.\n+        cursor.advance(n);\n+    }\n     Ok(())\n }\n \n@@ -801,32 +805,33 @@ pub trait Read {\n         default_read_exact(self, buf)\n     }\n \n+    // TODO naming, if should the method be read_cursor? Or should we change the names of the data structures?\n     /// Pull some bytes from this source into the specified buffer.\n     ///\n-    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to allow use\n+    /// This is equivalent to the [`read`](Read::read) method, except that it is passed a [`BorrowCursor`] rather than `[u8]` to allow use\n     /// with uninitialized buffers. The new data will be appended to any existing contents of `buf`.\n     ///\n     /// The default implementation delegates to `read`.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+    fn read_buf(&mut self, buf: BorrowCursor<'_, '_>) -> Result<()> {\n         default_read_buf(|b| self.read(b), buf)\n     }\n \n-    /// Read the exact number of bytes required to fill `buf`.\n+    /// Read the exact number of bytes required to fill `cursor`.\n     ///\n-    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`ReadBuf`] rather than `[u8]` to\n+    /// This is equivalent to the [`read_exact`](Read::read_exact) method, except that it is passed a [`BorrowCursor`] rather than `[u8]` to\n     /// allow use with uninitialized buffers.\n     #[unstable(feature = \"read_buf\", issue = \"78485\")]\n-    fn read_buf_exact(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n-        while buf.remaining() > 0 {\n-            let prev_filled = buf.filled().len();\n-            match self.read_buf(buf) {\n+    fn read_buf_exact(&mut self, mut cursor: BorrowCursor<'_, '_>) -> Result<()> {\n+        while cursor.capacity() > 0 {\n+            let prev_written = cursor.written();\n+            match self.read_buf(cursor.clone()) {\n                 Ok(()) => {}\n                 Err(e) if e.kind() == ErrorKind::Interrupted => continue,\n                 Err(e) => return Err(e),\n             }\n \n-            if buf.filled().len() == prev_filled {\n+            if cursor.written() == prev_written {\n                 return Err(Error::new(ErrorKind::UnexpectedEof, \"failed to fill buffer\"));\n             }\n         }\n@@ -2582,50 +2587,48 @@ impl<T: Read> Read for Take<T> {\n         Ok(n)\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> Result<()> {\n+    fn read_buf(&mut self, mut buf: BorrowCursor<'_, '_>) -> Result<()> {\n         // Don't call into inner reader at all at EOF because it may still block\n         if self.limit == 0 {\n             return Ok(());\n         }\n \n-        let prev_filled = buf.filled_len();\n-\n-        if self.limit <= buf.remaining() as u64 {\n+        if self.limit <= buf.capacity() as u64 {\n             // if we just use an as cast to convert, limit may wrap around on a 32 bit target\n             let limit = cmp::min(self.limit, usize::MAX as u64) as usize;\n \n-            let extra_init = cmp::min(limit as usize, buf.initialized_len() - buf.filled_len());\n+            let extra_init = cmp::min(limit as usize, buf.init_ref().len());\n \n             // SAFETY: no uninit data is written to ibuf\n-            let ibuf = unsafe { &mut buf.unfilled_mut()[..limit] };\n+            let ibuf = unsafe { &mut buf.as_mut()[..limit] };\n \n-            let mut sliced_buf = ReadBuf::uninit(ibuf);\n+            let mut sliced_buf: BorrowBuf<'_> = ibuf.into();\n \n             // SAFETY: extra_init bytes of ibuf are known to be initialized\n             unsafe {\n-                sliced_buf.assume_init(extra_init);\n+                sliced_buf.set_init(extra_init);\n             }\n \n-            self.inner.read_buf(&mut sliced_buf)?;\n+            let mut cursor = sliced_buf.unfilled();\n+            self.inner.read_buf(cursor.clone())?;\n \n-            let new_init = sliced_buf.initialized_len();\n-            let filled = sliced_buf.filled_len();\n+            let new_init = cursor.init_ref().len();\n+            let filled = sliced_buf.len();\n \n-            // sliced_buf / ibuf must drop here\n+            // cursor / sliced_buf / ibuf must drop here\n \n-            // SAFETY: new_init bytes of buf's unfilled buffer have been initialized\n             unsafe {\n-                buf.assume_init(new_init);\n+                // SAFETY: filled bytes have been filled and therefore initialized\n+                buf.advance(filled);\n+                // SAFETY: new_init bytes of buf's unfilled buffer have been initialized\n+                buf.set_init(new_init);\n             }\n \n-            buf.add_filled(filled);\n-\n             self.limit -= filled as u64;\n         } else {\n-            self.inner.read_buf(buf)?;\n-\n-            //inner may unfill\n-            self.limit -= buf.filled_len().saturating_sub(prev_filled) as u64;\n+            let written = buf.written();\n+            self.inner.read_buf(buf.clone())?;\n+            self.limit -= (buf.written() - written) as u64;\n         }\n \n         Ok(())"}, {"sha": "4578433b22a11ab4e6362a6928c2cb6bfbe78199", "filename": "library/std/src/io/readbuf.rs", "status": "modified", "additions": 119, "deletions": 124, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -7,6 +7,7 @@ use crate::cmp;\n use crate::fmt::{self, Debug, Formatter};\n use crate::mem::MaybeUninit;\n \n+// TODO docs\n /// A wrapper around a byte buffer that is incrementally filled and initialized.\n ///\n /// This type is a sort of \"double cursor\". It tracks three regions in the buffer: a region at the beginning of the\n@@ -20,230 +21,224 @@ use crate::mem::MaybeUninit;\n /// [ filled |         unfilled         ]\n /// [    initialized    | uninitialized ]\n /// ```\n-pub struct ReadBuf<'a> {\n+pub struct BorrowBuf<'a> {\n     buf: &'a mut [MaybeUninit<u8>],\n     filled: usize,\n     initialized: usize,\n }\n \n-impl Debug for ReadBuf<'_> {\n+impl Debug for BorrowBuf<'_> {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"ReadBuf\")\n-            .field(\"init\", &self.initialized())\n+            .field(\"init\", &self.initialized)\n             .field(\"filled\", &self.filled)\n             .field(\"capacity\", &self.capacity())\n             .finish()\n     }\n }\n \n-impl<'a> ReadBuf<'a> {\n-    /// Creates a new `ReadBuf` from a fully initialized buffer.\n+/// Creates a new `BorrowBuf` from a fully initialized slice.\n+impl<'a> From<&'a mut [u8]> for BorrowBuf<'a> {\n     #[inline]\n-    pub fn new(buf: &'a mut [u8]) -> ReadBuf<'a> {\n-        let len = buf.len();\n+    fn from(slice: &'a mut [u8]) -> BorrowBuf<'a> {\n+        let len = slice.len();\n \n-        ReadBuf {\n-            //SAFETY: initialized data never becoming uninitialized is an invariant of ReadBuf\n-            buf: unsafe { (buf as *mut [u8]).as_uninit_slice_mut().unwrap() },\n+        BorrowBuf {\n+            //SAFETY: initialized data never becoming uninitialized is an invariant of BorrowBuf\n+            buf: unsafe { (slice as *mut [u8]).as_uninit_slice_mut().unwrap() },\n             filled: 0,\n             initialized: len,\n         }\n     }\n+}\n \n-    /// Creates a new `ReadBuf` from a fully uninitialized buffer.\n-    ///\n-    /// Use `assume_init` if part of the buffer is known to be already initialized.\n+/// Creates a new `BorrowBuf` from a fully uninitialized buffer.\n+///\n+/// Use `set_init` if part of the buffer is known to be already initialized.\n+impl<'a> From<&'a mut [MaybeUninit<u8>]> for BorrowBuf<'a> {\n     #[inline]\n-    pub fn uninit(buf: &'a mut [MaybeUninit<u8>]) -> ReadBuf<'a> {\n-        ReadBuf { buf, filled: 0, initialized: 0 }\n+    fn from(buf: &'a mut [MaybeUninit<u8>]) -> BorrowBuf<'a> {\n+        BorrowBuf { buf, filled: 0, initialized: 0 }\n     }\n+}\n \n+impl<'a> BorrowBuf<'a> {\n     /// Returns the total capacity of the buffer.\n     #[inline]\n     pub fn capacity(&self) -> usize {\n         self.buf.len()\n     }\n \n+    /// Returns the length of the filled part of the buffer.\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.filled\n+    }\n+\n+    /// Returns the length of the initialized part of the buffer.\n+    #[inline]\n+    pub fn init_len(&self) -> usize {\n+        self.initialized\n+    }\n+\n     /// Returns a shared reference to the filled portion of the buffer.\n     #[inline]\n     pub fn filled(&self) -> &[u8] {\n         //SAFETY: We only slice the filled part of the buffer, which is always valid\n         unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.filled]) }\n     }\n \n-    /// Returns a mutable reference to the filled portion of the buffer.\n+    /// Returns a cursor over the unfilled part of the buffer.\n     #[inline]\n-    pub fn filled_mut(&mut self) -> &mut [u8] {\n-        //SAFETY: We only slice the filled part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.filled]) }\n+    pub fn unfilled<'b>(&'b mut self) -> BorrowCursor<'a, 'b> {\n+        BorrowCursor { start: self.filled, buf: self }\n     }\n \n-    /// Returns a shared reference to the initialized portion of the buffer.\n+    /// Clears the buffer, resetting the filled region to empty.\n     ///\n-    /// This includes the filled portion.\n+    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n     #[inline]\n-    pub fn initialized(&self) -> &[u8] {\n-        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_ref(&self.buf[0..self.initialized]) }\n+    pub fn clear(&mut self) -> &mut Self {\n+        self.filled = 0;\n+        self\n     }\n \n-    /// Returns a mutable reference to the initialized portion of the buffer.\n+    /// Asserts that the first `n` bytes of the buffer are initialized.\n     ///\n-    /// This includes the filled portion.\n-    #[inline]\n-    pub fn initialized_mut(&mut self) -> &mut [u8] {\n-        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n-        unsafe { MaybeUninit::slice_assume_init_mut(&mut self.buf[0..self.initialized]) }\n-    }\n-\n-    /// Returns a mutable reference to the unfilled part of the buffer without ensuring that it has been fully\n-    /// initialized.\n+    /// `BorrowBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n+    /// bytes than are already known to be initialized.\n     ///\n     /// # Safety\n     ///\n-    /// The caller must not de-initialize portions of the buffer that have already been initialized.\n+    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n     #[inline]\n-    pub unsafe fn unfilled_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n-        &mut self.buf[self.filled..]\n+    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {\n+        self.initialized = cmp::max(self.initialized, n);\n+        self\n     }\n+}\n \n-    /// Returns a mutable reference to the uninitialized part of the buffer.\n-    ///\n-    /// It is safe to uninitialize any of these bytes.\n+/// A cursor view of a [`BorrowBuf`](BorrowBuf).\n+///\n+/// Provides mutable access to the unfilled portion (both initialised and uninitialised data) from\n+/// the buffer.\n+#[derive(Debug)]\n+pub struct BorrowCursor<'a, 'b> {\n+    buf: &'b mut BorrowBuf<'a>,\n+    start: usize,\n+}\n+\n+impl<'a, 'b> BorrowCursor<'a, 'b> {\n+    /// Clone this cursor.\n     #[inline]\n-    pub fn uninitialized_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n-        &mut self.buf[self.initialized..]\n+    pub fn clone<'c>(&'c mut self) -> BorrowCursor<'a, 'c> {\n+        BorrowCursor { buf: self.buf, start: self.start }\n     }\n \n-    /// Returns a mutable reference to the unfilled part of the buffer, ensuring it is fully initialized.\n-    ///\n-    /// Since `ReadBuf` tracks the region of the buffer that has been initialized, this is effectively \"free\" after\n-    /// the first use.\n+    /// Returns the available space in the cursor.\n     #[inline]\n-    pub fn initialize_unfilled(&mut self) -> &mut [u8] {\n-        // should optimize out the assertion\n-        self.initialize_unfilled_to(self.remaining())\n+    pub fn capacity(&self) -> usize {\n+        self.buf.capacity() - self.buf.filled\n     }\n \n-    /// Returns a mutable reference to the first `n` bytes of the unfilled part of the buffer, ensuring it is\n-    /// fully initialized.\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if `self.remaining()` is less than `n`.\n+    /// Returns the number of bytes written to this cursor.\n+    // TODO check for reuse uses\n     #[inline]\n-    pub fn initialize_unfilled_to(&mut self, n: usize) -> &mut [u8] {\n-        assert!(self.remaining() >= n);\n-\n-        let extra_init = self.initialized - self.filled;\n-        // If we don't have enough initialized, do zeroing\n-        if n > extra_init {\n-            let uninit = n - extra_init;\n-            let unfilled = &mut self.uninitialized_mut()[0..uninit];\n-\n-            for byte in unfilled.iter_mut() {\n-                byte.write(0);\n-            }\n+    pub fn written(&self) -> usize {\n+        self.buf.filled - self.start\n+    }\n \n-            // SAFETY: we just initialized uninit bytes, and the previous bytes were already init\n-            unsafe {\n-                self.assume_init(n);\n-            }\n+    /// Returns a shared reference to the initialized portion of the buffer.\n+    #[inline]\n+    pub fn init_ref(&self) -> &[u8] {\n+        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe {\n+            MaybeUninit::slice_assume_init_ref(&self.buf.buf[self.buf.filled..self.buf.initialized])\n         }\n-\n-        let filled = self.filled;\n-\n-        &mut self.initialized_mut()[filled..filled + n]\n     }\n \n-    /// Returns the number of bytes at the end of the slice that have not yet been filled.\n+    /// Returns a mutable reference to the initialized portion of the buffer.\n     #[inline]\n-    pub fn remaining(&self) -> usize {\n-        self.capacity() - self.filled\n+    pub fn init_mut(&mut self) -> &mut [u8] {\n+        //SAFETY: We only slice the initialized part of the buffer, which is always valid\n+        unsafe {\n+            MaybeUninit::slice_assume_init_mut(\n+                &mut self.buf.buf[self.buf.filled..self.buf.initialized],\n+            )\n+        }\n     }\n \n-    /// Clears the buffer, resetting the filled region to empty.\n+    /// Returns a mutable reference to the uninitialized part of the buffer.\n     ///\n-    /// The number of initialized bytes is not changed, and the contents of the buffer are not modified.\n+    /// It is safe to uninitialize any of these bytes.\n     #[inline]\n-    pub fn clear(&mut self) -> &mut Self {\n-        self.set_filled(0) // The assertion in `set_filled` is optimized out\n+    pub fn uninit_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf.buf[self.buf.initialized..]\n+    }\n+\n+    /// A view of the cursor as a mutable slice of `MaybeUninit<u8>`.\n+    #[inline]\n+    pub unsafe fn as_mut(&mut self) -> &mut [MaybeUninit<u8>] {\n+        &mut self.buf.buf[self.buf.filled..]\n     }\n \n     /// Increases the size of the filled region of the buffer.\n     ///\n-    /// The number of initialized bytes is not changed.\n-    ///\n-    /// # Panics\n+    /// # Safety\n     ///\n-    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    /// The caller must ensure that the first `n` elements of the cursor have been properly\n+    /// initialised.\n     #[inline]\n-    pub fn add_filled(&mut self, n: usize) -> &mut Self {\n-        self.set_filled(self.filled + n)\n+    pub unsafe fn advance(&mut self, n: usize) -> &mut Self {\n+        self.buf.filled += n;\n+        self.buf.initialized = cmp::max(self.buf.initialized, self.buf.filled);\n+        self\n     }\n \n-    /// Sets the size of the filled region of the buffer.\n-    ///\n-    /// The number of initialized bytes is not changed.\n-    ///\n-    /// Note that this can be used to *shrink* the filled region of the buffer in addition to growing it (for\n-    /// example, by a `Read` implementation that compresses data in-place).\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the filled region of the buffer would become larger than the initialized region.\n+    /// Initialised all bytes in the cursor.\n     #[inline]\n-    pub fn set_filled(&mut self, n: usize) -> &mut Self {\n-        assert!(n <= self.initialized);\n+    pub fn ensure_init(&mut self) -> &mut Self {\n+        for byte in self.uninit_mut() {\n+            byte.write(0);\n+        }\n+        self.buf.initialized = self.buf.capacity();\n \n-        self.filled = n;\n         self\n     }\n \n-    /// Asserts that the first `n` unfilled bytes of the buffer are initialized.\n+    /// Asserts that the first `n` unfilled bytes of the cursor are initialized.\n     ///\n-    /// `ReadBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n+    /// `BorrowBuf` assumes that bytes are never de-initialized, so this method does nothing when called with fewer\n     /// bytes than are already known to be initialized.\n     ///\n     /// # Safety\n     ///\n-    /// The caller must ensure that the first `n` unfilled bytes of the buffer have already been initialized.\n+    /// The caller must ensure that the first `n` bytes of the buffer have already been initialized.\n     #[inline]\n-    pub unsafe fn assume_init(&mut self, n: usize) -> &mut Self {\n-        self.initialized = cmp::max(self.initialized, self.filled + n);\n+    pub unsafe fn set_init(&mut self, n: usize) -> &mut Self {\n+        self.buf.initialized = cmp::max(self.buf.initialized, self.buf.filled + n);\n         self\n     }\n \n-    /// Appends data to the buffer, advancing the written position and possibly also the initialized position.\n+    /// Appends data to the cursor, advancing the position within its buffer.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `self.remaining()` is less than `buf.len()`.\n+    /// Panics if `self.capacity()` is less than `buf.len()`.\n     #[inline]\n     pub fn append(&mut self, buf: &[u8]) {\n-        assert!(self.remaining() >= buf.len());\n+        assert!(self.capacity() >= buf.len());\n \n         // SAFETY: we do not de-initialize any of the elements of the slice\n         unsafe {\n-            MaybeUninit::write_slice(&mut self.unfilled_mut()[..buf.len()], buf);\n+            MaybeUninit::write_slice(&mut self.as_mut()[..buf.len()], buf);\n         }\n \n         // SAFETY: We just added the entire contents of buf to the filled section.\n         unsafe {\n-            self.assume_init(buf.len());\n-        }\n-        self.add_filled(buf.len());\n-    }\n-\n-    /// Returns the amount of bytes that have been filled.\n-    #[inline]\n-    pub fn filled_len(&self) -> usize {\n-        self.filled\n-    }\n \n-    /// Returns the amount of bytes that have been initialized.\n-    #[inline]\n-    pub fn initialized_len(&self) -> usize {\n-        self.initialized\n+            self.set_init(buf.len());\n+        }\n+        self.buf.filled += buf.len();\n     }\n }"}, {"sha": "584e5de982e978410546ab46f4f948d3901235f4", "filename": "library/std/src/io/readbuf/tests.rs", "status": "modified", "additions": 54, "deletions": 118, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -1,181 +1,117 @@\n-use super::ReadBuf;\n+use super::BorrowBuf;\n use crate::mem::MaybeUninit;\n \n-/// Test that ReadBuf has the correct numbers when created with new\n+/// Test that BorrowBuf has the correct numbers when created with new\n #[test]\n fn new() {\n-    let mut buf = [0; 16];\n-    let rbuf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [0; 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.init_len(), 16);\n     assert_eq!(rbuf.capacity(), 16);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n }\n \n-/// Test that ReadBuf has the correct numbers when created with uninit\n+/// Test that BorrowBuf has the correct numbers when created with uninit\n #[test]\n fn uninit() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.initialized_len(), 0);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.init_len(), 0);\n     assert_eq!(rbuf.capacity(), 16);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n }\n \n #[test]\n fn initialize_unfilled() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n-    rbuf.initialize_unfilled();\n+    rbuf.unfilled().ensure_init();\n \n-    assert_eq!(rbuf.initialized_len(), 16);\n-}\n-\n-#[test]\n-fn initialize_unfilled_to() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n-\n-    rbuf.initialize_unfilled_to(8);\n-\n-    assert_eq!(rbuf.initialized_len(), 8);\n-\n-    rbuf.initialize_unfilled_to(4);\n-\n-    assert_eq!(rbuf.initialized_len(), 8);\n-\n-    rbuf.set_filled(8);\n-\n-    rbuf.initialize_unfilled_to(6);\n-\n-    assert_eq!(rbuf.initialized_len(), 14);\n-\n-    rbuf.initialize_unfilled_to(8);\n-\n-    assert_eq!(rbuf.initialized_len(), 16);\n+    assert_eq!(rbuf.init_len(), 16);\n }\n \n #[test]\n fn add_filled() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.add_filled(1);\n-\n-    assert_eq!(rbuf.filled_len(), 1);\n-    assert_eq!(rbuf.remaining(), 15);\n-}\n+    let buf: &mut [_] = &mut [0; 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n-#[test]\n-#[should_panic]\n-fn add_filled_panic() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n-\n-    rbuf.add_filled(1);\n-}\n-\n-#[test]\n-fn set_filled() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.set_filled(16);\n-\n-    assert_eq!(rbuf.filled_len(), 16);\n-    assert_eq!(rbuf.remaining(), 0);\n-\n-    rbuf.set_filled(6);\n-\n-    assert_eq!(rbuf.filled_len(), 6);\n-    assert_eq!(rbuf.remaining(), 10);\n-}\n-\n-#[test]\n-#[should_panic]\n-fn set_filled_panic() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    unsafe {\n+        rbuf.unfilled().advance(1);\n+    }\n \n-    rbuf.set_filled(16);\n+    assert_eq!(rbuf.filled().len(), 1);\n+    assert_eq!(rbuf.unfilled().capacity(), 15);\n }\n \n #[test]\n fn clear() {\n-    let mut buf = [255; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [255; 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n-    rbuf.set_filled(16);\n+    unsafe {\n+        rbuf.unfilled().advance(16);\n+    }\n \n-    assert_eq!(rbuf.filled_len(), 16);\n-    assert_eq!(rbuf.remaining(), 0);\n+    assert_eq!(rbuf.filled().len(), 16);\n+    assert_eq!(rbuf.unfilled().capacity(), 0);\n \n     rbuf.clear();\n \n-    assert_eq!(rbuf.filled_len(), 0);\n-    assert_eq!(rbuf.remaining(), 16);\n+    assert_eq!(rbuf.filled().len(), 0);\n+    assert_eq!(rbuf.unfilled().capacity(), 16);\n \n-    assert_eq!(rbuf.initialized(), [255; 16]);\n+    assert_eq!(rbuf.unfilled().init_ref(), [255; 16]);\n }\n \n #[test]\n-fn assume_init() {\n-    let mut buf = [MaybeUninit::uninit(); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+fn set_init() {\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n     unsafe {\n-        rbuf.assume_init(8);\n+        rbuf.set_init(8);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n \n-    rbuf.add_filled(4);\n+    unsafe {\n+        rbuf.unfilled().advance(4);\n+    }\n \n     unsafe {\n-        rbuf.assume_init(2);\n+        rbuf.set_init(2);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n \n     unsafe {\n-        rbuf.assume_init(8);\n+        rbuf.set_init(8);\n     }\n \n-    assert_eq!(rbuf.initialized_len(), 12);\n+    assert_eq!(rbuf.init_len(), 8);\n }\n \n #[test]\n fn append() {\n-    let mut buf = [MaybeUninit::new(255); 16];\n-    let mut rbuf = ReadBuf::uninit(&mut buf);\n+    let buf: &mut [_] = &mut [MaybeUninit::new(255); 16];\n+    let mut rbuf: BorrowBuf<'_> = buf.into();\n \n-    rbuf.append(&[0; 8]);\n+    rbuf.unfilled().append(&[0; 8]);\n \n-    assert_eq!(rbuf.initialized_len(), 8);\n-    assert_eq!(rbuf.filled_len(), 8);\n+    assert_eq!(rbuf.init_len(), 8);\n+    assert_eq!(rbuf.filled().len(), 8);\n     assert_eq!(rbuf.filled(), [0; 8]);\n \n     rbuf.clear();\n \n-    rbuf.append(&[1; 16]);\n+    rbuf.unfilled().append(&[1; 16]);\n \n-    assert_eq!(rbuf.initialized_len(), 16);\n-    assert_eq!(rbuf.filled_len(), 16);\n+    assert_eq!(rbuf.init_len(), 16);\n+    assert_eq!(rbuf.filled().len(), 16);\n     assert_eq!(rbuf.filled(), [1; 16]);\n }\n-\n-#[test]\n-fn filled_mut() {\n-    let mut buf = [0; 16];\n-    let mut rbuf = ReadBuf::new(&mut buf);\n-\n-    rbuf.add_filled(8);\n-\n-    let filled = rbuf.filled().to_vec();\n-\n-    assert_eq!(&*filled, &*rbuf.filled_mut());\n-}"}, {"sha": "a1322a185651e489655f44d20f88fb7cbc6210c7", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -1,4 +1,4 @@\n-use super::{repeat, Cursor, ReadBuf, SeekFrom};\n+use super::{repeat, BorrowBuf, Cursor, SeekFrom};\n use crate::cmp::{self, min};\n use crate::io::{self, IoSlice, IoSliceMut};\n use crate::io::{BufRead, BufReader, Read, Seek, Write};\n@@ -159,24 +159,24 @@ fn read_exact_slice() {\n \n #[test]\n fn read_buf_exact() {\n-    let mut buf = [0; 4];\n-    let mut buf = ReadBuf::new(&mut buf);\n+    let buf: &mut [_] = &mut [0; 4];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n \n     let mut c = Cursor::new(&b\"\"[..]);\n-    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    assert_eq!(c.read_buf_exact(buf.unfilled()).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n \n     let mut c = Cursor::new(&b\"123456789\"[..]);\n-    c.read_buf_exact(&mut buf).unwrap();\n+    c.read_buf_exact(buf.unfilled()).unwrap();\n     assert_eq!(buf.filled(), b\"1234\");\n \n     buf.clear();\n \n-    c.read_buf_exact(&mut buf).unwrap();\n+    c.read_buf_exact(buf.unfilled()).unwrap();\n     assert_eq!(buf.filled(), b\"5678\");\n \n     buf.clear();\n \n-    assert_eq!(c.read_buf_exact(&mut buf).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n+    assert_eq!(c.read_buf_exact(buf.unfilled()).unwrap_err().kind(), io::ErrorKind::UnexpectedEof);\n }\n \n #[test]\n@@ -614,10 +614,10 @@ fn bench_take_read(b: &mut test::Bencher) {\n #[bench]\n fn bench_take_read_buf(b: &mut test::Bencher) {\n     b.iter(|| {\n-        let mut buf = [MaybeUninit::uninit(); 64];\n+        let buf: &mut [_] = &mut [MaybeUninit::uninit(); 64];\n \n-        let mut rbuf = ReadBuf::uninit(&mut buf);\n+        let mut buf: BorrowBuf<'_> = buf.into();\n \n-        [255; 128].take(64).read_buf(&mut rbuf).unwrap();\n+        [255; 128].take(64).read_buf(buf.unfilled()).unwrap();\n     });\n }"}, {"sha": "5149926fd519d61cd637e0542007a7f50f10cf0a", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -5,7 +5,7 @@ mod tests;\n \n use crate::fmt;\n use crate::io::{\n-    self, BufRead, IoSlice, IoSliceMut, Read, ReadBuf, Seek, SeekFrom, SizeHint, Write,\n+    self, BorrowCursor, BufRead, IoSlice, IoSliceMut, Read, Seek, SeekFrom, SizeHint, Write,\n };\n \n /// A reader which is always at EOF.\n@@ -47,7 +47,7 @@ impl Read for Empty {\n     }\n \n     #[inline]\n-    fn read_buf(&mut self, _buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, _cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n         Ok(())\n     }\n }\n@@ -130,21 +130,19 @@ impl Read for Repeat {\n         Ok(buf.len())\n     }\n \n-    fn read_buf(&mut self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    fn read_buf(&mut self, mut buf: BorrowCursor<'_, '_>) -> io::Result<()> {\n         // SAFETY: No uninit bytes are being written\n-        for slot in unsafe { buf.unfilled_mut() } {\n+        for slot in unsafe { buf.as_mut() } {\n             slot.write(self.byte);\n         }\n \n-        let remaining = buf.remaining();\n+        let remaining = buf.capacity();\n \n         // SAFETY: the entire unfilled portion of buf has been initialized\n         unsafe {\n-            buf.assume_init(remaining);\n+            buf.advance(remaining);\n         }\n \n-        buf.add_filled(remaining);\n-\n         Ok(())\n     }\n "}, {"sha": "025173c3f446cf7de881f72c869e649471ca707b", "filename": "library/std/src/io/util/tests.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil%2Ftests.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -1,7 +1,7 @@\n use crate::cmp::{max, min};\n use crate::io::prelude::*;\n use crate::io::{\n-    copy, empty, repeat, sink, BufWriter, Empty, ReadBuf, Repeat, Result, SeekFrom, Sink,\n+    copy, empty, repeat, sink, BorrowBuf, BufWriter, Empty, Repeat, Result, SeekFrom, Sink,\n     DEFAULT_BUF_SIZE,\n };\n \n@@ -79,29 +79,29 @@ fn empty_reads() {\n     assert_eq!(e.read(&mut [0; 1024]).unwrap(), 0);\n     assert_eq!(e.by_ref().read(&mut [0; 1024]).unwrap(), 0);\n \n-    let mut buf = [];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit()];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit(); 1024];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n-\n-    let mut buf = [MaybeUninit::uninit(); 1024];\n-    let mut buf = ReadBuf::uninit(&mut buf);\n-    e.by_ref().read_buf(&mut buf).unwrap();\n-    assert_eq!(buf.filled_len(), 0);\n-    assert_eq!(buf.initialized_len(), 0);\n+    let buf: &mut [MaybeUninit<_>] = &mut [];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit()];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1024];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n+    e.read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n+\n+    let buf: &mut [_] = &mut [MaybeUninit::uninit(); 1024];\n+    let mut buf: BorrowBuf<'_> = buf.into();\n+    e.by_ref().read_buf(buf.unfilled()).unwrap();\n+    assert_eq!(buf.len(), 0);\n+    assert_eq!(buf.init_len(), 0);\n }\n \n #[test]"}, {"sha": "6adb734fb0a2fe7fe80a0ec508ce0b4be613753d", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -4,7 +4,7 @@\n mod tests;\n \n use crate::cmp;\n-use crate::io::{self, IoSlice, IoSliceMut, Read, ReadBuf};\n+use crate::io::{self, BorrowCursor, IoSlice, IoSliceMut, Read};\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, OwnedFd, RawFd};\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -131,20 +131,19 @@ impl FileDesc {\n         }\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n+    pub fn read_buf(&self, mut cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n         let ret = cvt(unsafe {\n             libc::read(\n                 self.as_raw_fd(),\n-                buf.unfilled_mut().as_mut_ptr() as *mut libc::c_void,\n-                cmp::min(buf.remaining(), READ_LIMIT),\n+                cursor.as_mut().as_mut_ptr() as *mut libc::c_void,\n+                cmp::min(cursor.capacity(), READ_LIMIT),\n             )\n         })?;\n \n         // Safety: `ret` bytes were written to the initialized portion of the buffer\n         unsafe {\n-            buf.assume_init(ret as usize);\n+            cursor.advance(ret as usize);\n         }\n-        buf.add_filled(ret as usize);\n         Ok(())\n     }\n "}, {"sha": "374f9f72d6d7423868519b50c8bd4313808d19e9", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=c1aae4d27902aaaa0d8e7d1a76d030b4fc90f329", "patch": "@@ -2,7 +2,7 @@ use crate::os::unix::prelude::*;\n \n use crate::ffi::{CStr, CString, OsStr, OsString};\n use crate::fmt;\n-use crate::io::{self, Error, IoSlice, IoSliceMut, ReadBuf, SeekFrom};\n+use crate::io::{self, BorrowCursor, Error, IoSlice, IoSliceMut, SeekFrom};\n use crate::mem;\n use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd};\n use crate::path::{Path, PathBuf};\n@@ -1031,8 +1031,8 @@ impl File {\n         self.0.read_at(buf, offset)\n     }\n \n-    pub fn read_buf(&self, buf: &mut ReadBuf<'_>) -> io::Result<()> {\n-        self.0.read_buf(buf)\n+    pub fn read_buf(&self, cursor: BorrowCursor<'_, '_>) -> io::Result<()> {\n+        self.0.read_buf(cursor)\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {"}]}