{"sha": "1576de0ce6b75fd177eca289a2826d0190e407a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1NzZkZTBjZTZiNzVmZDE3N2VjYTI4OWEyODI2ZDAxOTBlNDA3YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-21T18:03:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-21T18:03:48Z"}, "message": "Auto merge of #35776 - jseyfried:more_groundwork, r=nrc\n\nresolve: More groundwork for `item_like_imports` (RFC 1560)\n\nr? @nrc", "tree": {"sha": "79ac20d214c6d3d6473956e780d9c418bbe9f590", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79ac20d214c6d3d6473956e780d9c418bbe9f590"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1576de0ce6b75fd177eca289a2826d0190e407a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1576de0ce6b75fd177eca289a2826d0190e407a5", "html_url": "https://github.com/rust-lang/rust/commit/1576de0ce6b75fd177eca289a2826d0190e407a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1576de0ce6b75fd177eca289a2826d0190e407a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "490189634b656dcca9e41e6b52093569c03bd4df", "url": "https://api.github.com/repos/rust-lang/rust/commits/490189634b656dcca9e41e6b52093569c03bd4df", "html_url": "https://github.com/rust-lang/rust/commit/490189634b656dcca9e41e6b52093569c03bd4df"}, {"sha": "a6e8f3ba8332cc4a7c32a64cf0df6f67b32a3dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6e8f3ba8332cc4a7c32a64cf0df6f67b32a3dd3", "html_url": "https://github.com/rust-lang/rust/commit/a6e8f3ba8332cc4a7c32a64cf0df6f67b32a3dd3"}], "stats": {"total": 784, "additions": 379, "deletions": 405}, "files": [{"sha": "579853446525e61d2fa6f9f982cf5fad48dfac0a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 26, "deletions": 32, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1576de0ce6b75fd177eca289a2826d0190e407a5", "patch": "@@ -56,12 +56,7 @@ impl<'b> Resolver<'b> {\n     pub fn build_reduced_graph(&mut self, krate: &Crate) {\n         let no_implicit_prelude = attr::contains_name(&krate.attrs, \"no_implicit_prelude\");\n         self.graph_root.no_implicit_prelude.set(no_implicit_prelude);\n-\n-        let mut visitor = BuildReducedGraphVisitor {\n-            parent: self.graph_root,\n-            resolver: self,\n-        };\n-        visit::walk_crate(&mut visitor, krate);\n+        visit::walk_crate(&mut BuildReducedGraphVisitor { resolver: self }, krate);\n     }\n \n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n@@ -84,11 +79,11 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_ref: &mut Module<'b>) {\n-        let parent = *parent_ref;\n+    fn build_reduced_graph_for_item(&mut self, item: &Item) {\n+        let parent = self.current_module;\n+        let parent_vis = self.current_vis;\n         let name = item.ident.name;\n         let sp = item.span;\n-        self.current_module = parent;\n         let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n@@ -130,8 +125,7 @@ impl<'b> Resolver<'b> {\n \n                         let subclass = ImportDirectiveSubclass::single(binding.name, source_name);\n                         let span = view_path.span;\n-                        parent.add_import_directive(module_path, subclass, span, item.id, vis);\n-                        self.unresolved_imports += 1;\n+                        self.add_import_directive(module_path, subclass, span, item.id, vis);\n                     }\n                     ViewPathList(_, ref source_items) => {\n                         // Make sure there's at most one `mod` import in the list.\n@@ -176,15 +170,13 @@ impl<'b> Resolver<'b> {\n                             };\n                             let subclass = ImportDirectiveSubclass::single(rename, name);\n                             let (span, id) = (source_item.span, source_item.node.id());\n-                            parent.add_import_directive(module_path, subclass, span, id, vis);\n-                            self.unresolved_imports += 1;\n+                            self.add_import_directive(module_path, subclass, span, id, vis);\n                         }\n                     }\n                     ViewPathGlob(_) => {\n                         let subclass = GlobImport { is_prelude: is_prelude };\n                         let span = view_path.span;\n-                        parent.add_import_directive(module_path, subclass, span, item.id, vis);\n-                        self.unresolved_imports += 1;\n+                        self.add_import_directive(module_path, subclass, span, item.id, vis);\n                     }\n                 }\n             }\n@@ -216,7 +208,10 @@ impl<'b> Resolver<'b> {\n                 });\n                 self.define(parent, name, TypeNS, (module, sp, vis));\n                 self.module_map.insert(item.id, module);\n-                *parent_ref = module;\n+\n+                // Descend into the module.\n+                self.current_module = module;\n+                self.current_vis = ty::Visibility::Restricted(item.id);\n             }\n \n             ItemKind::ForeignMod(..) => {}\n@@ -309,6 +304,10 @@ impl<'b> Resolver<'b> {\n             }\n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n+\n+        visit::walk_item(&mut BuildReducedGraphVisitor { resolver: self }, item);\n+        self.current_module = parent;\n+        self.current_vis = parent_vis;\n     }\n \n     // Constructs the reduced graph for one variant. Variants exist in the\n@@ -333,9 +332,8 @@ impl<'b> Resolver<'b> {\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n-    fn build_reduced_graph_for_foreign_item(&mut self,\n-                                            foreign_item: &ForeignItem,\n-                                            parent: Module<'b>) {\n+    fn build_reduced_graph_for_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+        let parent = self.current_module;\n         let name = foreign_item.ident.name;\n \n         let def = match foreign_item.node {\n@@ -346,12 +344,12 @@ impl<'b> Resolver<'b> {\n                 Def::Static(self.definitions.local_def_id(foreign_item.id), m)\n             }\n         };\n-        self.current_module = parent;\n         let vis = self.resolve_visibility(&foreign_item.vis);\n         self.define(parent, name, ValueNS, (def, foreign_item.span, vis));\n     }\n \n-    fn build_reduced_graph_for_block(&mut self, block: &Block, parent: &mut Module<'b>) {\n+    fn build_reduced_graph_for_block(&mut self, block: &Block) {\n+        let parent = self.current_module;\n         if self.block_needs_anonymous_module(block) {\n             let block_id = block.id;\n \n@@ -362,8 +360,11 @@ impl<'b> Resolver<'b> {\n             let parent_link = BlockParentLink(parent, block_id);\n             let new_module = self.new_module(parent_link, None, false);\n             self.module_map.insert(block_id, new_module);\n-            *parent = new_module;\n+            self.current_module = new_module; // Descend into the block.\n         }\n+\n+        visit::walk_block(&mut BuildReducedGraphVisitor { resolver: self }, block);\n+        self.current_module = parent;\n     }\n \n     /// Builds the reduced graph for a single item in an external crate.\n@@ -487,25 +488,18 @@ impl<'b> Resolver<'b> {\n \n struct BuildReducedGraphVisitor<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n-    parent: Module<'b>,\n }\n \n impl<'a, 'b> Visitor for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &Item) {\n-        let old_parent = self.parent;\n-        self.resolver.build_reduced_graph_for_item(item, &mut self.parent);\n-        visit::walk_item(self, item);\n-        self.parent = old_parent;\n+        self.resolver.build_reduced_graph_for_item(item);\n     }\n \n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n-        self.resolver.build_reduced_graph_for_foreign_item(foreign_item, &self.parent);\n+        self.resolver.build_reduced_graph_for_foreign_item(foreign_item);\n     }\n \n     fn visit_block(&mut self, block: &Block) {\n-        let old_parent = self.parent;\n-        self.resolver.build_reduced_graph_for_block(block, &mut self.parent);\n-        visit::walk_block(self, block);\n-        self.parent = old_parent;\n+        self.resolver.build_reduced_graph_for_block(block);\n     }\n }"}, {"sha": "0c0582edcc051220bf24335c24bdb0b818ffdeae", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 56, "deletions": 97, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1576de0ce6b75fd177eca289a2826d0190e407a5", "patch": "@@ -758,11 +758,10 @@ pub struct ModuleS<'a> {\n     extern_crate_id: Option<NodeId>,\n \n     resolutions: RefCell<HashMap<(Name, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    unresolved_imports: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     no_implicit_prelude: Cell<bool>,\n \n-    glob_importers: RefCell<Vec<(Module<'a>, &'a ImportDirective<'a>)>>,\n+    glob_importers: RefCell<Vec<&'a ImportDirective<'a>>>,\n     globs: RefCell<Vec<&'a ImportDirective<'a>>>,\n \n     // Used to memoize the traits in this module for faster searches through all traits in scope.\n@@ -772,29 +771,22 @@ pub struct ModuleS<'a> {\n     // access the children must be preceded with a\n     // `populate_module_if_necessary` call.\n     populated: Cell<bool>,\n-\n-    arenas: &'a ResolverArenas<'a>,\n }\n \n pub type Module<'a> = &'a ModuleS<'a>;\n \n impl<'a> ModuleS<'a> {\n-    fn new(parent_link: ParentLink<'a>,\n-           def: Option<Def>,\n-           external: bool,\n-           arenas: &'a ResolverArenas<'a>) -> Self {\n+    fn new(parent_link: ParentLink<'a>, def: Option<Def>, external: bool) -> Self {\n         ModuleS {\n             parent_link: parent_link,\n             def: def,\n             extern_crate_id: None,\n             resolutions: RefCell::new(HashMap::new()),\n-            unresolved_imports: RefCell::new(Vec::new()),\n             no_implicit_prelude: Cell::new(false),\n             glob_importers: RefCell::new(Vec::new()),\n             globs: RefCell::new((Vec::new())),\n             traits: RefCell::new(None),\n             populated: Cell::new(!external),\n-            arenas: arenas\n         }\n     }\n \n@@ -971,12 +963,19 @@ pub struct Resolver<'a> {\n \n     structs: FnvHashMap<DefId, Vec<Name>>,\n \n-    // The number of imports that are currently unresolved.\n-    unresolved_imports: usize,\n+    // All imports known to succeed or fail.\n+    determined_imports: Vec<&'a ImportDirective<'a>>,\n+\n+    // All non-determined imports.\n+    indeterminate_imports: Vec<&'a ImportDirective<'a>>,\n \n     // The module that represents the current item scope.\n     current_module: Module<'a>,\n \n+    // The visibility of `pub(self)` items in the current scope.\n+    // Equivalently, the visibility required for an item to be accessible from the current scope.\n+    current_vis: ty::Visibility,\n+\n     // The current set of local scopes, for values.\n     // FIXME #4948: Reuse ribs to avoid allocation.\n     value_ribs: Vec<Rib<'a>>,\n@@ -1140,7 +1139,7 @@ impl<'a> Resolver<'a> {\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n         let graph_root =\n-            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false, arenas);\n+            ModuleS::new(NoParentLink, Some(Def::Mod(root_def_id)), false);\n         let graph_root = arenas.alloc_module(graph_root);\n         let mut module_map = NodeMap();\n         module_map.insert(CRATE_NODE_ID, graph_root);\n@@ -1159,9 +1158,11 @@ impl<'a> Resolver<'a> {\n             trait_item_map: FnvHashMap(),\n             structs: FnvHashMap(),\n \n-            unresolved_imports: 0,\n+            determined_imports: Vec::new(),\n+            indeterminate_imports: Vec::new(),\n \n             current_module: graph_root,\n+            current_vis: ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n             value_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             type_ribs: vec![Rib::new(ModuleRibKind(graph_root))],\n             label_ribs: Vec::new(),\n@@ -1205,6 +1206,7 @@ impl<'a> Resolver<'a> {\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         self.current_module = self.graph_root;\n+        self.current_vis = ty::Visibility::Restricted(ast::CRATE_NODE_ID);\n         visit::walk_crate(self, krate);\n \n         check_unused::check_crate(self, krate);\n@@ -1213,12 +1215,12 @@ impl<'a> Resolver<'a> {\n \n     fn new_module(&self, parent_link: ParentLink<'a>, def: Option<Def>, external: bool)\n                   -> Module<'a> {\n-        self.arenas.alloc_module(ModuleS::new(parent_link, def, external, self.arenas))\n+        self.arenas.alloc_module(ModuleS::new(parent_link, def, external))\n     }\n \n     fn new_extern_crate_module(&self, parent_link: ParentLink<'a>, def: Def, local_node_id: NodeId)\n                                -> Module<'a> {\n-        let mut module = ModuleS::new(parent_link, Some(def), false, self.arenas);\n+        let mut module = ModuleS::new(parent_link, Some(def), false);\n         module.extern_crate_id = Some(local_node_id);\n         self.arenas.modules.alloc(module)\n     }\n@@ -1250,14 +1252,15 @@ impl<'a> Resolver<'a> {\n                                      mut search_module: Module<'a>,\n                                      module_path: &[Name],\n                                      index: usize,\n-                                     span: Span)\n+                                     span: Option<Span>)\n                                      -> ResolveResult<Module<'a>> {\n-        fn search_parent_externals(needle: Name, module: Module) -> Option<Module> {\n-            match module.resolve_name(needle, TypeNS, false) {\n+        fn search_parent_externals<'a>(this: &mut Resolver<'a>, needle: Name, module: Module<'a>)\n+                                       -> Option<Module<'a>> {\n+            match this.resolve_name_in_module(module, needle, TypeNS, false, None) {\n                 Success(binding) if binding.is_extern_crate() => Some(module),\n                 _ => match module.parent_link {\n                     ModuleParentLink(ref parent, _) => {\n-                        search_parent_externals(needle, parent)\n+                        search_parent_externals(this, needle, parent)\n                     }\n                     _ => None,\n                 },\n@@ -1272,16 +1275,17 @@ impl<'a> Resolver<'a> {\n         // modules as we go.\n         while index < module_path_len {\n             let name = module_path[index];\n-            match self.resolve_name_in_module(search_module, name, TypeNS, false, true) {\n+            match self.resolve_name_in_module(search_module, name, TypeNS, false, span) {\n                 Failed(None) => {\n                     let segment_name = name.as_str();\n                     let module_name = module_to_string(search_module);\n                     let msg = if \"???\" == &module_name {\n-                        match search_parent_externals(name, &self.current_module) {\n+                        let current_module = self.current_module;\n+                        match search_parent_externals(self, name, current_module) {\n                             Some(module) => {\n                                 let path_str = names_to_string(module_path);\n                                 let target_mod_str = module_to_string(&module);\n-                                let current_mod_str = module_to_string(&self.current_module);\n+                                let current_mod_str = module_to_string(current_module);\n \n                                 let prefix = if target_mod_str == current_mod_str {\n                                     \"self::\".to_string()\n@@ -1297,7 +1301,7 @@ impl<'a> Resolver<'a> {\n                         format!(\"Could not find `{}` in `{}`\", segment_name, module_name)\n                     };\n \n-                    return Failed(Some((span, msg)));\n+                    return Failed(span.map(|span| (span, msg)));\n                 }\n                 Failed(err) => return Failed(err),\n                 Indeterminate => {\n@@ -1310,11 +1314,10 @@ impl<'a> Resolver<'a> {\n                     // Check to see whether there are type bindings, and, if\n                     // so, whether there is a module within.\n                     if let Some(module_def) = binding.module() {\n-                        self.check_privacy(name, binding, span);\n                         search_module = module_def;\n                     } else {\n                         let msg = format!(\"Not a module `{}`\", name);\n-                        return Failed(Some((span, msg)));\n+                        return Failed(span.map(|span| (span, msg)));\n                     }\n                 }\n             }\n@@ -1330,7 +1333,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_module_path(&mut self,\n                            module_path: &[Name],\n                            use_lexical_scope: UseLexicalScopeFlag,\n-                           span: Span)\n+                           span: Option<Span>)\n                            -> ResolveResult<Module<'a>> {\n         if module_path.len() == 0 {\n             return Success(self.graph_root) // Use the crate root\n@@ -1367,7 +1370,7 @@ impl<'a> Resolver<'a> {\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n                         let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n-                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, true)\n+                        match self.resolve_ident_in_lexical_scope(ident, TypeNS, span)\n                                   .and_then(LexicalScopeBinding::module) {\n                             None => return Failed(None),\n                             Some(containing_module) => {\n@@ -1384,10 +1387,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.resolve_module_path_from_root(search_module,\n-                                           module_path,\n-                                           start_index,\n-                                           span)\n+        self.resolve_module_path_from_root(search_module, module_path, start_index, span)\n     }\n \n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n@@ -1410,7 +1410,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_ident_in_lexical_scope(&mut self,\n                                       mut ident: ast::Ident,\n                                       ns: Namespace,\n-                                      record_used: bool)\n+                                      record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n             ident = ast::Ident::with_empty_ctxt(ident.name);\n@@ -1438,8 +1438,8 @@ impl<'a> Resolver<'a> {\n                 if module.def.is_some() {\n                     return match self.prelude {\n                         Some(prelude) if !module.no_implicit_prelude.get() => {\n-                            prelude.resolve_name(name, ns, false).success()\n-                                   .map(LexicalScopeBinding::Item)\n+                            self.resolve_name_in_module(prelude, name, ns, false, None).success()\n+                                .map(LexicalScopeBinding::Item)\n                         }\n                         _ => None,\n                     };\n@@ -1491,7 +1491,7 @@ impl<'a> Resolver<'a> {\n     /// Resolves a \"module prefix\". A module prefix is one or both of (a) `self::`;\n     /// (b) some chain of `super::`.\n     /// grammar: (SELF MOD_SEP ) ? (SUPER MOD_SEP) *\n-    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Span)\n+    fn resolve_module_prefix(&mut self, module_path: &[Name], span: Option<Span>)\n                              -> ResolveResult<ModulePrefixResult<'a>> {\n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n@@ -1510,7 +1510,7 @@ impl<'a> Resolver<'a> {\n             match self.get_nearest_normal_module_parent(containing_module) {\n                 None => {\n                     let msg = \"There are too many initial `super`s.\".into();\n-                    return Failed(Some((span, msg)));\n+                    return Failed(span.map(|span| (span, msg)));\n                 }\n                 Some(new_module) => {\n                     containing_module = new_module;\n@@ -1525,27 +1525,6 @@ impl<'a> Resolver<'a> {\n         return Success(PrefixFound(containing_module, i));\n     }\n \n-    /// Attempts to resolve the supplied name in the given module for the\n-    /// given namespace. If successful, returns the binding corresponding to\n-    /// the name.\n-    fn resolve_name_in_module(&mut self,\n-                              module: Module<'a>,\n-                              name: Name,\n-                              namespace: Namespace,\n-                              use_lexical_scope: bool,\n-                              record_used: bool)\n-                              -> ResolveResult<&'a NameBinding<'a>> {\n-        debug!(\"(resolving name in module) resolving `{}` in `{}`\", name, module_to_string(module));\n-\n-        self.populate_module_if_necessary(module);\n-        module.resolve_name(name, namespace, use_lexical_scope).and_then(|binding| {\n-            if record_used {\n-                self.record_use(name, namespace, binding);\n-            }\n-            Success(binding)\n-        })\n-    }\n-\n     // AST resolution\n     //\n     // We maintain a list of value ribs and type ribs.\n@@ -1570,13 +1549,15 @@ impl<'a> Resolver<'a> {\n         let module = self.module_map.get(&id).cloned(); // clones a reference\n         if let Some(module) = module {\n             // Move down in the graph.\n-            let orig_module = ::std::mem::replace(&mut self.current_module, module);\n+            let orig_module = replace(&mut self.current_module, module);\n+            let orig_vis = replace(&mut self.current_vis, ty::Visibility::Restricted(id));\n             self.value_ribs.push(Rib::new(ModuleRibKind(module)));\n             self.type_ribs.push(Rib::new(ModuleRibKind(module)));\n \n             f(self);\n \n             self.current_module = orig_module;\n+            self.current_vis = orig_vis;\n             self.value_ribs.pop();\n             self.type_ribs.pop();\n         } else {\n@@ -2314,7 +2295,7 @@ impl<'a> Resolver<'a> {\n                 PatKind::Ident(bmode, ref ident, ref opt_pat) => {\n                     // First try to resolve the identifier as some existing\n                     // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, false)\n+                    let binding = self.resolve_ident_in_lexical_scope(ident.node, ValueNS, None)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.and_then(NameBinding::def).and_then(|def| {\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n@@ -2481,11 +2462,11 @@ impl<'a> Resolver<'a> {\n             //\n             // Such behavior is required for backward compatibility.\n             // The same fallback is used when `a` resolves to nothing.\n-            let def = resolve_identifier_with_fallback(self, true).ok_or(false);\n+            let def = resolve_identifier_with_fallback(self, Some(span)).ok_or(false);\n             return def.and_then(|def| self.adjust_local_def(def, span).ok_or(true)).map(mk_res);\n         }\n \n-        let unqualified_def = resolve_identifier_with_fallback(self, false);\n+        let unqualified_def = resolve_identifier_with_fallback(self, None);\n         let qualified_binding = self.resolve_module_relative_path(span, segments, namespace);\n         match (qualified_binding, unqualified_def) {\n             (Ok(binding), Some(ref ud)) if binding.def().unwrap() == ud.def => {\n@@ -2505,7 +2486,7 @@ impl<'a> Resolver<'a> {\n     fn resolve_identifier(&mut self,\n                           identifier: ast::Ident,\n                           namespace: Namespace,\n-                          record_used: bool)\n+                          record_used: Option<Span>)\n                           -> Option<LocalDef> {\n         if identifier.name == keywords::Invalid.name() {\n             return None;\n@@ -2619,7 +2600,7 @@ impl<'a> Resolver<'a> {\n                                   .collect::<Vec<_>>();\n \n         let containing_module;\n-        match self.resolve_module_path(&module_path, UseLexicalScope, span) {\n+        match self.resolve_module_path(&module_path, UseLexicalScope, Some(span)) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -2640,11 +2621,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let name = segments.last().unwrap().identifier.name;\n-        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n-        result.success().map(|binding| {\n-            self.check_privacy(name, binding, span);\n-            binding\n-        }).ok_or(false)\n+        let result =\n+            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        result.success().ok_or(false)\n     }\n \n     /// Invariant: This must be called only during main resolution, not during\n@@ -2658,10 +2637,7 @@ impl<'a> Resolver<'a> {\n         let root_module = self.graph_root;\n \n         let containing_module;\n-        match self.resolve_module_path_from_root(root_module,\n-                                                 &module_path,\n-                                                 0,\n-                                                 span) {\n+        match self.resolve_module_path_from_root(root_module, &module_path, 0, Some(span)) {\n             Failed(err) => {\n                 let (span, msg) = match err {\n                     Some((span, msg)) => (span, msg),\n@@ -2684,11 +2660,9 @@ impl<'a> Resolver<'a> {\n         }\n \n         let name = segments.last().unwrap().name();\n-        let result = self.resolve_name_in_module(containing_module, name, namespace, false, true);\n-        result.success().map(|binding| {\n-            self.check_privacy(name, binding, span);\n-            binding\n-        }).ok_or(false)\n+        let result =\n+            self.resolve_name_in_module(containing_module, name, namespace, false, Some(span));\n+        result.success().ok_or(false)\n     }\n \n     fn with_no_errors<T, F>(&mut self, f: F) -> T\n@@ -2716,7 +2690,6 @@ impl<'a> Resolver<'a> {\n     fn with_empty_ribs<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut Resolver<'a>) -> T,\n     {\n-        use ::std::mem::replace;\n         let value_ribs = replace(&mut self.value_ribs, Vec::new());\n         let type_ribs = replace(&mut self.type_ribs, Vec::new());\n         let label_ribs = replace(&mut self.label_ribs, Vec::new());\n@@ -2941,7 +2914,7 @@ impl<'a> Resolver<'a> {\n \n                                     match self.resolve_module_path(&name_path[..],\n                                                                    UseLexicalScope,\n-                                                                   expr.span) {\n+                                                                   Some(expr.span)) {\n                                         Success(e) => {\n                                             if let Some(def_type) = e.def {\n                                                 def = def_type;\n@@ -3274,18 +3247,12 @@ impl<'a> Resolver<'a> {\n             ast::Visibility::Public => return ty::Visibility::Public,\n             ast::Visibility::Crate(_) => return ty::Visibility::Restricted(ast::CRATE_NODE_ID),\n             ast::Visibility::Restricted { ref path, id } => (path, id),\n-            ast::Visibility::Inherited => {\n-                let current_module =\n-                    self.get_nearest_normal_module_parent_or_self(self.current_module);\n-                let id =\n-                    self.definitions.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n-                return ty::Visibility::Restricted(id);\n-            }\n+            ast::Visibility::Inherited => return self.current_vis,\n         };\n \n         let segments: Vec<_> = path.segments.iter().map(|seg| seg.identifier.name).collect();\n         let mut path_resolution = err_path_resolution();\n-        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, path.span) {\n+        let vis = match self.resolve_module_path(&segments, DontUseLexicalScope, Some(path.span)) {\n             Success(module) => {\n                 let def = module.def.unwrap();\n                 path_resolution = PathResolution::new(def);\n@@ -3309,15 +3276,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn is_accessible(&self, vis: ty::Visibility) -> bool {\n-        let current_module = self.get_nearest_normal_module_parent_or_self(self.current_module);\n-        let node_id = self.definitions.as_local_node_id(current_module.def_id().unwrap()).unwrap();\n-        vis.is_accessible_from(node_id, self)\n-    }\n-\n-    fn check_privacy(&mut self, name: Name, binding: &'a NameBinding<'a>, span: Span) {\n-        if !self.is_accessible(binding.vis) {\n-            self.privacy_errors.push(PrivacyError(span, name, binding));\n-        }\n+        vis.is_at_least(self.current_vis, self)\n     }\n \n     fn report_privacy_errors(&self) {"}, {"sha": "c0a9ee1c48380e957ea9c07118da18b91ee3dfbf", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 295, "deletions": 273, "changes": 568, "blob_url": "https://github.com/rust-lang/rust/blob/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1576de0ce6b75fd177eca289a2826d0190e407a5", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use self::Determinacy::*;\n use self::ImportDirectiveSubclass::*;\n \n use Module;\n@@ -36,25 +37,31 @@ impl<'a> Resolver<'a> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub enum Determinacy {\n+    Determined,\n+    Undetermined,\n+}\n+\n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n-pub enum ImportDirectiveSubclass {\n+pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n         target: Name,\n         source: Name,\n-        type_determined: Cell<bool>,\n-        value_determined: Cell<bool>,\n+        value_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n+        type_result: Cell<Result<&'a NameBinding<'a>, Determinacy>>,\n     },\n     GlobImport { is_prelude: bool },\n }\n \n-impl ImportDirectiveSubclass {\n+impl<'a> ImportDirectiveSubclass<'a> {\n     pub fn single(target: Name, source: Name) -> Self {\n         SingleImport {\n             target: target,\n             source: source,\n-            type_determined: Cell::new(false),\n-            value_determined: Cell::new(false),\n+            type_result: Cell::new(Err(Undetermined)),\n+            value_result: Cell::new(Err(Undetermined)),\n         }\n     }\n }\n@@ -63,11 +70,12 @@ impl ImportDirectiveSubclass {\n #[derive(Debug,Clone)]\n pub struct ImportDirective<'a> {\n     pub id: NodeId,\n+    parent: Module<'a>,\n     module_path: Vec<Name>,\n-    target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n-    subclass: ImportDirectiveSubclass,\n+    imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    subclass: ImportDirectiveSubclass<'a>,\n     span: Span,\n-    vis: ty::Visibility, // see note in ImportResolutionPerNamespace about how to use this\n+    vis: Cell<ty::Visibility>,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -132,119 +140,145 @@ impl<'a> NameResolution<'a> {\n             _ => None, // The binding could be shadowed by a single import, so it is not known.\n         })\n     }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    fn resolution(&self, module: Module<'a>, name: Name, ns: Namespace)\n+                  -> &'a RefCell<NameResolution<'a>> {\n+        *module.resolutions.borrow_mut().entry((name, ns))\n+               .or_insert_with(|| self.arenas.alloc_name_resolution())\n+    }\n+\n+    /// Attempts to resolve the supplied name in the given module for the given namespace.\n+    /// If successful, returns the binding corresponding to the name.\n+    /// Invariant: if `record_used` is `Some`, import resolution must be complete.\n+    pub fn resolve_name_in_module(&mut self,\n+                                  module: Module<'a>,\n+                                  name: Name,\n+                                  ns: Namespace,\n+                                  allow_private_imports: bool,\n+                                  record_used: Option<Span>)\n+                                  -> ResolveResult<&'a NameBinding<'a>> {\n+        self.populate_module_if_necessary(module);\n+\n+        let resolution = self.resolution(module, name, ns);\n+        let resolution = match resolution.borrow_state() {\n+            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n+            _ => return Failed(None), // This happens when there is a cycle of imports\n+        };\n+\n+        let is_disallowed_private_import = |binding: &NameBinding| {\n+            !allow_private_imports && !binding.is_pseudo_public() && binding.is_import()\n+        };\n+\n+        if let Some(span) = record_used {\n+            if let Some(binding) = resolution.binding {\n+                if is_disallowed_private_import(binding) {\n+                    return Failed(None);\n+                }\n+                self.record_use(name, ns, binding);\n+                if !self.is_accessible(binding.vis) {\n+                    self.privacy_errors.push(PrivacyError(span, name, binding));\n+                }\n+            }\n+\n+            return resolution.binding.map(Success).unwrap_or(Failed(None));\n+        }\n+\n+        // If the resolution doesn't depend on glob definability, check privacy and return.\n+        if let Some(result) = self.try_result(&resolution, ns) {\n+            return result.and_then(|binding| {\n+                if self.is_accessible(binding.vis) && !is_disallowed_private_import(binding) {\n+                    Success(binding)\n+                } else {\n+                    Failed(None)\n+                }\n+            });\n+        }\n+\n+        // Check if the globs are determined\n+        for directive in module.globs.borrow().iter() {\n+            if self.is_accessible(directive.vis.get()) {\n+                if let Some(module) = directive.imported_module.get() {\n+                    let result = self.resolve_name_in_module(module, name, ns, true, None);\n+                    if let Indeterminate = result {\n+                        return Indeterminate;\n+                    }\n+                } else {\n+                    return Indeterminate;\n+                }\n+            }\n+        }\n+\n+        Failed(None)\n+    }\n \n     // Returns Some(the resolution of the name), or None if the resolution depends\n     // on whether more globs can define the name.\n-    fn try_result(&self, ns: Namespace, allow_private_imports: bool)\n+    fn try_result(&mut self, resolution: &NameResolution<'a>, ns: Namespace)\n                   -> Option<ResolveResult<&'a NameBinding<'a>>> {\n-        match self.binding {\n+        match resolution.binding {\n             Some(binding) if !binding.is_glob_import() =>\n-                return Some(Success(binding)),\n-            _ => {} // Items and single imports are not shadowable\n+                return Some(Success(binding)), // Items and single imports are not shadowable.\n+            _ => {}\n         };\n \n         // Check if a single import can still define the name.\n-        match self.single_imports {\n-            SingleImports::None => {},\n+        match resolution.single_imports {\n             SingleImports::AtLeastOne => return Some(Indeterminate),\n-            SingleImports::MaybeOne(directive) => {\n-                // If (1) we don't allow private imports, (2) no public single import can define\n-                // the name, and (3) no public glob has defined the name, the resolution depends\n-                // on whether more globs can define the name.\n-                if !allow_private_imports && directive.vis != ty::Visibility::Public &&\n-                   !self.binding.map(NameBinding::is_pseudo_public).unwrap_or(false) {\n-                    return None;\n-                }\n-\n-                let target_module = match directive.target_module.get() {\n-                    Some(target_module) => target_module,\n+            SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n+                let module = match directive.imported_module.get() {\n+                    Some(module) => module,\n                     None => return Some(Indeterminate),\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     GlobImport { .. } => unreachable!(),\n                 };\n-                match target_module.resolve_name(name, ns, false) {\n+                match self.resolve_name_in_module(module, name, ns, true, None) {\n                     Failed(_) => {}\n                     _ => return Some(Indeterminate),\n                 }\n             }\n+            SingleImports::MaybeOne(_) | SingleImports::None => {},\n         }\n \n-        self.binding.map(Success)\n-    }\n-}\n-\n-impl<'a> ::ModuleS<'a> {\n-    fn resolution(&self, name: Name, ns: Namespace) -> &'a RefCell<NameResolution<'a>> {\n-        *self.resolutions.borrow_mut().entry((name, ns))\n-             .or_insert_with(|| self.arenas.alloc_name_resolution())\n+        resolution.binding.map(Success)\n     }\n \n-    pub fn resolve_name(&self, name: Name, ns: Namespace, allow_private_imports: bool)\n-                        -> ResolveResult<&'a NameBinding<'a>> {\n-        let resolution = self.resolution(name, ns);\n-        let resolution = match resolution.borrow_state() {\n-            ::std::cell::BorrowState::Unused => resolution.borrow_mut(),\n-            _ => return Failed(None), // This happens when there is a cycle of imports\n-        };\n-\n-        if let Some(result) = resolution.try_result(ns, allow_private_imports) {\n-            // If the resolution doesn't depend on glob definability, check privacy and return.\n-            return result.and_then(|binding| {\n-                let allowed = allow_private_imports || !binding.is_import() ||\n-                                                       binding.is_pseudo_public();\n-                if allowed { Success(binding) } else { Failed(None) }\n-            });\n-        }\n-\n-        // Check if the globs are determined\n-        for directive in self.globs.borrow().iter() {\n-            if !allow_private_imports && directive.vis != ty::Visibility::Public { continue }\n-            match directive.target_module.get() {\n-                None => return Indeterminate,\n-                Some(target_module) => match target_module.resolve_name(name, ns, false) {\n-                    Indeterminate => return Indeterminate,\n-                    _ => {}\n-                }\n-            }\n-        }\n-\n-        Failed(None)\n-    }\n-\n-    pub fn add_import_directive(&self,\n+    // Add an import directive to the current module.\n+    pub fn add_import_directive(&mut self,\n                                 module_path: Vec<Name>,\n-                                subclass: ImportDirectiveSubclass,\n+                                subclass: ImportDirectiveSubclass<'a>,\n                                 span: Span,\n                                 id: NodeId,\n                                 vis: ty::Visibility) {\n+        let current_module = self.current_module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n+            parent: current_module,\n             module_path: module_path,\n-            target_module: Cell::new(None),\n+            imported_module: Cell::new(None),\n             subclass: subclass,\n             span: span,\n             id: id,\n-            vis: vis,\n+            vis: Cell::new(vis),\n         });\n \n-        self.unresolved_imports.borrow_mut().push(directive);\n+        self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, .. } => {\n                 for &ns in &[ValueNS, TypeNS] {\n-                    self.resolution(target, ns).borrow_mut().single_imports\n-                                                            .add_directive(directive);\n+                    let mut resolution = self.resolution(current_module, target, ns).borrow_mut();\n+                    resolution.single_imports.add_directive(directive);\n                 }\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n             GlobImport { is_prelude: true } => {}\n-            GlobImport { .. } => self.globs.borrow_mut().push(directive),\n+            GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n         }\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     // Given a binding and an import directive that resolves to it,\n     // return the corresponding binding defined by the import directive.\n     fn import(&mut self, binding: &'a NameBinding<'a>, directive: &'a ImportDirective<'a>)\n@@ -255,7 +289,7 @@ impl<'a> Resolver<'a> {\n                 directive: directive,\n             },\n             span: directive.span,\n-            vis: directive.vis,\n+            vis: directive.vis.get(),\n         }\n     }\n \n@@ -291,7 +325,7 @@ impl<'a> Resolver<'a> {\n         // Ensure that `resolution` isn't borrowed when defining in the module's glob importers,\n         // during which the resolution might end up getting re-defined via a glob cycle.\n         let (new_binding, t) = {\n-            let mut resolution = &mut *module.resolution(name, ns).borrow_mut();\n+            let mut resolution = &mut *self.resolution(module, name, ns).borrow_mut();\n             let was_known = resolution.binding().is_some();\n \n             let t = f(self, resolution);\n@@ -305,24 +339,16 @@ impl<'a> Resolver<'a> {\n \n         // Define `new_binding` in `module`s glob importers.\n         if new_binding.is_importable() && new_binding.is_pseudo_public() {\n-            for &(importer, directive) in module.glob_importers.borrow_mut().iter() {\n+            for directive in module.glob_importers.borrow_mut().iter() {\n                 let imported_binding = self.import(new_binding, directive);\n-                let _ = self.try_define(importer, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n         }\n \n         t\n     }\n }\n \n-struct ImportResolvingError<'a> {\n-    /// Module where the error happened\n-    source_module: Module<'a>,\n-    import_directive: &'a ImportDirective<'a>,\n-    span: Span,\n-    help: String,\n-}\n-\n struct ImportResolver<'a, 'b: 'a> {\n     resolver: &'a mut Resolver<'b>,\n }\n@@ -355,55 +381,74 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     // remain or unsuccessfully when no forward progress in resolving imports\n     // is made.\n \n+    fn set_current_module(&mut self, module: Module<'b>) {\n+        self.current_module = module;\n+        self.current_vis = ty::Visibility::Restricted({\n+            let normal_module = self.get_nearest_normal_module_parent_or_self(module);\n+            self.definitions.as_local_node_id(normal_module.def_id().unwrap()).unwrap()\n+        });\n+    }\n+\n     /// Resolves all imports for the crate. This method performs the fixed-\n     /// point iteration.\n     fn resolve_imports(&mut self) {\n         let mut i = 0;\n-        let mut prev_unresolved_imports = 0;\n-        let mut errors = Vec::new();\n+        let mut prev_num_indeterminates = self.indeterminate_imports.len() + 1;\n \n-        loop {\n-            debug!(\"(resolving imports) iteration {}, {} imports left\", i, self.unresolved_imports);\n+        while self.indeterminate_imports.len() < prev_num_indeterminates {\n+            prev_num_indeterminates = self.indeterminate_imports.len();\n+            debug!(\"(resolving imports) iteration {}, {} imports left\", i, prev_num_indeterminates);\n \n-            // Attempt to resolve imports in all local modules.\n-            for module in self.arenas.local_modules().iter() {\n-                self.current_module = module;\n-                self.resolve_imports_in_current_module(&mut errors);\n-            }\n+            let mut imports = Vec::new();\n+            ::std::mem::swap(&mut imports, &mut self.indeterminate_imports);\n \n-            if self.unresolved_imports == 0 {\n-                debug!(\"(resolving imports) success\");\n-                for module in self.arenas.local_modules().iter() {\n-                    self.finalize_resolutions_in(module, false);\n+            for import in imports {\n+                match self.resolve_import(&import) {\n+                    Failed(_) => self.determined_imports.push(import),\n+                    Indeterminate => self.indeterminate_imports.push(import),\n+                    Success(()) => self.determined_imports.push(import),\n                 }\n-                break;\n             }\n \n-            if self.unresolved_imports == prev_unresolved_imports {\n-                // resolving failed\n-                // Report unresolved imports only if no hard error was already reported\n-                // to avoid generating multiple errors on the same import.\n-                // Imports that are still indeterminate at this point are actually blocked\n-                // by errored imports, so there is no point reporting them.\n-                for module in self.arenas.local_modules().iter() {\n-                    self.finalize_resolutions_in(module, errors.len() == 0);\n-                }\n-                for e in errors {\n-                    self.import_resolving_error(e)\n-                }\n-                break;\n+            i += 1;\n+        }\n+\n+        for module in self.arenas.local_modules().iter() {\n+            self.finalize_resolutions_in(module);\n+        }\n+\n+        let mut errors = false;\n+        for i in 0 .. self.determined_imports.len() {\n+            let import = self.determined_imports[i];\n+            if let Failed(err) = self.finalize_import(import) {\n+                errors = true;\n+                let (span, help) = match err {\n+                    Some((span, msg)) => (span, format!(\". {}\", msg)),\n+                    None => (import.span, String::new()),\n+                };\n+\n+                // If the error is a single failed import then create a \"fake\" import\n+                // resolution for it so that later resolve stages won't complain.\n+                self.import_dummy_binding(import);\n+                let path = import_path_to_string(&import.module_path, &import.subclass);\n+                let error = ResolutionError::UnresolvedImport(Some((&path, &help)));\n+                resolve_error(self.resolver, span, error);\n             }\n+        }\n \n-            i += 1;\n-            prev_unresolved_imports = self.unresolved_imports;\n+        // Report unresolved imports only if no hard error was already reported\n+        // to avoid generating multiple errors on the same import.\n+        if !errors {\n+            if let Some(import) = self.indeterminate_imports.iter().next() {\n+                let error = ResolutionError::UnresolvedImport(None);\n+                resolve_error(self.resolver, import.span, error);\n+            }\n         }\n     }\n \n     // Define a \"dummy\" resolution containing a Def::Err as a placeholder for a\n     // failed resolution\n-    fn import_dummy_binding(&mut self,\n-                            source_module: Module<'b>,\n-                            directive: &'b ImportDirective<'b>) {\n+    fn import_dummy_binding(&mut self, directive: &'b ImportDirective<'b>) {\n         if let SingleImport { target, .. } = directive.subclass {\n             let dummy_binding = self.arenas.alloc_name_binding(NameBinding {\n                 kind: NameBindingKind::Def(Def::Err),\n@@ -412,51 +457,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             });\n             let dummy_binding = self.import(dummy_binding, directive);\n \n-            let _ = self.try_define(source_module, target, ValueNS, dummy_binding.clone());\n-            let _ = self.try_define(source_module, target, TypeNS, dummy_binding);\n-        }\n-    }\n-\n-    /// Resolves an `ImportResolvingError` into the correct enum discriminant\n-    /// and passes that on to `resolve_error`.\n-    fn import_resolving_error(&mut self, e: ImportResolvingError<'b>) {\n-        // If the error is a single failed import then create a \"fake\" import\n-        // resolution for it so that later resolve stages won't complain.\n-        self.import_dummy_binding(e.source_module, e.import_directive);\n-        let path = import_path_to_string(&e.import_directive.module_path,\n-                                         &e.import_directive.subclass);\n-        resolve_error(self.resolver,\n-                      e.span,\n-                      ResolutionError::UnresolvedImport(Some((&path, &e.help))));\n-    }\n-\n-    /// Attempts to resolve imports for the given module only.\n-    fn resolve_imports_in_current_module(&mut self, errors: &mut Vec<ImportResolvingError<'b>>) {\n-        let mut imports = Vec::new();\n-        let mut unresolved_imports = self.current_module.unresolved_imports.borrow_mut();\n-        ::std::mem::swap(&mut imports, &mut unresolved_imports);\n-\n-        for import_directive in imports {\n-            match self.resolve_import(&import_directive) {\n-                Failed(err) => {\n-                    let (span, help) = match err {\n-                        Some((span, msg)) => (span, format!(\". {}\", msg)),\n-                        None => (import_directive.span, String::new()),\n-                    };\n-                    errors.push(ImportResolvingError {\n-                        source_module: self.current_module,\n-                        import_directive: import_directive,\n-                        span: span,\n-                        help: help,\n-                    });\n-                }\n-                Indeterminate => unresolved_imports.push(import_directive),\n-                Success(()) => {\n-                    // Decrement the count of unresolved imports.\n-                    assert!(self.unresolved_imports >= 1);\n-                    self.unresolved_imports -= 1;\n-                }\n-            }\n+            let _ = self.try_define(directive.parent, target, ValueNS, dummy_binding.clone());\n+            let _ = self.try_define(directive.parent, target, TypeNS, dummy_binding);\n         }\n     }\n \n@@ -470,126 +472,164 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n \n-        let target_module = match directive.target_module.get() {\n-            Some(module) => module,\n-            _ => match self.resolve_module_path(&directive.module_path,\n-                                                DontUseLexicalScope,\n-                                                directive.span) {\n+        self.set_current_module(directive.parent);\n+\n+        let module = if let Some(module) = directive.imported_module.get() {\n+            module\n+        } else {\n+            let vis = directive.vis.get();\n+            // For better failure detection, pretend that the import will not define any names\n+            // while resolving its module path.\n+            directive.vis.set(ty::Visibility::PrivateExternal);\n+            let result =\n+                self.resolve_module_path(&directive.module_path, DontUseLexicalScope, None);\n+            directive.vis.set(vis);\n+\n+            match result {\n                 Success(module) => module,\n                 Indeterminate => return Indeterminate,\n                 Failed(err) => return Failed(err),\n-            },\n+            }\n         };\n \n-        directive.target_module.set(Some(target_module));\n-        let (source, target, value_determined, type_determined) = match directive.subclass {\n-            SingleImport { source, target, ref value_determined, ref type_determined } =>\n-                (source, target, value_determined, type_determined),\n-            GlobImport { .. } => return self.resolve_glob_import(target_module, directive),\n+        directive.imported_module.set(Some(module));\n+        let (source, target, value_result, type_result) = match directive.subclass {\n+            SingleImport { source, target, ref value_result, ref type_result } =>\n+                (source, target, value_result, type_result),\n+            GlobImport { .. } => {\n+                self.resolve_glob_import(directive);\n+                return Success(());\n+            }\n         };\n \n-        // We need to resolve both namespaces for this to succeed.\n-        let value_result = self.resolve_name_in_module(target_module, source, ValueNS, false, true);\n-        let type_result = self.resolve_name_in_module(target_module, source, TypeNS, false, true);\n-\n-        let module = self.current_module;\n-        let mut privacy_error = true;\n-        for &(ns, result, determined) in &[(ValueNS, &value_result, value_determined),\n-                                           (TypeNS, &type_result, type_determined)] {\n-            match *result {\n-                Failed(..) if !determined.get() => {\n-                    determined.set(true);\n-                    self.update_resolution(module, target, ns, |_, resolution| {\n+        let mut indeterminate = false;\n+        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n+            if let Err(Undetermined) = result.get() {\n+                result.set({\n+                    match self.resolve_name_in_module(module, source, ns, false, None) {\n+                        Success(binding) => Ok(binding),\n+                        Indeterminate => Err(Undetermined),\n+                        Failed(_) => Err(Determined),\n+                    }\n+                });\n+            } else {\n+                continue\n+            };\n+\n+            match result.get() {\n+                Err(Undetermined) => indeterminate = true,\n+                Err(Determined) => {\n+                    self.update_resolution(directive.parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n-                Success(binding) if !binding.is_importable() => {\n+                Ok(binding) if !binding.is_importable() => {\n                     let msg = format!(\"`{}` is not directly importable\", target);\n                     struct_span_err!(self.session, directive.span, E0253, \"{}\", &msg)\n                         .span_label(directive.span, &format!(\"cannot be imported directly\"))\n                         .emit();\n                     // Do not import this illegal binding. Import a dummy binding and pretend\n                     // everything is fine\n-                    self.import_dummy_binding(module, directive);\n+                    self.import_dummy_binding(directive);\n                     return Success(());\n                 }\n-                Success(binding) if !self.is_accessible(binding.vis) => {}\n-                Success(binding) if !determined.get() => {\n-                    determined.set(true);\n+                Ok(binding) => {\n                     let imported_binding = self.import(binding, directive);\n-                    let conflict = self.try_define(module, target, ns, imported_binding);\n+                    let conflict = self.try_define(directive.parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         let binding = &self.import(binding, directive);\n-                        self.report_conflict(module, target, ns, binding, old_binding);\n+                        self.report_conflict(directive.parent, target, ns, binding, old_binding);\n                     }\n-                    privacy_error = false;\n                 }\n-                Success(_) => privacy_error = false,\n-                _ => {}\n             }\n         }\n \n-        match (&value_result, &type_result) {\n-            (&Indeterminate, _) | (_, &Indeterminate) => return Indeterminate,\n-            (&Failed(_), &Failed(_)) => {\n-                let resolutions = target_module.resolutions.borrow();\n-                let names = resolutions.iter().filter_map(|(&(ref name, _), resolution)| {\n-                    if *name == source { return None; } // Never suggest the same name\n+        if indeterminate { Indeterminate } else { Success(()) }\n+    }\n+\n+    fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> ResolveResult<()> {\n+        self.set_current_module(directive.parent);\n+\n+        let ImportDirective { ref module_path, span, .. } = *directive;\n+        let module_result = self.resolve_module_path(&module_path, DontUseLexicalScope, Some(span));\n+        let module = match module_result {\n+            Success(module) => module,\n+            Indeterminate => return Indeterminate,\n+            Failed(err) => return Failed(err),\n+        };\n+\n+        let (name, value_result, type_result) = match directive.subclass {\n+            SingleImport { source, ref value_result, ref type_result, .. } =>\n+                (source, value_result.get(), type_result.get()),\n+            GlobImport { .. } if module.def_id() == directive.parent.def_id() => {\n+                // Importing a module into itself is not allowed.\n+                let msg = \"Cannot glob-import a module into itself.\".into();\n+                return Failed(Some((directive.span, msg)));\n+            }\n+            GlobImport { .. } => return Success(()),\n+        };\n+\n+        for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n+            if let Ok(binding) = result {\n+                self.record_use(name, ns, binding);\n+            }\n+        }\n+\n+        if value_result.is_err() && type_result.is_err() {\n+            let (value_result, type_result);\n+            value_result = self.resolve_name_in_module(module, name, ValueNS, false, Some(span));\n+            type_result = self.resolve_name_in_module(module, name, TypeNS, false, Some(span));\n+\n+            return if let (Failed(_), Failed(_)) = (value_result, type_result) {\n+                let resolutions = module.resolutions.borrow();\n+                let names = resolutions.iter().filter_map(|(&(ref n, _), resolution)| {\n+                    if *n == name { return None; } // Never suggest the same name\n                     match *resolution.borrow() {\n-                        NameResolution { binding: Some(_), .. } => Some(name),\n+                        NameResolution { binding: Some(_), .. } => Some(n),\n                         NameResolution { single_imports: SingleImports::None, .. } => None,\n-                        _ => Some(name),\n+                        _ => Some(n),\n                     }\n                 });\n-                let lev_suggestion = match find_best_match_for_name(names, &source.as_str(), None) {\n+                let lev_suggestion = match find_best_match_for_name(names, &name.as_str(), None) {\n                     Some(name) => format!(\". Did you mean to use `{}`?\", name),\n                     None => \"\".to_owned(),\n                 };\n-                let module_str = module_to_string(target_module);\n+                let module_str = module_to_string(module);\n                 let msg = if &module_str == \"???\" {\n-                    format!(\"There is no `{}` in the crate root{}\", source, lev_suggestion)\n+                    format!(\"There is no `{}` in the crate root{}\", name, lev_suggestion)\n                 } else {\n-                    format!(\"There is no `{}` in `{}`{}\", source, module_str, lev_suggestion)\n+                    format!(\"There is no `{}` in `{}`{}\", name, module_str, lev_suggestion)\n                 };\n-                return Failed(Some((directive.span, msg)));\n-            }\n-            _ => (),\n-        }\n-\n-        if privacy_error {\n-            for &(ns, result) in &[(ValueNS, &value_result), (TypeNS, &type_result)] {\n-                let binding = match *result { Success(binding) => binding, _ => continue };\n-                self.privacy_errors.push(PrivacyError(directive.span, source, binding));\n-                let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(module, target, ns, imported_binding);\n+                Failed(Some((directive.span, msg)))\n+            } else {\n+                // `resolve_name_in_module` reported a privacy error.\n+                self.import_dummy_binding(directive);\n+                Success(())\n             }\n         }\n \n-        match (&value_result, &type_result) {\n-            (&Success(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n-                                      self.is_accessible(binding.vis) => {\n-                let msg = format!(\"`{}` is private, and cannot be reexported\", source);\n-                let note_msg = format!(\"consider marking `{}` as `pub` in the imported module\",\n-                                        source);\n+        match (value_result, type_result) {\n+            (Ok(binding), _) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n+                let msg = format!(\"`{}` is private, and cannot be reexported\", name);\n+                let note_msg =\n+                    format!(\"consider marking `{}` as `pub` in the imported module\", name);\n                 struct_span_err!(self.session, directive.span, E0364, \"{}\", &msg)\n                     .span_note(directive.span, &note_msg)\n                     .emit();\n             }\n \n-            (_, &Success(binding)) if !binding.pseudo_vis().is_at_least(directive.vis, self) &&\n-                                      self.is_accessible(binding.vis) => {\n+            (_, Ok(binding)) if !binding.pseudo_vis().is_at_least(directive.vis.get(), self) => {\n                 if binding.is_extern_crate() {\n                     let msg = format!(\"extern crate `{}` is private, and cannot be reexported \\\n                                        (error E0364), consider declaring with `pub`\",\n-                                       source);\n+                                       name);\n                     self.session.add_lint(PRIVATE_IN_PUBLIC, directive.id, directive.span, msg);\n                 } else {\n-                    let mut err = struct_span_err!(self.session, directive.span, E0365,\n-                                                     \"`{}` is private, and cannot be reexported\",\n-                                                     source);\n-                    err.span_label(directive.span, &format!(\"reexport of private `{}`\", source));\n-                    err.note(&format!(\"consider declaring type or module `{}` with `pub`\", source));\n-                    err.emit();\n+                    struct_span_err!(self.session, directive.span, E0365,\n+                                     \"`{}` is private, and cannot be reexported\", name)\n+                        .span_label(directive.span, &format!(\"reexport of private `{}`\", name))\n+                        .note(&format!(\"consider declaring type or module `{}` with `pub`\", name))\n+                        .emit();\n                 }\n             }\n \n@@ -599,9 +639,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        let def = match type_result.success().and_then(NameBinding::def) {\n+        let def = match type_result.ok().and_then(NameBinding::def) {\n             Some(def) => def,\n-            None => value_result.success().and_then(NameBinding::def).unwrap(),\n+            None => value_result.ok().and_then(NameBinding::def).unwrap(),\n         };\n         let path_resolution = PathResolution::new(def);\n         self.def_map.insert(directive.id, path_resolution);\n@@ -610,57 +650,46 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         return Success(());\n     }\n \n-    // Resolves a glob import. Note that this function cannot fail; it either\n-    // succeeds or bails out (as importing * from an empty module or a module\n-    // that exports nothing is valid). target_module is the module we are\n-    // actually importing, i.e., `foo` in `use foo::*`.\n-    fn resolve_glob_import(&mut self, target_module: Module<'b>, directive: &'b ImportDirective<'b>)\n-                           -> ResolveResult<()> {\n-        if let Some(Def::Trait(_)) = target_module.def {\n-            self.session.span_err(directive.span, \"items in traits are not importable.\");\n-        }\n+    fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n+        let module = directive.imported_module.get().unwrap();\n+        self.populate_module_if_necessary(module);\n \n-        let module = self.current_module;\n-        if module.def_id() == target_module.def_id() {\n-            // This means we are trying to glob import a module into itself, and it is a no-go\n-            let msg = \"Cannot glob-import a module into itself.\".into();\n-            return Failed(Some((directive.span, msg)));\n+        if let Some(Def::Trait(_)) = module.def {\n+            self.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n-        self.populate_module_if_necessary(target_module);\n \n-        if let GlobImport { is_prelude: true } = directive.subclass {\n-            self.prelude = Some(target_module);\n-            return Success(());\n+        if module.def_id() == directive.parent.def_id()  {\n+            return;\n+        } else if let GlobImport { is_prelude: true } = directive.subclass {\n+            self.prelude = Some(module);\n+            return;\n         }\n \n-        // Add to target_module's glob_importers\n-        target_module.glob_importers.borrow_mut().push((module, directive));\n+        // Add to module's glob_importers\n+        module.glob_importers.borrow_mut().push(directive);\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = target_module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n+        let bindings = module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(module, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = target_module.def_id() {\n+        if let Some(did) = module.def_id() {\n             let resolution = PathResolution::new(Def::Mod(did));\n             self.def_map.insert(directive.id, resolution);\n         }\n-\n-        debug!(\"(resolving glob import) successfully resolved import\");\n-        return Success(());\n     }\n \n     // Miscellaneous post-processing, including recording reexports, reporting conflicts,\n     // reporting the PRIVATE_IN_PUBLIC lint, and reporting unresolved imports.\n-    fn finalize_resolutions_in(&mut self, module: Module<'b>, report_unresolved_imports: bool) {\n+    fn finalize_resolutions_in(&mut self, module: Module<'b>) {\n         // Since import resolution is finished, globs will not define any more names.\n         *module.globs.borrow_mut() = Vec::new();\n \n@@ -708,13 +737,6 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 self.export_map.insert(node_id, reexports);\n             }\n         }\n-\n-        if report_unresolved_imports {\n-            for import in module.unresolved_imports.borrow().iter() {\n-                resolve_error(self.resolver, import.span, ResolutionError::UnresolvedImport(None));\n-                break;\n-            }\n-        }\n     }\n }\n "}, {"sha": "9c0a2267d7cf89f758d492c7ad50fdda9938fd5b", "filename": "src/test/compile-fail/task-rng-isnt-sendable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftask-rng-isnt-sendable.rs?ref=1576de0ce6b75fd177eca289a2826d0190e407a5", "patch": "@@ -16,5 +16,4 @@ fn test_send<S: Send>() {}\n \n pub fn main() {\n     test_send::<rand::ThreadRng>();\n-    //~^ ERROR : std::marker::Send` is not satisfied\n }"}, {"sha": "a40fa2337214ee8f135294ad88c3c8672f463496", "filename": "src/test/compile-fail/use-from-trait-xc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1576de0ce6b75fd177eca289a2826d0190e407a5/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuse-from-trait-xc.rs?ref=1576de0ce6b75fd177eca289a2826d0190e407a5", "patch": "@@ -21,10 +21,10 @@ use use_from_trait_xc::Trait::Assoc;\n use use_from_trait_xc::Trait::CONST;\n //~^ ERROR `CONST` is not directly importable\n \n-use use_from_trait_xc::Foo::new;\n+use use_from_trait_xc::Foo::new; //~ ERROR struct `Foo` is private\n //~^ ERROR unresolved import `use_from_trait_xc::Foo::new`\n \n-use use_from_trait_xc::Foo::C;\n+use use_from_trait_xc::Foo::C; //~ ERROR struct `Foo` is private\n //~^ ERROR unresolved import `use_from_trait_xc::Foo::C`\n \n use use_from_trait_xc::Bar::new as bnew;"}]}