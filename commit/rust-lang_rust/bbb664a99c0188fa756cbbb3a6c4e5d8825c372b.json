{"sha": "bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYjY2NGE5OWMwMTg4ZmE3NTZjYmJiM2E2YzRlNWQ4ODI1YzM3MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-28T17:30:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-28T17:30:24Z"}, "message": "Auto merge of #66642 - ecstatic-morse:promotion-in-const, r=eddyb\n\nCreate promoted MIR fragments for `const` and `static`s\n\nResolves #65732.\n\nThe previous strategy of removing `Drop` and `StorageDead` for promoted locals only worked for rvalue lifetime extension and only if no `loop`s were present. This PR applies the approach currently used for `fn` and `const fn`s to `const` and `statics`.\n\nThis may have some performance impacts.\n\nr? @eddyb", "tree": {"sha": "494cd4de8851dc0bae103a4f8e9f8293348e4fc3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/494cd4de8851dc0bae103a4f8e9f8293348e4fc3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "html_url": "https://github.com/rust-lang/rust/commit/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f453d1127d9095cf3c3356655d9e8502ceeb8373", "url": "https://api.github.com/repos/rust-lang/rust/commits/f453d1127d9095cf3c3356655d9e8502ceeb8373", "html_url": "https://github.com/rust-lang/rust/commit/f453d1127d9095cf3c3356655d9e8502ceeb8373"}, {"sha": "f9ed2199ff5a69b88d43949c138042a42ecd98b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ed2199ff5a69b88d43949c138042a42ecd98b5", "html_url": "https://github.com/rust-lang/rust/commit/f9ed2199ff5a69b88d43949c138042a42ecd98b5"}], "stats": {"total": 177, "additions": 48, "deletions": 129}, "files": [{"sha": "d927ac27fd7aee1f7e17de83ed0d752f9434656b", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 4, "deletions": 100, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "patch": "@@ -24,7 +24,6 @@ use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc_index::vec::{IndexVec, Idx};\n-use rustc_index::bit_set::HybridBitSet;\n use rustc_target::spec::abi::Abi;\n \n use std::cell::Cell;\n@@ -35,10 +34,8 @@ use crate::transform::check_consts::{qualifs, Item, ConstKind, is_lang_panic_fn}\n \n /// A `MirPass` for promotion.\n ///\n-/// In this case, \"promotion\" entails the following:\n-/// - Extract promotable temps in `fn` and `const fn` into their own MIR bodies.\n-/// - Extend lifetimes in `const` and `static` by removing `Drop` and `StorageDead`.\n-/// - Emit errors if the requirements of `#[rustc_args_required_const]` are not met.\n+/// Promotion is the extraction of promotable temps into separate MIR bodies. This pass also emits\n+/// errors when promotion of `#[rustc_args_required_const]` arguments fails.\n ///\n /// After this pass is run, `promoted_fragments` will hold the MIR body corresponding to each\n /// newly created `StaticKind::Promoted`.\n@@ -63,26 +60,13 @@ impl<'tcx> MirPass<'tcx> for PromoteTemps<'tcx> {\n \n         let def_id = src.def_id();\n \n-        let item = Item::new(tcx, def_id, body);\n         let mut rpo = traversal::reverse_postorder(body);\n         let (temps, all_candidates) = collect_temps_and_candidates(tcx, body, &mut rpo);\n \n         let promotable_candidates = validate_candidates(tcx, body, def_id, &temps, &all_candidates);\n \n-        // For now, lifetime extension is done in `const` and `static`s without creating promoted\n-        // MIR fragments by removing `Drop` and `StorageDead` for each referent. However, this will\n-        // not work inside loops when they are allowed in `const`s.\n-        //\n-        // FIXME: use promoted MIR fragments everywhere?\n-        let promoted_fragments = if should_create_promoted_mir_fragments(item.const_kind) {\n-            promote_candidates(def_id, body, tcx, temps, promotable_candidates)\n-        } else {\n-            // FIXME: promote const array initializers in consts.\n-            remove_drop_and_storage_dead_on_promoted_locals(tcx, body, &promotable_candidates);\n-            IndexVec::new()\n-        };\n-\n-        self.promoted_fragments.set(promoted_fragments);\n+        let promoted = promote_candidates(def_id, body, tcx, temps, promotable_candidates);\n+        self.promoted_fragments.set(promoted);\n     }\n }\n \n@@ -1178,83 +1162,3 @@ crate fn should_suggest_const_in_array_repeat_expressions_attribute<'tcx>(\n             should_promote={:?} feature_flag={:?}\", mir_def_id, should_promote, feature_flag);\n     should_promote && !feature_flag\n }\n-\n-fn should_create_promoted_mir_fragments(const_kind: Option<ConstKind>) -> bool {\n-    match const_kind {\n-        Some(ConstKind::ConstFn) | None => true,\n-        Some(ConstKind::Const) | Some(ConstKind::Static) | Some(ConstKind::StaticMut) => false,\n-    }\n-}\n-\n-/// In `const` and `static` everything without `StorageDead`\n-/// is `'static`, we don't have to create promoted MIR fragments,\n-/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n-fn remove_drop_and_storage_dead_on_promoted_locals(\n-    tcx: TyCtxt<'tcx>,\n-    body: &mut Body<'tcx>,\n-    promotable_candidates: &[Candidate],\n-) {\n-    debug!(\"run_pass: promotable_candidates={:?}\", promotable_candidates);\n-\n-    // Removing `StorageDead` will cause errors for temps declared inside a loop body. For now we\n-    // simply skip promotion if a loop exists, since loops are not yet allowed in a `const`.\n-    //\n-    // FIXME: Just create MIR fragments for `const`s instead of using this hackish approach?\n-    if body.is_cfg_cyclic() {\n-        tcx.sess.delay_span_bug(body.span, \"Control-flow cycle detected in `const`\");\n-        return;\n-    }\n-\n-    // The underlying local for promotion contexts like `&temp` and `&(temp.proj)`.\n-    let mut requires_lifetime_extension = HybridBitSet::new_empty(body.local_decls.len());\n-\n-    promotable_candidates\n-        .iter()\n-        .filter_map(|c| {\n-            match c {\n-                Candidate::Ref(loc) => Some(loc),\n-                Candidate::Repeat(_) | Candidate::Argument { .. } => None,\n-            }\n-        })\n-        .map(|&Location { block, statement_index }| {\n-            // FIXME: store the `Local` for each `Candidate` when it is created.\n-            let place = match &body[block].statements[statement_index].kind {\n-                StatementKind::Assign(box ( _, Rvalue::Ref(_, _, place))) => place,\n-                _ => bug!(\"`Candidate::Ref` without corresponding assignment\"),\n-            };\n-\n-            match place.base {\n-                PlaceBase::Local(local) => local,\n-                PlaceBase::Static(_) => bug!(\"`Candidate::Ref` for a non-local\"),\n-            }\n-        })\n-        .for_each(|local| {\n-            requires_lifetime_extension.insert(local);\n-        });\n-\n-    // Remove `Drop` terminators and `StorageDead` statements for all promotable temps that require\n-    // lifetime extension.\n-    for block in body.basic_blocks_mut() {\n-        block.statements.retain(|statement| {\n-            match statement.kind {\n-                StatementKind::StorageDead(index) => !requires_lifetime_extension.contains(index),\n-                _ => true\n-            }\n-        });\n-        let terminator = block.terminator_mut();\n-        match &terminator.kind {\n-            TerminatorKind::Drop {\n-                location,\n-                target,\n-                ..\n-            } => {\n-                if let Some(index) = location.as_local() {\n-                    if requires_lifetime_extension.contains(index) {\n-                        terminator.kind = TerminatorKind::Goto { target: *target };\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-    }\n-}"}, {"sha": "68a9227dea96ed4dd22549b440f5271099744495", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/const-fns.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f453d1127d9095cf3c3356655d9e8502ceeb8373/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Fconst-fns.rs?ref=f453d1127d9095cf3c3356655d9e8502ceeb8373", "patch": "@@ -1,26 +0,0 @@\n-// ignore-tidy-linelength\n-// ignore-compare-mode-nll\n-#![feature(const_in_array_repeat_expressions, nll)]\n-#![allow(warnings)]\n-\n-// Some type that is not copyable.\n-struct Bar;\n-\n-const fn type_no_copy() -> Option<Bar> {\n-    None\n-}\n-\n-const fn type_copy() -> u32 {\n-    3\n-}\n-\n-fn no_copy() {\n-    const ARR: [Option<Bar>; 2] = [type_no_copy(); 2];\n-    //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied [E0277]\n-}\n-\n-fn copy() {\n-    const ARR: [u32; 2] = [type_copy(); 2];\n-}\n-\n-fn main() {}"}, {"sha": "da1bae1be8d4eeebf07800a3cc4a7ef48fc2b1f8", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/fn-call-in-const.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-const.rs?ref=bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "patch": "@@ -0,0 +1,23 @@\n+// run-pass\n+\n+#![allow(unused)]\n+#![feature(const_in_array_repeat_expressions)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+const fn type_no_copy() -> Option<Bar> {\n+    None\n+}\n+\n+const fn type_copy() -> u32 {\n+    3\n+}\n+\n+const _: [u32; 2] = [type_copy(); 2];\n+\n+// This is allowed because all promotion contexts use the explicit rules for promotability when\n+// inside an explicit const context.\n+const _: [Option<Bar>; 2] = [type_no_copy(); 2];\n+\n+fn main() {}"}, {"sha": "38f744e99aab4c3c137edaf17050e0aad54e1dbb", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/fn-call-in-non-const.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-non-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-non-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-non-const.rs?ref=bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "patch": "@@ -0,0 +1,18 @@\n+#![feature(const_in_array_repeat_expressions)]\n+\n+// Some type that is not copyable.\n+struct Bar;\n+\n+const fn no_copy() -> Option<Bar> {\n+    None\n+}\n+\n+const fn copy() -> u32 {\n+    3\n+}\n+\n+fn main() {\n+    let _: [u32; 2] = [copy(); 2];\n+    let _: [Option<Bar>; 2] = [no_copy(); 2];\n+    //~^ ERROR the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n+}"}, {"sha": "8219d836a20e9f204bf64e86e4113a229d8f1d25", "filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/fn-call-in-non-const.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-non-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bbb664a99c0188fa756cbbb3a6c4e5d8825c372b/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-non-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Frfc-2203-const-array-repeat-exprs%2Ffn-call-in-non-const.stderr?ref=bbb664a99c0188fa756cbbb3a6c4e5d8825c372b", "patch": "@@ -1,8 +1,8 @@\n error[E0277]: the trait bound `std::option::Option<Bar>: std::marker::Copy` is not satisfied\n-  --> $DIR/const-fns.rs:18:35\n+  --> $DIR/fn-call-in-non-const.rs:16:31\n    |\n-LL |     const ARR: [Option<Bar>; 2] = [type_no_copy(); 2];\n-   |                                   ^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n+LL |     let _: [Option<Bar>; 2] = [no_copy(); 2];\n+   |                               ^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::option::Option<Bar>`\n    |\n    = help: the following implementations were found:\n              <std::option::Option<T> as std::marker::Copy>", "previous_filename": "src/test/ui/consts/rfc-2203-const-array-repeat-exprs/const-fns.stderr"}]}