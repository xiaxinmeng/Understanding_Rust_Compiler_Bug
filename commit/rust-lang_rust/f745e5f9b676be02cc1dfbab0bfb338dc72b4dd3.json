{"sha": "f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NDVlNWY5YjY3NmJlMDJjYzFkZmJhYjBiZmIzMzhkYzcyYjRkZDM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-05T08:56:06Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-06-06T11:04:02Z"}, "message": "syntax: Remove duplicate span from `token::Ident`", "tree": {"sha": "a4982d98a51c2f8358495b9b60e3a059a9e9c1cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4982d98a51c2f8358495b9b60e3a059a9e9c1cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "html_url": "https://github.com/rust-lang/rust/commit/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c5d773b4d529c6263f682513ea34ce644a8179b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5d773b4d529c6263f682513ea34ce644a8179b", "html_url": "https://github.com/rust-lang/rust/commit/4c5d773b4d529c6263f682513ea34ce644a8179b"}], "stats": {"total": 365, "additions": 181, "deletions": 184}, "files": [{"sha": "abe4196abd19cc930dc6a1220fe88d7e416013e1", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -353,8 +353,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for token::TokenKind {\n             }\n             token::Literal(lit) => lit.hash_stable(hcx, hasher),\n \n-            token::Ident(ident, is_raw) => {\n-                ident.name.hash_stable(hcx, hasher);\n+            token::Ident(name, is_raw) => {\n+                name.hash_stable(hcx, hasher);\n                 is_raw.hash_stable(hcx, hasher);\n             }\n             token::Lifetime(name) => name.hash_stable(hcx, hasher),"}, {"sha": "281bd72deeb805acc4d01ff5f2c0ae0190567127", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -325,8 +325,8 @@ impl<'a> Classifier<'a> {\n             }\n \n             // Keywords are also included in the identifier set.\n-            token::Ident(ident, is_raw) => {\n-                match ident.name {\n+            token::Ident(name, is_raw) => {\n+                match name {\n                     kw::Ref | kw::Mut if !is_raw => Class::RefKeyWord,\n \n                     kw::SelfLower | kw::SelfUpper => Class::Self_,"}, {"sha": "39ffabaa4a9481e2eb92d55ed7bd62189a679067", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -482,19 +482,19 @@ impl MetaItem {\n         let path = match tokens.next() {\n             Some(TokenTree::Token(Token { kind: kind @ token::Ident(..), span })) |\n             Some(TokenTree::Token(Token { kind: kind @ token::ModSep, span })) => 'arm: {\n-                let mut segments = if let token::Ident(ident, _) = kind {\n+                let mut segments = if let token::Ident(name, _) = kind {\n                     if let Some(TokenTree::Token(Token { kind: token::ModSep, .. })) = tokens.peek() {\n                         tokens.next();\n-                        vec![PathSegment::from_ident(ident.with_span_pos(span))]\n+                        vec![PathSegment::from_ident(Ident::new(name, span))]\n                     } else {\n-                        break 'arm Path::from_ident(ident.with_span_pos(span));\n+                        break 'arm Path::from_ident(Ident::new(name, span));\n                     }\n                 } else {\n                     vec![PathSegment::path_root(span)]\n                 };\n                 loop {\n-                    if let Some(TokenTree::Token(Token { kind: token::Ident(ident, _), span })) = tokens.next() {\n-                        segments.push(PathSegment::from_ident(ident.with_span_pos(span)));\n+                    if let Some(TokenTree::Token(Token { kind: token::Ident(name, _), span })) = tokens.next() {\n+                        segments.push(PathSegment::from_ident(Ident::new(name, span)));\n                     } else {\n                         return None;\n                     }"}, {"sha": "8d9848d98fb21a731007068137dfc9c4739e6133", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -39,7 +39,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n     };\n \n     ecx.parse_sess.registered_diagnostics.with_lock(|diagnostics| {\n-        match diagnostics.get_mut(&code.name) {\n+        match diagnostics.get_mut(&code) {\n             // Previously used errors.\n             Some(&mut ErrorInfo { description: _, use_site: Some(previous_span) }) => {\n                 ecx.struct_span_warn(span, &format!(\n@@ -72,10 +72,10 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n         token_tree.get(1),\n         token_tree.get(2)\n     ) {\n-        (1, Some(&TokenTree::Token(Token { kind: token::Ident(ref code, _), .. })), None, None) => {\n+        (1, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })), None, None) => {\n             (code, None)\n         },\n-        (3, Some(&TokenTree::Token(Token { kind: token::Ident(ref code, _), .. })),\n+        (3, Some(&TokenTree::Token(Token { kind: token::Ident(code, _), .. })),\n             Some(&TokenTree::Token(Token { kind: token::Comma, .. })),\n             Some(&TokenTree::Token(Token { kind: token::Literal(token::Lit { symbol, .. }), .. }))) => {\n             (code, Some(symbol))\n@@ -112,7 +112,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n             description,\n             use_site: None\n         };\n-        if diagnostics.insert(code.name, info).is_some() {\n+        if diagnostics.insert(code, info).is_some() {\n             ecx.span_err(span, &format!(\n                 \"diagnostic code {} already registered\", code\n             ));\n@@ -140,13 +140,13 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                           token_tree: &[TokenTree])\n                                           -> Box<dyn MacResult+'cx> {\n     assert_eq!(token_tree.len(), 3);\n-    let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n+    let (crate_name, ident) = match (&token_tree[0], &token_tree[2]) {\n         (\n             // Crate name.\n-            &TokenTree::Token(Token { kind: token::Ident(ref crate_name, _), .. }),\n+            &TokenTree::Token(Token { kind: token::Ident(crate_name, _), .. }),\n             // DIAGNOSTICS ident.\n-            &TokenTree::Token(Token { kind: token::Ident(ref name, _), .. })\n-        ) => (*&crate_name, name),\n+            &TokenTree::Token(Token { kind: token::Ident(name, _), span })\n+        ) => (crate_name, Ident::new(name, span)),\n         _ => unreachable!()\n     };\n \n@@ -209,7 +209,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n \n     MacEager::items(smallvec![\n         P(ast::Item {\n-            ident: *name,\n+            ident,\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             node: ast::ItemKind::Const("}, {"sha": "3b24837e365986e91777017def8db928411784d8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -269,7 +269,7 @@ impl<F> TTMacroExpander for F\n                     if let token::Interpolated(nt) = &token.kind {\n                         if let token::NtIdent(ident, is_raw) = **nt {\n                             *tt = tokenstream::TokenTree::token(ident.span,\n-                                                                token::Ident(ident, is_raw));\n+                                                                token::Ident(ident.name, is_raw));\n                         }\n                     }\n                 }"}, {"sha": "82cc9e8ac2280ec650b035a5c2d6c7996db40bb3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -74,7 +74,7 @@ pub use NamedMatch::*;\n pub use ParseResult::*;\n use TokenTreeOrTokenTreeSlice::*;\n \n-use crate::ast::Ident;\n+use crate::ast::{Ident, Name};\n use crate::ext::tt::quoted::{self, TokenTree};\n use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::{Parser, PathStyle};\n@@ -429,8 +429,8 @@ pub fn parse_failure_msg(tok: TokenKind) -> String {\n \n /// Performs a token equality check, ignoring syntax context (that is, an unhygienic comparison)\n fn token_name_eq(t1: &TokenKind, t2: &TokenKind) -> bool {\n-    if let (Some((id1, is_raw1)), Some((id2, is_raw2))) = (t1.ident(), t2.ident()) {\n-        id1.name == id2.name && is_raw1 == is_raw2\n+    if let (Some((name1, is_raw1)), Some((name2, is_raw2))) = (t1.ident_name(), t2.ident_name()) {\n+        name1 == name2 && is_raw1 == is_raw2\n     } else if let (Some(name1), Some(name2)) = (t1.lifetime_name(), t2.lifetime_name()) {\n         name1 == name2\n     } else {\n@@ -466,8 +466,7 @@ fn inner_parse_loop<'root, 'tt>(\n     next_items: &mut Vec<MatcherPosHandle<'root, 'tt>>,\n     eof_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n     bb_items: &mut SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n-    token: &TokenKind,\n-    span: syntax_pos::Span,\n+    token: &Token,\n ) -> ParseResult<()> {\n     // Pop items from `cur_items` until it is empty.\n     while let Some(mut item) = cur_items.pop() {\n@@ -510,7 +509,7 @@ fn inner_parse_loop<'root, 'tt>(\n                     // Add matches from this repetition to the `matches` of `up`\n                     for idx in item.match_lo..item.match_hi {\n                         let sub = item.matches[idx].clone();\n-                        let span = DelimSpan::from_pair(item.sp_open, span);\n+                        let span = DelimSpan::from_pair(item.sp_open, token.span);\n                         new_pos.push_match(idx, MatchedSeq(sub, span));\n                     }\n \n@@ -598,7 +597,7 @@ fn inner_parse_loop<'root, 'tt>(\n                 TokenTree::MetaVarDecl(_, _, id) => {\n                     // Built-in nonterminals never start with these tokens,\n                     // so we can eliminate them from consideration.\n-                    if may_begin_with(id.name, token) {\n+                    if may_begin_with(token, id.name) {\n                         bb_items.push(item);\n                     }\n                 }\n@@ -698,7 +697,6 @@ pub fn parse(\n             &mut eof_items,\n             &mut bb_items,\n             &parser.token,\n-            parser.span,\n         ) {\n             Success(_) => {}\n             Failure(token, msg) => return Failure(token, msg),\n@@ -806,10 +804,9 @@ pub fn parse(\n \n /// The token is an identifier, but not `_`.\n /// We prohibit passing `_` to macros expecting `ident` for now.\n-fn get_macro_ident(token: &TokenKind) -> Option<(Ident, bool)> {\n+fn get_macro_name(token: &TokenKind) -> Option<(Name, bool)> {\n     match *token {\n-        token::Ident(ident, is_raw) if ident.name != kw::Underscore =>\n-            Some((ident, is_raw)),\n+        token::Ident(name, is_raw) if name != kw::Underscore => Some((name, is_raw)),\n         _ => None,\n     }\n }\n@@ -818,7 +815,7 @@ fn get_macro_ident(token: &TokenKind) -> Option<(Ident, bool)> {\n ///\n /// Returning `false` is a *stability guarantee* that such a matcher will *never* begin with that\n /// token. Be conservative (return true) if not sure.\n-fn may_begin_with(name: Symbol, token: &TokenKind) -> bool {\n+fn may_begin_with(token: &Token, name: Name) -> bool {\n     /// Checks whether the non-terminal may contain a single (non-keyword) identifier.\n     fn may_be_ident(nt: &token::Nonterminal) -> bool {\n         match *nt {\n@@ -830,14 +827,14 @@ fn may_begin_with(name: Symbol, token: &TokenKind) -> bool {\n     match name {\n         sym::expr => token.can_begin_expr(),\n         sym::ty => token.can_begin_type(),\n-        sym::ident => get_macro_ident(token).is_some(),\n+        sym::ident => get_macro_name(token).is_some(),\n         sym::literal => token.can_begin_literal_or_bool(),\n-        sym::vis => match *token {\n+        sym::vis => match token.kind {\n             // The follow-set of :vis + \"priv\" keyword + interpolated\n             token::Comma | token::Ident(..) | token::Interpolated(_) => true,\n             _ => token.can_begin_type(),\n         },\n-        sym::block => match *token {\n+        sym::block => match token.kind {\n             token::OpenDelim(token::Brace) => true,\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtItem(_)\n@@ -851,15 +848,15 @@ fn may_begin_with(name: Symbol, token: &TokenKind) -> bool {\n             },\n             _ => false,\n         },\n-        sym::path | sym::meta => match *token {\n+        sym::path | sym::meta => match token.kind {\n             token::ModSep | token::Ident(..) => true,\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtPath(_) | token::NtMeta(_) => true,\n                 _ => may_be_ident(&nt),\n             },\n             _ => false,\n         },\n-        sym::pat => match *token {\n+        sym::pat => match token.kind {\n             token::Ident(..) |               // box, ref, mut, and other identifiers (can stricten)\n             token::OpenDelim(token::Paren) |    // tuple pattern\n             token::OpenDelim(token::Bracket) |  // slice pattern\n@@ -875,15 +872,15 @@ fn may_begin_with(name: Symbol, token: &TokenKind) -> bool {\n             token::Interpolated(ref nt) => may_be_ident(nt),\n             _ => false,\n         },\n-        sym::lifetime => match *token {\n+        sym::lifetime => match token.kind {\n             token::Lifetime(_) => true,\n             token::Interpolated(ref nt) => match **nt {\n                 token::NtLifetime(_) | token::NtTT(_) => true,\n                 _ => false,\n             },\n             _ => false,\n         },\n-        _ => match *token {\n+        _ => match token.kind {\n             token::CloseDelim(_) => false,\n             _ => true,\n         },\n@@ -929,10 +926,10 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: Symbol) -> Nonterminal {\n         sym::literal => token::NtLiteral(panictry!(p.parse_literal_maybe_minus())),\n         sym::ty => token::NtTy(panictry!(p.parse_ty())),\n         // this could be handled like a token, since it is one\n-        sym::ident => if let Some((ident, is_raw)) = get_macro_ident(&p.token) {\n+        sym::ident => if let Some((name, is_raw)) = get_macro_name(&p.token) {\n             let span = p.span;\n             p.bump();\n-            token::NtIdent(Ident::new(ident.name, span), is_raw)\n+            token::NtIdent(Ident::new(name, span), is_raw)\n         } else {\n             let token_str = pprust::token_to_string(&p.token);\n             p.fatal(&format!(\"expected ident, found {}\", &token_str)).emit();"}, {"sha": "77f53c35b0b5ed09d370a4596c29c38691aa592a", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -1046,8 +1046,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n                         FatArrow | Comma | Eq | BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == kw::If ||\n-                                           i.name == kw::In => IsInFollow::Yes,\n+                        Ident(name, false) if name == kw::If || name == kw::In => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n                     _ => IsInFollow::No(tokens),\n@@ -1064,8 +1063,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                         OpenDelim(token::DelimToken::Bracket) |\n                         Comma | FatArrow | Colon | Eq | Gt | BinOp(token::Shr) | Semi |\n                         BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == kw::As ||\n-                                           i.name == kw::Where => IsInFollow::Yes,\n+                        Ident(name, false) if name == kw::As ||\n+                                              name == kw::Where => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n                     TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block =>\n@@ -1092,9 +1091,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match tok {\n                     TokenTree::Token(token) => match token.kind {\n                         Comma => IsInFollow::Yes,\n-                        Ident(i, is_raw) if is_raw || i.name != kw::Priv =>\n-                            IsInFollow::Yes,\n-                        ref tok => if tok.can_begin_type() {\n+                        Ident(name, is_raw) if is_raw || name != kw::Priv => IsInFollow::Yes,\n+                        _ => if token.can_begin_type() {\n                             IsInFollow::Yes\n                         } else {\n                             IsInFollow::No(tokens)"}, {"sha": "582d87b911dbcbf7f94a45287cd815537944c4f1", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -323,10 +323,9 @@ where\n             // metavariable that names the crate of the invocation.\n             Some(tokenstream::TokenTree::Token(token)) if token.is_ident() => {\n                 let (ident, is_raw) = token.ident().unwrap();\n-                let span = token.span.with_lo(span.lo());\n+                let span = ident.span.with_lo(span.lo());\n                 if ident.name == kw::Crate && !is_raw {\n-                    let ident = ast::Ident::new(kw::DollarCrate, ident.span);\n-                    TokenTree::token(span, token::Ident(ident, is_raw))\n+                    TokenTree::token(span, token::Ident(kw::DollarCrate, is_raw))\n                 } else {\n                     TokenTree::MetaVar(span, ident)\n                 }"}, {"sha": "7eb88de2281da1bd33fd94ac300246405ede8ecc", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -598,7 +598,6 @@ pub fn noop_visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &m\n // apply ident visitor if it's an ident, apply other visits to interpolated nodes\n pub fn noop_visit_token<T: MutVisitor>(t: &mut TokenKind, vis: &mut T) {\n     match t {\n-        token::Ident(id, _is_raw) => vis.visit_ident(id),\n         token::Interpolated(nt) => {\n             let mut nt = Lrc::make_mut(nt);\n             vis.visit_interpolated(&mut nt);"}, {"sha": "7830b2ce880c2639d32391faf9a5064118c64a7e", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -201,12 +201,12 @@ impl<'a> Parser<'a> {\n             self.span,\n             &format!(\"expected identifier, found {}\", self.this_token_descr()),\n         );\n-        if let token::Ident(ident, false) = &self.token.kind {\n-            if ident.is_raw_guess() {\n+        if let token::Ident(name, false) = self.token.kind {\n+            if Ident::new(name, self.span).is_raw_guess() {\n                 err.span_suggestion(\n                     self.span,\n                     \"you can escape reserved keywords to use them as identifiers\",\n-                    format!(\"r#{}\", ident),\n+                    format!(\"r#{}\", name),\n                     Applicability::MaybeIncorrect,\n                 );\n             }"}, {"sha": "e3d959c2c54c450246716ae233849c6f3b100f18", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -1,4 +1,4 @@\n-use crate::ast::{self, Ident};\n+use crate::ast;\n use crate::parse::ParseSess;\n use crate::parse::token::{self, Token, TokenKind};\n use crate::symbol::{sym, Symbol};\n@@ -61,15 +61,6 @@ impl<'a> StringReader<'a> {\n         (real, raw)\n     }\n \n-    fn mk_ident(&self, string: &str) -> Ident {\n-        let mut ident = Ident::from_str(string);\n-        if let Some(span) = self.override_span {\n-            ident.span = span;\n-        }\n-\n-        ident\n-    }\n-\n     fn unwrap_or_abort(&mut self, res: Result<Token, ()>) -> Token {\n         match res {\n             Ok(tok) => tok,\n@@ -858,17 +849,17 @@ impl<'a> StringReader<'a> {\n \n                 return Ok(self.with_str_from(start, |string| {\n                     // FIXME: perform NFKC normalization here. (Issue #2253)\n-                    let ident = self.mk_ident(string);\n+                    let name = ast::Name::intern(string);\n \n                     if is_raw_ident {\n                         let span = self.mk_sp(raw_start, self.pos);\n-                        if !ident.can_be_raw() {\n-                            self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", ident));\n+                        if !name.can_be_raw() {\n+                            self.err_span(span, &format!(\"`{}` cannot be a raw identifier\", name));\n                         }\n                         self.sess.raw_identifier_spans.borrow_mut().push(span);\n                     }\n \n-                    token::Ident(ident, is_raw_ident)\n+                    token::Ident(name, is_raw_ident)\n                 }));\n             }\n         }\n@@ -1567,12 +1558,11 @@ mod tests {\n                                         &sh,\n                                         \"/* my source file */ fn main() { println!(\\\"zebra\\\"); }\\n\"\n                                             .to_string());\n-            let id = Ident::from_str(\"fn\");\n             assert_eq!(string_reader.next_token(), token::Comment);\n             assert_eq!(string_reader.next_token(), token::Whitespace);\n             let tok1 = string_reader.next_token();\n             let tok2 = Token::new(\n-                token::Ident(id, false),\n+                token::Ident(Symbol::intern(\"fn\"), false),\n                 Span::new(BytePos(21), BytePos(23), NO_EXPANSION),\n             );\n             assert_eq!(tok1.kind, tok2.kind);"}, {"sha": "7b27304071c7f85f922d1fca003ae3e3ee3f0557", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -1,6 +1,6 @@\n //! Code related to parsing literals.\n \n-use crate::ast::{self, Ident, Lit, LitKind};\n+use crate::ast::{self, Lit, LitKind};\n use crate::parse::parser::Parser;\n use crate::parse::PResult;\n use crate::parse::token::{self, Token, TokenKind};\n@@ -230,8 +230,8 @@ impl Lit {\n     /// Converts arbitrary token into an AST literal.\n     crate fn from_token(token: &TokenKind, span: Span) -> Result<Lit, LitError> {\n         let lit = match *token {\n-            token::Ident(ident, false) if ident.name == kw::True || ident.name == kw::False =>\n-                token::Lit::new(token::Bool, ident.name, None),\n+            token::Ident(name, false) if name == kw::True || name == kw::False =>\n+                token::Lit::new(token::Bool, name, None),\n             token::Literal(lit) =>\n                 lit,\n             token::Interpolated(ref nt) => {\n@@ -258,7 +258,7 @@ impl Lit {\n     /// Losslessly convert an AST literal into a token stream.\n     crate fn tokens(&self) -> TokenStream {\n         let token = match self.token.kind {\n-            token::Bool => token::Ident(Ident::new(self.token.symbol, self.span), false),\n+            token::Bool => token::Ident(self.token.symbol, false),\n             _ => token::Literal(self.token),\n         };\n         TokenTree::token(self.span, token).into()"}, {"sha": "2b82767d7e91df7164c5daa381e1a5e99332d1ac", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -382,11 +382,12 @@ impl SeqSep {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::ast::{self, Ident, PatKind};\n+    use crate::ast::{self, Name, PatKind};\n     use crate::attr::first_attr_value_str_by_name;\n     use crate::ptr::P;\n     use crate::parse::token::Token;\n     use crate::print::pprust::item_to_string;\n+    use crate::symbol::{kw, sym};\n     use crate::tokenstream::{DelimSpan, TokenTree};\n     use crate::util::parser_testing::string_to_stream;\n     use crate::util::parser_testing::{string_to_expr, string_to_item};\n@@ -418,8 +419,6 @@ mod tests {\n     #[test]\n     fn string_to_tts_macro () {\n         with_default_globals(|| {\n-            use crate::symbol::sym;\n-\n             let tts: Vec<_> =\n                 string_to_stream(\"macro_rules! zip (($a)=>($a))\".to_string()).trees().collect();\n             let tts: &[TokenTree] = &tts[..];\n@@ -432,8 +431,7 @@ mod tests {\n                     Some(&TokenTree::Token(Token { kind: token::Ident(name_zip, false), .. })),\n                     Some(&TokenTree::Delimited(_, macro_delim, ref macro_tts)),\n                 )\n-                if name_macro_rules.name == sym::macro_rules\n-                && name_zip.name.as_str() == \"zip\" => {\n+                if name_macro_rules == sym::macro_rules && name_zip.as_str() == \"zip\" => {\n                     let tts = &macro_tts.trees().collect::<Vec<_>>();\n                     match (tts.len(), tts.get(0), tts.get(1), tts.get(2)) {\n                         (\n@@ -448,19 +446,19 @@ mod tests {\n                                 (\n                                     2,\n                                     Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token { kind: token::Ident(ident, false), .. })),\n+                                    Some(&TokenTree::Token(Token { kind: token::Ident(name, false), .. })),\n                                 )\n-                                if first_delim == token::Paren && ident.name.as_str() == \"a\" => {},\n+                                if first_delim == token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 3: {:?} {:?}\", first_delim, first_tts),\n                             }\n                             let tts = &second_tts.trees().collect::<Vec<_>>();\n                             match (tts.len(), tts.get(0), tts.get(1)) {\n                                 (\n                                     2,\n                                     Some(&TokenTree::Token(Token { kind: token::Dollar, .. })),\n-                                    Some(&TokenTree::Token(Token { kind: token::Ident(ident, false), .. })),\n+                                    Some(&TokenTree::Token(Token { kind: token::Ident(name, false), .. })),\n                                 )\n-                                if second_delim == token::Paren && ident.name.as_str() == \"a\" => {},\n+                                if second_delim == token::Paren && name.as_str() == \"a\" => {},\n                                 _ => panic!(\"value 4: {:?} {:?}\", second_delim, second_tts),\n                             }\n                         },\n@@ -478,25 +476,22 @@ mod tests {\n             let tts = string_to_stream(\"fn a (b : i32) { b; }\".to_string());\n \n             let expected = TokenStream::new(vec![\n-                TokenTree::token(sp(0, 2), token::Ident(Ident::from_str(\"fn\"), false)).into(),\n-                TokenTree::token(sp(3, 4), token::Ident(Ident::from_str(\"a\"), false)).into(),\n+                TokenTree::token(sp(0, 2), token::Ident(kw::Fn, false)).into(),\n+                TokenTree::token(sp(3, 4), token::Ident(Name::intern(\"a\"), false)).into(),\n                 TokenTree::Delimited(\n                     DelimSpan::from_pair(sp(5, 6), sp(13, 14)),\n                     token::DelimToken::Paren,\n                     TokenStream::new(vec![\n-                        TokenTree::token(sp(6, 7),\n-                                         token::Ident(Ident::from_str(\"b\"), false)).into(),\n+                        TokenTree::token(sp(6, 7), token::Ident(Name::intern(\"b\"), false)).into(),\n                         TokenTree::token(sp(8, 9), token::Colon).into(),\n-                        TokenTree::token(sp(10, 13),\n-                                         token::Ident(Ident::from_str(\"i32\"), false)).into(),\n+                        TokenTree::token(sp(10, 13), token::Ident(sym::i32, false)).into(),\n                     ]).into(),\n                 ).into(),\n                 TokenTree::Delimited(\n                     DelimSpan::from_pair(sp(15, 16), sp(20, 21)),\n                     token::DelimToken::Brace,\n                     TokenStream::new(vec![\n-                        TokenTree::token(sp(17, 18),\n-                                         token::Ident(Ident::from_str(\"b\"), false)).into(),\n+                        TokenTree::token(sp(17, 18), token::Ident(Name::intern(\"b\"), false)).into(),\n                         TokenTree::token(sp(18, 19), token::Semi).into(),\n                     ]).into(),\n                 ).into()\n@@ -604,8 +599,6 @@ mod tests {\n \n     #[test] fn crlf_doc_comments() {\n         with_default_globals(|| {\n-            use crate::symbol::sym;\n-\n             let sess = ParseSess::new(FilePathMapping::empty());\n \n             let name_1 = FileName::Custom(\"crlf_source_1\".to_string());"}, {"sha": "57a49d1524d81cc5a412db136f971ed2a5f72db3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -362,7 +362,7 @@ impl TokenCursor {\n             delim_span,\n             token::Bracket,\n             [\n-                TokenTree::token(sp, token::Ident(ast::Ident::with_empty_ctxt(sym::doc), false)),\n+                TokenTree::token(sp, token::Ident(sym::doc, false)),\n                 TokenTree::token(sp, token::Eq),\n                 TokenTree::token(sp, token::TokenKind::lit(\n                     token::StrRaw(num_of_hashes), Symbol::intern(&stripped), None\n@@ -541,9 +541,9 @@ impl<'a> Parser<'a> {\n \n     crate fn token_descr(&self) -> Option<&'static str> {\n         Some(match &self.token.kind {\n-            t if t.is_special_ident() => \"reserved identifier\",\n-            t if t.is_used_keyword() => \"keyword\",\n-            t if t.is_unused_keyword() => \"reserved keyword\",\n+            _ if self.token.is_special_ident() => \"reserved identifier\",\n+            _ if self.token.is_used_keyword() => \"keyword\",\n+            _ if self.token.is_unused_keyword() => \"reserved keyword\",\n             token::DocComment(..) => \"doc comment\",\n             _ => return None,\n         })\n@@ -619,7 +619,7 @@ impl<'a> Parser<'a> {\n \n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n-            token::Ident(ident, _) => {\n+            token::Ident(name, _) => {\n                 if self.token.is_reserved_ident() {\n                     let mut err = self.expected_ident_found();\n                     if recover {\n@@ -630,7 +630,7 @@ impl<'a> Parser<'a> {\n                 }\n                 let span = self.span;\n                 self.bump();\n-                Ok(Ident::new(ident.name, span))\n+                Ok(Ident::new(name, span))\n             }\n             _ => {\n                 Err(if self.prev_token_kind == PrevTokenKind::DocComment {\n@@ -1618,21 +1618,21 @@ impl<'a> Parser<'a> {\n \n     fn parse_path_segment_ident(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n-            token::Ident(ident, _) if self.token.is_path_segment_keyword() => {\n+            token::Ident(name, _) if name.is_path_segment_keyword() => {\n                 let span = self.span;\n                 self.bump();\n-                Ok(Ident::new(ident.name, span))\n+                Ok(Ident::new(name, span))\n             }\n             _ => self.parse_ident(),\n         }\n     }\n \n     fn parse_ident_or_underscore(&mut self) -> PResult<'a, ast::Ident> {\n         match self.token.kind {\n-            token::Ident(ident, false) if ident.name == kw::Underscore => {\n+            token::Ident(name, false) if name == kw::Underscore => {\n                 let span = self.span;\n                 self.bump();\n-                Ok(Ident::new(ident.name, span))\n+                Ok(Ident::new(name, span))\n             }\n             _ => self.parse_ident(),\n         }\n@@ -2368,13 +2368,11 @@ impl<'a> Parser<'a> {\n             }\n \n             let mut recovery_field = None;\n-            if let token::Ident(ident, _) = self.token.kind {\n+            if let token::Ident(name, _) = self.token.kind {\n                 if !self.token.is_reserved_ident() && self.look_ahead(1, |t| *t == token::Colon) {\n                     // Use in case of error after field-looking code: `S { foo: () with a }`\n-                    let mut ident = ident.clone();\n-                    ident.span = self.span;\n                     recovery_field = Some(ast::Field {\n-                        ident,\n+                        ident: Ident::new(name, self.span),\n                         span: self.span,\n                         expr: self.mk_expr(self.span, ExprKind::Err, ThinVec::new()),\n                         is_shorthand: false,\n@@ -2637,7 +2635,7 @@ impl<'a> Parser<'a> {\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n                 let name = match self.token.kind {\n-                    token::Ident(ident, _) => ident,\n+                    token::Ident(name, _) => name,\n                     _ => unreachable!()\n                 };\n                 let mut err = self.fatal(&format!(\"unknown macro variable `{}`\", name));\n@@ -2651,7 +2649,7 @@ impl<'a> Parser<'a> {\n                 // Interpolated identifier and lifetime tokens are replaced with usual identifier\n                 // and lifetime tokens, so the former are never encountered during normal parsing.\n                 match **nt {\n-                    token::NtIdent(ident, is_raw) => Token::new(token::Ident(ident, is_raw), ident.span),\n+                    token::NtIdent(ident, is_raw) => Token::new(token::Ident(ident.name, is_raw), ident.span),\n                     token::NtLifetime(ident) => Token::new(token::Lifetime(ident.name), ident.span),\n                     _ => return,\n                 }\n@@ -2766,7 +2764,7 @@ impl<'a> Parser<'a> {\n                 let token_cannot_continue_expr = |t: &Token| match t.kind {\n                     // These tokens can start an expression after `!`, but\n                     // can't continue an expression after an ident\n-                    token::Ident(ident, is_raw) => token::ident_can_begin_expr(ident, is_raw),\n+                    token::Ident(name, is_raw) => token::ident_can_begin_expr(name, t.span, is_raw),\n                     token::Literal(..) | token::Pound => true,\n                     token::Interpolated(ref nt) => match **nt {\n                         token::NtIdent(..) | token::NtExpr(..) |\n@@ -4328,7 +4326,7 @@ impl<'a> Parser<'a> {\n                      -> PResult<'a, Option<P<Item>>> {\n         let token_lo = self.span;\n         let (ident, def) = match self.token.kind {\n-            token::Ident(ident, false) if ident.name == kw::Macro => {\n+            token::Ident(name, false) if name == kw::Macro => {\n                 self.bump();\n                 let ident = self.parse_ident()?;\n                 let tokens = if self.check(&token::OpenDelim(token::Brace)) {\n@@ -4356,8 +4354,8 @@ impl<'a> Parser<'a> {\n \n                 (ident, ast::MacroDef { tokens: tokens.into(), legacy: false })\n             }\n-            token::Ident(ident, _) if ident.name == sym::macro_rules &&\n-                                   self.look_ahead(1, |t| *t == token::Not) => {\n+            token::Ident(name, _) if name == sym::macro_rules &&\n+                                     self.look_ahead(1, |t| *t == token::Not) => {\n                 let prev_span = self.prev_span;\n                 self.complain_if_pub_macro(&vis.node, prev_span);\n                 self.bump();\n@@ -5481,8 +5479,8 @@ impl<'a> Parser<'a> {\n     fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token.kind {\n             // Preserve hygienic context.\n-            token::Ident(ident, _) =>\n-                { let span = this.span; this.bump(); Ident::new(ident.name, span) }\n+            token::Ident(name, _) =>\n+                { let span = this.span; this.bump(); Ident::new(name, span) }\n             _ => unreachable!()\n         };\n         let isolated_self = |this: &mut Self, n| {\n@@ -5805,11 +5803,7 @@ impl<'a> Parser<'a> {\n         match *vis {\n             VisibilityKind::Inherited => {}\n             _ => {\n-                let is_macro_rules: bool = match self.token.kind {\n-                    token::Ident(sid, _) => sid.name == sym::macro_rules,\n-                    _ => false,\n-                };\n-                let mut err = if is_macro_rules {\n+                let mut err = if self.token.is_keyword(sym::macro_rules) {\n                     let mut err = self.diagnostic()\n                         .struct_span_err(sp, \"can't qualify macro_rules invocation with `pub`\");\n                     err.span_suggestion("}, {"sha": "ba7c88e700074fdea4d1f6939826a9a5540665ee", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 59, "deletions": 35, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -118,8 +118,8 @@ impl Lit {\n     }\n }\n \n-pub(crate) fn ident_can_begin_expr(ident: ast::Ident, is_raw: bool) -> bool {\n-    let ident_token: TokenKind = Ident(ident, is_raw);\n+pub(crate) fn ident_can_begin_expr(name: ast::Name, span: Span, is_raw: bool) -> bool {\n+    let ident_token = Token::new(Ident(name, is_raw), span);\n \n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n@@ -146,11 +146,11 @@ pub(crate) fn ident_can_begin_expr(ident: ast::Ident, is_raw: bool) -> bool {\n         kw::While,\n         kw::Yield,\n         kw::Static,\n-    ].contains(&ident.name)\n+    ].contains(&name)\n }\n \n-fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n-    let ident_token: TokenKind = Ident(ident, is_raw);\n+fn ident_can_begin_type(name: ast::Name, span: Span, is_raw: bool) -> bool {\n+    let ident_token = Token::new(Ident(name, is_raw), span);\n \n     !ident_token.is_reserved_ident() ||\n     ident_token.is_path_segment_keyword() ||\n@@ -163,7 +163,7 @@ fn ident_can_begin_type(ident: ast::Ident, is_raw: bool) -> bool {\n         kw::Extern,\n         kw::Typeof,\n         kw::Dyn,\n-    ].contains(&ident.name)\n+    ].contains(&name)\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n@@ -210,7 +210,7 @@ pub enum TokenKind {\n     Literal(Lit),\n \n     /* Name components */\n-    Ident(ast::Ident, /* is_raw */ bool),\n+    Ident(ast::Name, /* is_raw */ bool),\n     Lifetime(ast::Name),\n \n     Interpolated(Lrc<Nonterminal>),\n@@ -245,7 +245,7 @@ pub struct Token {\n impl TokenKind {\n     /// Recovers a `TokenKind` from an `ast::Ident`. This creates a raw identifier if necessary.\n     pub fn from_ast_ident(ident: ast::Ident) -> TokenKind {\n-        Ident(ident, ident.is_raw_guess())\n+        Ident(ident.name, ident.is_raw_guess())\n     }\n \n     crate fn is_like_plus(&self) -> bool {\n@@ -254,12 +254,14 @@ impl TokenKind {\n             _ => false,\n         }\n     }\n+}\n \n+impl Token {\n     /// Returns `true` if the token can appear at the start of an expression.\n     crate fn can_begin_expr(&self) -> bool {\n-        match *self {\n-            Ident(ident, is_raw)              =>\n-                ident_can_begin_expr(ident, is_raw), // value name or keyword\n+        match self.kind {\n+            Ident(name, is_raw)              =>\n+                ident_can_begin_expr(name, self.span, is_raw), // value name or keyword\n             OpenDelim(..)                     | // tuple, array or block\n             Literal(..)                       | // literal\n             Not                               | // operator not\n@@ -289,9 +291,9 @@ impl TokenKind {\n \n     /// Returns `true` if the token can appear at the start of a type.\n     crate fn can_begin_type(&self) -> bool {\n-        match *self {\n-            Ident(ident, is_raw)        =>\n-                ident_can_begin_type(ident, is_raw), // type name or keyword\n+        match self.kind {\n+            Ident(name, is_raw)        =>\n+                ident_can_begin_type(name, self.span, is_raw), // type name or keyword\n             OpenDelim(Paren)            | // tuple\n             OpenDelim(Bracket)          | // array\n             Not                         | // never\n@@ -309,7 +311,9 @@ impl TokenKind {\n             _ => false,\n         }\n     }\n+}\n \n+impl TokenKind {\n     /// Returns `true` if the token can appear at the start of a const param.\n     pub fn can_begin_const_arg(&self) -> bool {\n         match self {\n@@ -323,13 +327,17 @@ impl TokenKind {\n             _ => self.can_begin_literal_or_bool(),\n         }\n     }\n+}\n \n+impl Token {\n     /// Returns `true` if the token can appear at the start of a generic bound.\n     crate fn can_begin_bound(&self) -> bool {\n         self.is_path_start() || self.is_lifetime() || self.is_keyword(kw::For) ||\n         self == &Question || self == &OpenDelim(Paren)\n     }\n+}\n \n+impl TokenKind {\n     pub fn lit(kind: LitKind, symbol: Symbol, suffix: Option<Symbol>) -> TokenKind {\n         Literal(Lit::new(kind, symbol, suffix))\n     }\n@@ -355,8 +363,8 @@ impl TokenKind {\n         match *self {\n             Literal(..)  => true,\n             BinOp(Minus) => true,\n-            Ident(ident, false) if ident.name == kw::True => true,\n-            Ident(ident, false) if ident.name == kw::False => true,\n+            Ident(name, false) if name == kw::True => true,\n+            Ident(name, false) if name == kw::False => true,\n             Interpolated(ref nt) => match **nt {\n                 NtLiteral(..) => true,\n                 _             => false,\n@@ -367,6 +375,18 @@ impl TokenKind {\n }\n \n impl Token {\n+    /// Returns an identifier if this token is an identifier.\n+    pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n+        match self.kind {\n+            Ident(name, is_raw) => Some((ast::Ident::new(name, self.span), is_raw)),\n+            Interpolated(ref nt) => match **nt {\n+                NtIdent(ident, is_raw) => Some((ident, is_raw)),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n     /// Returns a lifetime identifier if this token is a lifetime.\n     pub fn lifetime(&self) -> Option<ast::Ident> {\n         match self.kind {\n@@ -381,12 +401,12 @@ impl Token {\n }\n \n impl TokenKind {\n-    /// Returns an identifier if this token is an identifier.\n-    pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n+    /// Returns an identifier name if this token is an identifier.\n+    pub fn ident_name(&self) -> Option<(ast::Name, /* is_raw */ bool)> {\n         match *self {\n-            Ident(ident, is_raw) => Some((ident, is_raw)),\n+            Ident(name, is_raw) => Some((name, is_raw)),\n             Interpolated(ref nt) => match **nt {\n-                NtIdent(ident, is_raw) => Some((ident, is_raw)),\n+                NtIdent(ident, is_raw) => Some((ident.name, is_raw)),\n                 _ => None,\n             },\n             _ => None,\n@@ -405,7 +425,7 @@ impl TokenKind {\n     }\n     /// Returns `true` if the token is an identifier.\n     pub fn is_ident(&self) -> bool {\n-        self.ident().is_some()\n+        self.ident_name().is_some()\n     }\n     /// Returns `true` if the token is a lifetime.\n     crate fn is_lifetime(&self) -> bool {\n@@ -415,10 +435,7 @@ impl TokenKind {\n     /// Returns `true` if the token is a identifier whose name is the given\n     /// string slice.\n     crate fn is_ident_named(&self, name: Symbol) -> bool {\n-        match self.ident() {\n-            Some((ident, _)) => ident.name == name,\n-            None => false\n-        }\n+        self.ident_name().map_or(false, |(ident_name, _)| ident_name == name)\n     }\n \n     /// Returns `true` if the token is an interpolated path.\n@@ -440,24 +457,30 @@ impl TokenKind {\n     crate fn is_qpath_start(&self) -> bool {\n         self == &Lt || self == &BinOp(Shl)\n     }\n+}\n \n+impl Token {\n     crate fn is_path_start(&self) -> bool {\n         self == &ModSep || self.is_qpath_start() || self.is_path() ||\n         self.is_path_segment_keyword() || self.is_ident() && !self.is_reserved_ident()\n     }\n+}\n \n+impl TokenKind {\n     /// Returns `true` if the token is a given keyword, `kw`.\n     pub fn is_keyword(&self, kw: Symbol) -> bool {\n-        self.ident().map(|(ident, is_raw)| ident.name == kw && !is_raw).unwrap_or(false)\n+        self.ident_name().map(|(name, is_raw)| name == kw && !is_raw).unwrap_or(false)\n     }\n \n     pub fn is_path_segment_keyword(&self) -> bool {\n-        match self.ident() {\n-            Some((id, false)) => id.is_path_segment_keyword(),\n+        match self.ident_name() {\n+            Some((name, false)) => name.is_path_segment_keyword(),\n             _ => false,\n         }\n     }\n+}\n \n+impl Token {\n     // Returns true for reserved identifiers used internally for elided lifetimes,\n     // unnamed method parameters, crate root module, error recovery etc.\n     pub fn is_special_ident(&self) -> bool {\n@@ -490,7 +513,9 @@ impl TokenKind {\n             _ => false,\n         }\n     }\n+}\n \n+impl TokenKind {\n     crate fn glue(self, joint: TokenKind) -> Option<TokenKind> {\n         Some(match self {\n             Eq => match joint {\n@@ -537,7 +562,7 @@ impl TokenKind {\n                 _ => return None,\n             },\n             SingleQuote => match joint {\n-                Ident(ident, false) => Lifetime(Symbol::intern(&format!(\"'{}\", ident))),\n+                Ident(name, false) => Lifetime(Symbol::intern(&format!(\"'{}\", name))),\n                 _ => return None,\n             },\n \n@@ -608,9 +633,9 @@ impl TokenKind {\n             (&Literal(a), &Literal(b)) => a == b,\n \n             (&Lifetime(a), &Lifetime(b)) => a == b,\n-            (&Ident(a, b), &Ident(c, d)) => b == d && (a.name == c.name ||\n-                                                       a.name == kw::DollarCrate ||\n-                                                       c.name == kw::DollarCrate),\n+            (&Ident(a, b), &Ident(c, d)) => b == d && (a == c ||\n+                                                       a == kw::DollarCrate ||\n+                                                       c == kw::DollarCrate),\n \n             (&Interpolated(_), &Interpolated(_)) => false,\n \n@@ -738,8 +763,7 @@ impl Nonterminal {\n                 prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n             }\n             Nonterminal::NtIdent(ident, is_raw) => {\n-                let token = Ident(ident, is_raw);\n-                Some(TokenTree::token(ident.span, token).into())\n+                Some(TokenTree::token(ident.span, Ident(ident.name, is_raw)).into())\n             }\n             Nonterminal::NtLifetime(ident) => {\n                 Some(TokenTree::token(ident.span, Lifetime(ident.name)).into())\n@@ -827,7 +851,7 @@ fn prepend_attrs(sess: &ParseSess,\n         // For simple paths, push the identifier directly\n         if attr.path.segments.len() == 1 && attr.path.segments[0].args.is_none() {\n             let ident = attr.path.segments[0].ident;\n-            let token = Ident(ident, ident.as_str().starts_with(\"r#\"));\n+            let token = Ident(ident.name, ident.as_str().starts_with(\"r#\"));\n             brackets.push(tokenstream::TokenTree::token(ident.span, token));\n \n         // ... and for more complicated paths, fall back to a reparse hack that"}, {"sha": "bb80c1a1b3f33353c6373bddacd93bb6cc7ba198", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -575,7 +575,7 @@ impl DelimSpan {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::syntax::ast::Ident;\n+    use crate::syntax::ast::Name;\n     use crate::with_default_globals;\n     use crate::util::parser_testing::string_to_stream;\n     use syntax_pos::{Span, BytePos, NO_EXPANSION};\n@@ -660,7 +660,7 @@ mod tests {\n         with_default_globals(|| {\n             let test0: TokenStream = Vec::<TokenTree>::new().into_iter().collect();\n             let test1: TokenStream =\n-                TokenTree::token(sp(0, 1), token::Ident(Ident::from_str(\"a\"), false)).into();\n+                TokenTree::token(sp(0, 1), token::Ident(Name::intern(\"a\"), false)).into();\n             let test2 = string_to_ts(\"foo(bar::baz)\");\n \n             assert_eq!(test0.is_empty(), true);"}, {"sha": "8f061abc77b8d0f91eae10c5e79af82dd397c7a2", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -38,8 +38,8 @@ pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n             }\n         } else {\n             match *e {\n-                TokenTree::Token(Token { kind: token::Ident(ident, _), .. }) =>\n-                    res_str.push_str(&ident.as_str()),\n+                TokenTree::Token(Token { kind: token::Ident(name, _), .. }) =>\n+                    res_str.push_str(&name.as_str()),\n                 _ => {\n                     cx.span_err(sp, \"concat_idents! requires ident args.\");\n                     return DummyResult::any(sp);"}, {"sha": "c78215b77a973d86dbfbc698681ce12aeccc1a13", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -149,16 +149,16 @@ fn parse_args<'a>(\n         } // accept trailing commas\n         if named || (p.token.is_ident() && p.look_ahead(1, |t| *t == token::Eq)) {\n             named = true;\n-            let ident = if let token::Ident(i, _) = p.token.kind {\n+            let name = if let token::Ident(name, _) = p.token.kind {\n                 p.bump();\n-                i\n+                name\n             } else {\n                 return Err(ecx.struct_span_err(\n                     p.span,\n                     \"expected ident, positional arguments cannot follow named arguments\",\n                 ));\n             };\n-            let name: &str = &ident.as_str();\n+            let name: &str = &name.as_str();\n \n             p.expect(&token::Eq)?;\n             let e = p.parse_expr()?;"}, {"sha": "29297aa913ed418c11c3e41f812db6e4478e5bd7", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -132,7 +132,7 @@ impl<'a> CollectProcMacros<'a> {\n             }\n         };\n \n-        if !trait_ident.can_be_raw() {\n+        if !trait_ident.name.can_be_raw() {\n             self.handler.span_err(trait_attr.span,\n                                   &format!(\"`{}` cannot be a name of derive macro\", trait_ident));\n         }\n@@ -166,7 +166,7 @@ impl<'a> CollectProcMacros<'a> {\n                         return None;\n                     }\n                 };\n-                if !ident.can_be_raw() {\n+                if !ident.name.can_be_raw() {\n                     self.handler.span_err(\n                         attr.span,\n                         &format!(\"`{}` cannot be a name of derive helper attribute\", ident),"}, {"sha": "ff2835c70f75e84df1aa5d11b03f8dbedaa83fb1", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -142,9 +142,8 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n             Question => op!('?'),\n             SingleQuote => op!('\\''),\n \n-            Ident(ident, false) if ident.name == kw::DollarCrate =>\n-                tt!(Ident::dollar_crate()),\n-            Ident(ident, is_raw) => tt!(Ident::new(ident.name, is_raw)),\n+            Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n+            Ident(name, is_raw) => tt!(Ident::new(name, is_raw)),\n             Lifetime(name) => {\n                 let ident = ast::Ident::new(name, span).without_first_quote();\n                 stack.push(tt!(Ident::new(ident.name, false)));\n@@ -159,7 +158,7 @@ impl FromInternal<(TreeAndJoint, &'_ ParseSess, &'_ mut Vec<Self>)>\n                     escaped.extend(ch.escape_debug());\n                 }\n                 let stream = vec![\n-                    Ident(ast::Ident::new(sym::doc, span), false),\n+                    Ident(sym::doc, false),\n                     Eq,\n                     TokenKind::lit(token::Str, Symbol::intern(&escaped), None),\n                 ]\n@@ -211,8 +210,7 @@ impl ToInternal<TokenStream> for TokenTree<Group, Punct, Ident, Literal> {\n                 .into();\n             }\n             TokenTree::Ident(self::Ident { sym, is_raw, span }) => {\n-                let token = Ident(ast::Ident::new(sym, span), is_raw);\n-                return tokenstream::TokenTree::token(span, token).into();\n+                return tokenstream::TokenTree::token(span, Ident(sym, is_raw)).into();\n             }\n             TokenTree::Literal(self::Literal {\n                 lit: token::Lit { kind: token::Integer, symbol, suffix },\n@@ -338,7 +336,8 @@ impl Ident {\n         if !Self::is_valid(&string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        if is_raw && !ast::Ident::from_interned_str(sym.as_interned_str()).can_be_raw() {\n+        // Get rid of gensyms to conservatively check rawness on the string contents only.\n+        if is_raw && !sym.as_interned_str().as_symbol().can_be_raw() {\n             panic!(\"`{}` cannot be a raw identifier\", string);\n         }\n         Ident { sym, is_raw, span }"}, {"sha": "c37aae0bf3184e07e384f5190f6ce45c1234463a", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=f745e5f9b676be02cc1dfbab0bfb338dc72b4dd3", "patch": "@@ -1019,6 +1019,21 @@ impl Symbol {\n     pub fn is_doc_keyword(self) -> bool {\n         self <= kw::Union\n     }\n+\n+    /// A keyword or reserved identifier that can be used as a path segment.\n+    pub fn is_path_segment_keyword(self) -> bool {\n+        self == kw::Super ||\n+        self == kw::SelfLower ||\n+        self == kw::SelfUpper ||\n+        self == kw::Crate ||\n+        self == kw::PathRoot ||\n+        self == kw::DollarCrate\n+    }\n+\n+    /// This symbol can be a raw identifier.\n+    pub fn can_be_raw(self) -> bool {\n+        self != kw::Invalid && self != kw::Underscore && !self.is_path_segment_keyword()\n+    }\n }\n \n impl Ident {\n@@ -1049,24 +1064,13 @@ impl Ident {\n \n     /// A keyword or reserved identifier that can be used as a path segment.\n     pub fn is_path_segment_keyword(self) -> bool {\n-        self.name == kw::Super ||\n-        self.name == kw::SelfLower ||\n-        self.name == kw::SelfUpper ||\n-        self.name == kw::Crate ||\n-        self.name == kw::PathRoot ||\n-        self.name == kw::DollarCrate\n-    }\n-\n-    /// This identifier can be a raw identifier.\n-    pub fn can_be_raw(self) -> bool {\n-        self.name != kw::Invalid && self.name != kw::Underscore &&\n-        !self.is_path_segment_keyword()\n+        self.name.is_path_segment_keyword()\n     }\n \n     /// We see this identifier in a normal identifier position, like variable name or a type.\n     /// How was it written originally? Did it use the raw form? Let's try to guess.\n     pub fn is_raw_guess(self) -> bool {\n-        self.can_be_raw() && self.is_reserved()\n+        self.name.can_be_raw() && self.is_reserved()\n     }\n }\n "}]}