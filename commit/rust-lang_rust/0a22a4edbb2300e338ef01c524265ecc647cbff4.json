{"sha": "0a22a4edbb2300e338ef01c524265ecc647cbff4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMjJhNGVkYmIyMzAwZTMzOGVmMDFjNTI0MjY1ZWNjNjQ3Y2JmZjQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T02:48:17Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-09T02:48:17Z"}, "message": "rustc: Factor out path type instantiation so that tag patterns can use it as well", "tree": {"sha": "f7a417d31b8d705c82e5193edc69a0cbb1ac4cb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7a417d31b8d705c82e5193edc69a0cbb1ac4cb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a22a4edbb2300e338ef01c524265ecc647cbff4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a22a4edbb2300e338ef01c524265ecc647cbff4", "html_url": "https://github.com/rust-lang/rust/commit/0a22a4edbb2300e338ef01c524265ecc647cbff4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a22a4edbb2300e338ef01c524265ecc647cbff4/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64085b0a2b512822ed7f020659fc6bdb8ed8ef5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64085b0a2b512822ed7f020659fc6bdb8ed8ef5", "html_url": "https://github.com/rust-lang/rust/commit/e64085b0a2b512822ed7f020659fc6bdb8ed8ef5"}], "stats": {"total": 211, "additions": 108, "deletions": 103}, "files": [{"sha": "e035e733fb583e2c049e8088f5a27101b6b2fc55", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 108, "deletions": 103, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/0a22a4edbb2300e338ef01c524265ecc647cbff4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a22a4edbb2300e338ef01c524265ecc647cbff4/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0a22a4edbb2300e338ef01c524265ecc647cbff4", "patch": "@@ -128,6 +128,112 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n     ret ty.fold_ty(substituter, typ);\n }\n \n+// Instantiates the given path, which must refer to an item with the given\n+// definition.\n+fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ast.def defn, &span sp)\n+        -> ast.ann {\n+    auto t;\n+    auto ty_params;\n+    alt (defn) {\n+        case (ast.def_arg(?id)) {\n+            check (fcx.locals.contains_key(id));\n+            t = fcx.locals.get(id);\n+            ty_params = none[vec[ast.def_id]];\n+        }\n+        case (ast.def_local(?id)) {\n+            alt (fcx.locals.find(id)) {\n+                case (some[@ty.t](?t1)) { t = t1; }\n+                case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n+            }\n+            ty_params = none[vec[ast.def_id]];\n+        }\n+        case (ast.def_obj_field(?id)) {\n+            check (fcx.locals.contains_key(id));\n+            t = fcx.locals.get(id);\n+            ty_params = none[vec[ast.def_id]];\n+        }\n+        case (ast.def_fn(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            t = fcx.ccx.item_types.get(id);\n+            ty_params = some(fcx.ccx.item_ty_params.get(id));\n+        }\n+        case (ast.def_native_fn(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            t = fcx.ccx.item_types.get(id);\n+            ty_params = some(fcx.ccx.item_ty_params.get(id));\n+        }\n+        case (ast.def_const(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            t = fcx.ccx.item_types.get(id);\n+            ty_params = none[vec[ast.def_id]];\n+        }\n+        case (ast.def_variant(?tag_id, ?variant_id)) {\n+            check (fcx.ccx.item_types.contains_key(variant_id));\n+            t = fcx.ccx.item_types.get(variant_id);\n+            ty_params = some(fcx.ccx.item_ty_params.get(tag_id));\n+        }\n+        case (ast.def_binding(?id)) {\n+            check (fcx.locals.contains_key(id));\n+            t = fcx.locals.get(id);\n+            ty_params = none[vec[ast.def_id]];\n+        }\n+        case (ast.def_obj(?id)) {\n+            check (fcx.ccx.item_types.contains_key(id));\n+            t = fcx.ccx.item_types.get(id);\n+            ty_params = some(fcx.ccx.item_ty_params.get(id));\n+        }\n+\n+        case (ast.def_mod(_)) {\n+            // Hopefully part of a path.\n+            t = plain_ty(ty.ty_nil);    // TODO: something more poisonous?\n+            ty_params = none[vec[ast.def_id]];\n+        }\n+\n+        case (_) {\n+            // FIXME: handle other names.\n+            fcx.ccx.sess.unimpl(\"definition variant for: \"\n+                                + _str.connect(pth.node.idents, \".\"));\n+            fail;\n+        }\n+    }\n+\n+    auto ty_substs_opt;\n+    auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n+    if (ty_substs_len > 0u) {\n+        let vec[@ty.t] ty_substs = vec();\n+        auto i = 0u;\n+        while (i < ty_substs_len) {\n+            ty_substs += vec(ast_ty_to_ty_crate(fcx.ccx, pth.node.types.(i)));\n+            i += 1u;\n+        }\n+        ty_substs_opt = some[vec[@ty.t]](ty_substs);\n+\n+        alt (ty_params) {\n+            case (none[vec[ast.def_id]]) {\n+                fcx.ccx.sess.span_err(sp, \"this kind of item may not take \" +\n+                                          \"type parameters\");\n+                fail;\n+            }\n+            case (some[vec[ast.def_id]](?tps)) {\n+                t = substitute_ty_params(fcx.ccx, t, tps, ty_substs, sp);\n+            }\n+        }\n+    } else {\n+        ty_substs_opt = none[vec[@ty.t]];\n+\n+        alt (ty_params) {\n+            case (none[vec[ast.def_id]]) {  /* nothing */ }\n+            case (some[vec[ast.def_id]](_)) {\n+                // We will acquire the type parameters through\n+                // unification.\n+                t = generalize_ty(fcx.ccx, t);\n+            }\n+        }\n+    }\n+\n+    ret ast.ann_type(t, ty_substs_opt);\n+}\n+\n // Returns the type parameters and polytype of an item, if it's an item that\n // supports type parameters.\n fn ty_params_for_item(@crate_ctxt ccx, &ast.def d)\n@@ -1561,109 +1667,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n         case (ast.expr_path(?pth, ?defopt, _)) {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n-\n-            auto ty_params;\n-            alt (option.get[ast.def](defopt)) {\n-                case (ast.def_arg(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    t = fcx.locals.get(id);\n-                    ty_params = none[vec[ast.def_id]];\n-                }\n-                case (ast.def_local(?id)) {\n-                    alt (fcx.locals.find(id)) {\n-                        case (some[@ty.t](?t1)) { t = t1; }\n-                        case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n-                    }\n-                    ty_params = none[vec[ast.def_id]];\n-                }\n-                case (ast.def_obj_field(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    t = fcx.locals.get(id);\n-                    ty_params = none[vec[ast.def_id]];\n-                }\n-                case (ast.def_fn(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = fcx.ccx.item_types.get(id);\n-                    ty_params = some(fcx.ccx.item_ty_params.get(id));\n-                }\n-                case (ast.def_native_fn(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = fcx.ccx.item_types.get(id);\n-                    ty_params = some(fcx.ccx.item_ty_params.get(id));\n-                }\n-                case (ast.def_const(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = fcx.ccx.item_types.get(id);\n-                    ty_params = none[vec[ast.def_id]];\n-                }\n-                case (ast.def_variant(?tag_id, ?variant_id)) {\n-                    check (fcx.ccx.item_types.contains_key(variant_id));\n-                    t = fcx.ccx.item_types.get(variant_id);\n-                    ty_params = some(fcx.ccx.item_ty_params.get(tag_id));\n-                }\n-                case (ast.def_binding(?id)) {\n-                    check (fcx.locals.contains_key(id));\n-                    t = fcx.locals.get(id);\n-                    ty_params = none[vec[ast.def_id]];\n-                }\n-                case (ast.def_obj(?id)) {\n-                    check (fcx.ccx.item_types.contains_key(id));\n-                    t = fcx.ccx.item_types.get(id);\n-                    ty_params = some(fcx.ccx.item_ty_params.get(id));\n-                }\n-\n-                case (ast.def_mod(_)) {\n-                    // Hopefully part of a path.\n-                    ty_params = none[vec[ast.def_id]];\n-                }\n-\n-                case (_) {\n-                    // FIXME: handle other names.\n-                    fcx.ccx.sess.unimpl(\"definition variant for: \"\n-                                        + _str.connect(pth.node.idents, \".\"));\n-                    fail;\n-                }\n-            }\n-\n-            // Substitute type parameters if the user provided some.\n-            auto ty_substs_opt;\n-            auto ty_substs_len = _vec.len[@ast.ty](pth.node.types);\n-            if (ty_substs_len > 0u) {\n-                let vec[@ty.t] ty_substs = vec();\n-                auto i = 0u;\n-                while (i < ty_substs_len) {\n-                    ty_substs += vec(ast_ty_to_ty_crate(fcx.ccx,\n-                                                        pth.node.types.(i)));\n-                    i += 1u;\n-                }\n-                ty_substs_opt = some[vec[@ty.t]](ty_substs);\n-\n-                alt (ty_params) {\n-                    case (none[vec[ast.def_id]]) {\n-                        fcx.ccx.sess.span_err(expr.span, \"this kind of \" +\n-                                              \"item may not take type \" +\n-                                              \"parameters\");\n-                        fail;\n-                    }\n-                    case (some[vec[ast.def_id]](?tps)) {\n-                        t = substitute_ty_params(fcx.ccx, t, tps, ty_substs,\n-                                                 expr.span);\n-                    }\n-                }\n-            } else {\n-                ty_substs_opt = none[vec[@ty.t]];\n-\n-                alt (ty_params) {\n-                    case (none[vec[ast.def_id]]) {  /* nothing */ }\n-                    case (some[vec[ast.def_id]](_)) {\n-                        // We will acquire the type parameters through\n-                        // unification.\n-                        t = generalize_ty(fcx.ccx, t);\n-                    }\n-                }\n-            }\n-\n-            auto ann = ast.ann_type(t, ty_substs_opt);\n+            auto defn = option.get[ast.def](defopt);\n+            auto ann = instantiate_path(fcx, pth, defn, expr.span);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_path(pth, defopt, ann));\n         }"}]}