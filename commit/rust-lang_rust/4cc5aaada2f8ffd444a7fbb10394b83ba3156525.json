{"sha": "4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjYzVhYWFkYTJmOGZmZDQ0NGE3ZmJiMTAzOTRiODNiYTMxNTY1MjU=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-07T16:09:52Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-17T13:30:45Z"}, "message": "Protect error handler fields with single lock\n\nThis avoids concurrency-related bugs when locks are acquired for too\nshort a time and similar cases.", "tree": {"sha": "f7ded400b0dcb851da043655185bc5416cbc6c07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7ded400b0dcb851da043655185bc5416cbc6c07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "html_url": "https://github.com/rust-lang/rust/commit/4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4cc5aaada2f8ffd444a7fbb10394b83ba3156525/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a767eec0cae5aedb197d8fb823df67d93257fbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a767eec0cae5aedb197d8fb823df67d93257fbd", "html_url": "https://github.com/rust-lang/rust/commit/2a767eec0cae5aedb197d8fb823df67d93257fbd"}], "stats": {"total": 342, "additions": 207, "deletions": 135}, "files": [{"sha": "9eb68056bfd97f0c09afc8bf7f33df30ef9627ec", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4cc5aaada2f8ffd444a7fbb10394b83ba3156525/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc5aaada2f8ffd444a7fbb10394b83ba3156525/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "patch": "@@ -87,7 +87,7 @@ fn test_can_print_warnings() {\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(!sess.diagnostic().flags.can_emit_warnings);\n+        assert!(!sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n@@ -97,15 +97,15 @@ fn test_can_print_warnings() {\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(sess.diagnostic().flags.can_emit_warnings);\n+        assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(sess.diagnostic().flags.can_emit_warnings);\n+        assert!(sess.diagnostic().can_emit_warnings());\n     });\n }\n "}, {"sha": "a1a63664a4be330591e41a5f77d4b8d44fa2e7c4", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 204, "deletions": 132, "changes": 336, "blob_url": "https://github.com/rust-lang/rust/blob/4cc5aaada2f8ffd444a7fbb10394b83ba3156525/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4cc5aaada2f8ffd444a7fbb10394b83ba3156525/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "patch": "@@ -16,7 +16,7 @@ use Level::*;\n use emitter::{Emitter, EmitterWriter};\n use registry::Registry;\n \n-use rustc_data_structures::sync::{self, Lrc, Lock, AtomicUsize, AtomicBool, SeqCst};\n+use rustc_data_structures::sync::{self, Lrc, Lock};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stable_hasher::StableHasher;\n \n@@ -298,38 +298,42 @@ pub use diagnostic_builder::DiagnosticBuilder;\n /// Certain errors (fatal, bug, unimpl) may cause immediate exit,\n /// others log errors for later reporting.\n pub struct Handler {\n-    pub flags: HandlerFlags,\n+    flags: HandlerFlags,\n+    inner: Lock<HandlerInner>,\n+}\n \n+struct HandlerInner {\n+    flags: HandlerFlags,\n     /// The number of errors that have been emitted, including duplicates.\n     ///\n     /// This is not necessarily the count that's reported to the user once\n     /// compilation ends.\n-    err_count: AtomicUsize,\n-    deduplicated_err_count: AtomicUsize,\n-    emitter: Lock<Box<dyn Emitter + sync::Send>>,\n-    continue_after_error: AtomicBool,\n-    delayed_span_bugs: Lock<Vec<Diagnostic>>,\n+    err_count: usize,\n+    deduplicated_err_count: usize,\n+    emitter: Box<dyn Emitter + sync::Send>,\n+    continue_after_error: bool,\n+    delayed_span_bugs: Vec<Diagnostic>,\n \n     /// This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n     /// emitting the same diagnostic with extended help (`--teach`) twice, which\n     /// would be uneccessary repetition.\n-    taught_diagnostics: Lock<FxHashSet<DiagnosticId>>,\n+    taught_diagnostics: FxHashSet<DiagnosticId>,\n \n     /// Used to suggest rustc --explain <error code>\n-    emitted_diagnostic_codes: Lock<FxHashSet<DiagnosticId>>,\n+    emitted_diagnostic_codes: FxHashSet<DiagnosticId>,\n \n     /// This set contains a hash of every diagnostic that has been emitted by\n     /// this handler. These hashes is used to avoid emitting the same error\n     /// twice.\n-    emitted_diagnostics: Lock<FxHashSet<u128>>,\n+    emitted_diagnostics: FxHashSet<u128>,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n \n thread_local!(pub static TRACK_DIAGNOSTICS: Cell<fn(&Diagnostic)> =\n                 Cell::new(default_track_diagnostic));\n \n-#[derive(Default)]\n+#[derive(Copy, Clone, Default)]\n pub struct HandlerFlags {\n     /// If false, warning-level lints are suppressed.\n     /// (rustc: see `--allow warnings` and `--cap-lints`)\n@@ -348,13 +352,13 @@ pub struct HandlerFlags {\n     pub external_macro_backtrace: bool,\n }\n \n-impl Drop for Handler {\n+impl Drop for HandlerInner {\n     fn drop(&mut self) {\n-        if !self.has_errors() {\n-            let mut bugs = self.delayed_span_bugs.borrow_mut();\n+        if self.err_count == 0 {\n+            let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n             let has_bugs = !bugs.is_empty();\n-            for bug in bugs.drain(..) {\n-                DiagnosticBuilder::new_diagnostic(self, bug).emit();\n+            for bug in bugs {\n+                self.emit_diagnostic(&bug);\n             }\n             if has_bugs {\n                 panic!(\"no errors encountered even though `delay_span_bug` issued\");\n@@ -405,31 +409,42 @@ impl Handler {\n     {\n         Handler {\n             flags,\n-            err_count: AtomicUsize::new(0),\n-            deduplicated_err_count: AtomicUsize::new(0),\n-            emitter: Lock::new(e),\n-            continue_after_error: AtomicBool::new(true),\n-            delayed_span_bugs: Lock::new(Vec::new()),\n-            taught_diagnostics: Default::default(),\n-            emitted_diagnostic_codes: Default::default(),\n-            emitted_diagnostics: Default::default(),\n+            inner: Lock::new(HandlerInner {\n+                flags,\n+                err_count: 0,\n+                deduplicated_err_count: 0,\n+                emitter: e,\n+                continue_after_error: true,\n+                delayed_span_bugs: Vec::new(),\n+                taught_diagnostics: Default::default(),\n+                emitted_diagnostic_codes: Default::default(),\n+                emitted_diagnostics: Default::default(),\n+            }),\n         }\n     }\n \n     pub fn set_continue_after_error(&self, continue_after_error: bool) {\n-        self.continue_after_error.store(continue_after_error, SeqCst);\n+        self.inner.borrow_mut().continue_after_error = continue_after_error;\n+    }\n+\n+    // This is here to not allow mutation of flags;\n+    // as of this writing it's only used in tests in librustc.\n+    pub fn can_emit_warnings(&self) -> bool {\n+        self.flags.can_emit_warnings\n     }\n \n     /// Resets the diagnostic error count as well as the cached emitted diagnostics.\n     ///\n     /// NOTE: *do not* call this function from rustc. It is only meant to be called from external\n     /// tools that want to reuse a `Parser` cleaning the previously emitted diagnostics as well as\n     /// the overall count of emitted error diagnostics.\n+    // FIXME: this does not clear inner entirely\n     pub fn reset_err_count(&self) {\n+        let mut inner = self.inner.borrow_mut();\n         // actually frees the underlying memory (which `clear` would not do)\n-        *self.emitted_diagnostics.borrow_mut() = Default::default();\n-        self.deduplicated_err_count.store(0, SeqCst);\n-        self.err_count.store(0, SeqCst);\n+        inner.emitted_diagnostics = Default::default();\n+        inner.deduplicated_err_count = 0;\n+        inner.err_count = 0;\n     }\n \n     pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n@@ -520,24 +535,6 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    fn panic_if_treat_err_as_bug(&self) {\n-        if self.treat_err_as_bug() {\n-            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n-                (0, _) => return,\n-                (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n-                (1, _) => return,\n-                (count, as_bug) => {\n-                    format!(\n-                        \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n-                        count,\n-                        as_bug,\n-                    )\n-                }\n-            };\n-            panic!(s);\n-        }\n-    }\n-\n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         self.emit_diagnostic(Diagnostic::new(Fatal, msg).set_span(sp));\n         self.abort_if_errors_and_should_abort();\n@@ -577,24 +574,10 @@ impl Handler {\n         self.abort_if_errors_and_should_abort();\n     }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n-        self.abort_if_errors_and_should_abort();\n-        panic!(ExplicitBug);\n+        self.inner.borrow_mut().span_bug(sp, msg)\n     }\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        if self.treat_err_as_bug() {\n-            // FIXME: don't abort here if report_delayed_bugs is off\n-            self.span_bug(sp, msg);\n-        }\n-        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n-        diagnostic.set_span(sp.into());\n-        self.delay_as_bug(diagnostic);\n-    }\n-    fn delay_as_bug(&self, diagnostic: Diagnostic) {\n-        if self.flags.report_delayed_bugs {\n-            self.emit_diagnostic(&diagnostic);\n-        }\n-        self.delayed_span_bugs.borrow_mut().push(diagnostic);\n+        self.inner.borrow_mut().delay_span_bug(sp, msg)\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n@@ -613,54 +596,128 @@ impl Handler {\n         db\n     }\n     pub fn failure(&self, msg: &str) {\n-        DiagnosticBuilder::new(self, FailureNote, msg).emit()\n+        self.inner.borrow_mut().failure(msg);\n     }\n     pub fn fatal(&self, msg: &str) -> FatalError {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        DiagnosticBuilder::new(self, Fatal, msg).emit();\n-        FatalError\n+        self.inner.borrow_mut().fatal(msg)\n     }\n     pub fn err(&self, msg: &str) {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        let mut db = DiagnosticBuilder::new(self, Error, msg);\n-        db.emit();\n+        self.inner.borrow_mut().err(msg);\n     }\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n-    fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map(|c| self.err_count() >= c).unwrap_or(false)\n-    }\n     pub fn note_without_error(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.emit();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        let mut db = DiagnosticBuilder::new(self, Bug, msg);\n-        db.emit();\n-        panic!(ExplicitBug);\n-    }\n-\n-    fn bump_err_count(&self) {\n-        self.err_count.fetch_add(1, SeqCst);\n-        self.panic_if_treat_err_as_bug();\n+        self.inner.borrow_mut().bug(msg)\n     }\n \n     pub fn err_count(&self) -> usize {\n-        self.err_count.load(SeqCst)\n+        self.inner.borrow().err_count\n     }\n \n     pub fn has_errors(&self) -> bool {\n         self.err_count() > 0\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n-        let s = match self.deduplicated_err_count.load(SeqCst) {\n+        self.inner.borrow_mut().print_error_count(registry)\n+    }\n+\n+    pub fn abort_if_errors(&self) {\n+        self.inner.borrow().abort_if_errors()\n+    }\n+\n+    pub fn abort_if_errors_and_should_abort(&self) {\n+        self.inner.borrow().abort_if_errors_and_should_abort()\n+    }\n+\n+    pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n+        self.inner.borrow_mut().must_teach(code)\n+    }\n+\n+    pub fn force_print_diagnostic(&self, db: Diagnostic) {\n+        self.inner.borrow_mut().force_print_diagnostic(db)\n+    }\n+\n+    pub fn emit_diagnostic(&self, diagnostic: &Diagnostic) {\n+        self.inner.borrow_mut().emit_diagnostic(diagnostic)\n+    }\n+\n+    pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n+        self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n+    }\n+\n+    pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n+        self.inner.borrow_mut().delay_as_bug(diagnostic)\n+    }\n+}\n+\n+impl HandlerInner {\n+    /// `true` if we haven't taught a diagnostic with this code already.\n+    /// The caller must then teach the user about such a diagnostic.\n+    ///\n+    /// Used to suppress emitting the same error multiple times with extended explanation when\n+    /// calling `-Zteach`.\n+    fn must_teach(&mut self, code: &DiagnosticId) -> bool {\n+        self.taught_diagnostics.insert(code.clone())\n+    }\n+\n+    fn force_print_diagnostic(&mut self, db: Diagnostic) {\n+        self.emitter.emit_diagnostic(&db);\n+    }\n+\n+    fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n+        if diagnostic.cancelled() {\n+            return;\n+        }\n+\n+        if diagnostic.level == Warning && !self.flags.can_emit_warnings {\n+            return;\n+        }\n+\n+        TRACK_DIAGNOSTICS.with(|track_diagnostics| {\n+            track_diagnostics.get()(diagnostic);\n+        });\n+\n+        if let Some(ref code) = diagnostic.code {\n+            self.emitted_diagnostic_codes.insert(code.clone());\n+        }\n+\n+        let diagnostic_hash = {\n+            use std::hash::Hash;\n+            let mut hasher = StableHasher::new();\n+            diagnostic.hash(&mut hasher);\n+            hasher.finish()\n+        };\n+\n+        // Only emit the diagnostic if we haven't already emitted an equivalent\n+        // one:\n+        if self.emitted_diagnostics.insert(diagnostic_hash) {\n+            self.emitter.emit_diagnostic(diagnostic);\n+            if diagnostic.is_error() {\n+                self.deduplicated_err_count += 1;\n+            }\n+        }\n+        if diagnostic.is_error() {\n+            self.bump_err_count();\n+        }\n+    }\n+\n+    fn emit_artifact_notification(&mut self, path: &Path, artifact_type: &str) {\n+        self.emitter.emit_artifact_notification(path, artifact_type);\n+    }\n+\n+    fn treat_err_as_bug(&self) -> bool {\n+        self.flags.treat_err_as_bug.map(|c| self.err_count >= c).unwrap_or(false)\n+    }\n+\n+    fn print_error_count(&mut self, registry: &Registry) {\n+        let s = match self.deduplicated_err_count {\n             0 => return,\n             1 => \"aborting due to previous error\".to_string(),\n             count => format!(\"aborting due to {} previous errors\", count)\n@@ -671,12 +728,11 @@ impl Handler {\n \n         let _ = self.fatal(&s);\n \n-        let can_show_explain = self.emitter.borrow().should_show_explain();\n-        let are_there_diagnostics = !self.emitted_diagnostic_codes.borrow().is_empty();\n+        let can_show_explain = self.emitter.should_show_explain();\n+        let are_there_diagnostics = !self.emitted_diagnostic_codes.is_empty();\n         if can_show_explain && are_there_diagnostics {\n             let mut error_codes = self\n                 .emitted_diagnostic_codes\n-                .borrow()\n                 .iter()\n                 .filter_map(|x| match &x {\n                     DiagnosticId::Error(s) if registry.find_description(s).is_some() => {\n@@ -704,70 +760,86 @@ impl Handler {\n         }\n     }\n \n-    pub fn abort_if_errors_and_should_abort(&self) {\n-        if self.has_errors() && !self.continue_after_error.load(SeqCst) {\n+    fn abort_if_errors_and_should_abort(&self) {\n+        if self.err_count > 0 && !self.continue_after_error {\n             FatalError.raise();\n         }\n     }\n \n-    pub fn abort_if_errors(&self) {\n-        if self.has_errors() {\n+    fn abort_if_errors(&self) {\n+        if self.err_count > 0 {\n             FatalError.raise();\n         }\n     }\n \n-    /// `true` if we haven't taught a diagnostic with this code already.\n-    /// The caller must then teach the user about such a diagnostic.\n-    ///\n-    /// Used to suppress emitting the same error multiple times with extended explanation when\n-    /// calling `-Zteach`.\n-    pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n-        self.taught_diagnostics.borrow_mut().insert(code.clone())\n+    fn span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> ! {\n+        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n+        panic!(ExplicitBug);\n     }\n \n-    pub fn force_print_diagnostic(&self, db: Diagnostic) {\n-        self.emitter.borrow_mut().emit_diagnostic(&db);\n+    fn delay_span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) {\n+        if self.treat_err_as_bug() {\n+            // FIXME: don't abort here if report_delayed_bugs is off\n+            self.span_bug(sp, msg);\n+        }\n+        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n+        diagnostic.set_span(sp.into());\n+        self.delay_as_bug(diagnostic)\n     }\n \n-    pub fn emit_diagnostic(&self, diagnostic: &Diagnostic) {\n-        if diagnostic.cancelled() {\n-            return;\n-        }\n+    fn failure(&mut self, msg: &str) {\n+        self.emit_diagnostic(&Diagnostic::new(FailureNote, msg));\n+    }\n \n-        if diagnostic.level == Warning && !self.flags.can_emit_warnings {\n-            return;\n+    fn fatal(&mut self, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug() {\n+            self.bug(msg);\n         }\n+        self.emit_diagnostic(&Diagnostic::new(Fatal, msg));\n+        FatalError\n+    }\n \n-        TRACK_DIAGNOSTICS.with(|track_diagnostics| {\n-            track_diagnostics.get()(diagnostic);\n-        });\n-\n-        if let Some(ref code) = diagnostic.code {\n-            self.emitted_diagnostic_codes.borrow_mut().insert(code.clone());\n+    fn err(&mut self, msg: &str) {\n+        if self.treat_err_as_bug() {\n+            self.bug(msg);\n         }\n+        self.emit_diagnostic(&Diagnostic::new(Error, msg));\n+    }\n \n-        let diagnostic_hash = {\n-            use std::hash::Hash;\n-            let mut hasher = StableHasher::new();\n-            diagnostic.hash(&mut hasher);\n-            hasher.finish()\n-        };\n+    fn bug(&mut self, msg: &str) -> ! {\n+        self.emit_diagnostic(&Diagnostic::new(Bug, msg));\n+        panic!(ExplicitBug);\n+    }\n \n-        // Only emit the diagnostic if we haven't already emitted an equivalent\n-        // one:\n-        if self.emitted_diagnostics.borrow_mut().insert(diagnostic_hash) {\n-            self.emitter.borrow_mut().emit_diagnostic(diagnostic);\n-            if diagnostic.is_error() {\n-                self.deduplicated_err_count.fetch_add(1, SeqCst);\n-            }\n-        }\n-        if diagnostic.is_error() {\n-            self.bump_err_count();\n+    fn delay_as_bug(&mut self, diagnostic: Diagnostic) {\n+        if self.flags.report_delayed_bugs {\n+            self.emit_diagnostic(&diagnostic);\n         }\n+        self.delayed_span_bugs.push(diagnostic);\n     }\n \n-    pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n-        self.emitter.borrow_mut().emit_artifact_notification(path, artifact_type);\n+    fn bump_err_count(&mut self) {\n+        self.err_count += 1;\n+        self.panic_if_treat_err_as_bug();\n+    }\n+\n+    fn panic_if_treat_err_as_bug(&self) {\n+        if self.treat_err_as_bug() {\n+            let s = match (self.err_count, self.flags.treat_err_as_bug.unwrap_or(0)) {\n+                (0, _) => return,\n+                (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n+                (1, _) => return,\n+                (count, as_bug) => {\n+                    format!(\n+                        \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n+                        count,\n+                        as_bug,\n+                    )\n+                }\n+            };\n+            panic!(s);\n+        }\n     }\n }\n "}]}