{"sha": "575692c3bcb20897cf07fcd21769c8a7dbdd948e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3NTY5MmMzYmNiMjA4OTdjZjA3ZmNkMjE3NjljOGE3ZGJkZDk0OGU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-21T00:37:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-03-21T01:59:21Z"}, "message": "doc: Fix some language ref examples", "tree": {"sha": "3933f414998b2021d2cef8e9e4e9d77f62d408f7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3933f414998b2021d2cef8e9e4e9d77f62d408f7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/575692c3bcb20897cf07fcd21769c8a7dbdd948e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/575692c3bcb20897cf07fcd21769c8a7dbdd948e", "html_url": "https://github.com/rust-lang/rust/commit/575692c3bcb20897cf07fcd21769c8a7dbdd948e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/575692c3bcb20897cf07fcd21769c8a7dbdd948e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "089877f0c5b5827dcdf3a6f905738674a46ee6cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/089877f0c5b5827dcdf3a6f905738674a46ee6cd", "html_url": "https://github.com/rust-lang/rust/commit/089877f0c5b5827dcdf3a6f905738674a46ee6cd"}], "stats": {"total": 295, "additions": 199, "deletions": 96}, "files": [{"sha": "ec135327112a246385e5ab32cf1c1a07cdd74f74", "filename": "doc/rust.md", "status": "modified", "additions": 199, "deletions": 96, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/575692c3bcb20897cf07fcd21769c8a7dbdd948e/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/575692c3bcb20897cf07fcd21769c8a7dbdd948e/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=575692c3bcb20897cf07fcd21769c8a7dbdd948e", "patch": "@@ -424,7 +424,7 @@ across crates; an item's canonical path merely identifies it within the crate.\n \n Two examples of simple paths consisting of only identifier components:\n \n-~~~~{.xfail-test}\n+~~~~{.ignore}\n x;\n x::y::z;\n ~~~~\n@@ -438,9 +438,13 @@ expression context, the final namespace qualifier is omitted.\n \n Two examples of paths with type arguments:\n \n-~~~~{.xfail-test}\n-type t = map::hashtbl<int,str>;  // Type arguments used in a type expression\n+~~~~\n+# import std::map;\n+# fn f() {\n+# fn id<T:copy>(t: T) -> T { t }\n+type t = map::hashmap<int,str>;  // Type arguments used in a type expression\n let x = id::<int>(10);           // Type arguments used in a call expression\n+# }\n ~~~~\n \n \n@@ -627,19 +631,21 @@ of modules making up a crate. Modules can nest arbitrarily.\n \n An example of a module:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n mod math {\n-    type complex = (f64,f64);\n-    fn sin(f64) -> f64 {\n-        ...\n+    type complex = (f64, f64);\n+    fn sin(f: f64) -> f64 {\n+        // ...\n+# fail;\n     }\n-    fn cos(f64) -> f64 {\n-        ...\n+    fn cos(f: f64) -> f64 {\n+        // ...\n+# fail;\n     }\n-    fn tan(f64) -> f64 {\n-        ...\n+    fn tan(f: f64) -> f64 {\n+        // ...\n+# fail;\n     }\n-    ...\n }\n ~~~~~~~~\n \n@@ -718,22 +724,22 @@ Imports support a number of \"convenience\" notations:\n \n An example of imports:\n \n-~~~~{.xfail-test}\n+~~~~\n import foo = core::info;\n-import std::math::sin;\n-import std::str::{char_at, hash};\n-import core::option::*;\n+import core::float::sin;\n+import core::str::{slice, hash};\n+import core::option::some;\n \n fn main() {\n-    // Equivalent to 'log(core::info, std::math::sin(1.0));'\n+    // Equivalent to 'log(core::info, core::float::sin(1.0));'\n     log(foo, sin(1.0));\n \n     // Equivalent to 'log(core::info, core::option::some(1.0));'\n     log(info, some(1.0));\n \n     // Equivalent to 'log(core::info,\n-    //                    std::str::hash(std::str::char_at(\"foo\")));'\n-    log(info, hash(char_at(\"foo\")));\n+    //                    core::str::hash(core::str::slice(\"foo\", 0u, 1u)));'\n+    log(info, hash(slice(\"foo\", 0u, 1u)));\n }\n ~~~~\n \n@@ -753,7 +759,7 @@ declaration replaces the default export with the export specified.\n \n An example of an export:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n mod foo {\n     export primary;\n \n@@ -763,19 +769,25 @@ mod foo {\n     }\n \n     fn helper(x: int, y: int) {\n-        ...\n+        // ...\n     }\n }\n \n fn main() {\n     foo::primary();  // Will compile.\n-    foo::helper(2,3) // ERROR: will not compile.\n }\n ~~~~~~~~\n \n+If, instead of calling `foo::primary` in main, you were to call `foo::helper`\n+then it would fail to compile:\n+\n+~~~~~~~~{.ignore}\n+    foo::helper(2,3) // ERROR: will not compile.\n+~~~~~~~~\n+\n Multiple names may be exported from a single export declaration:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n mod foo {\n     export primary, secondary;\n \n@@ -785,23 +797,23 @@ mod foo {\n     }\n \n     fn secondary() {\n-        ...\n+        // ...\n     }\n \n     fn helper(x: int, y: int) {\n-        ...\n+        // ...\n     }\n }\n ~~~~~~~~\n \n When exporting the name of an `enum` type `t`, by default, the module also\n implicitly exports all of `t`'s constructors. For example:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n mod foo {\n     export t;\n     \n-    enum t {a, b, c};\n+    enum t {a, b, c}\n }\n ~~~~~~~~\n \n@@ -815,10 +827,10 @@ constructors, achieving a simple kind of data abstraction. The third\n form exports an `enum` type name along with a subset of its\n constructors. For example:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n mod foo {\n-    export abstract{};\n-    export slightly_abstract{a, b};\n+    export abstract::{};\n+    export slightly_abstract::{a, b};\n \n     enum abstract {x, y, z}\n     enum slightly_abstract {a, b, c, d}\n@@ -883,7 +895,9 @@ with a [`ret`](#return-expressions) or diverging expression. So, if `my_err`\n were declared without the `!` annotation, the following code would not\n typecheck:\n \n-~~~~{.xfail-test}\n+~~~~\n+# fn my_err(s: str) -> ! { fail }\n+\n fn f(i: int) -> int {\n    if i == 42 {\n      ret 42;\n@@ -953,18 +967,20 @@ verify the semantics of the predicates they write.\n \n An example of a predicate that uses an unchecked block:\n \n-~~~~{.xfail-test}\n-fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: block(&T, &U) -> U) -> U {\n+~~~~\n+# import std::list::*;\n+\n+fn pure_foldl<T, U: copy>(ls: list<T>, u: U, f: fn(&&T, &&U) -> U) -> U {\n     alt ls {\n-      nil. { u }\n+      nil { u }\n       cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n     }\n }\n \n pure fn pure_length<T>(ls: list<T>) -> uint {\n-    fn count<T>(_t: T, u: uint) -> uint { u + 1u }\n+    fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n     unchecked {\n-        pure_foldl(ls, 0u, count)\n+        pure_foldl(ls, 0u, count(_, _))\n     }\n }\n ~~~~\n@@ -982,11 +998,11 @@ appear in its signature. Each type parameter must be explicitly\n declared, in an angle-bracket-enclosed, comma-separated list following\n the function name.\n \n-~~~~{.xfail-test}\n-fn iter<T>(seq: [T], f: block(T)) {\n+~~~~\n+fn iter<T>(seq: [T], f: fn(T)) {\n     for elt: T in seq { f(elt); }\n }\n-fn map<T, U>(seq: [T], f: block(T) -> U) -> [U] {\n+fn map<T, U>(seq: [T], f: fn(T) -> U) -> [U] {\n     let acc = [];\n     for elt in seq { acc += [f(elt)]; }\n     acc\n@@ -1000,7 +1016,7 @@ When a generic function is referenced, its type is instantiated based\n on the context of the reference. For example, calling the `iter`\n function defined above on `[1, 2]` will instantiate type parameter `T`\n with `int`, and require the closure parameter to have type\n-`block(int)`.\n+`fn(int)`.\n \n Since a parameter type is opaque to the generic function, the set of\n operations that can be performed on it is limited. Values of parameter\n@@ -1031,7 +1047,8 @@ crust fn new_vec() -> [int] { [] }\n Crust functions may not be called from Rust code, but their value\n may be taken as an unsafe `u8` pointer.\n \n-~~~{.xfail-test}\n+~~~\n+# crust fn new_vec() -> [int] { [] }\n let fptr: *u8 = new_vec;\n ~~~\n \n@@ -1081,10 +1098,10 @@ type the constructor is a member of. Such recursion has restrictions:\n \n An example of an `enum` item and its use:\n \n-~~~~{.xfail-test}\n+~~~~\n enum animal {\n-  dog;\n-  cat;\n+  dog,\n+  cat\n }\n \n let a: animal = dog;\n@@ -1093,10 +1110,10 @@ a = cat;\n \n An example of a *recursive* `enum` item and its use:\n \n-~~~~{.xfail-test}\n+~~~~\n enum list<T> {\n-  nil;\n-  cons(T, @list<T>);\n+  nil,\n+  cons(T, @list<T>)\n }\n \n let a: list<int> = cons(7, @cons(13, @nil));\n@@ -1107,9 +1124,9 @@ let a: list<int> = cons(7, @cons(13, @nil));\n _Resources_ are values that have a destructor associated with them. A\n _resource item_ is used to declare resource type and constructor.\n \n-~~~~{.xfail-test}\n-resource file_descriptor(fd: int) {\n-    std::os::libc::close(fd);\n+~~~~\n+resource file_descriptor(fd: libc::c_int) {\n+    libc::close(fd);\n }\n ~~~~\n \n@@ -1133,7 +1150,10 @@ An _interface item_ describes a set of method types. _[implementation\n items](#implementations)_ can be used to provide implementations of\n those methods for a specific type.\n \n-~~~~{.xfail-test}\n+~~~~\n+# type surface = int;\n+# type bounding_box = int;\n+\n iface shape {\n     fn draw(surface);\n     fn bounding_box() -> bounding_box;\n@@ -1149,11 +1169,11 @@ Type parameters can be specified for an interface to make it generic.\n These appear after the name, using the same syntax used in [generic\n functions](#generic-functions).\n \n-~~~~{.xfail-test}\n+~~~~\n iface seq<T> {\n    fn len() -> uint;\n    fn elt_at(n: uint) -> T;\n-   fn iter(block(T));\n+   fn iter(fn(T));\n }\n ~~~~\n \n@@ -1163,7 +1183,10 @@ interface can be used to instantiate the parameter, and within the\n generic function, the methods of the interface can be called on values\n that have the parameter's type. For example:\n \n-~~~~{.xfail-test}\n+~~~~\n+# type surface = int;\n+# iface shape { fn draw(surface); }\n+\n fn draw_twice<T: shape>(surface: surface, sh: T) {\n     sh.draw(surface);\n     sh.draw(surface);\n@@ -1176,7 +1199,11 @@ interface. Values of this type are created by\n implementation of the given interface is in scope) to the interface\n type.\n \n-~~~~{.xfail-test}\n+~~~~\n+# iface shape { }\n+# impl of shape for int { }\n+# let mycircle = 0;\n+\n let myshape: shape = mycircle as shape;\n ~~~~\n \n@@ -1191,15 +1218,21 @@ instantiate type parameters that are bounded on their interface.\n An _implementation item_ provides an implementation of an\n [interfaces](#interfaces) for a type.\n \n-~~~~{.xfail-test}\n+~~~~\n+# type point = {x: float, y: float};\n+# type surface = int;\n+# type bounding_box = {x: float, y: float, width: float, height: float};\n+# iface shape { fn draw(surface); fn bounding_box() -> bounding_box; }\n+# fn do_draw_circle(s: surface, c: circle) { }\n+\n type circle = {radius: float, center: point};\n \n impl circle_shape of shape for circle {\n     fn draw(s: surface) { do_draw_circle(s, self); }\n     fn bounding_box() -> bounding_box {\n         let r = self.radius;\n         {x: self.center.x - r, y: self.center.y - r,\n-         width: 2 * r, height: 2 * r}\n+         width: 2.0 * r, height: 2.0 * r}\n     }\n }\n ~~~~\n@@ -1218,10 +1251,10 @@ statically (as direct calls on the values of the type that the\n implementation targets). In such an implementation, the `of` clause is\n not given, and the name is mandatory.\n \n-~~~~{.xfail-test}\n+~~~~\n impl uint_loops for uint {\n-    fn times(f: block(uint)) {\n-        let i = 0;\n+    fn times(f: fn(uint)) {\n+        let i = 0u;\n         while i < self { f(i); i += 1u; }\n     }\n }\n@@ -1236,7 +1269,9 @@ from the type parameters taken by the interface it implements. They\n are written after the name of the implementation, or if that is not\n specified, after the `impl` keyword.\n \n-~~~~{.xfail-test}\n+~~~~\n+# iface seq { }\n+\n impl <T> of seq<T> for [T] {\n     /* ... */\n }\n@@ -1257,9 +1292,12 @@ module describes functions in external, non-Rust libraries. Functions within\n native modules are declared the same as other Rust functions, with the exception\n that they may not have a body and are instead terminated by a semi-colon.\n \n-~~~{.xfail-test}\n+~~~\n+# import libc::{c_char, FILE};\n+# #[nolink]\n+\n native mod c {\n-    fn fopen(filename: *c_char, mod: *c_char) -> *FILE;\n+    fn fopen(filename: *c_char, mode: *c_char) -> *FILE;\n }\n ~~~\n \n@@ -1326,19 +1364,19 @@ declaration within the entity body.\n An example of attributes:\n \n ~~~~~~~~{.xfail-test}\n+// General metadata applied to the enclosing module or crate.\n+#[license = \"BSD\"];\n+\n // A function marked as a unit test\n #[test]\n fn test_foo() {\n-  ...\n+  // ...\n }\n \n-// General metadata applied to the enclosing module or crate.\n-#[license = \"BSD\"];\n-\n // A conditionally-compiled module\n #[cfg(target_os=\"linux\")]\n mod bar {\n-  ...\n+  // ...\n }\n \n // A documentation attribute\n@@ -1578,10 +1616,16 @@ Indices are zero-based, and may be of any integral type. Vector access\n is bounds-checked at run-time. When the check fails, it will put the\n task in a _failing state_.\n \n-~~~~{.xfail-test}\n+~~~~\n+# let builder = task::task_builder();\n+# task::unsupervise(builder);\n+# task::run(builder) {||\n+\n [1, 2, 3, 4][0];\n [mutable 'x', 'y'][1] = 'z';\n [\"a\", \"b\"][10]; // fails\n+\n+# }\n ~~~~\n \n ### Unary operator expressions\n@@ -1696,10 +1740,13 @@ is unsupported and will fail to compile.\n \n An example of an `as` expression:\n \n-~~~~{.xfail-test}\n+~~~~\n+# fn sum(v: [float]) -> float { 0.0 }\n+# fn len(v: [float]) -> int { 0 }\n+\n fn avg(v: [float]) -> float {\n   let sum: float = sum(v);\n-  let sz: float = std::vec::len(v) as float;\n+  let sz: float = len(v) as float;\n   ret sum / sz;\n }\n ~~~~\n@@ -1727,10 +1774,17 @@ expression. No allocation or destruction is entailed.\n \n An example of three different move expressions:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n+# let x = [mut 0];\n+# let a = [mut 0];\n+# let b = 0;\n+# let y = {mut z: 0};\n+# let c = 0;\n+# let i = 0;\n+\n x <- a;\n x[i] <- b;\n-x.y <- c;\n+y.z <- c;\n ~~~~~~~~\n \n #### Swap expressions\n@@ -1749,10 +1803,16 @@ expression. No allocation or destruction is entailed.\n \n An example of three different swap expressions:\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n+# let x = [mut 0];\n+# let a = [mut 0];\n+# let i = 0;\n+# let y = {mut z: 0};\n+# let b = {mut c: 0};\n+\n x <-> a;\n-x[i] <-> b[i];\n-x.y <-> a.b;\n+x[i] <-> a[i];\n+y.z <-> b.c;\n ~~~~~~~~\n \n \n@@ -1766,9 +1826,12 @@ expression](#binary-move-expressions) applied to a [unary copy\n expression](#unary-copy-expressions). For example, the following two\n expressions have the same effect:\n \n-~~~~{.xfail-test}\n-x = y\n-x <- copy y\n+~~~~\n+# let x = 0;\n+# let y = 0;\n+\n+x = y;\n+x <- copy y;\n ~~~~\n \n The former is just more terse and familiar.\n@@ -1871,7 +1934,9 @@ typestates propagate through function boundaries.\n \n An example of a call expression:\n \n-~~~~{.xfail-test}\n+~~~~\n+# fn add(x: int, y: int) -> int { 0 }\n+\n let x: int = add(1, 2);\n ~~~~\n \n@@ -1949,18 +2014,24 @@ loop body. If it evaluates to `false`, control exits the loop.\n \n An example of a simple `while` expression:\n \n-~~~~{.xfail-test}\n+~~~~\n+# let i = 0;\n+# let println = io::println;\n+\n while i < 10 {\n-    print(\"hello\\n\");\n+    println(\"hello\\n\");\n     i = i + 1;\n }\n ~~~~\n \n An example of a `do`-`while` expression:\n \n-~~~~{.xfail-test}\n+~~~~\n+# let i = 0;\n+# let println = io::println;\n+\n do {\n-    print(\"hello\\n\");\n+    println(\"hello\\n\");\n     i = i + 1;\n } while i < 10;\n ~~~~\n@@ -2035,7 +2106,11 @@ elements of the underlying sequence, one iteration per sequence element.\n \n An example a for loop:\n \n-~~~~{.xfail-test}\n+~~~~\n+# type foo = int;\n+# fn bar(f: foo) { }\n+# let a = 0, b = 0, c = 0;\n+\n let v: [foo] = [a, b, c];\n \n for e: foo in v {\n@@ -2093,8 +2168,11 @@ variables in the arm's block, and control enters the block.\n An example of an `alt` expression:\n \n \n-~~~~{.xfail-test}\n-enum list<X> { nil; cons(X, @list<X>); }\n+~~~~\n+# fn process_pair(a: int, b: int) { }\n+# fn process_ten() { }\n+\n+enum list<X> { nil, cons(X, @list<X>) }\n \n let x: list<int> = cons(10, @cons(11, @nil));\n \n@@ -2118,7 +2196,13 @@ Records can also be pattern-matched and their fields bound to variables.\n When matching fields of a record, the fields being matched are specified\n first, then a placeholder (`_`) represents the remaining fields.\n \n-~~~~{.xfail-test}\n+~~~~\n+# type options = {choose: bool, size: str};\n+# type player = {player: str, stats: (), options: options};\n+# fn load_stats() { }\n+# fn choose_player(r: player) { }\n+# fn next_player() { }\n+\n fn main() {\n     let r = {\n         player: \"ralph\",\n@@ -2146,24 +2230,31 @@ fn main() {\n Multiple alternative patterns may be joined with the `|` operator.  A\n range of values may be specified with `to`.  For example:\n \n-~~~~{.xfail-test}\n+~~~~\n+# let x = 2;\n+\n let message = alt x {\n   0 | 1  { \"not many\" }\n   2 to 9 { \"a few\" }\n   _      { \"lots\" }\n-}\n+};\n ~~~~\n \n Finally, alt patterns can accept *pattern guards* to further refine the\n criteria for matching a case. Pattern guards appear after the pattern and\n consist of a bool-typed expression following the `if` keyword. A pattern\n guard may refer to the variables bound within the pattern they follow.\n \n-~~~~{.xfail-test}\n+~~~~\n+# let maybe_digit = some(0);\n+# fn process_digit(i: int) { }\n+# fn process_other(i: int) { }\n+\n let message = alt maybe_digit {\n   some(x) if x < 10 { process_digit(x) }\n   some(x) { process_other(x) }\n-}\n+  none { fail }\n+};\n ~~~~\n \n \n@@ -2276,7 +2367,9 @@ syntax-extension.\n The following examples all produce the same output, logged at the `error`\n logging level:\n \n-~~~~{.xfail-test}\n+~~~~\n+# let filename = \"bulbasaur\";\n+\n // Full version, logging a value.\n log(core::error, \"file not found: \" + filename);\n \n@@ -2327,7 +2420,9 @@ itself. From there, the typestate algorithm can perform dataflow calculations\n on subsequent expressions, propagating [conditions](#conditions) forward and\n statically comparing implied states and their specifications.\n \n-~~~~~~~~{.xfail-test}\n+~~~~~~~~\n+# fn print(i: int) { }\n+\n pure fn even(x: int) -> bool {\n     ret x & 1 == 0;\n }\n@@ -2392,14 +2487,22 @@ following two examples are equivalent:\n \n Example using `check`:\n \n-~~~~{.xfail-test}\n+~~~~\n+# pure fn even(x: int) -> bool { true }\n+# fn print_even(x: int) { }\n+# let x = 0;\n+\n check even(x);\n print_even(x);\n ~~~~\n \n Equivalent example using `if check`:\n \n-~~~~{.xfail-test}\n+~~~~\n+# pure fn even(x: int) -> bool { true }\n+# fn print_even(x: int) { }\n+# let x = 0;\n+\n if check even(x) {\n     print_even(x);\n } else {"}]}