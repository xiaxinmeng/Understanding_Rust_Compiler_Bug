{"sha": "a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZGU5YmI1OTFjOTc1MmQzOWM4NzMzOWZkOGY1ZmY0OWVhNGIyZGE=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-28T20:17:34Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-10-28T20:17:34Z"}, "message": "Remove unsafe libc layer", "tree": {"sha": "69c296d20f5fe58d0bbd2b603bd4143430a5d6a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69c296d20f5fe58d0bbd2b603bd4143430a5d6a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "html_url": "https://github.com/rust-lang/rust/commit/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c", "html_url": "https://github.com/rust-lang/rust/commit/8b09e01fef9912e7c3eef997c40f9f4f91d09e4c"}], "stats": {"total": 830, "additions": 193, "deletions": 637}, "files": [{"sha": "5845963d31a1030bef0eb81ca76dc36fa26f166b", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -348,6 +348,16 @@ impl File {\n             inner: self.inner.duplicate()?\n         })\n     }\n+\n+    /// Get the path that this file points to.\n+    ///\n+    /// This function is only implemented on Redox, but could be\n+    /// implemented on other operating systems using readlink\n+    #[cfg(redox)]\n+    #[stable(feature = \"rust1\", since = \"1.14.0\")]\n+    pub fn path(&self) -> io::Result<PathBuf> {\n+        self.inner.path()\n+    }\n }\n \n impl AsInner<fs_imp::File> for File {"}, {"sha": "4f39f3b4f33f7c1d1ed2e30e57308dd81d5a28ce", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -13,13 +13,12 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use fs;\n-use os::raw;\n use sys;\n use sys_common::{AsInner, FromInner, IntoInner};\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub type RawFd = raw::c_int;\n+pub type RawFd = usize;\n \n /// A trait to extract the raw unix file descriptor from an underlying\n /// object."}, {"sha": "4c4dae7cd418b73798e9eea0d8e4fc616f5b431d", "filename": "src/libstd/sys/redox/fd.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -11,37 +11,32 @@\n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n use io::{self, Read};\n-use libc::{self, c_int, c_void};\n+use libc;\n use mem;\n use sys::cvt;\n use sys_common::AsInner;\n use sys_common::io::read_to_end_uninitialized;\n \n pub struct FileDesc {\n-    fd: c_int,\n+    fd: usize,\n }\n \n impl FileDesc {\n-    pub fn new(fd: c_int) -> FileDesc {\n+    pub fn new(fd: usize) -> FileDesc {\n         FileDesc { fd: fd }\n     }\n \n-    pub fn raw(&self) -> c_int { self.fd }\n+    pub fn raw(&self) -> usize { self.fd }\n \n     /// Extracts the actual filedescriptor without closing it.\n-    pub fn into_raw(self) -> c_int {\n+    pub fn into_raw(self) -> usize {\n         let fd = self.fd;\n         mem::forget(self);\n         fd\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::read(self.fd,\n-                       buf.as_mut_ptr() as *mut c_void,\n-                       buf.len())\n-        })?;\n-        Ok(ret as usize)\n+        cvt(libc::read(self.fd, buf))\n     }\n \n     pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n@@ -50,12 +45,7 @@ impl FileDesc {\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n-        let ret = cvt(unsafe {\n-            libc::write(self.fd,\n-                        buf.as_ptr() as *const c_void,\n-                        buf.len())\n-        })?;\n-        Ok(ret as usize)\n+        cvt(libc::write(self.fd, buf))\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n@@ -86,7 +76,7 @@ impl FileDesc {\n     }\n \n     pub fn duplicate(&self) -> io::Result<FileDesc> {\n-        let new_fd = cvt(unsafe { libc::dup(self.fd) })?;\n+        let new_fd = cvt(libc::dup(self.fd, &[]))?;\n         Ok(FileDesc::new(new_fd))\n     }\n }\n@@ -101,8 +91,8 @@ impl<'a> Read for &'a FileDesc {\n     }\n }\n \n-impl AsInner<c_int> for FileDesc {\n-    fn as_inner(&self) -> &c_int { &self.fd }\n+impl AsInner<usize> for FileDesc {\n+    fn as_inner(&self) -> &usize { &self.fd }\n }\n \n impl Drop for FileDesc {\n@@ -112,6 +102,6 @@ impl Drop for FileDesc {\n         // the file descriptor was closed or not, and if we retried (for\n         // something like EINTR), we might close another valid file descriptor\n         // (opened after we closed ours.\n-        let _ = unsafe { libc::close(self.fd) };\n+        let _ = libc::close(self.fd);\n     }\n }"}, {"sha": "ca1a7963f8e6ec56aff61a47cefc719c18d5ebaa", "filename": "src/libstd/sys/redox/fs.rs", "status": "modified", "additions": 46, "deletions": 140, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffs.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -10,26 +10,24 @@\n \n use os::unix::prelude::*;\n \n-use ffi::{CString, CStr, OsString, OsStr};\n+use ffi::{OsString, OsStr};\n use fmt;\n use io::{self, Error, ErrorKind, SeekFrom};\n use libc::{self, c_int, mode_t};\n-use mem;\n use path::{Path, PathBuf};\n use sync::Arc;\n use sys::fd::FileDesc;\n use sys::time::SystemTime;\n-use sys::{cvt, cvt_r};\n+use sys::cvt;\n use sys_common::{AsInner, FromInner};\n \n-use libc::{stat as stat64, fstat as fstat64, lstat as lstat64, off_t as off64_t,\n-           ftruncate as ftruncate64, lseek as lseek64, open as open64};\n+use libc::{stat, fstat, fsync, ftruncate, lseek, open};\n \n pub struct File(FileDesc);\n \n #[derive(Clone)]\n pub struct FileAttr {\n-    stat: stat64,\n+    stat: stat,\n }\n \n pub struct ReadDir {\n@@ -104,8 +102,8 @@ impl FileAttr {\n     }\n }\n \n-impl AsInner<stat64> for FileAttr {\n-    fn as_inner(&self) -> &stat64 { &self.stat }\n+impl AsInner<stat> for FileAttr {\n+    fn as_inner(&self) -> &stat { &self.stat }\n }\n \n impl FilePermissions {\n@@ -254,60 +252,32 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = cstr(path)?;\n-        File::open_c(&path, opts)\n-    }\n-\n-    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n-        let flags = libc::O_CLOEXEC as i32 |\n-                    opts.get_access_mode()? |\n-                    opts.get_creation_mode()? |\n-                    (opts.custom_flags as usize & !libc::O_ACCMODE) as i32;\n-        let fd = cvt_r(|| unsafe {\n-            open64(path.as_ptr(), flags, opts.mode as mode_t)\n-        })?;\n-        let fd = FileDesc::new(fd);\n-\n-        Ok(File(fd))\n+        let flags = libc::O_CLOEXEC |\n+                    opts.get_access_mode()? as usize |\n+                    opts.get_creation_mode()? as usize |\n+                    (opts.custom_flags as usize & !libc::O_ACCMODE);\n+        let fd = cvt(open(path.to_str().unwrap(), flags | opts.mode as usize))?;\n+        Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n-        let mut stat: stat64 = unsafe { mem::zeroed() };\n-        cvt(unsafe {\n-            fstat64(self.0.raw(), &mut stat)\n-        })?;\n+        let mut stat: stat = stat::default();\n+        cvt(fstat(self.0.raw(), &mut stat))?;\n         Ok(FileAttr { stat: stat })\n     }\n \n     pub fn fsync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { libc::fsync(self.0.raw()) })?;\n+        cvt(fsync(self.0.raw()))?;\n         Ok(())\n     }\n \n     pub fn datasync(&self) -> io::Result<()> {\n-        cvt_r(|| unsafe { os_datasync(self.0.raw()) })?;\n-        return Ok(());\n-\n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-        unsafe fn os_datasync(fd: c_int) -> c_int {\n-            libc::fcntl(fd, libc::F_FULLFSYNC)\n-        }\n-        #[cfg(target_os = \"linux\")]\n-        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fdatasync(fd) }\n-        #[cfg(not(any(target_os = \"macos\",\n-                      target_os = \"ios\",\n-                      target_os = \"linux\")))]\n-        unsafe fn os_datasync(fd: c_int) -> c_int { libc::fsync(fd) }\n+        self.fsync()\n     }\n \n     pub fn truncate(&self, size: u64) -> io::Result<()> {\n-        #[cfg(target_os = \"android\")]\n-        return ::sys::android::ftruncate64(self.0.raw(), size);\n-\n-        #[cfg(not(target_os = \"android\"))]\n-        return cvt_r(|| unsafe {\n-            ftruncate64(self.0.raw(), size as off64_t)\n-        }).map(|_| ());\n+        cvt(ftruncate(self.0.raw(), size as usize))?;\n+        Ok(())\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n@@ -332,7 +302,7 @@ impl File {\n             SeekFrom::End(off) => (libc::SEEK_END, off),\n             SeekFrom::Current(off) => (libc::SEEK_CUR, off),\n         };\n-        let n = cvt(unsafe { lseek64(self.0.raw(), pos as usize, whence) } as isize)?;\n+        let n = cvt(lseek(self.0.raw(), pos as isize, whence))?;\n         Ok(n as u64)\n     }\n \n@@ -341,9 +311,8 @@ impl File {\n     }\n \n     pub fn dup(&self, buf: &[u8]) -> io::Result<File> {\n-        libc::dup_extra(*self.fd().as_inner() as usize, buf)\n-            .map(|fd| File(FileDesc::new(fd as i32)))\n-            .map_err(|err| Error::from_raw_os_error(err.errno))\n+        let fd = cvt(libc::dup(*self.fd().as_inner() as usize, buf))?;\n+        Ok(File(FileDesc::new(fd)))\n     }\n \n     pub fn path(&self) -> io::Result<PathBuf> {\n@@ -365,8 +334,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = cstr(p)?;\n-        cvt(unsafe { libc::mkdir(p.as_ptr(), self.mode) })?;\n+        cvt(libc::mkdir(p.to_str().unwrap(), self.mode))?;\n         Ok(())\n     }\n \n@@ -375,96 +343,39 @@ impl DirBuilder {\n     }\n }\n \n-fn cstr(path: &Path) -> io::Result<CString> {\n-    Ok(CString::new(path.as_os_str().as_bytes())?)\n-}\n-\n-impl FromInner<c_int> for File {\n-    fn from_inner(fd: c_int) -> File {\n+impl FromInner<usize> for File {\n+    fn from_inner(fd: usize) -> File {\n         File(FileDesc::new(fd))\n     }\n }\n \n impl fmt::Debug for File {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        #[cfg(target_os = \"linux\")]\n-        fn get_path(fd: c_int) -> Option<PathBuf> {\n-            let mut p = PathBuf::from(\"/proc/self/fd\");\n-            p.push(&fd.to_string());\n-            readlink(&p).ok()\n-        }\n-\n-        #[cfg(target_os = \"macos\")]\n-        fn get_path(fd: c_int) -> Option<PathBuf> {\n-            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n-            // is inevitable in this case because OS X defines `fcntl` with\n-            // `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n-            // alternatives. If a better method is invented, it should be used\n-            // instead.\n-            let mut buf = vec![0;libc::PATH_MAX as usize];\n-            let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n-            if n == -1 {\n-                return None;\n-            }\n-            let l = buf.iter().position(|&c| c == 0).unwrap();\n-            buf.truncate(l as usize);\n-            buf.shrink_to_fit();\n-            Some(PathBuf::from(OsString::from_vec(buf)))\n-        }\n-\n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n-        fn get_path(_fd: c_int) -> Option<PathBuf> {\n-            // FIXME(#24570): implement this for other Unix platforms\n-            None\n-        }\n-\n-        #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n-        fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n-            let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n-            if mode == -1 {\n-                return None;\n-            }\n-            match mode & libc::O_ACCMODE {\n-                libc::O_RDONLY => Some((true, false)),\n-                libc::O_RDWR => Some((true, true)),\n-                libc::O_WRONLY => Some((false, true)),\n-                _ => None\n-            }\n-        }\n-\n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n-        fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n-            // FIXME(#24570): implement this for other Unix platforms\n-            None\n-        }\n-\n-        let fd = self.0.raw();\n         let mut b = f.debug_struct(\"File\");\n-        b.field(\"fd\", &fd);\n-        if let Some(path) = get_path(fd) {\n+        b.field(\"fd\", &self.0.raw());\n+        if let Ok(path) = self.path() {\n             b.field(\"path\", &path);\n         }\n+        /*\n         if let Some((read, write)) = get_mode(fd) {\n             b.field(\"read\", &read).field(\"write\", &write);\n         }\n+        */\n         b.finish()\n     }\n }\n \n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = Arc::new(p.to_path_buf());\n-    let p = cstr(p)?;\n-    unsafe {\n-        let fd = FileDesc::new(cvt(libc::open(p.as_ptr(), 0, 0))?);\n-        let mut data = Vec::new();\n-        fd.read_to_end(&mut data)?;\n-        Ok(ReadDir { data: data, i: 0, root: root })\n-    }\n+    let options = OpenOptions::new();\n+    let fd = File::open(p, &options)?;\n+    let mut data = Vec::new();\n+    fd.read_to_end(&mut data)?;\n+    Ok(ReadDir { data: data, i: 0, root: root })\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::unlink(p.as_ptr()) })?;\n+    cvt(libc::unlink(p.to_str().unwrap()))?;\n     Ok(())\n }\n \n@@ -477,8 +388,7 @@ pub fn set_perm(_p: &Path, _perm: FilePermissions) -> io::Result<()> {\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = cstr(p)?;\n-    cvt(unsafe { libc::rmdir(p.as_ptr()) })?;\n+    cvt(libc::rmdir(p.to_str().unwrap()))?;\n     Ok(())\n }\n \n@@ -503,8 +413,8 @@ fn remove_dir_all_recursive(path: &Path) -> io::Result<()> {\n     rmdir(path)\n }\n \n-pub fn readlink(_p: &Path) -> io::Result<PathBuf> {\n-    unimplemented!();\n+pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n+    canonicalize(p)\n }\n \n pub fn symlink(_src: &Path, _dst: &Path) -> io::Result<()> {\n@@ -516,25 +426,21 @@ pub fn link(_src: &Path, _dst: &Path) -> io::Result<()> {\n }\n \n pub fn stat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe {\n-        stat64(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    })?;\n+    let mut stat: stat = stat::default();\n+    let options = OpenOptions::new();\n+    let file = File::open(p, &options)?;\n+    cvt(fstat(file.0.raw(), &mut stat))?;\n     Ok(FileAttr { stat: stat })\n }\n \n pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n-    let p = cstr(p)?;\n-    let mut stat: stat64 = unsafe { mem::zeroed() };\n-    cvt(unsafe {\n-        lstat64(p.as_ptr(), &mut stat as *mut _ as *mut _)\n-    })?;\n-    Ok(FileAttr { stat: stat })\n+    stat(p)\n }\n \n-pub fn canonicalize(_p: &Path) -> io::Result<PathBuf> {\n-    unimplemented!();\n+pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n+    let options = OpenOptions::new();\n+    let file = File::open(p, &options)?;\n+    file.path()\n }\n \n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {"}, {"sha": "f7465d01fada3ad2a8646faf9846dbbb242bda58", "filename": "src/libstd/sys/redox/mod.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fmod.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -41,9 +41,7 @@ pub fn init() {\n         use intrinsics;\n         let msg = \"fatal runtime error: out of memory\\n\";\n         unsafe {\n-            libc::write(libc::STDERR_FILENO,\n-                        msg.as_ptr() as *const libc::c_void,\n-                        msg.len());\n+            let _ = libc::write(libc::STDERR_FILENO, msg.as_bytes());\n             intrinsics::abort();\n         }\n     }\n@@ -75,37 +73,6 @@ pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     }\n }\n \n-#[doc(hidden)]\n-pub trait IsMinusOne {\n-    fn is_minus_one(&self) -> bool;\n-}\n-\n-macro_rules! impl_is_minus_one {\n-    ($($t:ident)*) => ($(impl IsMinusOne for $t {\n-        fn is_minus_one(&self) -> bool {\n-            *self == -1\n-        }\n-    })*)\n-}\n-\n-impl_is_minus_one! { i8 i16 i32 i64 isize }\n-\n-pub fn cvt<T: IsMinusOne>(t: T) -> io::Result<T> {\n-    if t.is_minus_one() {\n-        Err(io::Error::last_os_error())\n-    } else {\n-        Ok(t)\n-    }\n-}\n-\n-pub fn cvt_r<T, F>(mut f: F) -> io::Result<T>\n-    where T: IsMinusOne,\n-          F: FnMut() -> T\n-{\n-    loop {\n-        match cvt(f()) {\n-            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-            other => return other,\n-        }\n-    }\n+pub fn cvt(result: Result<usize, libc::Error>) -> io::Result<usize> {\n+    result.map_err(|err| io::Error::from_raw_os_error(err.errno as i32))\n }"}, {"sha": "c2e419aeaaa5ae925ddd1dff21acd5c2bed1f8da", "filename": "src/libstd/sys/redox/os.rs", "status": "modified", "additions": 11, "deletions": 91, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fos.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -35,109 +35,28 @@ use vec;\n const TMPBUF_SZ: usize = 128;\n static ENV_LOCK: Mutex = Mutex::new();\n \n-\n-extern {\n-    #[cfg(not(target_os = \"dragonfly\"))]\n-    #[cfg_attr(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"fuchsia\"),\n-               link_name = \"__errno_location\")]\n-    #[cfg_attr(any(target_os = \"bitrig\",\n-                   target_os = \"netbsd\",\n-                   target_os = \"openbsd\",\n-                   target_os = \"android\",\n-                   target_env = \"newlib\"),\n-               link_name = \"__errno\")]\n-    #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n-    #[cfg_attr(any(target_os = \"macos\",\n-                   target_os = \"ios\",\n-                   target_os = \"freebsd\"),\n-               link_name = \"__error\")]\n-    #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n-    fn errno_location() -> *mut c_int;\n-}\n-\n /// Returns the platform-specific value of errno\n-#[cfg(not(target_os = \"dragonfly\"))]\n pub fn errno() -> i32 {\n-    unsafe {\n-        (*errno_location()) as i32\n-    }\n-}\n-\n-/// Sets the platform-specific value of errno\n-#[cfg(target_os = \"solaris\")] // only needed for readdir so far\n-pub fn set_errno(e: i32) {\n-    unsafe {\n-        *errno_location() = e as c_int\n-    }\n-}\n-\n-#[cfg(target_os = \"dragonfly\")]\n-pub fn errno() -> i32 {\n-    extern {\n-        #[thread_local]\n-        static errno: c_int;\n-    }\n-\n-    errno as i32\n+    0\n }\n \n /// Gets a detailed string description for the given error number.\n pub fn error_string(errno: i32) -> String {\n-    extern {\n-        #[cfg_attr(any(target_os = \"linux\", target_env = \"newlib\"),\n-                   link_name = \"__xpg_strerror_r\")]\n-        fn strerror_r(errnum: c_int, buf: *mut c_char,\n-                      buflen: libc::size_t) -> c_int;\n-    }\n-\n-    let mut buf = [0 as c_char; TMPBUF_SZ];\n-\n-    let p = buf.as_mut_ptr();\n-    unsafe {\n-        if strerror_r(errno as c_int, p, buf.len()) < 0 {\n-            panic!(\"strerror_r failure\");\n-        }\n-\n-        let p = p as *const _;\n-        str::from_utf8(CStr::from_ptr(p).to_bytes()).unwrap().to_owned()\n+    if let Some(string) = libc::STR_ERROR.get(errno as usize) {\n+        string.to_string()\n+    } else {\n+        \"unknown error\".to_string()\n     }\n }\n \n pub fn getcwd() -> io::Result<PathBuf> {\n-    let mut buf = Vec::with_capacity(512);\n-    loop {\n-        unsafe {\n-            let ptr = buf.as_mut_ptr() as *mut libc::c_char;\n-            if !libc::getcwd(ptr, buf.capacity()).is_null() {\n-                let len = CStr::from_ptr(buf.as_ptr() as *const libc::c_char).to_bytes().len();\n-                buf.set_len(len);\n-                buf.shrink_to_fit();\n-                return Ok(PathBuf::from(OsString::from_vec(buf)));\n-            } else {\n-                let error = io::Error::last_os_error();\n-                if error.raw_os_error() != Some(libc::ERANGE) {\n-                    return Err(error);\n-                }\n-            }\n-\n-            // Trigger the internal buffer resizing logic of `Vec` by requiring\n-            // more space than the current capacity.\n-            let cap = buf.capacity();\n-            buf.set_len(cap);\n-            buf.reserve(1);\n-        }\n-    }\n+    let mut buf = [0; 4096];\n+    let count = cvt(libc::getcwd(&mut buf))?;\n+    Ok(PathBuf::from(OsString::from_vec(buf[.. count].to_vec())))\n }\n \n pub fn chdir(p: &path::Path) -> io::Result<()> {\n-    let p: &OsStr = p.as_ref();\n-    let p = CString::new(p.as_bytes())?;\n-    unsafe {\n-        match libc::chdir(p.as_ptr()) == (0 as c_int) {\n-            true => Ok(()),\n-            false => Err(io::Error::last_os_error()),\n-        }\n-    }\n+    cvt(libc::chdir(p.to_str().unwrap())).and(Ok(()))\n }\n \n pub struct SplitPaths<'a> {\n@@ -242,5 +161,6 @@ pub fn home_dir() -> Option<PathBuf> {\n }\n \n pub fn exit(code: i32) -> ! {\n-    unsafe { libc::exit(code as c_int) }\n+    let _ = libc::exit(code as usize);\n+    unreachable!();\n }"}, {"sha": "5902ba128e8d7168ec63dfd295c8a4e215cb2ebb", "filename": "src/libstd/sys/redox/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fpipe.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use io;\n-use libc::{self, c_int};\n+use libc;\n use sys::fd::FileDesc;\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -23,8 +23,8 @@ pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n \n     libc::pipe2(&mut fds, libc::O_CLOEXEC).map_err(|err| io::Error::from_raw_os_error(err.errno))?;\n \n-    let fd0 = FileDesc::new(fds[0] as c_int);\n-    let fd1 = FileDesc::new(fds[1] as c_int);\n+    let fd0 = FileDesc::new(fds[0]);\n+    let fd1 = FileDesc::new(fds[1]);\n     Ok((AnonPipe::from_fd(fd0)?, AnonPipe::from_fd(fd1)?))\n }\n "}, {"sha": "921e3f056daba21fc7323790b67be1187d7d6963", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 28, "deletions": 109, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -12,14 +12,15 @@ use os::unix::prelude::*;\n \n use collections::hash_map::HashMap;\n use env;\n-use ffi::{OsStr, CString, CStr};\n+use ffi::{OsStr, CString};\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_int, gid_t, uid_t};\n+use path::Path;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n-use sys::{self, cvt, cvt_r};\n+use sys::{self, cvt};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -47,7 +48,7 @@ pub struct Command {\n     args: Vec<String>,\n     env: HashMap<String, String>,\n \n-    cwd: Option<CString>,\n+    cwd: Option<String>,\n     uid: Option<uid_t>,\n     gid: Option<gid_t>,\n     saw_nul: bool,\n@@ -75,7 +76,7 @@ struct ChildPipes {\n \n enum ChildStdio {\n     Inherit,\n-    Explicit(c_int),\n+    Explicit(usize),\n     Owned(FileDesc),\n }\n \n@@ -120,7 +121,7 @@ impl Command {\n     }\n \n     pub fn cwd(&mut self, dir: &OsStr) {\n-        self.cwd = Some(os2c(dir, &mut self.saw_nul));\n+        self.cwd = Some(dir.to_str().unwrap().to_owned());\n     }\n     pub fn uid(&mut self, id: uid_t) {\n         self.uid = Some(id);\n@@ -157,7 +158,7 @@ impl Command {\n         let (input, output) = sys::pipe::anon_pipe()?;\n \n         let pid = unsafe {\n-            match cvt(libc::fork() as isize)? {\n+            match cvt(libc::clone(0))? {\n                 0 => {\n                     drop(input);\n                     let err = self.do_exec(theirs);\n@@ -174,7 +175,8 @@ impl Command {\n                     // we want to be sure we *don't* run at_exit destructors as\n                     // we're being torn down regardless\n                     assert!(output.write(&bytes).is_ok());\n-                    libc::_exit(1)\n+                    let _ = libc::exit(1);\n+                    unreachable!();\n                 }\n                 n => n as pid_t,\n             }\n@@ -271,29 +273,29 @@ impl Command {\n         }\n \n         if let Some(fd) = stdio.stderr.fd() {\n-            libc::close(libc::STDERR_FILENO);\n-            t!(cvt(libc::dup(fd)));\n-            libc::close(fd);\n+            let _ = libc::close(libc::STDERR_FILENO);\n+            t!(cvt(libc::dup(fd, &[])));\n+            let _ = libc::close(fd);\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n-            libc::close(libc::STDOUT_FILENO);\n-            t!(cvt(libc::dup(fd)));\n-            libc::close(fd);\n+            let _ = libc::close(libc::STDOUT_FILENO);\n+            t!(cvt(libc::dup(fd, &[])));\n+            let _ = libc::close(fd);\n         }\n         if let Some(fd) = stdio.stdin.fd() {\n-            libc::close(libc::STDIN_FILENO);\n-            t!(cvt(libc::dup(fd)));\n-            libc::close(fd);\n+            let _ = libc::close(libc::STDIN_FILENO);\n+            t!(cvt(libc::dup(fd, &[])));\n+            let _ = libc::close(fd);\n         }\n \n-        if let Some(u) = self.gid {\n-            t!(cvt(libc::setgid(u as gid_t)));\n+        if let Some(g) = self.gid {\n+            t!(cvt(libc::setgid(g)));\n         }\n         if let Some(u) = self.uid {\n-            t!(cvt(libc::setuid(u as uid_t)));\n+            t!(cvt(libc::setuid(u)));\n         }\n         if let Some(ref cwd) = self.cwd {\n-            t!(cvt(libc::chdir(cwd.as_ptr())));\n+            t!(cvt(libc::chdir(cwd)));\n         }\n \n         for callback in self.closures.iter_mut() {\n@@ -363,7 +365,7 @@ impl Stdio {\n             // stderr. No matter which we dup first, the second will get\n             // overwritten prematurely.\n             Stdio::Fd(ref fd) => {\n-                if fd.raw() >= 0 && fd.raw() <= libc::STDERR_FILENO {\n+                if fd.raw() <= libc::STDERR_FILENO {\n                     Ok((ChildStdio::Owned(fd.duplicate()?), None))\n                 } else {\n                     Ok((ChildStdio::Explicit(fd.raw()), None))\n@@ -384,18 +386,15 @@ impl Stdio {\n                 let mut opts = OpenOptions::new();\n                 opts.read(readable);\n                 opts.write(!readable);\n-                let path = unsafe {\n-                    CStr::from_ptr(\"/dev/null\\0\".as_ptr() as *const _)\n-                };\n-                let fd = File::open_c(&path, &opts)?;\n+                let fd = File::open(&Path::new(\"null:\"), &opts)?;\n                 Ok((ChildStdio::Owned(fd.into_fd()), None))\n             }\n         }\n     }\n }\n \n impl ChildStdio {\n-    fn fd(&self) -> Option<c_int> {\n+    fn fd(&self) -> Option<usize> {\n         match *self {\n             ChildStdio::Inherit => None,\n             ChildStdio::Explicit(fd) => Some(fd),\n@@ -496,7 +495,8 @@ impl Process {\n             Err(Error::new(ErrorKind::InvalidInput,\n                            \"invalid argument: can't kill an exited process\"))\n         } else {\n-            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+            cvt(libc::kill(self.pid, libc::SIGKILL))?;\n+            Ok(())\n         }\n     }\n \n@@ -505,89 +505,8 @@ impl Process {\n             return Ok(status)\n         }\n         let mut status = 0;\n-        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n+        cvt(libc::waitpid(self.pid, &mut status, 0))?;\n         self.status = Some(ExitStatus(status as i32));\n         Ok(ExitStatus(status as i32))\n     }\n }\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests {\n-    use super::*;\n-\n-    use ffi::OsStr;\n-    use mem;\n-    use ptr;\n-    use libc;\n-    use sys::cvt;\n-\n-    macro_rules! t {\n-        ($e:expr) => {\n-            match $e {\n-                Ok(t) => t,\n-                Err(e) => panic!(\"received error for `{}`: {}\", stringify!($e), e),\n-            }\n-        }\n-    }\n-\n-    #[cfg(not(target_os = \"android\"))]\n-    extern {\n-        #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaddset14\")]\n-        fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int;\n-    }\n-\n-    #[cfg(target_os = \"android\")]\n-    unsafe fn sigaddset(set: *mut libc::sigset_t, signum: libc::c_int) -> libc::c_int {\n-        use slice;\n-\n-        let raw = slice::from_raw_parts_mut(set as *mut u8, mem::size_of::<libc::sigset_t>());\n-        let bit = (signum - 1) as usize;\n-        raw[bit / 8] |= 1 << (bit % 8);\n-        return 0;\n-    }\n-\n-    // See #14232 for more information, but it appears that signal delivery to a\n-    // newly spawned process may just be raced in the OSX, so to prevent this\n-    // test from being flaky we ignore it on OSX.\n-    #[test]\n-    #[cfg_attr(target_os = \"macos\", ignore)]\n-    #[cfg_attr(target_os = \"nacl\", ignore)] // no signals on NaCl.\n-    fn test_process_mask() {\n-        unsafe {\n-            // Test to make sure that a signal mask does not get inherited.\n-            let mut cmd = Command::new(OsStr::new(\"cat\"));\n-\n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            let mut old_set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(libc::sigemptyset(&mut set)));\n-            t!(cvt(sigaddset(&mut set, libc::SIGINT)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set, &mut old_set)));\n-\n-            cmd.stdin(Stdio::MakePipe);\n-            cmd.stdout(Stdio::MakePipe);\n-\n-            let (mut cat, mut pipes) = t!(cmd.spawn(Stdio::Null, true));\n-            let stdin_write = pipes.stdin.take().unwrap();\n-            let stdout_read = pipes.stdout.take().unwrap();\n-\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &old_set,\n-                                         ptr::null_mut())));\n-\n-            t!(cvt(libc::kill(cat.id() as libc::pid_t, libc::SIGINT)));\n-            // We need to wait until SIGINT is definitely delivered. The\n-            // easiest way is to write something to cat, and try to read it\n-            // back: if SIGINT is unmasked, it'll get delivered when cat is\n-            // next scheduled.\n-            let _ = stdin_write.write(b\"Hello\");\n-            drop(stdin_write);\n-\n-            // Either EOF or failure (EPIPE) is okay.\n-            let mut buf = [0; 5];\n-            if let Ok(ret) = stdout_read.read(&mut buf) {\n-                assert!(ret == 0);\n-            }\n-\n-            t!(cat.wait());\n-        }\n-    }\n-}"}, {"sha": "616da662d9ac1f1d1586fad2718d98a3c6a955b5", "filename": "src/libstd/sys/redox/thread.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fthread.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -14,7 +14,6 @@ use ffi::CStr;\n use io;\n use libc;\n use mem;\n-use sys::os;\n use sys_common::thread::start_thread;\n use time::Duration;\n \n@@ -42,7 +41,7 @@ impl Thread {\n     }\n \n     pub fn set_name(_name: &CStr) {\n-\n+        unimplemented!();\n     }\n \n     pub fn sleep(dur: Duration) {\n@@ -51,20 +50,18 @@ impl Thread {\n \n         // If we're awoken with a signal then the return value will be -1 and\n         // nanosleep will fill in `ts` with the remaining time.\n-        unsafe {\n-            while secs > 0 || nsecs > 0 {\n-                let mut ts = libc::timespec {\n-                    tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n-                    tv_nsec: nsecs,\n-                };\n-                secs -= ts.tv_sec as u64;\n-                if libc::nanosleep(&ts, &mut ts) == -1 {\n-                    assert_eq!(os::errno(), libc::EINTR);\n-                    secs += ts.tv_sec as u64;\n-                    nsecs = ts.tv_nsec;\n-                } else {\n-                    nsecs = 0;\n-                }\n+        while secs > 0 || nsecs > 0 {\n+            let req = libc::timespec {\n+                tv_sec: cmp::min(libc::time_t::max_value() as u64, secs) as libc::time_t,\n+                tv_nsec: nsecs,\n+            };\n+            secs -= req.tv_sec as u64;\n+            let mut rem = libc::timespec::default();\n+            if libc::nanosleep(&req, &mut rem).is_err() {\n+                secs += rem.tv_sec as u64;\n+                nsecs = rem.tv_nsec;\n+            } else {\n+                nsecs = 0;\n             }\n         }\n     }"}, {"sha": "4e1a82bcc9a092cf293617889a3d3758c3b894ef", "filename": "src/libstd/sys/redox/time.rs", "status": "modified", "additions": 67, "deletions": 219, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5de9bb591c9752d39c87339fd8f5ff49ea4b2da/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ftime.rs?ref=a5de9bb591c9752d39c87339fd8f5ff49ea4b2da", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use cmp::Ordering;\n+use fmt;\n use libc;\n+use sys::cvt;\n use time::Duration;\n \n-pub use self::inner::{Instant, SystemTime, UNIX_EPOCH};\n-\n const NSEC_PER_SEC: u64 = 1_000_000_000;\n \n #[derive(Copy, Clone)]\n@@ -103,249 +103,97 @@ impl Ord for Timespec {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-mod inner {\n-    use fmt;\n-    use libc;\n-    use sync::Once;\n-    use sys::cvt;\n-    use sys_common::mul_div_u64;\n-    use time::Duration;\n-\n-    use super::NSEC_PER_SEC;\n-    use super::Timespec;\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-    pub struct Instant {\n-        t: u64\n-    }\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Instant {\n+    t: Timespec,\n+}\n \n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct SystemTime {\n-        t: Timespec,\n-    }\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct SystemTime {\n+    t: Timespec,\n+}\n \n-    pub const UNIX_EPOCH: SystemTime = SystemTime {\n-        t: Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            },\n+pub const UNIX_EPOCH: SystemTime = SystemTime {\n+    t: Timespec {\n+        t: libc::timespec {\n+            tv_sec: 0,\n+            tv_nsec: 0,\n         },\n-    };\n+    },\n+};\n \n-    impl Instant {\n-        pub fn now() -> Instant {\n-            Instant { t: unsafe { libc::mach_absolute_time() } }\n-        }\n-\n-        pub fn sub_instant(&self, other: &Instant) -> Duration {\n-            let info = info();\n-            let diff = self.t.checked_sub(other.t)\n-                           .expect(\"second instant is later than self\");\n-            let nanos = mul_div_u64(diff, info.numer as u64, info.denom as u64);\n-            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n-        }\n-\n-        pub fn add_duration(&self, other: &Duration) -> Instant {\n-            Instant {\n-                t: self.t.checked_add(dur2intervals(other))\n-                       .expect(\"overflow when adding duration to instant\"),\n-            }\n-        }\n-\n-        pub fn sub_duration(&self, other: &Duration) -> Instant {\n-            Instant {\n-                t: self.t.checked_sub(dur2intervals(other))\n-                       .expect(\"overflow when adding duration to instant\"),\n-            }\n-        }\n+impl Instant {\n+    pub fn now() -> Instant {\n+        Instant { t: now(libc::CLOCK_MONOTONIC) }\n     }\n \n-    impl SystemTime {\n-        pub fn now() -> SystemTime {\n-            use ptr;\n-\n-            let mut s = libc::timeval {\n-                tv_sec: 0,\n-                tv_usec: 0,\n-            };\n-            cvt(unsafe {\n-                libc::gettimeofday(&mut s, ptr::null_mut())\n-            }).unwrap();\n-            return SystemTime::from(s)\n-        }\n-\n-        pub fn sub_time(&self, other: &SystemTime)\n-                        -> Result<Duration, Duration> {\n-            self.t.sub_timespec(&other.t)\n-        }\n-\n-        pub fn add_duration(&self, other: &Duration) -> SystemTime {\n-            SystemTime { t: self.t.add_duration(other) }\n-        }\n-\n-        pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n-            SystemTime { t: self.t.sub_duration(other) }\n-        }\n-    }\n-\n-    impl From<libc::timeval> for SystemTime {\n-        fn from(t: libc::timeval) -> SystemTime {\n-            SystemTime::from(libc::timespec {\n-                tv_sec: t.tv_sec,\n-                tv_nsec: (t.tv_usec * 1000) as libc::c_long,\n-            })\n-        }\n+    pub fn sub_instant(&self, other: &Instant) -> Duration {\n+        self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n+            panic!(\"other was less than the current instant\")\n+        })\n     }\n \n-    impl From<libc::timespec> for SystemTime {\n-        fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t: t } }\n-        }\n+    pub fn add_duration(&self, other: &Duration) -> Instant {\n+        Instant { t: self.t.add_duration(other) }\n     }\n \n-    impl fmt::Debug for SystemTime {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            f.debug_struct(\"SystemTime\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n-        }\n-    }\n-\n-    fn dur2intervals(dur: &Duration) -> u64 {\n-        let info = info();\n-        let nanos = dur.as_secs().checked_mul(NSEC_PER_SEC).and_then(|nanos| {\n-            nanos.checked_add(dur.subsec_nanos() as u64)\n-        }).expect(\"overflow converting duration to nanoseconds\");\n-        mul_div_u64(nanos, info.denom as u64, info.numer as u64)\n-    }\n-\n-    fn info() -> &'static libc::mach_timebase_info {\n-        static mut INFO: libc::mach_timebase_info = libc::mach_timebase_info {\n-            numer: 0,\n-            denom: 0,\n-        };\n-        static ONCE: Once = Once::new();\n-\n-        unsafe {\n-            ONCE.call_once(|| {\n-                libc::mach_timebase_info(&mut INFO);\n-            });\n-            &INFO\n-        }\n+    pub fn sub_duration(&self, other: &Duration) -> Instant {\n+        Instant { t: self.t.sub_duration(other) }\n     }\n }\n \n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n-mod inner {\n-    use fmt;\n-    use libc;\n-    use sys::cvt;\n-    use time::Duration;\n-\n-    use super::Timespec;\n-\n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct Instant {\n-        t: Timespec,\n+impl fmt::Debug for Instant {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"Instant\")\n+         .field(\"tv_sec\", &self.t.t.tv_sec)\n+         .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+         .finish()\n     }\n+}\n \n-    #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-    pub struct SystemTime {\n-        t: Timespec,\n+impl SystemTime {\n+    pub fn now() -> SystemTime {\n+        SystemTime { t: now(libc::CLOCK_REALTIME) }\n     }\n \n-    pub const UNIX_EPOCH: SystemTime = SystemTime {\n-        t: Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            },\n-        },\n-    };\n-\n-    impl Instant {\n-        pub fn now() -> Instant {\n-            Instant { t: now(libc::CLOCK_MONOTONIC) }\n-        }\n-\n-        pub fn sub_instant(&self, other: &Instant) -> Duration {\n-            self.t.sub_timespec(&other.t).unwrap_or_else(|_| {\n-                panic!(\"other was less than the current instant\")\n-            })\n-        }\n-\n-        pub fn add_duration(&self, other: &Duration) -> Instant {\n-            Instant { t: self.t.add_duration(other) }\n-        }\n-\n-        pub fn sub_duration(&self, other: &Duration) -> Instant {\n-            Instant { t: self.t.sub_duration(other) }\n-        }\n+    pub fn sub_time(&self, other: &SystemTime)\n+                    -> Result<Duration, Duration> {\n+        self.t.sub_timespec(&other.t)\n     }\n \n-    impl fmt::Debug for Instant {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            f.debug_struct(\"Instant\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n-        }\n+    pub fn add_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime { t: self.t.add_duration(other) }\n     }\n \n-    impl SystemTime {\n-        pub fn now() -> SystemTime {\n-            SystemTime { t: now(libc::CLOCK_REALTIME) }\n-        }\n-\n-        pub fn sub_time(&self, other: &SystemTime)\n-                        -> Result<Duration, Duration> {\n-            self.t.sub_timespec(&other.t)\n-        }\n-\n-        pub fn add_duration(&self, other: &Duration) -> SystemTime {\n-            SystemTime { t: self.t.add_duration(other) }\n-        }\n-\n-        pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n-            SystemTime { t: self.t.sub_duration(other) }\n-        }\n+    pub fn sub_duration(&self, other: &Duration) -> SystemTime {\n+        SystemTime { t: self.t.sub_duration(other) }\n     }\n+}\n \n-    impl From<libc::timespec> for SystemTime {\n-        fn from(t: libc::timespec) -> SystemTime {\n-            SystemTime { t: Timespec { t: t } }\n-        }\n+impl From<libc::timespec> for SystemTime {\n+    fn from(t: libc::timespec) -> SystemTime {\n+        SystemTime { t: Timespec { t: t } }\n     }\n+}\n \n-    impl fmt::Debug for SystemTime {\n-        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-            f.debug_struct(\"SystemTime\")\n-             .field(\"tv_sec\", &self.t.t.tv_sec)\n-             .field(\"tv_nsec\", &self.t.t.tv_nsec)\n-             .finish()\n-        }\n+impl fmt::Debug for SystemTime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.debug_struct(\"SystemTime\")\n+         .field(\"tv_sec\", &self.t.t.tv_sec)\n+         .field(\"tv_nsec\", &self.t.t.tv_nsec)\n+         .finish()\n     }\n+}\n \n-    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"redox\")))]\n-    pub type clock_t = libc::c_int;\n-    #[cfg(target_os = \"dragonfly\")]\n-    pub type clock_t = libc::c_ulong;\n-    #[cfg(target_os = \"redox\")]\n-    pub type clock_t = usize;\n+pub type clock_t = usize;\n \n-    fn now(clock: clock_t) -> Timespec {\n-        let mut t = Timespec {\n-            t: libc::timespec {\n-                tv_sec: 0,\n-                tv_nsec: 0,\n-            }\n-        };\n-        cvt(unsafe {\n-            libc::clock_gettime(clock, &mut t.t)\n-        }).unwrap();\n-        t\n-    }\n+fn now(clock: clock_t) -> Timespec {\n+    let mut t = Timespec {\n+        t: libc::timespec {\n+            tv_sec: 0,\n+            tv_nsec: 0,\n+        }\n+    };\n+    cvt(libc::clock_gettime(clock, &mut t.t)).unwrap();\n+    t\n }"}]}