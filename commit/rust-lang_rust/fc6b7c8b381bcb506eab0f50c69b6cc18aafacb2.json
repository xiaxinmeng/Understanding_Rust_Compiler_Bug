{"sha": "fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNmI3YzhiMzgxYmNiNTA2ZWFiMGY1MGM2OWI2Y2MxOGFhZmFjYjI=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T09:27:30Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T10:04:14Z"}, "message": "Reformat for new mode syntax, step 1\n\nLong lines were fixed in a very crude way, as I'll be following up\nwith another reformat in a bit.", "tree": {"sha": "c3511313bdb6c7cc8919426ce980e558396fe92c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3511313bdb6c7cc8919426ce980e558396fe92c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "html_url": "https://github.com/rust-lang/rust/commit/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64a6376da5ef6e40870af77410d3542ff7bab140", "url": "https://api.github.com/repos/rust-lang/rust/commits/64a6376da5ef6e40870af77410d3542ff7bab140", "html_url": "https://github.com/rust-lang/rust/commit/64a6376da5ef6e40870af77410d3542ff7bab140"}], "stats": {"total": 6723, "additions": 3364, "deletions": 3359}, "files": [{"sha": "704759ce4fd2cea4d4cc3f4c0e4552fee20ac216", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 42, "deletions": 45, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -31,7 +31,7 @@ tag output_type {\n     output_type_exe;\n }\n \n-fn llvm_err(sess: session::session, msg: &str) {\n+fn llvm_err(sess: session::session, msg: str) {\n     let buf = llvm::LLVMRustGetLastError();\n     if buf == std::ptr::null() {\n         sess.fatal(msg);\n@@ -41,11 +41,9 @@ fn llvm_err(sess: session::session, msg: &str) {\n fn link_intrinsics(sess: session::session, llmod: ModuleRef) {\n     let path = fs::connect(sess.get_opts().sysroot, \"lib/intrinsics.bc\");\n     let membuf =\n-        str::as_buf(\n-            path,\n-            {|buf|\n-                llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-            });\n+        str::as_buf(path, {|buf|\n+          llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+                    });\n     if membuf as uint == 0u {\n         llvm_err(sess, \"installation problem: couldn't open \" + path);\n         fail;\n@@ -75,15 +73,15 @@ mod write {\n \n     // Decides what to call an intermediate file, given the name of the output\n     // and the extension to use.\n-    fn mk_intermediate_name(output_path: &str, extension: &str) -> str {\n+    fn mk_intermediate_name(output_path: str, extension: str) -> str {\n         let dot_pos = str::index(output_path, '.' as u8);\n         let stem;\n         if dot_pos < 0 {\n             stem = output_path;\n         } else { stem = str::substr(output_path, 0u, dot_pos as uint); }\n         ret stem + \".\" + extension;\n     }\n-    fn run_passes(sess: session::session, llmod: ModuleRef, output: &str) {\n+    fn run_passes(sess: session::session, llmod: ModuleRef, output: str) {\n         let opts = sess.get_opts();\n         if opts.time_llvm_passes { llvm::LLVMRustEnableTimePasses(); }\n         link_intrinsics(sess, llmod);\n@@ -147,8 +145,8 @@ mod write {\n                                                                    False);\n \n             if threshold != 0u {\n-                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold(\n-                    MPMB, threshold);\n+                llvm::LLVMPassManagerBuilderUseInlinerWithThreshold\n+                    (MPMB, threshold);\n             }\n             llvm::LLVMPassManagerBuilderPopulateModulePassManager(MPMB,\n                                                                   pm.llpm);\n@@ -196,15 +194,14 @@ mod write {\n                     let _: () =\n                         str::as_buf(x86::get_target_triple(), {|buf_t|\n                             str::as_buf(output, {|buf_o|\n-                                llvm::LLVMRustWriteOutputFile(\n-                                    pm.llpm,\n-                                    llmod,\n-                                    buf_t,\n-                                    buf_o,\n-                                    LLVMAssemblyFile,\n-                                    CodeGenOptLevel)\n-                            })\n-                        });\n+                                llvm::LLVMRustWriteOutputFile(pm.llpm,\n+                                                              llmod,\n+                                                              buf_t,\n+                                                              buf_o,\n+                                                             LLVMAssemblyFile,\n+                                                              CodeGenOptLevel)\n+                                                    })\n+                                    });\n                 }\n \n \n@@ -221,8 +218,8 @@ mod write {\n                                                               buf_o,\n                                                               LLVMObjectFile,\n                                                               CodeGenOptLevel)\n-                            })\n-                    });\n+                                                    })\n+                                    });\n                 }\n             } else {\n                 // If we aren't saving temps then just output the file\n@@ -237,8 +234,8 @@ mod write {\n                                                           buf_o,\n                                                           FileType,\n                                                           CodeGenOptLevel)\n-                            })\n-                    });\n+                                                })\n+                                });\n             }\n             // Clean up and return\n \n@@ -311,15 +308,15 @@ mod write {\n \n type link_meta = {name: str, vers: str, extras_hash: str};\n \n-fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n+fn build_link_meta(sess: session::session, c: ast::crate, output: str,\n                    sha: sha1) -> link_meta {\n \n     type provided_metas =\n         {name: option::t<str>,\n          vers: option::t<str>,\n          cmh_items: [@ast::meta_item]};\n \n-    fn provided_link_metas(sess: &session::session, c: &ast::crate) ->\n+    fn provided_link_metas(sess: session::session, c: ast::crate) ->\n        provided_metas {\n         let name: option::t<str> = none;\n         let vers: option::t<str> = none;\n@@ -343,13 +340,13 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n     }\n \n     // This calculates CMH as defined above\n-    fn crate_meta_extras_hash(sha: sha1, _crate: &ast::crate,\n-                              metas: &provided_metas) -> str {\n-        fn len_and_str(s: &str) -> str {\n+    fn crate_meta_extras_hash(sha: sha1, _crate: ast::crate,\n+                              metas: provided_metas) -> str {\n+        fn len_and_str(s: str) -> str {\n             ret #fmt[\"%u_%s\", str::byte_len(s), s];\n         }\n \n-        fn len_and_str_lit(l: &ast::lit) -> str {\n+        fn len_and_str_lit(l: ast::lit) -> str {\n             ret len_and_str(pprust::lit_to_str(@l));\n         }\n \n@@ -373,14 +370,14 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n         ret truncated_sha1_result(sha);\n     }\n \n-    fn warn_missing(sess: &session::session, name: &str, default: &str) {\n+    fn warn_missing(sess: session::session, name: str, default: str) {\n         if !sess.get_opts().library { ret; }\n         sess.warn(#fmt[\"missing crate link meta '%s', using '%s' as default\",\n                        name, default]);\n     }\n \n-    fn crate_meta_name(sess: &session::session, _crate: &ast::crate,\n-                       output: &str, metas: &provided_metas) -> str {\n+    fn crate_meta_name(sess: session::session, _crate: ast::crate,\n+                       output: str, metas: provided_metas) -> str {\n         ret alt metas.name {\n               some(v) { v }\n               none. {\n@@ -397,8 +394,8 @@ fn build_link_meta(sess: &session::session, c: &ast::crate, output: &str,\n             };\n     }\n \n-    fn crate_meta_vers(sess: &session::session, _crate: &ast::crate,\n-                       metas: &provided_metas) -> str {\n+    fn crate_meta_vers(sess: session::session, _crate: ast::crate,\n+                       metas: provided_metas) -> str {\n         ret alt metas.vers {\n               some(v) { v }\n               none. {\n@@ -423,7 +420,7 @@ fn truncated_sha1_result(sha: sha1) -> str {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: &link_meta) ->\n+fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: link_meta) ->\n    str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n@@ -441,7 +438,7 @@ fn symbol_hash(tcx: ty::ctxt, sha: sha1, t: ty::t, link_meta: &link_meta) ->\n     ret \"_\" + hash;\n }\n \n-fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> str {\n+fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n     let hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n@@ -453,7 +450,7 @@ fn get_symbol_hash(ccx: &@crate_ctxt, t: ty::t) -> str {\n     ret hash;\n }\n \n-fn mangle(ss: &[str]) -> str {\n+fn mangle(ss: [str]) -> str {\n     // Follow C++ namespace-mangling style\n \n     let n = \"_ZN\"; // Begin name-sequence.\n@@ -464,35 +461,35 @@ fn mangle(ss: &[str]) -> str {\n     ret n;\n }\n \n-fn exported_name(path: &[str], hash: &str, _vers: &str) -> str {\n+fn exported_name(path: [str], hash: str, _vers: str) -> str {\n     // FIXME: versioning isn't working yet\n \n     ret mangle(path + [hash]); //  + \"@\" + vers;\n \n }\n \n-fn mangle_exported_name(ccx: &@crate_ctxt, path: &[str], t: ty::t) -> str {\n+fn mangle_exported_name(ccx: @crate_ctxt, path: [str], t: ty::t) -> str {\n     let hash = get_symbol_hash(ccx, t);\n     ret exported_name(path, hash, ccx.link_meta.vers);\n }\n \n-fn mangle_internal_name_by_type_only(ccx: &@crate_ctxt, t: ty::t, name: &str)\n-   -> str {\n+fn mangle_internal_name_by_type_only(ccx: @crate_ctxt, t: ty::t, name: str) ->\n+   str {\n     let s = util::ppaux::ty_to_short_str(ccx.tcx, t);\n     let hash = get_symbol_hash(ccx, t);\n     ret mangle([name, s, hash]);\n }\n \n-fn mangle_internal_name_by_path_and_seq(ccx: &@crate_ctxt, path: &[str],\n-                                        flav: &str) -> str {\n+fn mangle_internal_name_by_path_and_seq(ccx: @crate_ctxt, path: [str],\n+                                        flav: str) -> str {\n     ret mangle(path + [ccx.names.next(flav)]);\n }\n \n-fn mangle_internal_name_by_path(_ccx: &@crate_ctxt, path: &[str]) -> str {\n+fn mangle_internal_name_by_path(_ccx: @crate_ctxt, path: [str]) -> str {\n     ret mangle(path);\n }\n \n-fn mangle_internal_name_by_seq(ccx: &@crate_ctxt, flav: &str) -> str {\n+fn mangle_internal_name_by_seq(ccx: @crate_ctxt, flav: str) -> str {\n     ret ccx.names.next(flav);\n }\n //"}, {"sha": "3b1ee9c9cee19cf2a95c7dcead9ff1b78e4b1bcd", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -41,14 +41,14 @@ type upcalls =\n \n fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n                    taskptr_type: TypeRef, llmod: ModuleRef) -> @upcalls {\n-    fn decl(llmod: ModuleRef, name: &str, tys: [TypeRef], rv: TypeRef) ->\n+    fn decl(llmod: ModuleRef, name: str, tys: [TypeRef], rv: TypeRef) ->\n        ValueRef {\n         let arg_tys: [TypeRef] = [];\n         for t: TypeRef in tys { arg_tys += [t]; }\n         let fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef, name: &str,\n+    fn decl_with_taskptr(taskptr_type: TypeRef, llmod: ModuleRef, name: str,\n                          tys: [TypeRef], rv: TypeRef) -> ValueRef {\n         ret decl(llmod, name, [taskptr_type] + tys, rv);\n     }"}, {"sha": "dd7f13390f1979909499f51c982c8ffe66c33dfb", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -41,7 +41,7 @@ import back::link::output_type;\n \n tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n \n-fn default_configuration(sess: session::session, argv0: &str, input: &str) ->\n+fn default_configuration(sess: session::session, argv0: str, input: str) ->\n    ast::crate_cfg {\n     let libc =\n         alt sess.get_targ_cfg().os {\n@@ -60,7 +60,7 @@ fn default_configuration(sess: session::session, argv0: &str, input: &str) ->\n          mk(\"build_compiler\", argv0), mk(\"build_input\", input)];\n }\n \n-fn build_configuration(sess: session::session, argv0: &str, input: &str) ->\n+fn build_configuration(sess: session::session, argv0: str, input: str) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -78,24 +78,24 @@ fn build_configuration(sess: session::session, argv0: &str, input: &str) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: &[str]) -> ast::crate_cfg {\n+fn parse_cfgspecs(cfgspecs: [str]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n     let words = [];\n     for s: str in cfgspecs { words += [attr::mk_word_item(s)]; }\n     ret words;\n }\n \n-fn input_is_stdin(filename: &str) -> bool { filename == \"-\" }\n+fn input_is_stdin(filename: str) -> bool { filename == \"-\" }\n \n-fn parse_input(sess: session::session, cfg: &ast::crate_cfg, input: &str) ->\n+fn parse_input(sess: session::session, cfg: ast::crate_cfg, input: str) ->\n    @ast::crate {\n     if !input_is_stdin(input) {\n         parser::parse_crate_from_file(input, cfg, sess.get_parse_sess())\n     } else { parse_input_src(sess, cfg, input).crate }\n }\n \n-fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg, infile: &str)\n+fn parse_input_src(sess: session::session, cfg: ast::crate_cfg, infile: str)\n    -> {crate: @ast::crate, src: str} {\n     let srcbytes =\n         if infile != \"-\" {\n@@ -108,7 +108,7 @@ fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg, infile: &str)\n     ret {crate: crate, src: src};\n }\n \n-fn time<@T>(do_it: bool, what: &str, thunk: fn() -> T) -> T {\n+fn time<@T>(do_it: bool, what: str, thunk: fn() -> T) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n@@ -118,8 +118,8 @@ fn time<@T>(do_it: bool, what: &str, thunk: fn() -> T) -> T {\n     ret rv;\n }\n \n-fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &str,\n-                 output: &str) {\n+fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n+                 output: str) {\n     let time_passes = sess.get_opts().time_passes;\n     let crate =\n         time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n@@ -158,8 +158,9 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &str,\n     let mut_map =\n         time(time_passes, \"mutability checking\",\n              bind middle::mut::check_crate(ty_cx, crate));\n-    let copy_map = time(time_passes, \"alias checking\",\n-                        bind middle::alias::check_crate(ty_cx, crate));\n+    let copy_map =\n+        time(time_passes, \"alias checking\",\n+             bind middle::alias::check_crate(ty_cx, crate));\n     time(time_passes, \"kind checking\", bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n     let llmod =\n@@ -170,12 +171,12 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &str,\n          bind link::write::run_passes(sess, llmod, output));\n }\n \n-fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n-                      input: &str, ppm: pp_mode) {\n-    fn ann_paren_for_expr(node: &pprust::ann_node) {\n+fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n+                      ppm: pp_mode) {\n+    fn ann_paren_for_expr(node: pprust::ann_node) {\n         alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n     }\n-    fn ann_typed_post(tcx: &ty::ctxt, node: &pprust::ann_node) {\n+    fn ann_typed_post(tcx: ty::ctxt, node: pprust::ann_node) {\n         alt node {\n           pprust::node_expr(s, expr) {\n             pp::space(s.s);\n@@ -187,7 +188,7 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n           _ { }\n         }\n     }\n-    fn ann_identified_post(node: &pprust::ann_node) {\n+    fn ann_identified_post(node: pprust::ann_node) {\n         alt node {\n           pprust::node_item(s, item) {\n             pp::space(s.s);\n@@ -240,14 +241,14 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n                         io::string_reader(src), io::stdout(), ann);\n }\n \n-fn version(argv0: &str) {\n+fn version(argv0: str) {\n     let vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n     if str::byte_len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(#fmt[\"%s %s\\n\", argv0, vers]);\n }\n \n-fn usage(argv0: &str) {\n+fn usage(argv0: str) {\n     io::stdout().write_str(#fmt[\"usage: %s [options] <input>\\n\", argv0] +\n                                \"\n options:\n@@ -285,7 +286,7 @@ options:\n \");\n }\n \n-fn get_os(triple: &str) -> session::os {\n+fn get_os(triple: str) -> session::os {\n     ret if str::find(triple, \"win32\") >= 0 ||\n                str::find(triple, \"mingw32\") >= 0 {\n             session::os_win32\n@@ -296,7 +297,7 @@ fn get_os(triple: &str) -> session::os {\n         } else { log_err \"Unknown operating system!\"; fail };\n }\n \n-fn get_arch(triple: &str) -> session::arch {\n+fn get_arch(triple: str) -> session::arch {\n     ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n                str::find(triple, \"i586\") >= 0 ||\n                str::find(triple, \"i686\") >= 0 ||\n@@ -310,7 +311,7 @@ fn get_arch(triple: &str) -> session::arch {\n         } else { log_err \"Unknown architecture! \" + triple; fail };\n }\n \n-fn get_default_sysroot(binary: &str) -> str {\n+fn get_default_sysroot(binary: str) -> str {\n     let dirname = fs::dirname(binary);\n     if str::eq(dirname, binary) { ret \".\"; }\n     ret dirname;\n@@ -327,8 +328,8 @@ fn build_target_config() -> @session::config {\n     ret target_cfg;\n }\n \n-fn build_session_options(binary: &str, match: &getopts::match,\n-                         binary_dir: &str) -> @session::options {\n+fn build_session_options(binary: str, match: getopts::match, binary_dir: str)\n+   -> @session::options {\n     let library = opt_present(match, \"lib\");\n     let static = opt_present(match, \"static\");\n \n@@ -415,7 +416,7 @@ fn build_session(sopts: @session::options) -> session::session {\n                          none, 0u);\n }\n \n-fn parse_pretty(sess: session::session, name: &str) -> pp_mode {\n+fn parse_pretty(sess: session::session, name: str) -> pp_mode {\n     if str::eq(name, \"normal\") {\n         ret ppm_normal;\n     } else if str::eq(name, \"expanded\") {\n@@ -513,6 +514,7 @@ fn main(args: [str]) {\n               link::output_type_assembly. { \"s\" }\n \n \n+\n               // Object and exe output both use the '.o' extension here\n               link::output_type_object. | link::output_type_exe. {\n                 \"o\"\n@@ -554,17 +556,17 @@ fn main(args: [str]) {\n     } else { lib_cmd = \"-shared\"; }\n \n     // Converts a library file name into a gcc -l argument\n-    fn unlib(config: @session::config, filename: &str) -> str {\n+    fn unlib(config: @session::config, filename: str) -> str {\n         let rmlib =\n-            bind fn (config: @session::config, filename: &str) -> str {\n+            bind fn (config: @session::config, filename: str) -> str {\n                      if config.os == session::os_macos ||\n                             config.os == session::os_linux &&\n                                 str::find(filename, \"lib\") == 0 {\n                          ret str::slice(filename, 3u,\n                                         str::byte_len(filename));\n                      } else { ret filename; }\n                  }(config, _);\n-        fn rmext(filename: &str) -> str {\n+        fn rmext(filename: str) -> str {\n             let parts = str::split(filename, '.' as u8);\n             vec::pop(parts);\n             ret str::connect(parts, \".\");"}, {"sha": "5a2b26739aae45aad96fb2b168214bfc29f55f11", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -58,46 +58,46 @@ obj session(targ_cfg: @config,\n     fn get_targ_cfg() -> @config { ret targ_cfg; }\n     fn get_opts() -> @options { ret opts; }\n     fn get_cstore() -> metadata::cstore::cstore { cstore }\n-    fn span_fatal(sp: span, msg: &str) -> ! {\n+    fn span_fatal(sp: span, msg: str) -> ! {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_error(some(sp), msg, parse_sess.cm);\n         fail;\n     }\n-    fn fatal(msg: &str) -> ! {\n+    fn fatal(msg: str) -> ! {\n         codemap::emit_error(none, msg, parse_sess.cm);\n         fail;\n     }\n-    fn span_err(sp: span, msg: &str) {\n+    fn span_err(sp: span, msg: str) {\n         codemap::emit_error(some(sp), msg, parse_sess.cm);\n         err_count += 1u;\n     }\n-    fn err(msg: &str) {\n+    fn err(msg: str) {\n         codemap::emit_error(none, msg, parse_sess.cm);\n         err_count += 1u;\n     }\n     fn abort_if_errors() {\n         if err_count > 0u { self.fatal(\"aborting due to previous errors\"); }\n     }\n-    fn span_warn(sp: span, msg: &str) {\n+    fn span_warn(sp: span, msg: str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_warning(some(sp), msg, parse_sess.cm);\n     }\n-    fn warn(msg: &str) { codemap::emit_warning(none, msg, parse_sess.cm); }\n-    fn span_note(sp: span, msg: &str) {\n+    fn warn(msg: str) { codemap::emit_warning(none, msg, parse_sess.cm); }\n+    fn span_note(sp: span, msg: str) {\n         // FIXME: Use constants, but rustboot doesn't know how to export them.\n         codemap::emit_note(some(sp), msg, parse_sess.cm);\n     }\n-    fn note(msg: &str) { codemap::emit_note(none, msg, parse_sess.cm); }\n-    fn span_bug(sp: span, msg: &str) -> ! {\n+    fn note(msg: str) { codemap::emit_note(none, msg, parse_sess.cm); }\n+    fn span_bug(sp: span, msg: str) -> ! {\n         self.span_fatal(sp, #fmt[\"internal compiler error %s\", msg]);\n     }\n-    fn bug(msg: &str) -> ! {\n+    fn bug(msg: str) -> ! {\n         self.fatal(#fmt[\"internal compiler error %s\", msg]);\n     }\n-    fn span_unimpl(sp: span, msg: &str) -> ! {\n+    fn span_unimpl(sp: span, msg: str) -> ! {\n         self.span_bug(sp, \"unimplemented \" + msg);\n     }\n-    fn unimpl(msg: &str) -> ! { self.bug(\"unimplemented \" + msg); }\n+    fn unimpl(msg: str) -> ! { self.bug(\"unimplemented \" + msg); }\n     fn get_codemap() -> codemap::codemap { ret parse_sess.cm; }\n     fn lookup_pos(pos: uint) -> codemap::loc {\n         ret codemap::lookup_char_pos(parse_sess.cm, pos);"}, {"sha": "a13fc4aad35e3c9be6d338f52583b08ef13600af", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -30,7 +30,7 @@ export mk_attr;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n-fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n+fn find_linkage_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     let metas: [@ast::meta_item] = [];\n     for attr: ast::attribute in find_attrs_by_name(attrs, \"link\") {\n         alt attr.node.value.node {\n@@ -42,10 +42,10 @@ fn find_linkage_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n }\n \n // Search a list of attributes and return only those with a specific name\n-fn find_attrs_by_name(attrs: &[ast::attribute], name: ast::ident) ->\n+fn find_attrs_by_name(attrs: [ast::attribute], name: ast::ident) ->\n    [ast::attribute] {\n     let filter =\n-        bind fn (a: &ast::attribute, name: ast::ident) ->\n+        bind fn (a: ast::attribute, name: ast::ident) ->\n                 option::t<ast::attribute> {\n                  if get_attr_name(a) == name {\n                      option::some(a)\n@@ -54,14 +54,14 @@ fn find_attrs_by_name(attrs: &[ast::attribute], name: ast::ident) ->\n     ret vec::filter_map(filter, attrs);\n }\n \n-fn get_attr_name(attr: &ast::attribute) -> ast::ident {\n+fn get_attr_name(attr: ast::attribute) -> ast::ident {\n     get_meta_item_name(@attr.node.value)\n }\n \n-fn find_meta_items_by_name(metas: &[@ast::meta_item], name: ast::ident) ->\n+fn find_meta_items_by_name(metas: [@ast::meta_item], name: ast::ident) ->\n    [@ast::meta_item] {\n     let filter =\n-        bind fn (m: &@ast::meta_item, name: ast::ident) ->\n+        bind fn (m: @ast::meta_item, name: ast::ident) ->\n                 option::t<@ast::meta_item> {\n                  if get_meta_item_name(m) == name {\n                      option::some(m)\n@@ -70,7 +70,7 @@ fn find_meta_items_by_name(metas: &[@ast::meta_item], name: ast::ident) ->\n     ret vec::filter_map(filter, metas);\n }\n \n-fn get_meta_item_name(meta: &@ast::meta_item) -> ast::ident {\n+fn get_meta_item_name(meta: @ast::meta_item) -> ast::ident {\n     alt meta.node {\n       ast::meta_word(n) { n }\n       ast::meta_name_value(n, _) { n }\n@@ -80,7 +80,7 @@ fn get_meta_item_name(meta: &@ast::meta_item) -> ast::ident {\n \n // Gets the string value if the meta_item is a meta_name_value variant\n // containing a string, otherwise none\n-fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t<str> {\n+fn get_meta_item_value_str(meta: @ast::meta_item) -> option::t<str> {\n     alt meta.node {\n       ast::meta_name_value(_, v) {\n         alt v.node { ast::lit_str(s) { option::some(s) } _ { option::none } }\n@@ -89,10 +89,10 @@ fn get_meta_item_value_str(meta: &@ast::meta_item) -> option::t<str> {\n     }\n }\n \n-fn attr_meta(attr: &ast::attribute) -> @ast::meta_item { @attr.node.value }\n+fn attr_meta(attr: ast::attribute) -> @ast::meta_item { @attr.node.value }\n \n // Get the meta_items from inside a vector of attributes\n-fn attr_metas(attrs: &[ast::attribute]) -> [@ast::meta_item] {\n+fn attr_metas(attrs: [ast::attribute]) -> [@ast::meta_item] {\n     let mitems = [];\n     for a: ast::attribute in attrs { mitems += [attr_meta(a)]; }\n     ret mitems;\n@@ -119,7 +119,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n         }\n }\n \n-fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n+fn contains(haystack: [@ast::meta_item], needle: @ast::meta_item) -> bool {\n     log #fmt[\"looking for %s\",\n              syntax::print::pprust::meta_item_to_str(*needle)];\n     for item: @ast::meta_item in haystack {\n@@ -131,15 +131,15 @@ fn contains(haystack: &[@ast::meta_item], needle: @ast::meta_item) -> bool {\n     ret false;\n }\n \n-fn contains_name(metas: &[@ast::meta_item], name: ast::ident) -> bool {\n+fn contains_name(metas: [@ast::meta_item], name: ast::ident) -> bool {\n     let matches = find_meta_items_by_name(metas, name);\n     ret vec::len(matches) > 0u;\n }\n \n // FIXME: This needs to sort by meta_item variant in addition to the item name\n-fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n-    fn lteq(ma: &@ast::meta_item, mb: &@ast::meta_item) -> bool {\n-        fn key(m: &@ast::meta_item) -> ast::ident {\n+fn sort_meta_items(items: [@ast::meta_item]) -> [@ast::meta_item] {\n+    fn lteq(ma: @ast::meta_item, mb: @ast::meta_item) -> bool {\n+        fn key(m: @ast::meta_item) -> ast::ident {\n             alt m.node {\n               ast::meta_word(name) { name }\n               ast::meta_name_value(name, _) { name }\n@@ -160,11 +160,11 @@ fn sort_meta_items(items: &[@ast::meta_item]) -> [@ast::meta_item] {\n     ret v2;\n }\n \n-fn remove_meta_items_by_name(items: &[@ast::meta_item], name: &str) ->\n+fn remove_meta_items_by_name(items: [@ast::meta_item], name: str) ->\n    [@ast::meta_item] {\n \n     let filter =\n-        bind fn (item: &@ast::meta_item, name: &str) ->\n+        bind fn (item: @ast::meta_item, name: str) ->\n                 option::t<@ast::meta_item> {\n                  if get_meta_item_name(item) != name {\n                      option::some(item)\n@@ -174,7 +174,7 @@ fn remove_meta_items_by_name(items: &[@ast::meta_item], name: &str) ->\n     ret vec::filter_map(filter, items);\n }\n \n-fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n+fn require_unique_names(sess: session::session, metas: [@ast::meta_item]) {\n     let map = map::new_str_hash();\n     for meta: @ast::meta_item in metas {\n         let name = get_meta_item_name(meta);\n@@ -186,11 +186,11 @@ fn require_unique_names(sess: &session::session, metas: &[@ast::meta_item]) {\n     }\n }\n \n-fn span<@T>(item: &T) -> ast::spanned<T> {\n+fn span<@T>(item: T) -> ast::spanned<T> {\n     ret {node: item, span: ast_util::dummy_sp()};\n }\n \n-fn mk_name_value_item_str(name: ast::ident, value: &str) -> @ast::meta_item {\n+fn mk_name_value_item_str(name: ast::ident, value: str) -> @ast::meta_item {\n     let value_lit = span(ast::lit_str(value));\n     ret mk_name_value_item(name, value_lit);\n }\n@@ -199,7 +199,7 @@ fn mk_name_value_item(name: ast::ident, value: ast::lit) -> @ast::meta_item {\n     ret @span(ast::meta_name_value(name, value));\n }\n \n-fn mk_list_item(name: ast::ident, items: &[@ast::meta_item]) ->\n+fn mk_list_item(name: ast::ident, items: [@ast::meta_item]) ->\n    @ast::meta_item {\n     ret @span(ast::meta_list(name, items));\n }"}, {"sha": "843a936cc383ba48085507c41b3275455f9325b0", "filename": "src/comp/front/config.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fconfig.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -24,27 +24,27 @@ fn strip_unconfigured_items(crate: @ast::crate) -> @ast::crate {\n     ret res;\n }\n \n-fn filter_item(cfg: &ast::crate_cfg, item: &@ast::item) ->\n+fn filter_item(cfg: ast::crate_cfg, item: @ast::item) ->\n    option::t<@ast::item> {\n     if item_in_cfg(cfg, item) { option::some(item) } else { option::none }\n }\n \n-fn fold_mod(cfg: &ast::crate_cfg, m: &ast::_mod, fld: fold::ast_fold) ->\n+fn fold_mod(cfg: ast::crate_cfg, m: ast::_mod, fld: fold::ast_fold) ->\n    ast::_mod {\n     let filter = bind filter_item(cfg, _);\n     let filtered_items = vec::filter_map(filter, m.items);\n     ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n          items: vec::map(fld.fold_item, filtered_items)};\n }\n \n-fn filter_native_item(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n+fn filter_native_item(cfg: ast::crate_cfg, item: @ast::native_item) ->\n    option::t<@ast::native_item> {\n     if native_item_in_cfg(cfg, item) {\n         option::some(item)\n     } else { option::none }\n }\n \n-fn fold_native_mod(cfg: &ast::crate_cfg, nm: &ast::native_mod,\n+fn fold_native_mod(cfg: ast::crate_cfg, nm: ast::native_mod,\n                    fld: fold::ast_fold) -> ast::native_mod {\n     let filter = bind filter_native_item(cfg, _);\n     let filtered_items = vec::filter_map(filter, nm.items);\n@@ -54,7 +54,7 @@ fn fold_native_mod(cfg: &ast::crate_cfg, nm: &ast::native_mod,\n          items: filtered_items};\n }\n \n-fn filter_stmt(cfg: &ast::crate_cfg, stmt: &@ast::stmt) ->\n+fn filter_stmt(cfg: ast::crate_cfg, stmt: @ast::stmt) ->\n    option::t<@ast::stmt> {\n     alt stmt.node {\n       ast::stmt_decl(decl, _) {\n@@ -71,7 +71,7 @@ fn filter_stmt(cfg: &ast::crate_cfg, stmt: &@ast::stmt) ->\n     }\n }\n \n-fn fold_block(cfg: &ast::crate_cfg, b: &ast::blk_, fld: fold::ast_fold) ->\n+fn fold_block(cfg: ast::crate_cfg, b: ast::blk_, fld: fold::ast_fold) ->\n    ast::blk_ {\n     let filter = bind filter_stmt(cfg, _);\n     let filtered_stmts = vec::filter_map(filter, b.stmts);\n@@ -81,18 +81,17 @@ fn fold_block(cfg: &ast::crate_cfg, b: &ast::blk_, fld: fold::ast_fold) ->\n          rules: b.rules};\n }\n \n-fn item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::item) -> bool {\n+fn item_in_cfg(cfg: ast::crate_cfg, item: @ast::item) -> bool {\n     ret in_cfg(cfg, item.attrs);\n }\n \n-fn native_item_in_cfg(cfg: &ast::crate_cfg, item: &@ast::native_item) ->\n-   bool {\n+fn native_item_in_cfg(cfg: ast::crate_cfg, item: @ast::native_item) -> bool {\n     ret in_cfg(cfg, item.attrs);\n }\n \n // Determine if an item should be translated in the current crate\n // configuration based on the item's attributes\n-fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n+fn in_cfg(cfg: ast::crate_cfg, attrs: [ast::attribute]) -> bool {\n \n     // The \"cfg\" attributes on the item\n     let item_cfg_attrs = attr::find_attrs_by_name(attrs, \"cfg\");\n@@ -104,9 +103,8 @@ fn in_cfg(cfg: &ast::crate_cfg, attrs: &[ast::attribute]) -> bool {\n     // which the item is valid\n     let item_cfg_metas =\n         {\n-            fn extract_metas(inner_items: &[@ast::meta_item],\n-                             cfg_item: &@ast::meta_item) ->\n-               [@ast::meta_item] {\n+            fn extract_metas(inner_items: [@ast::meta_item],\n+                             cfg_item: @ast::meta_item) -> [@ast::meta_item] {\n                 alt cfg_item.node {\n                   ast::meta_list(name, items) {\n                     assert (name == \"cfg\");"}, {"sha": "e0d9fa45ce104495dc634b6dae5602bd04a7b191", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -55,14 +55,13 @@ fn modify_for_testing(crate: @ast::crate) -> @ast::crate {\n     ret res;\n }\n \n-fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) ->\n-   ast::_mod {\n+fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n \n     // Remove any defined main function from the AST so it doesn't clash with\n     // the one we're going to add.  FIXME: This is sloppy. Instead we should\n     // have some mechanism to indicate to the translation pass which function\n     // we want to be main.\n-    fn nomain(item: &@ast::item) -> option::t<@ast::item> {\n+    fn nomain(item: @ast::item) -> option::t<@ast::item> {\n         alt item.node {\n           ast::item_fn(f, _) {\n             if item.ident == \"main\" {\n@@ -78,7 +77,7 @@ fn fold_mod(_cx: &test_ctxt, m: &ast::_mod, fld: fold::ast_fold) ->\n     ret fold::noop_fold_mod(mod_nomain, fld);\n }\n \n-fn fold_crate(cx: &test_ctxt, c: &ast::crate_, fld: fold::ast_fold) ->\n+fn fold_crate(cx: test_ctxt, c: ast::crate_, fld: fold::ast_fold) ->\n    ast::crate_ {\n     let folded = fold::noop_fold_crate(c, fld);\n \n@@ -88,7 +87,7 @@ fn fold_crate(cx: &test_ctxt, c: &ast::crate_, fld: fold::ast_fold) ->\n }\n \n \n-fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n+fn fold_item(cx: test_ctxt, i: @ast::item, fld: fold::ast_fold) ->\n    @ast::item {\n \n     cx.path += [i.ident];\n@@ -106,11 +105,11 @@ fn fold_item(cx: &test_ctxt, i: &@ast::item, fld: fold::ast_fold) ->\n     ret res;\n }\n \n-fn is_test_fn(i: &@ast::item) -> bool {\n+fn is_test_fn(i: @ast::item) -> bool {\n     let has_test_attr =\n         vec::len(attr::find_attrs_by_name(i.attrs, \"test\")) > 0u;\n \n-    fn has_test_signature(i: &@ast::item) -> bool {\n+    fn has_test_signature(i: @ast::item) -> bool {\n         alt i.node {\n           ast::item_fn(f, tps) {\n             let input_cnt = vec::len(f.decl.inputs);\n@@ -125,11 +124,11 @@ fn is_test_fn(i: &@ast::item) -> bool {\n     ret has_test_attr && has_test_signature(i);\n }\n \n-fn is_ignored(i: &@ast::item) -> bool {\n+fn is_ignored(i: @ast::item) -> bool {\n     attr::contains_name(attr::attr_metas(i.attrs), \"ignore\")\n }\n \n-fn add_test_module(cx: &test_ctxt, m: &ast::_mod) -> ast::_mod {\n+fn add_test_module(cx: test_ctxt, m: ast::_mod) -> ast::_mod {\n     let testmod = mk_test_module(cx);\n     ret {items: m.items + [testmod] with m};\n }\n@@ -151,7 +150,7 @@ mod __test {\n \n */\n \n-fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n+fn mk_test_module(cx: test_ctxt) -> @ast::item {\n     // A function that generates a vector of test descriptors to feed to the\n     // test runner\n     let testsfn = mk_tests(cx);\n@@ -172,9 +171,9 @@ fn mk_test_module(cx: &test_ctxt) -> @ast::item {\n     ret @item;\n }\n \n-fn nospan<@T>(t: &T) -> ast::spanned<T> { ret {node: t, span: dummy_sp()}; }\n+fn nospan<@T>(t: T) -> ast::spanned<T> { ret {node: t, span: dummy_sp()}; }\n \n-fn mk_tests(cx: &test_ctxt) -> @ast::item {\n+fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n     let decl: ast::fn_decl =\n@@ -215,7 +214,7 @@ fn empty_fn_ty() -> ast::ty {\n }\n \n // The ast::ty of [std::test::test_desc]\n-fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n+fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::ty {\n     let test_desc_ty_path: ast::path =\n         nospan({global: false,\n                 idents: [\"std\", \"test\", \"test_desc\"],\n@@ -229,7 +228,7 @@ fn mk_test_desc_vec_ty(cx: &test_ctxt) -> @ast::ty {\n     ret @nospan(ast::ty_vec(vec_mt));\n }\n \n-fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n+fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     log #fmt[\"building test vector from %u tests\", vec::len(cx.testfns)];\n     let descs = [];\n     for test: test in cx.testfns {\n@@ -242,7 +241,7 @@ fn mk_test_desc_vec(cx: &test_ctxt) -> @ast::expr {\n           span: dummy_sp()};\n }\n \n-fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n+fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let path = test.path;\n \n     log #fmt[\"encoding %s\", ast_util::path_name_i(path)];\n@@ -284,13 +283,15 @@ fn mk_test_desc_rec(cx: &test_ctxt, test: test) -> @ast::expr {\n     ret @desc_rec;\n }\n \n-fn mk_main(cx: &test_ctxt) -> @ast::item {\n+fn mk_main(cx: test_ctxt) -> @ast::item {\n \n     let args_mt: ast::mt = {ty: @nospan(ast::ty_str), mut: ast::imm};\n     let args_ty: ast::ty = nospan(ast::ty_vec(args_mt));\n \n     let args_arg: ast::arg =\n-        {mode: ast::by_ref, ty: @args_ty, ident: \"args\",\n+        {mode: ast::by_ref,\n+         ty: @args_ty,\n+         ident: \"args\",\n          id: cx.next_node_id()};\n \n     let ret_ty = nospan(ast::ty_nil);\n@@ -322,7 +323,7 @@ fn mk_main(cx: &test_ctxt) -> @ast::item {\n     ret @item;\n }\n \n-fn mk_test_main_call(cx: &test_ctxt) -> @ast::expr {\n+fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n \n     // Get the args passed to main so we can pass the to test_main\n     let args_path: ast::path ="}, {"sha": "8abdb8560f7ccd063ae92c129c3c88eee8762395", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -809,15 +809,19 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n                                                    Value: Bool);\n     fn LLVMPassManagerBuilderSetDisableUnrollLoops(PMB: PassManagerBuilderRef,\n                                                    Value: Bool);\n-    fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls(\n-        PMB: PassManagerBuilderRef, Value: Bool);\n-    fn LLVMPassManagerBuilderUseInlinerWithThreshold(\n-        PMB: PassManagerBuilderRef, threshold: uint);\n-    fn LLVMPassManagerBuilderPopulateModulePassManager(\n-        PMB: PassManagerBuilderRef, PM: PassManagerRef);\n-\n-    fn LLVMPassManagerBuilderPopulateFunctionPassManager(\n-        PMB: PassManagerBuilderRef, PM: PassManagerRef);\n+    fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n+        (PMB: PassManagerBuilderRef,\n+                                                        Value: Bool);\n+    fn LLVMPassManagerBuilderUseInlinerWithThreshold\n+        (PMB: PassManagerBuilderRef,\n+                                                     threshold: uint);\n+    fn LLVMPassManagerBuilderPopulateModulePassManager(PMB:\n+                                                        PassManagerBuilderRef,\n+                                                       PM: PassManagerRef);\n+\n+    fn LLVMPassManagerBuilderPopulateFunctionPassManager(PMB:\n+                                                        PassManagerBuilderRef,\n+                                                         PM: PassManagerRef);\n \n     /** Destroys a memory buffer. */\n     fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n@@ -898,7 +902,7 @@ native \"cdecl\" mod llvm = \"rustllvm\" {\n obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n                named_types: std::map::hashmap<str, TypeRef>) {\n \n-    fn associate(s: &str, t: TypeRef) {\n+    fn associate(s: str, t: TypeRef) {\n         assert (!named_types.contains_key(s));\n         assert (!type_names.contains_key(t));\n         type_names.insert(t, s);\n@@ -909,17 +913,17 @@ obj type_names(type_names: std::map::hashmap<TypeRef, str>,\n \n     fn get_name(t: TypeRef) -> str { ret type_names.get(t); }\n \n-    fn name_has_type(s: &str) -> bool { ret named_types.contains_key(s); }\n+    fn name_has_type(s: str) -> bool { ret named_types.contains_key(s); }\n \n-    fn get_type(s: &str) -> TypeRef { ret named_types.get(s); }\n+    fn get_type(s: str) -> TypeRef { ret named_types.get(s); }\n }\n \n fn mk_type_names() -> type_names {\n     let nt = std::map::new_str_hash::<TypeRef>();\n \n-    fn hash(t: &TypeRef) -> uint { ret t as uint; }\n+    fn hash(t: TypeRef) -> uint { ret t as uint; }\n \n-    fn eq(a: &TypeRef, b: &TypeRef) -> bool { ret a as uint == b as uint; }\n+    fn eq(a: TypeRef, b: TypeRef) -> bool { ret a as uint == b as uint; }\n \n     let hasher: std::map::hashfn<TypeRef> = hash;\n     let eqer: std::map::eqfn<TypeRef> = eq;\n@@ -932,7 +936,7 @@ fn type_to_str(names: type_names, ty: TypeRef) -> str {\n     ret type_to_str_inner(names, [], ty);\n }\n \n-fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n+fn type_to_str_inner(names: type_names, outer0: [TypeRef], ty: TypeRef) ->\n    str {\n \n     if names.type_has_name(ty) { ret names.get_name(ty); }\n@@ -941,7 +945,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n     let kind: int = llvm::LLVMGetTypeKind(ty);\n \n-    fn tys_str(names: type_names, outer: &[TypeRef], tys: &[TypeRef]) -> str {\n+    fn tys_str(names: type_names, outer: [TypeRef], tys: [TypeRef]) -> str {\n         let s: str = \"\";\n         let first: bool = true;\n         for t: TypeRef in tys {\n@@ -957,6 +961,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       // FIXME: more enum-as-int constants determined from Core::h;\n       // horrible, horrible. Complete as needed.\n \n@@ -973,13 +978,15 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       7 {\n         ret \"i\" + std::int::str(llvm::LLVMGetIntTypeWidth(ty) as int);\n       }\n \n \n \n \n+\n       8 {\n         let s = \"fn(\";\n         let out_ty: TypeRef = llvm::LLVMGetReturnType(ty);\n@@ -995,6 +1002,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       9 {\n         let s: str = \"{\";\n         let n_elts: uint = llvm::LLVMCountStructElementTypes(ty);\n@@ -1008,6 +1016,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       10 {\n         let el_ty = llvm::LLVMGetElementType(ty);\n         ret \"[\" + type_to_str_inner(names, outer, el_ty) + \"]\";\n@@ -1016,6 +1025,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       11 {\n         let i: uint = 0u;\n         for tout: TypeRef in outer0 {\n@@ -1032,6 +1042,7 @@ fn type_to_str_inner(names: type_names, outer0: &[TypeRef], ty: TypeRef) ->\n \n \n \n+\n       12 {\n         ret \"Opaque\";\n       }\n@@ -1066,7 +1077,7 @@ resource target_data_res(TD: TargetDataRef) {\n \n type target_data = {lltd: TargetDataRef, dtor: @target_data_res};\n \n-fn mk_target_data(string_rep: &str) -> target_data {\n+fn mk_target_data(string_rep: str) -> target_data {\n     let lltd =\n         str::as_buf(string_rep, {|buf| llvm::LLVMCreateTargetData(buf) });\n     ret {lltd: lltd, dtor: @target_data_res(lltd)};"}, {"sha": "a22dfa62d2bb4599cff406b4cc1afbc5389fb159", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -65,9 +65,9 @@ const tag_crate_dep: uint = 0x26u;\n const tag_items_data_item_inlineness: uint = 0x27u;\n \n // djb's cdb hashes.\n-fn hash_node_id(node_id: &int) -> uint { ret 177573u ^ (node_id as uint); }\n+fn hash_node_id(node_id: int) -> uint { ret 177573u ^ (node_id as uint); }\n \n-fn hash_path(s: &str) -> uint {\n+fn hash_path(s: str) -> uint {\n     let h = 5381u;\n     for ch: u8 in str::bytes(s) { h = (h << 5u) + h ^ (ch as uint); }\n     ret h;"}, {"sha": "d9438c38e21b81985aa4e8af1de1a8712506dbb2", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -30,7 +30,7 @@ export list_file_metadata;\n \n // Traverses an AST, reading all the information about use'd crates and native\n // libraries necessary for later resolving, typechecking, linking, etc.\n-fn read_crates(sess: session::session, crate: &ast::crate) {\n+fn read_crates(sess: session::session, crate: ast::crate) {\n     let e =\n         @{sess: sess,\n           crate_cache: @std::map::new_str_hash::<int>(),\n@@ -50,7 +50,7 @@ type env =\n       library_search_paths: [str],\n       mutable next_crate_num: ast::crate_num};\n \n-fn visit_view_item(e: env, i: &@ast::view_item) {\n+fn visit_view_item(e: env, i: @ast::view_item) {\n     alt i.node {\n       ast::view_item_use(ident, meta_items, id) {\n         let cnum = resolve_crate(e, ident, meta_items, i.span);\n@@ -60,7 +60,7 @@ fn visit_view_item(e: env, i: &@ast::view_item) {\n     }\n }\n \n-fn visit_item(e: env, i: &@ast::item) {\n+fn visit_item(e: env, i: @ast::item) {\n     alt i.node {\n       ast::item_native_mod(m) {\n         if m.abi != ast::native_abi_rust && m.abi != ast::native_abi_cdecl {\n@@ -81,7 +81,7 @@ fn visit_item(e: env, i: &@ast::item) {\n }\n \n // A diagnostic function for dumping crate metadata to an output stream\n-fn list_file_metadata(path: &str, out: io::writer) {\n+fn list_file_metadata(path: str, out: io::writer) {\n     alt get_metadata_section(path) {\n       option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n       option::none. {\n@@ -90,7 +90,7 @@ fn list_file_metadata(path: &str, out: io::writer) {\n     }\n }\n \n-fn metadata_matches(crate_data: &@[u8], metas: &[@ast::meta_item]) -> bool {\n+fn metadata_matches(crate_data: @[u8], metas: [@ast::meta_item]) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n \n@@ -116,8 +116,8 @@ fn default_native_lib_naming(sess: session::session, static: bool) ->\n     }\n }\n \n-fn find_library_crate(sess: &session::session, ident: &ast::ident,\n-                      metas: &[@ast::meta_item], library_search_paths: &[str])\n+fn find_library_crate(sess: session::session, ident: ast::ident,\n+                      metas: [@ast::meta_item], library_search_paths: [str])\n    -> option::t<{ident: str, data: @[u8]}> {\n \n     attr::require_unique_names(sess, metas);\n@@ -146,9 +146,9 @@ fn find_library_crate(sess: &session::session, ident: &ast::ident,\n     ret find_library_crate_aux(nn2, crate_name, metas, library_search_paths);\n }\n \n-fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: &str,\n-                          metas: &[@ast::meta_item],\n-                          library_search_paths: &[str]) ->\n+fn find_library_crate_aux(nn: {prefix: str, suffix: str}, crate_name: str,\n+                          metas: [@ast::meta_item],\n+                          library_search_paths: [str]) ->\n    option::t<{ident: str, data: @[u8]}> {\n     let prefix: str = nn.prefix + crate_name;\n     let suffix: str = nn.suffix;\n@@ -184,11 +184,11 @@ fn find_library_crate_aux(nn: &{prefix: str, suffix: str}, crate_name: &str,\n     ret none;\n }\n \n-fn get_metadata_section(filename: &str) -> option::t<@[u8]> {\n+fn get_metadata_section(filename: str) -> option::t<@[u8]> {\n     let mb =\n         str::as_buf(filename, {|buf|\n-            llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n-        });\n+                llvm::LLVMRustCreateMemoryBufferWithContentsOfFile(buf)\n+                    });\n     if mb as int == 0 { ret option::none::<@[u8]>; }\n     let of = mk_object_file(mb);\n     let si = mk_section_iter(of.llof);\n@@ -206,8 +206,8 @@ fn get_metadata_section(filename: &str) -> option::t<@[u8]> {\n     ret option::none::<@[u8]>;\n }\n \n-fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n-                      metas: &[@ast::meta_item], library_search_paths: &[str])\n+fn load_library_crate(sess: session::session, span: span, ident: ast::ident,\n+                      metas: [@ast::meta_item], library_search_paths: [str])\n    -> {ident: str, data: @[u8]} {\n \n \n@@ -219,7 +219,7 @@ fn load_library_crate(sess: &session::session, span: span, ident: &ast::ident,\n     }\n }\n \n-fn resolve_crate(e: env, ident: &ast::ident, metas: [@ast::meta_item],\n+fn resolve_crate(e: env, ident: ast::ident, metas: [@ast::meta_item],\n                  span: span) -> ast::crate_num {\n     if !e.crate_cache.contains_key(ident) {\n         let cinfo =\n@@ -247,7 +247,7 @@ fn resolve_crate(e: env, ident: &ast::ident, metas: [@ast::meta_item],\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: env, cdata: &@[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: env, cdata: @[u8]) -> cstore::cnum_map {\n     log \"resolving deps of external crate\";\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "f05d98127b9e3b6ac8f82568f8a9b6dcf3c223e2", "filename": "src/comp/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcsearch.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -11,18 +11,18 @@ export lookup_defs;\n export get_tag_variants;\n export get_type;\n \n-fn get_symbol(cstore: &cstore::cstore, def: ast::def_id) -> str {\n+fn get_symbol(cstore: cstore::cstore, def: ast::def_id) -> str {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     ret decoder::get_symbol(cdata, def.node);\n }\n \n-fn get_type_param_count(cstore: &cstore::cstore, def: &ast::def_id) -> uint {\n+fn get_type_param_count(cstore: cstore::cstore, def: ast::def_id) -> uint {\n     let cdata = cstore::get_crate_data(cstore, def.crate).data;\n     ret decoder::get_type_param_count(cdata, def.node);\n }\n \n-fn lookup_defs(cstore: &cstore::cstore, cnum: ast::crate_num,\n-               path: &[ast::ident]) -> [ast::def] {\n+fn lookup_defs(cstore: cstore::cstore, cnum: ast::crate_num,\n+               path: [ast::ident]) -> [ast::def] {\n     let cdata = cstore::get_crate_data(cstore, cnum).data;\n     ret decoder::lookup_defs(cdata, cnum, path);\n }\n@@ -48,8 +48,8 @@ fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_kinds_and_ty {\n // external crates - if those types further refer to types in other crates\n // then we must translate the crate number from that encoded in the external\n // crate to the correct local crate number.\n-fn translate_def_id(sess: &session::session, searched_crate: ast::crate_num,\n-                    def_id: &ast::def_id) -> ast::def_id {\n+fn translate_def_id(sess: session::session, searched_crate: ast::crate_num,\n+                    def_id: ast::def_id) -> ast::def_id {\n \n     let ext_cnum = def_id.crate;\n     let node_id = def_id.node;"}, {"sha": "05d45fc6e3209859463efccfb1b554953415fc6d", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -49,7 +49,7 @@ type cstore_private =\n type use_crate_map = map::hashmap<ast::node_id, ast::crate_num>;\n \n // Internal method to retrieve the data from the cstore\n-fn p(cstore: &cstore) -> cstore_private { alt cstore { private(p) { p } } }\n+fn p(cstore: cstore) -> cstore_private { alt cstore { private(p) { p } } }\n \n fn mk_cstore() -> cstore {\n     let meta_cache = map::new_int_hash::<crate_metadata>();\n@@ -61,38 +61,38 @@ fn mk_cstore() -> cstore {\n                   mutable used_link_args: []});\n }\n \n-fn get_crate_data(cstore: &cstore, cnum: ast::crate_num) -> crate_metadata {\n+fn get_crate_data(cstore: cstore, cnum: ast::crate_num) -> crate_metadata {\n     ret p(cstore).metas.get(cnum);\n }\n \n-fn set_crate_data(cstore: &cstore, cnum: ast::crate_num,\n-                  data: &crate_metadata) {\n+fn set_crate_data(cstore: cstore, cnum: ast::crate_num,\n+                  data: crate_metadata) {\n     p(cstore).metas.insert(cnum, data);\n }\n \n-fn have_crate_data(cstore: &cstore, cnum: ast::crate_num) -> bool {\n+fn have_crate_data(cstore: cstore, cnum: ast::crate_num) -> bool {\n     ret p(cstore).metas.contains_key(cnum);\n }\n \n-iter iter_crate_data(cstore: &cstore) ->\n+iter iter_crate_data(cstore: cstore) ->\n      @{key: ast::crate_num, val: crate_metadata} {\n     for each kv: @{key: ast::crate_num, val: crate_metadata} in\n              p(cstore).metas.items() {\n         put kv;\n     }\n }\n \n-fn add_used_crate_file(cstore: &cstore, lib: &str) {\n+fn add_used_crate_file(cstore: cstore, lib: str) {\n     if !vec::member(lib, p(cstore).used_crate_files) {\n         p(cstore).used_crate_files += [lib];\n     }\n }\n \n-fn get_used_crate_files(cstore: &cstore) -> [str] {\n+fn get_used_crate_files(cstore: cstore) -> [str] {\n     ret p(cstore).used_crate_files;\n }\n \n-fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n+fn add_used_library(cstore: cstore, lib: str) -> bool {\n     if lib == \"\" { ret false; }\n \n     if vec::member(lib, p(cstore).used_libraries) { ret false; }\n@@ -101,25 +101,24 @@ fn add_used_library(cstore: &cstore, lib: &str) -> bool {\n     ret true;\n }\n \n-fn get_used_libraries(cstore: &cstore) -> [str] {\n+fn get_used_libraries(cstore: cstore) -> [str] {\n     ret p(cstore).used_libraries;\n }\n \n-fn add_used_link_args(cstore: &cstore, args: &str) {\n+fn add_used_link_args(cstore: cstore, args: str) {\n     p(cstore).used_link_args += str::split(args, ' ' as u8);\n }\n \n-fn get_used_link_args(cstore: &cstore) -> [str] {\n+fn get_used_link_args(cstore: cstore) -> [str] {\n     ret p(cstore).used_link_args;\n }\n \n-fn add_use_stmt_cnum(cstore: &cstore, use_id: ast::node_id,\n+fn add_use_stmt_cnum(cstore: cstore, use_id: ast::node_id,\n                      cnum: ast::crate_num) {\n     p(cstore).use_crate_map.insert(use_id, cnum);\n }\n \n-fn get_use_stmt_cnum(cstore: &cstore, use_id: ast::node_id) ->\n-   ast::crate_num {\n+fn get_use_stmt_cnum(cstore: cstore, use_id: ast::node_id) -> ast::crate_num {\n     ret p(cstore).use_crate_map.get(use_id);\n }\n "}, {"sha": "cd241f3931e64ab95500829af1a6abbd6c83e6be", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -34,9 +34,9 @@ export external_resolver;\n // def_id for an item defined in another crate, somebody needs to figure out\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n-type external_resolver = fn(&ast::def_id) -> ast::def_id;\n+type external_resolver = fn(ast::def_id) -> ast::def_id;\n \n-fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool, hash: uint) ->\n+fn lookup_hash(d: ebml::doc, eq_fn: fn([u8]) -> bool, hash: uint) ->\n    [ebml::doc] {\n     let index = ebml::get_doc(d, tag_index);\n     let table = ebml::get_doc(index, tag_index_table);\n@@ -56,8 +56,8 @@ fn lookup_hash(d: &ebml::doc, eq_fn: fn(&[u8]) -> bool, hash: uint) ->\n     ret result;\n }\n \n-fn maybe_find_item(item_id: int, items: &ebml::doc) -> option::t<ebml::doc> {\n-    fn eq_item(bytes: &[u8], item_id: int) -> bool {\n+fn maybe_find_item(item_id: int, items: ebml::doc) -> option::t<ebml::doc> {\n+    fn eq_item(bytes: [u8], item_id: int) -> bool {\n         ret ebml::be_uint_from_bytes(@bytes, 0u, 4u) as int == item_id;\n     }\n     let eqer = bind eq_item(_, item_id);\n@@ -67,36 +67,36 @@ fn maybe_find_item(item_id: int, items: &ebml::doc) -> option::t<ebml::doc> {\n     } else { ret option::some::<ebml::doc>(found[0]); }\n }\n \n-fn find_item(item_id: int, items: &ebml::doc) -> ebml::doc {\n+fn find_item(item_id: int, items: ebml::doc) -> ebml::doc {\n     ret option::get(maybe_find_item(item_id, items));\n }\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: &@[u8]) -> ebml::doc {\n+fn lookup_item(item_id: int, data: @[u8]) -> ebml::doc {\n     let items = ebml::get_doc(ebml::new_doc(data), tag_items);\n     ret find_item(item_id, items);\n }\n \n-fn item_family(item: &ebml::doc) -> u8 {\n+fn item_family(item: ebml::doc) -> u8 {\n     let fam = ebml::get_doc(item, tag_items_data_item_family);\n     ret ebml::doc_as_uint(fam) as u8;\n }\n \n-fn item_symbol(item: &ebml::doc) -> str {\n+fn item_symbol(item: ebml::doc) -> str {\n     let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n     ret str::unsafe_from_bytes(ebml::doc_data(sym));\n }\n \n-fn variant_tag_id(d: &ebml::doc) -> ast::def_id {\n+fn variant_tag_id(d: ebml::doc) -> ast::def_id {\n     let tagdoc = ebml::get_doc(d, tag_items_data_item_tag_id);\n     ret parse_def_id(ebml::doc_data(tagdoc));\n }\n \n-fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n-             extres: &external_resolver) -> ty::t {\n+fn item_type(item: ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n+             extres: external_resolver) -> ty::t {\n     fn parse_external_def_id(this_cnum: ast::crate_num,\n-                             extres: &external_resolver, s: &str) ->\n+                             extres: external_resolver, s: str) ->\n        ast::def_id {\n         let buf = str::bytes(s);\n         let external_def_id = parse_def_id(buf);\n@@ -114,7 +114,7 @@ fn item_type(item: &ebml::doc, this_cnum: ast::crate_num, tcx: ty::ctxt,\n                       def_parser, tcx);\n }\n \n-fn item_ty_param_kinds(item: &ebml::doc) -> [ast::kind] {\n+fn item_ty_param_kinds(item: ebml::doc) -> [ast::kind] {\n     let ks: [ast::kind] = [];\n     let tp = tag_items_data_item_ty_param_kinds;\n     for each p: ebml::doc in ebml::tagged_docs(item, tp) {\n@@ -135,7 +135,7 @@ fn item_ty_param_kinds(item: &ebml::doc) -> [ast::kind] {\n     ret ks;\n }\n \n-fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n+fn tag_variant_ids(item: ebml::doc, this_cnum: ast::crate_num) ->\n    [ast::def_id] {\n     let ids: [ast::def_id] = [];\n     let v = tag_items_data_item_variant;\n@@ -148,8 +148,8 @@ fn tag_variant_ids(item: &ebml::doc, this_cnum: ast::crate_num) ->\n \n // Given a path and serialized crate metadata, returns the ID of the\n // definition the path refers to.\n-fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n-    fn eq_item(data: &[u8], s: &str) -> bool {\n+fn resolve_path(path: [ast::ident], data: @[u8]) -> [ast::def_id] {\n+    fn eq_item(data: [u8], s: str) -> bool {\n         ret str::eq(str::unsafe_from_bytes(data), s);\n     }\n     let s = str::connect(path, \"::\");\n@@ -165,14 +165,14 @@ fn resolve_path(path: &[ast::ident], data: @[u8]) -> [ast::def_id] {\n }\n \n // Crate metadata queries\n-fn lookup_defs(data: &@[u8], cnum: ast::crate_num, path: &[ast::ident]) ->\n+fn lookup_defs(data: @[u8], cnum: ast::crate_num, path: [ast::ident]) ->\n    [ast::def] {\n     ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n }\n \n \n // FIXME doesn't yet handle re-exported externals\n-fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: &ast::def_id) ->\n+fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: ast::def_id) ->\n    ast::def {\n     let item = lookup_item(did_.node, data);\n     let fam_ch = item_family(item);\n@@ -198,8 +198,8 @@ fn lookup_def(cnum: ast::crate_num, data: @[u8], did_: &ast::def_id) ->\n     ret def;\n }\n \n-fn get_type(data: @[u8], def: ast::def_id, tcx: &ty::ctxt,\n-            extres: &external_resolver) -> ty::ty_param_kinds_and_ty {\n+fn get_type(data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n+            extres: external_resolver) -> ty::ty_param_kinds_and_ty {\n     let this_cnum = def.crate;\n     let node_id = def.node;\n     let item = lookup_item(node_id, data);\n@@ -225,8 +225,8 @@ fn get_symbol(data: @[u8], id: ast::node_id) -> str {\n     ret item_symbol(lookup_item(id, data));\n }\n \n-fn get_tag_variants(_data: &@[u8], def: ast::def_id, tcx: &ty::ctxt,\n-                    extres: &external_resolver) -> [ty::variant_info] {\n+fn get_tag_variants(_data: @[u8], def: ast::def_id, tcx: ty::ctxt,\n+                    extres: external_resolver) -> [ty::variant_info] {\n     let external_crate_id = def.crate;\n     let data =\n         cstore::get_crate_data(tcx.sess.get_cstore(), external_crate_id).data;\n@@ -267,15 +267,15 @@ fn family_has_type_params(fam_ch: u8) -> bool {\n         };\n }\n \n-fn read_path(d: &ebml::doc) -> {path: str, pos: uint} {\n+fn read_path(d: ebml::doc) -> {path: str, pos: uint} {\n     let desc = ebml::doc_data(d);\n     let pos = ebml::be_uint_from_bytes(@desc, 0u, 4u);\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::unsafe_from_bytes(pathbytes);\n     ret {path: path, pos: pos};\n }\n \n-fn describe_def(items: &ebml::doc, id: ast::def_id) -> str {\n+fn describe_def(items: ebml::doc, id: ast::def_id) -> str {\n     if id.crate != ast::local_crate { ret \"external\"; }\n     ret item_family_to_str(item_family(find_item(id.node, items)));\n }\n@@ -295,7 +295,7 @@ fn item_family_to_str(fam: u8) -> str {\n     }\n }\n \n-fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n+fn get_meta_items(md: ebml::doc) -> [@ast::meta_item] {\n     let items: [@ast::meta_item] = [];\n     for each meta_item_doc: ebml::doc in\n              ebml::tagged_docs(md, tag_meta_item_word) {\n@@ -323,7 +323,7 @@ fn get_meta_items(md: &ebml::doc) -> [@ast::meta_item] {\n     ret items;\n }\n \n-fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n+fn get_attributes(md: ebml::doc) -> [ast::attribute] {\n     let attrs: [ast::attribute] = [];\n     alt ebml::maybe_get_doc(md, tag_attributes) {\n       option::some(attrs_d) {\n@@ -344,13 +344,13 @@ fn get_attributes(md: &ebml::doc) -> [ast::attribute] {\n     ret attrs;\n }\n \n-fn list_meta_items(meta_items: &ebml::doc, out: io::writer) {\n+fn list_meta_items(meta_items: ebml::doc, out: io::writer) {\n     for mi: @ast::meta_item in get_meta_items(meta_items) {\n         out.write_str(#fmt[\"%s\\n\", pprust::meta_item_to_str(*mi)]);\n     }\n }\n \n-fn list_crate_attributes(md: &ebml::doc, out: io::writer) {\n+fn list_crate_attributes(md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Crate Attributes=\\n\");\n \n     for attr: ast::attribute in get_attributes(md) {\n@@ -389,7 +389,7 @@ fn list_crate_deps(data: @[u8], out: io::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n+fn list_crate_items(bytes: @[u8], md: ebml::doc, out: io::writer) {\n     out.write_str(\"=Items=\\n\");\n     let paths = ebml::get_doc(md, tag_paths);\n     let items = ebml::get_doc(md, tag_items);\n@@ -410,7 +410,7 @@ fn list_crate_items(bytes: &@[u8], md: &ebml::doc, out: io::writer) {\n     out.write_str(\"\\n\");\n }\n \n-fn list_crate_metadata(bytes: &@[u8], out: io::writer) {\n+fn list_crate_metadata(bytes: @[u8], out: io::writer) {\n     let md = ebml::new_doc(bytes);\n     list_crate_attributes(md, out);\n     list_crate_deps(bytes, out);"}, {"sha": "9c48772cd228110db29b66ce685edc4837e848ad", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 43, "deletions": 46, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -26,22 +26,22 @@ type abbrev_map = map::hashmap<ty::t, tyencode::ty_abbrev>;\n type encode_ctxt = {ccx: @crate_ctxt, type_abbrevs: abbrev_map};\n \n // Path table encoding\n-fn encode_name(ebml_w: &ebml::writer, name: &str) {\n+fn encode_name(ebml_w: ebml::writer, name: str) {\n     ebml::start_tag(ebml_w, tag_paths_data_name);\n     ebml_w.writer.write(str::bytes(name));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_def_id(ebml_w: &ebml::writer, id: &def_id) {\n+fn encode_def_id(ebml_w: ebml::writer, id: def_id) {\n     ebml::start_tag(ebml_w, tag_def_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n type entry<T> = {val: T, pos: uint};\n \n-fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n-                            path: &[str], index: &mutable [entry<str>]) {\n+fn encode_tag_variant_paths(ebml_w: ebml::writer, variants: [variant],\n+                            path: [str], index: &mutable [entry<str>]) {\n     for variant: variant in variants {\n         add_to_index(ebml_w, path, index, variant.node.name);\n         ebml::start_tag(ebml_w, tag_paths_data_item);\n@@ -51,15 +51,15 @@ fn encode_tag_variant_paths(ebml_w: &ebml::writer, variants: &[variant],\n     }\n }\n \n-fn add_to_index(ebml_w: &ebml::writer, path: &[str],\n-                index: &mutable [entry<str>], name: &str) {\n+fn add_to_index(ebml_w: ebml::writer, path: [str],\n+                index: &mutable [entry<str>], name: str) {\n     let full_path = path + [name];\n     index +=\n         [{val: str::connect(full_path, \"::\"), pos: ebml_w.writer.tell()}];\n }\n \n-fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n-                                   path: &[str],\n+fn encode_native_module_item_paths(ebml_w: ebml::writer, nmod: native_mod,\n+                                   path: [str],\n                                    index: &mutable [entry<str>]) {\n     for nitem: @native_item in nmod.items {\n         add_to_index(ebml_w, path, index, nitem.ident);\n@@ -70,8 +70,8 @@ fn encode_native_module_item_paths(ebml_w: &ebml::writer, nmod: &native_mod,\n     }\n }\n \n-fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n-                            path: &[str], index: &mutable [entry<str>]) {\n+fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n+                            index: &mutable [entry<str>]) {\n     for it: @item in module.items {\n         if !ast_util::is_exported(it.ident, module) { cont; }\n         alt it.node {\n@@ -149,7 +149,7 @@ fn encode_module_item_paths(ebml_w: &ebml::writer, module: &_mod,\n     }\n }\n \n-fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<str>] {\n+fn encode_item_paths(ebml_w: ebml::writer, crate: @crate) -> [entry<str>] {\n     let index: [entry<str>] = [];\n     let path: [str] = [];\n     ebml::start_tag(ebml_w, tag_paths);\n@@ -160,21 +160,21 @@ fn encode_item_paths(ebml_w: &ebml::writer, crate: &@crate) -> [entry<str>] {\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: &ebml::writer, c: u8) {\n+fn encode_family(ebml_w: ebml::writer, c: u8) {\n     ebml::start_tag(ebml_w, tag_items_data_item_family);\n     ebml_w.writer.write([c]);\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_inlineness(ebml_w: &ebml::writer, c: u8) {\n+fn encode_inlineness(ebml_w: ebml::writer, c: u8) {\n     ebml::start_tag(ebml_w, tag_items_data_item_inlineness);\n     ebml_w.writer.write([c]);\n     ebml::end_tag(ebml_w);\n }\n \n-fn def_to_str(did: &def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n+fn def_to_str(did: def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n \n-fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n+fn encode_type_param_kinds(ebml_w: ebml::writer, tps: [ty_param]) {\n     ebml::start_tag(ebml_w, tag_items_data_item_ty_param_kinds);\n     ebml::write_vint(ebml_w.writer, vec::len::<ty_param>(tps));\n     for tp: ty_param in tps {\n@@ -189,13 +189,13 @@ fn encode_type_param_kinds(ebml_w: &ebml::writer, tps: &[ty_param]) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_variant_id(ebml_w: &ebml::writer, vid: &def_id) {\n+fn encode_variant_id(ebml_w: ebml::writer, vid: def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_variant);\n     ebml_w.writer.write(str::bytes(def_to_str(vid)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebml::writer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::writer, typ: ty::t) {\n     ebml::start_tag(ebml_w, tag_items_data_item_type);\n     let f = def_to_str;\n     let ty_str_ctxt =\n@@ -206,29 +206,28 @@ fn encode_type(ecx: &@encode_ctxt, ebml_w: &ebml::writer, typ: ty::t) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_symbol(ecx: &@encode_ctxt, ebml_w: &ebml::writer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes(ecx.ccx.item_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_discriminant(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n-                       id: node_id) {\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::writer, id: node_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_symbol);\n     ebml_w.writer.write(str::bytes(ecx.ccx.discrim_symbols.get(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_id(ebml_w: &ebml::writer, id: &def_id) {\n+fn encode_tag_id(ebml_w: ebml::writer, id: def_id) {\n     ebml::start_tag(ebml_w, tag_items_data_item_tag_id);\n     ebml_w.writer.write(str::bytes(def_to_str(id)));\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n-                           id: node_id, variants: &[variant],\n+fn encode_tag_variant_info(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                           id: node_id, variants: [variant],\n                            index: &mutable [entry<int>],\n-                           ty_params: &[ty_param]) {\n+                           ty_params: [ty_param]) {\n     for variant: variant in variants {\n         index += [{val: variant.node.id, pos: ebml_w.writer.tell()}];\n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -246,7 +245,7 @@ fn encode_tag_variant_info(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n     }\n }\n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer, item: @item,\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                         index: &mutable [entry<int>]) {\n     alt item.node {\n       item_const(_, _) {\n@@ -349,8 +348,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: &ebml::writer, item: @item,\n     }\n }\n \n-fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n-                               nitem: &@native_item) {\n+fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n+                               nitem: @native_item) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     alt nitem.node {\n       native_item_ty. {\n@@ -370,7 +369,7 @@ fn encode_info_for_native_item(ecx: &@encode_ctxt, ebml_w: &ebml::writer,\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer) ->\n    [entry<int>] {\n     let index: [entry<int>] = [];\n     ebml::start_tag(ebml_w, tag_items_data);\n@@ -395,7 +394,7 @@ fn encode_info_for_items(ecx: &@encode_ctxt, ebml_w: &ebml::writer) ->\n \n // Path and definition ID indexing\n \n-fn create_index<T>(index: &[entry<T>], hash_fn: fn(&T) -> uint) ->\n+fn create_index<T>(index: [entry<T>], hash_fn: fn(T) -> uint) ->\n    [@[entry<T>]] {\n     let buckets: [@mutable [entry<T>]] = [];\n     for each i: uint in uint::range(0u, 256u) { buckets += [@mutable []]; }\n@@ -411,8 +410,8 @@ fn create_index<T>(index: &[entry<T>], hash_fn: fn(&T) -> uint) ->\n     ret buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n-                   write_fn: fn(&io::writer, &T)) {\n+fn encode_index<T>(ebml_w: ebml::writer, buckets: [@[entry<T>]],\n+                   write_fn: fn(io::writer, T)) {\n     let writer = io::new_writer(ebml_w.writer);\n     ebml::start_tag(ebml_w, tag_index);\n     let bucket_locs: [uint] = [];\n@@ -435,13 +434,13 @@ fn encode_index<T>(ebml_w: &ebml::writer, buckets: &[@[entry<T>]],\n     ebml::end_tag(ebml_w);\n }\n \n-fn write_str(writer: &io::writer, s: &str) { writer.write_str(s); }\n+fn write_str(writer: io::writer, s: str) { writer.write_str(s); }\n \n-fn write_int(writer: &io::writer, n: &int) {\n+fn write_int(writer: io::writer, n: int) {\n     writer.write_be_uint(n as uint, 4u);\n }\n \n-fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n+fn encode_meta_item(ebml_w: ebml::writer, mi: meta_item) {\n     alt mi.node {\n       meta_word(name) {\n         ebml::start_tag(ebml_w, tag_meta_item_word);\n@@ -478,7 +477,7 @@ fn encode_meta_item(ebml_w: &ebml::writer, mi: &meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: &ebml::writer, attrs: &[attribute]) {\n+fn encode_attributes(ebml_w: ebml::writer, attrs: [attribute]) {\n     ebml::start_tag(ebml_w, tag_attributes);\n     for attr: attribute in attrs {\n         ebml::start_tag(ebml_w, tag_attribute);\n@@ -492,9 +491,9 @@ fn encode_attributes(ebml_w: &ebml::writer, attrs: &[attribute]) {\n // metadata that Rust cares about for linking crates. This attribute requires\n // 'name' and 'vers' items, so if the user didn't provide them we will throw\n // them in anyway with default values.\n-fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n+fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> [attribute] {\n \n-    fn synthesize_link_attr(ecx: &@encode_ctxt, items: &[@meta_item]) ->\n+    fn synthesize_link_attr(ecx: @encode_ctxt, items: [@meta_item]) ->\n        attribute {\n \n         assert (ecx.ccx.link_meta.name != \"\");\n@@ -526,7 +525,7 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n             } else {\n                 alt attr.node.value.node {\n                   meta_list(n, l) {\n-                    found_link_attr = true;\n+                    found_link_attr = true;;\n                     [synthesize_link_attr(ecx, l)]\n                   }\n                   _ { [attr] }\n@@ -539,9 +538,9 @@ fn synthesize_crate_attrs(ecx: &@encode_ctxt, crate: &@crate) -> [attribute] {\n     ret attrs;\n }\n \n-fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n+fn encode_crate_deps(ebml_w: ebml::writer, cstore: cstore::cstore) {\n \n-    fn get_ordered_names(cstore: &cstore::cstore) -> [str] {\n+    fn get_ordered_names(cstore: cstore::cstore) -> [str] {\n         type hashkv = @{key: crate_num, val: cstore::crate_metadata};\n         type numname = {crate: crate_num, ident: str};\n \n@@ -552,9 +551,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n         }\n \n         // Sort by cnum\n-        fn lteq(kv1: &numname, kv2: &numname) -> bool {\n-            kv1.crate <= kv2.crate\n-        }\n+        fn lteq(kv1: numname, kv2: numname) -> bool { kv1.crate <= kv2.crate }\n         std::sort::quick_sort(lteq, pairs);\n \n         // Sanity-check the crate numbers\n@@ -565,7 +562,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n         }\n \n         // Return just the names\n-        fn name(kv: &numname) -> str { kv.ident }\n+        fn name(kv: numname) -> str { kv.ident }\n         // mutable -> immutable hack for vec::map\n         let immpairs = vec::slice(pairs, 0u, vec::len(pairs));\n         ret vec::map(name, immpairs);\n@@ -584,7 +581,7 @@ fn encode_crate_deps(ebml_w: &ebml::writer, cstore: &cstore::cstore) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n+fn encode_metadata(cx: @crate_ctxt, crate: @crate) -> str {\n \n     let abbrevs = map::mk_hashmap(ty::hash_ty, ty::eq_ty);\n     let ecx = @{ccx: cx, type_abbrevs: abbrevs};\n@@ -620,7 +617,7 @@ fn encode_metadata(cx: &@crate_ctxt, crate: &@crate) -> str {\n }\n \n // Get the encoded string for a type\n-fn encoded_ty(tcx: &ty::ctxt, t: ty::t) -> str {\n+fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> str {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n     let sw = io::string_writer();\n     tyencode::enc_ty(sw.get_writer(), cx, t);"}, {"sha": "ce73f736b798ec530c3f80fbff26e60a8234662e", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -20,7 +20,7 @@ export parse_ty_data;\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n // Callback to translate defs to strs or back:\n-type str_def = fn(&str) -> ast::def_id;\n+type str_def = fn(str) -> ast::def_id;\n \n type pstate =\n     {data: @[u8], crate: int, mutable pos: uint, len: uint, tcx: ty::ctxt};\n@@ -401,7 +401,7 @@ fn parse_ty_fn(st: @pstate, sd: str_def) ->\n \n \n // Rust metadata parsing\n-fn parse_def_id(buf: &[u8]) -> ast::def_id {\n+fn parse_def_id(buf: [u8]) -> ast::def_id {\n     let colon_idx = 0u;\n     let len = vec::len::<u8>(buf);\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1u; }"}, {"sha": "dde77d6533faa52e003df07c0304176e670b7aef", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -21,7 +21,7 @@ export enc_ty;\n type ctxt =\n     // Def -> str Callback:\n     // The type context.\n-    {ds: fn(&def_id) -> str, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n+    {ds: fn(def_id) -> str, tcx: ty::ctxt, abbrevs: abbrev_ctxt};\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n@@ -30,14 +30,14 @@ type ty_abbrev = {pos: uint, len: uint, s: @str};\n \n tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n \n-fn cx_uses_abbrevs(cx: &@ctxt) -> bool {\n+fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     alt cx.abbrevs {\n       ac_no_abbrevs. { ret false; }\n       ac_use_abbrevs(_) { ret true; }\n     }\n }\n \n-fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n+fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n     alt cx.abbrevs {\n       ac_no_abbrevs. {\n         let result_str: @str;\n@@ -82,15 +82,15 @@ fn enc_ty(w: &io::writer, cx: &@ctxt, t: ty::t) {\n       }\n     }\n }\n-fn enc_mt(w: &io::writer, cx: &@ctxt, mt: &ty::mt) {\n+fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     alt mt.mut {\n       imm. { }\n       mut. { w.write_char('m'); }\n       maybe_mut. { w.write_char('?'); }\n     }\n     enc_ty(w, cx, mt.ty);\n }\n-fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n+fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n     alt st {\n       ty::ty_nil. { w.write_char('n'); }\n       ty::ty_bot. { w.write_char('z'); }\n@@ -194,16 +194,16 @@ fn enc_sty(w: &io::writer, cx: &@ctxt, st: &ty::sty) {\n       }\n     }\n }\n-fn enc_proto(w: &io::writer, proto: proto) {\n+fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n       proto_iter. { w.write_char('W'); }\n       proto_fn. { w.write_char('F'); }\n       proto_block. { w.write_char('B'); }\n     }\n }\n \n-fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n-             cf: &controlflow, constrs: &[@ty::constr]) {\n+fn enc_ty_fn(w: io::writer, cx: @ctxt, args: [ty::arg], out: ty::t,\n+             cf: controlflow, constrs: [@ty::constr]) {\n     w.write_char('[');\n     for arg: ty::arg in args {\n         alt arg.mode {\n@@ -227,7 +227,7 @@ fn enc_ty_fn(w: &io::writer, cx: &@ctxt, args: &[ty::arg], out: ty::t,\n }\n \n // FIXME less copy-and-paste\n-fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n+fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n     w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));\n@@ -244,7 +244,7 @@ fn enc_constr(w: &io::writer, cx: &@ctxt, c: &@ty::constr) {\n     w.write_char(')');\n }\n \n-fn enc_ty_constr(w: &io::writer, cx: &@ctxt, c: &@ty::type_constr) {\n+fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n     w.write_str(path_to_str(c.node.path));\n     w.write_char('(');\n     w.write_str(cx.ds(c.node.id));"}, {"sha": "2d14daa2c427d1ee561eaed9d84ce120b96fd945", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -45,7 +45,7 @@ type ctx =\n      mutable next_local: uint,\n      copy_map: copy_map};\n \n-fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) -> copy_map {\n+fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> copy_map {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n     let cx =\n@@ -63,17 +63,19 @@ fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) -> copy_map {\n     ret cx.copy_map;\n }\n \n-fn visit_fn(f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span, _name: &fn_ident,\n-            _id: ast::node_id, sc: &scope, v: &vt<scope>) {\n+fn visit_fn(f: ast::_fn, _tp: [ast::ty_param], _sp: span, _name: fn_ident,\n+            _id: ast::node_id, sc: scope, v: vt<scope>) {\n     visit::visit_fn_decl(f.decl, sc, v);\n     let scope =\n         alt f.proto {\n \n+\n           // Blocks need to obey any restrictions from the enclosing scope.\n           ast::proto_block. | ast::proto_closure. {\n             sc\n           }\n \n+\n           // Non capturing functions start out fresh.\n           _ {\n             @[]\n@@ -82,7 +84,7 @@ fn visit_fn(f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span, _name: &fn_ident,\n     v.visit_block(f.body, scope, v);\n }\n \n-fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n+fn visit_expr(cx: @ctx, ex: @ast::expr, sc: scope, v: vt<scope>) {\n     let handled = true;\n     alt ex.node {\n       ast::expr_call(f, args) {\n@@ -129,14 +131,14 @@ fn visit_expr(cx: &@ctx, ex: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     if !handled { visit::visit_expr(ex, sc, v); }\n }\n \n-fn register_locals(cx: &ctx, pat: &@ast::pat) {\n+fn register_locals(cx: ctx, pat: @ast::pat) {\n     for each pat in ast_util::pat_bindings(pat) {\n         cx.local_map.insert(pat.id, local(cx.next_local));\n         cx.next_local += 1u;\n     }\n }\n \n-fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n+fn visit_decl(cx: @ctx, d: @ast::decl, sc: scope, v: vt<scope>) {\n     visit::visit_decl(d, sc, v);\n     alt d.node {\n       ast::decl_local(locs) {\n@@ -156,22 +158,21 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n     }\n }\n \n-fn cant_copy(cx: &ctx, r: &restrict) -> bool {\n+fn cant_copy(cx: ctx, r: restrict) -> bool {\n     if r.given_up { ret false; }\n     // FIXME alt contexts copying not supported yet\n     if r.node_id == 0 { ret true; }\n+\n     // FIXME warn when copy is expensive\n     if ty::type_allows_implicit_copy(cx.tcx, r.ty) {\n         r.given_up = true;\n         cx.copy_map.insert(r.node_id, ());\n         ret false;\n-    } else {\n-        ret true;\n-    }\n+    } else { ret true; }\n }\n \n-fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n-    -> [restrict] {\n+fn check_call(cx: ctx, f: @ast::expr, args: [@ast::expr], sc: scope) ->\n+   [restrict] {\n     let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n     let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n@@ -193,15 +194,16 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n         let unsafe_t =\n             alt inner_mut(root.ds) { some(t) { some(t) } _ { none } };\n         restricts +=\n-            [@{root_var: root_var,\n+            [\n+             // FIXME kludge\n+             @{root_var: root_var,\n                node_id: arg_t.mode == ast::by_mut_ref ? 0 : arg.id,\n                ty: arg_t.ty,\n                local_id: cx.next_local,\n                bindings: [arg.id],\n                unsafe_ty: unsafe_t,\n                depends_on: deps(sc, root_var),\n                mutable ok: valid,\n-               // FIXME kludge\n                mutable given_up: arg_t.mode == ast::by_move}];\n         i += 1u;\n     }\n@@ -230,12 +232,12 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias = arg_t.mode == ast::by_mut_ref;\n                 if i != j &&\n-                   ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n-                   cant_copy(cx, r) {\n-                    cx.tcx.sess.span_err(\n-                        args[i].span,\n-                        #fmt[\"argument %u may alias with argument %u, \\\n-                              which is not immutably rooted\", i, j]);\n+                       ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n+                       cant_copy(cx, r) {\n+                    cx.tcx.sess.span_err(args[i].span,\n+                               #fmt[\"argument %u may alias with argument %u, \\\n+                              which is not immutably rooted\",\n+                                              i, j]);\n                 }\n                 i += 1u;\n             }\n@@ -253,8 +255,8 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n                 alt r.root_var {\n                   some(root) {\n                     if node == root && cant_copy(cx, r) {\n-                        cx.tcx.sess.span_err(\n-                            args[arg].span, \"passing a mutable alias to a \\\n+                        cx.tcx.sess.span_err(args[arg].span,\n+                                             \"passing a mutable alias to a \\\n                             variable that roots another alias\");\n                         break;\n                     }\n@@ -268,8 +270,8 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n     ret restricts;\n }\n \n-fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n-             v: &vt<scope>) {\n+fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n+             v: vt<scope>) {\n     v.visit_expr(input, sc, v);\n     let root = expr_root(cx.tcx, input, true);\n     for a: ast::arm in arms {\n@@ -279,8 +281,9 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n             let root_var = path_def_id(cx, root.ex);\n             new_sc =\n                 @(*sc +\n-                      [@{root_var: root_var,\n-                     // FIXME need to use separate restrict for each binding\n+                      [\n+                       // FIXME need to use separate restrict for each binding\n+                       @{root_var: root_var,\n                          node_id: 0,\n                          ty: ty::mk_int(cx.tcx),\n                          local_id: cx.next_local,\n@@ -295,8 +298,8 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n     }\n }\n \n-fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n-                  blk: &ast::blk, sc: &scope, v: &vt<scope>) {\n+fn check_for_each(cx: ctx, local: @ast::local, call: @ast::expr,\n+                  blk: ast::blk, sc: scope, v: vt<scope>) {\n     v.visit_expr(call, sc, v);\n     alt call.node {\n       ast::expr_call(f, args) {\n@@ -307,8 +310,8 @@ fn check_for_each(cx: &ctx, local: &@ast::local, call: &@ast::expr,\n     }\n }\n \n-fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n-             sc: &scope, v: &vt<scope>) {\n+fn check_for(cx: ctx, local: @ast::local, seq: @ast::expr, blk: ast::blk,\n+             sc: scope, v: vt<scope>) {\n     v.visit_expr(seq, sc, v);\n     let root = expr_root(cx.tcx, seq, false);\n     let unsafe = inner_mut(root.ds);\n@@ -321,13 +324,12 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n         if mt.mut != ast::imm { unsafe = some(seq_t); }\n         elt_t = mt.ty;\n       }\n-      ty::ty_str. {\n-        elt_t = ty::mk_mach(cx.tcx, ast::ty_u8);\n-      }\n+      ty::ty_str. { elt_t = ty::mk_mach(cx.tcx, ast::ty_u8); }\n     }\n     let root_var = path_def_id(cx, root.ex);\n     let new_sc =\n         @{root_var: root_var,\n+\n           // FIXME reenable when trans knows how to copy for vars\n           node_id: 0, // blk.node.id,\n           ty: elt_t,\n@@ -341,15 +343,16 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n     visit::visit_block(blk, @(*sc + [new_sc]), v);\n }\n \n-fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n-             assign: bool, sc: &scope) {\n+fn check_var(cx: ctx, ex: @ast::expr, p: ast::path, id: ast::node_id,\n+             assign: bool, sc: scope) {\n     let def = cx.tcx.def_map.get(id);\n     if !def_is_local(def, true) { ret; }\n     let my_defnum = ast_util::def_id_of_def(def).node;\n     let my_local_id =\n         alt cx.local_map.find(my_defnum) { some(local(id)) { id } _ { 0u } };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n+\n         // excludes variables introduced since the alias was made\n         if my_local_id < r.local_id {\n             alt r.unsafe_ty {\n@@ -366,7 +369,7 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n     }\n }\n \n-fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n+fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n     alt dest.node {\n       ast::expr_path(p) {\n         let def = cx.tcx.def_map.get(dest.id);\n@@ -379,35 +382,37 @@ fn check_lval(cx: &@ctx, dest: &@ast::expr, sc: &scope, v: &vt<scope>) {\n     }\n }\n \n-fn check_assign(cx: &@ctx, dest: &@ast::expr, src: &@ast::expr, sc: &scope,\n-                v: &vt<scope>) {\n+fn check_assign(cx: @ctx, dest: @ast::expr, src: @ast::expr, sc: scope,\n+                v: vt<scope>) {\n     visit_expr(cx, src, sc, v);\n     check_lval(cx, dest, sc, v);\n }\n \n-fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n+fn test_scope(cx: ctx, sc: scope, r: restrict, p: ast::path) {\n     let prob = r.ok;\n     for dep: uint in r.depends_on {\n         if prob != valid { break; }\n         prob = sc[dep].ok;\n     }\n     if prob != valid && cant_copy(cx, r) {\n-        let msg = alt prob {\n-          overwritten(sp, wpt) {\n-            {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n-          }\n-          val_taken(sp, vpt) {\n-            {span: sp, msg: \"taking the value of \" + ast_util::path_name(vpt)}\n-          }\n-        };\n+        let msg =\n+            alt prob {\n+              overwritten(sp, wpt) {\n+                {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n+              }\n+              val_taken(sp, vpt) {\n+                {span: sp,\n+                 msg: \"taking the value of \" + ast_util::path_name(vpt)}\n+              }\n+            };\n         cx.tcx.sess.span_err(msg.span,\n                              msg.msg + \" will invalidate alias \" +\n                                  ast_util::path_name(p) +\n                                  \", which is still used\");\n     }\n }\n \n-fn deps(sc: &scope, root: &option::t<node_id>) -> [uint] {\n+fn deps(sc: scope, root: option::t<node_id>) -> [uint] {\n     let result = [];\n     alt root {\n       some(dn) {\n@@ -422,14 +427,14 @@ fn deps(sc: &scope, root: &option::t<node_id>) -> [uint] {\n     ret result;\n }\n \n-fn path_def(cx: &ctx, ex: &@ast::expr) -> option::t<ast::def> {\n+fn path_def(cx: ctx, ex: @ast::expr) -> option::t<ast::def> {\n     ret alt ex.node {\n           ast::expr_path(_) { some(cx.tcx.def_map.get(ex.id)) }\n           _ { none }\n         }\n }\n \n-fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::node_id> {\n+fn path_def_id(cx: ctx, ex: @ast::expr) -> option::t<ast::node_id> {\n     alt ex.node {\n       ast::expr_path(_) {\n         ret some(ast_util::def_id_of_def(cx.tcx.def_map.get(ex.id)).node);\n@@ -438,12 +443,12 @@ fn path_def_id(cx: &ctx, ex: &@ast::expr) -> option::t<ast::node_id> {\n     }\n }\n \n-fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n-                           mut: bool) -> bool {\n-    fn get_mut(cur: bool, mt: &ty::mt) -> bool {\n+fn ty_can_unsafely_include(cx: ctx, needle: ty::t, haystack: ty::t, mut: bool)\n+   -> bool {\n+    fn get_mut(cur: bool, mt: ty::mt) -> bool {\n         ret cur || mt.mut != ast::imm;\n     }\n-    fn helper(tcx: &ty::ctxt, needle: ty::t, haystack: ty::t, mut: bool) ->\n+    fn helper(tcx: ty::ctxt, needle: ty::t, haystack: ty::t, mut: bool) ->\n        bool {\n         if needle == haystack { ret true; }\n         alt ty::struct(tcx, haystack) {\n@@ -472,6 +477,7 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n \n \n \n+\n           // These may contain anything.\n           ty::ty_fn(_, _, _, _, _) {\n             ret true;\n@@ -480,6 +486,7 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n \n \n \n+\n           // A type param may include everything, but can only be\n           // treated as opaque downstream, and is thus safe unless we\n           // saw mutable fields, in which case the whole thing can be\n@@ -493,7 +500,7 @@ fn ty_can_unsafely_include(cx: &ctx, needle: ty::t, haystack: ty::t,\n     ret helper(cx.tcx, needle, haystack, mut);\n }\n \n-fn def_is_local(d: &ast::def, objfields_count: bool) -> bool {\n+fn def_is_local(d: ast::def, objfields_count: bool) -> bool {\n     ret alt d {\n           ast::def_local(_) | ast::def_arg(_, _) | ast::def_binding(_) |\n           ast::def_upvar(_, _, _) {"}, {"sha": "d31a8d65e1327654abdce7c4c688364c40492045", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -14,7 +14,7 @@ tag ast_node {\n \n type map = std::map::hashmap<node_id, ast_node>;\n \n-fn map_crate(c: &crate) -> map {\n+fn map_crate(c: crate) -> map {\n     // FIXME: This is using an adapter to convert the smallintmap\n     // interface to the hashmap interface. It would be better to just\n     // convert everything to use the smallintmap.\n@@ -29,7 +29,7 @@ fn map_crate(c: &crate) -> map {\n     ret map;\n }\n \n-fn map_item(map: &map, i: &@item, e: &(), v: &vt<()>) {\n+fn map_item(map: map, i: @item, e: (), v: vt<()>) {\n     map.insert(i.id, node_item(i));\n     alt i.node {\n       item_obj(_, _, ctor_id) { map.insert(ctor_id, node_obj_ctor(i)); }\n@@ -38,19 +38,19 @@ fn map_item(map: &map, i: &@item, e: &(), v: &vt<()>) {\n     visit::visit_item(i, e, v);\n }\n \n-fn map_native_item(map: &map, i: &@native_item, e: &(), v: &vt<()>) {\n+fn map_native_item(map: map, i: @native_item, e: (), v: vt<()>) {\n     map.insert(i.id, node_native_item(i));\n     visit::visit_native_item(i, e, v);\n }\n \n-fn map_expr(map: &map, ex: &@expr, e: &(), v: &vt<()>) {\n+fn map_expr(map: map, ex: @expr, e: (), v: vt<()>) {\n     map.insert(ex.id, node_expr(ex));\n     visit::visit_expr(ex, e, v);\n }\n \n fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n-    let key_idx = fn (key: &int) -> uint { key as uint };\n-    let idx_key = fn (idx: &uint) -> int { idx as int };\n+    let key_idx = fn (key: int) -> uint { key as uint };\n+    let idx_key = fn (idx: uint) -> int { idx as int };\n     ret new_smallintmap_adapter(key_idx, idx_key);\n }\n \n@@ -60,34 +60,33 @@ fn new_smallintmap_int_adapter<@V>() -> std::map::hashmap<int, V> {\n // interface.\n // FIXME: hashmap and smallintmap should support the same interface.\n fn new_smallintmap_adapter<@K,\n-                           @V>(key_idx: fn(&K) -> uint,\n-                               idx_key: fn(&uint) -> K) ->\n-   std::map::hashmap<K, V> {\n+                           @V>(key_idx: fn(K) -> uint, idx_key: fn(uint) -> K)\n+   -> std::map::hashmap<K, V> {\n \n     obj adapter<@K,\n                 @V>(map: smallintmap::smallintmap<V>,\n-                    key_idx: fn(&K) -> uint,\n-                    idx_key: fn(&uint) -> K) {\n+                    key_idx: fn(K) -> uint,\n+                    idx_key: fn(uint) -> K) {\n \n         fn size() -> uint { fail }\n \n-        fn insert(key: &K, value: &V) -> bool {\n+        fn insert(key: K, value: V) -> bool {\n             let exists = smallintmap::contains_key(map, key_idx(key));\n             smallintmap::insert(map, key_idx(key), value);\n             ret !exists;\n         }\n \n-        fn contains_key(key: &K) -> bool {\n+        fn contains_key(key: K) -> bool {\n             ret smallintmap::contains_key(map, key_idx(key));\n         }\n \n-        fn get(key: &K) -> V { ret smallintmap::get(map, key_idx(key)); }\n+        fn get(key: K) -> V { ret smallintmap::get(map, key_idx(key)); }\n \n-        fn find(key: &K) -> option::t<V> {\n+        fn find(key: K) -> option::t<V> {\n             ret smallintmap::find(map, key_idx(key));\n         }\n \n-        fn remove(_key: &K) -> option::t<V> { fail }\n+        fn remove(_key: K) -> option::t<V> { fail }\n \n         fn rehash() { fail }\n \n@@ -114,7 +113,7 @@ fn new_smallintmap_adapter<@K,\n     ret adapter(map, key_idx, idx_key);\n }\n \n-fn node_span(node: &ast_node) -> codemap::span {\n+fn node_span(node: ast_node) -> codemap::span {\n     alt node {\n       node_item(item) { item.span }\n       node_obj_ctor(item) { item.span }"}, {"sha": "03f83d0a7e7a700245c98b67b66d5c5d8b330a48", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,7 +3,7 @@ import syntax::ast_util::variant_def_ids;\n import syntax::ast_util::dummy_sp;\n import syntax::visit;\n \n-fn check_crate(tcx: &ty::ctxt, crate: &@crate) {\n+fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     let v =\n         @{visit_expr: bind check_expr(tcx, _, _, _),\n           visit_local: bind check_local(tcx, _, _, _)\n@@ -12,12 +12,12 @@ fn check_crate(tcx: &ty::ctxt, crate: &@crate) {\n     tcx.sess.abort_if_errors();\n }\n \n-fn check_expr(tcx: &ty::ctxt, ex: &@expr, s: &(), v: &visit::vt<()>) {\n+fn check_expr(tcx: ty::ctxt, ex: @expr, s: (), v: visit::vt<()>) {\n     visit::visit_expr(ex, s, v);\n     alt ex.node { expr_alt(_, arms) { check_arms(tcx, arms); } _ { } }\n }\n \n-fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n+fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n     let i = 0;\n     for arm: arm in arms {\n         for arm_pat: @pat in arm.pats {\n@@ -41,17 +41,17 @@ fn check_arms(tcx: &ty::ctxt, arms: &[arm]) {\n     }\n }\n \n-fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n-    fn patterns_supersede(tcx: &ty::ctxt, as: &[@pat], bs: &[@pat]) -> bool {\n+fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n+    fn patterns_supersede(tcx: ty::ctxt, as: [@pat], bs: [@pat]) -> bool {\n         let i = 0;\n         for a: @pat in as {\n             if !pattern_supersedes(tcx, a, bs[i]) { ret false; }\n             i += 1;\n         }\n         ret true;\n     }\n-    fn field_patterns_supersede(tcx: &ty::ctxt, fas: &[field_pat],\n-                                fbs: &[field_pat]) -> bool {\n+    fn field_patterns_supersede(tcx: ty::ctxt, fas: [field_pat],\n+                                fbs: [field_pat]) -> bool {\n         let wild = @{id: 0, node: pat_wild, span: dummy_sp()};\n         for fa: field_pat in fas {\n             let pb = wild;\n@@ -102,15 +102,15 @@ fn pattern_supersedes(tcx: &ty::ctxt, a: &@pat, b: &@pat) -> bool {\n     }\n }\n \n-fn check_local(tcx: &ty::ctxt, loc: &@local, s: &(), v: &visit::vt<()>) {\n+fn check_local(tcx: ty::ctxt, loc: @local, s: (), v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(tcx, loc.node.pat) {\n         tcx.sess.span_err(loc.node.pat.span,\n                           \"refutable pattern in local binding\");\n     }\n }\n \n-fn is_refutable(tcx: &ty::ctxt, pat: &@pat) -> bool {\n+fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n     alt pat.node {\n       pat_wild. | pat_bind(_) { ret false; }\n       pat_lit(_) { ret true; }"}, {"sha": "14641d556d1c0d2e221af7f222c4a5fb120f974d", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -29,15 +29,15 @@ type freevar_map = hashmap<ast::node_id, freevar_info>;\n // Since we want to be able to collect upvars in some arbitrary piece\n // of the AST, we take a walker function that we invoke with a visitor\n // in order to start the search.\n-fn collect_freevars(def_map: &resolve::def_map, walker: &fn(&visit::vt<int>))\n-   -> freevar_info {\n+fn collect_freevars(def_map: resolve::def_map, walker: fn(visit::vt<int>)) ->\n+   freevar_info {\n     let seen = new_int_hash();\n     let refs = @mutable [];\n \n-    fn ignore_item(_i: &@ast::item, _depth: &int, _v: &visit::vt<int>) { }\n+    fn ignore_item(_i: @ast::item, _depth: int, _v: visit::vt<int>) { }\n \n     let walk_expr =\n-        lambda (expr: &@ast::expr, depth: &int, v: &visit::vt<int>) {\n+        lambda (expr: @ast::expr, depth: int, v: visit::vt<int>) {\n             alt expr.node {\n               ast::expr_fn(f) {\n                 if f.proto == ast::proto_block ||\n@@ -81,28 +81,26 @@ fn collect_freevars(def_map: &resolve::def_map, walker: &fn(&visit::vt<int>))\n // efficient as it fully recomputes the free variables at every\n // node of interest rather than building up the free variables in\n // one pass. This could be improved upon if it turns out to matter.\n-fn annotate_freevars(def_map: &resolve::def_map, crate: &@ast::crate) ->\n+fn annotate_freevars(def_map: resolve::def_map, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = new_int_hash();\n \n     let walk_fn =\n-        lambda (f: &ast::_fn, tps: &[ast::ty_param], sp: &span,\n-                i: &ast::fn_ident, nid: ast::node_id) {\n+        lambda (f: ast::_fn, tps: [ast::ty_param], sp: span, i: ast::fn_ident,\n+                nid: ast::node_id) {\n             let start_walk =\n-                lambda (v: &visit::vt<int>) {\n+                lambda (v: visit::vt<int>) {\n                     v.visit_fn(f, tps, sp, i, nid, 1, v);\n                 };\n             let vars = collect_freevars(def_map, start_walk);\n             freevars.insert(nid, vars);\n         };\n     let walk_expr =\n-        lambda (expr: &@ast::expr) {\n+        lambda (expr: @ast::expr) {\n             alt expr.node {\n               ast::expr_for_each(local, _, body) {\n                 let start_walk =\n-                    lambda (v: &visit::vt<int>) {\n-                        v.visit_block(body, 1, v);\n-                    };\n+                    lambda (v: visit::vt<int>) { v.visit_block(body, 1, v); };\n                 let vars = collect_freevars(def_map, start_walk);\n                 freevars.insert(body.node.id, vars);\n               }\n@@ -118,13 +116,13 @@ fn annotate_freevars(def_map: &resolve::def_map, crate: &@ast::crate) ->\n     ret freevars;\n }\n \n-fn get_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> freevar_info {\n+fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     alt tcx.freevars.find(fid) {\n       none. { fail \"get_freevars: \" + int::str(fid) + \" has no freevars\"; }\n       some(d) { ret d; }\n     }\n }\n-fn has_freevars(tcx: &ty::ctxt, fid: ast::node_id) -> bool {\n+fn has_freevars(tcx: ty::ctxt, fid: ast::node_id) -> bool {\n     ret std::vec::len(*get_freevars(tcx, fid)) != 0u;\n }\n "}, {"sha": "2069f4096de84a91af451771eb77d6e418edce9f", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -21,7 +21,7 @@ type ctxt = @{mutable next_tydesc_num: uint};\n \n fn mk_ctxt() -> ctxt { ret @{mutable next_tydesc_num: 0u}; }\n \n-fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: &str) -> ValueRef {\n+fn add_global(ccx: @crate_ctxt, llval: ValueRef, name: str) -> ValueRef {\n     let llglobal =\n         str::as_buf(name,\n                     {|buf|\n@@ -32,7 +32,7 @@ fn add_global(ccx: &@crate_ctxt, llval: ValueRef, name: &str) -> ValueRef {\n     ret llglobal;\n }\n \n-fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n+fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let bcx = cx;\n     if !type_is_gc_relevant(bcx_tcx(cx), ty) ||\n            ty::type_has_dynamic_size(bcx_tcx(cx), ty) {\n@@ -102,7 +102,7 @@ fn add_gc_root(cx: &@block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     ret bcx;\n }\n \n-fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n+fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n       ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int. | ty::ty_float. |\n       ty::ty_uint. | ty::ty_machine(_) | ty::ty_char. | ty::ty_str. |\n@@ -113,6 +113,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_rec(fields) {\n         for f in fields { if type_is_gc_relevant(cx, f.mt.ty) { ret true; } }\n         ret false;\n@@ -124,6 +125,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_tag(did, tps) {\n         let variants = ty::tag_variants(cx, did);\n         for variant in variants {\n@@ -137,13 +139,15 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_vec(tm) {\n         ret type_is_gc_relevant(cx, tm.ty);\n       }\n       ty::ty_constr(sub, _) { ret type_is_gc_relevant(cx, sub); }\n \n \n \n+\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_fn(_, _, _, _, _) |\n       ty::ty_native_fn(_, _, _) | ty::ty_obj(_) | ty::ty_param(_, _) |\n       ty::ty_res(_, _, _) {\n@@ -152,6 +156,7 @@ fn type_is_gc_relevant(cx: &ty::ctxt, ty: ty::t) -> bool {\n \n \n \n+\n       ty::ty_var(_) {\n         fail \"ty_var in type_is_gc_relevant\";\n       }"}, {"sha": "21053f83f8fe669feafbfe93d41cadb7645d6b65", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -104,15 +104,15 @@ fn kind_to_str(k: kind) -> str {\n     }\n }\n \n-fn type_and_kind(tcx: &ty::ctxt, e: &@ast::expr) ->\n+fn type_and_kind(tcx: ty::ctxt, e: @ast::expr) ->\n    {ty: ty::t, kind: ast::kind} {\n     let t = ty::expr_ty(tcx, e);\n     let k = ty::type_kind(tcx, t);\n     {ty: t, kind: k}\n }\n \n-fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n-                  descr: &str) {\n+fn need_expr_kind(tcx: ty::ctxt, e: @ast::expr, k_need: ast::kind,\n+                  descr: str) {\n     let tk = type_and_kind(tcx, e);\n     log #fmt[\"for %s: want %s type, got %s type %s\", descr,\n              kind_to_str(k_need), kind_to_str(tk.kind),\n@@ -127,13 +127,12 @@ fn need_expr_kind(tcx: &ty::ctxt, e: &@ast::expr, k_need: ast::kind,\n     }\n }\n \n-fn need_shared_lhs_rhs(tcx: &ty::ctxt, a: &@ast::expr, b: &@ast::expr,\n-                       op: &str) {\n+fn need_shared_lhs_rhs(tcx: ty::ctxt, a: @ast::expr, b: @ast::expr, op: str) {\n     need_expr_kind(tcx, a, ast::kind_shared, op + \" lhs\");\n     need_expr_kind(tcx, b, ast::kind_shared, op + \" rhs\");\n }\n \n-fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n+fn check_expr(tcx: ty::ctxt, e: @ast::expr) {\n     alt e.node {\n       ast::expr_move(a, b) { need_shared_lhs_rhs(tcx, a, b, \"<-\"); }\n       ast::expr_assign(a, b) { need_shared_lhs_rhs(tcx, a, b, \"=\"); }\n@@ -182,7 +181,7 @@ fn check_expr(tcx: &ty::ctxt, e: &@ast::expr) {\n     }\n }\n \n-fn check_crate(tcx: &ty::ctxt, crate: &@ast::crate) {\n+fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     let visit =\n         visit::mk_simple_visitor(@{visit_expr: bind check_expr(tcx, _)\n                                       with *visit::default_simple_visitor()});"}, {"sha": "eae2d1b15412f9ad07c97d9407ad658681a4ca89", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -12,9 +12,9 @@ type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n // vec of dereferences that were used on this root. Note that, in this vec,\n // the inner derefs come in front, so foo.bar[1] becomes rec(ex=foo,\n // ds=[index,field])\n-fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool) ->\n+fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n    {ex: @expr, ds: @[deref]} {\n-    fn maybe_auto_unbox(tcx: &ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n+    fn maybe_auto_unbox(tcx: ty::ctxt, t: ty::t) -> {t: ty::t, ds: [deref]} {\n         let ds = [];\n         while true {\n             alt ty::struct(tcx, t) {\n@@ -68,14 +68,13 @@ fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool) ->\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n             alt ty::struct(tcx, auto_unbox.t) {\n               ty::ty_vec(mt) {\n-                ds += [@{mut: mt.mut != imm,\n-                         kind: index,\n-                         outer_t: auto_unbox.t}];\n+                ds +=\n+                    [@{mut: mt.mut != imm,\n+                       kind: index,\n+                       outer_t: auto_unbox.t}];\n               }\n               ty::ty_str. {\n-                ds += [@{mut: false,\n-                         kind: index,\n-                         outer_t: auto_unbox.t}];\n+                ds += [@{mut: false, kind: index, outer_t: auto_unbox.t}];\n               }\n             }\n             ds += auto_unbox.ds;\n@@ -106,12 +105,12 @@ fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool) ->\n     ret {ex: ex, ds: @ds};\n }\n \n-fn mut_field(ds: &@[deref]) -> bool {\n+fn mut_field(ds: @[deref]) -> bool {\n     for d: deref in *ds { if d.mut { ret true; } }\n     ret false;\n }\n \n-fn inner_mut(ds: &@[deref]) -> option::t<ty::t> {\n+fn inner_mut(ds: @[deref]) -> option::t<ty::t> {\n     for d: deref in *ds { if d.mut { ret some(d.outer_t); } }\n     ret none;\n }\n@@ -121,7 +120,7 @@ fn inner_mut(ds: &@[deref]) -> option::t<ty::t> {\n type mut_map = std::map::hashmap<node_id, ()>;\n type ctx = {tcx: ty::ctxt, mut_map: mut_map};\n \n-fn check_crate(tcx: ty::ctxt, crate: &@crate) -> mut_map {\n+fn check_crate(tcx: ty::ctxt, crate: @crate) -> mut_map {\n     let cx = @{tcx: tcx, mut_map: std::map::new_int_hash()};\n     let v =\n         @{visit_expr: bind visit_expr(cx, _, _, _),\n@@ -133,7 +132,7 @@ fn check_crate(tcx: ty::ctxt, crate: &@crate) -> mut_map {\n \n tag msg { msg_assign; msg_move_out; msg_mut_alias; }\n \n-fn mk_err(cx: &@ctx, span: &syntax::codemap::span, msg: msg, name: &str) {\n+fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span,\n                          alt msg {\n                            msg_assign. { \"assigning to \" + name }\n@@ -144,7 +143,7 @@ fn mk_err(cx: &@ctx, span: &syntax::codemap::span, msg: msg, name: &str) {\n                          });\n }\n \n-fn visit_decl(cx: &@ctx, d: &@decl, e: &(), v: &visit::vt<()>) {\n+fn visit_decl(cx: @ctx, d: @decl, e: (), v: visit::vt<()>) {\n     visit::visit_decl(d, e, v);\n     alt d.node {\n       decl_local(locs) {\n@@ -161,7 +160,7 @@ fn visit_decl(cx: &@ctx, d: &@decl, e: &(), v: &visit::vt<()>) {\n     }\n }\n \n-fn visit_expr(cx: &@ctx, ex: &@expr, e: &(), v: &visit::vt<()>) {\n+fn visit_expr(cx: @ctx, ex: @expr, e: (), v: visit::vt<()>) {\n     alt ex.node {\n       expr_call(f, args) { check_call(cx, f, args); }\n       expr_swap(lhs, rhs) {\n@@ -180,7 +179,7 @@ fn visit_expr(cx: &@ctx, ex: &@expr, e: &(), v: &visit::vt<()>) {\n     visit::visit_expr(ex, e, v);\n }\n \n-fn check_lval(cx: &@ctx, dest: &@expr, msg: msg) {\n+fn check_lval(cx: @ctx, dest: @expr, msg: msg) {\n     alt dest.node {\n       expr_path(p) {\n         let def = cx.tcx.def_map.get(dest.id);\n@@ -193,9 +192,7 @@ fn check_lval(cx: &@ctx, dest: &@expr, msg: msg) {\n       _ {\n         let root = expr_root(cx.tcx, dest, false);\n         if vec::len(*root.ds) == 0u {\n-            if msg == msg_assign {\n-                mk_err(cx, dest.span, msg, \"non-lvalue\");\n-            }\n+            if msg == msg_assign { mk_err(cx, dest.span, msg, \"non-lvalue\"); }\n         } else if !root.ds[0].mut {\n             let name =\n                 alt root.ds[0].kind {\n@@ -209,7 +206,7 @@ fn check_lval(cx: &@ctx, dest: &@expr, msg: msg) {\n     }\n }\n \n-fn check_move_rhs(cx: &@ctx, src: &@expr) {\n+fn check_move_rhs(cx: @ctx, src: @expr) {\n     alt src.node {\n       expr_path(p) {\n         alt cx.tcx.def_map.get(src.id) {\n@@ -231,20 +228,18 @@ fn check_move_rhs(cx: &@ctx, src: &@expr) {\n     }\n }\n \n-fn check_call(cx: &@ctx, f: &@expr, args: &[@expr]) {\n+fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     let arg_ts =\n         ty::ty_fn_args(cx.tcx,\n                        ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f)));\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n-        if arg_t.mode != by_ref {\n-            check_lval(cx, args[i], msg_mut_alias);\n-        }\n+        if arg_t.mode != by_ref { check_lval(cx, args[i], msg_mut_alias); }\n         i += 1u;\n     }\n }\n \n-fn is_immutable_def(def: &def) -> option::t<str> {\n+fn is_immutable_def(def: def) -> option::t<str> {\n     alt def {\n       def_fn(_, _) | def_mod(_) | def_native_mod(_) | def_const(_) |\n       def_use(_) {"}, {"sha": "b4a1b0bbcfb55cf02ab3779f74de2ecb9a2797c7", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 98, "deletions": 97, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -78,15 +78,15 @@ type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n \n fn new_ext_hash() -> ext_hash {\n     type key = {did: def_id, ident: str, ns: namespace};\n-    fn hash(v: &key) -> uint {\n+    fn hash(v: key) -> uint {\n         ret str::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n                   ns_value. { 1u }\n                   ns_type. { 2u }\n                   ns_module. { 3u }\n                 };\n     }\n-    fn eq(v1: &key, v2: &key) -> bool {\n+    fn eq(v1: key, v2: key) -> bool {\n         ret util::common::def_eq(v1.did, v2.did) &&\n                 str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n@@ -137,7 +137,7 @@ tag dir { inside; outside; }\n \n tag namespace { ns_value; ns_type; ns_module; }\n \n-fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n+fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, ext_map: ext_map} {\n     let e =\n         @{cstore: sess.get_cstore(),\n@@ -160,7 +160,7 @@ fn resolve_crate(sess: session, amap: &ast_map::map, crate: @ast::crate) ->\n \n // Locate all modules and imports and index them, so that the next passes can\n // resolve through them.\n-fn map_crate(e: &@env, c: &@ast::crate) {\n+fn map_crate(e: @env, c: @ast::crate) {\n     // First, find all the modules, and index the names that they contain\n \n     let v_map_mod =\n@@ -175,7 +175,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n                        index: index_mod(c.node.module),\n                        mutable glob_imports: [],\n                        glob_imported_names: new_str_hash::<import_state>()});\n-    fn index_vi(e: @env, i: &@ast::view_item, sc: &scopes, _v: &vt<scopes>) {\n+    fn index_vi(e: @env, i: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n         alt i.node {\n           ast::view_item_import(name, ids, id) {\n             e.imports.insert(id, todo(id, name, ids, i.span, sc));\n@@ -191,7 +191,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n           _ { }\n         }\n     }\n-    fn index_i(e: @env, i: &@ast::item, sc: &scopes, v: &vt<scopes>) {\n+    fn index_i(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(i, sc, v);\n         alt i.node {\n           ast::item_mod(md) {\n@@ -221,8 +221,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n              with *visit::default_visitor::<scopes>()};\n     visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n-    fn link_glob(e: @env, vi: &@ast::view_item, sc: &scopes,\n-                 _v: &vt<scopes>) {\n+    fn link_glob(e: @env, vi: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n         fn find_mod(e: @env, sc: scopes) -> @indexed_mod {\n             alt sc {\n               cons(scope_item(i), tl) {\n@@ -243,6 +242,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n \n \n \n+\n           //if it really is a glob import, that is\n           ast::view_item_import_glob(path, _) {\n             let imp = follow_import(*e, sc, path, vi.span);\n@@ -256,7 +256,7 @@ fn map_crate(e: &@env, c: &@ast::crate) {\n     }\n }\n \n-fn resolve_imports(e: &env) {\n+fn resolve_imports(e: env) {\n     for each it: @{key: ast::node_id, val: import_state} in e.imports.items()\n              {\n         alt it.val {\n@@ -269,7 +269,7 @@ fn resolve_imports(e: &env) {\n     e.sess.abort_if_errors();\n }\n \n-fn resolve_names(e: &@env, c: &@ast::crate) {\n+fn resolve_names(e: @env, c: @ast::crate) {\n     let v =\n         @{visit_native_item: visit_native_item_with_scope,\n           visit_item: visit_item_with_scope,\n@@ -285,7 +285,7 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n     e.sess.abort_if_errors();\n \n-    fn walk_expr(e: @env, exp: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n+    fn walk_expr(e: @env, exp: @ast::expr, sc: scopes, v: vt<scopes>) {\n         visit_expr_with_scope(exp, sc, v);\n         alt exp.node {\n           ast::expr_path(p) {\n@@ -296,7 +296,7 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n           _ { }\n         }\n     }\n-    fn walk_ty(e: @env, t: &@ast::ty, sc: &scopes, v: &vt<scopes>) {\n+    fn walk_ty(e: @env, t: @ast::ty, sc: scopes, v: vt<scopes>) {\n         visit::visit_ty(t, sc, v);\n         alt t.node {\n           ast::ty_path(p, id) {\n@@ -306,11 +306,11 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n           _ { }\n         }\n     }\n-    fn walk_constr(e: @env, p: &ast::path, sp: &span, id: node_id,\n-                   sc: &scopes, _v: &vt<scopes>) {\n+    fn walk_constr(e: @env, p: ast::path, sp: span, id: node_id, sc: scopes,\n+                   _v: vt<scopes>) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p.node, ns_value));\n     }\n-    fn walk_pat(e: &@env, pat: &@ast::pat, sc: &scopes, v: &vt<scopes>) {\n+    fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_tag(p, _) {\n@@ -337,18 +337,18 @@ fn resolve_names(e: &@env, c: &@ast::crate) {\n \n \n // Visit helper functions\n-fn visit_item_with_scope(i: &@ast::item, sc: &scopes, v: &vt<scopes>) {\n+fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n     visit::visit_item(i, cons(scope_item(i), @sc), v);\n }\n \n-fn visit_native_item_with_scope(ni: &@ast::native_item, sc: &scopes,\n-                                v: &vt<scopes>) {\n+fn visit_native_item_with_scope(ni: @ast::native_item, sc: scopes,\n+                                v: vt<scopes>) {\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n-                       sp: &span, name: &fn_ident, id: node_id, sc: &scopes,\n-                       v: &vt<scopes>) {\n+fn visit_fn_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param], sp: span,\n+                       name: fn_ident, id: node_id, sc: scopes,\n+                       v: vt<scopes>) {\n     // is this a main fn declaration?\n     alt name {\n       some(nm) {\n@@ -369,7 +369,7 @@ fn visit_fn_with_scope(e: &@env, f: &ast::_fn, tp: &[ast::ty_param],\n                     cons(scope_fn(f.decl, f.proto, tp), @sc), v);\n }\n \n-fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt<scopes>) {\n+fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n     let pos = @mutable 0u, loc = @mutable 0u;\n     let block_sc = cons(scope_block(b, pos, loc), @sc);\n     for stmt in b.node.stmts {\n@@ -380,7 +380,7 @@ fn visit_block_with_scope(b: &ast::blk, sc: &scopes, v: &vt<scopes>) {\n     visit::visit_expr_opt(b.node.expr, block_sc, v);\n }\n \n-fn visit_decl_with_scope(d: &@decl, sc: &scopes, v: &vt<scopes>) {\n+fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n     let loc_pos =\n         alt list::car(sc) {\n           scope_block(_, _, pos) { pos }\n@@ -394,14 +394,14 @@ fn visit_decl_with_scope(d: &@decl, sc: &scopes, v: &vt<scopes>) {\n     }\n }\n \n-fn visit_arm_with_scope(a: &ast::arm, sc: &scopes, v: &vt<scopes>) {\n+fn visit_arm_with_scope(a: ast::arm, sc: scopes, v: vt<scopes>) {\n     for p: @pat in a.pats { v.visit_pat(p, sc, v); }\n     let sc_inner = cons(scope_arm(a), @sc);\n     visit::visit_expr_opt(a.guard, sc_inner, v);\n     v.visit_block(a.body, sc_inner, v);\n }\n \n-fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n+fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n     alt x.node {\n       ast::expr_for(decl, coll, blk) | ast::expr_for_each(decl, coll, blk) {\n         let f_e = alt x.node { expr_for_each(_, _, _) { true } _ { false } };\n@@ -414,7 +414,7 @@ fn visit_expr_with_scope(x: &@ast::expr, sc: &scopes, v: &vt<scopes>) {\n     }\n }\n \n-fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n+fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n    option::t<def> {\n     let path_len = vec::len(path);\n     let dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n@@ -439,7 +439,7 @@ fn follow_import(e: &env, sc: &scopes, path: &[ident], sp: &span) ->\n     } else { ret none; }\n }\n \n-fn resolve_constr(e: @env, c: &@ast::constr, sc: &scopes, _v: &vt<scopes>) {\n+fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n     let new_def =\n         lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_value);\n     if option::is_some(new_def) {\n@@ -457,8 +457,8 @@ fn resolve_constr(e: @env, c: &@ast::constr, sc: &scopes, _v: &vt<scopes>) {\n }\n \n // Import resolution\n-fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n-                  ids: &[ast::ident], sp: &codemap::span, sc_in: &scopes) {\n+fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n+                  ids: [ast::ident], sp: codemap::span, sc_in: scopes) {\n     e.imports.insert(defid.node, resolving(sp));\n     let n_idents = vec::len(ids);\n     let end_id = ids[n_idents - 1u];\n@@ -507,9 +507,9 @@ fn resolve_import(e: &env, defid: ast::def_id, name: &ast::ident,\n             }\n         }\n     }\n-    fn register(e: &env, defid: def_id, sp: &span, name: &ident, sc: &scopes,\n-                val: &option::t<def>, typ: &option::t<def>,\n-                md: &option::t<def>) {\n+    fn register(e: env, defid: def_id, sp: span, name: ident, sc: scopes,\n+                val: option::t<def>, typ: option::t<def>,\n+                md: option::t<def>) {\n         if is_none(val) && is_none(typ) && is_none(md) {\n             unresolved_err(e, sc, sp, name, \"import\");\n         } else { e.imports.insert(defid.node, resolved(val, typ, md)); }\n@@ -539,7 +539,7 @@ fn ns_name(ns: namespace) -> str {\n     }\n }\n \n-fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n+fn unresolved_err(e: env, sc: scopes, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> scope {\n         while true {\n             alt sc {\n@@ -564,16 +564,16 @@ fn unresolved_err(e: &env, sc: &scopes, sp: &span, name: &ident, kind: &str) {\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n-fn unresolved_fatal(e: &env, sp: &span, id: &ident, kind: &str) -> ! {\n+fn unresolved_fatal(e: env, sp: span, id: ident, kind: str) -> ! {\n     e.sess.span_fatal(sp, mk_unresolved_msg(id, kind));\n }\n \n-fn mk_unresolved_msg(id: &ident, kind: &str) -> str {\n+fn mk_unresolved_msg(id: ident, kind: str) -> str {\n     ret #fmt[\"unresolved %s: %s\", kind, id];\n }\n \n // Lookup helpers\n-fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n+fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n                       ns: namespace) -> option::t<def> {\n     let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n@@ -597,15 +597,15 @@ fn lookup_path_strict(e: &env, sc: &scopes, sp: &span, pth: &ast::path_,\n     ret dcur;\n }\n \n-fn lookup_in_scope_strict(e: &env, sc: scopes, sp: &span, name: &ident,\n+fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n                           ns: namespace) -> option::t<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n       none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n \n-fn scope_is_fn(sc: &scope) -> bool {\n+fn scope_is_fn(sc: scope) -> bool {\n     ret alt sc {\n           scope_fn(_, ast::proto_iter., _) | scope_fn(_, ast::proto_fn., _) |\n           scope_native_item(_) {\n@@ -615,15 +615,15 @@ fn scope_is_fn(sc: &scope) -> bool {\n         };\n }\n \n-fn scope_closes(sc: &scope) -> option::t<bool> {\n+fn scope_closes(sc: scope) -> option::t<bool> {\n     alt sc {\n       scope_fn(_, ast::proto_block., _) | scope_loop(_, true) { some(true) }\n       scope_fn(_, ast::proto_closure., _) { some(false) }\n       _ { none }\n     }\n }\n \n-fn def_is_local(d: &def) -> bool {\n+fn def_is_local(d: def) -> bool {\n     ret alt d {\n           ast::def_arg(_, _) | ast::def_local(_) | ast::def_binding(_) |\n           ast::def_upvar(_, _, _) {\n@@ -633,17 +633,17 @@ fn def_is_local(d: &def) -> bool {\n         };\n }\n \n-fn def_is_obj_field(d: &def) -> bool {\n+fn def_is_obj_field(d: def) -> bool {\n     ret alt d { ast::def_obj_field(_, _) { true } _ { false } };\n }\n \n-fn def_is_ty_arg(d: &def) -> bool {\n+fn def_is_ty_arg(d: def) -> bool {\n     ret alt d { ast::def_ty_arg(_, _) { true } _ { false } };\n }\n \n-fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n-                   ns: namespace) -> option::t<def> {\n-    fn in_scope(e: &env, sp: &span, name: &ident, s: &scope, ns: namespace) ->\n+fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n+   -> option::t<def> {\n+    fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n        option::t<def> {\n         alt s {\n           scope_crate. {\n@@ -749,7 +749,7 @@ fn lookup_in_scope(e: &env, sc: scopes, sp: &span, name: &ident,\n \n }\n \n-fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n+fn lookup_in_ty_params(name: ident, ty_params: [ast::ty_param]) ->\n    option::t<def> {\n     let i = 0u;\n     for tp: ast::ty_param in ty_params {\n@@ -759,7 +759,7 @@ fn lookup_in_ty_params(name: &ident, ty_params: &[ast::ty_param]) ->\n     ret none::<def>;\n }\n \n-fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n+fn lookup_in_pat(name: ident, pat: @ast::pat) -> option::t<def_id> {\n     let found = none;\n     for each bound in ast_util::pat_bindings(pat) {\n         let p_name = alt bound.node { ast::pat_bind(n) { n } };\n@@ -768,9 +768,8 @@ fn lookup_in_pat(name: &ident, pat: &@ast::pat) -> option::t<def_id> {\n     ret found;\n }\n \n-fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n-                ty_params: &[ast::ty_param], ns: namespace) ->\n-   option::t<def> {\n+fn lookup_in_fn(name: ident, decl: ast::fn_decl, ty_params: [ast::ty_param],\n+                ns: namespace) -> option::t<def> {\n     alt ns {\n       ns_value. {\n         for a: ast::arg in decl.inputs {\n@@ -785,7 +784,7 @@ fn lookup_in_fn(name: &ident, decl: &ast::fn_decl,\n     }\n }\n \n-fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n+fn lookup_in_obj(name: ident, ob: ast::_obj, ty_params: [ast::ty_param],\n                  ns: namespace) -> option::t<def> {\n     alt ns {\n       ns_value. {\n@@ -801,7 +800,7 @@ fn lookup_in_obj(name: &ident, ob: &ast::_obj, ty_params: &[ast::ty_param],\n     }\n }\n \n-fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n+fn lookup_in_block(name: ident, b: ast::blk_, pos: uint, loc_pos: uint,\n                    ns: namespace) -> option::t<def> {\n     let i = vec::len(b.stmts);\n     while i > 0u {\n@@ -858,7 +857,7 @@ fn lookup_in_block(name: &ident, b: &ast::blk_, pos: uint, loc_pos: uint,\n     ret none::<def>;\n }\n \n-fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n+fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n     alt i.node {\n       ast::item_const(_, _) {\n         if ns == ns_value { ret some(ast::def_const(local_def(i.id))); }\n@@ -903,15 +902,15 @@ fn found_def_item(i: &@ast::item, ns: namespace) -> option::t<def> {\n     ret none::<def>;\n }\n \n-fn lookup_in_mod_strict(e: &env, sc: &scopes, m: def, sp: &span, name: &ident,\n+fn lookup_in_mod_strict(e: env, sc: scopes, m: def, sp: span, name: ident,\n                         ns: namespace, dr: dir) -> option::t<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n       none. { unresolved_err(e, sc, sp, name, ns_name(ns)); ret none; }\n       some(d) { ret some(d); }\n     }\n }\n \n-fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n+fn lookup_in_mod(e: env, m: def, sp: span, name: ident, ns: namespace,\n                  dr: dir) -> option::t<def> {\n     let defid = ast_util::def_id_of_def(m);\n     if defid.crate != ast::local_crate {\n@@ -938,7 +937,7 @@ fn lookup_in_mod(e: &env, m: &def, sp: &span, name: &ident, ns: namespace,\n     }\n }\n \n-fn found_view_item(e: &env, vi: @ast::view_item) -> option::t<def> {\n+fn found_view_item(e: env, vi: @ast::view_item) -> option::t<def> {\n     alt vi.node {\n       ast::view_item_use(_, _, id) {\n         let cnum = cstore::get_use_stmt_cnum(e.cstore, id);\n@@ -947,7 +946,7 @@ fn found_view_item(e: &env, vi: @ast::view_item) -> option::t<def> {\n     }\n }\n \n-fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t<def> {\n+fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n     alt e.imports.get(defid.node) {\n       todo(node_id, name, path, span, scopes) {\n         resolve_import(e, local_def(node_id), name, path, span, scopes);\n@@ -960,12 +959,12 @@ fn lookup_import(e: &env, defid: def_id, ns: namespace) -> option::t<def> {\n     }\n }\n \n-fn lookup_in_local_native_mod(e: &env, node_id: node_id, sp: &span,\n-                              id: &ident, ns: namespace) -> option::t<def> {\n+fn lookup_in_local_native_mod(e: env, node_id: node_id, sp: span, id: ident,\n+                              ns: namespace) -> option::t<def> {\n     ret lookup_in_local_mod(e, node_id, sp, id, ns, inside);\n }\n \n-fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n+fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n                        ns: namespace, dr: dir) -> option::t<def> {\n     let info = e.mod_map.get(node_id);\n     if dr == outside && !ast_util::is_exported(id, option::get(info.m)) {\n@@ -993,14 +992,13 @@ fn lookup_in_local_mod(e: &env, node_id: node_id, sp: &span, id: &ident,\n     ret lookup_glob_in_mod(e, info, sp, id, ns, outside);\n }\n \n-fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n+fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n                       wanted_ns: namespace, dr: dir) -> option::t<def> {\n-    fn per_ns(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n-              ns: namespace, dr: dir) -> option::t<def> {\n+    fn per_ns(e: env, info: @indexed_mod, sp: span, id: ident, ns: namespace,\n+              dr: dir) -> option::t<def> {\n \n-        fn lookup_in_mod_(e: &env, def: &glob_imp_def, sp: &span,\n-                          name: &ident, ns: namespace, dr: dir) ->\n-           option::t<glob_imp_def> {\n+        fn lookup_in_mod_(e: env, def: glob_imp_def, sp: span, name: ident,\n+                          ns: namespace, dr: dir) -> option::t<glob_imp_def> {\n             alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n               option::some(d) { option::some({def: d, item: def.item}) }\n               option::none. { option::none }\n@@ -1050,7 +1048,7 @@ fn lookup_glob_in_mod(e: &env, info: @indexed_mod, sp: &span, id: &ident,\n     }\n }\n \n-fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n+fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n    option::t<def> {\n     alt mie {\n       mie_view_item(view_item) {\n@@ -1089,15 +1087,15 @@ fn lookup_in_mie(e: &env, mie: &mod_index_entry, ns: namespace) ->\n \n \n // Module indexing\n-fn add_to_index(index: &hashmap<ident, list<mod_index_entry>>, id: &ident,\n-                ent: &mod_index_entry) {\n+fn add_to_index(index: hashmap<ident, list<mod_index_entry>>, id: ident,\n+                ent: mod_index_entry) {\n     alt index.find(id) {\n       none. { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n       some(prev) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n \n-fn index_mod(md: &ast::_mod) -> mod_index {\n+fn index_mod(md: ast::_mod) -> mod_index {\n     let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n@@ -1107,12 +1105,14 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n \n \n \n+\n           ast::view_item_import(ident, _, id) {\n             add_to_index(index, ident, mie_import_ident(id, it.span));\n           }\n \n \n \n+\n           ast::view_item_import_from(_, idents, _) {\n             for ident in idents {\n                 add_to_index(index, ident.node.name,\n@@ -1122,6 +1122,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n \n \n \n+\n           //globbed imports have to be resolved lazily.\n           ast::view_item_import_glob(_, _) | ast::view_item_export(_, _) {\n           }\n@@ -1148,7 +1149,7 @@ fn index_mod(md: &ast::_mod) -> mod_index {\n     ret index;\n }\n \n-fn index_nmod(md: &ast::native_mod) -> mod_index {\n+fn index_nmod(md: ast::native_mod) -> mod_index {\n     let index = new_str_hash::<list<mod_index_entry>>();\n     for it: @ast::view_item in md.view_items {\n         alt it.node {\n@@ -1194,7 +1195,7 @@ fn ns_for_def(d: def) -> namespace {\n         };\n }\n \n-fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n+fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n    option::t<def> {\n     for d: def in csearch::lookup_defs(e.sess.get_cstore(), cnum, ids) {\n         e.ext_map.insert(ast_util::def_id_of_def(d), ids);\n@@ -1205,7 +1206,7 @@ fn lookup_external(e: &env, cnum: int, ids: &[ident], ns: namespace) ->\n \n \n // Collision detection\n-fn check_for_collisions(e: &@env, c: &ast::crate) {\n+fn check_for_collisions(e: @env, c: ast::crate) {\n     // Module indices make checking those relatively simple -- just check each\n     // name for multiple entities in the same namespace.\n     for each m: @{key: ast::node_id, val: @indexed_mod} in e.mod_map.items() {\n@@ -1224,11 +1225,11 @@ fn check_for_collisions(e: &@env, c: &ast::crate) {\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n-fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n+fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n     let saw_mod = false;\n     let saw_type = false;\n     let saw_value = false;\n-    fn dup(e: &env, sp: &span, word: &str, name: &ident) {\n+    fn dup(e: env, sp: span, word: str, name: ident) {\n         e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n     while true {\n@@ -1256,7 +1257,7 @@ fn check_mod_name(e: &env, name: &ident, entries: list<mod_index_entry>) {\n     }\n }\n \n-fn mie_span(mie: &mod_index_entry) -> span {\n+fn mie_span(mie: mod_index_entry) -> span {\n     ret alt mie {\n           mie_view_item(item) { item.span }\n           mie_import_ident(_, span) { span }\n@@ -1266,8 +1267,8 @@ fn mie_span(mie: &mod_index_entry) -> span {\n         };\n }\n \n-fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n-    fn typaram_names(tps: &[ast::ty_param]) -> [ident] {\n+fn check_item(e: @env, i: @ast::item, x: (), v: vt<()>) {\n+    fn typaram_names(tps: [ast::ty_param]) -> [ident] {\n         let x: [ast::ident] = [];\n         for tp: ast::ty_param in tps { x += [tp.ident] }\n         ret x;\n@@ -1280,7 +1281,7 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n                       \"type parameter\");\n       }\n       ast::item_obj(ob, ty_params, _) {\n-        fn field_name(field: &ast::obj_field) -> ident { ret field.ident; }\n+        fn field_name(field: ast::obj_field) -> ident { ret field.ident; }\n         ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n         for m: @ast::method in ob.methods {\n             check_fn(*e, m.span, m.node.meth);\n@@ -1296,14 +1297,14 @@ fn check_item(e: &@env, i: &@ast::item, x: &(), v: &vt<()>) {\n     }\n }\n \n-fn check_pat(ch: checker, p: &@ast::pat) {\n+fn check_pat(ch: checker, p: @ast::pat) {\n     for each p in ast_util::pat_bindings(p) {\n         let ident = alt p.node { pat_bind(n) { n } };\n         add_name(ch, p.span, ident);\n     }\n }\n \n-fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n+fn check_arm(e: @env, a: ast::arm, x: (), v: vt<()>) {\n     visit::visit_arm(a, x, v);\n     let ch0 = checker(*e, \"binding\");\n     check_pat(ch0, a.pats[0]);\n@@ -1333,7 +1334,7 @@ fn check_arm(e: &@env, a: &ast::arm, x: &(), v: &vt<()>) {\n     }\n }\n \n-fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n+fn check_block(e: @env, b: ast::blk, x: (), v: vt<()>) {\n     visit::visit_block(b, x, v);\n     let values = checker(*e, \"value\");\n     let types = checker(*e, \"type\");\n@@ -1381,26 +1382,26 @@ fn check_block(e: &@env, b: &ast::blk, x: &(), v: &vt<()>) {\n     }\n }\n \n-fn check_fn(e: &env, sp: &span, f: &ast::_fn) {\n-    fn arg_name(a: &ast::arg) -> ident { ret a.ident; }\n+fn check_fn(e: env, sp: span, f: ast::_fn) {\n+    fn arg_name(a: ast::arg) -> ident { ret a.ident; }\n     ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n }\n \n-fn check_expr(e: &@env, ex: &@ast::expr, x: &(), v: &vt<()>) {\n+fn check_expr(e: @env, ex: @ast::expr, x: (), v: vt<()>) {\n     alt ex.node {\n       ast::expr_rec(fields, _) {\n-        fn field_name(f: &ast::field) -> ident { ret f.node.ident; }\n+        fn field_name(f: ast::field) -> ident { ret f.node.ident; }\n         ensure_unique(*e, ex.span, fields, field_name, \"field\");\n       }\n       _ { }\n     }\n     visit::visit_expr(ex, x, v);\n }\n \n-fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt<()>) {\n+fn check_ty(e: @env, ty: @ast::ty, x: (), v: vt<()>) {\n     alt ty.node {\n       ast::ty_rec(fields) {\n-        fn field_name(f: &ast::ty_field) -> ident { ret f.node.ident; }\n+        fn field_name(f: ast::ty_field) -> ident { ret f.node.ident; }\n         ensure_unique(*e, ty.span, fields, field_name, \"field\");\n       }\n       _ { }\n@@ -1410,34 +1411,34 @@ fn check_ty(e: &@env, ty: &@ast::ty, x: &(), v: &vt<()>) {\n \n type checker = @{mutable seen: [ident], kind: str, sess: session};\n \n-fn checker(e: &env, kind: &str) -> checker {\n+fn checker(e: env, kind: str) -> checker {\n     let seen: [ident] = [];\n     ret @{mutable seen: seen, kind: kind, sess: e.sess};\n }\n \n-fn check_name(ch: &checker, sp: &span, name: &ident) {\n+fn check_name(ch: checker, sp: span, name: ident) {\n     for s: ident in ch.seen {\n         if str::eq(s, name) {\n             ch.sess.span_fatal(sp, \"duplicate \" + ch.kind + \" name: \" + name);\n         }\n     }\n }\n-fn add_name(ch: &checker, sp: &span, name: &ident) {\n+fn add_name(ch: checker, sp: span, name: ident) {\n     check_name(ch, sp, name);\n     ch.seen += [name];\n }\n \n-fn ident_id(i: &ident) -> ident { ret i; }\n+fn ident_id(i: ident) -> ident { ret i; }\n \n-fn ensure_unique<T>(e: &env, sp: &span, elts: &[T], id: fn(&T) -> ident,\n-                    kind: &str) {\n+fn ensure_unique<T>(e: env, sp: span, elts: [T], id: fn(T) -> ident,\n+                    kind: str) {\n     let ch = checker(e, kind);\n     for elt: T in elts { add_name(ch, sp, id(elt)); }\n }\n \n-fn check_bad_exports(e: &@env) {\n-    fn lookup_glob_any(e: &env, info: &@indexed_mod, sp: &span, ident: &ident)\n-       -> bool {\n+fn check_bad_exports(e: @env) {\n+    fn lookup_glob_any(e: env, info: @indexed_mod, sp: span, ident: ident) ->\n+       bool {\n         ret !option::is_none(lookup_glob_in_mod(e, info, sp, ident, ns_module,\n                                                 inside)) ||\n                 !option::is_none(lookup_glob_in_mod(e, info, sp, ident,"}, {"sha": "01c0e059b1497d5961c1bcbf82c16117b909d1be", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -69,7 +69,7 @@ const shape_uniq: u8 = 22u8;\n // FIXME: This is a bad API in trans_common.\n fn C_u8(n: u8) -> ValueRef { ret trans_common::C_u8(n as uint); }\n \n-fn hash_res_info(ri: &res_info) -> uint {\n+fn hash_res_info(ri: res_info) -> uint {\n     let h = 5381u;\n     h *= 33u;\n     h += ri.did.crate as uint;\n@@ -80,12 +80,12 @@ fn hash_res_info(ri: &res_info) -> uint {\n     ret h;\n }\n \n-fn eq_res_info(a: &res_info, b: &res_info) -> bool {\n+fn eq_res_info(a: res_info, b: res_info) -> bool {\n     ret a.did.crate == b.did.crate && a.did.node == b.did.node && a.t == b.t;\n }\n \n-fn mk_global(ccx: &@crate_ctxt, name: &str, llval: ValueRef, internal: bool)\n-   -> ValueRef {\n+fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n+   ValueRef {\n     let llglobal =\n         str::as_buf(name,\n                     {|buf|\n@@ -111,7 +111,7 @@ fn mk_global(ccx: &@crate_ctxt, name: &str, llval: ValueRef, internal: bool)\n //\n // TODO: Use this in dynamic_size_of() as well.\n \n-fn largest_variants(ccx: &@crate_ctxt, tag_id: &ast::def_id) -> [uint] {\n+fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     // Compute the minimum and maximum size and alignment for each variant.\n     //\n     // TODO: We could do better here; e.g. we know that any variant that\n@@ -133,7 +133,7 @@ fn largest_variants(ccx: &@crate_ctxt, tag_id: &ast::def_id) -> [uint] {\n                 // follow from how elem_t doesn't contain params.\n                 // (Could add a postcondition to type_contains_params,\n                 // once we implement Issue #586.)\n-                check trans_common::type_has_static_size(ccx, elem_t);\n+                check (trans_common::type_has_static_size(ccx, elem_t));\n                 let llty = trans::type_of(ccx, dummy_sp(), elem_t);\n                 min_size += trans::llsize_of_real(ccx, llty);\n                 min_align += trans::llalign_of_real(ccx, llty);\n@@ -200,8 +200,8 @@ fn round_up(size: u16, align: u8) -> u16 {\n \n type size_align = {size: u16, align: u8};\n \n-fn compute_static_tag_size(ccx: &@crate_ctxt, largest_variants: &[uint],\n-                           did: &ast::def_id) -> size_align {\n+fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n+                           did: ast::def_id) -> size_align {\n     let max_size = 0u16;\n     let max_align = 1u8;\n     let variants = ty::tag_variants(ccx.tcx, did);\n@@ -212,7 +212,7 @@ fn compute_static_tag_size(ccx: &@crate_ctxt, largest_variants: &[uint],\n             // FIXME: there should really be a postcondition\n             // on tag_variants that would obviate the need for\n             // this check. (Issue #586)\n-            check trans_common::type_has_static_size(ccx, typ);\n+            check (trans_common::type_has_static_size(ccx, typ));\n             lltys += [trans::type_of(ccx, dummy_sp(), typ)];\n         }\n \n@@ -234,7 +234,7 @@ fn compute_static_tag_size(ccx: &@crate_ctxt, largest_variants: &[uint],\n \n tag tag_kind { tk_unit; tk_enum; tk_complex; }\n \n-fn tag_kind(ccx: &@crate_ctxt, did: &ast::def_id) -> tag_kind {\n+fn tag_kind(ccx: @crate_ctxt, did: ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);\n     if vec::len(variants) == 0u { ret tk_complex; }\n     for v: ty::variant_info in variants {\n@@ -246,15 +246,15 @@ fn tag_kind(ccx: &@crate_ctxt, did: &ast::def_id) -> tag_kind {\n \n \n // Returns the code corresponding to the pointer size on this architecture.\n-fn s_int(_tcx: &ty_ctxt) -> u8 {\n+fn s_int(_tcx: ty_ctxt) -> u8 {\n     ret shape_i32; // TODO: x86-64\n }\n \n-fn s_uint(_tcx: &ty_ctxt) -> u8 {\n+fn s_uint(_tcx: ty_ctxt) -> u8 {\n     ret shape_u32; // TODO: x86-64\n }\n \n-fn s_float(_tcx: &ty_ctxt) -> u8 {\n+fn s_float(_tcx: ty_ctxt) -> u8 {\n     ret shape_f64; // TODO: x86-64\n }\n \n@@ -284,12 +284,12 @@ fn add_u16(dest: &mutable [u8], val: u16) {\n     dest += [val & 0xffu16 as u8, val >> 8u16 as u8];\n }\n \n-fn add_substr(dest: &mutable [u8], src: &[u8]) {\n+fn add_substr(dest: &mutable [u8], src: [u8]) {\n     add_u16(dest, vec::len(src) as u16);\n     dest += src;\n }\n \n-fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n+fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n     let s = [];\n \n     alt ty::struct(ccx.tcx, t) {\n@@ -299,19 +299,22 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n \n \n \n+\n       ty::ty_int. {\n         s += [s_int(ccx.tcx)];\n       }\n       ty::ty_float. { s += [s_float(ccx.tcx)]; }\n \n \n \n+\n       ty::ty_uint. | ty::ty_ptr(_) | ty::ty_type. | ty::ty_native(_) {\n         s += [s_uint(ccx.tcx)];\n       }\n \n \n \n+\n       ty::ty_machine(ast::ty_i8.) {\n         s += [shape_i8];\n       }\n@@ -324,6 +327,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n \n \n \n+\n       ty::ty_str. {\n         s += [shape_vec];\n         add_bool(s, true); // type is POD\n@@ -332,6 +336,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n       }\n \n \n+\n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n           tk_unit. {\n@@ -370,6 +375,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n \n \n \n+\n       ty::ty_box(mt) {\n         s += [shape_box];\n         add_substr(s, shape_of(ccx, mt.ty, ty_param_map));\n@@ -400,6 +406,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n \n \n \n+\n       ty::ty_fn(_, _, _, _, _) {\n         s += [shape_fn];\n       }\n@@ -408,6 +415,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n \n \n \n+\n       ty::ty_res(did, raw_subt, tps) {\n         let subt = ty::substitute_type_params(ccx.tcx, tps, raw_subt);\n         let ri = {did: did, t: subt};\n@@ -424,11 +432,13 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n       }\n \n \n+\n       ty::ty_var(n) {\n         fail \"shape_of ty_var\";\n       }\n \n \n+\n       ty::ty_param(n, _) {\n         // Find the type parameter in the parameter list.\n         let found = false;\n@@ -449,7 +459,7 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t, ty_param_map: &[uint]) -> [u8] {\n }\n \n // FIXME: We might discover other variants as we traverse these. Handle this.\n-fn shape_of_variant(ccx: &@crate_ctxt, v: &ty::variant_info,\n+fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n                     ty_param_count: uint) -> [u8] {\n     let ty_param_map = [];\n     let i = 0u;\n@@ -460,7 +470,7 @@ fn shape_of_variant(ccx: &@crate_ctxt, v: &ty::variant_info,\n     ret s;\n }\n \n-fn gen_tag_shapes(ccx: &@crate_ctxt) -> ValueRef {\n+fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     // Loop over all the tag variants and write their shapes into a data\n     // buffer. As we do this, it's possible for us to discover new tags, so we\n     // must do this first.\n@@ -555,7 +565,7 @@ fn gen_tag_shapes(ccx: &@crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"tag_shapes\", C_bytes(header), true);\n }\n \n-fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n+fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let dtors = [];\n     let i = 0u;\n     let len = interner::len(ccx.shape_cx.resources);\n@@ -568,7 +578,7 @@ fn gen_resource_shapes(ccx: &@crate_ctxt) -> ValueRef {\n     ret mk_global(ccx, \"resource_shapes\", C_struct(dtors), true);\n }\n \n-fn gen_shape_tables(ccx: &@crate_ctxt) {\n+fn gen_shape_tables(ccx: @crate_ctxt) {\n     let lltagstable = gen_tag_shapes(ccx);\n     let llresourcestable = gen_resource_shapes(ccx);\n     trans_common::set_struct_body(ccx.shape_cx.llshapetablesty,"}, {"sha": "d91e17fc215267112afd1f4d5519dcc5db8dbf35", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 450, "deletions": 464, "changes": 914, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2"}, {"sha": "c72979c3bca300a10cf2da28482107cea6d91948", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -28,7 +28,7 @@ tag opt {\n     lit(@ast::lit);\n     var(/* variant id */uint, /* variant dids */{tg: def_id, var: def_id});\n }\n-fn opt_eq(a: &opt, b: &opt) -> bool {\n+fn opt_eq(a: opt, b: opt) -> bool {\n     alt a {\n       lit(la) {\n         ret alt b { lit(lb) { lit_eq(la, lb) } var(_, _) { false } };\n@@ -38,14 +38,14 @@ fn opt_eq(a: &opt, b: &opt) -> bool {\n       }\n     }\n }\n-fn trans_opt(bcx: &@block_ctxt, o: &opt) -> result {\n+fn trans_opt(bcx: @block_ctxt, o: opt) -> result {\n     alt o {\n       lit(l) { ret trans::trans_lit(bcx, *l); }\n       var(id, _) { ret rslt(bcx, C_int(id as int)); }\n     }\n }\n \n-fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n+fn variant_opt(ccx: @crate_ctxt, pat_id: ast::node_id) -> opt {\n     let vdef = ast_util::variant_def_ids(ccx.tcx.def_map.get(pat_id));\n     let variants = ty::tag_variants(ccx.tcx, vdef.tg);\n     let i = 0u;\n@@ -57,7 +57,7 @@ fn variant_opt(ccx: &@crate_ctxt, pat_id: ast::node_id) -> opt {\n }\n \n type bind_map = [{ident: ast::ident, val: ValueRef}];\n-fn assoc(key: &str, list: &bind_map) -> option::t<ValueRef> {\n+fn assoc(key: str, list: bind_map) -> option::t<ValueRef> {\n     for elt: {ident: ast::ident, val: ValueRef} in list {\n         if str::eq(elt.ident, key) { ret some(elt.val); }\n     }\n@@ -73,7 +73,7 @@ type match_branch =\n             id_map: ast_util::pat_id_map}};\n type match = [match_branch];\n \n-fn matches_always(p: &@ast::pat) -> bool {\n+fn matches_always(p: @ast::pat) -> bool {\n     ret alt p.node {\n           ast::pat_wild. { true }\n           ast::pat_bind(_) { true }\n@@ -83,9 +83,9 @@ fn matches_always(p: &@ast::pat) -> bool {\n         };\n }\n \n-type enter_pat = fn(&@ast::pat) -> option::t<[@ast::pat]>;\n+type enter_pat = fn(@ast::pat) -> option::t<[@ast::pat]>;\n \n-fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n+fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n     let result = [];\n     for br: match_branch in m {\n         alt e(br.pats[col]) {\n@@ -110,18 +110,18 @@ fn enter_match(m: &match, col: uint, val: ValueRef, e: &enter_pat) -> match {\n     ret result;\n }\n \n-fn enter_default(m: &match, col: uint, val: ValueRef) -> match {\n-    fn e(p: &@ast::pat) -> option::t<[@ast::pat]> {\n+fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n+    fn e(p: @ast::pat) -> option::t<[@ast::pat]> {\n         ret if matches_always(p) { some([]) } else { none };\n     }\n     ret enter_match(m, col, val, e);\n }\n \n-fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n-             tag_size: uint, val: ValueRef) -> match {\n+fn enter_opt(ccx: @crate_ctxt, m: match, opt: opt, col: uint, tag_size: uint,\n+             val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(ccx: &@crate_ctxt, dummy: &@ast::pat, opt: &opt, size: uint,\n-         p: &@ast::pat) -> option::t<[@ast::pat]> {\n+    fn e(ccx: @crate_ctxt, dummy: @ast::pat, opt: opt, size: uint,\n+         p: @ast::pat) -> option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_tag(ctor, subpats) {\n             ret if opt_eq(variant_opt(ccx, p.id), opt) {\n@@ -137,10 +137,10 @@ fn enter_opt(ccx: &@crate_ctxt, m: &match, opt: &opt, col: uint,\n     ret enter_match(m, col, val, bind e(ccx, dummy, opt, tag_size, _));\n }\n \n-fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n+fn enter_rec(m: match, col: uint, fields: [ast::ident], val: ValueRef) ->\n    match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: &@ast::pat, fields: &[ast::ident], p: &@ast::pat) ->\n+    fn e(dummy: @ast::pat, fields: [ast::ident], p: @ast::pat) ->\n        option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_rec(fpats, _) {\n@@ -160,9 +160,9 @@ fn enter_rec(m: &match, col: uint, fields: &[ast::ident], val: ValueRef) ->\n     ret enter_match(m, col, val, bind e(dummy, fields, _));\n }\n \n-fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n+fn enter_tup(m: match, col: uint, val: ValueRef, n_elts: uint) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: &@ast::pat, n_elts: uint, p: &@ast::pat) ->\n+    fn e(dummy: @ast::pat, n_elts: uint, p: @ast::pat) ->\n        option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_tup(elts) { ret some(elts); }\n@@ -172,9 +172,9 @@ fn enter_tup(m: &match, col: uint, val: ValueRef, n_elts: uint) -> match {\n     ret enter_match(m, col, val, bind e(dummy, n_elts, _));\n }\n \n-fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n+fn enter_box(m: match, col: uint, val: ValueRef) -> match {\n     let dummy = @{id: 0, node: ast::pat_wild, span: dummy_sp()};\n-    fn e(dummy: &@ast::pat, p: &@ast::pat) -> option::t<[@ast::pat]> {\n+    fn e(dummy: @ast::pat, p: @ast::pat) -> option::t<[@ast::pat]> {\n         alt p.node {\n           ast::pat_box(sub) { ret some([sub]); }\n           _ { ret some([dummy]); }\n@@ -183,8 +183,8 @@ fn enter_box(m: &match, col: uint, val: ValueRef) -> match {\n     ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n-fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> [opt] {\n-    fn add_to_set(set: &mutable [opt], val: &opt) {\n+fn get_options(ccx: @crate_ctxt, m: match, col: uint) -> [opt] {\n+    fn add_to_set(set: &mutable [opt], val: opt) {\n         for l: opt in set { if opt_eq(l, val) { ret; } }\n         set += [val];\n     }\n@@ -203,7 +203,7 @@ fn get_options(ccx: &@crate_ctxt, m: &match, col: uint) -> [opt] {\n }\n \n fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n-                        vdefs: &{tg: def_id, var: def_id}, val: ValueRef) ->\n+                        vdefs: {tg: def_id, var: def_id}, val: ValueRef) ->\n    {vals: [ValueRef], bcx: @block_ctxt} {\n     let ccx = bcx.fcx.lcx.ccx;\n     let ty_param_substs = ty::node_id_to_type_params(ccx.tcx, pat_id);\n@@ -232,7 +232,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n     ret {vals: args, bcx: bcx};\n }\n \n-fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n+fn collect_record_fields(m: match, col: uint) -> [ast::ident] {\n     let fields = [];\n     for br: match_branch in m {\n         alt br.pats[col].node {\n@@ -249,14 +249,14 @@ fn collect_record_fields(m: &match, col: uint) -> [ast::ident] {\n     ret fields;\n }\n \n-fn any_box_pat(m: &match, col: uint) -> bool {\n+fn any_box_pat(m: match, col: uint) -> bool {\n     for br: match_branch in m {\n         alt br.pats[col].node { ast::pat_box(_) { ret true; } _ { } }\n     }\n     ret false;\n }\n \n-fn any_tup_pat(m: &match, col: uint) -> bool {\n+fn any_tup_pat(m: match, col: uint) -> bool {\n     for br: match_branch in m {\n         alt br.pats[col].node { ast::pat_tup(_) { ret true; } _ { } }\n     }\n@@ -266,7 +266,7 @@ fn any_tup_pat(m: &match, col: uint) -> bool {\n type exit_node = {bound: bind_map, from: BasicBlockRef, to: BasicBlockRef};\n type mk_fail = fn() -> BasicBlockRef;\n \n-fn pick_col(m: &match) -> uint {\n+fn pick_col(m: match) -> uint {\n     let scores = vec::init_elt_mut(0u, vec::len(m[0].pats));\n     for br: match_branch in m {\n         let i = 0u;\n@@ -293,8 +293,8 @@ fn pick_col(m: &match) -> uint {\n     ret best_col;\n }\n \n-fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n-                    f: &mk_fail, exits: &mutable [exit_node]) {\n+fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n+                    exits: &mutable [exit_node]) {\n     if vec::len(m) == 0u { Br(bcx, f()); ret; }\n     if vec::len(m[0].pats) == 0u {\n         let data = m[0].data;\n@@ -407,10 +407,11 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n             }\n           }\n           lit(l) {\n-            kind = alt l.node {\n-              ast::lit_str(_) { compare }\n-              _ { test_val = Load(bcx, val); switch }\n-            };\n+            kind =\n+                alt l.node {\n+                  ast::lit_str(_) { compare }\n+                  _ { test_val = Load(bcx, val); switch }\n+                };\n           }\n         }\n     }\n@@ -473,8 +474,8 @@ fn compile_submatch(bcx: @block_ctxt, m: &match, vals: [ValueRef],\n }\n \n // Returns false for unreachable blocks\n-fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n-                     ids: &ast_util::pat_id_map) -> bool {\n+fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n+                     ids: ast_util::pat_id_map) -> bool {\n     let our_block = bcx.llbb as uint;\n     let success = true;\n     for each item: @{key: ast::ident, val: ast::node_id} in ids.items() {\n@@ -496,8 +497,8 @@ fn make_phi_bindings(bcx: &@block_ctxt, map: &[exit_node],\n     ret success;\n }\n \n-fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n-             output: &trans::out_method) -> result {\n+fn trans_alt(cx: @block_ctxt, expr: @ast::expr, arms: [ast::arm],\n+             output: trans::out_method) -> result {\n     let bodies = [];\n     let match: match = [];\n     let er = trans::trans_expr(cx, expr);\n@@ -524,7 +525,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n \n     // Cached fail-on-fallthrough block\n     let fail_cx = @mutable none;\n-    fn mk_fail(cx: &@block_ctxt, sp: &span,\n+    fn mk_fail(cx: @block_ctxt, sp: span,\n                done: @mutable option::t<BasicBlockRef>) -> BasicBlockRef {\n         alt *done { some(bb) { ret bb; } _ { } }\n         let fail_cx = new_sub_block_ctxt(cx, \"case_fallthrough\");\n@@ -556,7 +557,7 @@ fn trans_alt(cx: &@block_ctxt, expr: &@ast::expr, arms: &[ast::arm],\n }\n \n // Not alt-related, but similar to the pattern-munging code above\n-fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n+fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n                         table: hashmap<ast::node_id, ValueRef>,\n                         make_copy: bool) -> @block_ctxt {\n     let ccx = bcx.fcx.lcx.ccx;\n@@ -566,7 +567,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: &@ast::pat, val: ValueRef,\n             let ty = ty::node_id_to_monotype(ccx.tcx, pat.id);\n             // FIXME: Could constrain pat_bind to make this\n             // check unnecessary.\n-            check type_has_static_size(ccx, ty);\n+            check (type_has_static_size(ccx, ty));\n             let llty = trans::type_of(ccx, pat.span, ty);\n             let alloc = trans::alloca(bcx, llty);\n             bcx ="}, {"sha": "ebf1b20c0caa6ce4a017e2f998354118cfafce67", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 91, "deletions": 94, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,58 +5,58 @@ import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef, Opcode,\n               ModuleRef};\n import trans_common::block_ctxt;\n \n-fn B(cx: &@block_ctxt) -> BuilderRef {\n+fn B(cx: @block_ctxt) -> BuilderRef {\n     let b = *cx.fcx.lcx.ccx.builder;\n     llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n     ret b;\n }\n \n-fn RetVoid(cx: &@block_ctxt) -> ValueRef {\n+fn RetVoid(cx: @block_ctxt) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildRetVoid(B(cx));\n }\n \n-fn Ret(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+fn Ret(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildRet(B(cx), V);\n }\n \n-fn AggregateRet(cx: &@block_ctxt, RetVals: &[ValueRef]) -> ValueRef {\n+fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n                                     vec::len(RetVals));\n }\n \n-fn Br(cx: &@block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n+fn Br(cx: @block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n-fn CondBr(cx: &@block_ctxt, If: ValueRef, Then: BasicBlockRef,\n+fn CondBr(cx: @block_ctxt, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n-fn Switch(cx: &@block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n+fn Switch(cx: @block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n    -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n }\n \n-fn IndirectBr(cx: &@block_ctxt, Addr: ValueRef, NumDests: uint) -> ValueRef {\n+fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n }\n \n-fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n+fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n@@ -68,172 +68,171 @@ fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n                     });\n }\n \n-fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n+fn Unreachable(cx: @block_ctxt) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n     ret llvm::LLVMBuildUnreachable(B(cx));\n }\n \n /* Arithmetic */\n-fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Add(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf) });\n }\n \n-fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NSWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf) });\n }\n \n-fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NUWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf) });\n }\n \n-fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf) });\n }\n \n-fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Sub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSub(B(cx), LHS, RHS, buf) });\n }\n \n-fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NSWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf) });\n }\n \n-fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NUWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf) });\n }\n \n-fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf) });\n }\n \n-fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Mul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMul(B(cx), LHS, RHS, buf) });\n }\n \n-fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NSWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf) });\n }\n \n-fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn NUWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf) });\n }\n \n-fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf) });\n }\n \n-fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn UDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf) });\n }\n \n-fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn SDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf) });\n }\n \n-fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn ExactSDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf) });\n }\n \n-fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf) });\n }\n \n-fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn URem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildURem(B(cx), LHS, RHS, buf) });\n }\n \n-fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn SRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf) });\n }\n \n-fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn FRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf) });\n }\n \n-fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Shl(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildShl(B(cx), LHS, RHS, buf) });\n }\n \n-fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn LShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf) });\n }\n \n-fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn AShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf) });\n }\n \n-fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn And(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf) });\n }\n \n-fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Or(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildOr(B(cx), LHS, RHS, buf) });\n }\n \n-fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn Xor(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildXor(B(cx), LHS, RHS, buf) });\n }\n \n-fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n+fn BinOp(cx: @block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf) });\n }\n \n-fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+fn Neg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNeg(B(cx), V, buf) });\n }\n \n-fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+fn NSWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNSWNeg(B(cx), V, buf) });\n }\n \n-fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+fn NUWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNUWNeg(B(cx), V, buf) });\n }\n-fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+fn FNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildFNeg(B(cx), V, buf) });\n }\n \n-fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n+fn Not(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildNot(B(cx), V, buf) });\n }\n \n /* Memory */\n-fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n+fn Malloc(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildMalloc(B(cx), Ty, buf) });\n }\n \n-fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+fn ArrayMalloc(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf) });\n }\n \n-fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n+fn Alloca(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildAlloca(B(cx), Ty, buf) });\n }\n \n-fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n+fn ArrayAlloca(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf) });\n }\n \n-fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+fn Free(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     ret llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n-fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n+fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildLoad(B(cx), PointerVal, buf) });\n }\n \n-fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n+fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n     ret llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n-fn GEP(cx: &@block_ctxt, Pointer: ValueRef, Indices: &[ValueRef]) ->\n-   ValueRef {\n+fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildGEP(B(cx), Pointer,\n@@ -242,7 +241,7 @@ fn GEP(cx: &@block_ctxt, Pointer: ValueRef, Indices: &[ValueRef]) ->\n                     });\n }\n \n-fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef, Indices: &[ValueRef]) ->\n+fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n@@ -252,179 +251,177 @@ fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef, Indices: &[ValueRef]) ->\n                     });\n }\n \n-fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n+fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n                     });\n }\n \n-fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n+fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildGlobalString(B(cx), _Str, buf) });\n }\n \n-fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n+fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n                     });\n }\n \n /* Casts */\n-fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn Trunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf) });\n }\n \n-fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn ZExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf) });\n }\n \n-fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn SExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf) });\n }\n \n-fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPToUI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf) });\n }\n \n-fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPToSI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf) });\n }\n \n-fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn UIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf) });\n }\n \n-fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn SIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf) });\n }\n \n-fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPTrunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf) });\n }\n \n-fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf) });\n }\n \n-fn PtrToInt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn PtrToInt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n                     });\n }\n \n-fn IntToPtr(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn IntToPtr(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n                     });\n }\n \n-fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn BitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf) });\n }\n \n-fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n                     });\n }\n \n-fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n                     });\n }\n \n-fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n+fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n                     });\n }\n \n-fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n+fn Cast(cx: @block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: sbuf) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n                     });\n }\n \n-fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn PointerCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n                     });\n }\n \n-fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn IntCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf) });\n }\n \n-fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n+fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf) });\n }\n \n \n /* Comparisons */\n-fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) ->\n-   ValueRef {\n+fn ICmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf) });\n }\n \n-fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) ->\n-   ValueRef {\n+fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf) });\n }\n \n \n /* Miscellaneous instructions */\n-fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n-       bbs: &[BasicBlockRef]) -> ValueRef {\n+fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n+   -> ValueRef {\n     let phi = str::as_buf(\"\", {|buf| llvm::LLVMBuildPhi(B(cx), Ty, buf) });\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n     ret phi;\n }\n \n-fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n+fn AddIncomingToPhi(phi: ValueRef, vals: [ValueRef], bbs: [BasicBlockRef]) {\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n                           vec::len(vals));\n }\n \n-fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                             vec::len(Args), buf)\n                     });\n }\n \n-fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n+fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     let v =\n         str::as_buf(\"\",\n                     {|buf|\n@@ -435,7 +432,7 @@ fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n     ret v;\n }\n \n-fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef], Conv: uint)\n+fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n    -> ValueRef {\n     let v =\n         str::as_buf(\"\",\n@@ -447,19 +444,19 @@ fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef], Conv: uint)\n     ret v;\n }\n \n-fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n+fn Select(cx: @block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n                     });\n }\n \n-fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n+fn VAArg(cx: @block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildVAArg(B(cx), list, Ty, buf) });\n }\n \n-fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n+fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n@@ -468,7 +465,7 @@ fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n                     });\n }\n \n-fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n+fn InsertElement(cx: @block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n@@ -477,22 +474,22 @@ fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                     });\n }\n \n-fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef, Mask: ValueRef)\n+fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef, Mask: ValueRef)\n    -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n                     });\n }\n \n-fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n+fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n                         llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n                     });\n }\n \n-fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n+fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf|\n@@ -501,20 +498,20 @@ fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n                     });\n }\n \n-fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n+fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNull(B(cx), Val, buf) });\n }\n \n-fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n+fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\", {|buf| llvm::LLVMBuildIsNotNull(B(cx), Val, buf) });\n }\n \n-fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n+fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     ret str::as_buf(\"\",\n                     {|buf| llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf) });\n }\n \n-fn Trap(cx: &@block_ctxt) -> ValueRef {\n+fn Trap(cx: @block_ctxt) -> ValueRef {\n     let b = B(cx);\n     let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);"}, {"sha": "b266f64292118b5f0a3147ade9f1de8f2ff9f767", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 57, "deletions": 58, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -62,7 +62,7 @@ import trans::type_of_fn_full;\n import trans::drop_ty;\n \n obj namegen(mutable i: int) {\n-    fn next(prefix: &str) -> str { i += 1; ret prefix + int::str(i); }\n+    fn next(prefix: str) -> str { i += 1; ret prefix + int::str(i); }\n }\n \n type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n@@ -291,15 +291,15 @@ type fn_ctxt =\n      lcx: @local_ctxt};\n \n tag cleanup {\n-    clean(fn(&@block_ctxt) -> @block_ctxt);\n-    clean_temp(ValueRef, fn(&@block_ctxt) -> @block_ctxt);\n+    clean(fn(@block_ctxt) -> @block_ctxt);\n+    clean_temp(ValueRef, fn(@block_ctxt) -> @block_ctxt);\n }\n \n-fn add_clean(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n+fn add_clean(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n     find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, val, ty))];\n }\n-fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n-    fn spill_and_drop(cx: &@block_ctxt, val: ValueRef, ty: ty::t) ->\n+fn add_clean_temp(cx: @block_ctxt, val: ValueRef, ty: ty::t) {\n+    fn spill_and_drop(cx: @block_ctxt, val: ValueRef, ty: ty::t) ->\n        @block_ctxt {\n         let bcx = cx;\n         let r = trans::spill_if_immediate(bcx, val, ty);\n@@ -315,7 +315,7 @@ fn add_clean_temp(cx: &@block_ctxt, val: ValueRef, ty: ty::t) {\n // to a system where we can also cancel the cleanup on local variables, but\n // this will be more involved. For now, we simply zero out the local, and the\n // drop glue checks whether it is zero.\n-fn revoke_clean(cx: &@block_ctxt, val: ValueRef, t: ty::t) -> @block_ctxt {\n+fn revoke_clean(cx: @block_ctxt, val: ValueRef, t: ty::t) -> @block_ctxt {\n     if ty::type_is_unique(bcx_tcx(cx), t) {\n         // Just zero out the allocation. This ensures that the GC won't try to\n         // traverse dangling pointers.\n@@ -346,8 +346,8 @@ fn revoke_clean(cx: &@block_ctxt, val: ValueRef, t: ty::t) -> @block_ctxt {\n     ret cx;\n }\n \n-fn get_res_dtor(ccx: &@crate_ctxt, sp: &span, did: &ast::def_id,\n-                inner_t: ty::t) -> ValueRef {\n+fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n+   -> ValueRef {\n     if did.crate == ast::local_crate {\n         alt ccx.fn_pairs.find(did.node) {\n           some(x) { ret x; }\n@@ -418,7 +418,7 @@ type block_ctxt =\n      sp: span,\n      fcx: @fn_ctxt};\n \n-fn is_terminated(cx: &@block_ctxt) -> bool { ret cx.terminated; }\n+fn is_terminated(cx: @block_ctxt) -> bool { ret cx.terminated; }\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n@@ -427,7 +427,7 @@ tag block_parent { parent_none; parent_some(@block_ctxt); }\n type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n \n-fn extend_path(cx: @local_ctxt, name: &str) -> @local_ctxt {\n+fn extend_path(cx: @local_ctxt, name: str) -> @local_ctxt {\n     ret @{path: cx.path + [name] with *cx};\n }\n \n@@ -452,7 +452,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     ret llvm::LLVMGetElementType(elt_tys[n]);\n }\n \n-fn find_scope_cx(cx: &@block_ctxt) -> @block_ctxt {\n+fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n     if cx.kind != NON_SCOPE_BLOCK { ret cx; }\n     alt cx.parent {\n       parent_some(b) { ret find_scope_cx(b); }\n@@ -466,14 +466,14 @@ fn find_scope_cx(cx: &@block_ctxt) -> @block_ctxt {\n // Accessors\n // TODO: When we have overloading, simplify these names!\n \n-fn bcx_tcx(bcx: &@block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n-fn bcx_ccx(bcx: &@block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n-fn bcx_lcx(bcx: &@block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n-fn bcx_fcx(bcx: &@block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n-fn fcx_ccx(fcx: &@fn_ctxt) -> @crate_ctxt { ret fcx.lcx.ccx; }\n-fn fcx_tcx(fcx: &@fn_ctxt) -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n-fn lcx_ccx(lcx: &@local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n-fn ccx_tcx(ccx: &@crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n+fn bcx_tcx(bcx: @block_ctxt) -> ty::ctxt { ret bcx.fcx.lcx.ccx.tcx; }\n+fn bcx_ccx(bcx: @block_ctxt) -> @crate_ctxt { ret bcx.fcx.lcx.ccx; }\n+fn bcx_lcx(bcx: @block_ctxt) -> @local_ctxt { ret bcx.fcx.lcx; }\n+fn bcx_fcx(bcx: @block_ctxt) -> @fn_ctxt { ret bcx.fcx; }\n+fn fcx_ccx(fcx: @fn_ctxt) -> @crate_ctxt { ret fcx.lcx.ccx; }\n+fn fcx_tcx(fcx: @fn_ctxt) -> ty::ctxt { ret fcx.lcx.ccx.tcx; }\n+fn lcx_ccx(lcx: @local_ctxt) -> @crate_ctxt { ret lcx.ccx; }\n+fn ccx_tcx(ccx: @crate_ctxt) -> ty::ctxt { ret ccx.tcx; }\n \n // LLVM type constructors.\n fn T_void() -> TypeRef {\n@@ -532,27 +532,27 @@ fn T_size_t() -> TypeRef {\n     ret T_i32();\n }\n \n-fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n+fn T_fn(inputs: [TypeRef], output: TypeRef) -> TypeRef {\n     ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n                                std::vec::len::<TypeRef>(inputs), False);\n }\n \n-fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n+fn T_fn_pair(cx: crate_ctxt, tfn: TypeRef) -> TypeRef {\n     ret T_struct([T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n }\n \n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n-fn T_struct(elts: &[TypeRef]) -> TypeRef {\n+fn T_struct(elts: [TypeRef]) -> TypeRef {\n     ret llvm::LLVMStructType(to_ptr(elts), std::vec::len(elts), False);\n }\n \n-fn T_named_struct(name: &str) -> TypeRef {\n+fn T_named_struct(name: str) -> TypeRef {\n     let c = llvm::LLVMGetGlobalContext();\n     ret str::as_buf(name, {|buf| llvm::LLVMStructCreateNamed(c, buf) });\n }\n \n-fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n+fn set_struct_body(t: TypeRef, elts: [TypeRef]) {\n     llvm::LLVMStructSetBody(t, to_ptr(elts), std::vec::len(elts), False);\n }\n \n@@ -590,7 +590,7 @@ fn T_task() -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n+fn T_tydesc_field(cx: crate_ctxt, field: int) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let tydesc_elts: [TypeRef] =\n@@ -601,15 +601,15 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n     ret t;\n }\n \n-fn T_glue_fn(cx: &crate_ctxt) -> TypeRef {\n+fn T_glue_fn(cx: crate_ctxt) -> TypeRef {\n     let s = \"glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_cmp_glue_fn(cx: &crate_ctxt) -> TypeRef {\n+fn T_cmp_glue_fn(cx: crate_ctxt) -> TypeRef {\n     let s = \"cmp_glue_fn\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n@@ -663,77 +663,76 @@ fn T_chan(_t: TypeRef) -> TypeRef {\n \n }\n \n-fn T_taskptr(cx: &crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n+fn T_taskptr(cx: crate_ctxt) -> TypeRef { ret T_ptr(cx.task_type); }\n \n \n // This type must never be used directly; it must always be cast away.\n-fn T_typaram(tn: &type_names) -> TypeRef {\n+fn T_typaram(tn: type_names) -> TypeRef {\n     let s = \"typaram\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_i8();\n     tn.associate(s, t);\n     ret t;\n }\n \n-fn T_typaram_ptr(tn: &type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n+fn T_typaram_ptr(tn: type_names) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure_ptr(cx: &crate_ctxt, llbindings_ty: TypeRef, n_ty_params: uint)\n-   -> TypeRef {\n+fn T_closure_ptr(cx: crate_ctxt, llbindings_ty: TypeRef, n_ty_params: uint) ->\n+   TypeRef {\n     // NB: keep this in sync with code in trans_bind; we're making\n     // an LLVM typeref structure that has the same \"shape\" as the ty::t\n     // it constructs.\n     ret T_ptr(T_box(T_struct([T_ptr(cx.tydesc_type), llbindings_ty,\n                               T_captured_tydescs(cx, n_ty_params)])));\n }\n \n-fn T_opaque_closure_ptr(cx: &crate_ctxt) -> TypeRef {\n+fn T_opaque_closure_ptr(cx: crate_ctxt) -> TypeRef {\n     let s = \"*closure\";\n     if cx.tn.name_has_type(s) { ret cx.tn.get_type(s); }\n     let t = T_closure_ptr(cx, T_nil(), 0u);\n     cx.tn.associate(s, t);\n     ret t;\n }\n \n-fn T_tag(tn: &type_names, size: uint) -> TypeRef {\n+fn T_tag(tn: type_names, size: uint) -> TypeRef {\n     let s = \"tag_\" + uint::to_str(size, 10u);\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n-    let t = if size == 0u {\n-        T_struct([T_int()])\n-    } else {\n-        T_struct([T_int(), T_array(T_i8(), size)])\n-    };\n+    let t =\n+        if size == 0u {\n+            T_struct([T_int()])\n+        } else { T_struct([T_int(), T_array(T_i8(), size)]) };\n     tn.associate(s, t);\n     ret t;\n }\n \n-fn T_opaque_tag(tn: &type_names) -> TypeRef {\n+fn T_opaque_tag(tn: type_names) -> TypeRef {\n     let s = \"opaque_tag\";\n     if tn.name_has_type(s) { ret tn.get_type(s); }\n     let t = T_struct([T_int(), T_i8()]);\n     tn.associate(s, t);\n     ret t;\n }\n \n-fn T_opaque_tag_ptr(tn: &type_names) -> TypeRef {\n+fn T_opaque_tag_ptr(tn: type_names) -> TypeRef {\n     ret T_ptr(T_opaque_tag(tn));\n }\n \n-fn T_captured_tydescs(cx: &crate_ctxt, n: uint) -> TypeRef {\n+fn T_captured_tydescs(cx: crate_ctxt, n: uint) -> TypeRef {\n     ret T_struct(std::vec::init_elt::<TypeRef>(T_ptr(cx.tydesc_type), n));\n }\n \n-fn T_obj_ptr(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n+fn T_obj_ptr(cx: crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n     // This function is not publicly exposed because it returns an incomplete\n     // type. The dynamically-sized fields follow the captured tydescs.\n \n-    fn T_obj(cx: &crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n+    fn T_obj(cx: crate_ctxt, n_captured_tydescs: uint) -> TypeRef {\n         ret T_struct([T_ptr(cx.tydesc_type),\n                       T_captured_tydescs(cx, n_captured_tydescs)]);\n     }\n     ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n }\n \n-fn T_opaque_obj_ptr(cx: &crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n+fn T_opaque_obj_ptr(cx: crate_ctxt) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n \n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n@@ -753,11 +752,11 @@ fn C_integral(t: TypeRef, u: uint, sign_extend: Bool) -> ValueRef {\n     ret llvm::LLVMRustConstSmallInt(t, u, sign_extend);\n }\n \n-fn C_float(s: &str) -> ValueRef {\n+fn C_float(s: str) -> ValueRef {\n     ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(T_float(), buf) });\n }\n \n-fn C_floating(s: &str, t: TypeRef) -> ValueRef {\n+fn C_floating(s: str, t: TypeRef) -> ValueRef {\n     ret str::as_buf(s, {|buf| llvm::LLVMConstRealOfString(t, buf) });\n }\n \n@@ -782,7 +781,7 @@ fn C_u8(i: uint) -> ValueRef { ret C_integral(T_i8(), i, False); }\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n+fn C_cstr(cx: @crate_ctxt, s: str) -> ValueRef {\n     let sc =\n         str::as_buf(s,\n                     {|buf|\n@@ -798,7 +797,7 @@ fn C_cstr(cx: &@crate_ctxt, s: &str) -> ValueRef {\n }\n \n // Returns a Plain Old LLVM String:\n-fn C_postr(s: &str) -> ValueRef {\n+fn C_postr(s: str) -> ValueRef {\n     ret str::as_buf(s,\n                     {|buf|\n                         llvm::LLVMConstString(buf, str::byte_len(s), False)\n@@ -813,26 +812,26 @@ fn C_zero_byte_arr(size: uint) -> ValueRef {\n                              std::vec::len(elts));\n }\n \n-fn C_struct(elts: &[ValueRef]) -> ValueRef {\n+fn C_struct(elts: [ValueRef]) -> ValueRef {\n     ret llvm::LLVMConstStruct(std::vec::to_ptr(elts), std::vec::len(elts),\n                               False);\n }\n \n-fn C_named_struct(T: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+fn C_named_struct(T: TypeRef, elts: [ValueRef]) -> ValueRef {\n     ret llvm::LLVMConstNamedStruct(T, std::vec::to_ptr(elts),\n                                    std::vec::len(elts));\n }\n \n-fn C_array(ty: TypeRef, elts: &[ValueRef]) -> ValueRef {\n+fn C_array(ty: TypeRef, elts: [ValueRef]) -> ValueRef {\n     ret llvm::LLVMConstArray(ty, std::vec::to_ptr(elts), std::vec::len(elts));\n }\n \n-fn C_bytes(bytes: &[u8]) -> ValueRef {\n+fn C_bytes(bytes: [u8]) -> ValueRef {\n     ret llvm::LLVMConstString(unsafe::reinterpret_cast(vec::to_ptr(bytes)),\n                               vec::len(bytes), False);\n }\n \n-fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n+fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     let llshape = C_bytes(bytes);\n     let llglobal =\n         str::as_buf(ccx.names.next(\"shape\"),\n@@ -847,8 +846,8 @@ fn C_shape(ccx: &@crate_ctxt, bytes: &[u8]) -> ValueRef {\n }\n \n \n-pure fn valid_variant_index(ix: uint, cx: @block_ctxt, tag_id: &ast::def_id,\n-                            variant_id: &ast::def_id) -> bool {\n+pure fn valid_variant_index(ix: uint, cx: @block_ctxt, tag_id: ast::def_id,\n+                            variant_id: ast::def_id) -> bool {\n \n     // Handwaving: it's ok to pretend this code is referentially\n     // transparent, because the relevant parts of the type context don't\n@@ -860,7 +859,7 @@ pure fn valid_variant_index(ix: uint, cx: @block_ctxt, tag_id: &ast::def_id,\n     }\n }\n \n-pure fn type_has_static_size(cx: &@crate_ctxt, t: ty::t) -> bool {\n+pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n     !ty::type_has_dynamic_size(cx.tcx, t)\n }\n "}, {"sha": "cd554dac8d46ecb601782560683c9b100e21cc32", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -28,8 +28,8 @@ export trans_obj;\n \n // trans_obj: create an LLVM function that is the object constructor for the\n // object being translated.\n-fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n-             ctor_id: ast::node_id, ty_params: &[ast::ty_param]) {\n+fn trans_obj(cx: @local_ctxt, sp: span, ob: ast::_obj, ctor_id: ast::node_id,\n+             ty_params: [ast::ty_param]) {\n \n     // To make a function, we have to create a function context and, inside\n     // that, a number of block contexts for which code is generated.\n@@ -48,8 +48,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n     // we're creating.\n     let fn_args: [ast::arg] = [];\n     for f: ast::obj_field in ob.fields {\n-        fn_args +=\n-            [{mode: ast::by_ref, ty: f.ty, ident: f.ident, id: f.id}];\n+        fn_args += [{mode: ast::by_ref, ty: f.ty, ident: f.ident, id: f.id}];\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n \n@@ -205,7 +204,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n // function and putting it in the generated code as an object item, we are\n // instead \"inlining\" the construction of the object and returning the object\n // itself.\n-fn trans_anon_obj(bcx: @block_ctxt, sp: &span, anon_obj: &ast::anon_obj,\n+fn trans_anon_obj(bcx: @block_ctxt, sp: span, anon_obj: ast::anon_obj,\n                   id: ast::node_id) -> result {\n \n     let ccx = bcx_ccx(bcx);\n@@ -394,12 +393,12 @@ tag vtbl_mthd {\n }\n \n // Alphabetize ast::methods by ident.  A helper for create_vtbl.\n-fn ast_mthd_lteq(a: &@ast::method, b: &@ast::method) -> bool {\n+fn ast_mthd_lteq(a: @ast::method, b: @ast::method) -> bool {\n     ret str::lteq(a.node.ident, b.node.ident);\n }\n \n // Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n-fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n+fn vtbl_mthd_lteq(a: vtbl_mthd, b: vtbl_mthd) -> bool {\n     alt a {\n       normal_mthd(ma) {\n         alt b {\n@@ -418,8 +417,8 @@ fn vtbl_mthd_lteq(a: &vtbl_mthd, b: &vtbl_mthd) -> bool {\n \n // filtering_fn: Used by create_vtbl to filter a list of methods to remove the\n // ones that we don't need forwarding slots for.\n-fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n-   -> option::t<vtbl_mthd> {\n+fn filtering_fn(cx: @local_ctxt, m: vtbl_mthd, addtl_meths: [@ast::method]) ->\n+   option::t<vtbl_mthd> {\n \n     // Since m is a fwding_mthd, and we're checking to see if it's in\n     // addtl_meths (which only contains normal_mthds), we can't just check if\n@@ -442,10 +441,9 @@ fn filtering_fn(cx: @local_ctxt, m: &vtbl_mthd, addtl_meths: [@ast::method])\n \n // create_vtbl: Create a vtable for a regular object or for an outer anonymous\n // object, and return a pointer to it.\n-fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n-               ob: &ast::_obj, ty_params: &[ast::ty_param],\n-               inner_obj_ty: option::t<ty::t>, additional_field_tys: &[ty::t])\n-   -> ValueRef {\n+fn create_vtbl(cx: @local_ctxt, sp: span, outer_obj_ty: ty::t, ob: ast::_obj,\n+               ty_params: [ast::ty_param], inner_obj_ty: option::t<ty::t>,\n+               additional_field_tys: [ty::t]) -> ValueRef {\n \n     let llmethods: [ValueRef] = [];\n \n@@ -531,7 +529,7 @@ fn create_vtbl(cx: @local_ctxt, sp: &span, outer_obj_ty: ty::t,\n // create_backwarding_vtbl: Create a vtable for the inner object of an\n // anonymous object, so that any self-calls made from the inner object's\n // methods get redirected appropriately.\n-fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n+fn create_backwarding_vtbl(cx: @local_ctxt, sp: span, inner_obj_ty: ty::t,\n                            outer_obj_ty: ty::t) -> ValueRef {\n \n     // This vtbl needs to have slots for all of the methods on an inner\n@@ -564,7 +562,7 @@ fn create_backwarding_vtbl(cx: @local_ctxt, sp: &span, inner_obj_ty: ty::t,\n \n // finish_vtbl: Given a vector of vtable entries, create the table in\n // read-only memory and return a pointer to it.\n-fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: &str) ->\n+fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: str) ->\n    ValueRef {\n     let vtbl = C_struct(llmethods);\n     let vtbl_name = mangle_internal_name_by_path(cx.ccx, cx.path + [name]);\n@@ -594,9 +592,9 @@ fn finish_vtbl(cx: @local_ctxt, llmethods: [ValueRef], name: &str) ->\n // one for each method on inner, each of which takes all the same arguments as\n // the corresponding method on inner does, calls that method on outer, and\n // returns the value returned from that call.\n-fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                        ty_params: &[ast::ty_param], outer_obj_ty: ty::t,\n-                        _additional_field_tys: &[ty::t]) -> ValueRef {\n+fn process_bkwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n+                        ty_params: [ast::ty_param], outer_obj_ty: ty::t,\n+                        _additional_field_tys: [ty::t]) -> ValueRef {\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n@@ -717,10 +715,10 @@ fn process_bkwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n // calls inner.foo() with those arguments, and then returns the value returned\n // from that call.  (The inner object won't exist until run-time, but we know\n // its type statically.)\n-fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n-                       ty_params: &[ast::ty_param], inner_obj_ty: ty::t,\n+fn process_fwding_mthd(cx: @local_ctxt, sp: span, m: @ty::method,\n+                       ty_params: [ast::ty_param], inner_obj_ty: ty::t,\n                        backwarding_vtbl: ValueRef,\n-                       additional_field_tys: &[ty::t]) -> ValueRef {\n+                       additional_field_tys: [ty::t]) -> ValueRef {\n \n     // Create a local context that's aware of the name of the method we're\n     // creating.\n@@ -783,11 +781,11 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n     // create_object_body_type maybe should have a postcondition...\n \n     let cx_ccx = cx.ccx;\n-    check type_has_static_size(cx_ccx, body_ty);\n+    check (type_has_static_size(cx_ccx, body_ty));\n \n     llself_obj_body =\n         PointerCast(bcx, llself_obj_body,\n-                              T_ptr(type_of(cx_ccx, sp, body_ty)));\n+                    T_ptr(type_of(cx_ccx, sp, body_ty)));\n \n     // Now, reach into the body and grab the inner_obj.\n     let llinner_obj =\n@@ -873,8 +871,8 @@ fn process_fwding_mthd(cx: @local_ctxt, sp: &span, m: @ty::method,\n \n // create_object_body_type: Synthesize a big structural tuple type for an\n // object body: [tydesc, [typaram, ...], [field, ...], inner_obj].\n-fn create_object_body_type(tcx: &ty::ctxt, fields_ty: &[ty::t],\n-                           typarams_ty: &[ty::t],\n+fn create_object_body_type(tcx: ty::ctxt, fields_ty: [ty::t],\n+                           typarams_ty: [ty::t],\n                            maybe_inner_obj_ty: option::t<ty::t>) -> ty::t {\n \n     let tydesc_ty: ty::t = ty::mk_type(tcx);\n@@ -901,7 +899,7 @@ fn create_object_body_type(tcx: &ty::ctxt, fields_ty: &[ty::t],\n // process_normal_mthd: Create the contents of a normal vtable slot.  A helper\n // function for create_vtbl.\n fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n-                       ty_params: &[ast::ty_param]) -> ValueRef {\n+                       ty_params: [ast::ty_param]) -> ValueRef {\n \n     let llfnty = T_nil();\n     alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {"}, {"sha": "08279f07b8b1c1b3844309e1a966c86692831cb1", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -12,26 +12,25 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of, type_of_or_i8,\n import trans_build::*;\n import trans_common::*;\n \n-fn get_fill(bcx: &@block_ctxt, vptrptr: ValueRef) -> ValueRef {\n+fn get_fill(bcx: @block_ctxt, vptrptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_fill as int]))\n }\n-fn get_alloc(bcx: &@block_ctxt, vptrptr: ValueRef) -> ValueRef {\n+fn get_alloc(bcx: @block_ctxt, vptrptr: ValueRef) -> ValueRef {\n     Load(bcx, GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_alloc as int]))\n }\n-fn get_dataptr(bcx: &@block_ctxt, vptrptr: ValueRef, unit_ty: TypeRef) ->\n+fn get_dataptr(bcx: @block_ctxt, vptrptr: ValueRef, unit_ty: TypeRef) ->\n    ValueRef {\n     let ptr = GEPi(bcx, Load(bcx, vptrptr), [0, abi::vec_elt_elems as int]);\n     PointerCast(bcx, ptr, T_ptr(unit_ty))\n }\n \n-fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef) ->\n-   ValueRef {\n+fn pointer_add(bcx: @block_ctxt, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n     ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n }\n \n-fn alloc_raw(bcx: &@block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n+fn alloc_raw(bcx: @block_ctxt, fill: ValueRef, alloc: ValueRef) -> result {\n     let llvecty = T_opaque_vec();\n     let vecsize = Add(bcx, alloc, llsize_of(llvecty));\n     let {bcx: bcx, val: vecptr} =\n@@ -50,7 +49,7 @@ type alloc_result =\n      llunitsz: ValueRef,\n      llunitty: TypeRef};\n \n-fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n+fn alloc(bcx: @block_ctxt, vec_ty: ty::t, elts: uint) -> alloc_result {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let llvecty = T_vec(llunitty);\n@@ -62,7 +61,8 @@ fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n     let vptr = PointerCast(bcx, vptr, T_ptr(llvecty));\n \n     let r = alloc_ty(bcx, vec_ty);\n-    let vptrptr = r.val; bcx = r.bcx;\n+    let vptrptr = r.val;\n+    bcx = r.bcx;\n \n     Store(bcx, vptr, vptrptr);\n     add_clean_temp(bcx, vptrptr, vec_ty);\n@@ -73,7 +73,7 @@ fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, elts: uint) -> alloc_result {\n          llunitty: llunitty};\n }\n \n-fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n+fn duplicate(bcx: @block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n     let fill = get_fill(bcx, vptrptr);\n     let vptr = Load(bcx, vptrptr);\n     let size = Add(bcx, fill, llsize_of(T_opaque_vec()));\n@@ -85,7 +85,7 @@ fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n     Store(bcx, newptr, vptrptr);\n     ret bcx;\n }\n-fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t) ->\n+fn make_drop_glue(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t) ->\n    @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let vptr = Load(bcx, vptrptr);\n@@ -102,7 +102,7 @@ fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t) ->\n     ret next_cx;\n }\n \n-fn trans_vec(bcx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n+fn trans_vec(bcx: @block_ctxt, args: [@ast::expr], id: ast::node_id) ->\n    result {\n     let vec_ty = node_id_type(bcx_ccx(bcx), id);\n     let {bcx: bcx,\n@@ -127,7 +127,7 @@ fn trans_vec(bcx: &@block_ctxt, args: &[@ast::expr], id: ast::node_id) ->\n     }\n     ret rslt(bcx, vptr);\n }\n-fn trans_str(bcx: &@block_ctxt, s: str) -> result {\n+fn trans_str(bcx: @block_ctxt, s: str) -> result {\n     let veclen = std::str::byte_len(s) + 1u; // +1 for \\0\n     let {bcx: bcx, val: sptr, _} =\n         alloc(bcx, ty::mk_str(bcx_tcx(bcx)), veclen);\n@@ -140,7 +140,7 @@ fn trans_str(bcx: &@block_ctxt, s: str) -> result {\n     ret rslt(bcx, sptr);\n }\n \n-fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n+fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                 rhsptr: ValueRef) -> result {\n     // Cast to opaque interior vector types if necessary.\n     let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n@@ -179,7 +179,7 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let bcx =\n         iter_vec_raw(bcx, rhsptr, vec_ty, rfill,\n                      // We have to increment by the dynamically-computed size.\n-                     {|&bcx, addr, _ty|\n+                     {|bcx, addr, _ty|\n                          let write_ptr = Load(bcx, write_ptr_ptr);\n                          let bcx =\n                              copy_val(bcx, INIT, write_ptr,\n@@ -193,8 +193,8 @@ fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     ret rslt(bcx, C_nil());\n }\n \n-fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-                        vals: &[@ast::expr]) -> @block_ctxt {\n+fn trans_append_literal(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+                        vals: [@ast::expr]) -> @block_ctxt {\n     let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let ti = none;\n     let {bcx: bcx, val: td} =\n@@ -214,9 +214,8 @@ fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n     ret bcx;\n }\n \n-fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n-             rhsptr: ValueRef)\n-   -> result {\n+fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n+             rhsptr: ValueRef) -> result {\n     let strings =\n         alt ty::struct(bcx_tcx(bcx), vec_ty) {\n           ty::ty_str. { true }\n@@ -239,15 +238,16 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     let write_ptr_ptr =\n         do_spill_noroot(bcx, get_dataptr(bcx, new_vec_ptr_ptr, llunitty));\n     let copy_fn =\n-        bind fn (bcx: &@block_ctxt, addr: ValueRef, _ty: ty::t,\n+        bind fn (bcx: @block_ctxt, addr: ValueRef, _ty: ty::t,\n                  write_ptr_ptr: ValueRef, unit_ty: ty::t, llunitsz: ValueRef)\n                 -> @block_ctxt {\n                  let write_ptr = Load(bcx, write_ptr_ptr);\n                  let bcx =\n                      copy_val(bcx, INIT, write_ptr,\n                               load_if_immediate(bcx, addr, unit_ty), unit_ty);\n-                 let incr = ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) ?\n-                     llunitsz : C_int(1);\n+                 let incr =\n+                     ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) ?\n+                         llunitsz : C_int(1);\n                  Store(bcx, InBoundsGEP(bcx, write_ptr, [incr]),\n                        write_ptr_ptr);\n                  ret bcx;\n@@ -258,12 +258,12 @@ fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n     ret rslt(bcx, new_vec_ptr_ptr);\n }\n \n-type val_and_ty_fn = fn(&@block_ctxt, ValueRef, ty::t) -> result;\n+type val_and_ty_fn = fn(@block_ctxt, ValueRef, ty::t) -> result;\n \n-type iter_vec_block = block(&@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n+type iter_vec_block = block(@block_ctxt, ValueRef, ty::t) -> @block_ctxt;\n \n-fn iter_vec_raw(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-                fill: ValueRef, f: &iter_vec_block) -> @block_ctxt {\n+fn iter_vec_raw(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+                fill: ValueRef, f: iter_vec_block) -> @block_ctxt {\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let llunitty = type_of_or_i8(bcx, unit_ty);\n     let {bcx: bcx, val: unit_sz} = size_of(bcx, unit_ty);\n@@ -289,14 +289,14 @@ fn iter_vec_raw(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n         if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n             unit_sz\n         } else { C_int(1) };\n-    AddIncomingToPhi(data_ptr, [InBoundsGEP(body_cx, data_ptr,\n-                                            [increment])], [body_cx.llbb]);\n+    AddIncomingToPhi(data_ptr, [InBoundsGEP(body_cx, data_ptr, [increment])],\n+                     [body_cx.llbb]);\n     Br(body_cx, header_cx.llbb);\n     ret next_cx;\n }\n \n-fn iter_vec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n-            f: &iter_vec_block) -> @block_ctxt {\n+fn iter_vec(bcx: @block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+            f: iter_vec_block) -> @block_ctxt {\n     vptrptr = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_vec())));\n     ret iter_vec_raw(bcx, vptrptr, vec_ty, get_fill(bcx, vptrptr), f);\n }"}, {"sha": "d71ac7ac92e0d5254d1d92cb77e965626c8f68bc", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -70,84 +70,84 @@ fn empty_ann(num_vars: uint) -> ts_ann {\n           states: empty_states(num_vars)};\n }\n \n-fn get_pre(p: &pre_and_post) -> precond { ret p.precondition; }\n+fn get_pre(p: pre_and_post) -> precond { ret p.precondition; }\n \n-fn get_post(p: &pre_and_post) -> postcond { ret p.postcondition; }\n+fn get_post(p: pre_and_post) -> postcond { ret p.postcondition; }\n \n-fn difference(p1: &precond, p2: &precond) -> bool {\n+fn difference(p1: precond, p2: precond) -> bool {\n     ret tritv_difference(p1, p2);\n }\n \n-fn union(p1: &precond, p2: &precond) -> bool { ret tritv_union(p1, p2); }\n+fn union(p1: precond, p2: precond) -> bool { ret tritv_union(p1, p2); }\n \n-fn intersect(p1: &precond, p2: &precond) -> bool {\n+fn intersect(p1: precond, p2: precond) -> bool {\n     ret tritv_intersect(p1, p2);\n }\n \n-fn pps_len(p: &pre_and_post) -> uint {\n+fn pps_len(p: pre_and_post) -> uint {\n     // gratuitous check\n \n     assert (p.precondition.nbits == p.postcondition.nbits);\n     ret p.precondition.nbits;\n }\n \n-fn require(i: uint, p: &pre_and_post) {\n+fn require(i: uint, p: pre_and_post) {\n     // sets the ith bit in p's pre\n     tritv_set(i, p.precondition, ttrue);\n }\n \n-fn require_and_preserve(i: uint, p: &pre_and_post) {\n+fn require_and_preserve(i: uint, p: pre_and_post) {\n     // sets the ith bit in p's pre and post\n     tritv_set(i, p.precondition, ttrue);\n     tritv_set(i, p.postcondition, ttrue);\n }\n \n-fn set_in_postcond(i: uint, p: &pre_and_post) -> bool {\n+fn set_in_postcond(i: uint, p: pre_and_post) -> bool {\n     // sets the ith bit in p's post\n     ret set_in_postcond_(i, p.postcondition);\n }\n \n-fn set_in_postcond_(i: uint, p: &postcond) -> bool {\n+fn set_in_postcond_(i: uint, p: postcond) -> bool {\n     let was_set = tritv_get(p, i);\n     tritv_set(i, p, ttrue);\n     ret was_set != ttrue;\n }\n \n-fn set_in_poststate(i: uint, s: &pre_and_post_state) -> bool {\n+fn set_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n     // sets the ith bit in p's post\n     ret set_in_poststate_(i, s.poststate);\n }\n \n-fn set_in_poststate_(i: uint, p: &poststate) -> bool {\n+fn set_in_poststate_(i: uint, p: poststate) -> bool {\n     let was_set = tritv_get(p, i);\n     tritv_set(i, p, ttrue);\n     ret was_set != ttrue;\n \n }\n \n-fn clear_in_poststate(i: uint, s: &pre_and_post_state) -> bool {\n+fn clear_in_poststate(i: uint, s: pre_and_post_state) -> bool {\n     // sets the ith bit in p's post\n     ret clear_in_poststate_(i, s.poststate);\n }\n \n-fn clear_in_poststate_(i: uint, s: &poststate) -> bool {\n+fn clear_in_poststate_(i: uint, s: poststate) -> bool {\n     let was_set = tritv_get(s, i);\n     tritv_set(i, s, tfalse);\n     ret was_set != tfalse;\n }\n \n-fn clear_in_prestate(i: uint, s: &pre_and_post_state) -> bool {\n+fn clear_in_prestate(i: uint, s: pre_and_post_state) -> bool {\n     // sets the ith bit in p's pre\n     ret clear_in_prestate_(i, s.prestate);\n }\n \n-fn clear_in_prestate_(i: uint, s: &prestate) -> bool {\n+fn clear_in_prestate_(i: uint, s: prestate) -> bool {\n     let was_set = tritv_get(s, i);\n     tritv_set(i, s, tfalse);\n     ret was_set != tfalse;\n }\n \n-fn clear_in_postcond(i: uint, s: &pre_and_post) -> bool {\n+fn clear_in_postcond(i: uint, s: pre_and_post) -> bool {\n     // sets the ith bit in p's post\n     let was_set = tritv_get(s.postcondition, i);\n     tritv_set(i, s.postcondition, tfalse);\n@@ -156,72 +156,72 @@ fn clear_in_postcond(i: uint, s: &pre_and_post) -> bool {\n \n // Sets all the bits in a's precondition to equal the\n // corresponding bit in p's precondition.\n-fn set_precondition(a: ts_ann, p: &precond) {\n+fn set_precondition(a: ts_ann, p: precond) {\n     tritv_copy(a.conditions.precondition, p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_postcondition(a: ts_ann, p: &postcond) {\n+fn set_postcondition(a: ts_ann, p: postcond) {\n     tritv_copy(a.conditions.postcondition, p);\n }\n \n \n // Sets all the bits in a's prestate to equal the\n // corresponding bit in p's prestate.\n-fn set_prestate(a: ts_ann, p: &prestate) -> bool {\n+fn set_prestate(a: ts_ann, p: prestate) -> bool {\n     ret tritv_copy(a.states.prestate, p);\n }\n \n \n // Sets all the bits in a's postcondition to equal the\n // corresponding bit in p's postcondition.\n-fn set_poststate(a: ts_ann, p: &poststate) -> bool {\n+fn set_poststate(a: ts_ann, p: poststate) -> bool {\n     ret tritv_copy(a.states.poststate, p);\n }\n \n \n // Set all the bits in p that are set in new\n-fn extend_prestate(p: &prestate, new: &poststate) -> bool {\n+fn extend_prestate(p: prestate, new: poststate) -> bool {\n     ret tritv_union(p, new);\n }\n \n \n // Set all the bits in p that are set in new\n-fn extend_poststate(p: &poststate, new: &poststate) -> bool {\n+fn extend_poststate(p: poststate, new: poststate) -> bool {\n     ret tritv_union(p, new);\n }\n \n // Sets the given bit in p to \"don't care\"\n // FIXME: is this correct?\n-fn relax_prestate(i: uint, p: &prestate) -> bool {\n+fn relax_prestate(i: uint, p: prestate) -> bool {\n     let was_set = tritv_get(p, i);\n     tritv_set(i, p, dont_care);\n     ret was_set != dont_care;\n }\n \n // Clears the given bit in p\n-fn relax_poststate(i: uint, p: &poststate) -> bool {\n+fn relax_poststate(i: uint, p: poststate) -> bool {\n     ret relax_prestate(i, p);\n }\n \n // Clears the given bit in p\n-fn relax_precond(i: uint, p: &precond) { relax_prestate(i, p); }\n+fn relax_precond(i: uint, p: precond) { relax_prestate(i, p); }\n \n // Sets all the bits in p to \"don't care\"\n-fn clear(p: &precond) { tritv_clear(p); }\n+fn clear(p: precond) { tritv_clear(p); }\n \n // Sets all the bits in p to true\n-fn set(p: &precond) { tritv_set_all(p); }\n+fn set(p: precond) { tritv_set_all(p); }\n \n-fn ann_precond(a: &ts_ann) -> precond { ret a.conditions.precondition; }\n+fn ann_precond(a: ts_ann) -> precond { ret a.conditions.precondition; }\n \n-fn ann_prestate(a: &ts_ann) -> prestate { ret a.states.prestate; }\n+fn ann_prestate(a: ts_ann) -> prestate { ret a.states.prestate; }\n \n-fn ann_poststate(a: &ts_ann) -> poststate { ret a.states.poststate; }\n+fn ann_poststate(a: ts_ann) -> poststate { ret a.states.poststate; }\n \n-fn pp_clone(p: &pre_and_post) -> pre_and_post {\n+fn pp_clone(p: pre_and_post) -> pre_and_post {\n     ret @{precondition: clone(p.precondition),\n           postcondition: clone(p.postcondition)};\n }"}, {"sha": "a3e6be269691e0fe24442d3c6b2c916bca5f2fd3", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -25,11 +25,11 @@ import aux::crate_ctxt;\n import aux::add_node;\n import middle::tstate::ann::empty_ann;\n \n-fn collect_ids_expr(e: &@expr, rs: @mutable [node_id]) { *rs += [e.id]; }\n+fn collect_ids_expr(e: @expr, rs: @mutable [node_id]) { *rs += [e.id]; }\n \n-fn collect_ids_block(b: &blk, rs: @mutable [node_id]) { *rs += [b.node.id]; }\n+fn collect_ids_block(b: blk, rs: @mutable [node_id]) { *rs += [b.node.id]; }\n \n-fn collect_ids_stmt(s: &@stmt, rs: @mutable [node_id]) {\n+fn collect_ids_stmt(s: @stmt, rs: @mutable [node_id]) {\n     alt s.node {\n       stmt_decl(_, id) {\n         log \"node_id \" + int::str(id);\n@@ -45,12 +45,12 @@ fn collect_ids_stmt(s: &@stmt, rs: @mutable [node_id]) {\n     }\n }\n \n-fn collect_ids_local(l: &@local, rs: @mutable [node_id]) {\n+fn collect_ids_local(l: @local, rs: @mutable [node_id]) {\n     *rs += pat_binding_ids(l.node.pat);\n }\n \n-fn node_ids_in_fn(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n-                  id: node_id, rs: @mutable [node_id]) {\n+fn node_ids_in_fn(f: _fn, tps: [ty_param], sp: span, i: fn_ident, id: node_id,\n+                  rs: @mutable [node_id]) {\n     let collect_ids =\n         visit::mk_simple_visitor(@{visit_expr: bind collect_ids_expr(_, rs),\n                                    visit_block: bind collect_ids_block(_, rs),\n@@ -60,28 +60,28 @@ fn node_ids_in_fn(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n     visit::visit_fn(f, tps, sp, i, id, (), collect_ids);\n }\n \n-fn init_vecs(ccx: &crate_ctxt, node_ids: &[node_id], len: uint) {\n+fn init_vecs(ccx: crate_ctxt, node_ids: [node_id], len: uint) {\n     for i: node_id in node_ids {\n         log int::str(i) + \" |-> \" + uint::str(len);\n         add_node(ccx, i, empty_ann(len));\n     }\n }\n \n-fn visit_fn(ccx: &crate_ctxt, num_constraints: uint, f: &_fn,\n-            tps: &[ty_param], sp: &span, i: &fn_ident, id: node_id) {\n+fn visit_fn(ccx: crate_ctxt, num_constraints: uint, f: _fn, tps: [ty_param],\n+            sp: span, i: fn_ident, id: node_id) {\n     let node_ids: @mutable [node_id] = @mutable [];\n     node_ids_in_fn(f, tps, sp, i, id, node_ids);\n     let node_id_vec = *node_ids;\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(ccx: &crate_ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n-                  i: &fn_ident, id: node_id) {\n+fn annotate_in_fn(ccx: crate_ctxt, f: _fn, tps: [ty_param], sp: span,\n+                  i: fn_ident, id: node_id) {\n     let f_info = get_fn_info(ccx, id);\n     visit_fn(ccx, num_constraints(f_info), f, tps, sp, i, id);\n }\n \n-fn annotate_crate(ccx: &crate_ctxt, crate: &crate) {\n+fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n     let do_ann =\n         visit::mk_simple_visitor(@{visit_fn:\n                                        bind annotate_in_fn(ccx, _, _, _, _, _)"}, {"sha": "b873b9d62332b17afc18671cb73d40509dcee6a4", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 113, "deletions": 117, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -59,7 +59,7 @@ fn def_id_to_str(d: def_id) -> str {\n     ret int::str(d.crate) + \",\" + int::str(d.node);\n }\n \n-fn comma_str(args: &[@constr_arg_use]) -> str {\n+fn comma_str(args: [@constr_arg_use]) -> str {\n     let rslt = \"\";\n     let comma = false;\n     for a: @constr_arg_use in args {\n@@ -73,7 +73,7 @@ fn comma_str(args: &[@constr_arg_use]) -> str {\n     ret rslt;\n }\n \n-fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n+fn constraint_to_str(tcx: ty::ctxt, c: sp_constr) -> str {\n     alt c.node {\n       ninit(_, i) {\n         ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n@@ -85,7 +85,7 @@ fn constraint_to_str(tcx: &ty::ctxt, c: &sp_constr) -> str {\n     }\n }\n \n-fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n+fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n     let s = \"\";\n     let comma = false;\n     for p: norm_constraint in constraints(fcx) {\n@@ -102,10 +102,10 @@ fn tritv_to_str(fcx: fn_ctxt, v: &tritv::t) -> str {\n     ret s;\n }\n \n-fn log_tritv(fcx: &fn_ctxt, v: &tritv::t) { log tritv_to_str(fcx, v); }\n+fn log_tritv(fcx: fn_ctxt, v: tritv::t) { log tritv_to_str(fcx, v); }\n \n-fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n-                           actual: &tritv::t) -> str {\n+fn first_difference_string(fcx: fn_ctxt, expected: tritv::t, actual: tritv::t)\n+   -> str {\n     let s: str = \"\";\n     for c: norm_constraint in constraints(fcx) {\n         if tritv_get(expected, c.bit_num) == ttrue &&\n@@ -118,7 +118,7 @@ fn first_difference_string(fcx: &fn_ctxt, expected: &tritv::t,\n \n fn log_tritv_err(fcx: fn_ctxt, v: tritv::t) { log_err tritv_to_str(fcx, v); }\n \n-fn tos(v: &[uint]) -> str {\n+fn tos(v: [uint]) -> str {\n     let rslt = \"\";\n     for i: uint in v {\n         if i == 0u {\n@@ -128,11 +128,11 @@ fn tos(v: &[uint]) -> str {\n     ret rslt;\n }\n \n-fn log_cond(v: &[uint]) { log tos(v); }\n+fn log_cond(v: [uint]) { log tos(v); }\n \n-fn log_cond_err(v: &[uint]) { log_err tos(v); }\n+fn log_cond_err(v: [uint]) { log_err tos(v); }\n \n-fn log_pp(pp: &pre_and_post) {\n+fn log_pp(pp: pre_and_post) {\n     let p1 = tritv::to_vec(pp.precondition);\n     let p2 = tritv::to_vec(pp.postcondition);\n     log \"pre:\";\n@@ -141,7 +141,7 @@ fn log_pp(pp: &pre_and_post) {\n     log_cond(p2);\n }\n \n-fn log_pp_err(pp: &pre_and_post) {\n+fn log_pp_err(pp: pre_and_post) {\n     let p1 = tritv::to_vec(pp.precondition);\n     let p2 = tritv::to_vec(pp.postcondition);\n     log_err \"pre:\";\n@@ -150,7 +150,7 @@ fn log_pp_err(pp: &pre_and_post) {\n     log_cond_err(p2);\n }\n \n-fn log_states(pp: &pre_and_post_state) {\n+fn log_states(pp: pre_and_post_state) {\n     let p1 = tritv::to_vec(pp.prestate);\n     let p2 = tritv::to_vec(pp.poststate);\n     log \"prestate:\";\n@@ -159,7 +159,7 @@ fn log_states(pp: &pre_and_post_state) {\n     log_cond(p2);\n }\n \n-fn log_states_err(pp: &pre_and_post_state) {\n+fn log_states_err(pp: pre_and_post_state) {\n     let p1 = tritv::to_vec(pp.prestate);\n     let p2 = tritv::to_vec(pp.poststate);\n     log_err \"prestate:\";\n@@ -168,7 +168,7 @@ fn log_states_err(pp: &pre_and_post_state) {\n     log_cond_err(p2);\n }\n \n-fn print_ident(i: &ident) { log \" \" + i + \" \"; }\n+fn print_ident(i: ident) { log \" \" + i + \" \"; }\n \n fn print_idents(idents: &mutable [ident]) {\n     if vec::len::<ident>(idents) == 0u { ret; }\n@@ -281,11 +281,11 @@ type fn_info =\n      i_diverge: tsconstr,\n      used_vars: @mutable [node_id]};\n \n-fn tsconstr_to_def_id(t: &tsconstr) -> def_id {\n+fn tsconstr_to_def_id(t: tsconstr) -> def_id {\n     alt t { ninit(id, _) { local_def(id) } npred(_, id, _) { id } }\n }\n \n-fn tsconstr_to_node_id(t: &tsconstr) -> node_id {\n+fn tsconstr_to_node_id(t: tsconstr) -> node_id {\n     alt t {\n       ninit(id, _) { id }\n       npred(_, id, _) { fail \"tsconstr_to_node_id called on pred constraint\" }\n@@ -304,28 +304,28 @@ type fn_ctxt =\n \n type crate_ctxt = {tcx: ty::ctxt, node_anns: node_ann_table, fm: fn_info_map};\n \n-fn get_fn_info(ccx: &crate_ctxt, id: node_id) -> fn_info {\n+fn get_fn_info(ccx: crate_ctxt, id: node_id) -> fn_info {\n     assert (ccx.fm.contains_key(id));\n     ret ccx.fm.get(id);\n }\n \n-fn add_node(ccx: &crate_ctxt, i: node_id, a: &ts_ann) {\n+fn add_node(ccx: crate_ctxt, i: node_id, a: ts_ann) {\n     let sz = vec::len(*ccx.node_anns);\n     if sz <= i as uint {\n         vec::grow_mut(*ccx.node_anns, (i as uint) - sz + 1u, empty_ann(0u));\n     }\n     ccx.node_anns[i] = a;\n }\n \n-fn get_ts_ann(ccx: &crate_ctxt, i: node_id) -> option::t<ts_ann> {\n+fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option::t<ts_ann> {\n     if i as uint < vec::len(*ccx.node_anns) {\n         ret some::<ts_ann>(ccx.node_anns[i]);\n     } else { ret none::<ts_ann>; }\n }\n \n \n /********* utils ********/\n-fn node_id_to_ts_ann(ccx: &crate_ctxt, id: node_id) -> ts_ann {\n+fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n     alt get_ts_ann(ccx, id) {\n       none. {\n         log_err \"node_id_to_ts_ann: no ts_ann for node_id \" + int::str(id);\n@@ -335,12 +335,12 @@ fn node_id_to_ts_ann(ccx: &crate_ctxt, id: node_id) -> ts_ann {\n     }\n }\n \n-fn node_id_to_poststate(ccx: &crate_ctxt, id: node_id) -> poststate {\n+fn node_id_to_poststate(ccx: crate_ctxt, id: node_id) -> poststate {\n     log \"node_id_to_poststate\";\n     ret node_id_to_ts_ann(ccx, id).states.poststate;\n }\n \n-fn stmt_to_ann(ccx: &crate_ctxt, s: &stmt) -> ts_ann {\n+fn stmt_to_ann(ccx: crate_ctxt, s: stmt) -> ts_ann {\n     log \"stmt_to_ann\";\n     alt s.node {\n       stmt_decl(_, id) { ret node_id_to_ts_ann(ccx, id); }\n@@ -354,25 +354,25 @@ fn stmt_to_ann(ccx: &crate_ctxt, s: &stmt) -> ts_ann {\n \n \n /* fails if e has no annotation */\n-fn expr_states(ccx: &crate_ctxt, e: @expr) -> pre_and_post_state {\n+fn expr_states(ccx: crate_ctxt, e: @expr) -> pre_and_post_state {\n     log \"expr_states\";\n     ret node_id_to_ts_ann(ccx, e.id).states;\n }\n \n \n /* fails if e has no annotation */\n-fn expr_pp(ccx: &crate_ctxt, e: @expr) -> pre_and_post {\n+fn expr_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n     log \"expr_pp\";\n     ret node_id_to_ts_ann(ccx, e.id).conditions;\n }\n \n-fn stmt_pp(ccx: &crate_ctxt, s: &stmt) -> pre_and_post {\n+fn stmt_pp(ccx: crate_ctxt, s: stmt) -> pre_and_post {\n     ret stmt_to_ann(ccx, s).conditions;\n }\n \n \n /* fails if b has no annotation */\n-fn block_pp(ccx: &crate_ctxt, b: &blk) -> pre_and_post {\n+fn block_pp(ccx: crate_ctxt, b: blk) -> pre_and_post {\n     log \"block_pp\";\n     ret node_id_to_ts_ann(ccx, b.node.id).conditions;\n }\n@@ -382,124 +382,122 @@ fn clear_pp(pp: pre_and_post) {\n     ann::clear(pp.postcondition);\n }\n \n-fn clear_precond(ccx: &crate_ctxt, id: node_id) {\n+fn clear_precond(ccx: crate_ctxt, id: node_id) {\n     let pp = node_id_to_ts_ann(ccx, id);\n     ann::clear(pp.conditions.precondition);\n }\n \n-fn block_states(ccx: &crate_ctxt, b: &blk) -> pre_and_post_state {\n+fn block_states(ccx: crate_ctxt, b: blk) -> pre_and_post_state {\n     log \"block_states\";\n     ret node_id_to_ts_ann(ccx, b.node.id).states;\n }\n \n-fn stmt_states(ccx: &crate_ctxt, s: &stmt) -> pre_and_post_state {\n+fn stmt_states(ccx: crate_ctxt, s: stmt) -> pre_and_post_state {\n     ret stmt_to_ann(ccx, s).states;\n }\n \n-fn expr_precond(ccx: &crate_ctxt, e: @expr) -> precond {\n+fn expr_precond(ccx: crate_ctxt, e: @expr) -> precond {\n     ret expr_pp(ccx, e).precondition;\n }\n \n-fn expr_postcond(ccx: &crate_ctxt, e: @expr) -> postcond {\n+fn expr_postcond(ccx: crate_ctxt, e: @expr) -> postcond {\n     ret expr_pp(ccx, e).postcondition;\n }\n \n-fn expr_prestate(ccx: &crate_ctxt, e: @expr) -> prestate {\n+fn expr_prestate(ccx: crate_ctxt, e: @expr) -> prestate {\n     ret expr_states(ccx, e).prestate;\n }\n \n-fn expr_poststate(ccx: &crate_ctxt, e: @expr) -> poststate {\n+fn expr_poststate(ccx: crate_ctxt, e: @expr) -> poststate {\n     ret expr_states(ccx, e).poststate;\n }\n \n-fn stmt_precond(ccx: &crate_ctxt, s: &stmt) -> precond {\n+fn stmt_precond(ccx: crate_ctxt, s: stmt) -> precond {\n     ret stmt_pp(ccx, s).precondition;\n }\n \n-fn stmt_postcond(ccx: &crate_ctxt, s: &stmt) -> postcond {\n+fn stmt_postcond(ccx: crate_ctxt, s: stmt) -> postcond {\n     ret stmt_pp(ccx, s).postcondition;\n }\n \n-fn states_to_poststate(ss: &pre_and_post_state) -> poststate {\n+fn states_to_poststate(ss: pre_and_post_state) -> poststate {\n     ret ss.poststate;\n }\n \n-fn stmt_prestate(ccx: &crate_ctxt, s: &stmt) -> prestate {\n+fn stmt_prestate(ccx: crate_ctxt, s: stmt) -> prestate {\n     ret stmt_states(ccx, s).prestate;\n }\n \n-fn stmt_poststate(ccx: &crate_ctxt, s: &stmt) -> poststate {\n+fn stmt_poststate(ccx: crate_ctxt, s: stmt) -> poststate {\n     ret stmt_states(ccx, s).poststate;\n }\n \n-fn block_precond(ccx: &crate_ctxt, b: &blk) -> precond {\n+fn block_precond(ccx: crate_ctxt, b: blk) -> precond {\n     ret block_pp(ccx, b).precondition;\n }\n \n-fn block_postcond(ccx: &crate_ctxt, b: &blk) -> postcond {\n+fn block_postcond(ccx: crate_ctxt, b: blk) -> postcond {\n     ret block_pp(ccx, b).postcondition;\n }\n \n-fn block_prestate(ccx: &crate_ctxt, b: &blk) -> prestate {\n+fn block_prestate(ccx: crate_ctxt, b: blk) -> prestate {\n     ret block_states(ccx, b).prestate;\n }\n \n-fn block_poststate(ccx: &crate_ctxt, b: &blk) -> poststate {\n+fn block_poststate(ccx: crate_ctxt, b: blk) -> poststate {\n     ret block_states(ccx, b).poststate;\n }\n \n-fn set_prestate_ann(ccx: &crate_ctxt, id: node_id, pre: &prestate) -> bool {\n+fn set_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n     log \"set_prestate_ann\";\n     ret set_prestate(node_id_to_ts_ann(ccx, id), pre);\n }\n \n-fn extend_prestate_ann(ccx: &crate_ctxt, id: node_id, pre: &prestate) ->\n-   bool {\n+fn extend_prestate_ann(ccx: crate_ctxt, id: node_id, pre: prestate) -> bool {\n     log \"extend_prestate_ann\";\n     ret extend_prestate(node_id_to_ts_ann(ccx, id).states.prestate, pre);\n }\n \n-fn set_poststate_ann(ccx: &crate_ctxt, id: node_id, post: &poststate) ->\n-   bool {\n+fn set_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) -> bool {\n     log \"set_poststate_ann\";\n     ret set_poststate(node_id_to_ts_ann(ccx, id), post);\n }\n \n-fn extend_poststate_ann(ccx: &crate_ctxt, id: node_id, post: &poststate) ->\n+fn extend_poststate_ann(ccx: crate_ctxt, id: node_id, post: poststate) ->\n    bool {\n     log \"extend_poststate_ann\";\n     ret extend_poststate(node_id_to_ts_ann(ccx, id).states.poststate, post);\n }\n \n-fn set_pre_and_post(ccx: &crate_ctxt, id: node_id, pre: &precond,\n-                    post: &postcond) {\n+fn set_pre_and_post(ccx: crate_ctxt, id: node_id, pre: precond,\n+                    post: postcond) {\n     log \"set_pre_and_post\";\n     let t = node_id_to_ts_ann(ccx, id);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n-fn copy_pre_post(ccx: &crate_ctxt, id: node_id, sub: &@expr) {\n+fn copy_pre_post(ccx: crate_ctxt, id: node_id, sub: @expr) {\n     log \"set_pre_and_post\";\n     let p = expr_pp(ccx, sub);\n     copy_pre_post_(ccx, id, p.precondition, p.postcondition);\n }\n \n-fn copy_pre_post_(ccx: &crate_ctxt, id: node_id, pre: &prestate,\n-                  post: &poststate) {\n+fn copy_pre_post_(ccx: crate_ctxt, id: node_id, pre: prestate,\n+                  post: poststate) {\n     log \"set_pre_and_post\";\n     let t = node_id_to_ts_ann(ccx, id);\n     set_precondition(t, pre);\n     set_postcondition(t, post);\n }\n \n /* sets all bits to *1* */\n-fn set_postcond_false(ccx: &crate_ctxt, id: node_id) {\n+fn set_postcond_false(ccx: crate_ctxt, id: node_id) {\n     let p = node_id_to_ts_ann(ccx, id);\n     ann::set(p.conditions.postcondition);\n }\n \n-fn pure_exp(ccx: &crate_ctxt, id: node_id, p: &prestate) -> bool {\n+fn pure_exp(ccx: crate_ctxt, id: node_id, p: prestate) -> bool {\n     ret set_prestate_ann(ccx, id, p) | set_poststate_ann(ccx, id, p);\n }\n \n@@ -513,21 +511,21 @@ fn new_crate_ctxt(cx: ty::ctxt) -> crate_ctxt {\n /* Use e's type to determine whether it returns.\n  If it has a function type with a ! annotation,\n the answer is noreturn. */\n-fn controlflow_expr(ccx: &crate_ctxt, e: @expr) -> controlflow {\n+fn controlflow_expr(ccx: crate_ctxt, e: @expr) -> controlflow {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, e.id)) {\n       ty::ty_fn(_, _, _, cf, _) { ret cf; }\n       _ { ret return; }\n     }\n }\n \n-fn constraints_expr(cx: &ty::ctxt, e: @expr) -> [@ty::constr] {\n+fn constraints_expr(cx: ty::ctxt, e: @expr) -> [@ty::constr] {\n     alt ty::struct(cx, ty::node_id_to_type(cx, e.id)) {\n       ty::ty_fn(_, _, _, _, cs) { ret cs; }\n       _ { ret []; }\n     }\n }\n \n-fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n+fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n     alt cx.def_map.find(id) {\n       none. {\n         log_err \"node_id_to_def: node_id \" + int::str(id) + \" has no def\";\n@@ -537,11 +535,11 @@ fn node_id_to_def_strict(cx: &ty::ctxt, id: node_id) -> def {\n     }\n }\n \n-fn node_id_to_def(ccx: &crate_ctxt, id: node_id) -> option::t<def> {\n+fn node_id_to_def(ccx: crate_ctxt, id: node_id) -> option::t<def> {\n     ret ccx.tcx.def_map.find(id);\n }\n \n-fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n+fn norm_a_constraint(id: def_id, c: constraint) -> [norm_constraint] {\n     alt c {\n       cinit(n, sp, i) {\n         ret [{bit_num: n, c: respan(sp, ninit(id.node, i))}];\n@@ -561,7 +559,7 @@ fn norm_a_constraint(id: def_id, c: &constraint) -> [norm_constraint] {\n \n // Tried to write this as an iterator, but I got a\n // non-exhaustive match in trans.\n-fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n+fn constraints(fcx: fn_ctxt) -> [norm_constraint] {\n     let rslt: [norm_constraint] = [];\n     for each p: @{key: def_id, val: constraint} in\n              fcx.enclosing.constrs.items() {\n@@ -573,13 +571,13 @@ fn constraints(fcx: &fn_ctxt) -> [norm_constraint] {\n // FIXME\n // Would rather take an immutable vec as an argument,\n // should freeze it at some earlier point.\n-fn match_args(fcx: &fn_ctxt, occs: &@mutable [pred_args],\n-              occ: &[@constr_arg_use]) -> uint {\n+fn match_args(fcx: fn_ctxt, occs: @mutable [pred_args],\n+              occ: [@constr_arg_use]) -> uint {\n     log \"match_args: looking at \" +\n-            constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, occ);\n+            constr_args_to_str(fn (i: inst) -> str { ret i.ident; }, occ);\n     for pd: pred_args in *occs {\n         log \"match_args: candidate \" + pred_args_to_str(pd);\n-        fn eq(p: &inst, q: &inst) -> bool { ret p.node == q.node; }\n+        fn eq(p: inst, q: inst) -> bool { ret p.node == q.node; }\n         if ty::args_eq(eq, pd.node.args, occ) { ret pd.node.bit_num; }\n     }\n     fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");\n@@ -595,7 +593,7 @@ fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n     }\n }\n \n-fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n+fn expr_to_constr_arg(tcx: ty::ctxt, e: @expr) -> @constr_arg_use {\n     alt e.node {\n       expr_path(p) {\n         alt tcx.def_map.find(e.id) {\n@@ -623,14 +621,14 @@ fn expr_to_constr_arg(tcx: ty::ctxt, e: &@expr) -> @constr_arg_use {\n     }\n }\n \n-fn exprs_to_constr_args(tcx: ty::ctxt, args: &[@expr]) -> [@constr_arg_use] {\n+fn exprs_to_constr_args(tcx: ty::ctxt, args: [@expr]) -> [@constr_arg_use] {\n     let f = bind expr_to_constr_arg(tcx, _);\n     let rslt: [@constr_arg_use] = [];\n     for e: @expr in args { rslt += [f(e)]; }\n     rslt\n }\n \n-fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n+fn expr_to_constr(tcx: ty::ctxt, e: @expr) -> sp_constr {\n     alt e.node {\n       expr_call(operator, args) {\n         alt operator.node {\n@@ -654,22 +652,22 @@ fn expr_to_constr(tcx: ty::ctxt, e: &@expr) -> sp_constr {\n     }\n }\n \n-fn pred_args_to_str(p: &pred_args) -> str {\n+fn pred_args_to_str(p: pred_args) -> str {\n     \"<\" + uint::str(p.node.bit_num) + \", \" +\n-        constr_args_to_str(fn (i: &inst) -> str { ret i.ident; }, p.node.args)\n+        constr_args_to_str(fn (i: inst) -> str { ret i.ident; }, p.node.args)\n         + \">\"\n }\n \n-fn substitute_constr_args(cx: &ty::ctxt, actuals: &[@expr], c: &@ty::constr)\n-   -> tsconstr {\n+fn substitute_constr_args(cx: ty::ctxt, actuals: [@expr], c: @ty::constr) ->\n+   tsconstr {\n     let rslt: [@constr_arg_use] = [];\n     for a: @constr_arg in c.node.args {\n         rslt += [substitute_arg(cx, actuals, a)];\n     }\n     ret npred(c.node.path, c.node.id, rslt);\n }\n \n-fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n+fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n    @constr_arg_use {\n     let num_actuals = vec::len(actuals);\n     alt a.node {\n@@ -685,8 +683,8 @@ fn substitute_arg(cx: &ty::ctxt, actuals: &[@expr], a: @constr_arg) ->\n     }\n }\n \n-fn pred_args_matches(pattern: &[constr_arg_general_<inst>], desc: &pred_args)\n-   -> bool {\n+fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n+   bool {\n     let i = 0u;\n     for c: @constr_arg_use in desc.node.args {\n         let n = pattern[i];\n@@ -710,8 +708,8 @@ fn pred_args_matches(pattern: &[constr_arg_general_<inst>], desc: &pred_args)\n     ret true;\n }\n \n-fn find_instance_(pattern: &[constr_arg_general_<inst>], descs: &[pred_args])\n-   -> option::t<uint> {\n+fn find_instance_(pattern: [constr_arg_general_<inst>], descs: [pred_args]) ->\n+   option::t<uint> {\n     for d: pred_args in descs {\n         if pred_args_matches(pattern, d) { ret some(d.node.bit_num); }\n     }\n@@ -721,7 +719,7 @@ fn find_instance_(pattern: &[constr_arg_general_<inst>], descs: &[pred_args])\n type inst = {ident: ident, node: node_id};\n type subst = [{from: inst, to: inst}];\n \n-fn find_instances(_fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n+fn find_instances(_fcx: fn_ctxt, subst: subst, c: constraint) ->\n    [{from: uint, to: uint}] {\n \n     let rslt = [];\n@@ -745,18 +743,18 @@ fn find_instances(_fcx: &fn_ctxt, subst: &subst, c: &constraint) ->\n     rslt\n }\n \n-fn find_in_subst(id: node_id, s: &subst) -> option::t<inst> {\n+fn find_in_subst(id: node_id, s: subst) -> option::t<inst> {\n     for p: {from: inst, to: inst} in s {\n         if id == p.from.node { ret some(p.to); }\n     }\n     ret none;\n }\n \n-fn find_in_subst_bool(s: &subst, id: node_id) -> bool {\n+fn find_in_subst_bool(s: subst, id: node_id) -> bool {\n     is_some(find_in_subst(id, s))\n }\n \n-fn insts_to_str(stuff: &[constr_arg_general_<inst>]) -> str {\n+fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n     let rslt = \"<\";\n     for i: constr_arg_general_<inst> in stuff {\n         rslt +=\n@@ -802,7 +800,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n     ret rslt;\n }\n \n-fn path_to_ident(cx: &ty::ctxt, p: &path) -> ident {\n+fn path_to_ident(cx: ty::ctxt, p: path) -> ident {\n     alt vec::last(p.node.idents) {\n       none. { cx.sess.span_fatal(p.span, \"Malformed path\"); }\n       some(i) { ret i; }\n@@ -811,7 +809,7 @@ fn path_to_ident(cx: &ty::ctxt, p: &path) -> ident {\n \n tag if_ty { if_check; plain_if; }\n \n-fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n+fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n    def_id {\n     alt local_node_id_to_def(fcx, i) {\n       some(def_local(id)) | some(def_arg(id, _)) | some(def_upvar(id, _, _)) {\n@@ -831,11 +829,11 @@ fn local_node_id_to_def_id_strict(fcx: &fn_ctxt, sp: &span, i: &node_id) ->\n     }\n }\n \n-fn local_node_id_to_def(fcx: &fn_ctxt, i: &node_id) -> option::t<def> {\n+fn local_node_id_to_def(fcx: fn_ctxt, i: node_id) -> option::t<def> {\n     fcx.ccx.tcx.def_map.find(i)\n }\n \n-fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t<def_id> {\n+fn local_node_id_to_def_id(fcx: fn_ctxt, i: node_id) -> option::t<def_id> {\n     alt local_node_id_to_def(fcx, i) {\n       some(def_local(id)) | some(def_arg(id, _)) | some(def_binding(id)) |\n       some(def_upvar(id, _, _)) {\n@@ -845,23 +843,23 @@ fn local_node_id_to_def_id(fcx: &fn_ctxt, i: &node_id) -> option::t<def_id> {\n     }\n }\n \n-fn local_node_id_to_local_def_id(fcx: &fn_ctxt, i: &node_id) ->\n+fn local_node_id_to_local_def_id(fcx: fn_ctxt, i: node_id) ->\n    option::t<node_id> {\n     alt local_node_id_to_def_id(fcx, i) {\n       some(did) { some(did.node) }\n       _ { none }\n     }\n }\n \n-fn copy_in_postcond(fcx: &fn_ctxt, parent_exp: node_id, dest: inst, src: inst,\n+fn copy_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dest: inst, src: inst,\n                     ty: oper_type) {\n     let post =\n         node_id_to_ts_ann(fcx.ccx, parent_exp).conditions.postcondition;\n     copy_in_poststate_two(fcx, post, post, dest, src, ty);\n }\n \n // FIXME refactor\n-fn copy_in_poststate(fcx: &fn_ctxt, post: &poststate, dest: inst, src: inst,\n+fn copy_in_poststate(fcx: fn_ctxt, post: poststate, dest: inst, src: inst,\n                      ty: oper_type) {\n     copy_in_poststate_two(fcx, post, post, dest, src, ty);\n }\n@@ -871,8 +869,8 @@ fn copy_in_poststate(fcx: &fn_ctxt, post: &poststate, dest: inst, src: inst,\n // dest substituted for src.\n // (This doesn't create any new constraints. If a new, substituted\n // constraint isn't already in the bit vector, it's ignored.)\n-fn copy_in_poststate_two(fcx: &fn_ctxt, src_post: &poststate,\n-                         target_post: &poststate, dest: inst, src: inst,\n+fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n+                         target_post: poststate, dest: inst, src: inst,\n                          ty: oper_type) {\n     let subst;\n     alt ty {\n@@ -899,7 +897,7 @@ fn copy_in_poststate_two(fcx: &fn_ctxt, src_post: &poststate,\n \n \n /* FIXME should refactor this better */\n-fn forget_in_postcond(fcx: &fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n+fn forget_in_postcond(fcx: fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n@@ -917,7 +915,7 @@ fn forget_in_postcond(fcx: &fn_ctxt, parent_exp: node_id, dead_v: node_id) {\n     }\n }\n \n-fn forget_in_postcond_still_init(fcx: &fn_ctxt, parent_exp: node_id,\n+fn forget_in_postcond_still_init(fcx: fn_ctxt, parent_exp: node_id,\n                                  dead_v: node_id) {\n     // In the postcondition given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n@@ -936,8 +934,7 @@ fn forget_in_postcond_still_init(fcx: &fn_ctxt, parent_exp: node_id,\n     }\n }\n \n-fn forget_in_poststate(fcx: &fn_ctxt, p: &poststate, dead_v: node_id) ->\n-   bool {\n+fn forget_in_poststate(fcx: fn_ctxt, p: poststate, dead_v: node_id) -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n@@ -955,8 +952,8 @@ fn forget_in_poststate(fcx: &fn_ctxt, p: &poststate, dead_v: node_id) ->\n     ret changed;\n }\n \n-fn forget_in_poststate_still_init(fcx: &fn_ctxt, p: &poststate,\n-                                  dead_v: node_id) -> bool {\n+fn forget_in_poststate_still_init(fcx: fn_ctxt, p: poststate, dead_v: node_id)\n+   -> bool {\n     // In the poststate given by parent_exp, clear the bits\n     // for any constraints mentioning dead_v\n     let d = local_node_id_to_local_def_id(fcx, dead_v);\n@@ -974,29 +971,29 @@ fn forget_in_poststate_still_init(fcx: &fn_ctxt, p: &poststate,\n     ret changed;\n }\n \n-fn any_eq(v: &[node_id], d: node_id) -> bool {\n+fn any_eq(v: [node_id], d: node_id) -> bool {\n     for i: node_id in v { if i == d { ret true; } }\n     false\n }\n \n-fn constraint_mentions(_fcx: &fn_ctxt, c: &norm_constraint, v: node_id) ->\n+fn constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id) ->\n    bool {\n     ret alt c.c.node {\n           ninit(id, _) { v == id }\n           npred(_, _, args) { args_mention(args, any_eq, [v]) }\n         };\n }\n \n-fn non_init_constraint_mentions(_fcx: &fn_ctxt, c: &norm_constraint,\n-                                v: &node_id) -> bool {\n+fn non_init_constraint_mentions(_fcx: fn_ctxt, c: norm_constraint, v: node_id)\n+   -> bool {\n     ret alt c.c.node {\n           ninit(_, _) { false }\n           npred(_, _, args) { args_mention(args, any_eq, [v]) }\n         };\n }\n \n-fn args_mention<T>(args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool,\n-                   s: &[T]) -> bool {\n+fn args_mention<T>(args: [@constr_arg_use], q: fn([T], node_id) -> bool,\n+                   s: [T]) -> bool {\n     /*\n       FIXME\n       The following version causes an assertion in trans to fail\n@@ -1021,10 +1018,10 @@ fn args_mention<T>(args: &[@constr_arg_use], q: fn(&[T], node_id) -> bool,\n     ret false;\n }\n \n-fn use_var(fcx: &fn_ctxt, v: &node_id) { *fcx.enclosing.used_vars += [v]; }\n+fn use_var(fcx: fn_ctxt, v: node_id) { *fcx.enclosing.used_vars += [v]; }\n \n // FIXME: This should be a function in std::vec::.\n-fn vec_contains(v: &@mutable [node_id], i: &node_id) -> bool {\n+fn vec_contains(v: @mutable [node_id], i: node_id) -> bool {\n     for d: node_id in *v { if d == i { ret true; } }\n     ret false;\n }\n@@ -1034,14 +1031,13 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n }\n \n // default function visitor\n-fn do_nothing<T>(_f: &_fn, _tp: &[ty_param], _sp: &span, _i: &fn_ident,\n-                 _iid: node_id, _cx: &T, _v: &visit::vt<T>) {\n+fn do_nothing<T>(_f: _fn, _tp: [ty_param], _sp: span, _i: fn_ident,\n+                 _iid: node_id, _cx: T, _v: visit::vt<T>) {\n }\n \n \n-fn args_to_constr_args(tcx: &ty::ctxt, args: &[arg],\n-                       indices: &[@sp_constr_arg<uint>]) ->\n-   [@constr_arg_use] {\n+fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n+                       indices: [@sp_constr_arg<uint>]) -> [@constr_arg_use] {\n     let actuals: [@constr_arg_use] = [];\n     let num_args = vec::len(args);\n     for a: @sp_constr_arg<uint> in indices {\n@@ -1065,22 +1061,22 @@ fn args_to_constr_args(tcx: &ty::ctxt, args: &[arg],\n     ret actuals;\n }\n \n-fn ast_constr_to_ts_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n+fn ast_constr_to_ts_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n    tsconstr {\n     let tconstr = ty::ast_constr_to_constr(tcx, c);\n     ret npred(tconstr.node.path, tconstr.node.id,\n               args_to_constr_args(tcx, args, tconstr.node.args));\n }\n \n-fn ast_constr_to_sp_constr(tcx: &ty::ctxt, args: &[arg], c: &@constr) ->\n+fn ast_constr_to_sp_constr(tcx: ty::ctxt, args: [arg], c: @constr) ->\n    sp_constr {\n     let tconstr = ast_constr_to_ts_constr(tcx, args, c);\n     ret respan(c.span, tconstr);\n }\n \n type binding = {lhs: [inst], rhs: option::t<initializer>};\n \n-fn local_to_bindings(loc: &@local) -> binding {\n+fn local_to_bindings(loc: @local) -> binding {\n     let lhs = [];\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(name) { name } };\n@@ -1089,11 +1085,11 @@ fn local_to_bindings(loc: &@local) -> binding {\n     {lhs: lhs, rhs: loc.node.init}\n }\n \n-fn locals_to_bindings(locals: &[@local]) -> [binding] {\n+fn locals_to_bindings(locals: [@local]) -> [binding] {\n     vec::map(local_to_bindings, locals)\n }\n \n-fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n+fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [ty::mode] {\n     let ty =\n         ty::type_autoderef(fcx.ccx.tcx,\n                            ty::node_id_to_type(fcx.ccx.tcx, callee));\n@@ -1111,14 +1107,14 @@ fn callee_modes(fcx: &fn_ctxt, callee: node_id) -> [ty::mode] {\n     }\n }\n \n-fn callee_arg_init_ops(fcx: &fn_ctxt, callee: node_id) -> [init_op] {\n-    fn mode_to_op(m: &ty::mode) -> init_op {\n+fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n+    fn mode_to_op(m: ty::mode) -> init_op {\n         alt m { by_move. { init_move } _ { init_assign } }\n     }\n     vec::map(mode_to_op, callee_modes(fcx, callee))\n }\n \n-fn anon_bindings(ops: &[init_op], es: &[@expr]) -> [binding] {\n+fn anon_bindings(ops: [init_op], es: [@expr]) -> [binding] {\n     let bindings: [binding] = [];\n     let i = 0;\n     for op: init_op in ops {"}, {"sha": "329c542fcddfb22dcafaedb26b33b9aa31e422e5", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 33, "deletions": 35, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -27,7 +27,7 @@ import tstate::ann::clear_in_poststate_;\n import tritv::*;\n import util::common::*;\n \n-fn bit_num(fcx: &fn_ctxt, c: &tsconstr) -> uint {\n+fn bit_num(fcx: fn_ctxt, c: tsconstr) -> uint {\n     let d = tsconstr_to_def_id(c);\n     assert (fcx.enclosing.constrs.contains_key(d));\n     let rslt = fcx.enclosing.constrs.get(d);\n@@ -53,11 +53,11 @@ fn bit_num(fcx: &fn_ctxt, c: &tsconstr) -> uint {\n     }\n }\n \n-fn promises(fcx: &fn_ctxt, p: &poststate, c: &tsconstr) -> bool {\n+fn promises(fcx: fn_ctxt, p: poststate, c: tsconstr) -> bool {\n     ret promises_(bit_num(fcx, c), p);\n }\n \n-fn promises_(n: uint, p: &poststate) -> bool { ret tritv_get(p, n) == ttrue; }\n+fn promises_(n: uint, p: poststate) -> bool { ret tritv_get(p, n) == ttrue; }\n \n // v \"happens after\" u\n fn seq_trit(u: trit, v: trit) -> trit {\n@@ -67,7 +67,7 @@ fn seq_trit(u: trit, v: trit) -> trit {\n // idea: q \"happens after\" p -- so if something is\n // 1 in q and 0 in p, it's 1 in the result; however,\n // if it's 0 in q and 1 in p, it's 0 in the result\n-fn seq_tritv(p: &postcond, q: &postcond) {\n+fn seq_tritv(p: postcond, q: postcond) {\n     let i = 0u;\n     assert (p.nbits == q.nbits);\n     while i < p.nbits {\n@@ -76,7 +76,7 @@ fn seq_tritv(p: &postcond, q: &postcond) {\n     }\n }\n \n-fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n+fn seq_postconds(fcx: fn_ctxt, ps: [postcond]) -> postcond {\n     let sz = vec::len(ps);\n     if sz >= 1u {\n         let prev = tritv_clone(ps[0]);\n@@ -89,12 +89,12 @@ fn seq_postconds(fcx: &fn_ctxt, ps: &[postcond]) -> postcond {\n // return the precondition for evaluating each expr in order.\n // So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n // precondition shouldn't include x.\n-fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n+fn seq_preconds(fcx: fn_ctxt, pps: [pre_and_post]) -> precond {\n     let sz: uint = vec::len(pps);\n     let num_vars: uint = num_constraints(fcx.enclosing);\n \n-    fn seq_preconds_go(fcx: &fn_ctxt, pps: &[pre_and_post],\n-                       first: &pre_and_post) -> precond {\n+    fn seq_preconds_go(fcx: fn_ctxt, pps: [pre_and_post], first: pre_and_post)\n+       -> precond {\n         let sz: uint = vec::len(pps);\n         if sz >= 1u {\n             let second = pps[0];\n@@ -119,82 +119,80 @@ fn seq_preconds(fcx: &fn_ctxt, pps: &[pre_and_post]) -> precond {\n     } else { ret true_precond(num_vars); }\n }\n \n-fn intersect_states(p: &prestate, q: &prestate) -> prestate {\n+fn intersect_states(p: prestate, q: prestate) -> prestate {\n     let rslt = tritv_clone(p);\n     tritv_intersect(rslt, q);\n     ret rslt;\n }\n \n-fn gen(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n+fn gen(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n     ret set_in_postcond(bit_num(fcx, c),\n                         node_id_to_ts_ann(fcx.ccx, id).conditions);\n }\n \n-fn declare_var(fcx: &fn_ctxt, c: &tsconstr, pre: prestate) -> prestate {\n+fn declare_var(fcx: fn_ctxt, c: tsconstr, pre: prestate) -> prestate {\n     let rslt = clone(pre);\n     relax_prestate(bit_num(fcx, c), rslt);\n     // idea is this is scoped\n     relax_poststate(bit_num(fcx, c), rslt);\n     ret rslt;\n }\n \n-fn relax_precond_expr(e: &@expr, cx: &relax_ctxt,\n-                      vt: &visit::vt<relax_ctxt>) {\n+fn relax_precond_expr(e: @expr, cx: relax_ctxt, vt: visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, expr_precond(cx.fcx.ccx, e));\n     visit::visit_expr(e, cx, vt);\n }\n \n-fn relax_precond_stmt(s: &@stmt, cx: &relax_ctxt,\n-                      vt: &visit::vt<relax_ctxt>) {\n+fn relax_precond_stmt(s: @stmt, cx: relax_ctxt, vt: visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, stmt_precond(cx.fcx.ccx, *s));\n     visit::visit_stmt(s, cx, vt);\n }\n \n type relax_ctxt = {fcx: fn_ctxt, i: node_id};\n \n-fn relax_precond_block_inner(b: &blk, cx: &relax_ctxt,\n-                             vt: &visit::vt<relax_ctxt>) {\n+fn relax_precond_block_inner(b: blk, cx: relax_ctxt,\n+                             vt: visit::vt<relax_ctxt>) {\n     relax_precond(cx.i as uint, block_precond(cx.fcx.ccx, b));\n     visit::visit_block(b, cx, vt);\n }\n \n-fn relax_precond_block(fcx: &fn_ctxt, i: node_id, b: &blk) {\n+fn relax_precond_block(fcx: fn_ctxt, i: node_id, b: blk) {\n     let cx = {fcx: fcx, i: i};\n     let visitor = visit::default_visitor::<relax_ctxt>();\n     visitor =\n         @{visit_block: relax_precond_block_inner,\n           visit_expr: relax_precond_expr,\n           visit_stmt: relax_precond_stmt,\n           visit_item:\n-              fn (_i: &@item, _cx: &relax_ctxt, _vt: &visit::vt<relax_ctxt>) {\n-              } with *visitor};\n+              fn (_i: @item, _cx: relax_ctxt, _vt: visit::vt<relax_ctxt>) { }\n+             with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);\n }\n \n-fn gen_poststate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n+fn gen_poststate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n     log \"gen_poststate\";\n     ret set_in_poststate(bit_num(fcx, c),\n                          node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_prestate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n+fn kill_prestate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n     ret clear_in_prestate(bit_num(fcx, c),\n                           node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn kill_all_prestate(fcx: &fn_ctxt, id: node_id) {\n+fn kill_all_prestate(fcx: fn_ctxt, id: node_id) {\n     tritv::tritv_kill(node_id_to_ts_ann(fcx.ccx, id).states.prestate);\n }\n \n \n-fn kill_poststate(fcx: &fn_ctxt, id: node_id, c: &tsconstr) -> bool {\n+fn kill_poststate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n     log \"kill_poststate\";\n     ret clear_in_poststate(bit_num(fcx, c),\n                            node_id_to_ts_ann(fcx.ccx, id).states);\n }\n \n-fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n+fn clear_in_poststate_expr(fcx: fn_ctxt, e: @expr, t: poststate) {\n     alt e.node {\n       expr_path(p) {\n         alt vec::last(p.node.idents) {\n@@ -217,32 +215,32 @@ fn clear_in_poststate_expr(fcx: &fn_ctxt, e: &@expr, t: &poststate) {\n     }\n }\n \n-fn kill_poststate_(fcx: &fn_ctxt, c: &tsconstr, post: &poststate) -> bool {\n+fn kill_poststate_(fcx: fn_ctxt, c: tsconstr, post: poststate) -> bool {\n     log \"kill_poststate_\";\n     ret clear_in_poststate_(bit_num(fcx, c), post);\n }\n \n-fn set_in_poststate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n-                          t: &poststate) -> bool {\n+fn set_in_poststate_ident(fcx: fn_ctxt, id: node_id, ident: ident,\n+                          t: poststate) -> bool {\n     ret set_in_poststate_(bit_num(fcx, ninit(id, ident)), t);\n }\n \n-fn set_in_prestate_constr(fcx: &fn_ctxt, c: &tsconstr, t: &prestate) -> bool {\n+fn set_in_prestate_constr(fcx: fn_ctxt, c: tsconstr, t: prestate) -> bool {\n     ret set_in_poststate_(bit_num(fcx, c), t);\n }\n \n-fn clear_in_poststate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n-                            parent: &node_id) -> bool {\n+fn clear_in_poststate_ident(fcx: fn_ctxt, id: node_id, ident: ident,\n+                            parent: node_id) -> bool {\n     ret kill_poststate(fcx, parent, ninit(id, ident));\n }\n \n-fn clear_in_prestate_ident(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n-                           parent: &node_id) -> bool {\n+fn clear_in_prestate_ident(fcx: fn_ctxt, id: node_id, ident: ident,\n+                           parent: node_id) -> bool {\n     ret kill_prestate(fcx, parent, ninit(id, ident));\n }\n \n-fn clear_in_poststate_ident_(fcx: &fn_ctxt, id: &node_id, ident: &ident,\n-                             post: &poststate) -> bool {\n+fn clear_in_poststate_ident_(fcx: fn_ctxt, id: node_id, ident: ident,\n+                             post: poststate) -> bool {\n     ret kill_poststate_(fcx, ninit(id, ident), post);\n }\n "}, {"sha": "08af62f369ccf98d96af82ee5f146a465a5374ce", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -47,7 +47,7 @@ import collect_locals::mk_f_to_fn_info;\n import pre_post_conditions::fn_pre_post;\n import states::find_pre_post_state_fn;\n \n-fn check_unused_vars(fcx: &fn_ctxt) {\n+fn check_unused_vars(fcx: fn_ctxt) {\n \n     // FIXME: could be more efficient\n     for c: norm_constraint in constraints(fcx) {\n@@ -63,7 +63,7 @@ fn check_unused_vars(fcx: &fn_ctxt) {\n     }\n }\n \n-fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n+fn check_states_expr(e: @expr, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     visit::visit_expr(e, fcx, v);\n \n     let prec: precond = expr_precond(fcx.ccx, e);\n@@ -94,7 +94,7 @@ fn check_states_expr(e: &@expr, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     }\n }\n \n-fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n+fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n     visit::visit_stmt(s, fcx, v);\n \n     let a = stmt_to_ann(fcx.ccx, *s);\n@@ -126,9 +126,8 @@ fn check_states_stmt(s: &@stmt, fcx: &fn_ctxt, v: &visit::vt<fn_ctxt>) {\n     }\n }\n \n-fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n-                                   tps: &[ast::ty_param], id: node_id,\n-                                   sp: &span, i: &fn_ident) {\n+fn check_states_against_conditions(fcx: fn_ctxt, f: _fn, tps: [ast::ty_param],\n+                                   id: node_id, sp: span, i: fn_ident) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n        or expression. */\n@@ -173,8 +172,8 @@ fn check_states_against_conditions(fcx: &fn_ctxt, f: &_fn,\n     check_unused_vars(fcx);\n }\n \n-fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &[ast::ty_param], id: node_id,\n-                   sp: &span, i: &fn_ident) {\n+fn check_fn_states(fcx: fn_ctxt, f: _fn, tps: [ast::ty_param], id: node_id,\n+                   sp: span, i: fn_ident) {\n     /* Compute the pre- and post-states for this function */\n \n     // Fixpoint iteration\n@@ -186,8 +185,8 @@ fn check_fn_states(fcx: &fn_ctxt, f: &_fn, tps: &[ast::ty_param], id: node_id,\n     check_states_against_conditions(fcx, f, tps, id, sp, i);\n }\n \n-fn fn_states(f: &_fn, tps: &[ast::ty_param], sp: &span, i: &fn_ident,\n-             id: node_id, ccx: &crate_ctxt, v: &visit::vt<crate_ctxt>) {\n+fn fn_states(f: _fn, tps: [ast::ty_param], sp: span, i: fn_ident, id: node_id,\n+             ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */\n "}, {"sha": "03e889b5a4eb7d2f1994a397aea1c28ee84f66ef", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -15,7 +15,7 @@ import syntax::ast_util::respan;\n \n type ctxt = {cs: @mutable [sp_constr], tcx: ty::ctxt};\n \n-fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt<ctxt>) {\n+fn collect_local(loc: @local, cx: ctxt, v: visit::vt<ctxt>) {\n     for each p: @pat in pat_bindings(loc.node.pat) {\n         let ident = alt p.node { pat_bind(id) { id } };\n         log \"collect_local: pushing \" + ident;;\n@@ -24,13 +24,14 @@ fn collect_local(loc: &@local, cx: &ctxt, v: &visit::vt<ctxt>) {\n     visit::visit_local(loc, cx, v);\n }\n \n-fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n+fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n     alt e.node {\n       expr_check(_, ch) { *cx.cs += [expr_to_constr(cx.tcx, ch)]; }\n       expr_if_check(ex, _, _) { *cx.cs += [expr_to_constr(cx.tcx, ex)]; }\n \n \n \n+\n       // If it's a call, generate appropriate instances of the\n       // call's constraints.\n       expr_call(operator, operands) {\n@@ -47,8 +48,8 @@ fn collect_pred(e: &@expr, cx: &ctxt, v: &visit::vt<ctxt>) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n-               i: &fn_ident, id: node_id) -> ctxt {\n+fn find_locals(tcx: ty::ctxt, f: _fn, tps: [ty_param], sp: span, i: fn_ident,\n+               id: node_id) -> ctxt {\n     let cx: ctxt = {cs: @mutable [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n \n@@ -60,8 +61,8 @@ fn find_locals(tcx: &ty::ctxt, f: &_fn, tps: &[ty_param], sp: &span,\n     ret cx;\n }\n \n-fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n-   -> uint {\n+fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n+   uint {\n     log constraint_to_str(tcx, c) + \" |-> \" + std::uint::str(next);\n     alt c.node {\n       ninit(id, i) { tbl.insert(local_def(id), cinit(next, c.span, i)); }\n@@ -92,8 +93,8 @@ fn add_constraint(tcx: &ty::ctxt, c: sp_constr, next: uint, tbl: constr_map)\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n-fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n-              f_name: &fn_ident, id: node_id) {\n+fn mk_fn_info(ccx: crate_ctxt, f: _fn, tp: [ty_param], f_sp: span,\n+              f_name: fn_ident, id: node_id) {\n     let name = fn_ident_to_string(id, f_name);\n     let res_map = @new_def_hash::<constraint>();\n     let next: uint = 0u;\n@@ -155,7 +156,7 @@ fn mk_fn_info(ccx: &crate_ctxt, f: &_fn, tp: &[ty_param], f_sp: &span,\n /* initializes the global fn_info_map (mapping each function ID, including\n    nested locally defined functions, onto a mapping from local variable name\n    to bit number) */\n-fn mk_f_to_fn_info(ccx: &crate_ctxt, c: @crate) {\n+fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n     let visitor =\n         visit::mk_simple_visitor(@{visit_fn:\n                                        bind mk_fn_info(ccx, _, _, _, _, _)"}, {"sha": "8f9e08b5533a409b6a6cc645922206f2ef255f11", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -34,18 +34,18 @@ import util::common::log_block;\n import syntax::codemap::span;\n import util::ppaux::fn_ident_to_string;\n \n-fn find_pre_post_mod(_m: &_mod) -> _mod {\n+fn find_pre_post_mod(_m: _mod) -> _mod {\n     log \"implement find_pre_post_mod!\";\n     fail;\n }\n \n-fn find_pre_post_native_mod(_m: &native_mod) -> native_mod {\n+fn find_pre_post_native_mod(_m: native_mod) -> native_mod {\n     log \"implement find_pre_post_native_mod\";\n     fail;\n }\n \n-fn find_pre_post_obj(ccx: &crate_ctxt, o: _obj) {\n-    fn do_a_method(ccx: crate_ctxt, m: &@method) {\n+fn find_pre_post_obj(ccx: crate_ctxt, o: _obj) {\n+    fn do_a_method(ccx: crate_ctxt, m: @method) {\n         assert (ccx.fm.contains_key(m.node.id));\n         let fcx: fn_ctxt =\n             {enclosing: ccx.fm.get(m.node.id),\n@@ -57,7 +57,7 @@ fn find_pre_post_obj(ccx: &crate_ctxt, o: _obj) {\n     for m: @method in o.methods { do_a_method(ccx, m); }\n }\n \n-fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n+fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n     alt i.node {\n       item_const(_, e) {\n         // make a fake fcx\n@@ -104,15 +104,15 @@ fn find_pre_post_item(ccx: &crate_ctxt, i: &item) {\n    sets the precondition in a to be the result of combining\n    the preconditions for <args>, and the postcondition in a to\n    be the union of all postconditions for <args> */\n-fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n+fn find_pre_post_exprs(fcx: fn_ctxt, args: [@expr], id: node_id) {\n     if vec::len::<@expr>(args) > 0u {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args[0]);\n     }\n-    fn do_one(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n+    fn do_one(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n     for e: @expr in args { do_one(fcx, e); }\n \n-    fn get_pp(ccx: crate_ctxt, e: &@expr) -> pre_and_post {\n+    fn get_pp(ccx: crate_ctxt, e: @expr) -> pre_and_post {\n         ret expr_pp(ccx, e);\n     }\n     let pps = vec::map::<@expr, pre_and_post>(bind get_pp(fcx.ccx, _), args);\n@@ -121,7 +121,7 @@ fn find_pre_post_exprs(fcx: &fn_ctxt, args: &[@expr], id: node_id) {\n                      seq_postconds(fcx, vec::map(get_post, pps)));\n }\n \n-fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n+fn find_pre_post_loop(fcx: fn_ctxt, l: @local, index: @expr, body: blk,\n                       id: node_id) {\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n@@ -145,8 +145,8 @@ fn find_pre_post_loop(fcx: &fn_ctxt, l: &@local, index: &@expr, body: &blk,\n // Generates a pre/post assuming that a is the\n // annotation for an if-expression with consequent conseq\n // and alternative maybe_alt\n-fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n-                  maybe_alt: &option::t<@expr>, id: node_id, chck: &if_ty) {\n+fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n+                  maybe_alt: option::t<@expr>, id: node_id, chck: if_ty) {\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n     alt maybe_alt {\n@@ -208,8 +208,8 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n     }\n }\n \n-fn gen_if_local(fcx: &fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n-                new_var: node_id, pth: &path) {\n+fn gen_if_local(fcx: fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n+                new_var: node_id, pth: path) {\n     alt node_id_to_def(fcx.ccx, new_var) {\n       some(d) {\n         alt d {\n@@ -228,7 +228,7 @@ fn gen_if_local(fcx: &fn_ctxt, lhs: @expr, rhs: @expr, larger_id: node_id,\n     }\n }\n \n-fn handle_update(fcx: &fn_ctxt, parent: &@expr, lhs: &@expr, rhs: &@expr,\n+fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n                  ty: oper_type) {\n     find_pre_post_expr(fcx, rhs);\n     alt lhs.node {\n@@ -291,12 +291,11 @@ fn handle_update(fcx: &fn_ctxt, parent: &@expr, lhs: &@expr, rhs: &@expr,\n     }\n }\n \n-fn handle_var(fcx: &fn_ctxt, rslt: &pre_and_post, id: node_id, name: ident) {\n+fn handle_var(fcx: fn_ctxt, rslt: pre_and_post, id: node_id, name: ident) {\n     handle_var_def(fcx, rslt, node_id_to_def_strict(fcx.ccx.tcx, id), name);\n }\n \n-fn handle_var_def(fcx: &fn_ctxt, rslt: &pre_and_post, def: &def,\n-                  name: ident) {\n+fn handle_var_def(fcx: fn_ctxt, rslt: pre_and_post, def: def, name: ident) {\n     alt def {\n       def_local(d_id) | def_arg(d_id, _) {\n         use_var(fcx, d_id.node);\n@@ -307,8 +306,8 @@ fn handle_var_def(fcx: &fn_ctxt, rslt: &pre_and_post, def: &def,\n     }\n }\n \n-fn forget_args_moved_in(fcx: &fn_ctxt, parent: &@expr, modes: &[ty::mode],\n-                        operands: &[@expr]) {\n+fn forget_args_moved_in(fcx: fn_ctxt, parent: @expr, modes: [ty::mode],\n+                        operands: [@expr]) {\n     let i = 0u;\n     for mode: ty::mode in modes {\n         if mode == by_move {\n@@ -319,10 +318,10 @@ fn forget_args_moved_in(fcx: &fn_ctxt, parent: &@expr, modes: &[ty::mode],\n }\n \n /* Fills in annotations as a side effect. Does not rebuild the expr */\n-fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n+fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n     let enclosing = fcx.enclosing;\n     let num_local_vars = num_constraints(enclosing);\n-    fn do_rand_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n+    fn do_rand_(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n \n \n     alt e.node {\n@@ -487,14 +486,14 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n       expr_index(val, sub) { find_pre_post_exprs(fcx, [val, sub], e.id); }\n       expr_alt(ex, alts) {\n         find_pre_post_expr(fcx, ex);\n-        fn do_an_alt(fcx: &fn_ctxt, an_alt: &arm) -> pre_and_post {\n+        fn do_an_alt(fcx: fn_ctxt, an_alt: arm) -> pre_and_post {\n             find_pre_post_block(fcx, an_alt.body);\n             ret block_pp(fcx.ccx, an_alt.body);\n         }\n         let alt_pps = [];\n         for a: arm in alts { alt_pps += [do_an_alt(fcx, a)]; }\n-        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, pp: &pre_and_post,\n-                      next: &pre_and_post) -> pre_and_post {\n+        fn combine_pp(antec: pre_and_post, fcx: fn_ctxt, pp: pre_and_post,\n+                      next: pre_and_post) -> pre_and_post {\n             union(pp.precondition, seq_preconds(fcx, [antec, next]));\n             intersect(pp.postcondition, next.postcondition);\n             ret pp;\n@@ -546,6 +545,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n \n \n \n+\n       expr_bind(operator, maybe_args) {\n         let args = [];\n         let cmodes = callee_modes(fcx, operator.id);\n@@ -578,7 +578,7 @@ fn find_pre_post_expr(fcx: &fn_ctxt, e: @expr) {\n     }\n }\n \n-fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n+fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n     log \"stmt =\";\n     log_stmt(s);\n     alt s.node {\n@@ -681,7 +681,7 @@ fn find_pre_post_stmt(fcx: &fn_ctxt, s: &stmt) {\n     }\n }\n \n-fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n+fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     /* Want to say that if there is a break or cont in this\n      block, then that invalidates the poststate upheld by\n     any of the stmts after it.\n@@ -700,7 +700,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n      */\n \n     let nv = num_constraints(fcx.enclosing);\n-    fn do_one_(fcx: fn_ctxt, s: &@stmt) {\n+    fn do_one_(fcx: fn_ctxt, s: @stmt) {\n         find_pre_post_stmt(fcx, *s);\n         /*\n                 log_err \"pre_post for stmt:\";\n@@ -710,7 +710,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n         */\n     }\n     for s: @stmt in b.node.stmts { do_one_(fcx, s); }\n-    fn do_inner_(fcx: fn_ctxt, e: &@expr) { find_pre_post_expr(fcx, e); }\n+    fn do_inner_(fcx: fn_ctxt, e: @expr) { find_pre_post_expr(fcx, e); }\n     let do_inner = bind do_inner_(fcx, _);\n     option::map::<@expr, ()>(do_inner, b.node.expr);\n \n@@ -739,7 +739,7 @@ fn find_pre_post_block(fcx: &fn_ctxt, b: blk) {\n     set_pre_and_post(fcx.ccx, b.node.id, block_precond, block_postcond);\n }\n \n-fn find_pre_post_fn(fcx: &fn_ctxt, f: &_fn) {\n+fn find_pre_post_fn(fcx: fn_ctxt, f: _fn) {\n     // hack\n     use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_return));\n     use_var(fcx, tsconstr_to_node_id(fcx.enclosing.i_diverge));\n@@ -754,8 +754,8 @@ fn find_pre_post_fn(fcx: &fn_ctxt, f: &_fn) {\n     }\n }\n \n-fn fn_pre_post(f: &_fn, tps: &[ty_param], sp: &span, i: &fn_ident,\n-               id: node_id, ccx: &crate_ctxt, v: &visit::vt<crate_ctxt>) {\n+fn fn_pre_post(f: _fn, tps: [ty_param], sp: span, i: fn_ident, id: node_id,\n+               ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n     visit::visit_fn(f, tps, sp, i, id, ccx, v);\n     assert (ccx.fm.contains_key(id));\n     let fcx ="}, {"sha": "b86edea26fa043fddd79fa8f57e6af55dd490a31", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -32,24 +32,24 @@ import util::common::log_stmt;\n import util::common::log_stmt_err;\n import util::common::log_expr_err;\n \n-fn forbid_upvar(fcx: &fn_ctxt, rhs_id: &node_id, sp: &span,\n-                t: oper_type) {\n+fn forbid_upvar(fcx: fn_ctxt, rhs_id: node_id, sp: span, t: oper_type) {\n     alt t {\n       oper_move. {\n         alt local_node_id_to_def(fcx, rhs_id) {\n-          some(def_upvar(_,_,_)) {\n-             fcx.ccx.tcx.sess.span_err(sp, \"Tried to deinitialize a variable \\\n+          some(def_upvar(_, _, _)) {\n+            fcx.ccx.tcx.sess.span_err(sp,\n+                                      \"Tried to deinitialize a variable \\\n               declared in a different scope\");\n-           }\n-          _ {}\n+          }\n+          _ { }\n         }\n       }\n-      _ { /* do nothing */ }\n+      _ {/* do nothing */ }\n     }\n }\n \n-fn handle_move_or_copy(fcx: &fn_ctxt, post: &poststate, rhs_path: &path,\n-                       rhs_id: &node_id, instlhs: &inst, init_op: &init_op) {\n+fn handle_move_or_copy(fcx: fn_ctxt, post: poststate, rhs_path: path,\n+                       rhs_id: node_id, instlhs: inst, init_op: init_op) {\n     forbid_upvar(fcx, rhs_id, rhs_path.span, op_to_oper_ty(init_op));\n \n     let rhs_d_id = local_node_id_to_def_id(fcx, rhs_id);\n@@ -67,7 +67,7 @@ fn handle_move_or_copy(fcx: &fn_ctxt, post: &poststate, rhs_path: &path,\n     }\n }\n \n-fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding]) ->\n+fn seq_states(fcx: fn_ctxt, pres: prestate, bindings: [binding]) ->\n    {changed: bool, post: poststate} {\n     let changed = false;\n     let post = tritv_clone(pres);\n@@ -105,7 +105,7 @@ fn seq_states(fcx: &fn_ctxt, pres: &prestate, bindings: &[binding]) ->\n     ret {changed: changed, post: post};\n }\n \n-fn find_pre_post_state_sub(fcx: &fn_ctxt, pres: &prestate, e: &@expr,\n+fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n                            parent: node_id, c: option::t<tsconstr>) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, e);\n \n@@ -121,8 +121,8 @@ fn find_pre_post_state_sub(fcx: &fn_ctxt, pres: &prestate, e: &@expr,\n     ret changed;\n }\n \n-fn find_pre_post_state_two(fcx: &fn_ctxt, pres: &prestate, lhs: &@expr,\n-                           rhs: &@expr, parent: node_id, ty: oper_type) ->\n+fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n+                           rhs: @expr, parent: node_id, ty: oper_type) ->\n    bool {\n     let changed = set_prestate_ann(fcx.ccx, parent, pres);\n     changed = find_pre_post_state_expr(fcx, pres, lhs) || changed;\n@@ -184,8 +184,8 @@ fn find_pre_post_state_two(fcx: &fn_ctxt, pres: &prestate, lhs: &@expr,\n     ret changed;\n }\n \n-fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n-                            id: node_id, ops: &[init_op], bs: &[@expr],\n+fn find_pre_post_state_call(fcx: fn_ctxt, pres: prestate, a: @expr,\n+                            id: node_id, ops: [init_op], bs: [@expr],\n                             cf: controlflow) -> bool {\n     let changed = find_pre_post_state_expr(fcx, pres, a);\n     // FIXME: This could be a typestate constraint\n@@ -199,9 +199,9 @@ fn find_pre_post_state_call(fcx: &fn_ctxt, pres: &prestate, a: &@expr,\n                                   bs, cf) || changed;\n }\n \n-fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n-                             ops: &[init_op], es: &[@expr], cf: controlflow)\n-   -> bool {\n+fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n+                             ops: [init_op], es: [@expr], cf: controlflow) ->\n+   bool {\n     let rs = seq_states(fcx, pres, anon_bindings(ops, es));\n     let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n@@ -215,8 +215,8 @@ fn find_pre_post_state_exprs(fcx: &fn_ctxt, pres: &prestate, id: node_id,\n     ret changed;\n }\n \n-fn find_pre_post_state_loop(fcx: &fn_ctxt, pres: prestate, l: &@local,\n-                            index: &@expr, body: &blk, id: node_id) -> bool {\n+fn find_pre_post_state_loop(fcx: fn_ctxt, pres: prestate, l: @local,\n+                            index: @expr, body: blk, id: node_id) -> bool {\n     let loop_pres = intersect_states(pres, block_poststate(fcx.ccx, body));\n \n     let changed =\n@@ -245,7 +245,7 @@ fn find_pre_post_state_loop(fcx: &fn_ctxt, pres: prestate, l: &@local,\n     }\n }\n \n-fn gen_if_local(fcx: &fn_ctxt, p: &poststate, e: &@expr) -> bool {\n+fn gen_if_local(fcx: fn_ctxt, p: poststate, e: @expr) -> bool {\n     alt e.node {\n       expr_path(pth) {\n         alt fcx.ccx.tcx.def_map.find(e.id) {\n@@ -260,9 +260,9 @@ fn gen_if_local(fcx: &fn_ctxt, p: &poststate, e: &@expr) -> bool {\n     }\n }\n \n-fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n-                  maybe_alt: &option::t<@expr>, id: node_id, chk: &if_ty,\n-                  pres: &prestate) -> bool {\n+fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n+                  maybe_alt: option::t<@expr>, id: node_id, chk: if_ty,\n+                  pres: prestate) -> bool {\n     let changed =\n         set_prestate_ann(fcx.ccx, id, pres) |\n             find_pre_post_state_expr(fcx, pres, antec);\n@@ -291,18 +291,18 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n             tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n             changed |=\n                 find_pre_post_state_block(fcx, conseq_prestate, conseq) |\n-                set_poststate_ann(fcx.ccx, id,\n-                                  expr_poststate(fcx.ccx, antec));\n+                    set_poststate_ann(fcx.ccx, id,\n+                                      expr_poststate(fcx.ccx, antec));\n           }\n           _ {\n             changed |=\n                 find_pre_post_state_block(fcx, expr_poststate(fcx.ccx, antec),\n                                           conseq) |\n-                set_poststate_ann(fcx.ccx, id,\n-                                  expr_poststate(fcx.ccx, antec));\n+                    set_poststate_ann(fcx.ccx, id,\n+                                      expr_poststate(fcx.ccx, antec));\n           }\n         }\n-     }\n+      }\n       some(altern) {\n         changed |=\n             find_pre_post_state_expr(fcx, expr_poststate(fcx.ccx, antec),\n@@ -341,8 +341,7 @@ fn join_then_else(fcx: &fn_ctxt, antec: &@expr, conseq: &blk,\n     ret changed;\n }\n \n-fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n-   bool {\n+fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n     let num_constrs = num_constraints(fcx.enclosing);\n \n \n@@ -630,8 +629,7 @@ fn find_pre_post_state_expr(fcx: &fn_ctxt, pres: &prestate, e: @expr) ->\n     }\n }\n \n-fn find_pre_post_state_stmt(fcx: &fn_ctxt, pres: &prestate, s: @stmt) ->\n-   bool {\n+fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n     let stmt_ann = stmt_to_ann(fcx.ccx, *s);\n \n     /*\n@@ -705,8 +703,7 @@ fn find_pre_post_state_stmt(fcx: &fn_ctxt, pres: &prestate, s: @stmt) ->\n \n /* Updates the pre- and post-states of statements in the block,\n    returns a boolean flag saying whether any pre- or poststates changed */\n-fn find_pre_post_state_block(fcx: &fn_ctxt, pres0: &prestate, b: &blk) ->\n-   bool {\n+fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n     /* First, set the pre-states and post-states for every expression */\n \n     let pres = pres0;\n@@ -748,7 +745,7 @@ fn find_pre_post_state_block(fcx: &fn_ctxt, pres0: &prestate, b: &blk) ->\n     ret changed;\n }\n \n-fn find_pre_post_state_fn(fcx: &fn_ctxt, f: &_fn) -> bool {\n+fn find_pre_post_state_fn(fcx: fn_ctxt, f: _fn) -> bool {\n     let num_constrs = num_constraints(fcx.enclosing);\n     // All constraints are considered false until proven otherwise.\n     // This ensures that intersect works correctly."}, {"sha": "bc8a6aa1ff2f23cfa485589b0c6feec14eda2278", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -56,6 +56,7 @@ fn trit_minus(a: trit, b: trit) -> trit {\n           tfalse. { ttrue }\n \n \n+\n           /* internally contradictory, but\n              I guess it'll get flagged? */\n           dont_care. {\n@@ -68,6 +69,7 @@ fn trit_minus(a: trit, b: trit) -> trit {\n           ttrue. { tfalse }\n \n \n+\n           /* see above comment */\n           _ {\n             tfalse\n@@ -86,6 +88,7 @@ fn trit_or(a: trit, b: trit) -> trit {\n           ttrue. { dont_care }\n \n \n+\n           /* FIXME: ?????? */\n           _ {\n             tfalse\n@@ -105,19 +108,22 @@ fn trit_and(a: trit, b: trit) -> trit {\n       dont_care. { b }\n \n \n+\n       // also seems wrong for case b = ttrue\n       ttrue. {\n         alt b {\n           dont_care. { ttrue }\n \n \n+\n           // ??? Seems wrong\n           ttrue. {\n             ttrue\n           }\n \n \n \n+\n           // false wins, since if something is uninit\n           // on one path, we care\n           // (Rationale: it's always safe to assume that\n@@ -131,6 +137,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n \n \n \n+\n       // Rationale: if it's uninit on one path,\n       // we can consider it as uninit on all paths\n       tfalse. {\n@@ -145,7 +152,7 @@ fn change(changed: bool, old: trit, new: trit) -> bool {\n     changed || new != old\n }\n \n-fn tritv_difference(p1: &t, p2: &t) -> bool {\n+fn tritv_difference(p1: t, p2: t) -> bool {\n     let i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n     let sz: uint = p1.nbits;\n@@ -160,7 +167,7 @@ fn tritv_difference(p1: &t, p2: &t) -> bool {\n     ret changed;\n }\n \n-fn tritv_union(p1: &t, p2: &t) -> bool {\n+fn tritv_union(p1: t, p2: t) -> bool {\n     let i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n     let sz: uint = p1.nbits;\n@@ -175,7 +182,7 @@ fn tritv_union(p1: &t, p2: &t) -> bool {\n     ret changed;\n }\n \n-fn tritv_intersect(p1: &t, p2: &t) -> bool {\n+fn tritv_intersect(p1: t, p2: t) -> bool {\n     let i: uint = 0u;\n     assert (p1.nbits == p2.nbits);\n     let sz: uint = p1.nbits;\n@@ -190,14 +197,14 @@ fn tritv_intersect(p1: &t, p2: &t) -> bool {\n     ret changed;\n }\n \n-fn tritv_get(v: &t, i: uint) -> trit {\n+fn tritv_get(v: t, i: uint) -> trit {\n     let b1 = bitv::get(v.uncertain, i);\n     let b2 = bitv::get(v.val, i);\n     assert (!(b1 && b2));\n     if b1 { dont_care } else if b2 { ttrue } else { tfalse }\n }\n \n-fn tritv_set(i: uint, v: &t, t: trit) -> bool {\n+fn tritv_set(i: uint, v: t, t: trit) -> bool {\n     let old = tritv_get(v, i);\n     alt t {\n       dont_care. {\n@@ -213,7 +220,7 @@ fn tritv_set(i: uint, v: &t, t: trit) -> bool {\n     ret change(false, old, t);\n }\n \n-fn tritv_copy(target: &t, source: &t) -> bool {\n+fn tritv_copy(target: t, source: t) -> bool {\n     assert (target.nbits == source.nbits);\n     let changed =\n         !bitv::equal(target.uncertain, source.uncertain) ||\n@@ -223,28 +230,28 @@ fn tritv_copy(target: &t, source: &t) -> bool {\n     ret changed;\n }\n \n-fn tritv_set_all(v: &t) {\n+fn tritv_set_all(v: t) {\n     let i: uint = 0u;\n     while i < v.nbits { tritv_set(i, v, ttrue); i += 1u; }\n }\n \n-fn tritv_clear(v: &t) {\n+fn tritv_clear(v: t) {\n     let i: uint = 0u;\n     while i < v.nbits { tritv_set(i, v, dont_care); i += 1u; }\n }\n \n-fn tritv_kill(v: &t) {\n+fn tritv_kill(v: t) {\n     let i: uint = 0u;\n     while i < v.nbits { tritv_set(i, v, tfalse); i += 1u; }\n }\n \n-fn tritv_clone(v: &t) -> t {\n+fn tritv_clone(v: t) -> t {\n     ret {uncertain: bitv::clone(v.uncertain),\n          val: bitv::clone(v.val),\n          nbits: v.nbits};\n }\n \n-fn tritv_doesntcare(v: &t) -> bool {\n+fn tritv_doesntcare(v: t) -> bool {\n     let i: uint = 0u;\n     while i < v.nbits {\n         if tritv_get(v, i) != dont_care { ret false; }\n@@ -253,7 +260,7 @@ fn tritv_doesntcare(v: &t) -> bool {\n     ret true;\n }\n \n-fn to_vec(v: &t) -> [uint] {\n+fn to_vec(v: t) -> [uint] {\n     let i: uint = 0u;\n     let rslt: [uint] = [];\n     while i < v.nbits {\n@@ -268,7 +275,7 @@ fn to_vec(v: &t) -> [uint] {\n     ret rslt;\n }\n \n-fn to_str(v: &t) -> str {\n+fn to_str(v: t) -> str {\n     let i: uint = 0u;\n     let rs: str = \"\";\n     while i < v.nbits {"}, {"sha": "7e3d5572910a4fa23e6200fed1a0890b69f76d49", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 240, "deletions": 211, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -220,7 +220,7 @@ type ty_ctxt = ctxt;\n // Needed for disambiguation from unify::ctxt.\n // Convert from method type to function type.  Pretty easy; we just drop\n // 'ident'.\n-fn method_ty_to_fn_ty(cx: &ctxt, m: method) -> t {\n+fn method_ty_to_fn_ty(cx: ctxt, m: method) -> t {\n     ret mk_fn(cx, m.proto, m.inputs, m.output, m.cf, m.constrs);\n }\n \n@@ -344,7 +344,7 @@ type ty_param_substs_opt_and_ty = {substs: option::t<[ty::t]>, ty: ty::t};\n type node_type_table =\n     @smallintmap::smallintmap<ty::ty_param_substs_opt_and_ty>;\n \n-fn populate_type_store(cx: &ctxt) {\n+fn populate_type_store(cx: ctxt) {\n     intern(cx, ty_nil, none);\n     intern(cx, ty_bool, none);\n     intern(cx, ty_int, none);\n@@ -369,10 +369,10 @@ fn populate_type_store(cx: &ctxt) {\n \n fn mk_rcache() -> creader_cache {\n     type val = {cnum: int, pos: uint, len: uint};\n-    fn hash_cache_entry(k: &val) -> uint {\n+    fn hash_cache_entry(k: val) -> uint {\n         ret (k.cnum as uint) + k.pos + k.len;\n     }\n-    fn eq_cache_entries(a: &val, b: &val) -> bool {\n+    fn eq_cache_entries(a: val, b: val) -> bool {\n         ret a.cnum == b.cnum && a.pos == b.pos && a.len == b.len;\n     }\n     ret map::mk_hashmap(hash_cache_entry, eq_cache_entries);\n@@ -407,27 +407,27 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n \n \n // Type constructors\n-fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n+fn mk_raw_ty(cx: ctxt, st: sty, _in_cname: option::t<str>) -> @raw_t {\n     let cname: option::t<str> = none;\n     let h = hash_type_info(st, cname);\n     let has_params: bool = false;\n     let has_vars: bool = false;\n-    fn derive_flags_t(cx: &ctxt, has_params: &mutable bool,\n+    fn derive_flags_t(cx: ctxt, has_params: &mutable bool,\n                       has_vars: &mutable bool, tt: t) {\n         let rt = interner::get::<@raw_t>(*cx.ts, tt);\n         has_params = has_params || rt.has_params;\n         has_vars = has_vars || rt.has_vars;\n     }\n-    fn derive_flags_mt(cx: &ctxt, has_params: &mutable bool,\n-                       has_vars: &mutable bool, m: &mt) {\n+    fn derive_flags_mt(cx: ctxt, has_params: &mutable bool,\n+                       has_vars: &mutable bool, m: mt) {\n         derive_flags_t(cx, has_params, has_vars, m.ty);\n     }\n-    fn derive_flags_arg(cx: &ctxt, has_params: &mutable bool,\n-                        has_vars: &mutable bool, a: &arg) {\n+    fn derive_flags_arg(cx: ctxt, has_params: &mutable bool,\n+                        has_vars: &mutable bool, a: arg) {\n         derive_flags_t(cx, has_params, has_vars, a.ty);\n     }\n-    fn derive_flags_sig(cx: &ctxt, has_params: &mutable bool,\n-                        has_vars: &mutable bool, args: &[arg], tt: t) {\n+    fn derive_flags_sig(cx: ctxt, has_params: &mutable bool,\n+                        has_vars: &mutable bool, args: [arg], tt: t) {\n         for a: arg in args { derive_flags_arg(cx, has_params, has_vars, a); }\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n@@ -484,33 +484,33 @@ fn mk_raw_ty(cx: &ctxt, st: &sty, _in_cname: &option::t<str>) -> @raw_t {\n           has_vars: has_vars};\n }\n \n-fn intern(cx: &ctxt, st: &sty, cname: &option::t<str>) {\n+fn intern(cx: ctxt, st: sty, cname: option::t<str>) {\n     interner::intern(*cx.ts, mk_raw_ty(cx, st, cname));\n }\n \n-fn gen_ty_full(cx: &ctxt, st: &sty, cname: &option::t<str>) -> t {\n+fn gen_ty_full(cx: ctxt, st: sty, cname: option::t<str>) -> t {\n     let raw_type = mk_raw_ty(cx, st, cname);\n     ret interner::intern(*cx.ts, raw_type);\n }\n \n \n // These are private constructors to this module. External users should always\n // use the mk_foo() functions below.\n-fn gen_ty(cx: &ctxt, st: &sty) -> t { ret gen_ty_full(cx, st, none); }\n+fn gen_ty(cx: ctxt, st: sty) -> t { ret gen_ty_full(cx, st, none); }\n \n-fn mk_nil(_cx: &ctxt) -> t { ret idx_nil; }\n+fn mk_nil(_cx: ctxt) -> t { ret idx_nil; }\n \n-fn mk_bot(_cx: &ctxt) -> t { ret idx_bot; }\n+fn mk_bot(_cx: ctxt) -> t { ret idx_bot; }\n \n-fn mk_bool(_cx: &ctxt) -> t { ret idx_bool; }\n+fn mk_bool(_cx: ctxt) -> t { ret idx_bool; }\n \n-fn mk_int(_cx: &ctxt) -> t { ret idx_int; }\n+fn mk_int(_cx: ctxt) -> t { ret idx_int; }\n \n-fn mk_float(_cx: &ctxt) -> t { ret idx_float; }\n+fn mk_float(_cx: ctxt) -> t { ret idx_float; }\n \n-fn mk_uint(_cx: &ctxt) -> t { ret idx_uint; }\n+fn mk_uint(_cx: ctxt) -> t { ret idx_uint; }\n \n-fn mk_mach(_cx: &ctxt, tm: &ast::ty_mach) -> t {\n+fn mk_mach(_cx: ctxt, tm: ast::ty_mach) -> t {\n     alt tm {\n       ast::ty_u8. { ret idx_u8; }\n       ast::ty_u16. { ret idx_u16; }\n@@ -525,82 +525,82 @@ fn mk_mach(_cx: &ctxt, tm: &ast::ty_mach) -> t {\n     }\n }\n \n-fn mk_char(_cx: &ctxt) -> t { ret idx_char; }\n+fn mk_char(_cx: ctxt) -> t { ret idx_char; }\n \n-fn mk_str(_cx: &ctxt) -> t { ret idx_str; }\n+fn mk_str(_cx: ctxt) -> t { ret idx_str; }\n \n-fn mk_tag(cx: &ctxt, did: &ast::def_id, tys: &[t]) -> t {\n+fn mk_tag(cx: ctxt, did: ast::def_id, tys: [t]) -> t {\n     ret gen_ty(cx, ty_tag(did, tys));\n }\n \n-fn mk_box(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_box(tm)); }\n+fn mk_box(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_box(tm)); }\n \n-fn mk_uniq(cx: &ctxt, typ: t) -> t { ret gen_ty(cx, ty_uniq(typ)); }\n+fn mk_uniq(cx: ctxt, typ: t) -> t { ret gen_ty(cx, ty_uniq(typ)); }\n \n-fn mk_ptr(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_ptr(tm)); }\n+fn mk_ptr(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_ptr(tm)); }\n \n-fn mk_imm_box(cx: &ctxt, ty: t) -> t {\n+fn mk_imm_box(cx: ctxt, ty: t) -> t {\n     ret mk_box(cx, {ty: ty, mut: ast::imm});\n }\n \n-fn mk_mut_ptr(cx: &ctxt, ty: t) -> t {\n+fn mk_mut_ptr(cx: ctxt, ty: t) -> t {\n     ret mk_ptr(cx, {ty: ty, mut: ast::mut});\n }\n \n-fn mk_vec(cx: &ctxt, tm: &mt) -> t { ret gen_ty(cx, ty_vec(tm)); }\n+fn mk_vec(cx: ctxt, tm: mt) -> t { ret gen_ty(cx, ty_vec(tm)); }\n \n-fn mk_rec(cx: &ctxt, fs: &[field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n+fn mk_rec(cx: ctxt, fs: [field]) -> t { ret gen_ty(cx, ty_rec(fs)); }\n \n-fn mk_constr(cx: &ctxt, t: t, cs: &[@type_constr]) -> t {\n+fn mk_constr(cx: ctxt, t: t, cs: [@type_constr]) -> t {\n     ret gen_ty(cx, ty_constr(t, cs));\n }\n \n-fn mk_tup(cx: &ctxt, ts: &[t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n+fn mk_tup(cx: ctxt, ts: [t]) -> t { ret gen_ty(cx, ty_tup(ts)); }\n \n-fn mk_fn(cx: &ctxt, proto: &ast::proto, args: &[arg], ty: t, cf: &controlflow,\n-         constrs: &[@constr]) -> t {\n+fn mk_fn(cx: ctxt, proto: ast::proto, args: [arg], ty: t, cf: controlflow,\n+         constrs: [@constr]) -> t {\n     ret gen_ty(cx, ty_fn(proto, args, ty, cf, constrs));\n }\n \n-fn mk_native_fn(cx: &ctxt, abi: &ast::native_abi, args: &[arg], ty: t) -> t {\n+fn mk_native_fn(cx: ctxt, abi: ast::native_abi, args: [arg], ty: t) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(cx: &ctxt, meths: &[method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n+fn mk_obj(cx: ctxt, meths: [method]) -> t { ret gen_ty(cx, ty_obj(meths)); }\n \n-fn mk_res(cx: &ctxt, did: &ast::def_id, inner: t, tps: &[t]) -> t {\n+fn mk_res(cx: ctxt, did: ast::def_id, inner: t, tps: [t]) -> t {\n     ret gen_ty(cx, ty_res(did, inner, tps));\n }\n \n-fn mk_var(cx: &ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n+fn mk_var(cx: ctxt, v: int) -> t { ret gen_ty(cx, ty_var(v)); }\n \n-fn mk_param(cx: &ctxt, n: uint, k: ast::kind) -> t {\n+fn mk_param(cx: ctxt, n: uint, k: ast::kind) -> t {\n     ret gen_ty(cx, ty_param(n, k));\n }\n \n-fn mk_type(_cx: &ctxt) -> t { ret idx_type; }\n+fn mk_type(_cx: ctxt) -> t { ret idx_type; }\n \n-fn mk_native(cx: &ctxt, did: &def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n+fn mk_native(cx: ctxt, did: def_id) -> t { ret gen_ty(cx, ty_native(did)); }\n \n-fn mk_iter_body_fn(cx: &ctxt, output: t) -> t {\n+fn mk_iter_body_fn(cx: ctxt, output: t) -> t {\n     ret mk_fn(cx, ast::proto_block, [{mode: ast::by_ref, ty: output}],\n               ty::mk_nil(cx), ast::return, []);\n }\n \n // Returns the one-level-deep type structure of the given type.\n-fn struct(cx: &ctxt, typ: t) -> sty { ret interner::get(*cx.ts, typ).struct; }\n+fn struct(cx: ctxt, typ: t) -> sty { ret interner::get(*cx.ts, typ).struct; }\n \n \n // Returns the canonical name of the given type.\n-fn cname(cx: &ctxt, typ: t) -> option::t<str> {\n+fn cname(cx: ctxt, typ: t) -> option::t<str> {\n     ret interner::get(*cx.ts, typ).cname;\n }\n \n \n // Type folds\n type ty_walk = fn(t);\n \n-fn walk_ty(cx: &ctxt, walker: ty_walk, ty: t) {\n+fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n       ty_nil. {/* no-op */ }\n       ty_bot. {/* no-op */ }\n@@ -655,7 +655,7 @@ tag fold_mode {\n     fm_general(fn(t) -> t);\n }\n \n-fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n+fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n     let ty = ty_0;\n     // Fast paths.\n \n@@ -767,33 +767,33 @@ fn fold_ty(cx: &ctxt, fld: fold_mode, ty_0: t) -> t {\n \n // Type utilities\n \n-fn rename(cx: &ctxt, typ: t, new_cname: &str) -> t {\n+fn rename(cx: ctxt, typ: t, new_cname: str) -> t {\n     ret gen_ty_full(cx, struct(cx, typ), some(new_cname));\n }\n \n-fn strip_cname(cx: &ctxt, typ: t) -> t {\n+fn strip_cname(cx: ctxt, typ: t) -> t {\n     ret gen_ty_full(cx, struct(cx, typ), none);\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n-fn copy_cname(cx: &ctxt, struct_ty: t, cname_ty: t) -> t {\n+fn copy_cname(cx: ctxt, struct_ty: t, cname_ty: t) -> t {\n     ret gen_ty_full(cx, struct(cx, struct_ty), cname(cx, cname_ty));\n }\n \n-fn type_is_nil(cx: &ctxt, ty: t) -> bool {\n+fn type_is_nil(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_nil. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_bot(cx: &ctxt, ty: t) -> bool {\n+fn type_is_bot(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_bot. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_bool(cx: &ctxt, ty: t) -> bool {\n+fn type_is_bool(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_bool. { ret true; } _ { ret false; } }\n }\n \n-fn type_is_structural(cx: &ctxt, ty: t) -> bool {\n+fn type_is_structural(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_rec(_) { ret true; }\n       ty_tup(_) { ret true; }\n@@ -806,35 +806,35 @@ fn type_is_structural(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_is_copyable(cx: &ctxt, ty: t) -> bool {\n+fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_res(_, _, _) { false }\n           ty_fn(proto_block., _, _, _, _) { false }\n           _ { true }\n         };\n }\n \n-fn type_is_sequence(cx: &ctxt, ty: t) -> bool {\n+fn type_is_sequence(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_str. { ret true; }\n       ty_vec(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n-fn type_is_str(cx: &ctxt, ty: t) -> bool {\n+fn type_is_str(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_str. { ret true; } _ { ret false; } }\n }\n \n-fn sequence_element_type(cx: &ctxt, ty: t) -> t {\n+fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     alt struct(cx, ty) {\n       ty_str. { ret mk_mach(cx, ast::ty_u8); }\n       ty_vec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n }\n \n-fn type_is_tup_like(cx: &ctxt, ty: t) -> bool {\n+fn type_is_tup_like(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_box(_) { ret true; }\n       ty_rec(_) { ret true; }\n@@ -844,7 +844,7 @@ fn type_is_tup_like(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn get_element_type(cx: &ctxt, ty: t, i: uint) -> t {\n+fn get_element_type(cx: ctxt, ty: t, i: uint) -> t {\n     alt struct(cx, ty) {\n       ty_rec(flds) { ret flds[i].mt.ty; }\n       ty_tup(ts) { ret ts[i]; }\n@@ -858,23 +858,23 @@ fn get_element_type(cx: &ctxt, ty: t, i: uint) -> t {\n     // tag.\n }\n \n-fn type_is_box(cx: &ctxt, ty: t) -> bool {\n+fn type_is_box(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_box(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_is_boxed(cx: &ctxt, ty: t) -> bool {\n+fn type_is_boxed(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_box(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_is_vec(cx: &ctxt, ty: t) -> bool {\n+fn type_is_vec(cx: ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_vec(_) { true }\n           ty_str. { true }\n           _ { false }\n         };\n }\n \n-fn type_is_unique(cx: &ctxt, ty: t) -> bool {\n+fn type_is_unique(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_uniq(_) { ret true; }\n       ty_vec(_) { true }\n@@ -883,7 +883,7 @@ fn type_is_unique(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_is_scalar(cx: &ctxt, ty: t) -> bool {\n+fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_nil. { ret true; }\n       ty_bool. { ret true; }\n@@ -899,7 +899,7 @@ fn type_is_scalar(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n+fn type_has_pointers(cx: ctxt, ty: t) -> bool {\n     alt cx.has_pointer_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n@@ -908,6 +908,7 @@ fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n     let result = false;\n     alt struct(cx, ty) {\n \n+\n       // scalar types\n       ty_nil. {\n         /* no-op */\n@@ -952,15 +953,15 @@ fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n     ret result;\n }\n \n-fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n+fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_res(_, _, _) { true }\n           ty_param(_, _) { true }\n           _ { type_has_pointers(cx, ty) }\n         };\n }\n \n-fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n+fn type_kind(cx: ctxt, ty: t) -> ast::kind {\n     alt cx.kind_cache.find(ty) {\n       some(result) { ret result; }\n       none. {/* fall through */ }\n@@ -975,6 +976,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Scalar types are unique-kind, no substructure.\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_uint. | ty_float. |\n       ty_machine(_) | ty_char. | ty_native(_) {\n@@ -983,13 +985,15 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // A handful of other built-in are unique too.\n       ty_type. | ty_str. | ty_native_fn(_, _, _) {\n         // no-op\n       }\n \n \n \n+\n       // FIXME: obj is broken for now, since we aren't asserting\n       // anything about its fields.\n       ty_obj(_) {\n@@ -998,6 +1002,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // FIXME: the environment capture mode is not fully encoded\n       // here yet, leading to weirdness around closure.\n       ty_fn(proto, _, _, _, _) {\n@@ -1011,6 +1016,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(mt) {\n@@ -1019,6 +1025,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Pointers and unique boxes / vecs raise pinned to shared,\n       // otherwise pass through their pointee kind.\n       ty_ptr(tm) | ty_vec(tm) {\n@@ -1029,6 +1036,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Records lower to the lowest of their members.\n       ty_rec(flds) {\n         for f: field in flds {\n@@ -1038,6 +1046,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n       }\n \n \n+\n       // Tuples lower to the lowest of their members.\n       ty_tup(tys) {\n         for ty: t in tys {\n@@ -1048,6 +1057,7 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Tags lower to the lowest of their variants.\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1064,31 +1074,36 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n \n \n+\n       // Resources are always pinned.\n       ty_res(did, inner, tps) {\n         result = ast::kind_pinned;\n       }\n \n \n \n+\n       ty_var(_) {\n         fail;\n       }\n \n \n \n+\n       ty_param(_, k) {\n         result = kind::lower_kind(result, k);\n       }\n \n \n \n+\n       ty_constr(t, _) {\n         result = type_kind(cx, t);\n       }\n \n \n \n+\n       _ {\n         cx.sess.bug(\"missed case: \" + ty_to_str(cx, ty));\n       }\n@@ -1102,11 +1117,11 @@ fn type_kind(cx: &ctxt, ty: t) -> ast::kind {\n \n // FIXME: should we just return true for native types in\n // type_is_scalar?\n-fn type_is_native(cx: &ctxt, ty: t) -> bool {\n+fn type_is_native(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) { ty_native(_) { ret true; } _ { ret false; } }\n }\n \n-fn type_structurally_contains(cx: &ctxt, ty: t, test: fn(&sty) -> bool) ->\n+fn type_structurally_contains(cx: ctxt, ty: t, test: fn(sty) -> bool) ->\n    bool {\n     let sty = struct(cx, ty);\n     if test(sty) { ret true; }\n@@ -1140,7 +1155,8 @@ fn type_structurally_contains(cx: &ctxt, ty: t, test: fn(&sty) -> bool) ->\n     }\n }\n \n-pure fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n+pure fn type_has_dynamic_size(cx: ctxt, ty: t) -> bool {\n+\n     /* type_structurally_contains can't be declared pure\n     because it takes a function argument. But it should be\n     referentially transparent, since a given type's size should\n@@ -1149,45 +1165,55 @@ pure fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n     actually checkable. It seems to me like a lot of properties\n     that the type context tracks about types should be immutable.)\n     */\n-    unchecked {\n-    type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n-        ret alt sty {\n-          ty_param(_, _) { true }\n-          _ { false }\n-        };\n-    })\n+    unchecked{\n+        type_structurally_contains(cx, ty,\n+                                   fn (sty: sty) -> bool {\n+                                       ret alt sty {\n+                                             ty_param(_, _) { true }\n+                                             _ { false }\n+                                           };\n+                                   })\n     }\n }\n \n // Returns true for types where a copy of a value can be distinguished from\n // the value itself. I.e. types with mutable content that's not shared through\n // a pointer.\n-fn type_allows_implicit_copy(cx: &ctxt, ty: t) -> bool {\n-    ret !type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n-        ret alt sty {\n-          ty_param(_, _) { true }\n-          ty_vec(mt) { mt.mut != ast::imm }\n-          ty_rec(fields) {\n-            for field in fields { if field.mt.mut != ast::imm { ret true; } }\n-            false\n-          }\n-          _ { false }\n-        };\n-    });\n-}\n-\n-fn type_structurally_contains_uniques(cx: &ctxt, ty: t) -> bool {\n-    ret type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n-        ret alt sty {\n-          ty_uniq(_) { ret true; }\n-          ty_vec(_) { true }\n-          ty_str. { true }\n-          _ { ret false; }\n-        };\n-    });\n-}\n-\n-fn type_is_integral(cx: &ctxt, ty: t) -> bool {\n+fn type_allows_implicit_copy(cx: ctxt, ty: t) -> bool {\n+    ret !type_structurally_contains(cx, ty,\n+                                    fn (sty: sty) -> bool {\n+                                        ret alt sty {\n+                                              ty_param(_, _) { true }\n+                                              ty_vec(mt) {\n+                                                mt.mut != ast::imm\n+                                              }\n+                                              ty_rec(fields) {\n+                                                for field in fields {\n+                                                    if field.mt.mut !=\n+                                                           ast::imm {\n+                                                        ret true;\n+                                                    }\n+                                                }\n+                                                false\n+                                              }\n+                                              _ { false }\n+                                            };\n+                                    });\n+}\n+\n+fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n+    ret type_structurally_contains(cx, ty,\n+                                   fn (sty: sty) -> bool {\n+                                       ret alt sty {\n+                                             ty_uniq(_) { ret true; }\n+                                             ty_vec(_) { true }\n+                                             ty_str. { true }\n+                                             _ { ret false; }\n+                                           };\n+                                   });\n+}\n+\n+fn type_is_integral(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }\n       ty_uint. { ret true; }\n@@ -1210,7 +1236,7 @@ fn type_is_integral(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_is_fp(cx: &ctxt, ty: t) -> bool {\n+fn type_is_fp(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_machine(tm) {\n         alt tm {\n@@ -1224,7 +1250,7 @@ fn type_is_fp(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_is_signed(cx: &ctxt, ty: t) -> bool {\n+fn type_is_signed(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }\n       ty_machine(tm) {\n@@ -1241,11 +1267,12 @@ fn type_is_signed(cx: &ctxt, ty: t) -> bool {\n }\n \n // Whether a type is Plain Old Data (i.e. can be safely memmoved).\n-fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n+fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n \n \n+\n       // Scalar types\n       ty_nil. | ty_bot. | ty_bool. | ty_int. | ty_float. | ty_uint. |\n       ty_machine(_) | ty_char. | ty_type. | ty_native(_) | ty_ptr(_) {\n@@ -1254,6 +1281,7 @@ fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n \n \n \n+\n       // Boxed types\n       ty_str. | ty_box(_) | ty_vec(_) | ty_fn(_, _, _, _, _) |\n       ty_native_fn(_, _, _) | ty_obj(_) {\n@@ -1262,6 +1290,7 @@ fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n \n \n \n+\n       // Structural types\n       ty_tag(did, tps) {\n         let variants = tag_variants(cx, did);\n@@ -1288,6 +1317,7 @@ fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n \n \n \n+\n       ty_var(_) {\n         fail \"ty_var in type_is_pod\";\n       }\n@@ -1297,7 +1327,7 @@ fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n     ret result;\n }\n \n-fn type_param(cx: &ctxt, ty: t) -> option::t<uint> {\n+fn type_param(cx: ctxt, ty: t) -> option::t<uint> {\n     alt struct(cx, ty) {\n       ty_param(id, _) { ret some(id); }\n       _ {/* fall through */ }\n@@ -1307,8 +1337,8 @@ fn type_param(cx: &ctxt, ty: t) -> option::t<uint> {\n \n // Returns a vec of all the type variables\n // occurring in t. It may contain duplicates.\n-fn vars_in_type(cx: &ctxt, ty: t) -> [int] {\n-    fn collect_var(cx: &ctxt, vars: &@mutable [int], ty: t) {\n+fn vars_in_type(cx: ctxt, ty: t) -> [int] {\n+    fn collect_var(cx: ctxt, vars: @mutable [int], ty: t) {\n         alt struct(cx, ty) { ty_var(v) { *vars += [v]; } _ { } }\n     }\n     let rslt: @mutable [int] = @mutable [];\n@@ -1318,7 +1348,7 @@ fn vars_in_type(cx: &ctxt, ty: t) -> [int] {\n     ret *rslt;\n }\n \n-fn type_autoderef(cx: &ctxt, t: ty::t) -> ty::t {\n+fn type_autoderef(cx: ctxt, t: ty::t) -> ty::t {\n     let t1: ty::t = t;\n     while true {\n         alt struct(cx, t1) {\n@@ -1341,7 +1371,7 @@ fn type_autoderef(cx: &ctxt, t: ty::t) -> ty::t {\n \n // Type hashing. This function is private to this module (and slow); external\n // users should use `hash_ty()` instead.\n-fn hash_type_structure(st: &sty) -> uint {\n+fn hash_type_structure(st: sty) -> uint {\n     fn hash_uint(id: uint, n: uint) -> uint {\n         let h = id;\n         h += h << 5u + n;\n@@ -1358,7 +1388,7 @@ fn hash_type_structure(st: &sty) -> uint {\n         h += h << 5u + hash_ty(subty);\n         ret h;\n     }\n-    fn hash_type_constr(id: uint, c: &@type_constr) -> uint {\n+    fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n         let h = id;\n         h += h << 5u + hash_def(h, c.node.id);\n         ret hash_type_constr_args(h, c.node.args);\n@@ -1382,7 +1412,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n \n \n-    fn hash_fn(id: uint, args: &[arg], rty: t) -> uint {\n+    fn hash_fn(id: uint, args: [arg], rty: t) -> uint {\n         let h = id;\n         for a: arg in args { h += h << 5u + hash_ty(a.ty); }\n         h += h << 5u + hash_ty(rty);\n@@ -1430,6 +1460,7 @@ fn hash_type_structure(st: &sty) -> uint {\n \n \n \n+\n       // ???\n       ty_fn(_, args, rty, _, _) {\n         ret hash_fn(27u, args, rty);\n@@ -1460,7 +1491,7 @@ fn hash_type_structure(st: &sty) -> uint {\n     }\n }\n \n-fn hash_type_info(st: &sty, cname_opt: &option::t<str>) -> uint {\n+fn hash_type_info(st: sty, cname_opt: option::t<str>) -> uint {\n     let h = hash_type_structure(st);\n     alt cname_opt {\n       none. {/* no-op */ }\n@@ -1469,17 +1500,17 @@ fn hash_type_info(st: &sty, cname_opt: &option::t<str>) -> uint {\n     ret h;\n }\n \n-fn hash_raw_ty(rt: &@raw_t) -> uint { ret rt.hash; }\n+fn hash_raw_ty(rt: @raw_t) -> uint { ret rt.hash; }\n \n-fn hash_ty(typ: &t) -> uint { ret typ; }\n+fn hash_ty(typ: t) -> uint { ret typ; }\n \n \n // Type equality. This function is private to this module (and slow); external\n // users should use `eq_ty()` instead.\n-fn eq_int(x: &uint, y: &uint) -> bool { ret x == y; }\n+fn eq_int(x: uint, y: uint) -> bool { ret x == y; }\n \n-fn arg_eq<T>(eq: &fn(&T, &T) -> bool, a: @sp_constr_arg<T>,\n-             b: @sp_constr_arg<T>) -> bool {\n+fn arg_eq<T>(eq: fn(T, T) -> bool, a: @sp_constr_arg<T>, b: @sp_constr_arg<T>)\n+   -> bool {\n     alt a.node {\n       ast::carg_base. {\n         alt b.node { ast::carg_base. { ret true; } _ { ret false; } }\n@@ -1493,8 +1524,8 @@ fn arg_eq<T>(eq: &fn(&T, &T) -> bool, a: @sp_constr_arg<T>,\n     }\n }\n \n-fn args_eq<T>(eq: fn(&T, &T) -> bool, a: &[@sp_constr_arg<T>],\n-              b: &[@sp_constr_arg<T>]) -> bool {\n+fn args_eq<T>(eq: fn(T, T) -> bool, a: [@sp_constr_arg<T>],\n+              b: [@sp_constr_arg<T>]) -> bool {\n     let i: uint = 0u;\n     for arg: @sp_constr_arg<T> in a {\n         if !arg_eq(eq, arg, b[i]) { ret false; }\n@@ -1503,13 +1534,13 @@ fn args_eq<T>(eq: fn(&T, &T) -> bool, a: &[@sp_constr_arg<T>],\n     ret true;\n }\n \n-fn constr_eq(c: &@constr, d: &@constr) -> bool {\n+fn constr_eq(c: @constr, d: @constr) -> bool {\n     ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n             // FIXME: hack\n             args_eq(eq_int, c.node.args, d.node.args);\n }\n \n-fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n+fn constrs_eq(cs: [@constr], ds: [@constr]) -> bool {\n     if vec::len(cs) != vec::len(ds) { ret false; }\n     let i = 0u;\n     for c: @constr in cs { if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n@@ -1518,7 +1549,7 @@ fn constrs_eq(cs: &[@constr], ds: &[@constr]) -> bool {\n \n // An expensive type equality function. This function is private to this\n // module.\n-fn eq_raw_ty(a: &@raw_t, b: &@raw_t) -> bool {\n+fn eq_raw_ty(a: @raw_t, b: @raw_t) -> bool {\n     // Check hashes (fast path).\n \n     if a.hash != b.hash { ret false; }\n@@ -1541,11 +1572,11 @@ fn eq_raw_ty(a: &@raw_t, b: &@raw_t) -> bool {\n \n // This is the equality function the public should use. It works as long as\n // the types are interned.\n-fn eq_ty(a: &t, b: &t) -> bool { ret a == b; }\n+fn eq_ty(a: t, b: t) -> bool { ret a == b; }\n \n \n // Type lookups\n-fn node_id_to_ty_param_substs_opt_and_ty(cx: &ctxt, id: &ast::node_id) ->\n+fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n    ty_param_substs_opt_and_ty {\n \n \n@@ -1560,26 +1591,26 @@ fn node_id_to_ty_param_substs_opt_and_ty(cx: &ctxt, id: &ast::node_id) ->\n     }\n }\n \n-fn node_id_to_type(cx: &ctxt, id: &ast::node_id) -> t {\n+fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     ret node_id_to_ty_param_substs_opt_and_ty(cx, id).ty;\n }\n \n-fn node_id_to_type_params(cx: &ctxt, id: &ast::node_id) -> [t] {\n+fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> [t] {\n     alt node_id_to_ty_param_substs_opt_and_ty(cx, id).substs {\n       none. { ret []; }\n       some(tps) { ret tps; }\n     }\n }\n \n-fn node_id_has_type_params(cx: &ctxt, id: &ast::node_id) -> bool {\n+fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n     ret vec::len(node_id_to_type_params(cx, id)) > 0u;\n }\n \n \n // Returns a type with type parameter substitutions performed if applicable.\n-fn ty_param_substs_opt_and_ty_to_monotype(cx: &ctxt,\n-                                          tpot: &ty_param_substs_opt_and_ty)\n-   -> t {\n+fn ty_param_substs_opt_and_ty_to_monotype(cx: ctxt,\n+                                          tpot: ty_param_substs_opt_and_ty) ->\n+   t {\n     alt tpot.substs {\n       none. { ret tpot.ty; }\n       some(tps) { ret substitute_type_params(cx, tps, tpot.ty); }\n@@ -1589,15 +1620,15 @@ fn ty_param_substs_opt_and_ty_to_monotype(cx: &ctxt,\n \n // Returns the type of an annotation, with type parameter substitutions\n // performed if applicable.\n-fn node_id_to_monotype(cx: &ctxt, id: ast::node_id) -> t {\n+fn node_id_to_monotype(cx: ctxt, id: ast::node_id) -> t {\n     let tpot = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n     ret ty_param_substs_opt_and_ty_to_monotype(cx, tpot);\n }\n \n \n // Returns the number of distinct type parameters in the given type.\n-fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n-    fn counter(cx: &ctxt, param_indices: @mutable [uint], ty: t) {\n+fn count_ty_params(cx: ctxt, ty: t) -> uint {\n+    fn counter(cx: ctxt, param_indices: @mutable [uint], ty: t) {\n         alt struct(cx, ty) {\n           ty_param(param_idx, _) {\n             let seen = false;\n@@ -1615,47 +1646,47 @@ fn count_ty_params(cx: &ctxt, ty: t) -> uint {\n     ret vec::len::<uint>(*param_indices);\n }\n \n-fn type_contains_vars(cx: &ctxt, typ: t) -> bool {\n+fn type_contains_vars(cx: ctxt, typ: t) -> bool {\n     ret interner::get(*cx.ts, typ).has_vars;\n }\n \n-fn type_contains_params(cx: &ctxt, typ: t) -> bool {\n+fn type_contains_params(cx: ctxt, typ: t) -> bool {\n     ret interner::get(*cx.ts, typ).has_params;\n }\n \n \n // Type accessors for substructures of types\n-fn ty_fn_args(cx: &ctxt, fty: t) -> [arg] {\n+fn ty_fn_args(cx: ctxt, fty: t) -> [arg] {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, a, _, _, _) { ret a; }\n       ty::ty_native_fn(_, a, _) { ret a; }\n       _ { cx.sess.bug(\"ty_fn_args() called on non-fn type\"); }\n     }\n }\n \n-fn ty_fn_proto(cx: &ctxt, fty: t) -> ast::proto {\n+fn ty_fn_proto(cx: ctxt, fty: t) -> ast::proto {\n     alt struct(cx, fty) {\n       ty::ty_fn(p, _, _, _, _) { ret p; }\n       _ { cx.sess.bug(\"ty_fn_proto() called on non-fn type\"); }\n     }\n }\n \n-fn ty_fn_abi(cx: &ctxt, fty: t) -> ast::native_abi {\n+fn ty_fn_abi(cx: ctxt, fty: t) -> ast::native_abi {\n     alt struct(cx, fty) {\n       ty::ty_native_fn(a, _, _) { ret a; }\n       _ { cx.sess.bug(\"ty_fn_abi() called on non-native-fn type\"); }\n     }\n }\n \n-fn ty_fn_ret(cx: &ctxt, fty: t) -> t {\n+fn ty_fn_ret(cx: ctxt, fty: t) -> t {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, r, _, _) { ret r; }\n       ty::ty_native_fn(_, _, r) { ret r; }\n       _ { cx.sess.bug(\"ty_fn_ret() called on non-fn type\"); }\n     }\n }\n \n-fn is_fn_ty(cx: &ctxt, fty: t) -> bool {\n+fn is_fn_ty(cx: ctxt, fty: t) -> bool {\n     alt struct(cx, fty) {\n       ty::ty_fn(_, _, _, _, _) { ret true; }\n       ty::ty_native_fn(_, _, _) { ret true; }\n@@ -1665,11 +1696,11 @@ fn is_fn_ty(cx: &ctxt, fty: t) -> bool {\n \n // Just checks whether it's a fn that returns bool,\n // not its purity.\n-fn is_pred_ty(cx: &ctxt, fty: t) -> bool {\n+fn is_pred_ty(cx: ctxt, fty: t) -> bool {\n     is_fn_ty(cx, fty) && type_is_bool(cx, ty_fn_ret(cx, fty))\n }\n \n-fn ty_var_id(cx: &ctxt, typ: t) -> int {\n+fn ty_var_id(cx: ctxt, typ: t) -> int {\n     alt struct(cx, typ) {\n       ty::ty_var(vid) { ret vid; }\n       _ { log_err \"ty_var_id called on non-var ty\"; fail; }\n@@ -1678,14 +1709,14 @@ fn ty_var_id(cx: &ctxt, typ: t) -> int {\n \n \n // Type accessors for AST nodes\n-fn block_ty(cx: &ctxt, b: &ast::blk) -> t {\n+fn block_ty(cx: ctxt, b: ast::blk) -> t {\n     ret node_id_to_type(cx, b.node.id);\n }\n \n \n // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n // doesn't provide type parameter substitutions.\n-fn pat_ty(cx: &ctxt, pat: &@ast::pat) -> t {\n+fn pat_ty(cx: ctxt, pat: @ast::pat) -> t {\n     ret node_id_to_monotype(cx, pat.id);\n }\n \n@@ -1696,21 +1727,20 @@ fn pat_ty(cx: &ctxt, pat: &@ast::pat) -> t {\n // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&int) -> int\"\n // instead of \"fn(t) -> T with T = int\". If this isn't what you want, see\n // expr_ty_params_and_ty() below.\n-fn expr_ty(cx: &ctxt, expr: &@ast::expr) -> t {\n+fn expr_ty(cx: ctxt, expr: @ast::expr) -> t {\n     ret node_id_to_monotype(cx, expr.id);\n }\n \n-fn expr_ty_params_and_ty(cx: &ctxt, expr: &@ast::expr) ->\n-   {params: [t], ty: t} {\n+fn expr_ty_params_and_ty(cx: ctxt, expr: @ast::expr) -> {params: [t], ty: t} {\n     ret {params: node_id_to_type_params(cx, expr.id),\n          ty: node_id_to_type(cx, expr.id)};\n }\n \n-fn expr_has_ty_params(cx: &ctxt, expr: &@ast::expr) -> bool {\n+fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n     ret node_id_has_type_params(cx, expr.id);\n }\n \n-fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n+fn stmt_node_id(s: @ast::stmt) -> ast::node_id {\n     alt s.node {\n       ast::stmt_decl(_, id) { ret id; }\n       ast::stmt_expr(_, id) { ret id; }\n@@ -1721,28 +1751,28 @@ fn stmt_node_id(s: &@ast::stmt) -> ast::node_id {\n     }\n }\n \n-fn field_idx(sess: &session::session, sp: &span, id: &ast::ident,\n-             fields: &[field]) -> uint {\n+fn field_idx(sess: session::session, sp: span, id: ast::ident,\n+             fields: [field]) -> uint {\n     let i: uint = 0u;\n     for f: field in fields { if str::eq(f.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown field '\" + id + \"' of record\");\n }\n \n-fn method_idx(sess: &session::session, sp: &span, id: &ast::ident,\n-              meths: &[method]) -> uint {\n+fn method_idx(sess: session::session, sp: span, id: ast::ident,\n+              meths: [method]) -> uint {\n     let i: uint = 0u;\n     for m: method in meths { if str::eq(m.ident, id) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n-fn sort_methods(meths: &[method]) -> [method] {\n-    fn method_lteq(a: &method, b: &method) -> bool {\n+fn sort_methods(meths: [method]) -> [method] {\n+    fn method_lteq(a: method, b: method) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n     ret std::sort::merge_sort::<method>(bind method_lteq(_, _), meths);\n }\n \n-fn is_lval(expr: &@ast::expr) -> bool {\n+fn is_lval(expr: @ast::expr) -> bool {\n     alt expr.node {\n       ast::expr_field(_, _) { ret true; }\n       ast::expr_index(_, _) { ret true; }\n@@ -1752,7 +1782,7 @@ fn is_lval(expr: &@ast::expr) -> bool {\n     }\n }\n \n-fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: t) ->\n+fn occurs_check_fails(tcx: ctxt, sp: option::t<span>, vid: int, rt: t) ->\n    bool {\n     if !type_contains_vars(tcx, rt) {\n         // Fast path\n@@ -1766,13 +1796,12 @@ fn occurs_check_fails(tcx: &ctxt, sp: &option::t<span>, vid: int, rt: t) ->\n             // Maybe this should be span_err -- however, there's an\n             // assertion later on that the type doesn't contain\n             // variables, so in this case we have to be sure to die.\n-            tcx.sess.span_fatal(\n-                s,\n-                \"Type inference failed because I \\\n+            tcx.sess.span_fatal(s,\n+                                \"Type inference failed because I \\\n                  could not find a type\\n that's both of the form \"\n-                + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n-                \" and of the form \" + ty_to_str(tcx, rt) +\n-                \". Such a type would have to be infinitely \\\n+                                    + ty_to_str(tcx, ty::mk_var(tcx, vid)) +\n+                                    \" and of the form \" + ty_to_str(tcx, rt) +\n+                                \". Such a type would have to be infinitely \\\n                  large.\");\n           }\n           _ { ret true; }\n@@ -1815,13 +1844,13 @@ mod unify {\n     }\n \n     // Unifies two sets.\n-    fn union(cx: &@ctxt, set_a: uint, set_b: uint) -> union_result {\n+    fn union(cx: @ctxt, set_a: uint, set_b: uint) -> union_result {\n         ufind::grow(cx.vb.sets, uint::max(set_a, set_b) + 1u);\n         let root_a = ufind::find(cx.vb.sets, set_a);\n         let root_b = ufind::find(cx.vb.sets, set_b);\n \n         let replace_type =\n-            bind fn (cx: &@ctxt, t: t, set_a: uint, set_b: uint) {\n+            bind fn (cx: @ctxt, t: t, set_a: uint, set_b: uint) {\n                      ufind::union(cx.vb.sets, set_a, set_b);\n                      let root_c: uint = ufind::find(cx.vb.sets, set_a);\n                      smallintmap::insert::<t>(cx.vb.types, root_c, t);\n@@ -1848,7 +1877,7 @@ mod unify {\n           }\n         }\n     }\n-    fn record_var_binding(cx: &@ctxt, key: int, typ: t) -> result {\n+    fn record_var_binding(cx: @ctxt, key: int, typ: t) -> result {\n         ufind::grow(cx.vb.sets, (key as uint) + 1u);\n         let root = ufind::find(cx.vb.sets, key as uint);\n         let result_type = typ;\n@@ -1883,7 +1912,7 @@ mod unify {\n     // Right now this just checks that the lists of constraints are\n     // pairwise equal.\n     fn unify_constrs(base_t: t, expected: [@type_constr],\n-                     actual: &[@type_constr]) -> result {\n+                     actual: [@type_constr]) -> result {\n         let expected_len = vec::len(expected);\n         let actual_len = vec::len(actual);\n \n@@ -1900,7 +1929,7 @@ mod unify {\n         ret ures_ok(base_t);\n     }\n     fn unify_constr(base_t: t, expected: @type_constr,\n-                    actual_constr: &@type_constr) -> result {\n+                    actual_constr: @type_constr) -> result {\n         let ok_res = ures_ok(base_t);\n         let err_res = ures_err(terr_constr_mismatch(expected, actual_constr));\n         if expected.node.id != actual_constr.node.id { ret err_res; }\n@@ -1945,9 +1974,9 @@ mod unify {\n         fn_common_res_err(result);\n         fn_common_res_ok([arg], t);\n     }\n-    fn unify_fn_common(cx: &@ctxt, _expected: t, _actual: t,\n-                       expected_inputs: &[arg], expected_output: t,\n-                       actual_inputs: &[arg], actual_output: t) ->\n+    fn unify_fn_common(cx: @ctxt, _expected: t, _actual: t,\n+                       expected_inputs: [arg], expected_output: t,\n+                       actual_inputs: [arg], actual_output: t) ->\n        fn_common_res {\n         let expected_len = vec::len::<arg>(expected_inputs);\n         let actual_len = vec::len::<arg>(actual_inputs);\n@@ -1965,9 +1994,8 @@ mod unify {\n \n             let result_mode;\n             if expected_input.mode != actual_input.mode {\n-                ret fn_common_res_err(ures_err(\n-                    terr_mode_mismatch(expected_input.mode,\n-                                       actual_input.mode)));\n+       ret fn_common_res_err(ures_err(terr_mode_mismatch(expected_input.mode,\n+                                                        actual_input.mode)));\n             } else { result_mode = expected_input.mode; }\n             let result = unify_step(cx, expected_input.ty, actual_input.ty);\n             alt result {\n@@ -1984,17 +2012,18 @@ mod unify {\n           _ { ret fn_common_res_err(result); }\n         }\n     }\n-    fn unify_fn(cx: &@ctxt, e_proto: &ast::proto, a_proto: &ast::proto,\n-                expected: t, actual: t, expected_inputs: &[arg],\n-                expected_output: t, actual_inputs: &[arg], actual_output: t,\n-                expected_cf: &controlflow, actual_cf: &controlflow,\n-                _expected_constrs: &[@constr], actual_constrs: &[@constr]) ->\n+    fn unify_fn(cx: @ctxt, e_proto: ast::proto, a_proto: ast::proto,\n+                expected: t, actual: t, expected_inputs: [arg],\n+                expected_output: t, actual_inputs: [arg], actual_output: t,\n+                expected_cf: controlflow, actual_cf: controlflow,\n+                _expected_constrs: [@constr], actual_constrs: [@constr]) ->\n        result {\n         if e_proto != a_proto { ret ures_err(terr_mismatch); }\n         alt expected_cf {\n           ast::return. { }\n \n \n+\n           // ok\n           ast::noreturn. {\n             alt actual_cf {\n@@ -2027,10 +2056,10 @@ mod unify {\n           }\n         }\n     }\n-    fn unify_native_fn(cx: &@ctxt, e_abi: &ast::native_abi,\n-                       a_abi: &ast::native_abi, expected: t, actual: t,\n-                       expected_inputs: &[arg], expected_output: t,\n-                       actual_inputs: &[arg], actual_output: t) -> result {\n+    fn unify_native_fn(cx: @ctxt, e_abi: ast::native_abi,\n+                       a_abi: ast::native_abi, expected: t, actual: t,\n+                       expected_inputs: [arg], expected_output: t,\n+                       actual_inputs: [arg], actual_output: t) -> result {\n         if e_abi != a_abi { ret ures_err(terr_mismatch); }\n         let t =\n             unify_fn_common(cx, expected, actual, expected_inputs,\n@@ -2043,9 +2072,8 @@ mod unify {\n           }\n         }\n     }\n-    fn unify_obj(cx: &@ctxt, expected: t, actual: t,\n-                 expected_meths: &[method], actual_meths: &[method]) ->\n-       result {\n+    fn unify_obj(cx: @ctxt, expected: t, actual: t, expected_meths: [method],\n+                 actual_meths: [method]) -> result {\n         let result_meths: [method] = [];\n         let i: uint = 0u;\n         let expected_len: uint = vec::len::<method>(expected_meths);\n@@ -2081,7 +2109,7 @@ mod unify {\n     }\n \n     // If the given type is a variable, returns the structure of that type.\n-    fn resolve_type_structure(tcx: &ty_ctxt, vb: &@var_bindings, typ: t) ->\n+    fn resolve_type_structure(tcx: ty_ctxt, vb: @var_bindings, typ: t) ->\n        fixup_result {\n         alt struct(tcx, typ) {\n           ty_var(vid) {\n@@ -2095,7 +2123,7 @@ mod unify {\n           _ { ret fix_ok(typ); }\n         }\n     }\n-    fn unify_step(cx: &@ctxt, expected: t, actual: t) -> result {\n+    fn unify_step(cx: @ctxt, expected: t, actual: t) -> result {\n         // TODO: rewrite this using tuple pattern matching when available, to\n         // avoid all this rightward drift and spikiness.\n \n@@ -2109,6 +2137,7 @@ mod unify {\n \n \n \n+\n           // If the RHS is a variable type, then just do the\n           // appropriate binding.\n           ty::ty_var(actual_id) {\n@@ -2158,6 +2187,7 @@ mod unify {\n \n \n \n+\n           // _|_ unifies with anything\n           ty::ty_bot. {\n             ret ures_ok(actual);\n@@ -2443,7 +2473,7 @@ mod unify {\n           }\n         }\n     }\n-    fn unify(expected: t, actual: t, vb: &@var_bindings, tcx: &ty_ctxt) ->\n+    fn unify(expected: t, actual: t, vb: @var_bindings, tcx: ty_ctxt) ->\n        result {\n         let cx = @{vb: vb, tcx: tcx};\n         ret unify_step(cx, expected, actual);\n@@ -2471,9 +2501,9 @@ mod unify {\n     //    Takes an optional span - complain about occurs check violations\n     //    iff the span is present (so that if we already know we're going\n     //    to error anyway, we don't complain)\n-    fn fixup_vars(tcx: ty_ctxt, sp: &option::t<span>, vb: @var_bindings,\n+    fn fixup_vars(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n                   typ: t) -> fixup_result {\n-        fn subst_vars(tcx: ty_ctxt, sp: &option::t<span>, vb: @var_bindings,\n+        fn subst_vars(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n                       unresolved: @mutable option::t<int>, vid: int) -> t {\n             // Should really return a fixup_result instead of a t, but fold_ty\n             // doesn't allow returning anything but a t.\n@@ -2506,8 +2536,8 @@ mod unify {\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n-    fn resolve_type_var(tcx: &ty_ctxt, sp: &option::t<span>,\n-                        vb: &@var_bindings, vid: int) -> fixup_result {\n+    fn resolve_type_var(tcx: ty_ctxt, sp: option::t<span>, vb: @var_bindings,\n+                        vid: int) -> fixup_result {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n         alt smallintmap::find::<t>(vb.types, root_id) {\n@@ -2517,7 +2547,7 @@ mod unify {\n     }\n }\n \n-fn type_err_to_str(err: &ty::type_err) -> str {\n+fn type_err_to_str(err: ty::type_err) -> str {\n     alt err {\n       terr_mismatch. { ret \"types differ\"; }\n       terr_controlflow_mismatch. {\n@@ -2567,7 +2597,7 @@ fn type_err_to_str(err: &ty::type_err) -> str {\n \n // Converts type parameters in a type to type variables and returns the\n // resulting type along with a list of type variable IDs.\n-fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int, typ: t,\n+fn bind_params_in_type(sp: span, cx: ctxt, next_ty_var: fn() -> int, typ: t,\n                        ty_param_count: uint) -> {ids: [int], ty: t} {\n     let param_var_ids: @mutable [int] = @mutable [];\n     let i = 0u;\n@@ -2590,7 +2620,7 @@ fn bind_params_in_type(sp: &span, cx: &ctxt, next_ty_var: fn() -> int, typ: t,\n \n // Replaces type parameters in the given type using the given list of\n // substitions.\n-fn substitute_type_params(cx: &ctxt, substs: &[ty::t], typ: t) -> t {\n+fn substitute_type_params(cx: ctxt, substs: [ty::t], typ: t) -> t {\n     if !type_contains_params(cx, typ) { ret typ; }\n     fn substituter(_cx: ctxt, substs: @[ty::t], idx: uint, _kind: ast::kind)\n        -> t {\n@@ -2600,7 +2630,7 @@ fn substitute_type_params(cx: &ctxt, substs: &[ty::t], typ: t) -> t {\n     ret fold_ty(cx, fm_param(bind substituter(cx, @substs, _, _)), typ);\n }\n \n-fn def_has_ty_params(def: &ast::def) -> bool {\n+fn def_has_ty_params(def: ast::def) -> bool {\n     alt def {\n       ast::def_fn(_, _) { ret true; }\n       ast::def_obj_field(_, _) { ret false; }\n@@ -2623,7 +2653,7 @@ fn def_has_ty_params(def: &ast::def) -> bool {\n // Tag information\n type variant_info = {args: [ty::t], ctor_ty: ty::t, id: ast::def_id};\n \n-fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n+fn tag_variants(cx: ctxt, id: ast::def_id) -> [variant_info] {\n     if ast::local_crate != id.crate { ret csearch::get_tag_variants(cx, id); }\n     let item =\n         alt cx.items.find(id.node) {\n@@ -2658,8 +2688,8 @@ fn tag_variants(cx: &ctxt, id: &ast::def_id) -> [variant_info] {\n \n \n // Returns information about the tag variant with the given ID:\n-fn tag_variant_with_id(cx: &ctxt, tag_id: &ast::def_id,\n-                       variant_id: &ast::def_id) -> variant_info {\n+fn tag_variant_with_id(cx: ctxt, tag_id: ast::def_id, variant_id: ast::def_id)\n+   -> variant_info {\n     let variants = tag_variants(cx, tag_id);\n     let i = 0u;\n     while i < vec::len::<variant_info>(variants) {\n@@ -2705,7 +2735,7 @@ fn ret_ty_of_fn(cx: ctxt, id: ast::node_id) -> t {\n     ret ret_ty_of_fn_ty(cx, node_id_to_type(cx, id));\n }\n \n-fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n+fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n \n     const tycat_other: int = 0;\n     const tycat_bool: int = 1;\n@@ -2749,7 +2779,7 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n         }\n     }\n \n-    fn tycat(cx: &ctxt, ty: t) -> int {\n+    fn tycat(cx: ctxt, ty: t) -> int {\n         alt struct(cx, ty) {\n           ty_bool. { tycat_bool }\n           ty_int. { tycat_int }\n@@ -2799,7 +2829,7 @@ fn is_binopable(cx: &ctxt, ty: t, op: ast::binop) -> bool {\n     ret tbl[tycat(cx, ty)][opcat(op)];\n }\n \n-fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n+fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: @ast::constr_general<T>) ->\n    @ty::constr_general<T> {\n     alt tcx.def_map.find(c.node.id) {\n       some(ast::def_fn(pred_id, ast::pure_fn.)) {\n@@ -2809,10 +2839,9 @@ fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: &@ast::constr_general<T>) ->\n                                id: pred_id});\n       }\n       _ {\n-        tcx.sess.span_fatal(\n-            c.span,\n-            \"Predicate \" + path_to_str(c.node.path) +\n-            \" is unbound or bound to a non-function or an \\\n+        tcx.sess.span_fatal(c.span,\n+                            \"Predicate \" + path_to_str(c.node.path) +\n+             \" is unbound or bound to a non-function or an \\\n             impure function\");\n       }\n     }"}, {"sha": "3ea6bed549abe92f98ec70d44202376a1521a8b6", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 191, "deletions": 217, "changes": 408, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -78,9 +78,9 @@ type fn_ctxt =\n \n \n // Used for ast_ty_to_ty() below.\n-type ty_getter = fn(&ast::def_id) -> ty::ty_param_kinds_and_ty;\n+type ty_getter = fn(ast::def_id) -> ty::ty_param_kinds_and_ty;\n \n-fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n+fn lookup_local(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> int {\n     alt fcx.locals.find(id) {\n       some(x) { x }\n       _ {\n@@ -90,7 +90,7 @@ fn lookup_local(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> int {\n     }\n }\n \n-fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n+fn lookup_def(fcx: @fn_ctxt, sp: span, id: ast::node_id) -> ast::def {\n     alt fcx.ccx.tcx.def_map.find(id) {\n       some(x) { x }\n       _ {\n@@ -100,16 +100,16 @@ fn lookup_def(fcx: &@fn_ctxt, sp: &span, id: ast::node_id) -> ast::def {\n     }\n }\n \n-fn ident_for_local(loc: &@ast::local) -> ast::ident {\n+fn ident_for_local(loc: @ast::local) -> ast::ident {\n     ret alt loc.node.pat.node {\n           ast::pat_bind(name) { name }\n           _ { \"local\" }\n         }; // FIXME DESTR\n }\n \n // Returns the type parameter count and the type for the given definition.\n-fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n-   -> ty_param_kinds_and_ty {\n+fn ty_param_kinds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n+   ty_param_kinds_and_ty {\n     let no_kinds: [ast::kind] = [];\n     alt defn {\n       ast::def_arg(id, _) {\n@@ -157,9 +157,8 @@ fn ty_param_kinds_and_ty_for_def(fcx: &@fn_ctxt, sp: &span, defn: &ast::def)\n \n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n-fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n-                    tpt: &ty_param_kinds_and_ty, sp: &span) ->\n-   ty_param_substs_opt_and_ty {\n+fn instantiate_path(fcx: @fn_ctxt, pth: ast::path, tpt: ty_param_kinds_and_ty,\n+                    sp: span) -> ty_param_substs_opt_and_ty {\n     let ty_param_count = vec::len(tpt.kinds);\n     let bind_result =\n         bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt.ty,\n@@ -170,16 +169,13 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n     if ty_substs_len > 0u {\n         let param_var_len = vec::len(ty_param_vars);\n         if param_var_len == 0u {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                sp,\n-                \"this item does not take type parameters\");\n+            fcx.ccx.tcx.sess.span_fatal(sp,\n+                    \"this item does not take type parameters\");\n         } else if ty_substs_len > param_var_len {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                sp,\n-                \"too many type parameter provided for this item\");\n+            fcx.ccx.tcx.sess.span_fatal(sp,\n+                 \"too many type parameter provided for this item\");\n         } else if ty_substs_len < param_var_len {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                sp,\n+            fcx.ccx.tcx.sess.span_fatal(sp,\n                 \"not enough type parameters provided for this item\");\n         }\n         let ty_substs: [ty::t] = [];\n@@ -211,26 +207,25 @@ fn instantiate_path(fcx: &@fn_ctxt, pth: &ast::path,\n }\n \n // Type tests\n-fn structurally_resolved_type(fcx: &@fn_ctxt, sp: &span, tp: ty::t) -> ty::t {\n+fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     alt ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, tp) {\n       fix_ok(typ_s) { ret typ_s; }\n       fix_err(_) {\n-        fcx.ccx.tcx.sess.span_fatal(\n-            sp,\n-            \"the type of this value must be known in this context\");\n+        fcx.ccx.tcx.sess.span_fatal(sp,\n+              \"the type of this value must be known in this context\");\n       }\n     }\n }\n \n \n // Returns the one-level-deep structure of the given type.\n-fn structure_of(fcx: &@fn_ctxt, sp: &span, typ: ty::t) -> ty::sty {\n+fn structure_of(fcx: @fn_ctxt, sp: span, typ: ty::t) -> ty::sty {\n     ret ty::struct(fcx.ccx.tcx, structurally_resolved_type(fcx, sp, typ));\n }\n \n // Returns the one-level-deep structure of the given type or none if it\n // is not known yet.\n-fn structure_of_maybe(fcx: &@fn_ctxt, _sp: &span, typ: ty::t) ->\n+fn structure_of_maybe(fcx: @fn_ctxt, _sp: span, typ: ty::t) ->\n    option::t<ty::sty> {\n     let r =\n         ty::unify::resolve_type_structure(fcx.ccx.tcx, fcx.var_bindings, typ);\n@@ -240,12 +235,12 @@ fn structure_of_maybe(fcx: &@fn_ctxt, _sp: &span, typ: ty::t) ->\n         }\n }\n \n-fn type_is_integral(fcx: &@fn_ctxt, sp: &span, typ: ty::t) -> bool {\n+fn type_is_integral(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     ret ty::type_is_integral(fcx.ccx.tcx, typ_s);\n }\n \n-fn type_is_scalar(fcx: &@fn_ctxt, sp: &span, typ: ty::t) -> bool {\n+fn type_is_scalar(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     let typ_s = structurally_resolved_type(fcx, sp, typ);\n     ret ty::type_is_scalar(fcx.ccx.tcx, typ_s);\n }\n@@ -254,8 +249,7 @@ fn type_is_scalar(fcx: &@fn_ctxt, sp: &span, typ: ty::t) -> bool {\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID:\n-fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n-   ty::t {\n+fn ast_ty_to_ty(tcx: ty::ctxt, getter: ty_getter, ast_ty: @ast::ty) -> ty::t {\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(some(ty)) { ret ty; }\n       some(none.) {\n@@ -268,16 +262,15 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n     } /* go on */\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n-    fn ast_arg_to_arg(tcx: &ty::ctxt, getter: &ty_getter, arg: &ast::ty_arg)\n-       -> {mode: ty::mode, ty: ty::t} {\n+    fn ast_arg_to_arg(tcx: ty::ctxt, getter: ty_getter, arg: ast::ty_arg) ->\n+       {mode: ty::mode, ty: ty::t} {\n         ret {mode: arg.node.mode, ty: ast_ty_to_ty(tcx, getter, arg.node.ty)};\n     }\n-    fn ast_mt_to_mt(tcx: &ty::ctxt, getter: &ty_getter, mt: &ast::mt) ->\n-       ty::mt {\n+    fn ast_mt_to_mt(tcx: ty::ctxt, getter: ty_getter, mt: ast::mt) -> ty::mt {\n         ret {ty: ast_ty_to_ty(tcx, getter, mt.ty), mut: mt.mut};\n     }\n-    fn instantiate(tcx: &ty::ctxt, sp: &span, getter: &ty_getter,\n-                   id: &ast::def_id, args: &[@ast::ty]) -> ty::t {\n+    fn instantiate(tcx: ty::ctxt, sp: span, getter: ty_getter,\n+                   id: ast::def_id, args: [@ast::ty]) -> ty::t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n \n@@ -411,8 +404,8 @@ fn ast_ty_to_ty(tcx: &ty::ctxt, getter: &ty_getter, ast_ty: &@ast::ty) ->\n \n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n-fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: &@ast::ty) -> ty::t {\n-    fn getter(ccx: @crate_ctxt, id: &ast::def_id) ->\n+fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: @ast::ty) -> ty::t {\n+    fn getter(ccx: @crate_ctxt, id: ast::def_id) ->\n        ty::ty_param_kinds_and_ty {\n         ret ty::lookup_item_type(ccx.tcx, id);\n     }\n@@ -421,7 +414,7 @@ fn ast_ty_to_ty_crate(ccx: @crate_ctxt, ast_ty: &@ast::ty) -> ty::t {\n }\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n-fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: &@ast::ty) ->\n+fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: @ast::ty) ->\n    option::t<ty::t> {\n     alt ast_ty.node {\n       ast::ty_infer. { none }\n@@ -430,7 +423,7 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, ast_ty: &@ast::ty) ->\n }\n // A wrapper around ast_ty_to_ty_infer that generates a new type variable if\n // there isn't a fixed type.\n-fn ast_ty_to_ty_crate_tyvar(fcx: &@fn_ctxt, ast_ty: &@ast::ty) -> ty::t {\n+fn ast_ty_to_ty_crate_tyvar(fcx: @fn_ctxt, ast_ty: @ast::ty) -> ty::t {\n     alt ast_ty_to_ty_crate_infer(fcx.ccx, ast_ty) {\n       some(ty) { ty }\n       none. { next_ty_var(fcx) }\n@@ -440,14 +433,14 @@ fn ast_ty_to_ty_crate_tyvar(fcx: &@fn_ctxt, ast_ty: &@ast::ty) -> ty::t {\n \n // Functions that write types into the node type table.\n mod write {\n-    fn inner(ntt: &node_type_table, node_id: ast::node_id,\n-             tpot: &ty_param_substs_opt_and_ty) {\n+    fn inner(ntt: node_type_table, node_id: ast::node_id,\n+             tpot: ty_param_substs_opt_and_ty) {\n         smallintmap::insert(*ntt, node_id as uint, tpot);\n     }\n \n     // Writes a type parameter count and type pair into the node type table.\n-    fn ty(tcx: &ty::ctxt, node_id: ast::node_id,\n-          tpot: &ty_param_substs_opt_and_ty) {\n+    fn ty(tcx: ty::ctxt, node_id: ast::node_id,\n+          tpot: ty_param_substs_opt_and_ty) {\n         assert (!ty::type_contains_vars(tcx, tpot.ty));\n         inner(tcx.node_types, node_id, tpot);\n     }\n@@ -456,15 +449,15 @@ mod write {\n     // This function allows for the possibility of type variables, which will\n     // be rewritten later during the fixup phase.\n     fn ty_fixup(fcx: @fn_ctxt, node_id: ast::node_id,\n-                tpot: &ty_param_substs_opt_and_ty) {\n+                tpot: ty_param_substs_opt_and_ty) {\n         inner(fcx.ccx.tcx.node_types, node_id, tpot);\n         if ty::type_contains_vars(fcx.ccx.tcx, tpot.ty) {\n             fcx.fixups += [node_id];\n         }\n     }\n \n     // Writes a type with no type parameters into the node type table.\n-    fn ty_only(tcx: &ty::ctxt, node_id: ast::node_id, typ: ty::t) {\n+    fn ty_only(tcx: ty::ctxt, node_id: ast::node_id, typ: ty::t) {\n         ty(tcx, node_id, {substs: none::<[ty::t]>, ty: typ});\n     }\n \n@@ -475,20 +468,20 @@ mod write {\n     }\n \n     // Writes a nil type into the node type table.\n-    fn nil_ty(tcx: &ty::ctxt, node_id: ast::node_id) {\n+    fn nil_ty(tcx: ty::ctxt, node_id: ast::node_id) {\n         ret ty(tcx, node_id, {substs: none::<[ty::t]>, ty: ty::mk_nil(tcx)});\n     }\n \n     // Writes the bottom type into the node type table.\n-    fn bot_ty(tcx: &ty::ctxt, node_id: ast::node_id) {\n+    fn bot_ty(tcx: ty::ctxt, node_id: ast::node_id) {\n         ret ty(tcx, node_id, {substs: none::<[ty::t]>, ty: ty::mk_bot(tcx)});\n     }\n }\n \n // Determine the proto for a fn type given the proto for its associated\n // code. This is needed because fn and lambda have fn type while iter\n // has iter type and block has block type. This may end up changing.\n-fn proto_to_ty_proto(proto: &ast::proto) -> ast::proto {\n+fn proto_to_ty_proto(proto: ast::proto) -> ast::proto {\n     ret alt proto {\n           ast::proto_iter. | ast::proto_block. { proto }\n           _ { ast::proto_fn }\n@@ -512,7 +505,7 @@ fn proto_to_ty_proto(proto: &ast::proto) -> ast::proto {\n mod collect {\n     type ctxt = {tcx: ty::ctxt};\n \n-    fn mk_ty_params(cx: &@ctxt, atps: &[ast::ty_param]) -> [ty::t] {\n+    fn mk_ty_params(cx: @ctxt, atps: [ast::ty_param]) -> [ty::t] {\n         let tps = [];\n         let i = 0u;\n         for atp: ast::ty_param in atps {\n@@ -522,16 +515,16 @@ mod collect {\n         ret tps;\n     }\n \n-    fn ty_param_kinds(tps: &[ast::ty_param]) -> [ast::kind] {\n+    fn ty_param_kinds(tps: [ast::ty_param]) -> [ast::kind] {\n         let k: [ast::kind] = [];\n         for p: ast::ty_param in tps { k += [p.kind] }\n         ret k;\n     }\n \n-    fn ty_of_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t,\n-                     ty_of_arg: &fn(&ast::arg) -> arg, decl: &ast::fn_decl,\n-                     proto: ast::proto, ty_params: &[ast::ty_param],\n-                     def_id: &option::t<ast::def_id>) ->\n+    fn ty_of_fn_decl(cx: @ctxt, convert: fn(@ast::ty) -> ty::t,\n+                     ty_of_arg: fn(ast::arg) -> arg, decl: ast::fn_decl,\n+                     proto: ast::proto, ty_params: [ast::ty_param],\n+                     def_id: option::t<ast::def_id>) ->\n        ty::ty_param_kinds_and_ty {\n         let input_tys = [];\n         for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n@@ -548,10 +541,10 @@ mod collect {\n         alt def_id { some(did) { cx.tcx.tcache.insert(did, tpt); } _ { } }\n         ret tpt;\n     }\n-    fn ty_of_native_fn_decl(cx: &@ctxt, convert: &fn(&@ast::ty) -> ty::t,\n-                            ty_of_arg: &fn(&ast::arg) -> arg,\n-                            decl: &ast::fn_decl, abi: ast::native_abi,\n-                            ty_params: &[ast::ty_param], def_id: &ast::def_id)\n+    fn ty_of_native_fn_decl(cx: @ctxt, convert: fn(@ast::ty) -> ty::t,\n+                            ty_of_arg: fn(ast::arg) -> arg,\n+                            decl: ast::fn_decl, abi: ast::native_abi,\n+                            ty_params: [ast::ty_param], def_id: ast::def_id)\n        -> ty::ty_param_kinds_and_ty {\n         let input_tys = [];\n         for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(a)]; }\n@@ -562,7 +555,7 @@ mod collect {\n         cx.tcx.tcache.insert(def_id, tpt);\n         ret tpt;\n     }\n-    fn getter(cx: @ctxt, id: &ast::def_id) -> ty::ty_param_kinds_and_ty {\n+    fn getter(cx: @ctxt, id: ast::def_id) -> ty::ty_param_kinds_and_ty {\n         if id.crate != ast::local_crate {\n             // This is a type we need to load in from the crate reader.\n             ret csearch::get_type(cx.tcx, id);\n@@ -578,12 +571,12 @@ mod collect {\n         }\n         ret tpt;\n     }\n-    fn ty_of_arg(cx: @ctxt, a: &ast::arg) -> ty::arg {\n+    fn ty_of_arg(cx: @ctxt, a: ast::arg) -> ty::arg {\n         let f = bind getter(cx, _);\n         let tt = ast_ty_to_ty(cx.tcx, f, a.ty);\n         ret {mode: a.mode, ty: tt};\n     }\n-    fn ty_of_method(cx: @ctxt, m: &@ast::method) -> ty::method {\n+    fn ty_of_method(cx: @ctxt, m: @ast::method) -> ty::method {\n         let get = bind getter(cx, _);\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n \n@@ -605,15 +598,15 @@ mod collect {\n              cf: m.node.meth.decl.cf,\n              constrs: out_constrs};\n     }\n-    fn ty_of_obj(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n-                 ty_params: &[ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n+    fn ty_of_obj(cx: @ctxt, id: ast::ident, ob: ast::_obj,\n+                 ty_params: [ast::ty_param]) -> ty::ty_param_kinds_and_ty {\n         let methods = get_obj_method_types(cx, ob);\n         let t_obj = ty::mk_obj(cx.tcx, ty::sort_methods(methods));\n         t_obj = ty::rename(cx.tcx, t_obj, id);\n         ret {kinds: ty_param_kinds(ty_params), ty: t_obj};\n     }\n-    fn ty_of_obj_ctor(cx: @ctxt, id: &ast::ident, ob: &ast::_obj,\n-                      ctor_id: ast::node_id, ty_params: &[ast::ty_param]) ->\n+    fn ty_of_obj_ctor(cx: @ctxt, id: ast::ident, ob: ast::_obj,\n+                      ctor_id: ast::node_id, ty_params: [ast::ty_param]) ->\n        ty::ty_param_kinds_and_ty {\n         let t_obj = ty_of_obj(cx, id, ob, ty_params);\n \n@@ -631,7 +624,7 @@ mod collect {\n         cx.tcx.tcache.insert(local_def(ctor_id), tpt);\n         ret tpt;\n     }\n-    fn ty_of_item(cx: &@ctxt, it: &@ast::item) -> ty::ty_param_kinds_and_ty {\n+    fn ty_of_item(cx: @ctxt, it: @ast::item) -> ty::ty_param_kinds_and_ty {\n         let get = bind getter(cx, _);\n         let convert = bind ast_ty_to_ty(cx.tcx, get, _);\n         let no_kinds: [ast::kind] = [];\n@@ -687,7 +680,7 @@ mod collect {\n           ast::item_native_mod(_) { fail; }\n         }\n     }\n-    fn ty_of_native_item(cx: &@ctxt, it: &@ast::native_item,\n+    fn ty_of_native_item(cx: @ctxt, it: @ast::native_item,\n                          abi: ast::native_abi) -> ty::ty_param_kinds_and_ty {\n         let no_kinds: [ast::kind] = [];\n         alt it.node {\n@@ -710,9 +703,9 @@ mod collect {\n           }\n         }\n     }\n-    fn get_tag_variant_types(cx: &@ctxt, tag_id: &ast::def_id,\n-                             variants: &[ast::variant],\n-                             ty_params: &[ast::ty_param]) {\n+    fn get_tag_variant_types(cx: @ctxt, tag_id: ast::def_id,\n+                             variants: [ast::variant],\n+                             ty_params: [ast::ty_param]) {\n         // Create a set of parameter types shared among all the variants.\n \n         let ty_param_tys: [ty::t] = mk_ty_params(cx, ty_params);\n@@ -744,15 +737,15 @@ mod collect {\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn get_obj_method_types(cx: &@ctxt, object: &ast::_obj) -> [ty::method] {\n+    fn get_obj_method_types(cx: @ctxt, object: ast::_obj) -> [ty::method] {\n         let meths = [];\n         for m: @ast::method in object.methods {\n             meths += [ty_of_method(cx, m)];\n         }\n         ret meths;\n     }\n     fn convert(cx: @ctxt, abi: @mutable option::t<ast::native_abi>,\n-               it: &@ast::item) {\n+               it: @ast::item) {\n         alt it.node {\n           ast::item_mod(_) {\n             // ignore item_mod, it has no type.\n@@ -827,7 +820,7 @@ mod collect {\n         }\n     }\n     fn convert_native(cx: @ctxt, abi: @mutable option::t<ast::native_abi>,\n-                      i: &@ast::native_item) {\n+                      i: @ast::native_item) {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n         // table.\n@@ -843,7 +836,7 @@ mod collect {\n           }\n         }\n     }\n-    fn collect_item_types(tcx: &ty::ctxt, crate: &@ast::crate) {\n+    fn collect_item_types(tcx: ty::ctxt, crate: @ast::crate) {\n         // We have to propagate the surrounding ABI to the native items\n         // contained within the native module.\n         let abi = @mutable none::<ast::native_abi>;\n@@ -853,15 +846,15 @@ mod collect {\n                                        visit_native_item:\n                                            bind convert_native(cx, abi, _)\n                                           with\n-                                          *visit::default_simple_visitor()});\n+                               *visit::default_simple_visitor()});\n         visit::visit_crate(*crate, (), visit);\n     }\n }\n \n \n // Type unification\n mod unify {\n-    fn unify(fcx: &@fn_ctxt, expected: ty::t, actual: ty::t) ->\n+    fn unify(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) ->\n        ty::unify::result {\n         ret ty::unify::unify(expected, actual, fcx.var_bindings, fcx.ccx.tcx);\n     }\n@@ -870,7 +863,7 @@ mod unify {\n \n // FIXME This is almost a duplicate of ty::type_autoderef, with structure_of\n // instead of ty::struct.\n-fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: ty::t) -> ty::t {\n+fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     let t1 = t;\n     while true {\n         alt structure_of(fcx, sp, t1) {\n@@ -904,8 +897,8 @@ fn do_autoderef(fcx: &@fn_ctxt, sp: &span, t: ty::t) -> ty::t {\n     fail;\n }\n \n-fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: ty::t,\n-                      expected: ty::t) -> ty::t {\n+fn do_fn_block_coerce(fcx: @fn_ctxt, sp: span, actual: ty::t, expected: ty::t)\n+   -> ty::t {\n \n     // fns can be silently coerced to blocks when being used as\n     // function call or bind arguments, but not the reverse.\n@@ -928,7 +921,7 @@ fn do_fn_block_coerce(fcx: &@fn_ctxt, sp: &span, actual: ty::t,\n }\n \n \n-fn resolve_type_vars_if_possible(fcx: &@fn_ctxt, typ: ty::t) -> ty::t {\n+fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n     alt ty::unify::fixup_vars(fcx.ccx.tcx, none, fcx.var_bindings, typ) {\n       fix_ok(new_type) { ret new_type; }\n       fix_err(_) { ret typ; }\n@@ -941,24 +934,24 @@ fn resolve_type_vars_if_possible(fcx: &@fn_ctxt, typ: ty::t) -> ty::t {\n type ty_param_substs_and_ty = {substs: [ty::t], ty: ty::t};\n \n mod demand {\n-    fn simple(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t) ->\n+    fn simple(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t) ->\n        ty::t {\n         full(fcx, sp, expected, actual, [], false).ty\n     }\n-    fn block_coerce(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t)\n+    fn block_coerce(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t)\n        -> ty::t {\n         full(fcx, sp, expected, actual, [], true).ty\n     }\n \n-    fn with_substs(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t,\n-                   ty_param_substs_0: &[ty::t]) -> ty_param_substs_and_ty {\n+    fn with_substs(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t,\n+                   ty_param_substs_0: [ty::t]) -> ty_param_substs_and_ty {\n         full(fcx, sp, expected, actual, ty_param_substs_0, false)\n     }\n \n     // Requires that the two types unify, and prints an error message if they\n     // don't. Returns the unified type and the type parameter substitutions.\n-    fn full(fcx: &@fn_ctxt, sp: &span, expected: ty::t, actual: ty::t,\n-            ty_param_substs_0: &[ty::t], do_block_coerce: bool) ->\n+    fn full(fcx: @fn_ctxt, sp: span, expected: ty::t, actual: ty::t,\n+            ty_param_substs_0: [ty::t], do_block_coerce: bool) ->\n        ty_param_substs_and_ty {\n         if do_block_coerce {\n             actual = do_fn_block_coerce(fcx, sp, actual, expected);\n@@ -975,8 +968,8 @@ mod demand {\n             simple(fcx, sp, ty_param_subst, t_0);\n         }\n \n-        fn mk_result(fcx: &@fn_ctxt, result_ty: ty::t,\n-                     ty_param_subst_var_ids: &[int]) ->\n+        fn mk_result(fcx: @fn_ctxt, result_ty: ty::t,\n+                     ty_param_subst_var_ids: [int]) ->\n            ty_param_substs_and_ty {\n             let result_ty_param_substs: [ty::t] = [];\n             for var_id: int in ty_param_subst_var_ids {\n@@ -1006,7 +999,7 @@ mod demand {\n \n \n // Returns true if the two types unify and false if they don't.\n-fn are_compatible(fcx: &@fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n+fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     alt unify::unify(fcx, expected, actual) {\n       ures_ok(_) { ret true; }\n       ures_err(_) { ret false; }\n@@ -1015,8 +1008,8 @@ fn are_compatible(fcx: &@fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n \n \n // Returns the types of the arguments to a tag variant.\n-fn variant_arg_types(ccx: &@crate_ctxt, _sp: &span, vid: &ast::def_id,\n-                     tag_ty_params: &[ty::t]) -> [ty::t] {\n+fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n+                     tag_ty_params: [ty::t]) -> [ty::t] {\n     let result: [ty::t] = [];\n     let tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt ty::struct(ccx.tcx, tpt.ty) {\n@@ -1052,7 +1045,7 @@ mod writeback {\n     export resolve_type_vars_in_block;\n     export resolve_type_vars_in_expr;\n \n-    fn resolve_type_vars_in_type(fcx: &@fn_ctxt, sp: &span, typ: ty::t) ->\n+    fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t) ->\n        option::t<ty::t> {\n         if !ty::type_contains_vars(fcx.ccx.tcx, typ) { ret some(typ); }\n         alt ty::unify::fixup_vars(fcx.ccx.tcx, some(sp), fcx.var_bindings,\n@@ -1066,8 +1059,7 @@ mod writeback {\n           }\n         }\n     }\n-    fn resolve_type_vars_for_node(wbcx: &wb_ctxt, sp: &span,\n-                                  id: ast::node_id) {\n+    fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id) {\n         let fcx = wbcx.fcx;\n         let tpot = ty::node_id_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx, id);\n         let new_ty =\n@@ -1098,12 +1090,12 @@ mod writeback {\n         {fcx: @fn_ctxt, mutable success: bool};\n     type wb_vt = visit::vt<wb_ctxt>;\n \n-    fn visit_stmt(s: &@ast::stmt, wbcx: &wb_ctxt, v: &wb_vt) {\n+    fn visit_stmt(s: @ast::stmt, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, s.span, ty::stmt_node_id(s));\n         visit::visit_stmt(s, wbcx, v);\n     }\n-    fn visit_expr(e: &@ast::expr, wbcx: &wb_ctxt, v: &wb_vt) {\n+    fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n         alt e.node {\n@@ -1116,17 +1108,17 @@ mod writeback {\n         }\n         visit::visit_expr(e, wbcx, v);\n     }\n-    fn visit_block(b: &ast::blk, wbcx: &wb_ctxt, v: &wb_vt) {\n+    fn visit_block(b: ast::blk, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, b.span, b.node.id);\n         visit::visit_block(b, wbcx, v);\n     }\n-    fn visit_pat(p: &@ast::pat, wbcx: &wb_ctxt, v: &wb_vt) {\n+    fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, p.span, p.id);\n         visit::visit_pat(p, wbcx, v);\n     }\n-    fn visit_local(l: &@ast::local, wbcx: &wb_ctxt, v: &wb_vt) {\n+    fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n         if !wbcx.success { ret; }\n         let var_id = lookup_local(wbcx.fcx, l.span, l.node.id);\n         let fix_rslt =\n@@ -1143,11 +1135,11 @@ mod writeback {\n         }\n         visit::visit_local(l, wbcx, v);\n     }\n-    fn visit_item(_item: &@ast::item, _wbcx: &wb_ctxt, _v: &wb_vt) {\n+    fn visit_item(_item: @ast::item, _wbcx: wb_ctxt, _v: wb_vt) {\n         // Ignore items\n     }\n \n-    fn resolve_type_vars_in_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n+    fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n         let wbcx = {fcx: fcx, mutable success: true};\n         let visit =\n             visit::mk_vt(@{visit_item: visit_item,\n@@ -1161,7 +1153,7 @@ mod writeback {\n         ret wbcx.success;\n     }\n \n-    fn resolve_type_vars_in_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n+    fn resolve_type_vars_in_block(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n         let wbcx = {fcx: fcx, mutable success: true};\n         let visit =\n             visit::mk_vt(@{visit_item: visit_item,\n@@ -1186,8 +1178,8 @@ type gather_result =\n      next_var_id: @mutable int};\n \n // Used only as a helper for check_fn.\n-fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n-                 old_fcx: &option::t<@fn_ctxt>) -> gather_result {\n+fn gather_locals(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n+                 old_fcx: option::t<@fn_ctxt>) -> gather_result {\n     let {vb: vb, locals: locals, local_names: local_names, nvi: nvi} =\n         alt old_fcx {\n           none. {\n@@ -1207,7 +1199,7 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n \n     let next_var_id = lambda () -> int { let rv = *nvi; *nvi += 1; ret rv; };\n     let assign =\n-        lambda (nid: ast::node_id, ident: &ast::ident,\n+        lambda (nid: ast::node_id, ident: ast::ident,\n                 ty_opt: option::t<ty::t>) {\n             let var_id = next_var_id();\n             locals.insert(nid, var_id);\n@@ -1246,15 +1238,15 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n \n     // Add explicitly-declared locals.\n     let visit_local =\n-        lambda (local: &@ast::local, e: &(), v: &visit::vt<()>) {\n+        lambda (local: @ast::local, e: (), v: visit::vt<()>) {\n             let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n             assign(local.node.id, ident_for_local(local), local_ty);\n             visit::visit_local(local, e, v);\n         };\n \n     // Add pattern bindings.\n     let visit_pat =\n-        lambda (p: &@ast::pat, e: &(), v: &visit::vt<()>) {\n+        lambda (p: @ast::pat, e: (), v: visit::vt<()>) {\n             alt p.node {\n               ast::pat_bind(ident) { assign(p.id, ident, none); }\n               _ {/* no-op */ }\n@@ -1263,11 +1255,11 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n         };\n \n     // Don't descend into fns and items\n-    fn visit_fn<E>(_f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span,\n-                   _i: &ast::fn_ident, _id: ast::node_id, _e: &E,\n-                   _v: &visit::vt<E>) {\n+    fn visit_fn<E>(_f: ast::_fn, _tp: [ast::ty_param], _sp: span,\n+                   _i: ast::fn_ident, _id: ast::node_id, _e: E,\n+                   _v: visit::vt<E>) {\n     }\n-    fn visit_item<E>(_i: &@ast::item, _e: &E, _v: &visit::vt<E>) { }\n+    fn visit_item<E>(_i: @ast::item, _e: E, _v: visit::vt<E>) { }\n \n     let visit =\n         @{visit_local: visit_local,\n@@ -1282,7 +1274,7 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n }\n \n // AST fragment checking\n-fn check_lit(ccx: @crate_ctxt, lit: &@ast::lit) -> ty::t {\n+fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n     alt lit.node {\n       ast::lit_str(_) { ret ty::mk_str(ccx.tcx); }\n       ast::lit_char(_) { ret ty::mk_char(ccx.tcx); }\n@@ -1298,7 +1290,7 @@ fn check_lit(ccx: @crate_ctxt, lit: &@ast::lit) -> ty::t {\n \n // Pattern checking is top-down rather than bottom-up so that bindings get\n // their types immediately.\n-fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n+fn check_pat(fcx: @fn_ctxt, map: ast_util::pat_id_map, pat: @ast::pat,\n              expected: ty::t) {\n     alt pat.node {\n       ast::pat_wild. { write::ty_only_fixup(fcx, pat.id, expected); }\n@@ -1372,9 +1364,8 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n                 }\n             } else if subpats_len > 0u {\n                 // TODO: note definition of tag variant\n-                fcx.ccx.tcx.sess.span_fatal(\n-                    pat.span,\n-                    #fmt[\"this pattern has %u field%s, \\\n+                fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                       #fmt[\"this pattern has %u field%s, \\\n                           but the corresponding \\\n                           variant has no fields\",\n                                                  subpats_len,\n@@ -1387,11 +1378,10 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n           _ {\n             // FIXME: Switch expected and actual in this message? I\n             // can never tell.\n-            fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n-                #fmt[\"mismatched types: expected %s, found tag\",\n-                     ty_to_str(fcx.ccx.tcx,\n-                               expected)]);\n+            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                       #fmt[\"mismatched types: expected %s, found tag\",\n+                                             ty_to_str(fcx.ccx.tcx,\n+                                                       expected)]);\n           }\n         }\n         write::ty_fixup(fcx, pat.id, path_tpot);\n@@ -1401,24 +1391,22 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_rec(fields) { ex_fields = fields; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n-                #fmt[\"mismatched types: expected %s, found record\",\n+            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                    #fmt[\"mismatched types: expected %s, found record\",\n                                              ty_to_str(fcx.ccx.tcx,\n                                                        expected)]);\n           }\n         }\n         let f_count = vec::len(fields);\n         let ex_f_count = vec::len(ex_fields);\n         if ex_f_count < f_count || !etc && ex_f_count > f_count {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n-                #fmt[\"mismatched types: expected a record \\\n+            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                   #fmt[\"mismatched types: expected a record \\\n                       with %u fields, found one with %u \\\n                       fields\",\n                                              ex_f_count, f_count]);\n         }\n-        fn matches(name: &str, f: &ty::field) -> bool {\n+        fn matches(name: str, f: ty::field) -> bool {\n             ret str::eq(name, f.ident);\n         }\n         for f: ast::field_pat in fields {\n@@ -1439,18 +1427,16 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_tup(elts) { ex_elts = elts; }\n           _ {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n+            fcx.ccx.tcx.sess.span_fatal(pat.span,\n                 #fmt[\"mismatched types: expected %s, found tuple\",\n                                              ty_to_str(fcx.ccx.tcx,\n                                                        expected)]);\n           }\n         }\n         let e_count = vec::len(elts);\n         if e_count != vec::len(ex_elts) {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                pat.span,\n-                #fmt[\"mismatched types: expected a tuple \\\n+            fcx.ccx.tcx.sess.span_fatal(pat.span,\n+                  #fmt[\"mismatched types: expected a tuple \\\n                       with %u fields, found one with %u \\\n                       fields\",\n                                              vec::len(ex_elts), e_count]);\n@@ -1476,8 +1462,7 @@ fn check_pat(fcx: &@fn_ctxt, map: &ast_util::pat_id_map, pat: &@ast::pat,\n     }\n }\n \n-fn require_impure(sess: &session::session, f_purity: &ast::purity,\n-                  sp: &span) {\n+fn require_impure(sess: session::session, f_purity: ast::purity, sp: span) {\n     alt f_purity {\n       ast::impure_fn. { ret; }\n       ast::pure_fn. {\n@@ -1486,46 +1471,44 @@ fn require_impure(sess: &session::session, f_purity: &ast::purity,\n     }\n }\n \n-fn require_pure_call(ccx: @crate_ctxt, caller_purity: &ast::purity,\n-                     callee: &@ast::expr, sp: &span) {\n+fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n+                     callee: @ast::expr, sp: span) {\n     alt caller_purity {\n       ast::impure_fn. { ret; }\n       ast::pure_fn. {\n         alt ccx.tcx.def_map.find(callee.id) {\n           some(ast::def_fn(_, ast::pure_fn.)) { ret; }\n           _ {\n-            ccx.tcx.sess.span_fatal(\n-                sp,\n-                \"Pure function calls function not known to be pure\");\n+            ccx.tcx.sess.span_fatal(sp,\n+         \"Pure function calls function not known to be pure\");\n           }\n         }\n       }\n     }\n }\n \n-type unifier = fn(&@fn_ctxt, &span, ty::t, ty::t) -> ty::t;\n+type unifier = fn(@fn_ctxt, span, ty::t, ty::t) -> ty::t;\n \n-fn check_expr(fcx: &@fn_ctxt, expr: &@ast::expr) -> bool {\n-    fn dummy_unify(_fcx: &@fn_ctxt, _sp: &span, _expected: ty::t,\n-                   actual: ty::t) -> ty::t {\n+fn check_expr(fcx: @fn_ctxt, expr: @ast::expr) -> bool {\n+    fn dummy_unify(_fcx: @fn_ctxt, _sp: span, _expected: ty::t, actual: ty::t)\n+       -> ty::t {\n         actual\n     }\n     ret check_expr_with_unifier(fcx, expr, dummy_unify, 0u);\n }\n-fn check_expr_with(fcx: &@fn_ctxt, expr: &@ast::expr, expected: ty::t) ->\n-   bool {\n+fn check_expr_with(fcx: @fn_ctxt, expr: @ast::expr, expected: ty::t) -> bool {\n     ret check_expr_with_unifier(fcx, expr, demand::simple, expected);\n }\n \n-fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n+fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                            expected: ty::t) -> bool {\n     //log_err \"typechecking expr \" + syntax::print::pprust::expr_to_str(expr);\n \n     // A generic function to factor out common logic from call and bind\n     // expressions.\n-    fn check_call_or_bind(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                          args: &[option::t<@ast::expr>],\n-                          call_kind: call_kind) -> bool {\n+    fn check_call_or_bind(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n+                          args: [option::t<@ast::expr>], call_kind: call_kind)\n+       -> bool {\n         // Check the function.\n         let bot = check_expr(fcx, f);\n \n@@ -1545,16 +1528,14 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         alt sty {\n           ty::ty_fn(ast::proto_iter., _, _, _, _) {\n             if call_kind != kind_for_each {\n-                fcx.ccx.tcx.sess.span_err(\n-                    sp,\n-                    \"calling iter outside of for each loop\");\n+                fcx.ccx.tcx.sess.span_err(sp,\n+                       \"calling iter outside of for each loop\");\n             }\n           }\n           _ {\n             if call_kind == kind_for_each {\n-                fcx.ccx.tcx.sess.span_err(\n-                    sp,\n-                    \"calling non-iter as sequence of for each loop\");\n+                fcx.ccx.tcx.sess.span_err(sp,\n+                   \"calling non-iter as sequence of for each loop\");\n             }\n           }\n         }\n@@ -1633,17 +1614,17 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(fcx: &@fn_ctxt, _sp: &span, lhs: &@ast::expr,\n-                        rhs: &@ast::expr, id: &ast::node_id) -> bool {\n+    fn check_assignment(fcx: @fn_ctxt, _sp: span, lhs: @ast::expr,\n+                        rhs: @ast::expr, id: ast::node_id) -> bool {\n         let t = next_ty_var(fcx);\n         let bot = check_expr_with(fcx, lhs, t) | check_expr_with(fcx, rhs, t);\n         write::ty_only_fixup(fcx, id, ty::mk_nil(fcx.ccx.tcx));\n         ret bot;\n     }\n \n     // A generic function for checking call expressions\n-    fn check_call(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                  args: &[@ast::expr], call_kind: call_kind) -> bool {\n+    fn check_call(fcx: @fn_ctxt, sp: span, f: @ast::expr, args: [@ast::expr],\n+                  call_kind: call_kind) -> bool {\n         let args_opt_0: [option::t<@ast::expr>] = [];\n         for arg: @ast::expr in args {\n             args_opt_0 += [some::<@ast::expr>(arg)];\n@@ -1654,8 +1635,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n     }\n \n     // A generic function for doing all of the checking for call expressions\n-    fn check_call_full(fcx: &@fn_ctxt, sp: &span, f: &@ast::expr,\n-                       args: &[@ast::expr], call_kind: call_kind,\n+    fn check_call_full(fcx: @fn_ctxt, sp: span, f: @ast::expr,\n+                       args: [@ast::expr], call_kind: call_kind,\n                        id: ast::node_id) -> bool {\n         /* here we're kind of hosed, as f can be any expr\n         need to restrict it to being an explicit expr_path if we're\n@@ -1680,8 +1661,8 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n     }\n \n     // A generic function for checking for or for-each loops\n-    fn check_for_or_for_each(fcx: &@fn_ctxt, local: &@ast::local,\n-                             element_ty: ty::t, body: &ast::blk,\n+    fn check_for_or_for_each(fcx: @fn_ctxt, local: @ast::local,\n+                             element_ty: ty::t, body: ast::blk,\n                              node_id: ast::node_id) -> bool {\n         let locid = lookup_local(fcx, local.span, local.node.id);\n         element_ty =\n@@ -1700,9 +1681,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n \n     // A generic function for checking the then and else in an if\n     // or if-check\n-    fn check_then_else(fcx: &@fn_ctxt, thn: &ast::blk,\n-                       elsopt: &option::t<@ast::expr>, id: ast::node_id,\n-                       _sp: &span) -> bool {\n+    fn check_then_else(fcx: @fn_ctxt, thn: ast::blk,\n+                       elsopt: option::t<@ast::expr>, id: ast::node_id,\n+                       _sp: span) -> bool {\n         let then_bot = check_block(fcx, thn);\n         let els_bot = false;\n         let if_t =\n@@ -1722,7 +1703,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n     }\n \n     // Checks the compatibility\n-    fn check_binop_type_compat(fcx: &@fn_ctxt, span: span, ty: ty::t,\n+    fn check_binop_type_compat(fcx: @fn_ctxt, span: span, ty: ty::t,\n                                binop: ast::binop) {\n         let resolved_t = resolve_type_vars_if_possible(fcx, ty);\n         if !ty::is_binopable(fcx.ccx.tcx, resolved_t, binop) {\n@@ -1777,11 +1758,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                 let variants = ty::tag_variants(tcx, id);\n                 if vec::len(variants) != 1u ||\n                        vec::len(variants[0].args) != 1u {\n-                    tcx.sess.span_fatal(\n-                        expr.span,\n-                        \"can only dereference tags \" +\n-                        \"with a single variant which has a \"\n-                        + \"single argument\");\n+                    tcx.sess.span_fatal(expr.span,\n+                                        \"can only dereference tags \" +\n+                                        \"with a single variant which has a \"\n+                                            + \"single argument\");\n                 }\n                 oper_t =\n                     ty::substitute_type_params(tcx, tps, variants[0].args[0]);\n@@ -1940,10 +1920,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n           ty::ty_str. { elt_ty = ty::mk_mach(tcx, ast::ty_u8); }\n           _ {\n-            tcx.sess.span_fatal(\n-                expr.span,\n-                \"mismatched types: expected vector or string but \"\n-                + \"found \" + ty_to_str(tcx, ety));\n+            tcx.sess.span_fatal(expr.span,\n+                     \"mismatched types: expected vector or string but \"\n+                                    + \"found \" + ty_to_str(tcx, ety));\n           }\n         }\n         bot |= check_for_or_for_each(fcx, decl, elt_ty, body, id);\n@@ -2003,7 +1982,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         let cx = @{tcx: tcx};\n         let convert = bind ast_ty_to_ty_crate_tyvar(fcx, _);\n         let ty_of_arg =\n-            lambda (a: &ast::arg) -> ty::arg {\n+            lambda (a: ast::arg) -> ty::arg {\n                 let tt = ast_ty_to_ty_crate_tyvar(fcx, a.ty);\n                 ret {mode: a.mode, ty: tt};\n             };\n@@ -2042,6 +2021,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         // Pull the argument and return types out.\n         let proto, arg_tys, rt, cf, constrs;\n         alt structure_of(fcx, expr.span, expr_ty(tcx, f)) {\n+\n           // FIXME:\n           // probably need to munge the constrs to drop constraints\n           // for any bound args\n@@ -2060,7 +2040,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             constrs = [];\n           }\n           _ { fail \"LHS of bind expr didn't have a function type?!\"; }\n-        };\n+        }\n \n         // For each blank argument, add the type of that argument\n         // to the resulting function type.\n@@ -2179,7 +2159,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n         }\n         alt base {\n           none. {\n-            fn get_node(f: &spanned<field>) -> field { f.node }\n+            fn get_node(f: spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(get_node, fields_t));\n             write::ty_only_fixup(fcx, id, typ);\n           }\n@@ -2276,11 +2256,11 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n \n         // FIXME: These next three functions are largely ripped off from\n         // similar ones in collect::.  Is there a better way to do this?\n-        fn ty_of_arg(ccx: @crate_ctxt, a: &ast::arg) -> ty::arg {\n+        fn ty_of_arg(ccx: @crate_ctxt, a: ast::arg) -> ty::arg {\n             ret {mode: a.mode, ty: ast_ty_to_ty_crate(ccx, a.ty)};\n         }\n \n-        fn ty_of_method(ccx: @crate_ctxt, m: &@ast::method) -> ty::method {\n+        fn ty_of_method(ccx: @crate_ctxt, m: @ast::method) -> ty::method {\n             let convert = bind ast_ty_to_ty_crate(ccx, _);\n \n             let inputs = [];\n@@ -2333,11 +2313,9 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                       ty::ty_obj(ms) { inner_obj_methods = ms; }\n                       _ {\n                         // The user is trying to extend a non-object.\n-                        tcx.sess.span_fatal(\n-                            e.span,\n-                            syntax::print::pprust::expr_to_str(e)\n-                            +\n-                            \" does not have object type\");\n+                        tcx.sess.span_fatal(e.span,\n+                                   syntax::print::pprust::expr_to_str(e) +\n+                                   \" does not have object type\");\n                       }\n                     }\n                   }\n@@ -2352,7 +2330,7 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n             // Whenever an outer method overrides an inner, we need to remove\n             // that inner from the type.  Filter inner_obj_methods to remove\n             // any methods that share a name with an outer method.\n-            fn filtering_fn(ccx: @crate_ctxt, m: &ty::method,\n+            fn filtering_fn(ccx: @crate_ctxt, m: ty::method,\n                             outer_obj_methods: [@ast::method]) ->\n                option::t<ty::method> {\n \n@@ -2362,11 +2340,10 @@ fn check_expr_with_unifier(fcx: &@fn_ctxt, expr: &@ast::expr, unify: &unifier,\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx, om);\n                         if new_type != m {\n-                            ccx.tcx.sess.span_fatal(\n-                                om.span,\n-                                \"Attempted to override method \"\n-                                + m.ident +\n-                                \" with one of a different type\");\n+                            ccx.tcx.sess.span_fatal(om.span,\n+                                         \"Attempted to override method \"\n+                                                    + m.ident +\n+                                         \" with one of a different type\");\n                         }\n                         ret none;\n                     }\n@@ -2422,21 +2399,21 @@ fn next_ty_var_id(fcx: @fn_ctxt) -> int {\n     ret id;\n }\n \n-fn next_ty_var(fcx: &@fn_ctxt) -> ty::t {\n+fn next_ty_var(fcx: @fn_ctxt) -> ty::t {\n     ret ty::mk_var(fcx.ccx.tcx, next_ty_var_id(fcx));\n }\n \n-fn get_obj_info(ccx: &@crate_ctxt) -> option::t<obj_info> {\n+fn get_obj_info(ccx: @crate_ctxt) -> option::t<obj_info> {\n     ret vec::last::<obj_info>(ccx.obj_infos);\n }\n \n-fn check_decl_initializer(fcx: &@fn_ctxt, nid: ast::node_id,\n-                          init: &ast::initializer) -> bool {\n+fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n+                          init: ast::initializer) -> bool {\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.expr.span, nid));\n     ret check_expr_with(fcx, init.expr, lty);\n }\n \n-fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n+fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     let bot = false;\n \n     alt fcx.locals.find(local.node.id) {\n@@ -2460,7 +2437,7 @@ fn check_decl_local(fcx: &@fn_ctxt, local: &@ast::local) -> bool {\n     ret bot;\n }\n \n-fn check_stmt(fcx: &@fn_ctxt, stmt: &@ast::stmt) -> bool {\n+fn check_stmt(fcx: @fn_ctxt, stmt: @ast::stmt) -> bool {\n     let node_id;\n     let bot = false;\n     alt stmt.node {\n@@ -2479,7 +2456,7 @@ fn check_stmt(fcx: &@fn_ctxt, stmt: &@ast::stmt) -> bool {\n     ret bot;\n }\n \n-fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n+fn check_block(fcx: @fn_ctxt, blk: ast::blk) -> bool {\n     let bot = false;\n     let warned = false;\n     for s: @ast::stmt in blk.node.stmts {\n@@ -2513,8 +2490,7 @@ fn check_block(fcx: &@fn_ctxt, blk: &ast::blk) -> bool {\n     ret bot;\n }\n \n-fn check_const(ccx: &@crate_ctxt, _sp: &span, e: &@ast::expr,\n-               id: &ast::node_id) {\n+fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n     // FIXME: this is kinda a kludge; we manufacture a fake function context\n     // and statement context for checking the initializer expression.\n     let rty = node_id_to_type(ccx.tcx, id);\n@@ -2534,17 +2510,16 @@ fn check_const(ccx: &@crate_ctxt, _sp: &span, e: &@ast::expr,\n \n // A generic function for checking the pred in a check\n // or if-check\n-fn check_pred_expr(fcx: &@fn_ctxt, e: &@ast::expr) -> bool {\n+fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n     let bot = check_expr_with(fcx, e, ty::mk_bool(fcx.ccx.tcx));\n \n     /* e must be a call expr where all arguments are either\n     literals or slots */\n     alt e.node {\n       ast::expr_call(operator, operands) {\n         if !ty::is_pred_ty(fcx.ccx.tcx, expr_ty(fcx.ccx.tcx, operator)) {\n-            fcx.ccx.tcx.sess.span_fatal(\n-                operator.span,\n-                \"Operator in constraint has non-boolean return type\");\n+            fcx.ccx.tcx.sess.span_fatal(operator.span,\n+                      \"Operator in constraint has non-boolean return type\");\n         }\n \n         alt operator.node {\n@@ -2581,7 +2556,7 @@ constraint name to be an explicit name\";\n     ret bot;\n }\n \n-fn check_constraints(fcx: &@fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n+fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n     let c_args;\n     let num_args = vec::len(args);\n     for c: @ast::constr in cs {\n@@ -2617,10 +2592,9 @@ fn check_constraints(fcx: &@fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n                                types: []};\n                           let arg_occ_node_id =\n                               fcx.ccx.tcx.sess.next_node_id();\n-                          fcx.ccx.tcx.def_map.insert(\n-                              arg_occ_node_id,\n-                              ast::def_arg(local_def(args[i].id),\n-                                           args[i].mode));\n+                          fcx.ccx.tcx.def_map.insert(arg_occ_node_id,\n+                                           ast::def_arg(local_def(args[i].id),\n+                                                               args[i].mode));\n                           {id: arg_occ_node_id,\n                            node: ast::expr_path(respan(a.span, p)),\n                            span: a.span}\n@@ -2644,8 +2618,8 @@ fn check_constraints(fcx: &@fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n     }\n }\n \n-fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n-            old_fcx: &option::t<@fn_ctxt>) {\n+fn check_fn(ccx: @crate_ctxt, f: ast::_fn, id: ast::node_id,\n+            old_fcx: option::t<@fn_ctxt>) {\n     let decl = f.decl;\n     let body = f.body;\n     let gather_result = gather_locals(ccx, f, id, old_fcx);\n@@ -2694,11 +2668,11 @@ fn check_fn(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     }\n }\n \n-fn check_method(ccx: &@crate_ctxt, method: &@ast::method) {\n+fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n     check_fn(ccx, method.node.meth, method.node.id, none);\n }\n \n-fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n+fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n       ast::item_fn(f, _) { check_fn(ccx, f, it.id, none); }\n@@ -2717,7 +2691,7 @@ fn check_item(ccx: @crate_ctxt, it: &@ast::item) {\n     }\n }\n \n-fn arg_is_argv_ty(tcx: &ty::ctxt, a: &ty::arg) -> bool {\n+fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n     alt ty::struct(tcx, a.ty) {\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm { ret false; }\n@@ -2730,7 +2704,7 @@ fn arg_is_argv_ty(tcx: &ty::ctxt, a: &ty::arg) -> bool {\n     }\n }\n \n-fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n+fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n     let main_t = ty::node_id_to_monotype(tcx, main_id);\n     alt ty::struct(tcx, main_t) {\n       ty::ty_fn(ast::proto_fn., args, rs, ast::return., constrs) {\n@@ -2755,7 +2729,7 @@ fn check_main_fn_ty(tcx: &ty::ctxt, main_id: &ast::node_id) {\n     }\n }\n \n-fn check_for_main_fn(tcx: &ty::ctxt, crate: &@ast::crate) {\n+fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     if !tcx.sess.get_opts().library {\n         alt tcx.sess.get_main_id() {\n           some(id) { check_main_fn_ty(tcx, id); }\n@@ -2764,7 +2738,7 @@ fn check_for_main_fn(tcx: &ty::ctxt, crate: &@ast::crate) {\n     }\n }\n \n-fn check_crate(tcx: &ty::ctxt, crate: &@ast::crate) {\n+fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     collect::collect_item_types(tcx, crate);\n \n     let obj_infos: [obj_info] = [];"}, {"sha": "7ab627ec2b968d912ccaaefd32adc10e1ff843ab", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -293,10 +293,11 @@ tag ty_ {\n              for this type. */\n \n \n+\n      /* bot represents the value of functions that don't return a value\n         locally to their context. in contrast, things like log that do\n         return, but don't return a meaningful value, have result type nil. */\n-    ty_bool;\n+     ty_bool;\n     ty_int;\n     ty_uint;\n     ty_float;\n@@ -381,6 +382,7 @@ tag controlflow {\n               // raise an error or exit (i.e. never return to the caller)\n \n \n+\n     return; // everything else\n }\n "}, {"sha": "eaf6728838b3b6d2d50a8430a868a924d22d1b41", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,7 +3,7 @@ import std::option;\n import codemap::span;\n import ast::*;\n \n-fn respan<@T>(sp: &span, t: &T) -> spanned<T> { ret {node: t, span: sp}; }\n+fn respan<@T>(sp: span, t: T) -> spanned<T> { ret {node: t, span: sp}; }\n \n /* assuming that we're not in macro expansion */\n fn mk_sp(lo: uint, hi: uint) -> span {\n@@ -13,13 +13,13 @@ fn mk_sp(lo: uint, hi: uint) -> span {\n // make this a const, once the compiler supports it\n fn dummy_sp() -> span { ret mk_sp(0u, 0u); }\n \n-fn path_name(p: &path) -> str { path_name_i(p.node.idents) }\n+fn path_name(p: path) -> str { path_name_i(p.node.idents) }\n \n-fn path_name_i(idents: &[ident]) -> str { str::connect(idents, \"::\") }\n+fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n \n-fn variant_def_ids(d: &def) -> {tg: def_id, var: def_id} {\n+fn variant_def_ids(d: def) -> {tg: def_id, var: def_id} {\n     alt d { def_variant(tag_id, var_id) { ret {tg: tag_id, var: var_id}; } }\n }\n \n@@ -47,7 +47,7 @@ type pat_id_map = std::map::hashmap<str, node_id>;\n \n // This is used because same-named variables in alternative patterns need to\n // use the node_id of their namesake in the first pattern.\n-fn pat_id_map(pat: &@pat) -> pat_id_map {\n+fn pat_id_map(pat: @pat) -> pat_id_map {\n     let map = std::map::new_str_hash::<node_id>();\n     for each bound in pat_bindings(pat) {\n         let name = alt bound.node { pat_bind(n) { n } };\n@@ -57,7 +57,7 @@ fn pat_id_map(pat: &@pat) -> pat_id_map {\n }\n \n // FIXME: could return a constrained type\n-iter pat_bindings(pat: &@pat) -> @pat {\n+iter pat_bindings(pat: @pat) -> @pat {\n     alt pat.node {\n       pat_bind(_) { put pat; }\n       pat_tag(_, sub) {\n@@ -74,7 +74,7 @@ iter pat_bindings(pat: &@pat) -> @pat {\n     }\n }\n \n-fn pat_binding_ids(pat: &@pat) -> [node_id] {\n+fn pat_binding_ids(pat: @pat) -> [node_id] {\n     let found = [];\n     for each b in pat_bindings(pat) { found += [b.id]; }\n     ret found;\n@@ -117,7 +117,7 @@ fn unop_to_str(op: unop) -> str {\n     }\n }\n \n-fn is_path(e: &@expr) -> bool {\n+fn is_path(e: @expr) -> bool {\n     ret alt e.node { expr_path(_) { true } _ { false } };\n }\n \n@@ -179,9 +179,9 @@ fn is_constraint_arg(e: @expr) -> bool {\n     }\n }\n \n-fn eq_ty(a: &@ty, b: &@ty) -> bool { ret std::box::ptr_eq(a, b); }\n+fn eq_ty(a: @ty, b: @ty) -> bool { ret std::box::ptr_eq(a, b); }\n \n-fn hash_ty(t: &@ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n+fn hash_ty(t: @ty) -> uint { ret t.span.lo << 16u + t.span.hi; }\n \n fn block_from_expr(e: @expr) -> blk {\n     let blk_ = checked_blk([], option::some::<@expr>(e), e.id);\n@@ -193,13 +193,13 @@ fn checked_blk(stmts1: [@stmt], expr1: option::t<@expr>, id1: node_id) ->\n     ret {stmts: stmts1, expr: expr1, id: id1, rules: checked};\n }\n \n-fn obj_field_from_anon_obj_field(f: &anon_obj_field) -> obj_field {\n+fn obj_field_from_anon_obj_field(f: anon_obj_field) -> obj_field {\n     ret {mut: f.mut, ty: f.ty, ident: f.ident, id: f.id};\n }\n \n // This is a convenience function to transfor ternary expressions to if\n // expressions so that they can be treated the same\n-fn ternary_to_if(e: &@expr) -> @expr {\n+fn ternary_to_if(e: @expr) -> @expr {\n     alt e.node {\n       expr_ternary(cond, then, els) {\n         let then_blk = block_from_expr(then);"}, {"sha": "b0f3bde73d93d937b0d836fb949ba09370f12643", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -73,7 +73,7 @@ tag opt_span {\n }\n type span = {lo: uint, hi: uint, expanded_from: opt_span};\n \n-fn span_to_str(sp: &span, cm: &codemap) -> str {\n+fn span_to_str(sp: span, cm: codemap) -> str {\n     let cur = sp;\n     let res = \"\";\n     let prev_file = none;\n@@ -98,8 +98,8 @@ fn span_to_str(sp: &span, cm: &codemap) -> str {\n     ret res;\n }\n \n-fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n-                   cm: &codemap) {\n+fn emit_diagnostic(sp: option::t<span>, msg: str, kind: str, color: u8,\n+                   cm: codemap) {\n     let ss = \"\";\n     let maybe_lines: option::t<@file_lines> = none;\n     alt sp {\n@@ -120,7 +120,7 @@ fn emit_diagnostic(sp: &option::t<span>, msg: &str, kind: &str, color: u8,\n     maybe_highlight_lines(sp, cm, maybe_lines);\n }\n \n-fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n+fn maybe_highlight_lines(sp: option::t<span>, cm: codemap,\n                          maybe_lines: option::t<@file_lines>) {\n \n     alt maybe_lines {\n@@ -188,13 +188,13 @@ fn maybe_highlight_lines(sp: &option::t<span>, cm: &codemap,\n     }\n }\n \n-fn emit_warning(sp: &option::t<span>, msg: &str, cm: &codemap) {\n+fn emit_warning(sp: option::t<span>, msg: str, cm: codemap) {\n     emit_diagnostic(sp, msg, \"warning\", 11u8, cm);\n }\n-fn emit_error(sp: &option::t<span>, msg: &str, cm: &codemap) {\n+fn emit_error(sp: option::t<span>, msg: str, cm: codemap) {\n     emit_diagnostic(sp, msg, \"error\", 9u8, cm);\n }\n-fn emit_note(sp: &option::t<span>, msg: &str, cm: &codemap) {\n+fn emit_note(sp: option::t<span>, msg: str, cm: codemap) {\n     emit_diagnostic(sp, msg, \"note\", 10u8, cm);\n }\n \n@@ -210,7 +210,7 @@ fn span_to_lines(sp: span, cm: codemap::codemap) -> @file_lines {\n     ret @{name: lo.filename, lines: lines};\n }\n \n-fn get_line(fm: filemap, line: int, file: &str) -> str {\n+fn get_line(fm: filemap, line: int, file: str) -> str {\n     let begin: uint = fm.lines[line].byte - fm.start_pos.byte;\n     let end: uint;\n     if line as uint < vec::len(fm.lines) - 1u {"}, {"sha": "a77376edd6ef5949f485170598e552c82fcc0887", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -8,10 +8,10 @@ import std::map::new_str_hash;\n import codemap;\n \n type syntax_expander =\n-    fn(&ext_ctxt, span, @ast::expr, &option::t<str>) -> @ast::expr;\n+    fn(ext_ctxt, span, @ast::expr, option::t<str>) -> @ast::expr;\n type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n-    fn(&ext_ctxt, span, @ast::expr, &option::t<str>) -> macro_def;\n+    fn(ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def;\n \n tag syntax_extension {\n     normal(syntax_expander);\n@@ -83,7 +83,7 @@ obj ext_ctxt(sess: @session,\n \n }\n \n-fn mk_ctxt(sess: &session) -> ext_ctxt {\n+fn mk_ctxt(sess: session) -> ext_ctxt {\n     // FIXME: Some extensions work by building ASTs with paths to functions\n     // they need to call at runtime. As those functions live in the std crate,\n     // the paths are prefixed with \"std::\". Unfortunately, these paths can't\n@@ -96,7 +96,7 @@ fn mk_ctxt(sess: &session) -> ext_ctxt {\n     ret ext_ctxt(@sess, crate_file_name_hack, codemap::os_none);\n }\n \n-fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: &str) -> str {\n+fn expr_to_str(cx: ext_ctxt, expr: @ast::expr, error: str) -> str {\n     alt expr.node {\n       ast::expr_lit(l) {\n         alt l.node {\n@@ -108,7 +108,7 @@ fn expr_to_str(cx: &ext_ctxt, expr: @ast::expr, error: &str) -> str {\n     }\n }\n \n-fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr, error: &str) -> ast::ident {\n+fn expr_to_ident(cx: ext_ctxt, expr: @ast::expr, error: str) -> ast::ident {\n     alt expr.node {\n       ast::expr_path(p) {\n         if vec::len(p.node.types) > 0u || vec::len(p.node.idents) != 1u {\n@@ -119,7 +119,7 @@ fn expr_to_ident(cx: &ext_ctxt, expr: @ast::expr, error: &str) -> ast::ident {\n     }\n }\n \n-fn make_new_lit(cx: &ext_ctxt, sp: codemap::span, lit: ast::lit_) ->\n+fn make_new_lit(cx: ext_ctxt, sp: codemap::span, lit: ast::lit_) ->\n    @ast::expr {\n     let sp_lit = @{node: lit, span: sp};\n     ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};"}, {"sha": "b2f019f233daa762851c2c34bbab14276244862b", "filename": "src/comp/syntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fconcat_idents.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,8 +2,8 @@ import std::option;\n import base::*;\n import syntax::ast;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<str>) -> @ast::expr {\n+fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }"}, {"sha": "2889487a6aea1c324df8fa2b05788eb32c29e012", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -11,8 +11,8 @@ import std::generic_os;\n import base::*;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<str>) -> @ast::expr {\n+fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n@@ -33,7 +33,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n     }\n }\n \n-fn make_new_str(cx: &ext_ctxt, sp: codemap::span, s: &str) -> @ast::expr {\n+fn make_new_str(cx: ext_ctxt, sp: codemap::span, s: str) -> @ast::expr {\n     ret make_new_lit(cx, sp, ast::lit_str(s));\n }\n //"}, {"sha": "05128fdd62b46b82b9c0f1441edc2e855776ffb9", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -15,9 +15,8 @@ import syntax::fold::*;\n import syntax::ext::base::*;\n \n \n-fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n-               e: &expr_, fld: ast_fold, orig: &fn(&expr_, ast_fold) -> expr_)\n-   -> expr_ {\n+fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt, e: expr_,\n+               fld: ast_fold, orig: fn(expr_, ast_fold) -> expr_) -> expr_ {\n     ret alt e {\n           expr_mac(mac) {\n             alt mac.node {\n@@ -53,7 +52,7 @@ fn expand_expr(exts: &hashmap<str, syntax_extension>, cx: &ext_ctxt,\n         };\n }\n \n-fn expand_crate(sess: &session::session, c: &@crate) -> @crate {\n+fn expand_crate(sess: session::session, c: @crate) -> @crate {\n     let exts = syntax_expander_table();\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(sess);"}, {"sha": "43a2cd03ec3533d18b8c388777761d2b74ad35ff", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -15,8 +15,8 @@ import base::*;\n import codemap::span;\n export expand_syntax_ext;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n-                     _body: &option::t<str>) -> @ast::expr {\n+fn expand_syntax_ext(cx: ext_ctxt, sp: span, arg: @ast::expr,\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n@@ -33,7 +33,7 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n     let fmtspan = args[0].span;\n     log \"Format string:\";\n     log fmt;\n-    fn parse_fmt_err_(cx: &ext_ctxt, sp: span, msg: &str) -> ! {\n+    fn parse_fmt_err_(cx: ext_ctxt, sp: span, msg: str) -> ! {\n         cx.span_fatal(sp, msg);\n     }\n     let parse_fmt_err = bind parse_fmt_err_(cx, fmtspan, _);\n@@ -44,49 +44,49 @@ fn expand_syntax_ext(cx: &ext_ctxt, sp: span, arg: @ast::expr,\n // FIXME: A lot of these functions for producing expressions can probably\n // be factored out in common with other code that builds expressions.\n // FIXME: Cleanup the naming of these functions\n-fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n-                  args: &[@ast::expr]) -> @ast::expr {\n-    fn make_new_lit(cx: &ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n+fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n+   -> @ast::expr {\n+    fn make_new_lit(cx: ext_ctxt, sp: span, lit: ast::lit_) -> @ast::expr {\n         let sp_lit = @{node: lit, span: sp};\n         ret @{id: cx.next_id(), node: ast::expr_lit(sp_lit), span: sp};\n     }\n-    fn make_new_str(cx: &ext_ctxt, sp: span, s: &str) -> @ast::expr {\n+    fn make_new_str(cx: ext_ctxt, sp: span, s: str) -> @ast::expr {\n         let lit = ast::lit_str(s);\n         ret make_new_lit(cx, sp, lit);\n     }\n-    fn make_new_int(cx: &ext_ctxt, sp: span, i: int) -> @ast::expr {\n+    fn make_new_int(cx: ext_ctxt, sp: span, i: int) -> @ast::expr {\n         let lit = ast::lit_int(i);\n         ret make_new_lit(cx, sp, lit);\n     }\n-    fn make_new_uint(cx: &ext_ctxt, sp: span, u: uint) -> @ast::expr {\n+    fn make_new_uint(cx: ext_ctxt, sp: span, u: uint) -> @ast::expr {\n         let lit = ast::lit_uint(u);\n         ret make_new_lit(cx, sp, lit);\n     }\n-    fn make_add_expr(cx: &ext_ctxt, sp: span, lhs: @ast::expr,\n-                     rhs: @ast::expr) -> @ast::expr {\n+    fn make_add_expr(cx: ext_ctxt, sp: span, lhs: @ast::expr, rhs: @ast::expr)\n+       -> @ast::expr {\n         let binexpr = ast::expr_binary(ast::add, lhs, rhs);\n         ret @{id: cx.next_id(), node: binexpr, span: sp};\n     }\n-    fn make_path_expr(cx: &ext_ctxt, sp: span, idents: &[ast::ident]) ->\n+    fn make_path_expr(cx: ext_ctxt, sp: span, idents: [ast::ident]) ->\n        @ast::expr {\n         let path = {global: false, idents: idents, types: []};\n         let sp_path = {node: path, span: sp};\n         let pathexpr = ast::expr_path(sp_path);\n         ret @{id: cx.next_id(), node: pathexpr, span: sp};\n     }\n-    fn make_vec_expr(cx: &ext_ctxt, sp: span, exprs: &[@ast::expr]) ->\n+    fn make_vec_expr(cx: ext_ctxt, sp: span, exprs: [@ast::expr]) ->\n        @ast::expr {\n         let vecexpr = ast::expr_vec(exprs, ast::imm);\n         ret @{id: cx.next_id(), node: vecexpr, span: sp};\n     }\n-    fn make_call(cx: &ext_ctxt, sp: span, fn_path: &[ast::ident],\n-                 args: &[@ast::expr]) -> @ast::expr {\n+    fn make_call(cx: ext_ctxt, sp: span, fn_path: [ast::ident],\n+                 args: [@ast::expr]) -> @ast::expr {\n         let pathexpr = make_path_expr(cx, sp, fn_path);\n         let callexpr = ast::expr_call(pathexpr, args);\n         ret @{id: cx.next_id(), node: callexpr, span: sp};\n     }\n-    fn make_rec_expr(cx: &ext_ctxt, sp: span,\n-                     fields: &[{ident: ast::ident, ex: @ast::expr}]) ->\n+    fn make_rec_expr(cx: ext_ctxt, sp: span,\n+                     fields: [{ident: ast::ident, ex: @ast::expr}]) ->\n        @ast::expr {\n         let astfields: [ast::field] = [];\n         for field: {ident: ast::ident, ex: @ast::expr} in fields {\n@@ -99,23 +99,23 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         let recexpr = ast::expr_rec(astfields, option::none::<@ast::expr>);\n         ret @{id: cx.next_id(), node: recexpr, span: sp};\n     }\n-    fn make_path_vec(cx: &ext_ctxt, ident: &ast::ident) -> [ast::ident] {\n-        fn compiling_std(cx: &ext_ctxt) -> bool {\n+    fn make_path_vec(cx: ext_ctxt, ident: ast::ident) -> [ast::ident] {\n+        fn compiling_std(cx: ext_ctxt) -> bool {\n             ret str::find(cx.crate_file_name(), \"std.rc\") >= 0;\n         }\n         if compiling_std(cx) {\n             ret [\"extfmt\", \"rt\", ident];\n         } else { ret [\"std\", \"extfmt\", \"rt\", ident]; }\n     }\n-    fn make_rt_path_expr(cx: &ext_ctxt, sp: span, ident: &str) -> @ast::expr {\n+    fn make_rt_path_expr(cx: ext_ctxt, sp: span, ident: str) -> @ast::expr {\n         let path = make_path_vec(cx, ident);\n         ret make_path_expr(cx, sp, path);\n     }\n     // Produces an AST expression that represents a RT::conv record,\n     // which tells the RT::conv* functions how to perform the conversion\n \n-    fn make_rt_conv_expr(cx: &ext_ctxt, sp: span, cnv: &conv) -> @ast::expr {\n-        fn make_flags(cx: &ext_ctxt, sp: span, flags: &[flag]) -> @ast::expr {\n+    fn make_rt_conv_expr(cx: ext_ctxt, sp: span, cnv: conv) -> @ast::expr {\n+        fn make_flags(cx: ext_ctxt, sp: span, flags: [flag]) -> @ast::expr {\n             let flagexprs: [@ast::expr] = [];\n             for f: flag in flags {\n                 let fstr;\n@@ -137,7 +137,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             }\n             ret make_vec_expr(cx, sp, flagexprs);\n         }\n-        fn make_count(cx: &ext_ctxt, sp: span, cnt: &count) -> @ast::expr {\n+        fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n               count_implied. {\n                 ret make_rt_path_expr(cx, sp, \"count_implied\");\n@@ -151,7 +151,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n               _ { cx.span_unimpl(sp, \"unimplemented #fmt conversion\"); }\n             }\n         }\n-        fn make_ty(cx: &ext_ctxt, sp: span, t: &ty) -> @ast::expr {\n+        fn make_ty(cx: ext_ctxt, sp: span, t: ty) -> @ast::expr {\n             let rt_type;\n             alt t {\n               ty_hex(c) {\n@@ -166,7 +166,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n             }\n             ret make_rt_path_expr(cx, sp, rt_type);\n         }\n-        fn make_conv_rec(cx: &ext_ctxt, sp: span, flags_expr: @ast::expr,\n+        fn make_conv_rec(cx: ext_ctxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n             ret make_rec_expr(cx, sp,\n@@ -182,15 +182,15 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n         ret make_conv_rec(cx, sp, rt_conv_flags, rt_conv_width,\n                           rt_conv_precision, rt_conv_ty);\n     }\n-    fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: &str, cnv: &conv,\n+    fn make_conv_call(cx: ext_ctxt, sp: span, conv_type: str, cnv: conv,\n                       arg: @ast::expr) -> @ast::expr {\n         let fname = \"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = [cnv_expr, arg];\n         ret make_call(cx, arg.span, path, args);\n     }\n-    fn make_new_conv(cx: &ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n+    fn make_new_conv(cx: ext_ctxt, sp: span, cnv: conv, arg: @ast::expr) ->\n        @ast::expr {\n         // FIXME: Extract all this validation into extfmt::ct\n \n@@ -334,10 +334,9 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     let expected_nargs = n + 1u; // n conversions + the fmt string\n \n     if expected_nargs < nargs {\n-        cx.span_fatal(\n-            sp,\n-            #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n-                 nargs, expected_nargs]);\n+        cx.span_fatal(sp,\n+       #fmt[\"too many arguments to #fmt. found %u, expected %u\",\n+                           nargs, expected_nargs]);\n     }\n     ret tmp_expr;\n }"}, {"sha": "382e1ec305608f422ca472427d49b094db54d23d", "filename": "src/comp/syntax/ext/ident_to_str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fident_to_str.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,8 +4,8 @@ import std::option;\n import base::*;\n import syntax::ast;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<str>) -> @ast::expr {\n+fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n+                     _body: option::t<str>) -> @ast::expr {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }"}, {"sha": "8f28e3b6c76cabbfc677ac9fa25269907a5be183", "filename": "src/comp/syntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Flog_syntax.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,8 +3,8 @@ import base::*;\n import syntax::ast;\n import std::str;\n \n-fn expand_syntax_ext(cx: &ext_ctxt, sp: codemap::span, arg: @ast::expr,\n-                     _body: &option::t<str>) -> @ast::expr {\n+fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n+                     _body: option::t<str>) -> @ast::expr {\n \n     cx.print_backtrace();\n     std::io::stdout().write_line(print::pprust::expr_to_str(arg));"}, {"sha": "dc3b40645c20fc2b60adbf499ef8ab720b4f8fda", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 61, "deletions": 60, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -33,7 +33,7 @@ import ast::mac_invoc;\n \n export add_new_extension;\n \n-fn path_to_ident(pth: &path) -> option::t<ident> {\n+fn path_to_ident(pth: path) -> option::t<ident> {\n     if vec::len(pth.node.idents) == 1u && vec::len(pth.node.types) == 0u {\n         ret some(pth.node.idents[0u]);\n     }\n@@ -57,7 +57,7 @@ tag matchable {\n }\n \n /* for when given an incompatible bit of AST */\n-fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n+fn match_error(cx: ext_ctxt, m: matchable, expected: str) -> ! {\n     alt m {\n       match_expr(x) {\n         cx.span_fatal(x.span,\n@@ -90,9 +90,9 @@ fn match_error(cx: &ext_ctxt, m: &matchable, expected: &str) -> ! {\n // we'll want to return something indicating amount of progress and location\n // of failure instead of `none`.\n type match_result = option::t<arb_depth<matchable>>;\n-type selector = fn(&matchable) -> match_result;\n+type selector = fn(matchable) -> match_result;\n \n-fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr]) ->\n+fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n    {pre: [@expr], rep: option::t<@expr>, post: [@expr]} {\n     let idx: uint = 0u;\n     let res = none;\n@@ -122,7 +122,7 @@ fn elts_to_ell(cx: &ext_ctxt, elts: &[@expr]) ->\n         }\n }\n \n-fn option_flatten_map<T, U>(f: &fn(&T) -> option::t<U>, v: &[T]) ->\n+fn option_flatten_map<T, U>(f: fn(T) -> option::t<U>, v: [T]) ->\n    option::t<[U]> {\n     let res = [];\n     for elem: T in v {\n@@ -131,7 +131,7 @@ fn option_flatten_map<T, U>(f: &fn(&T) -> option::t<U>, v: &[T]) ->\n     ret some(res);\n }\n \n-fn a_d_map(ad: &arb_depth<matchable>, f: &selector) -> match_result {\n+fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n     alt ad {\n       leaf(x) { ret f(x); }\n       seq(ads, span) {\n@@ -144,7 +144,7 @@ fn a_d_map(ad: &arb_depth<matchable>, f: &selector) -> match_result {\n }\n \n fn compose_sels(s1: selector, s2: selector) -> selector {\n-    fn scomp(s1: selector, s2: selector, m: &matchable) -> match_result {\n+    fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n         ret alt s1(m) {\n               none. { none }\n               some(matches) { a_d_map(matches, s2) }\n@@ -160,19 +160,19 @@ type binders =\n      mutable literal_ast_matchers: [selector]};\n type bindings = hashmap<ident, arb_depth<matchable>>;\n \n-fn acumm_bindings(_cx: &ext_ctxt, _b_dest: &bindings, _b_src: &bindings) { }\n+fn acumm_bindings(_cx: ext_ctxt, _b_dest: bindings, _b_src: bindings) { }\n \n /* these three functions are the big moving parts */\n \n /* create the selectors needed to bind and verify the pattern */\n \n-fn pattern_to_selectors(cx: &ext_ctxt, e: @expr) -> binders {\n+fn pattern_to_selectors(cx: ext_ctxt, e: @expr) -> binders {\n     let res: binders =\n         {real_binders: new_str_hash::<selector>(),\n          mutable literal_ast_matchers: []};\n     //this oughta return binders instead, but macro args are a sequence of\n     //expressions, rather than a single expression\n-    fn trivial_selector(m: &matchable) -> match_result { ret some(leaf(m)); }\n+    fn trivial_selector(m: matchable) -> match_result { ret some(leaf(m)); }\n     p_t_s_rec(cx, match_expr(e), trivial_selector, res);\n     ret res;\n }\n@@ -183,7 +183,7 @@ fn pattern_to_selectors(cx: &ext_ctxt, e: @expr) -> binders {\n bindings. Most of the work is done in p_t_s, which generates the\n selectors. */\n \n-fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n+fn use_selectors_to_bind(b: binders, e: @expr) -> option::t<bindings> {\n     let res = new_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for sel: selector in b.literal_ast_matchers {\n@@ -203,10 +203,10 @@ fn use_selectors_to_bind(b: &binders, e: @expr) -> option::t<bindings> {\n \n /* use the bindings on the body to generate the expanded code */\n \n-fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n+fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     let idx_path: @mutable [uint] = @mutable [];\n-    fn new_id(_old: node_id, cx: &ext_ctxt) -> node_id { ret cx.next_id(); }\n-    fn new_span(cx: &ext_ctxt, sp: &span) -> span {\n+    fn new_id(_old: node_id, cx: ext_ctxt) -> node_id { ret cx.next_id(); }\n+    fn new_span(cx: ext_ctxt, sp: span) -> span {\n         /* this discards information in the case of macro-defining macros */\n         ret {lo: sp.lo, hi: sp.hi, expanded_from: cx.backtrace()};\n     }\n@@ -231,7 +231,7 @@ fn transcribe(cx: &ext_ctxt, b: &bindings, body: @expr) -> @expr {\n \n \n /* helper: descend into a matcher */\n-fn follow(m: &arb_depth<matchable>, idx_path: @mutable [uint]) ->\n+fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n    arb_depth<matchable> {\n     let res: arb_depth<matchable> = m;\n     for idx: uint in *idx_path {\n@@ -243,7 +243,7 @@ fn follow(m: &arb_depth<matchable>, idx_path: @mutable [uint]) ->\n     ret res;\n }\n \n-fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n+fn follow_for_trans(cx: ext_ctxt, mmaybe: option::t<arb_depth<matchable>>,\n                     idx_path: @mutable [uint]) -> option::t<matchable> {\n     alt mmaybe {\n       none. { ret none }\n@@ -262,10 +262,10 @@ fn follow_for_trans(cx: &ext_ctxt, mmaybe: &option::t<arb_depth<matchable>>,\n }\n \n /* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n-iter free_vars(b: &bindings, e: @expr) -> ident {\n+iter free_vars(b: bindings, e: @expr) -> ident {\n     let idents: hashmap<ident, ()> = new_str_hash::<()>();\n-    fn mark_ident(i: &ident, _fld: ast_fold, b: &bindings,\n-                  idents: &hashmap<ident, ()>) -> ident {\n+    fn mark_ident(i: ident, _fld: ast_fold, b: bindings,\n+                  idents: hashmap<ident, ()>) -> ident {\n         if b.contains_key(i) { idents.insert(i, ()); }\n         ret i;\n     }\n@@ -282,8 +282,8 @@ iter free_vars(b: &bindings, e: @expr) -> ident {\n \n \n /* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n-fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                    recur: fn(&@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n+fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+                    recur: fn(@expr) -> @expr, exprs: [@expr]) -> [@expr] {\n     alt elts_to_ell(cx, exprs) {\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n         let res = vec::map(recur, pre);\n@@ -344,8 +344,8 @@ fn transcribe_exprs(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n \n // substitute, in a position that's required to be an ident\n-fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                    i: &ident, _fld: ast_fold) -> ident {\n+fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+                    i: ident, _fld: ast_fold) -> ident {\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n           some(m) { match_error(cx, m, \"an identifier\") }\n@@ -354,8 +354,8 @@ fn transcribe_ident(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n }\n \n \n-fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                   p: &path_, _fld: ast_fold) -> path_ {\n+fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+                   p: path_, _fld: ast_fold) -> path_ {\n     // Don't substitute into qualified names.\n     if vec::len(p.types) > 0u || vec::len(p.idents) != 1u { ret p; }\n     ret alt follow_for_trans(cx, b.find(p.idents[0]), idx_path) {\n@@ -369,9 +369,9 @@ fn transcribe_path(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n }\n \n \n-fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                   e: &ast::expr_, fld: ast_fold,\n-                   orig: fn(&ast::expr_, ast_fold) -> ast::expr_) ->\n+fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+                   e: ast::expr_, fld: ast_fold,\n+                   orig: fn(ast::expr_, ast_fold) -> ast::expr_) ->\n    ast::expr_ {\n     ret alt e {\n           expr_path(p) {\n@@ -396,9 +396,9 @@ fn transcribe_expr(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n         }\n }\n \n-fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                   t: &ast::ty_, fld: ast_fold,\n-                   orig: fn(&ast::ty_, ast_fold) -> ast::ty_) -> ast::ty_ {\n+fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+                   t: ast::ty_, fld: ast_fold,\n+                   orig: fn(ast::ty_, ast_fold) -> ast::ty_) -> ast::ty_ {\n     ret alt t {\n           ast::ty_path(pth, _) {\n             alt path_to_ident(pth) {\n@@ -420,16 +420,17 @@ fn transcribe_type(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n /* for parsing reasons, syntax variables bound to blocks must be used like\n `{v}` */\n \n-fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n-                    blk: &blk_, fld: ast_fold,\n-                    orig: fn(&blk_, ast_fold) -> blk_) -> blk_ {\n+fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n+                    blk: blk_, fld: ast_fold,\n+                    orig: fn(blk_, ast_fold) -> blk_) -> blk_ {\n     ret alt block_to_ident(blk) {\n           some(id) {\n             alt follow_for_trans(cx, b.find(id), idx_path) {\n               some(match_block(new_blk)) { new_blk.node }\n \n \n \n+\n               // possibly allow promotion of ident/path/expr to blocks?\n               some(m) {\n                 match_error(cx, m, \"a block\")\n@@ -444,7 +445,7 @@ fn transcribe_block(cx: &ext_ctxt, b: &bindings, idx_path: @mutable [uint],\n \n /* traverse the pattern, building instructions on how to bind the actual\n argument. ps accumulates instructions on navigating the tree.*/\n-fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n+fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n \n     //it might be possible to traverse only exprs, not matchables\n     alt m {\n@@ -478,12 +479,13 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n \n \n \n+\n           /* TODO: handle embedded types and blocks, at least */\n           expr_mac(mac) {\n             p_t_s_r_mac(cx, mac, s, b);\n           }\n           _ {\n-            fn select(cx: &ext_ctxt, m: &matchable, pat: @expr) ->\n+            fn select(cx: ext_ctxt, m: matchable, pat: @expr) ->\n                match_result {\n                 ret alt m {\n                       match_expr(e) {\n@@ -501,7 +503,7 @@ fn p_t_s_rec(cx: &ext_ctxt, m: &matchable, s: &selector, b: &binders) {\n \n \n /* make a match more precise */\n-fn specialize_match(m: &matchable) -> matchable {\n+fn specialize_match(m: matchable) -> matchable {\n     ret alt m {\n           match_expr(e) {\n             alt e.node {\n@@ -519,10 +521,10 @@ fn specialize_match(m: &matchable) -> matchable {\n }\n \n /* pattern_to_selectors helper functions */\n-fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n+fn p_t_s_r_path(cx: ext_ctxt, p: path, s: selector, b: binders) {\n     alt path_to_ident(p) {\n       some(p_id) {\n-        fn select(cx: &ext_ctxt, m: &matchable) -> match_result {\n+        fn select(cx: ext_ctxt, m: matchable) -> match_result {\n             ret alt m {\n                   match_expr(e) { some(leaf(specialize_match(m))) }\n                   _ { cx.bug(\"broken traversal in p_t_s_r\") }\n@@ -537,7 +539,7 @@ fn p_t_s_r_path(cx: &ext_ctxt, p: &path, s: &selector, b: &binders) {\n     }\n }\n \n-fn block_to_ident(blk: &blk_) -> option::t<ident> {\n+fn block_to_ident(blk: blk_) -> option::t<ident> {\n     if vec::len(blk.stmts) != 0u { ret none; }\n     ret alt blk.expr {\n           some(expr) {\n@@ -547,17 +549,17 @@ fn block_to_ident(blk: &blk_) -> option::t<ident> {\n         }\n }\n \n-fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n-    fn select_pt_1(cx: &ext_ctxt, m: &matchable,\n-                   fn_m: fn(&ast::mac) -> match_result) -> match_result {\n+fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n+    fn select_pt_1(cx: ext_ctxt, m: matchable,\n+                   fn_m: fn(ast::mac) -> match_result) -> match_result {\n         ret alt m {\n               match_expr(e) {\n                 alt e.node { expr_mac(mac) { fn_m(mac) } _ { none } }\n               }\n               _ { cx.bug(\"broken traversal in p_t_s_r\") }\n             }\n     }\n-    fn no_des(cx: &ext_ctxt, sp: &span, syn: &str) -> ! {\n+    fn no_des(cx: ext_ctxt, sp: span, syn: str) -> ! {\n         cx.span_fatal(sp, \"destructuring \" + syn + \" is not yet supported\");\n     }\n     alt mac.node {\n@@ -569,7 +571,7 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n             alt path_to_ident(pth) {\n               some(id) {\n                 /* look for an embedded type */\n-                fn select_pt_2(m: &ast::mac) -> match_result {\n+                fn select_pt_2(m: ast::mac) -> match_result {\n                     ret alt m.node {\n                           ast::mac_embed_type(t) { some(leaf(match_ty(t))) }\n                           _ { none }\n@@ -587,7 +589,7 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n       ast::mac_embed_block(blk) {\n         alt block_to_ident(blk.node) {\n           some(id) {\n-            fn select_pt_2(m: &ast::mac) -> match_result {\n+            fn select_pt_2(m: ast::mac) -> match_result {\n                 ret alt m.node {\n                       ast::mac_embed_block(blk) {\n                         some(leaf(match_block(blk)))\n@@ -604,9 +606,9 @@ fn p_t_s_r_mac(cx: &ext_ctxt, mac: &ast::mac, s: &selector, b: &binders) {\n     }\n }\n \n-fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n-                    s: &selector, b: &binders) {\n-    fn select(cx: &ext_ctxt, repeat_me: @expr, offset: uint, m: &matchable) ->\n+fn p_t_s_r_ellipses(cx: ext_ctxt, repeat_me: @expr, offset: uint, s: selector,\n+                    b: binders) {\n+    fn select(cx: ext_ctxt, repeat_me: @expr, offset: uint, m: matchable) ->\n        match_result {\n         ret alt m {\n               match_expr(e) {\n@@ -634,9 +636,9 @@ fn p_t_s_r_ellipses(cx: &ext_ctxt, repeat_me: @expr, offset: uint,\n }\n \n \n-fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n-                  b: &binders) {\n-    fn len_select(_cx: &ext_ctxt, m: &matchable, at_least: bool, len: uint) ->\n+fn p_t_s_r_length(cx: ext_ctxt, len: uint, at_least: bool, s: selector,\n+                  b: binders) {\n+    fn len_select(_cx: ext_ctxt, m: matchable, at_least: bool, len: uint) ->\n        match_result {\n         ret alt m {\n               match_expr(e) {\n@@ -657,11 +659,11 @@ fn p_t_s_r_length(cx: &ext_ctxt, len: uint, at_least: bool, s: selector,\n         [compose_sels(s, bind len_select(cx, _, at_least, len))];\n }\n \n-fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n-                         s: &selector, b: &binders) {\n+fn p_t_s_r_actual_vector(cx: ext_ctxt, elts: [@expr], _repeat_after: bool,\n+                         s: selector, b: binders) {\n     let idx: uint = 0u;\n     while idx < vec::len(elts) {\n-        fn select(cx: &ext_ctxt, m: &matchable, idx: uint) -> match_result {\n+        fn select(cx: ext_ctxt, m: matchable, idx: uint) -> match_result {\n             ret alt m {\n                   match_expr(e) {\n                     alt e.node {\n@@ -680,8 +682,8 @@ fn p_t_s_r_actual_vector(cx: &ext_ctxt, elts: [@expr], _repeat_after: bool,\n     }\n }\n \n-fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                     _body: &option::t<str>) -> base::macro_def {\n+fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n+                     _body: option::t<str>) -> base::macro_def {\n     let args: [@ast::expr] =\n         alt arg.node {\n           ast::expr_vec(elts, _) { elts }\n@@ -760,9 +762,8 @@ fn add_new_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n              },\n          ext: normal(ext)};\n \n-    fn generic_extension(cx: &ext_ctxt, sp: span, arg: @expr,\n-                         _body: &option::t<str>, clauses: [@clause]) ->\n-       @expr {\n+    fn generic_extension(cx: ext_ctxt, sp: span, arg: @expr,\n+                         _body: option::t<str>, clauses: [@clause]) -> @expr {\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body) }"}, {"sha": "0a628214eda4c8118b76699b197da03942cfb311", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 129, "deletions": 131, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -21,92 +21,91 @@ type ast_fold = @mutable a_f;\n \n type ast_fold_precursor =\n     //unlike the others, item_ is non-trivial\n-    {fold_crate: fn(&crate_, ast_fold) -> crate_,\n-     fold_crate_directive:\n-         fn(&crate_directive_, ast_fold) -> crate_directive_,\n-     fold_view_item: fn(&view_item_, ast_fold) -> view_item_,\n-     fold_native_item: fn(&@native_item, ast_fold) -> @native_item,\n-     fold_item: fn(&@item, ast_fold) -> @item,\n-     fold_item_underscore: fn(&item_, ast_fold) -> item_,\n-     fold_method: fn(&method_, ast_fold) -> method_,\n-     fold_block: fn(&blk_, ast_fold) -> blk_,\n-     fold_stmt: fn(&stmt_, ast_fold) -> stmt_,\n-     fold_arm: fn(&arm, ast_fold) -> arm,\n-     fold_pat: fn(&pat_, ast_fold) -> pat_,\n-     fold_decl: fn(&decl_, ast_fold) -> decl_,\n-     fold_expr: fn(&expr_, ast_fold) -> expr_,\n-     fold_ty: fn(&ty_, ast_fold) -> ty_,\n-     fold_constr: fn(&ast::constr_, ast_fold) -> constr_,\n-     fold_fn: fn(&_fn, ast_fold) -> _fn,\n-     fold_mod: fn(&_mod, ast_fold) -> _mod,\n-     fold_native_mod: fn(&native_mod, ast_fold) -> native_mod,\n-     fold_variant: fn(&variant_, ast_fold) -> variant_,\n-     fold_ident: fn(&ident, ast_fold) -> ident,\n-     fold_path: fn(&path_, ast_fold) -> path_,\n-     fold_local: fn(&local_, ast_fold) -> local_,\n-     map_exprs: fn(fn(&@expr) -> @expr, [@expr]) -> [@expr],\n+    {fold_crate: fn(crate_, ast_fold) -> crate_,\n+     fold_crate_directive: fn(crate_directive_, ast_fold) -> crate_directive_,\n+     fold_view_item: fn(view_item_, ast_fold) -> view_item_,\n+     fold_native_item: fn(@native_item, ast_fold) -> @native_item,\n+     fold_item: fn(@item, ast_fold) -> @item,\n+     fold_item_underscore: fn(item_, ast_fold) -> item_,\n+     fold_method: fn(method_, ast_fold) -> method_,\n+     fold_block: fn(blk_, ast_fold) -> blk_,\n+     fold_stmt: fn(stmt_, ast_fold) -> stmt_,\n+     fold_arm: fn(arm, ast_fold) -> arm,\n+     fold_pat: fn(pat_, ast_fold) -> pat_,\n+     fold_decl: fn(decl_, ast_fold) -> decl_,\n+     fold_expr: fn(expr_, ast_fold) -> expr_,\n+     fold_ty: fn(ty_, ast_fold) -> ty_,\n+     fold_constr: fn(ast::constr_, ast_fold) -> constr_,\n+     fold_fn: fn(_fn, ast_fold) -> _fn,\n+     fold_mod: fn(_mod, ast_fold) -> _mod,\n+     fold_native_mod: fn(native_mod, ast_fold) -> native_mod,\n+     fold_variant: fn(variant_, ast_fold) -> variant_,\n+     fold_ident: fn(ident, ast_fold) -> ident,\n+     fold_path: fn(path_, ast_fold) -> path_,\n+     fold_local: fn(local_, ast_fold) -> local_,\n+     map_exprs: fn(fn(@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn(node_id) -> node_id,\n-     new_span: fn(&span) -> span};\n+     new_span: fn(span) -> span};\n \n type a_f =\n-    {fold_crate: fn(&crate) -> crate,\n-     fold_crate_directive: fn(&@crate_directive) -> @crate_directive,\n-     fold_view_item: fn(&@view_item) -> @view_item,\n-     fold_native_item: fn(&@native_item) -> @native_item,\n-     fold_item: fn(&@item) -> @item,\n-     fold_item_underscore: fn(&item_) -> item_,\n-     fold_method: fn(&@method) -> @method,\n-     fold_block: fn(&blk) -> blk,\n-     fold_stmt: fn(&@stmt) -> @stmt,\n-     fold_arm: fn(&arm) -> arm,\n-     fold_pat: fn(&@pat) -> @pat,\n-     fold_decl: fn(&@decl) -> @decl,\n-     fold_expr: fn(&@expr) -> @expr,\n-     fold_ty: fn(&@ty) -> @ty,\n-     fold_constr: fn(&@constr) -> @constr,\n-     fold_fn: fn(&_fn) -> _fn,\n-     fold_mod: fn(&_mod) -> _mod,\n-     fold_native_mod: fn(&native_mod) -> native_mod,\n-     fold_variant: fn(&variant) -> variant,\n-     fold_ident: fn(&ident) -> ident,\n-     fold_path: fn(&path) -> path,\n-     fold_local: fn(&@local) -> @local,\n-     map_exprs: fn(fn(&@expr) -> @expr, [@expr]) -> [@expr],\n+    {fold_crate: fn(crate) -> crate,\n+     fold_crate_directive: fn(@crate_directive) -> @crate_directive,\n+     fold_view_item: fn(@view_item) -> @view_item,\n+     fold_native_item: fn(@native_item) -> @native_item,\n+     fold_item: fn(@item) -> @item,\n+     fold_item_underscore: fn(item_) -> item_,\n+     fold_method: fn(@method) -> @method,\n+     fold_block: fn(blk) -> blk,\n+     fold_stmt: fn(@stmt) -> @stmt,\n+     fold_arm: fn(arm) -> arm,\n+     fold_pat: fn(@pat) -> @pat,\n+     fold_decl: fn(@decl) -> @decl,\n+     fold_expr: fn(@expr) -> @expr,\n+     fold_ty: fn(@ty) -> @ty,\n+     fold_constr: fn(@constr) -> @constr,\n+     fold_fn: fn(_fn) -> _fn,\n+     fold_mod: fn(_mod) -> _mod,\n+     fold_native_mod: fn(native_mod) -> native_mod,\n+     fold_variant: fn(variant) -> variant,\n+     fold_ident: fn(ident) -> ident,\n+     fold_path: fn(path) -> path,\n+     fold_local: fn(@local) -> @local,\n+     map_exprs: fn(fn(@expr) -> @expr, [@expr]) -> [@expr],\n      new_id: fn(node_id) -> node_id,\n-     new_span: fn(&span) -> span};\n+     new_span: fn(span) -> span};\n \n \n //fn nf_dummy<T>(&T node) -> T { fail; }\n-fn nf_crate_dummy(_c: &crate) -> crate { fail; }\n-fn nf_crate_directive_dummy(_c: &@crate_directive) -> @crate_directive {\n+fn nf_crate_dummy(_c: crate) -> crate { fail; }\n+fn nf_crate_directive_dummy(_c: @crate_directive) -> @crate_directive {\n     fail;\n }\n-fn nf_view_item_dummy(_v: &@view_item) -> @view_item { fail; }\n-fn nf_native_item_dummy(_n: &@native_item) -> @native_item { fail; }\n-fn nf_item_dummy(_i: &@item) -> @item { fail; }\n-fn nf_item_underscore_dummy(_i: &item_) -> item_ { fail; }\n-fn nf_method_dummy(_m: &@method) -> @method { fail; }\n-fn nf_blk_dummy(_b: &blk) -> blk { fail; }\n-fn nf_stmt_dummy(_s: &@stmt) -> @stmt { fail; }\n-fn nf_arm_dummy(_a: &arm) -> arm { fail; }\n-fn nf_pat_dummy(_p: &@pat) -> @pat { fail; }\n-fn nf_decl_dummy(_d: &@decl) -> @decl { fail; }\n-fn nf_expr_dummy(_e: &@expr) -> @expr { fail; }\n-fn nf_ty_dummy(_t: &@ty) -> @ty { fail; }\n-fn nf_constr_dummy(_c: &@constr) -> @constr { fail; }\n-fn nf_fn_dummy(_f: &_fn) -> _fn { fail; }\n-fn nf_mod_dummy(_m: &_mod) -> _mod { fail; }\n-fn nf_native_mod_dummy(_n: &native_mod) -> native_mod { fail; }\n-fn nf_variant_dummy(_v: &variant) -> variant { fail; }\n-fn nf_ident_dummy(_i: &ident) -> ident { fail; }\n-fn nf_path_dummy(_p: &path) -> path { fail; }\n-fn nf_obj_field_dummy(_o: &obj_field) -> obj_field { fail; }\n-fn nf_local_dummy(_o: &@local) -> @local { fail; }\n+fn nf_view_item_dummy(_v: @view_item) -> @view_item { fail; }\n+fn nf_native_item_dummy(_n: @native_item) -> @native_item { fail; }\n+fn nf_item_dummy(_i: @item) -> @item { fail; }\n+fn nf_item_underscore_dummy(_i: item_) -> item_ { fail; }\n+fn nf_method_dummy(_m: @method) -> @method { fail; }\n+fn nf_blk_dummy(_b: blk) -> blk { fail; }\n+fn nf_stmt_dummy(_s: @stmt) -> @stmt { fail; }\n+fn nf_arm_dummy(_a: arm) -> arm { fail; }\n+fn nf_pat_dummy(_p: @pat) -> @pat { fail; }\n+fn nf_decl_dummy(_d: @decl) -> @decl { fail; }\n+fn nf_expr_dummy(_e: @expr) -> @expr { fail; }\n+fn nf_ty_dummy(_t: @ty) -> @ty { fail; }\n+fn nf_constr_dummy(_c: @constr) -> @constr { fail; }\n+fn nf_fn_dummy(_f: _fn) -> _fn { fail; }\n+fn nf_mod_dummy(_m: _mod) -> _mod { fail; }\n+fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n+fn nf_variant_dummy(_v: variant) -> variant { fail; }\n+fn nf_ident_dummy(_i: ident) -> ident { fail; }\n+fn nf_path_dummy(_p: path) -> path { fail; }\n+fn nf_obj_field_dummy(_o: obj_field) -> obj_field { fail; }\n+fn nf_local_dummy(_o: @local) -> @local { fail; }\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n //used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(mi: &@meta_item, fld: ast_fold) -> @meta_item {\n+fn fold_meta_item_(mi: @meta_item, fld: ast_fold) -> @meta_item {\n     ret @{node:\n               alt mi.node {\n                 meta_word(id) { meta_word(fld.fold_ident(id)) }\n@@ -121,20 +120,20 @@ fn fold_meta_item_(mi: &@meta_item, fld: ast_fold) -> @meta_item {\n           span: mi.span};\n }\n //used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: &attribute, fmi: fn(&@meta_item) -> @meta_item) ->\n+fn fold_attribute_(at: attribute, fmi: fn(@meta_item) -> @meta_item) ->\n    attribute {\n     ret {node: {style: at.node.style, value: *fmi(@at.node.value)},\n          span: at.span};\n }\n //used in noop_fold_native_item and noop_fold_fn\n-fn fold_arg_(a: &arg, fld: ast_fold) -> arg {\n+fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n     ret {mode: a.mode,\n          ty: fld.fold_ty(a.ty),\n          ident: fld.fold_ident(a.ident),\n          id: a.id};\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n-fn fold_mac_(m: &mac, fld: ast_fold) -> mac {\n+fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n     ret {node:\n              alt m.node {\n                mac_invoc(pth, arg, body) {\n@@ -151,7 +150,7 @@ fn fold_mac_(m: &mac, fld: ast_fold) -> mac {\n \n \n \n-fn noop_fold_crate(c: &crate_, fld: ast_fold) -> crate_ {\n+fn noop_fold_crate(c: crate_, fld: ast_fold) -> crate_ {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n@@ -161,7 +160,7 @@ fn noop_fold_crate(c: &crate_, fld: ast_fold) -> crate_ {\n          config: vec::map(fold_meta_item, c.config)};\n }\n \n-fn noop_fold_crate_directive(cd: &crate_directive_, fld: ast_fold) ->\n+fn noop_fold_crate_directive(cd: crate_directive_, fld: ast_fold) ->\n    crate_directive_ {\n     ret alt cd {\n           cdir_src_mod(id, fname, attrs) {\n@@ -177,12 +176,12 @@ fn noop_fold_crate_directive(cd: &crate_directive_, fld: ast_fold) ->\n         }\n }\n \n-fn noop_fold_view_item(vi: &view_item_, _fld: ast_fold) -> view_item_ {\n+fn noop_fold_view_item(vi: view_item_, _fld: ast_fold) -> view_item_ {\n     ret vi;\n }\n \n \n-fn noop_fold_native_item(ni: &@native_item, fld: ast_fold) -> @native_item {\n+fn noop_fold_native_item(ni: @native_item, fld: ast_fold) -> @native_item {\n     let fold_arg = bind fold_arg_(_, fld);\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n@@ -208,7 +207,7 @@ fn noop_fold_native_item(ni: &@native_item, fld: ast_fold) -> @native_item {\n           span: ni.span};\n }\n \n-fn noop_fold_item(i: &@item, fld: ast_fold) -> @item {\n+fn noop_fold_item(i: @item, fld: ast_fold) -> @item {\n     let fold_meta_item = bind fold_meta_item_(_, fld);\n     let fold_attribute = bind fold_attribute_(_, fold_meta_item);\n \n@@ -219,8 +218,8 @@ fn noop_fold_item(i: &@item, fld: ast_fold) -> @item {\n           span: i.span};\n }\n \n-fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n-    fn fold_obj_field_(of: &obj_field, fld: ast_fold) -> obj_field {\n+fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n+    fn fold_obj_field_(of: obj_field, fld: ast_fold) -> obj_field {\n         ret {mut: of.mut,\n              ty: fld.fold_ty(of.ty),\n              ident: fld.fold_ident(of.ident),\n@@ -248,19 +247,19 @@ fn noop_fold_item_underscore(i: &item_, fld: ast_fold) -> item_ {\n         };\n }\n \n-fn noop_fold_method(m: &method_, fld: ast_fold) -> method_ {\n+fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n     ret {ident: fld.fold_ident(m.ident), meth: fld.fold_fn(m.meth), id: m.id};\n }\n \n \n-fn noop_fold_block(b: &blk_, fld: ast_fold) -> blk_ {\n+fn noop_fold_block(b: blk_, fld: ast_fold) -> blk_ {\n     ret {stmts: vec::map(fld.fold_stmt, b.stmts),\n          expr: option::map(fld.fold_expr, b.expr),\n          id: b.id,\n          rules: b.rules};\n }\n \n-fn noop_fold_stmt(s: &stmt_, fld: ast_fold) -> stmt_ {\n+fn noop_fold_stmt(s: stmt_, fld: ast_fold) -> stmt_ {\n     ret alt s {\n           stmt_decl(d, nid) { stmt_decl(fld.fold_decl(d), nid) }\n           stmt_expr(e, nid) { stmt_expr(fld.fold_expr(e), nid) }\n@@ -270,13 +269,13 @@ fn noop_fold_stmt(s: &stmt_, fld: ast_fold) -> stmt_ {\n         };\n }\n \n-fn noop_fold_arm(a: &arm, fld: ast_fold) -> arm {\n+fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n     ret {pats: vec::map(fld.fold_pat, a.pats),\n          guard: option::map(fld.fold_expr, a.guard),\n          body: fld.fold_block(a.body)};\n }\n \n-fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n+fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n           pat_wild. { p }\n           pat_bind(ident) { pat_bind(fld.fold_ident(ident)) }\n@@ -296,24 +295,24 @@ fn noop_fold_pat(p: &pat_, fld: ast_fold) -> pat_ {\n         };\n }\n \n-fn noop_fold_decl(d: &decl_, fld: ast_fold) -> decl_ {\n+fn noop_fold_decl(d: decl_, fld: ast_fold) -> decl_ {\n     ret alt d {\n           decl_local(ls) { decl_local(vec::map(fld.fold_local, ls)) }\n           decl_item(it) { decl_item(fld.fold_item(it)) }\n         }\n }\n \n-fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n-    fn fold_field_(field: &field, fld: ast_fold) -> field {\n+fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n+    fn fold_field_(field: field, fld: ast_fold) -> field {\n         ret {node:\n                  {mut: field.node.mut,\n                   ident: fld.fold_ident(field.node.ident),\n                   expr: fld.fold_expr(field.node.expr)},\n              span: field.span};\n     }\n     let fold_field = bind fold_field_(_, fld);\n-    fn fold_anon_obj_(ao: &anon_obj, fld: ast_fold) -> anon_obj {\n-        fn fold_anon_obj_field_(aof: &anon_obj_field, fld: ast_fold) ->\n+    fn fold_anon_obj_(ao: anon_obj, fld: ast_fold) -> anon_obj {\n+        fn fold_anon_obj_field_(aof: anon_obj_field, fld: ast_fold) ->\n            anon_obj_field {\n             ret {mut: aof.mut,\n                  ty: fld.fold_ty(aof.ty),\n@@ -427,17 +426,17 @@ fn noop_fold_expr(e: &expr_, fld: ast_fold) -> expr_ {\n         }\n }\n \n-fn noop_fold_ty(t: &ty_, _fld: ast_fold) -> ty_ {\n+fn noop_fold_ty(t: ty_, _fld: ast_fold) -> ty_ {\n     //drop in ty::fold_ty here if necessary\n     ret t;\n }\n \n-fn noop_fold_constr(c: &constr_, fld: ast_fold) -> constr_ {\n+fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n     {path: fld.fold_path(c.path), args: c.args, id: c.id}\n }\n \n // functions just don't get spans, for some reason\n-fn noop_fold_fn(f: &_fn, fld: ast_fold) -> _fn {\n+fn noop_fold_fn(f: _fn, fld: ast_fold) -> _fn {\n     let fold_arg = bind fold_arg_(_, fld);\n \n     ret {decl:\n@@ -452,35 +451,35 @@ fn noop_fold_fn(f: &_fn, fld: ast_fold) -> _fn {\n }\n \n // ...nor do modules\n-fn noop_fold_mod(m: &_mod, fld: ast_fold) -> _mod {\n+fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     ret {view_items: vec::map(fld.fold_view_item, m.view_items),\n          items: vec::map(fld.fold_item, m.items)};\n }\n \n-fn noop_fold_native_mod(nm: &native_mod, fld: ast_fold) -> native_mod {\n+fn noop_fold_native_mod(nm: native_mod, fld: ast_fold) -> native_mod {\n     ret {native_name: nm.native_name,\n          abi: nm.abi,\n          view_items: vec::map(fld.fold_view_item, nm.view_items),\n          items: vec::map(fld.fold_native_item, nm.items)}\n }\n \n-fn noop_fold_variant(v: &variant_, fld: ast_fold) -> variant_ {\n-    fn fold_variant_arg_(va: &variant_arg, fld: ast_fold) -> variant_arg {\n+fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n+    fn fold_variant_arg_(va: variant_arg, fld: ast_fold) -> variant_arg {\n         ret {ty: fld.fold_ty(va.ty), id: va.id};\n     }\n     let fold_variant_arg = bind fold_variant_arg_(_, fld);\n     ret {name: v.name, args: vec::map(fold_variant_arg, v.args), id: v.id};\n }\n \n-fn noop_fold_ident(i: &ident, _fld: ast_fold) -> ident { ret i; }\n+fn noop_fold_ident(i: ident, _fld: ast_fold) -> ident { ret i; }\n \n-fn noop_fold_path(p: &path_, fld: ast_fold) -> path_ {\n+fn noop_fold_path(p: path_, fld: ast_fold) -> path_ {\n     ret {global: p.global,\n          idents: vec::map(fld.fold_ident, p.idents),\n          types: vec::map(fld.fold_ty, p.types)};\n }\n \n-fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n+fn noop_fold_local(l: local_, fld: ast_fold) -> local_ {\n     ret {ty: fld.fold_ty(l.ty),\n          pat: fld.fold_pat(l.pat),\n          init:\n@@ -496,13 +495,13 @@ fn noop_fold_local(l: &local_, fld: ast_fold) -> local_ {\n \n /* temporarily eta-expand because of a compiler bug with using `fn<T>` as a\n    value */\n-fn noop_map_exprs(f: fn(&@expr) -> @expr, es: [@expr]) -> [@expr] {\n+fn noop_map_exprs(f: fn(@expr) -> @expr, es: [@expr]) -> [@expr] {\n     ret vec::map(f, es);\n }\n \n fn noop_id(i: node_id) -> node_id { ret i; }\n \n-fn noop_span(sp: &span) -> span { ret sp; }\n+fn noop_span(sp: span) -> span { ret sp; }\n \n \n fn default_ast_fold() -> @ast_fold_precursor {\n@@ -563,7 +562,7 @@ fn dummy_out(a: ast_fold) {\n }\n \n \n-fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n+fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     let result: ast_fold =\n         @mutable {fold_crate: nf_crate_dummy,\n                   fold_crate_directive: nf_crate_directive_dummy,\n@@ -592,84 +591,83 @@ fn make_fold(afp: &ast_fold_precursor) -> ast_fold {\n                   new_span: noop_span};\n \n     /* naturally, a macro to write these would be nice */\n-    fn f_crate(afp: &ast_fold_precursor, f: ast_fold, c: &crate) -> crate {\n+    fn f_crate(afp: ast_fold_precursor, f: ast_fold, c: crate) -> crate {\n         ret {node: afp.fold_crate(c.node, f), span: afp.new_span(c.span)};\n     }\n-    fn f_crate_directive(afp: &ast_fold_precursor, f: ast_fold,\n-                         c: &@crate_directive) -> @crate_directive {\n+    fn f_crate_directive(afp: ast_fold_precursor, f: ast_fold,\n+                         c: @crate_directive) -> @crate_directive {\n         ret @{node: afp.fold_crate_directive(c.node, f),\n               span: afp.new_span(c.span)};\n     }\n-    fn f_view_item(afp: &ast_fold_precursor, f: ast_fold, x: &@view_item) ->\n+    fn f_view_item(afp: ast_fold_precursor, f: ast_fold, x: @view_item) ->\n        @view_item {\n         ret @{node: afp.fold_view_item(x.node, f),\n               span: afp.new_span(x.span)};\n     }\n-    fn f_native_item(afp: &ast_fold_precursor, f: ast_fold, x: &@native_item)\n-       -> @native_item {\n+    fn f_native_item(afp: ast_fold_precursor, f: ast_fold, x: @native_item) ->\n+       @native_item {\n         ret afp.fold_native_item(x, f);\n     }\n-    fn f_item(afp: &ast_fold_precursor, f: ast_fold, i: &@item) -> @item {\n+    fn f_item(afp: ast_fold_precursor, f: ast_fold, i: @item) -> @item {\n         ret afp.fold_item(i, f);\n     }\n-    fn f_item_underscore(afp: &ast_fold_precursor, f: ast_fold, i: &item_) ->\n+    fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n        item_ {\n         ret afp.fold_item_underscore(i, f);\n     }\n-    fn f_method(afp: &ast_fold_precursor, f: ast_fold, x: &@method) ->\n-       @method {\n+    fn f_method(afp: ast_fold_precursor, f: ast_fold, x: @method) -> @method {\n         ret @{node: afp.fold_method(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_block(afp: &ast_fold_precursor, f: ast_fold, x: &blk) -> blk {\n+    fn f_block(afp: ast_fold_precursor, f: ast_fold, x: blk) -> blk {\n         ret {node: afp.fold_block(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_stmt(afp: &ast_fold_precursor, f: ast_fold, x: &@stmt) -> @stmt {\n+    fn f_stmt(afp: ast_fold_precursor, f: ast_fold, x: @stmt) -> @stmt {\n         ret @{node: afp.fold_stmt(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_arm(afp: &ast_fold_precursor, f: ast_fold, x: &arm) -> arm {\n+    fn f_arm(afp: ast_fold_precursor, f: ast_fold, x: arm) -> arm {\n         ret afp.fold_arm(x, f);\n     }\n-    fn f_pat(afp: &ast_fold_precursor, f: ast_fold, x: &@pat) -> @pat {\n+    fn f_pat(afp: ast_fold_precursor, f: ast_fold, x: @pat) -> @pat {\n         ret @{id: afp.new_id(x.id),\n               node: afp.fold_pat(x.node, f),\n               span: afp.new_span(x.span)};\n     }\n-    fn f_decl(afp: &ast_fold_precursor, f: ast_fold, x: &@decl) -> @decl {\n+    fn f_decl(afp: ast_fold_precursor, f: ast_fold, x: @decl) -> @decl {\n         ret @{node: afp.fold_decl(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_expr(afp: &ast_fold_precursor, f: ast_fold, x: &@expr) -> @expr {\n+    fn f_expr(afp: ast_fold_precursor, f: ast_fold, x: @expr) -> @expr {\n         ret @{id: afp.new_id(x.id),\n               node: afp.fold_expr(x.node, f),\n               span: afp.new_span(x.span)};\n     }\n-    fn f_ty(afp: &ast_fold_precursor, f: ast_fold, x: &@ty) -> @ty {\n+    fn f_ty(afp: ast_fold_precursor, f: ast_fold, x: @ty) -> @ty {\n         ret @{node: afp.fold_ty(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_constr(afp: &ast_fold_precursor, f: ast_fold, x: &@ast::constr) ->\n+    fn f_constr(afp: ast_fold_precursor, f: ast_fold, x: @ast::constr) ->\n        @ast::constr {\n         ret @{node: afp.fold_constr(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_fn(afp: &ast_fold_precursor, f: ast_fold, x: &_fn) -> _fn {\n+    fn f_fn(afp: ast_fold_precursor, f: ast_fold, x: _fn) -> _fn {\n         ret afp.fold_fn(x, f);\n     }\n-    fn f_mod(afp: &ast_fold_precursor, f: ast_fold, x: &_mod) -> _mod {\n+    fn f_mod(afp: ast_fold_precursor, f: ast_fold, x: _mod) -> _mod {\n         ret afp.fold_mod(x, f);\n     }\n-    fn f_native_mod(afp: &ast_fold_precursor, f: ast_fold, x: &native_mod) ->\n+    fn f_native_mod(afp: ast_fold_precursor, f: ast_fold, x: native_mod) ->\n        native_mod {\n         ret afp.fold_native_mod(x, f);\n     }\n-    fn f_variant(afp: &ast_fold_precursor, f: ast_fold, x: &variant) ->\n+    fn f_variant(afp: ast_fold_precursor, f: ast_fold, x: variant) ->\n        variant {\n         ret {node: afp.fold_variant(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_ident(afp: &ast_fold_precursor, f: ast_fold, x: &ident) -> ident {\n+    fn f_ident(afp: ast_fold_precursor, f: ast_fold, x: ident) -> ident {\n         ret afp.fold_ident(x, f);\n     }\n-    fn f_path(afp: &ast_fold_precursor, f: ast_fold, x: &path) -> path {\n+    fn f_path(afp: ast_fold_precursor, f: ast_fold, x: path) -> path {\n         ret {node: afp.fold_path(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_local(afp: &ast_fold_precursor, f: ast_fold, x: &@local) -> @local {\n+    fn f_local(afp: ast_fold_precursor, f: ast_fold, x: @local) -> @local {\n         ret @{node: afp.fold_local(x.node, f), span: afp.new_span(x.span)};\n     }\n "}, {"sha": "147f1b9453e894b506ad611f74216a45b7ccfc83", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -25,23 +25,23 @@ type ctx =\n       mutable byte_pos: uint,\n       cfg: ast::crate_cfg};\n \n-fn eval_crate_directives(cx: ctx, cdirs: &[@ast::crate_directive],\n-                         prefix: &str, view_items: &mutable [@ast::view_item],\n+fn eval_crate_directives(cx: ctx, cdirs: [@ast::crate_directive], prefix: str,\n+                         view_items: &mutable [@ast::view_item],\n                          items: &mutable [@ast::item]) {\n     for sub_cdir: @ast::crate_directive in cdirs {\n         eval_crate_directive(cx, sub_cdir, prefix, view_items, items);\n     }\n }\n \n-fn eval_crate_directives_to_mod(cx: ctx, cdirs: &[@ast::crate_directive],\n-                                prefix: &str) -> ast::_mod {\n+fn eval_crate_directives_to_mod(cx: ctx, cdirs: [@ast::crate_directive],\n+                                prefix: str) -> ast::_mod {\n     let view_items: [@ast::view_item] = [];\n     let items: [@ast::item] = [];\n     eval_crate_directives(cx, cdirs, prefix, view_items, items);\n     ret {view_items: view_items, items: items};\n }\n \n-fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &str,\n+fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: str,\n                         view_items: &mutable [@ast::view_item],\n                         items: &mutable [@ast::item]) {\n     alt cdir.node {"}, {"sha": "c5a9eefdec22c2d66a09e3574eac045b00b5af03", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -25,10 +25,10 @@ type reader =\n         fn get_byte_pos() -> uint;\n         fn get_col() -> uint;\n         fn get_filemap() -> codemap::filemap;\n-        fn err(&str);\n+        fn err(str);\n     };\n \n-fn new_reader(cm: &codemap::codemap, src: &str, filemap: codemap::filemap,\n+fn new_reader(cm: codemap::codemap, src: str, filemap: codemap::filemap,\n               itr: @interner::interner<str>) -> reader {\n     obj reader(cm: codemap::codemap,\n                src: str,\n@@ -77,7 +77,7 @@ fn new_reader(cm: &codemap::codemap, src: &str, filemap: codemap::filemap,\n         fn get_interner() -> @interner::interner<str> { ret itr; }\n         fn get_col() -> uint { ret col; }\n         fn get_filemap() -> codemap::filemap { ret fm; }\n-        fn err(m: &str) {\n+        fn err(m: str) {\n             codemap::emit_error(some(ast_util::mk_sp(chpos, chpos)), m, cm);\n         }\n     }\n@@ -123,12 +123,12 @@ fn is_hex_digit(c: char) -> bool {\n \n fn is_bin_digit(c: char) -> bool { ret c == '0' || c == '1'; }\n \n-fn consume_whitespace_and_comments(rdr: &reader) {\n+fn consume_whitespace_and_comments(rdr: reader) {\n     while is_whitespace(rdr.curr()) { rdr.bump(); }\n     be consume_any_line_comment(rdr);\n }\n \n-fn consume_any_line_comment(rdr: &reader) {\n+fn consume_any_line_comment(rdr: reader) {\n     if rdr.curr() == '/' {\n         alt rdr.next() {\n           '/' {\n@@ -143,7 +143,7 @@ fn consume_any_line_comment(rdr: &reader) {\n     }\n }\n \n-fn consume_block_comment(rdr: &reader) {\n+fn consume_block_comment(rdr: reader) {\n     let level: int = 1;\n     while level > 0 {\n         if rdr.is_eof() { rdr.err(\"unterminated block comment\"); fail; }\n@@ -164,13 +164,13 @@ fn consume_block_comment(rdr: &reader) {\n     be consume_whitespace_and_comments(rdr);\n }\n \n-fn digits_to_string(s: &str) -> int {\n+fn digits_to_string(s: str) -> int {\n     let accum_int: int = 0;\n     for c: u8 in s { accum_int *= 10; accum_int += dec_digit_val(c as char); }\n     ret accum_int;\n }\n \n-fn scan_exponent(rdr: &reader) -> option::t<str> {\n+fn scan_exponent(rdr: reader) -> option::t<str> {\n     let c = rdr.curr();\n     let rslt = \"\";\n     if c == 'e' || c == 'E' {\n@@ -188,7 +188,7 @@ fn scan_exponent(rdr: &reader) -> option::t<str> {\n     } else { ret none::<str>; }\n }\n \n-fn scan_dec_digits(rdr: &reader) -> str {\n+fn scan_dec_digits(rdr: reader) -> str {\n     let c = rdr.curr();\n     let rslt: str = \"\";\n     while is_dec_digit(c) || c == '_' {\n@@ -199,7 +199,7 @@ fn scan_dec_digits(rdr: &reader) -> str {\n     ret rslt;\n }\n \n-fn scan_number(c: char, rdr: &reader) -> token::token {\n+fn scan_number(c: char, rdr: reader) -> token::token {\n     let accum_int = 0;\n     let dec_str: str = \"\";\n     let is_dec_integer: bool = false;\n@@ -312,7 +312,7 @@ fn scan_number(c: char, rdr: &reader) -> token::token {\n     }\n }\n \n-fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n+fn scan_numeric_escape(rdr: reader, n_hex_digits: uint) -> char {\n     let accum_int = 0;\n     while n_hex_digits != 0u {\n         let n = rdr.curr();\n@@ -328,15 +328,15 @@ fn scan_numeric_escape(rdr: &reader, n_hex_digits: uint) -> char {\n     ret accum_int as char;\n }\n \n-fn next_token(rdr: &reader) -> {tok: token::token, chpos: uint, bpos: uint} {\n+fn next_token(rdr: reader) -> {tok: token::token, chpos: uint, bpos: uint} {\n     consume_whitespace_and_comments(rdr);\n     let start_chpos = rdr.get_chpos();\n     let start_bpos = rdr.get_byte_pos();\n     let tok = if rdr.is_eof() { token::EOF } else { next_token_inner(rdr) };\n     ret {tok: tok, chpos: start_chpos, bpos: start_bpos};\n }\n \n-fn next_token_inner(rdr: &reader) -> token::token {\n+fn next_token_inner(rdr: reader) -> token::token {\n     let accum_str = \"\";\n     let c = rdr.curr();\n     if is_alpha(c) || c == '_' {\n@@ -351,7 +351,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n                                                  accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) { ret scan_number(c, rdr); }\n-    fn binop(rdr: &reader, op: token::binop) -> token::token {\n+    fn binop(rdr: reader, op: token::binop) -> token::token {\n         rdr.bump();\n         if rdr.curr() == '=' {\n             rdr.bump();\n@@ -362,6 +362,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n \n \n \n+\n       // One-byte tokens.\n       '?' {\n         rdr.bump();\n@@ -402,6 +403,7 @@ fn next_token_inner(rdr: &reader) -> token::token {\n \n \n \n+\n       // Multi-byte tokens.\n       '=' {\n         rdr.bump();\n@@ -551,7 +553,7 @@ tag cmnt_style {\n \n type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n \n-fn read_to_eol(rdr: &reader) -> str {\n+fn read_to_eol(rdr: reader) -> str {\n     let val = \"\";\n     while rdr.curr() != '\\n' && !rdr.is_eof() {\n         str::push_char(val, rdr.curr());\n@@ -561,29 +563,29 @@ fn read_to_eol(rdr: &reader) -> str {\n     ret val;\n }\n \n-fn read_one_line_comment(rdr: &reader) -> str {\n+fn read_one_line_comment(rdr: reader) -> str {\n     let val = read_to_eol(rdr);\n     assert (val[0] == '/' as u8 && val[1] == '/' as u8);\n     ret val;\n }\n \n-fn consume_whitespace(rdr: &reader) {\n+fn consume_whitespace(rdr: reader) {\n     while is_whitespace(rdr.curr()) && !rdr.is_eof() { rdr.bump(); }\n }\n \n-fn consume_non_eol_whitespace(rdr: &reader) {\n+fn consume_non_eol_whitespace(rdr: reader) {\n     while is_whitespace(rdr.curr()) && rdr.curr() != '\\n' && !rdr.is_eof() {\n         rdr.bump();\n     }\n }\n \n-fn push_blank_line_comment(rdr: &reader, comments: &mutable [cmnt]) {\n+fn push_blank_line_comment(rdr: reader, comments: &mutable [cmnt]) {\n     log \">>> blank-line comment\";\n     let v: [str] = [];\n     comments += [{style: blank_line, lines: v, pos: rdr.get_chpos()}];\n }\n \n-fn consume_whitespace_counting_blank_lines(rdr: &reader,\n+fn consume_whitespace_counting_blank_lines(rdr: reader,\n                                            comments: &mutable [cmnt]) {\n     while is_whitespace(rdr.curr()) && !rdr.is_eof() {\n         if rdr.get_col() == 0u && rdr.curr() == '\\n' {\n@@ -593,7 +595,7 @@ fn consume_whitespace_counting_blank_lines(rdr: &reader,\n     }\n }\n \n-fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n+fn read_line_comments(rdr: reader, code_to_the_left: bool) -> cmnt {\n     log \">>> line comments\";\n     let p = rdr.get_chpos();\n     let lines: [str] = [];\n@@ -609,13 +611,13 @@ fn read_line_comments(rdr: &reader, code_to_the_left: bool) -> cmnt {\n          pos: p};\n }\n \n-fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n+fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n     let i: uint = begin;\n     while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n     ret true;\n }\n \n-fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: &str,\n+fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: str,\n                                         col: uint) {\n     let s1;\n     if all_whitespace(s, 0u, col) {\n@@ -627,7 +629,7 @@ fn trim_whitespace_prefix_and_push_line(lines: &mutable [str], s: &str,\n     lines += [s1];\n }\n \n-fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n+fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n     log \">>> block comment\";\n     let p = rdr.get_chpos();\n     let lines: [str] = [];\n@@ -672,12 +674,12 @@ fn read_block_comment(rdr: &reader, code_to_the_left: bool) -> cmnt {\n     ret {style: style, lines: lines, pos: p};\n }\n \n-fn peeking_at_comment(rdr: &reader) -> bool {\n+fn peeking_at_comment(rdr: reader) -> bool {\n     ret rdr.curr() == '/' && rdr.next() == '/' ||\n             rdr.curr() == '/' && rdr.next() == '*';\n }\n \n-fn consume_comment(rdr: &reader, code_to_the_left: bool,\n+fn consume_comment(rdr: reader, code_to_the_left: bool,\n                    comments: &mutable [cmnt]) {\n     log \">>> consume comment\";\n     if rdr.curr() == '/' && rdr.next() == '/' {\n@@ -688,7 +690,7 @@ fn consume_comment(rdr: &reader, code_to_the_left: bool,\n     log \"<<< consume comment\";\n }\n \n-fn is_lit(t: &token::token) -> bool {\n+fn is_lit(t: token::token) -> bool {\n     ret alt t {\n           token::LIT_INT(_) { true }\n           token::LIT_UINT(_) { true }\n@@ -704,7 +706,7 @@ fn is_lit(t: &token::token) -> bool {\n \n type lit = {lit: str, pos: uint};\n \n-fn gather_comments_and_literals(cm: &codemap::codemap, path: &str,\n+fn gather_comments_and_literals(cm: codemap::codemap, path: str,\n                                 srdr: io::reader) ->\n    {cmnts: [cmnt], lits: [lit]} {\n     let src = str::unsafe_from_bytes(srdr.read_whole_stream());"}, {"sha": "3d115197794a5f34cdc2046877ecba6020ede991", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 168, "deletions": 161, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -25,7 +25,7 @@ tag ty_or_bang { a_ty(@ast::ty); a_bang; }\n \n type parse_sess = @{cm: codemap::codemap, mutable next_id: node_id};\n \n-fn next_node_id(sess: &parse_sess) -> node_id {\n+fn next_node_id(sess: parse_sess) -> node_id {\n     let rv = sess.next_id;\n     sess.next_id += 1;\n     ret rv;\n@@ -37,8 +37,8 @@ type parser =\n         fn bump();\n         fn swap(token::token, uint, uint);\n         fn look_ahead(uint) -> token::token;\n-        fn fatal(&str) -> ! ;\n-        fn warn(&str);\n+        fn fatal(str) -> ! ;\n+        fn warn(str);\n         fn restrict(restriction);\n         fn get_restriction() -> restriction;\n         fn get_file_type() -> file_type;\n@@ -59,7 +59,7 @@ type parser =\n         fn get_sess() -> parse_sess;\n     };\n \n-fn new_parser_from_file(sess: parse_sess, cfg: &ast::crate_cfg, path: &str,\n+fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: str,\n                         chpos: uint, byte_pos: uint, ftype: file_type) ->\n    parser {\n     let src = io::read_whole_file_str(path);\n@@ -70,7 +70,7 @@ fn new_parser_from_file(sess: parse_sess, cfg: &ast::crate_cfg, path: &str,\n     ret new_parser(sess, cfg, rdr, ftype);\n }\n \n-fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n+fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n               ftype: file_type) -> parser {\n     obj stdio_parser(sess: parse_sess,\n                      cfg: ast::crate_cfg,\n@@ -108,11 +108,11 @@ fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n             }\n             ret buffer[distance - 1u].tok;\n         }\n-        fn fatal(m: &str) -> ! {\n+        fn fatal(m: str) -> ! {\n             codemap::emit_error(some(self.get_span()), m, sess.cm);\n             fail;\n         }\n-        fn warn(m: &str) {\n+        fn warn(m: str) {\n             codemap::emit_warning(some(self.get_span()), m, sess.cm);\n         }\n         fn restrict(r: restriction) { restr = r; }\n@@ -185,13 +185,13 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n     ret words;\n }\n \n-fn unexpected(p: &parser, t: token::token) -> ! {\n+fn unexpected(p: parser, t: token::token) -> ! {\n     let s: str = \"unexpected token: \";\n     s += token::to_str(p.get_reader(), t);\n     p.fatal(s);\n }\n \n-fn expect(p: &parser, t: token::token) {\n+fn expect(p: parser, t: token::token) {\n     if p.peek() == t {\n         p.bump();\n     } else {\n@@ -203,7 +203,7 @@ fn expect(p: &parser, t: token::token) {\n     }\n }\n \n-fn expect_gt(p: &parser) {\n+fn expect_gt(p: parser) {\n     if p.peek() == token::GT {\n         p.bump();\n     } else if p.peek() == token::BINOP(token::LSR) {\n@@ -219,34 +219,34 @@ fn expect_gt(p: &parser) {\n     }\n }\n \n-fn spanned<@T>(lo: uint, hi: uint, node: &T) -> spanned<T> {\n+fn spanned<@T>(lo: uint, hi: uint, node: T) -> spanned<T> {\n     ret {node: node, span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_ident(p: &parser) -> ast::ident {\n+fn parse_ident(p: parser) -> ast::ident {\n     alt p.peek() {\n       token::IDENT(i, _) { p.bump(); ret p.get_str(i); }\n       _ { p.fatal(\"expecting ident\"); }\n     }\n }\n \n-fn parse_value_ident(p: &parser) -> ast::ident {\n+fn parse_value_ident(p: parser) -> ast::ident {\n     check_bad_word(p);\n     ret parse_ident(p);\n }\n \n-fn eat(p: &parser, tok: &token::token) -> bool {\n+fn eat(p: parser, tok: token::token) -> bool {\n     ret if p.peek() == tok { p.bump(); true } else { false };\n }\n \n-fn is_word(p: &parser, word: &str) -> bool {\n+fn is_word(p: parser, word: str) -> bool {\n     ret alt p.peek() {\n           token::IDENT(sid, false) { str::eq(word, p.get_str(sid)) }\n           _ { false }\n         };\n }\n \n-fn eat_word(p: &parser, word: &str) -> bool {\n+fn eat_word(p: parser, word: str) -> bool {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         if str::eq(word, p.get_str(sid)) {\n@@ -258,14 +258,14 @@ fn eat_word(p: &parser, word: &str) -> bool {\n     }\n }\n \n-fn expect_word(p: &parser, word: &str) {\n+fn expect_word(p: parser, word: str) {\n     if !eat_word(p, word) {\n         p.fatal(\"expecting \" + word + \", found \" +\n                     token::to_str(p.get_reader(), p.peek()));\n     }\n }\n \n-fn check_bad_word(p: &parser) {\n+fn check_bad_word(p: parser) {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         let w = p.get_str(sid);\n@@ -277,15 +277,16 @@ fn check_bad_word(p: &parser) {\n     }\n }\n \n-fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n-    fn parse_fn_input_ty(p: &parser) -> ast::ty_arg {\n+fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n+    fn parse_fn_input_ty(p: parser) -> ast::ty_arg {\n         let lo = p.get_lo_pos();\n+        let mode = parse_arg_mode(p);\n         // Ignore arg name, if present\n         if is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n             p.bump();\n             p.bump();\n         }\n-        let mode = parse_arg_mode(p);\n+        if mode == ast::by_ref { mode = parse_arg_mode(p); }\n         let t = parse_ty(p, false);\n         ret spanned(lo, t.span.hi, {mode: mode, ty: t});\n     }\n@@ -312,7 +313,7 @@ fn parse_ty_fn(proto: ast::proto, p: &parser) -> ast::ty_ {\n     ret ast::ty_fn(proto, inputs.node, output, cf, constrs);\n }\n \n-fn parse_proto(p: &parser) -> ast::proto {\n+fn parse_proto(p: parser) -> ast::proto {\n     if eat_word(p, \"iter\") {\n         ret ast::proto_iter;\n     } else if eat_word(p, \"fn\") {\n@@ -322,8 +323,8 @@ fn parse_proto(p: &parser) -> ast::proto {\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_ty_obj(p: &parser, hi: &mutable uint) -> ast::ty_ {\n-    fn parse_method_sig(p: &parser) -> ast::ty_method {\n+fn parse_ty_obj(p: parser, hi: &mutable uint) -> ast::ty_ {\n+    fn parse_method_sig(p: parser) -> ast::ty_method {\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_proto(p);\n         let ident = parse_value_ident(p);\n@@ -347,13 +348,13 @@ fn parse_ty_obj(p: &parser, hi: &mutable uint) -> ast::ty_ {\n     ret ast::ty_obj(meths.node);\n }\n \n-fn parse_mt(p: &parser) -> ast::mt {\n+fn parse_mt(p: parser) -> ast::mt {\n     let mut = parse_mutability(p);\n     let t = parse_ty(p, false);\n     ret {ty: t, mut: mut};\n }\n \n-fn parse_ty_field(p: &parser) -> ast::ty_field {\n+fn parse_ty_field(p: parser) -> ast::ty_field {\n     let lo = p.get_lo_pos();\n     let mut = parse_mutability(p);\n     let id = parse_ident(p);\n@@ -364,13 +365,13 @@ fn parse_ty_field(p: &parser) -> ast::ty_field {\n \n // if i is the jth ident in args, return j\n // otherwise, fail\n-fn ident_index(p: &parser, args: &[ast::arg], i: &ast::ident) -> uint {\n+fn ident_index(p: parser, args: [ast::arg], i: ast::ident) -> uint {\n     let j = 0u;\n     for a: ast::arg in args { if a.ident == i { ret j; } j += 1u; }\n     p.fatal(\"Unbound variable \" + i + \" in constraint arg\");\n }\n \n-fn parse_type_constr_arg(p: &parser) -> @ast::ty_constr_arg {\n+fn parse_type_constr_arg(p: parser) -> @ast::ty_constr_arg {\n     let sp = p.get_span();\n     let carg = ast::carg_base;\n     expect(p, token::BINOP(token::STAR));\n@@ -384,7 +385,7 @@ fn parse_type_constr_arg(p: &parser) -> @ast::ty_constr_arg {\n     ret @{node: carg, span: sp};\n }\n \n-fn parse_constr_arg(args: &[ast::arg], p: &parser) -> @ast::constr_arg {\n+fn parse_constr_arg(args: [ast::arg], p: parser) -> @ast::constr_arg {\n     let sp = p.get_span();\n     let carg = ast::carg_base;\n     if p.peek() == token::BINOP(token::STAR) {\n@@ -396,7 +397,7 @@ fn parse_constr_arg(args: &[ast::arg], p: &parser) -> @ast::constr_arg {\n     ret @{node: carg, span: sp};\n }\n \n-fn parse_ty_constr(fn_args: &[ast::arg], p: &parser) -> @ast::constr {\n+fn parse_ty_constr(fn_args: [ast::arg], p: parser) -> @ast::constr {\n     let lo = p.get_lo_pos();\n     let path = parse_path(p);\n     let pf = bind parse_constr_arg(fn_args, _);\n@@ -406,7 +407,7 @@ fn parse_ty_constr(fn_args: &[ast::arg], p: &parser) -> @ast::constr {\n                  {path: path, args: args.node, id: p.get_id()});\n }\n \n-fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n+fn parse_constr_in_type(p: parser) -> @ast::ty_constr {\n     let lo = p.get_lo_pos();\n     let path = parse_path(p);\n     let args: [@ast::ty_constr_arg] =\n@@ -418,8 +419,8 @@ fn parse_constr_in_type(p: &parser) -> @ast::ty_constr {\n }\n \n \n-fn parse_constrs<T>(pser: fn(&parser) -> @ast::constr_general<T>, p: &parser)\n-   -> [@ast::constr_general<T>] {\n+fn parse_constrs<T>(pser: fn(parser) -> @ast::constr_general<T>, p: parser) ->\n+   [@ast::constr_general<T>] {\n     let constrs: [@ast::constr_general<T>] = [];\n     while true {\n         let constr = pser(p);\n@@ -429,11 +430,11 @@ fn parse_constrs<T>(pser: fn(&parser) -> @ast::constr_general<T>, p: &parser)\n     constrs\n }\n \n-fn parse_type_constraints(p: &parser) -> [@ast::ty_constr] {\n+fn parse_type_constraints(p: parser) -> [@ast::ty_constr] {\n     ret parse_constrs(parse_constr_in_type, p);\n }\n \n-fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n+fn parse_ty_postfix(orig_t: ast::ty_, p: parser, colons_before_params: bool)\n    -> @ast::ty {\n     let lo = p.get_lo_pos();\n \n@@ -460,14 +461,14 @@ fn parse_ty_postfix(orig_t: ast::ty_, p: &parser, colons_before_params: bool)\n     }\n }\n \n-fn parse_ty_or_bang(p: &parser) -> ty_or_bang {\n+fn parse_ty_or_bang(p: parser) -> ty_or_bang {\n     alt p.peek() {\n       token::NOT. { p.bump(); ret a_bang; }\n       _ { ret a_ty(parse_ty(p, false)); }\n     }\n }\n \n-fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n+fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     let lo = p.get_lo_pos();\n     let hi = lo;\n     let t: ast::ty_;\n@@ -578,33 +579,35 @@ fn parse_ty(p: &parser, colons_before_params: bool) -> @ast::ty {\n     ret parse_ty_postfix(t, p, colons_before_params);\n }\n \n-fn parse_arg_mode(p: &parser) -> ast::mode {\n-    let mode = ast::by_ref;\n+fn parse_arg_mode(p: parser) -> ast::mode {\n     if eat(p, token::BINOP(token::AND)) {\n-        if eat_word(p, \"mutable\") { mode = ast::by_mut_ref; }\n+        eat_word(p, \"mutable\");\n+        ret ast::by_mut_ref;\n     } else if eat(p, token::BINOP(token::MINUS)) {\n-        mode = ast::by_move;\n+        ret ast::by_move;\n+    } else {\n+        ret ast::by_ref;\n     }\n-    ret mode;\n }\n \n-fn parse_arg(p: &parser) -> ast::arg {\n+fn parse_arg(p: parser) -> ast::arg {\n+    let m = parse_arg_mode(p);\n     let i = parse_value_ident(p);\n     expect(p, token::COLON);\n-    let m = parse_arg_mode(p);\n+    if m == ast::by_ref { m = parse_arg_mode(p); }\n     let t = parse_ty(p, false);\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_fn_block_arg(p: &parser) -> ast::arg {\n+fn parse_fn_block_arg(p: parser) -> ast::arg {\n     let m = parse_arg_mode(p);\n     let i = parse_value_ident(p);\n     let t = @spanned(p.get_lo_pos(), p.get_hi_pos(), ast::ty_infer);\n     ret {mode: m, ty: t, ident: i, id: p.get_id()};\n }\n \n-fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n-                             f: fn(&parser) -> T, p: &parser) -> [T] {\n+fn parse_seq_to_before_gt<T>(sep: option::t<token::token>, f: fn(parser) -> T,\n+                             p: parser) -> [T] {\n     let first = true;\n     let v = [];\n     while p.peek() != token::GT && p.peek() != token::BINOP(token::LSR) &&\n@@ -619,16 +622,16 @@ fn parse_seq_to_before_gt<T>(sep: option::t<token::token>,\n     ret v;\n }\n \n-fn parse_seq_to_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n-                      p: &parser) -> [T] {\n+fn parse_seq_to_gt<T>(sep: option::t<token::token>, f: fn(parser) -> T,\n+                      p: parser) -> [T] {\n     let v = parse_seq_to_before_gt(sep, f, p);\n     expect_gt(p);\n \n     ret v;\n }\n \n-fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n-                      p: &parser) -> spanned<[T]> {\n+fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn(parser) -> T,\n+                      p: parser) -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, token::LT);\n     let result = parse_seq_to_before_gt::<T>(sep, f, p);\n@@ -638,14 +641,14 @@ fn parse_seq_lt_gt<T>(sep: option::t<token::token>, f: fn(&parser) -> T,\n }\n \n fn parse_seq_to_end<T>(ket: token::token, sep: option::t<token::token>,\n-                       f: fn(&parser) -> T, p: &parser) -> [T] {\n+                       f: fn(parser) -> T, p: parser) -> [T] {\n     let val = parse_seq_to_before_end(ket, sep, f, p);\n     p.bump();\n     ret val;\n }\n \n fn parse_seq_to_before_end<T>(ket: token::token, sep: option::t<token::token>,\n-                              f: fn(&parser) -> T, p: &parser) -> [T] {\n+                              f: fn(parser) -> T, p: parser) -> [T] {\n     let first: bool = true;\n     let v: [T] = [];\n     while p.peek() != ket {\n@@ -660,7 +663,7 @@ fn parse_seq_to_before_end<T>(ket: token::token, sep: option::t<token::token>,\n \n \n fn parse_seq<T>(bra: token::token, ket: token::token,\n-                sep: option::t<token::token>, f: fn(&parser) -> T, p: &parser)\n+                sep: option::t<token::token>, f: fn(parser) -> T, p: parser)\n    -> spanned<[T]> {\n     let lo = p.get_lo_pos();\n     expect(p, bra);\n@@ -671,7 +674,7 @@ fn parse_seq<T>(bra: token::token, ket: token::token,\n }\n \n \n-fn parse_lit(p: &parser) -> ast::lit {\n+fn parse_lit(p: parser) -> ast::lit {\n     let sp = p.get_span();\n     let lit: ast::lit_ = ast::lit_nil;\n     if eat_word(p, \"true\") {\n@@ -712,11 +715,11 @@ fn is_ident(t: token::token) -> bool {\n     ret false;\n }\n \n-fn is_plain_ident(p: &parser) -> bool {\n+fn is_plain_ident(p: parser) -> bool {\n     ret alt p.peek() { token::IDENT(_, false) { true } _ { false } };\n }\n \n-fn parse_path(p: &parser) -> ast::path {\n+fn parse_path(p: parser) -> ast::path {\n     let lo = p.get_lo_pos();\n     let hi = lo;\n \n@@ -744,7 +747,7 @@ fn parse_path(p: &parser) -> ast::path {\n     ret spanned(lo, hi, {global: global, idents: ids, types: []});\n }\n \n-fn parse_path_and_ty_param_substs(p: &parser) -> ast::path {\n+fn parse_path_and_ty_param_substs(p: parser) -> ast::path {\n     let lo = p.get_lo_pos();\n     let path = parse_path(p);\n     if p.peek() == token::MOD_SEP {\n@@ -762,15 +765,15 @@ fn parse_path_and_ty_param_substs(p: &parser) -> ast::path {\n     ret path;\n }\n \n-fn parse_mutability(p: &parser) -> ast::mutability {\n+fn parse_mutability(p: parser) -> ast::mutability {\n     if eat_word(p, \"mutable\") {\n         if p.peek() == token::QUES { p.bump(); ret ast::maybe_mut; }\n         ret ast::mut;\n     }\n     ret ast::imm;\n }\n \n-fn parse_field(p: &parser, sep: &token::token) -> ast::field {\n+fn parse_field(p: parser, sep: token::token) -> ast::field {\n     let lo = p.get_lo_pos();\n     let m = parse_mutability(p);\n     let i = parse_ident(p);\n@@ -779,17 +782,17 @@ fn parse_field(p: &parser, sep: &token::token) -> ast::field {\n     ret spanned(lo, e.span.hi, {mut: m, ident: i, expr: e});\n }\n \n-fn mk_expr(p: &parser, lo: uint, hi: uint, node: &ast::expr_) -> @ast::expr {\n+fn mk_expr(p: parser, lo: uint, hi: uint, node: ast::expr_) -> @ast::expr {\n     ret @{id: p.get_id(), node: node, span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn mk_mac_expr(p: &parser, lo: uint, hi: uint, m: &ast::mac_) -> @ast::expr {\n+fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: ast::mac_) -> @ast::expr {\n     ret @{id: p.get_id(),\n           node: ast::expr_mac({node: m, span: ast_util::mk_sp(lo, hi)}),\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_bottom_expr(p: &parser) -> @ast::expr {\n+fn parse_bottom_expr(p: parser) -> @ast::expr {\n     let lo = p.get_lo_pos();\n     let hi = p.get_hi_pos();\n \n@@ -908,7 +911,7 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n         ex = ast::expr_anon_obj(ob);\n     } else if eat_word(p, \"bind\") {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n-        fn parse_expr_opt(p: &parser) -> option::t<@ast::expr> {\n+        fn parse_expr_opt(p: parser) -> option::t<@ast::expr> {\n             alt p.peek() {\n               token::UNDERSCORE. { p.bump(); ret none; }\n               _ { ret some(parse_expr(p)); }\n@@ -1014,13 +1017,13 @@ fn parse_bottom_expr(p: &parser) -> @ast::expr {\n     ret mk_expr(p, lo, hi, ex);\n }\n \n-fn parse_syntax_ext(p: &parser) -> @ast::expr {\n+fn parse_syntax_ext(p: parser) -> @ast::expr {\n     let lo = p.get_lo_pos();\n     expect(p, token::POUND);\n     ret parse_syntax_ext_naked(p, lo);\n }\n \n-fn parse_syntax_ext_naked(p: &parser, lo: uint) -> @ast::expr {\n+fn parse_syntax_ext_naked(p: parser, lo: uint) -> @ast::expr {\n     let pth = parse_path(p);\n     if vec::len(pth.node.idents) == 0u {\n         p.fatal(\"expected a syntax expander name\");\n@@ -1039,17 +1042,17 @@ fn parse_syntax_ext_naked(p: &parser, lo: uint) -> @ast::expr {\n     ret mk_mac_expr(p, lo, hi, ast::mac_invoc(pth, e, none));\n }\n \n-fn parse_self_method(p: &parser) -> @ast::expr {\n+fn parse_self_method(p: parser) -> @ast::expr {\n     let sp = p.get_span();\n     let f_name: ast::ident = parse_ident(p);\n     ret mk_expr(p, sp.lo, sp.hi, ast::expr_self_method(f_name));\n }\n \n-fn parse_dot_or_call_expr(p: &parser) -> @ast::expr {\n+fn parse_dot_or_call_expr(p: parser) -> @ast::expr {\n     ret parse_dot_or_call_expr_with(p, parse_bottom_expr(p));\n }\n \n-fn parse_dot_or_call_expr_with(p: &parser, e: @ast::expr) -> @ast::expr {\n+fn parse_dot_or_call_expr_with(p: parser, e: @ast::expr) -> @ast::expr {\n     let lo = e.span.lo;\n     let hi = e.span.hi;\n     while true {\n@@ -1092,7 +1095,7 @@ fn parse_dot_or_call_expr_with(p: &parser, e: @ast::expr) -> @ast::expr {\n     ret e;\n }\n \n-fn parse_prefix_expr(p: &parser) -> @ast::expr {\n+fn parse_prefix_expr(p: parser) -> @ast::expr {\n     if eat_word(p, \"mutable\") {\n         p.warn(\"ignoring deprecated 'mutable' prefix operator\");\n     }\n@@ -1136,7 +1139,7 @@ fn parse_prefix_expr(p: &parser) -> @ast::expr {\n     ret mk_expr(p, lo, hi, ex);\n }\n \n-fn parse_ternary(p: &parser) -> @ast::expr {\n+fn parse_ternary(p: parser) -> @ast::expr {\n     let cond_expr = parse_binops(p);\n     if p.peek() == token::QUES {\n         p.bump();\n@@ -1175,7 +1178,7 @@ fn prec_table() -> @[op_spec] {\n           {tok: token::OROR, op: ast::or, prec: 1}];\n }\n \n-fn parse_binops(p: &parser) -> @ast::expr {\n+fn parse_binops(p: parser) -> @ast::expr {\n     ret parse_more_binops(p, parse_prefix_expr(p), 0);\n }\n \n@@ -1184,7 +1187,7 @@ const unop_prec: int = 100;\n const as_prec: int = 5;\n const ternary_prec: int = 0;\n \n-fn parse_more_binops(p: &parser, lhs: @ast::expr, min_prec: int) ->\n+fn parse_more_binops(p: parser, lhs: @ast::expr, min_prec: int) ->\n    @ast::expr {\n     let peeked = p.peek();\n     for cur: op_spec in *p.get_prec_table() {\n@@ -1206,7 +1209,7 @@ fn parse_more_binops(p: &parser, lhs: @ast::expr, min_prec: int) ->\n     ret lhs;\n }\n \n-fn parse_assign_expr(p: &parser) -> @ast::expr {\n+fn parse_assign_expr(p: parser) -> @ast::expr {\n     let lo = p.get_lo_pos();\n     let lhs = parse_ternary(p);\n     alt p.peek() {\n@@ -1249,7 +1252,7 @@ fn parse_assign_expr(p: &parser) -> @ast::expr {\n     ret lhs;\n }\n \n-fn parse_if_expr_1(p: &parser) ->\n+fn parse_if_expr_1(p: parser) ->\n    {cond: @ast::expr,\n     then: ast::blk,\n     els: option::t<@ast::expr>,\n@@ -1268,7 +1271,7 @@ fn parse_if_expr_1(p: &parser) ->\n     ret {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n }\n \n-fn parse_if_expr(p: &parser) -> @ast::expr {\n+fn parse_if_expr(p: parser) -> @ast::expr {\n     if eat_word(p, \"check\") {\n         let q = parse_if_expr_1(p);\n         ret mk_expr(p, q.lo, q.hi, ast::expr_if_check(q.cond, q.then, q.els));\n@@ -1278,23 +1281,23 @@ fn parse_if_expr(p: &parser) -> @ast::expr {\n     }\n }\n \n-fn parse_fn_expr(p: &parser, proto: ast::proto) -> @ast::expr {\n+fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let decl = parse_fn_decl(p, ast::impure_fn, ast::il_normal);\n     let body = parse_block(p);\n     let _fn = {decl: decl, proto: proto, body: body};\n     ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n }\n \n-fn parse_fn_block_expr(p: &parser) -> @ast::expr {\n+fn parse_fn_block_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let decl = parse_fn_block_decl(p);\n     let body = parse_block_tail(p, lo, ast::checked);\n     let _fn = {decl: decl, proto: ast::proto_block, body: body};\n     ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn));\n }\n \n-fn parse_else_expr(p: &parser) -> @ast::expr {\n+fn parse_else_expr(p: parser) -> @ast::expr {\n     if eat_word(p, \"if\") {\n         ret parse_if_expr(p);\n     } else {\n@@ -1303,7 +1306,7 @@ fn parse_else_expr(p: &parser) -> @ast::expr {\n     }\n }\n \n-fn parse_for_expr(p: &parser) -> @ast::expr {\n+fn parse_for_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let is_each = eat_word(p, \"each\");\n     let decl = parse_local(p, false);\n@@ -1316,15 +1319,15 @@ fn parse_for_expr(p: &parser) -> @ast::expr {\n     } else { ret mk_expr(p, lo, hi, ast::expr_for(decl, seq, body)); }\n }\n \n-fn parse_while_expr(p: &parser) -> @ast::expr {\n+fn parse_while_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let cond = parse_expr(p);\n     let body = parse_block(p);\n     let hi = body.span.hi;\n     ret mk_expr(p, lo, hi, ast::expr_while(cond, body));\n }\n \n-fn parse_do_while_expr(p: &parser) -> @ast::expr {\n+fn parse_do_while_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let body = parse_block(p);\n     expect_word(p, \"while\");\n@@ -1333,7 +1336,7 @@ fn parse_do_while_expr(p: &parser) -> @ast::expr {\n     ret mk_expr(p, lo, hi, ast::expr_do_while(body, cond));\n }\n \n-fn parse_alt_expr(p: &parser) -> @ast::expr {\n+fn parse_alt_expr(p: parser) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let discriminant = parse_expr(p);\n     expect(p, token::LBRACE);\n@@ -1350,19 +1353,19 @@ fn parse_alt_expr(p: &parser) -> @ast::expr {\n     ret mk_expr(p, lo, hi, ast::expr_alt(discriminant, arms));\n }\n \n-fn parse_expr(p: &parser) -> @ast::expr {\n+fn parse_expr(p: parser) -> @ast::expr {\n     ret parse_expr_res(p, UNRESTRICTED);\n }\n \n-fn parse_expr_res(p: &parser, r: restriction) -> @ast::expr {\n+fn parse_expr_res(p: parser, r: restriction) -> @ast::expr {\n     let old = p.get_restriction();\n     p.restrict(r);\n     let e = parse_assign_expr(p);\n     p.restrict(old);\n     ret e;\n }\n \n-fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n+fn parse_initializer(p: parser) -> option::t<ast::initializer> {\n     alt p.peek() {\n       token::EQ. {\n         p.bump();\n@@ -1375,6 +1378,7 @@ fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n \n \n \n+\n       // Now that the the channel is the first argument to receive,\n       // combining it with an initializer doesn't really make sense.\n       // case (token::RECV) {\n@@ -1388,7 +1392,7 @@ fn parse_initializer(p: &parser) -> option::t<ast::initializer> {\n     }\n }\n \n-fn parse_pats(p: &parser) -> [@ast::pat] {\n+fn parse_pats(p: parser) -> [@ast::pat] {\n     let pats = [];\n     while true {\n         pats += [parse_pat(p)];\n@@ -1397,7 +1401,7 @@ fn parse_pats(p: &parser) -> [@ast::pat] {\n     ret pats;\n }\n \n-fn parse_pat(p: &parser) -> @ast::pat {\n+fn parse_pat(p: parser) -> @ast::pat {\n     let lo = p.get_lo_pos();\n     let hi = p.get_hi_pos();\n     let pat;\n@@ -1503,7 +1507,7 @@ fn parse_pat(p: &parser) -> @ast::pat {\n     ret @{id: p.get_id(), node: pat, span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n+fn parse_local(p: parser, allow_init: bool) -> @ast::local {\n     let lo = p.get_lo_pos();\n     let pat = parse_pat(p);\n     let ty = @spanned(lo, lo, ast::ty_infer);\n@@ -1513,7 +1517,7 @@ fn parse_local(p: &parser, allow_init: bool) -> @ast::local {\n                  {ty: ty, pat: pat, init: init, id: p.get_id()});\n }\n \n-fn parse_let(p: &parser) -> @ast::decl {\n+fn parse_let(p: parser) -> @ast::decl {\n     let lo = p.get_lo_pos();\n     let locals = [parse_local(p, true)];\n     while p.peek() == token::COMMA {\n@@ -1523,19 +1527,19 @@ fn parse_let(p: &parser) -> @ast::decl {\n     ret @spanned(lo, p.get_last_hi_pos(), ast::decl_local(locals));\n }\n \n-fn parse_stmt(p: &parser) -> @ast::stmt {\n+fn parse_stmt(p: parser) -> @ast::stmt {\n     if p.get_file_type() == SOURCE_FILE {\n         ret parse_source_stmt(p);\n     } else { ret parse_crate_stmt(p); }\n }\n \n-fn parse_crate_stmt(p: &parser) -> @ast::stmt {\n+fn parse_crate_stmt(p: parser) -> @ast::stmt {\n     let cdir = parse_crate_directive(p, []);\n     ret @spanned(cdir.span.lo, cdir.span.hi,\n                  ast::stmt_crate_directive(@cdir));\n }\n \n-fn parse_source_stmt(p: &parser) -> @ast::stmt {\n+fn parse_source_stmt(p: parser) -> @ast::stmt {\n     let lo = p.get_lo_pos();\n     if eat_word(p, \"let\") {\n         let decl = parse_let(p);\n@@ -1582,7 +1586,7 @@ fn stmt_to_expr(stmt: @ast::stmt) -> option::t<@ast::expr> {\n     ret alt stmt.node { ast::stmt_expr(e, _) { some(e) } _ { none } };\n }\n \n-fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n+fn stmt_ends_with_semi(stmt: ast::stmt) -> bool {\n     alt stmt.node {\n       ast::stmt_decl(d, _) {\n         ret alt d.node {\n@@ -1636,14 +1640,15 @@ fn stmt_ends_with_semi(stmt: &ast::stmt) -> bool {\n \n \n \n+\n       // We should not be calling this on a cdir.\n       ast::stmt_crate_directive(cdir) {\n         fail;\n       }\n     }\n }\n \n-fn parse_block(p: &parser) -> ast::blk {\n+fn parse_block(p: parser) -> ast::blk {\n     let lo = p.get_lo_pos();\n     if eat_word(p, \"unchecked\") {\n         be parse_block_tail(p, lo, ast::unchecked);\n@@ -1657,7 +1662,7 @@ fn parse_block(p: &parser) -> ast::blk {\n // I guess that also means \"already parsed the 'impure'\" if\n // necessary, and this should take a qualifier.\n // some blocks start with \"#{\"...\n-fn parse_block_tail(p: &parser, lo: uint, s: ast::check_mode) -> ast::blk {\n+fn parse_block_tail(p: parser, lo: uint, s: ast::check_mode) -> ast::blk {\n     let stmts: [@ast::stmt] = [];\n     let expr: option::t<@ast::expr> = none;\n     while p.peek() != token::RBRACE {\n@@ -1702,7 +1707,7 @@ fn parse_block_tail(p: &parser, lo: uint, s: ast::check_mode) -> ast::blk {\n     ret spanned(lo, hi, bloc);\n }\n \n-fn parse_ty_param(p: &parser) -> ast::ty_param {\n+fn parse_ty_param(p: parser) -> ast::ty_param {\n     let k =\n         alt p.peek() {\n           token::TILDE. { p.bump(); ast::kind_unique }\n@@ -1712,7 +1717,7 @@ fn parse_ty_param(p: &parser) -> ast::ty_param {\n     ret {ident: parse_ident(p), kind: k};\n }\n \n-fn parse_ty_params(p: &parser) -> [ast::ty_param] {\n+fn parse_ty_params(p: parser) -> [ast::ty_param] {\n     let ty_params: [ast::ty_param] = [];\n     if p.peek() == token::LT {\n         p.bump();\n@@ -1726,7 +1731,7 @@ fn parse_ty_params(p: &parser) -> [ast::ty_param] {\n     ret ty_params;\n }\n \n-fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness) ->\n+fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n    ast::fn_decl {\n     let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA), parse_arg,\n@@ -1766,7 +1771,7 @@ fn parse_fn_decl(p: &parser, purity: ast::purity, il: ast::inlineness) ->\n     }\n }\n \n-fn parse_fn_block_decl(p: &parser) -> ast::fn_decl {\n+fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n     let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::BINOP(token::OR), token::BINOP(token::OR),\n                   some(token::COMMA), parse_fn_block_arg, p);\n@@ -1778,30 +1783,30 @@ fn parse_fn_block_decl(p: &parser) -> ast::fn_decl {\n          constraints: []};\n }\n \n-fn parse_fn(p: &parser, proto: ast::proto, purity: ast::purity,\n+fn parse_fn(p: parser, proto: ast::proto, purity: ast::purity,\n             il: ast::inlineness) -> ast::_fn {\n     let decl = parse_fn_decl(p, purity, il);\n     let body = parse_block(p);\n     ret {decl: decl, proto: proto, body: body};\n }\n \n-fn parse_fn_header(p: &parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n+fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n     let id = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n     ret {ident: id, tps: ty_params};\n }\n \n-fn mk_item(p: &parser, lo: uint, hi: uint, ident: &ast::ident,\n-           node: &ast::item_, attrs: &[ast::attribute]) -> @ast::item {\n+fn mk_item(p: parser, lo: uint, hi: uint, ident: ast::ident, node: ast::item_,\n+           attrs: [ast::attribute]) -> @ast::item {\n     ret @{ident: ident,\n           attrs: attrs,\n           id: p.get_id(),\n           node: node,\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_item_fn_or_iter(p: &parser, purity: ast::purity, proto: ast::proto,\n-                         attrs: &[ast::attribute], il: ast::inlineness) ->\n+fn parse_item_fn_or_iter(p: parser, purity: ast::purity, proto: ast::proto,\n+                         attrs: [ast::attribute], il: ast::inlineness) ->\n    @ast::item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n@@ -1810,15 +1815,15 @@ fn parse_item_fn_or_iter(p: &parser, purity: ast::purity, proto: ast::proto,\n                 attrs);\n }\n \n-fn parse_obj_field(p: &parser) -> ast::obj_field {\n+fn parse_obj_field(p: parser) -> ast::obj_field {\n     let mut = parse_mutability(p);\n     let ident = parse_value_ident(p);\n     expect(p, token::COLON);\n     let ty = parse_ty(p, false);\n     ret {mut: mut, ty: ty, ident: ident, id: p.get_id()};\n }\n \n-fn parse_anon_obj_field(p: &parser) -> ast::anon_obj_field {\n+fn parse_anon_obj_field(p: parser) -> ast::anon_obj_field {\n     let mut = parse_mutability(p);\n     let ident = parse_value_ident(p);\n     expect(p, token::COLON);\n@@ -1828,7 +1833,7 @@ fn parse_anon_obj_field(p: &parser) -> ast::anon_obj_field {\n     ret {mut: mut, ty: ty, expr: expr, ident: ident, id: p.get_id()};\n }\n \n-fn parse_method(p: &parser) -> @ast::method {\n+fn parse_method(p: parser) -> @ast::method {\n     let lo = p.get_lo_pos();\n     let proto = parse_proto(p);\n     let ident = parse_value_ident(p);\n@@ -1837,7 +1842,7 @@ fn parse_method(p: &parser) -> @ast::method {\n     ret @spanned(lo, f.body.span.hi, meth);\n }\n \n-fn parse_item_obj(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n@@ -1854,7 +1859,7 @@ fn parse_item_obj(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n                 attrs);\n }\n \n-fn parse_item_res(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let ident = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n@@ -1866,10 +1871,7 @@ fn parse_item_res(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     let dtor = parse_block(p);\n     let decl =\n         {inputs:\n-             [{mode: ast::by_ref,\n-               ty: t,\n-               ident: arg_ident,\n-               id: p.get_id()}],\n+             [{mode: ast::by_ref, ty: t, ident: arg_ident, id: p.get_id()}],\n          output: @spanned(lo, lo, ast::ty_nil),\n          purity: ast::impure_fn,\n          il: ast::il_normal,\n@@ -1880,8 +1882,8 @@ fn parse_item_res(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n                 ast::item_res(f, p.get_id(), ty_params, p.get_id()), attrs);\n }\n \n-fn parse_mod_items(p: &parser, term: token::token,\n-                   first_item_attrs: &[ast::attribute]) -> ast::_mod {\n+fn parse_mod_items(p: parser, term: token::token,\n+                   first_item_attrs: [ast::attribute]) -> ast::_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n         if vec::len(first_item_attrs) == 0u { parse_view(p) } else { [] };\n@@ -1901,7 +1903,7 @@ fn parse_mod_items(p: &parser, term: token::token,\n     ret {view_items: view_items, items: items};\n }\n \n-fn parse_item_const(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_const(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_value_ident(p);\n     expect(p, token::COLON);\n@@ -1913,7 +1915,7 @@ fn parse_item_const(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_const(ty, e), attrs);\n }\n \n-fn parse_item_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n     expect(p, token::LBRACE);\n@@ -1925,7 +1927,7 @@ fn parse_item_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_mod(m), attrs + inner_attrs.inner);\n }\n \n-fn parse_item_native_type(p: &parser, attrs: &[ast::attribute]) ->\n+fn parse_item_native_type(p: parser, attrs: [ast::attribute]) ->\n    @ast::native_item {\n     let t = parse_type_decl(p);\n     let hi = p.get_hi_pos();\n@@ -1937,7 +1939,7 @@ fn parse_item_native_type(p: &parser, attrs: &[ast::attribute]) ->\n           span: ast_util::mk_sp(t.lo, hi)};\n }\n \n-fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n+fn parse_item_native_fn(p: parser, attrs: [ast::attribute]) ->\n    @ast::native_item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n@@ -1953,7 +1955,7 @@ fn parse_item_native_fn(p: &parser, attrs: &[ast::attribute]) ->\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->\n+fn parse_native_item(p: parser, attrs: [ast::attribute]) ->\n    @ast::native_item {\n     if eat_word(p, \"type\") {\n         ret parse_item_native_type(p, attrs);\n@@ -1962,8 +1964,8 @@ fn parse_native_item(p: &parser, attrs: &[ast::attribute]) ->\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n-                          first_item_attrs: &[ast::attribute]) ->\n+fn parse_native_mod_items(p: parser, native_name: str, abi: ast::native_abi,\n+                          first_item_attrs: [ast::attribute]) ->\n    ast::native_mod {\n     // Shouldn't be any view items since we've already parsed an item attr\n     let view_items =\n@@ -1983,7 +1985,7 @@ fn parse_native_mod_items(p: &parser, native_name: &str, abi: ast::native_abi,\n          items: items};\n }\n \n-fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_native_mod(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let abi = ast::native_abi_cdecl;\n     if !is_word(p, \"mod\") {\n@@ -2017,13 +2019,13 @@ fn parse_item_native_mod(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_native_mod(m), attrs + inner_attrs);\n }\n \n-fn parse_type_decl(p: &parser) -> {lo: uint, ident: ast::ident} {\n+fn parse_type_decl(p: parser) -> {lo: uint, ident: ast::ident} {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n     ret {lo: lo, ident: id};\n }\n \n-fn parse_item_type(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_type(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let t = parse_type_decl(p);\n     let tps = parse_ty_params(p);\n     expect(p, token::EQ);\n@@ -2033,7 +2035,7 @@ fn parse_item_type(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     ret mk_item(p, t.lo, hi, t.ident, ast::item_ty(ty, tps), attrs);\n }\n \n-fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n+fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let id = parse_ident(p);\n     let ty_params = parse_ty_params(p);\n@@ -2093,13 +2095,13 @@ fn parse_item_tag(p: &parser, attrs: &[ast::attribute]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_tag(variants, ty_params), attrs);\n }\n \n-fn parse_auth(p: &parser) -> ast::_auth {\n+fn parse_auth(p: parser) -> ast::_auth {\n     if eat_word(p, \"unsafe\") {\n         ret ast::auth_unsafe;\n     } else { unexpected(p, p.peek()); }\n }\n \n-fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t<@ast::item> {\n+fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n     } else if eat_word(p, \"inline\") {\n@@ -2138,7 +2140,7 @@ fn parse_item(p: &parser, attrs: &[ast::attribute]) -> option::t<@ast::item> {\n // extensions, which both begin with token.POUND\n type attr_or_ext = option::t<either::t<[ast::attribute], @ast::expr>>;\n \n-fn parse_outer_attrs_or_ext(p: &parser) -> attr_or_ext {\n+fn parse_outer_attrs_or_ext(p: parser) -> attr_or_ext {\n     if p.peek() == token::POUND {\n         let lo = p.get_lo_pos();\n         p.bump();\n@@ -2152,21 +2154,21 @@ fn parse_outer_attrs_or_ext(p: &parser) -> attr_or_ext {\n }\n \n // Parse attributes that appear before an item\n-fn parse_outer_attributes(p: &parser) -> [ast::attribute] {\n+fn parse_outer_attributes(p: parser) -> [ast::attribute] {\n     let attrs: [ast::attribute] = [];\n     while p.peek() == token::POUND {\n         attrs += [parse_attribute(p, ast::attr_outer)];\n     }\n     ret attrs;\n }\n \n-fn parse_attribute(p: &parser, style: ast::attr_style) -> ast::attribute {\n+fn parse_attribute(p: parser, style: ast::attr_style) -> ast::attribute {\n     let lo = p.get_lo_pos();\n     expect(p, token::POUND);\n     ret parse_attribute_naked(p, style, lo);\n }\n \n-fn parse_attribute_naked(p: &parser, style: ast::attr_style, lo: uint) ->\n+fn parse_attribute_naked(p: parser, style: ast::attr_style, lo: uint) ->\n    ast::attribute {\n     expect(p, token::LBRACKET);\n     let meta_item = parse_meta_item(p);\n@@ -2181,7 +2183,7 @@ fn parse_attribute_naked(p: &parser, style: ast::attr_style, lo: uint) ->\n // next item (since we can't know whether the attribute is an inner attribute\n // of the containing item or an outer attribute of the first contained item\n // until we see the semi).\n-fn parse_inner_attrs_and_next(p: &parser) ->\n+fn parse_inner_attrs_and_next(p: parser) ->\n    {inner: [ast::attribute], next: [ast::attribute]} {\n     let inner_attrs: [ast::attribute] = [];\n     let next_outer_attrs: [ast::attribute] = [];\n@@ -2202,7 +2204,7 @@ fn parse_inner_attrs_and_next(p: &parser) ->\n     ret {inner: inner_attrs, next: next_outer_attrs};\n }\n \n-fn parse_meta_item(p: &parser) -> @ast::meta_item {\n+fn parse_meta_item(p: parser) -> @ast::meta_item {\n     let lo = p.get_lo_pos();\n     let ident = parse_ident(p);\n     alt p.peek() {\n@@ -2224,22 +2226,22 @@ fn parse_meta_item(p: &parser) -> @ast::meta_item {\n     }\n }\n \n-fn parse_meta_seq(p: &parser) -> [@ast::meta_item] {\n+fn parse_meta_seq(p: parser) -> [@ast::meta_item] {\n     ret parse_seq(token::LPAREN, token::RPAREN, some(token::COMMA),\n                   parse_meta_item, p).node;\n }\n \n-fn parse_optional_meta(p: &parser) -> [@ast::meta_item] {\n+fn parse_optional_meta(p: parser) -> [@ast::meta_item] {\n     alt p.peek() { token::LPAREN. { ret parse_meta_seq(p); } _ { ret []; } }\n }\n \n-fn parse_use(p: &parser) -> ast::view_item_ {\n+fn parse_use(p: parser) -> ast::view_item_ {\n     let ident = parse_ident(p);\n     let metadata = parse_optional_meta(p);\n     ret ast::view_item_use(ident, metadata, p.get_id());\n }\n \n-fn parse_rest_import_name(p: &parser, first: &ast::ident,\n+fn parse_rest_import_name(p: parser, first: ast::ident,\n                           def_ident: option::t<ast::ident>) ->\n    ast::view_item_ {\n     let identifiers: [ast::ident] = [first];\n@@ -2262,6 +2264,7 @@ fn parse_rest_import_name(p: &parser, first: &ast::ident,\n \n \n \n+\n           //the lexer can't tell the different kinds of stars apart ) :\n           token::BINOP(token::STAR.) {\n             glob = true;\n@@ -2270,8 +2273,9 @@ fn parse_rest_import_name(p: &parser, first: &ast::ident,\n \n \n \n+\n           token::LBRACE. {\n-            fn parse_import_ident(p: &parser) -> ast::import_ident {\n+            fn parse_import_ident(p: parser) -> ast::import_ident {\n                 let lo = p.get_lo_pos();\n                 let ident = parse_ident(p);\n                 let hi = p.get_hi_pos();\n@@ -2288,6 +2292,7 @@ fn parse_rest_import_name(p: &parser, first: &ast::ident,\n \n \n \n+\n           _ {\n             p.fatal(\"expecting an identifier, or '*'\");\n           }\n@@ -2317,7 +2322,7 @@ fn parse_rest_import_name(p: &parser, first: &ast::ident,\n     }\n }\n \n-fn parse_full_import_name(p: &parser, def_ident: &ast::ident) ->\n+fn parse_full_import_name(p: parser, def_ident: ast::ident) ->\n    ast::view_item_ {\n     alt p.peek() {\n       token::IDENT(i, _) {\n@@ -2328,7 +2333,7 @@ fn parse_full_import_name(p: &parser, def_ident: &ast::ident) ->\n     }\n }\n \n-fn parse_import(p: &parser) -> ast::view_item_ {\n+fn parse_import(p: parser) -> ast::view_item_ {\n     alt p.peek() {\n       token::IDENT(i, _) {\n         p.bump();\n@@ -2344,14 +2349,14 @@ fn parse_import(p: &parser) -> ast::view_item_ {\n     }\n }\n \n-fn parse_export(p: &parser) -> ast::view_item_ {\n+fn parse_export(p: parser) -> ast::view_item_ {\n     let ids =\n         parse_seq_to_before_end(token::SEMI, option::some(token::COMMA),\n                                 parse_ident, p);\n     ret ast::view_item_export(ids, p.get_id());\n }\n \n-fn parse_view_item(p: &parser) -> @ast::view_item {\n+fn parse_view_item(p: parser) -> @ast::view_item {\n     let lo = p.get_lo_pos();\n     let the_item =\n         if eat_word(p, \"use\") {\n@@ -2364,7 +2369,7 @@ fn parse_view_item(p: &parser) -> @ast::view_item {\n     ret @spanned(lo, hi, the_item);\n }\n \n-fn is_view_item(p: &parser) -> bool {\n+fn is_view_item(p: parser) -> bool {\n     alt p.peek() {\n       token::IDENT(sid, false) {\n         let st = p.get_str(sid);\n@@ -2375,26 +2380,26 @@ fn is_view_item(p: &parser) -> bool {\n     }\n }\n \n-fn parse_view(p: &parser) -> [@ast::view_item] {\n+fn parse_view(p: parser) -> [@ast::view_item] {\n     let items: [@ast::view_item] = [];\n     while is_view_item(p) { items += [parse_view_item(p)]; }\n     ret items;\n }\n \n-fn parse_native_view(p: &parser) -> [@ast::view_item] {\n+fn parse_native_view(p: parser) -> [@ast::view_item] {\n     let items: [@ast::view_item] = [];\n     while is_view_item(p) { items += [parse_view_item(p)]; }\n     ret items;\n }\n \n-fn parse_crate_from_source_file(input: &str, cfg: &ast::crate_cfg,\n-                                sess: &parse_sess) -> @ast::crate {\n+fn parse_crate_from_source_file(input: str, cfg: ast::crate_cfg,\n+                                sess: parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, 0u, 0u, SOURCE_FILE);\n     ret parse_crate_mod(p, cfg);\n }\n \n-fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n-                               sess: &parse_sess) -> @ast::crate {\n+fn parse_crate_from_source_str(name: str, source: str, cfg: ast::crate_cfg,\n+                               sess: parse_sess) -> @ast::crate {\n     let ftype = SOURCE_FILE;\n     let filemap = codemap::new_filemap(name, 0u, 0u);\n     sess.cm.files += [filemap];\n@@ -2405,7 +2410,7 @@ fn parse_crate_from_source_str(name: &str, source: &str, cfg: &ast::crate_cfg,\n }\n \n // Parses a source module as a crate\n-fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) -> @ast::crate {\n+fn parse_crate_mod(p: parser, _cfg: ast::crate_cfg) -> @ast::crate {\n     let lo = p.get_lo_pos();\n     let crate_attrs = parse_inner_attrs_and_next(p);\n     let first_item_outer_attrs = crate_attrs.next;\n@@ -2417,7 +2422,7 @@ fn parse_crate_mod(p: &parser, _cfg: &ast::crate_cfg) -> @ast::crate {\n                   config: p.get_cfg()});\n }\n \n-fn parse_str(p: &parser) -> str {\n+fn parse_str(p: parser) -> str {\n     alt p.peek() {\n       token::LIT_STR(s) { p.bump(); ret p.get_str(s); }\n       _ { fail; }\n@@ -2429,7 +2434,7 @@ fn parse_str(p: &parser) -> str {\n // Each crate file is a sequence of directives.\n //\n // Each directive imperatively extends its environment with 0 or more items.\n-fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n+fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n    ast::crate_directive {\n \n     // Collect the next attributes\n@@ -2450,6 +2455,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n \n \n \n+\n           // mod x = \"foo.rs\";\n           token::SEMI. {\n             let hi = p.get_hi_pos();\n@@ -2459,6 +2465,7 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n \n \n \n+\n           // mod x = \"foo_dir\" { ...directives... }\n           token::LBRACE. {\n             p.bump();\n@@ -2487,8 +2494,8 @@ fn parse_crate_directive(p: &parser, first_outer_attr: &[ast::attribute]) ->\n     } else { ret p.fatal(\"expected crate directive\"); }\n }\n \n-fn parse_crate_directives(p: &parser, term: token::token,\n-                          first_outer_attr: &[ast::attribute]) ->\n+fn parse_crate_directives(p: parser, term: token::token,\n+                          first_outer_attr: [ast::attribute]) ->\n    [@ast::crate_directive] {\n \n     // This is pretty ugly. If we have an outer attribute then we can't accept\n@@ -2506,8 +2513,8 @@ fn parse_crate_directives(p: &parser, term: token::token,\n     ret cdirs;\n }\n \n-fn parse_crate_from_crate_file(input: &str, cfg: &ast::crate_cfg,\n-                               sess: &parse_sess) -> @ast::crate {\n+fn parse_crate_from_crate_file(input: str, cfg: ast::crate_cfg,\n+                               sess: parse_sess) -> @ast::crate {\n     let p = new_parser_from_file(sess, cfg, input, 0u, 0u, CRATE_FILE);\n     let lo = p.get_lo_pos();\n     let prefix = std::fs::dirname(p.get_filemap().name);\n@@ -2534,8 +2541,8 @@ fn parse_crate_from_crate_file(input: &str, cfg: &ast::crate_cfg,\n                   config: p.get_cfg()});\n }\n \n-fn parse_crate_from_file(input: &str, cfg: &ast::crate_cfg, sess: &parse_sess)\n-   -> @ast::crate {\n+fn parse_crate_from_file(input: str, cfg: ast::crate_cfg, sess: parse_sess) ->\n+   @ast::crate {\n     if str::ends_with(input, \".rc\") {\n         parse_crate_from_crate_file(input, cfg, sess)\n     } else if str::ends_with(input, \".rs\") {"}, {"sha": "2846d3945dd5b8b4e278badb5725c18f97d986b7", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -118,6 +118,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n \n \n+\n       /* Structural symbols */\n       AT. {\n         ret \"@\";\n@@ -144,6 +145,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n \n \n+\n       /* Literals */\n       LIT_INT(i) {\n         ret int::to_str(i, 10u);\n@@ -171,6 +173,7 @@ fn to_str(r: lexer::reader, t: token) -> str {\n \n \n \n+\n       /* Name components */\n       IDENT(s, _) {\n         ret interner::get::<str>(*r.get_interner(), s);"}, {"sha": "280a36a3ac7cbc8e63eb875a719fbd415fdeffec", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -73,8 +73,8 @@ fn tok_str(t: token) -> str {\n     }\n }\n \n-fn buf_str(toks: &[mutable token], szs: &[mutable int], left: uint,\n-           right: uint, lim: uint) -> str {\n+fn buf_str(toks: [mutable token], szs: [mutable int], left: uint, right: uint,\n+           lim: uint) -> str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n     let i = left;\n@@ -404,7 +404,7 @@ obj printer(out: io::writer,\n         if n != 0u { top = print_stack[n - 1u]; }\n         ret top;\n     }\n-    fn write_str(s: &str) {\n+    fn write_str(s: str) {\n         while pending_indentation > 0 {\n             out.write_str(\" \");\n             pending_indentation -= 1;\n@@ -492,15 +492,15 @@ fn end(p: printer) { p.pretty_print(END); }\n \n fn eof(p: printer) { p.pretty_print(EOF); }\n \n-fn word(p: printer, wrd: &str) {\n+fn word(p: printer, wrd: str) {\n     p.pretty_print(STRING(wrd, str::char_len(wrd) as int));\n }\n \n-fn huge_word(p: printer, wrd: &str) {\n+fn huge_word(p: printer, wrd: str) {\n     p.pretty_print(STRING(wrd, size_infinity));\n }\n \n-fn zero_word(p: printer, wrd: &str) { p.pretty_print(STRING(wrd, 0)); }\n+fn zero_word(p: printer, wrd: str) { p.pretty_print(STRING(wrd, 0)); }\n \n fn spaces(p: printer, n: uint) { break_offset(p, n, 0); }\n "}, {"sha": "b1ecf450c5d0092fc7bf319e2ea398e312aa8418", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 130, "deletions": 131, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -33,10 +33,10 @@ tag ann_node {\n     node_expr(ps, @ast::expr);\n     node_pat(ps, @ast::pat);\n }\n-type pp_ann = {pre: fn(&ann_node), post: fn(&ann_node)};\n+type pp_ann = {pre: fn(ann_node), post: fn(ann_node)};\n \n fn no_ann() -> pp_ann {\n-    fn ignore(_node: &ann_node) { }\n+    fn ignore(_node: ann_node) { }\n     ret {pre: ignore, post: ignore};\n }\n \n@@ -50,9 +50,9 @@ type ps =\n       mutable boxes: [pp::breaks],\n       ann: pp_ann};\n \n-fn ibox(s: &ps, u: uint) { s.boxes += [pp::inconsistent]; pp::ibox(s.s, u); }\n+fn ibox(s: ps, u: uint) { s.boxes += [pp::inconsistent]; pp::ibox(s.s, u); }\n \n-fn end(s: &ps) { vec::pop(s.boxes); pp::end(s.s); }\n+fn end(s: ps) { vec::pop(s.boxes); pp::end(s.s); }\n \n fn rust_printer(writer: io::writer) -> ps {\n     let boxes: [pp::breaks] = [];\n@@ -74,8 +74,8 @@ const default_columns: uint = 78u;\n // Requires you to pass an input filename and reader so that\n // it can scan the input text for comments and literals to\n // copy forward.\n-fn print_crate(cm: &codemap, crate: @ast::crate, filename: &str,\n-               in: io::reader, out: io::writer, ann: &pp_ann) {\n+fn print_crate(cm: codemap, crate: @ast::crate, filename: str, in: io::reader,\n+               out: io::writer, ann: pp_ann) {\n     let boxes: [pp::breaks] = [];\n     let r = lexer::gather_comments_and_literals(cm, filename, in);\n     let s =\n@@ -92,30 +92,29 @@ fn print_crate(cm: &codemap, crate: @ast::crate, filename: &str,\n     eof(s.s);\n }\n \n-fn ty_to_str(ty: &@ast::ty) -> str { be to_str(ty, print_type); }\n+fn ty_to_str(ty: @ast::ty) -> str { be to_str(ty, print_type); }\n \n-fn pat_to_str(pat: &@ast::pat) -> str { be to_str(pat, print_pat); }\n+fn pat_to_str(pat: @ast::pat) -> str { be to_str(pat, print_pat); }\n \n-fn expr_to_str(e: &@ast::expr) -> str { be to_str(e, print_expr); }\n+fn expr_to_str(e: @ast::expr) -> str { be to_str(e, print_expr); }\n \n-fn stmt_to_str(s: &ast::stmt) -> str { be to_str(s, print_stmt); }\n+fn stmt_to_str(s: ast::stmt) -> str { be to_str(s, print_stmt); }\n \n-fn item_to_str(i: &@ast::item) -> str { be to_str(i, print_item); }\n+fn item_to_str(i: @ast::item) -> str { be to_str(i, print_item); }\n \n-fn path_to_str(p: &ast::path) -> str {\n+fn path_to_str(p: ast::path) -> str {\n     be to_str(p, bind print_path(_, _, false));\n }\n \n-fn fun_to_str(f: &ast::_fn, name: &ast::ident, params: &[ast::ty_param]) ->\n-   str {\n+fn fun_to_str(f: ast::_fn, name: ast::ident, params: [ast::ty_param]) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n-fn block_to_str(blk: &ast::blk) -> str {\n+fn block_to_str(blk: ast::blk) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     // containing cbox, will be closed by print-block at }\n@@ -129,29 +128,29 @@ fn block_to_str(blk: &ast::blk) -> str {\n     ret writer.get_str();\n }\n \n-fn meta_item_to_str(mi: &ast::meta_item) -> str {\n+fn meta_item_to_str(mi: ast::meta_item) -> str {\n     ret to_str(@mi, print_meta_item);\n }\n \n-fn attribute_to_str(attr: &ast::attribute) -> str {\n+fn attribute_to_str(attr: ast::attribute) -> str {\n     be to_str(attr, print_attribute);\n }\n \n-fn cbox(s: &ps, u: uint) { s.boxes += [pp::consistent]; pp::cbox(s.s, u); }\n+fn cbox(s: ps, u: uint) { s.boxes += [pp::consistent]; pp::cbox(s.s, u); }\n \n-fn box(s: &ps, u: uint, b: pp::breaks) { s.boxes += [b]; pp::box(s.s, u, b); }\n+fn box(s: ps, u: uint, b: pp::breaks) { s.boxes += [b]; pp::box(s.s, u, b); }\n \n-fn nbsp(s: &ps) { word(s.s, \" \"); }\n+fn nbsp(s: ps) { word(s.s, \" \"); }\n \n-fn word_nbsp(s: &ps, w: &str) { word(s.s, w); nbsp(s); }\n+fn word_nbsp(s: ps, w: str) { word(s.s, w); nbsp(s); }\n \n-fn word_space(s: &ps, w: &str) { word(s.s, w); space(s.s); }\n+fn word_space(s: ps, w: str) { word(s.s, w); space(s.s); }\n \n-fn popen(s: &ps) { word(s.s, \"(\"); }\n+fn popen(s: ps) { word(s.s, \"(\"); }\n \n-fn pclose(s: &ps) { word(s.s, \")\"); }\n+fn pclose(s: ps) { word(s.s, \")\"); }\n \n-fn head(s: &ps, w: &str) {\n+fn head(s: ps, w: str) {\n     // outer-box is consistent\n     cbox(s, indent_unit);\n     // head-box is inconsistent\n@@ -160,35 +159,35 @@ fn head(s: &ps, w: &str) {\n     word_nbsp(s, w);\n }\n \n-fn bopen(s: &ps) {\n+fn bopen(s: ps) {\n     word(s.s, \"{\");\n     end(s); // close the head-box\n }\n \n-fn bclose_(s: &ps, span: codemap::span, indented: uint) {\n+fn bclose_(s: ps, span: codemap::span, indented: uint) {\n     maybe_print_comment(s, span.hi);\n     break_offset_if_not_bol(s, 1u, -(indented as int));\n     word(s.s, \"}\");\n     end(s); // close the outer-box\n }\n-fn bclose(s: &ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n+fn bclose(s: ps, span: codemap::span) { bclose_(s, span, indent_unit); }\n \n-fn is_begin(s: &ps) -> bool {\n+fn is_begin(s: ps) -> bool {\n     alt s.s.last_token() { pp::BEGIN(_) { true } _ { false } }\n }\n \n-fn is_end(s: &ps) -> bool {\n+fn is_end(s: ps) -> bool {\n     alt s.s.last_token() { pp::END. { true } _ { false } }\n }\n \n-fn is_bol(s: &ps) -> bool {\n+fn is_bol(s: ps) -> bool {\n     ret s.s.last_token() == pp::EOF ||\n             s.s.last_token() == pp::hardbreak_tok();\n }\n \n-fn hardbreak_if_not_bol(s: &ps) { if !is_bol(s) { hardbreak(s.s); } }\n-fn space_if_not_bol(s: &ps) { if !is_bol(s) { space(s.s); } }\n-fn break_offset_if_not_bol(s: &ps, n: uint, off: int) {\n+fn hardbreak_if_not_bol(s: ps) { if !is_bol(s) { hardbreak(s.s); } }\n+fn space_if_not_bol(s: ps) { if !is_bol(s) { space(s.s); } }\n+fn break_offset_if_not_bol(s: ps, n: uint, off: int) {\n     if !is_bol(s) {\n         break_offset(s.s, n, off);\n     } else {\n@@ -203,15 +202,15 @@ fn break_offset_if_not_bol(s: &ps, n: uint, off: int) {\n \n // Synthesizes a comment that was not textually present in the original source\n // file.\n-fn synth_comment(s: &ps, text: &str) {\n+fn synth_comment(s: ps, text: str) {\n     word(s.s, \"/*\");\n     space(s.s);\n     word(s.s, text);\n     space(s.s);\n     word(s.s, \"*/\");\n }\n \n-fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN)) {\n+fn commasep<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN)) {\n     box(s, 0u, b);\n     let first = true;\n     for elt: IN in elts {\n@@ -222,8 +221,8 @@ fn commasep<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN)) {\n }\n \n \n-fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN),\n-                     get_span: fn(&IN) -> codemap::span) {\n+fn commasep_cmnt<IN>(s: ps, b: breaks, elts: [IN], op: fn(ps, IN),\n+                     get_span: fn(IN) -> codemap::span) {\n     box(s, 0u, b);\n     let len = vec::len::<IN>(elts);\n     let i = 0u;\n@@ -241,29 +240,28 @@ fn commasep_cmnt<IN>(s: &ps, b: breaks, elts: &[IN], op: fn(&ps, &IN),\n     end(s);\n }\n \n-fn commasep_exprs(s: &ps, b: breaks, exprs: &[@ast::expr]) {\n-    fn expr_span(expr: &@ast::expr) -> codemap::span { ret expr.span; }\n+fn commasep_exprs(s: ps, b: breaks, exprs: [@ast::expr]) {\n+    fn expr_span(expr: @ast::expr) -> codemap::span { ret expr.span; }\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-fn print_mod(s: &ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n+fn print_mod(s: ps, _mod: ast::_mod, attrs: [ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem: @ast::view_item in _mod.view_items {\n         print_view_item(s, vitem);\n     }\n     for item: @ast::item in _mod.items { print_item(s, item); }\n }\n \n-fn print_native_mod(s: &ps, nmod: &ast::native_mod,\n-                    attrs: &[ast::attribute]) {\n+fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for vitem: @ast::view_item in nmod.view_items {\n         print_view_item(s, vitem);\n     }\n     for item: @ast::native_item in nmod.items { print_native_item(s, item); }\n }\n \n-fn print_type(s: &ps, ty: &@ast::ty) {\n+fn print_type(s: ps, ty: @ast::ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt ty.node {\n@@ -301,15 +299,15 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n       }\n       ast::ty_rec(fields) {\n         word(s.s, \"{\");\n-        fn print_field(s: &ps, f: &ast::ty_field) {\n+        fn print_field(s: ps, f: ast::ty_field) {\n             cbox(s, indent_unit);\n             print_mutability(s, f.node.mt.mut);\n             word(s.s, f.node.ident);\n             word_space(s, \":\");\n             print_type(s, f.node.mt.ty);\n             end(s);\n         }\n-        fn get_span(f: &ast::ty_field) -> codemap::span { ret f.span; }\n+        fn get_span(f: ast::ty_field) -> codemap::span { ret f.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         word(s.s, \"}\");\n       }\n@@ -346,7 +344,7 @@ fn print_type(s: &ps, ty: &@ast::ty) {\n     end(s);\n }\n \n-fn print_native_item(s: &ps, item: &@ast::native_item) {\n+fn print_native_item(s: ps, item: @ast::native_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -365,6 +363,7 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n \n \n \n+\n       ast::native_item_fn(lname, decl, typarams) {\n         print_fn(s, decl, ast::proto_fn, item.ident, typarams,\n                  decl.constraints);\n@@ -379,7 +378,7 @@ fn print_native_item(s: &ps, item: &@ast::native_item) {\n     }\n }\n \n-fn print_item(s: &ps, item: &@ast::item) {\n+fn print_item(s: ps, item: @ast::item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n@@ -473,7 +472,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n                 word(s.s, v.node.name);\n                 if vec::len(v.node.args) > 0u {\n                     popen(s);\n-                    fn print_variant_arg(s: &ps, arg: &ast::variant_arg) {\n+                    fn print_variant_arg(s: ps, arg: ast::variant_arg) {\n                         print_type(s, arg.ty);\n                     }\n                     commasep(s, consistent, v.node.args, print_variant_arg);\n@@ -490,14 +489,14 @@ fn print_item(s: &ps, item: &@ast::item) {\n         word(s.s, item.ident);\n         print_type_params(s, params);\n         popen(s);\n-        fn print_field(s: &ps, field: &ast::obj_field) {\n+        fn print_field(s: ps, field: ast::obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n             word_space(s, field.ident + \":\");\n             print_type(s, field.ty);\n             end(s);\n         }\n-        fn get_span(f: &ast::obj_field) -> codemap::span { ret f.ty.span; }\n+        fn get_span(f: ast::obj_field) -> codemap::span { ret f.ty.span; }\n         commasep_cmnt(s, consistent, _obj.fields, print_field, get_span);\n         pclose(s);\n         space(s.s);\n@@ -528,7 +527,7 @@ fn print_item(s: &ps, item: &@ast::item) {\n     s.ann.post(ann_node);\n }\n \n-fn print_outer_attributes(s: &ps, attrs: &[ast::attribute]) {\n+fn print_outer_attributes(s: ps, attrs: [ast::attribute]) {\n     let count = 0;\n     for attr: ast::attribute in attrs {\n         alt attr.node.style {\n@@ -539,7 +538,7 @@ fn print_outer_attributes(s: &ps, attrs: &[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n+fn print_inner_attributes(s: ps, attrs: [ast::attribute]) {\n     let count = 0;\n     for attr: ast::attribute in attrs {\n         alt attr.node.style {\n@@ -554,15 +553,15 @@ fn print_inner_attributes(s: &ps, attrs: &[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-fn print_attribute(s: &ps, attr: &ast::attribute) {\n+fn print_attribute(s: ps, attr: ast::attribute) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, attr.span.lo);\n     word(s.s, \"#[\");\n     print_meta_item(s, @attr.node.value);\n     word(s.s, \"]\");\n }\n \n-fn print_stmt(s: &ps, st: &ast::stmt) {\n+fn print_stmt(s: ps, st: ast::stmt) {\n     maybe_print_comment(s, st.span.lo);\n     alt st.node {\n       ast::stmt_decl(decl, _) { print_decl(s, decl); }\n@@ -572,13 +571,13 @@ fn print_stmt(s: &ps, st: &ast::stmt) {\n     maybe_print_trailing_comment(s, st.span, none::<uint>);\n }\n \n-fn print_block(s: &ps, blk: &ast::blk) {\n+fn print_block(s: ps, blk: ast::blk) {\n     print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n }\n \n tag embed_type { block_macro; block_block_fn; block_normal; }\n \n-fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n+fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {\n     alt blk.node.rules { ast::unchecked. { word(s.s, \"unchecked\"); } _ { } }\n \n@@ -615,8 +614,8 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n     // followed by a unary op, square bracket, or paren. In those cases we\n     // have to add an extra semi to make sure the output retains the same\n     // meaning.\n-    fn maybe_protect_block(s: &ps, last: &option::t<@ast::stmt>,\n-                           next: &expr_or_stmt) {\n+    fn maybe_protect_block(s: ps, last: option::t<@ast::stmt>,\n+                           next: expr_or_stmt) {\n         let last_expr_is_block =\n             alt last {\n               option::some(@{node: ast::stmt_expr(e, _), _}) {\n@@ -655,7 +654,7 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n             visit_expr(ex, env, visitor);\n             ret *env;\n \n-            fn visit_expr(ex: &@ast::expr, e: &env, v: &visit::vt<env>) {\n+            fn visit_expr(ex: @ast::expr, e: env, v: visit::vt<env>) {\n                 assert (*e == false);\n \n                 if expr_is_ambig(ex) { *e = true; ret; }\n@@ -695,28 +694,29 @@ fn print_possibly_embedded_block(s: &ps, blk: &ast::blk, embedded: embed_type,\n \n // ret and fail, without arguments cannot appear is the discriminant of if,\n // alt, do, & while unambiguously without being parenthesized\n-fn print_maybe_parens_discrim(s: &ps, e: &@ast::expr) {\n+fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n     let disambig =\n         alt e.node { ast::expr_ret(option::none.) { true } _ { false } };\n     if disambig { popen(s) }\n     print_expr(s, e);\n     if disambig { pclose(s) }\n }\n \n-fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n-            elseopt: &option::t<@ast::expr>, chk: bool) {\n+fn print_if(s: ps, test: @ast::expr, blk: ast::blk,\n+            elseopt: option::t<@ast::expr>, chk: bool) {\n     head(s, \"if\");\n     if chk { word_nbsp(s, \"check\"); }\n     print_maybe_parens_discrim(s, test);\n     space(s.s);\n     print_block(s, blk);\n-    fn do_else(s: &ps, els: option::t<@ast::expr>) {\n+    fn do_else(s: ps, els: option::t<@ast::expr>) {\n         alt els {\n           some(_else) {\n             alt _else.node {\n \n \n \n+\n               // \"another else-if\"\n               ast::expr_if(i, t, e) {\n                 cbox(s, indent_unit - 1u);\n@@ -730,6 +730,7 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n \n \n \n+\n               // \"final else\"\n               ast::expr_block(b) {\n                 cbox(s, indent_unit - 1u);\n@@ -745,7 +746,7 @@ fn print_if(s: &ps, test: &@ast::expr, blk: &ast::blk,\n     do_else(s, elseopt);\n }\n \n-fn print_mac(s: &ps, m: &ast::mac) {\n+fn print_mac(s: ps, m: ast::mac) {\n     alt m.node {\n       ast::mac_invoc(path, arg, body) {\n         word(s.s, \"#\");\n@@ -766,7 +767,7 @@ fn print_mac(s: &ps, m: &ast::mac) {\n     }\n }\n \n-fn print_expr(s: &ps, expr: &@ast::expr) {\n+fn print_expr(s: ps, expr: @ast::expr) {\n     maybe_print_comment(s, expr.span.lo);\n     ibox(s, indent_unit);\n     let ann_node = node_expr(s, expr);\n@@ -784,15 +785,15 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         end(s);\n       }\n       ast::expr_rec(fields, wth) {\n-        fn print_field(s: &ps, field: &ast::field) {\n+        fn print_field(s: ps, field: ast::field) {\n             ibox(s, indent_unit);\n             if field.node.mut == ast::mut { word_nbsp(s, \"mutable\"); }\n             word(s.s, field.node.ident);\n             word_space(s, \":\");\n             print_expr(s, field.node.expr);\n             end(s);\n         }\n-        fn get_span(field: &ast::field) -> codemap::span { ret field.span; }\n+        fn get_span(field: ast::field) -> codemap::span { ret field.span; }\n         word(s.s, \"{\");\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         alt wth {\n@@ -823,7 +824,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n         print_ident(s, ident);\n       }\n       ast::expr_bind(func, args) {\n-        fn print_opt(s: &ps, expr: &option::t<@ast::expr>) {\n+        fn print_opt(s: ps, expr: option::t<@ast::expr>) {\n             alt expr {\n               some(expr) { print_expr(s, expr); }\n               _ { word(s.s, \"_\"); }\n@@ -1036,7 +1037,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n \n         // Fields\n         popen(s);\n-        fn print_field(s: &ps, field: &ast::anon_obj_field) {\n+        fn print_field(s: ps, field: ast::anon_obj_field) {\n             ibox(s, indent_unit);\n             print_mutability(s, field.mut);\n             word_space(s, field.ident + \":\");\n@@ -1046,7 +1047,7 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n             print_expr(s, field.expr);\n             end(s);\n         }\n-        fn get_span(f: &ast::anon_obj_field) -> codemap::span {\n+        fn get_span(f: ast::anon_obj_field) -> codemap::span {\n             ret f.ty.span;\n         }\n         alt anon_obj.fields {\n@@ -1083,29 +1084,29 @@ fn print_expr(s: &ps, expr: &@ast::expr) {\n     end(s);\n }\n \n-fn print_expr_parens_if_unary(s: &ps, ex: &@ast::expr) {\n+fn print_expr_parens_if_unary(s: ps, ex: @ast::expr) {\n     let parens = alt ex.node { ast::expr_unary(_, _) { true } _ { false } };\n     if parens { popen(s); }\n     print_expr(s, ex);\n     if parens { pclose(s); }\n }\n \n-fn print_local_decl(s: &ps, loc: &@ast::local) {\n+fn print_local_decl(s: ps, loc: @ast::local) {\n     print_pat(s, loc.node.pat);\n     alt loc.node.ty.node {\n       ast::ty_infer. { }\n       _ { word_space(s, \":\"); print_type(s, loc.node.ty); }\n     }\n }\n \n-fn print_decl(s: &ps, decl: &@ast::decl) {\n+fn print_decl(s: ps, decl: @ast::decl) {\n     maybe_print_comment(s, decl.span.lo);\n     alt decl.node {\n       ast::decl_local(locs) {\n         space_if_not_bol(s);\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n-        fn print_local(s: &ps, loc: &@ast::local) {\n+        fn print_local(s: ps, loc: @ast::local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n             end(s);\n@@ -1128,16 +1129,16 @@ fn print_decl(s: &ps, decl: &@ast::decl) {\n     }\n }\n \n-fn print_ident(s: &ps, ident: &ast::ident) { word(s.s, ident); }\n+fn print_ident(s: ps, ident: ast::ident) { word(s.s, ident); }\n \n-fn print_for_decl(s: &ps, loc: &@ast::local, coll: &@ast::expr) {\n+fn print_for_decl(s: ps, loc: @ast::local, coll: @ast::expr) {\n     print_local_decl(s, loc);\n     space(s.s);\n     word_space(s, \"in\");\n     print_expr(s, coll);\n }\n \n-fn print_path(s: &ps, path: &ast::path, colons_before_params: bool) {\n+fn print_path(s: ps, path: ast::path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.node.global { word(s.s, \"::\"); }\n     let first = true;\n@@ -1153,7 +1154,7 @@ fn print_path(s: &ps, path: &ast::path, colons_before_params: bool) {\n     }\n }\n \n-fn print_pat(s: &ps, pat: &@ast::pat) {\n+fn print_pat(s: ps, pat: @ast::pat) {\n     maybe_print_comment(s, pat.span.lo);\n     let ann_node = node_pat(s, pat);\n     s.ann.pre(ann_node);\n@@ -1171,14 +1172,14 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n       }\n       ast::pat_rec(fields, etc) {\n         word(s.s, \"{\");\n-        fn print_field(s: &ps, f: &ast::field_pat) {\n+        fn print_field(s: ps, f: ast::field_pat) {\n             cbox(s, indent_unit);\n             word(s.s, f.ident);\n             word_space(s, \":\");\n             print_pat(s, f.pat);\n             end(s);\n         }\n-        fn get_span(f: &ast::field_pat) -> codemap::span { ret f.pat.span; }\n+        fn get_span(f: ast::field_pat) -> codemap::span { ret f.pat.span; }\n         commasep_cmnt(s, consistent, fields, print_field, get_span);\n         if etc {\n             if vec::len(fields) != 0u { word_space(s, \",\"); }\n@@ -1196,8 +1197,8 @@ fn print_pat(s: &ps, pat: &@ast::pat) {\n     s.ann.post(ann_node);\n }\n \n-fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: &ast::ident,\n-            typarams: &[ast::ty_param], constrs: [@ast::constr]) {\n+fn print_fn(s: ps, decl: ast::fn_decl, proto: ast::proto, name: ast::ident,\n+            typarams: [ast::ty_param], constrs: [@ast::constr]) {\n     alt decl.purity {\n       ast::impure_fn. { head(s, proto_to_str(proto)); }\n       _ { head(s, \"pure fn\"); }\n@@ -1207,10 +1208,9 @@ fn print_fn(s: &ps, decl: ast::fn_decl, proto: ast::proto, name: &ast::ident,\n     print_fn_args_and_ret(s, decl, constrs);\n }\n \n-fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n-                         constrs: [@ast::constr]) {\n+fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n     popen(s);\n-    fn print_arg(s: &ps, x: &ast::arg) {\n+    fn print_arg(s: ps, x: ast::arg) {\n         ibox(s, indent_unit);\n         word_space(s, x.ident + \":\");\n         print_alias(s, x.mode);\n@@ -1228,9 +1228,9 @@ fn print_fn_args_and_ret(s: &ps, decl: &ast::fn_decl,\n     }\n }\n \n-fn print_fn_block_args(s: &ps, decl: &ast::fn_decl) {\n+fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n     word(s.s, \"|\");\n-    fn print_arg(s: &ps, x: &ast::arg) {\n+    fn print_arg(s: ps, x: ast::arg) {\n         ibox(s, indent_unit);\n         print_alias(s, x.mode);\n         word(s.s, x.ident);\n@@ -1241,26 +1241,26 @@ fn print_fn_block_args(s: &ps, decl: &ast::fn_decl) {\n     maybe_print_comment(s, decl.output.span.lo);\n }\n \n-fn print_alias(s: &ps, m: ast::mode) {\n+fn print_alias(s: ps, m: ast::mode) {\n     alt m {\n       ast::by_mut_ref. { word_space(s, \"&mutable\"); }\n       ast::by_move. { word(s.s, \"-\"); }\n       ast::by_ref. { }\n     }\n }\n \n-fn print_kind(s: &ps, kind: ast::kind) {\n+fn print_kind(s: ps, kind: ast::kind) {\n     alt kind {\n       ast::kind_unique. { word(s.s, \"~\"); }\n       ast::kind_shared. { word(s.s, \"@\"); }\n       _ {/* fallthrough */ }\n     }\n }\n \n-fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n+fn print_type_params(s: ps, params: [ast::ty_param]) {\n     if vec::len(params) > 0u {\n         word(s.s, \"<\");\n-        fn printParam(s: &ps, param: &ast::ty_param) {\n+        fn printParam(s: ps, param: ast::ty_param) {\n             print_kind(s, param.kind);\n             word(s.s, param.ident);\n         }\n@@ -1269,7 +1269,7 @@ fn print_type_params(s: &ps, params: &[ast::ty_param]) {\n     }\n }\n \n-fn print_meta_item(s: &ps, item: &@ast::meta_item) {\n+fn print_meta_item(s: ps, item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     alt item.node {\n       ast::meta_word(name) { word(s.s, name); }\n@@ -1288,7 +1288,7 @@ fn print_meta_item(s: &ps, item: &@ast::meta_item) {\n     end(s);\n }\n \n-fn print_view_item(s: &ps, item: &@ast::view_item) {\n+fn print_view_item(s: ps, item: @ast::view_item) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, item.span.lo);\n     alt item.node {\n@@ -1318,9 +1318,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n         for elt: ast::ident in mod_path { word(s.s, elt); word(s.s, \"::\"); }\n         word(s.s, \"{\");\n         commasep(s, inconsistent, idents,\n-                 fn (s: &ps, w: &ast::import_ident) {\n-                     word(s.s, w.node.name)\n-                 });\n+                 fn (s: ps, w: ast::import_ident) { word(s.s, w.node.name) });\n         word(s.s, \"}\");\n       }\n       ast::view_item_import_glob(ids, _) {\n@@ -1335,7 +1333,7 @@ fn print_view_item(s: &ps, item: &@ast::view_item) {\n       ast::view_item_export(ids, _) {\n         head(s, \"export\");\n         commasep(s, inconsistent, ids,\n-                 fn (s: &ps, w: &ast::ident) { word(s.s, w) });\n+                 fn (s: ps, w: ast::ident) { word(s.s, w) });\n       }\n     }\n     word(s.s, \";\");\n@@ -1355,14 +1353,15 @@ fn operator_prec(op: ast::binop) -> int {\n     fail;\n }\n \n-fn need_parens(expr: &@ast::expr, outer_prec: int) -> bool {\n+fn need_parens(expr: @ast::expr, outer_prec: int) -> bool {\n     alt expr.node {\n       ast::expr_binary(op, _, _) { operator_prec(op) < outer_prec }\n       ast::expr_cast(_, _) { parse::parser::as_prec < outer_prec }\n       ast::expr_ternary(_, _, _) { parse::parser::ternary_prec < outer_prec }\n \n \n \n+\n       // This may be too conservative in some cases\n       ast::expr_assign(_, _) {\n         true\n@@ -1380,35 +1379,35 @@ fn need_parens(expr: &@ast::expr, outer_prec: int) -> bool {\n     }\n }\n \n-fn print_maybe_parens(s: &ps, expr: &@ast::expr, outer_prec: int) {\n+fn print_maybe_parens(s: ps, expr: @ast::expr, outer_prec: int) {\n     let add_them = need_parens(expr, outer_prec);\n     if add_them { popen(s); }\n     print_expr(s, expr);\n     if add_them { pclose(s); }\n }\n \n-fn print_mutability(s: &ps, mut: &ast::mutability) {\n+fn print_mutability(s: ps, mut: ast::mutability) {\n     alt mut {\n       ast::mut. { word_nbsp(s, \"mutable\"); }\n       ast::maybe_mut. { word_nbsp(s, \"mutable?\"); }\n       ast::imm. {/* nothing */ }\n     }\n }\n \n-fn print_mt(s: &ps, mt: &ast::mt) {\n+fn print_mt(s: ps, mt: ast::mt) {\n     print_mutability(s, mt.mut);\n     print_type(s, mt.ty);\n }\n \n-fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n-               inputs: &[ast::ty_arg], output: &@ast::ty,\n-               cf: &ast::controlflow, constrs: &[@ast::constr]) {\n+fn print_ty_fn(s: ps, proto: ast::proto, id: option::t<ast::ident>,\n+               inputs: [ast::ty_arg], output: @ast::ty, cf: ast::controlflow,\n+               constrs: [@ast::constr]) {\n     ibox(s, indent_unit);\n     word(s.s, proto_to_str(proto));\n     alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n     zerobreak(s.s);\n     popen(s);\n-    fn print_arg(s: &ps, input: &ast::ty_arg) {\n+    fn print_arg(s: ps, input: ast::ty_arg) {\n         print_alias(s, input.node.mode);\n         print_type(s, input.node.ty);\n     }\n@@ -1429,7 +1428,7 @@ fn print_ty_fn(s: &ps, proto: &ast::proto, id: &option::t<ast::ident>,\n     end(s);\n }\n \n-fn maybe_print_trailing_comment(s: &ps, span: codemap::span,\n+fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n                                 next_pos: option::t<uint>) {\n     let cm;\n     alt s.cm { some(ccm) { cm = ccm; } _ { ret; } }\n@@ -1450,7 +1449,7 @@ fn maybe_print_trailing_comment(s: &ps, span: codemap::span,\n     }\n }\n \n-fn print_remaining_comments(s: &ps) {\n+fn print_remaining_comments(s: ps) {\n     // If there aren't any remaining comments, then we need to manually\n     // make sure there is a line break at the end.\n     if option::is_none(next_comment(s)) { hardbreak(s.s); }\n@@ -1462,13 +1461,13 @@ fn print_remaining_comments(s: &ps) {\n     }\n }\n \n-fn in_cbox(s: &ps) -> bool {\n+fn in_cbox(s: ps) -> bool {\n     let len = vec::len(s.boxes);\n     if len == 0u { ret false; }\n     ret s.boxes[len - 1u] == pp::consistent;\n }\n \n-fn print_literal(s: &ps, lit: &@ast::lit) {\n+fn print_literal(s: ps, lit: @ast::lit) {\n     maybe_print_comment(s, lit.span.lo);\n     alt next_lit(s) {\n       some(lt) {\n@@ -1502,9 +1501,9 @@ fn print_literal(s: &ps, lit: &@ast::lit) {\n     }\n }\n \n-fn lit_to_str(l: &@ast::lit) -> str { be to_str(l, print_literal); }\n+fn lit_to_str(l: @ast::lit) -> str { be to_str(l, print_literal); }\n \n-fn next_lit(s: &ps) -> option::t<lexer::lit> {\n+fn next_lit(s: ps) -> option::t<lexer::lit> {\n     alt s.literals {\n       some(lits) {\n         if s.cur_lit < vec::len(lits) {\n@@ -1515,7 +1514,7 @@ fn next_lit(s: &ps) -> option::t<lexer::lit> {\n     }\n }\n \n-fn maybe_print_comment(s: &ps, pos: uint) {\n+fn maybe_print_comment(s: ps, pos: uint) {\n     while true {\n         alt next_comment(s) {\n           some(cmnt) {\n@@ -1529,7 +1528,7 @@ fn maybe_print_comment(s: &ps, pos: uint) {\n     }\n }\n \n-fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n+fn print_comment(s: ps, cmnt: lexer::cmnt) {\n     alt cmnt.style {\n       lexer::mixed. {\n         assert (vec::len(cmnt.lines) == 1u);\n@@ -1573,13 +1572,13 @@ fn print_comment(s: &ps, cmnt: lexer::cmnt) {\n     }\n }\n \n-fn print_string(s: &ps, st: &str) {\n+fn print_string(s: ps, st: str) {\n     word(s.s, \"\\\"\");\n     word(s.s, escape_str(st, '\"'));\n     word(s.s, \"\\\"\");\n }\n \n-fn escape_str(st: &str, to_escape: char) -> str {\n+fn escape_str(st: str, to_escape: char) -> str {\n     let out: str = \"\";\n     let len = str::byte_len(st);\n     let i = 0u;\n@@ -1601,15 +1600,15 @@ fn escape_str(st: &str, to_escape: char) -> str {\n     ret out;\n }\n \n-fn to_str<T>(t: &T, f: fn(&ps, &T)) -> str {\n+fn to_str<T>(t: T, f: fn(ps, T)) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n     f(s, t);\n     eof(s.s);\n     ret writer.get_str();\n }\n \n-fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n+fn next_comment(s: ps) -> option::t<lexer::cmnt> {\n     alt s.comments {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {\n@@ -1622,8 +1621,8 @@ fn next_comment(s: &ps) -> option::t<lexer::cmnt> {\n \n // Removing the aliases from the type of f in the next two functions\n // triggers memory corruption, but I haven't isolated the bug yet. FIXME\n-fn constr_args_to_str<T>(f: &fn(&T) -> str, args: &[@ast::sp_constr_arg<T>])\n-   -> str {\n+fn constr_args_to_str<T>(f: fn(T) -> str, args: [@ast::sp_constr_arg<T>]) ->\n+   str {\n     let comma = false;\n     let s = \"(\";\n     for a: @ast::sp_constr_arg<T> in args {\n@@ -1634,7 +1633,7 @@ fn constr_args_to_str<T>(f: &fn(&T) -> str, args: &[@ast::sp_constr_arg<T>])\n     ret s;\n }\n \n-fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>) ->\n+fn constr_arg_to_str<T>(f: fn(T) -> str, c: ast::constr_arg_general_<T>) ->\n    str {\n     alt c {\n       ast::carg_base. { ret \"*\"; }\n@@ -1646,15 +1645,15 @@ fn constr_arg_to_str<T>(f: &fn(&T) -> str, c: &ast::constr_arg_general_<T>) ->\n // needed b/c constr_args_to_str needs\n // something that takes an alias\n // (argh)\n-fn uint_to_str(i: &uint) -> str { ret uint::str(i); }\n+fn uint_to_str(i: uint) -> str { ret uint::str(i); }\n \n-fn ast_ty_fn_constr_to_str(c: &@ast::constr) -> str {\n+fn ast_ty_fn_constr_to_str(c: @ast::constr) -> str {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(uint_to_str, c.node.args);\n }\n \n // FIXME: fix repeated code\n-fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n+fn ast_ty_fn_constrs_str(constrs: [@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n@@ -1664,18 +1663,18 @@ fn ast_ty_fn_constrs_str(constrs: &[@ast::constr]) -> str {\n     ret s;\n }\n \n-fn fn_arg_idx_to_str(decl: &ast::fn_decl, idx: &uint) -> str {\n+fn fn_arg_idx_to_str(decl: ast::fn_decl, idx: uint) -> str {\n     decl.inputs[idx].ident\n }\n \n-fn ast_fn_constr_to_str(decl: &ast::fn_decl, c: &@ast::constr) -> str {\n+fn ast_fn_constr_to_str(decl: ast::fn_decl, c: @ast::constr) -> str {\n     let arg_to_str = bind fn_arg_idx_to_str(decl, _);\n     ret path_to_str(c.node.path) +\n             constr_args_to_str(arg_to_str, c.node.args);\n }\n \n // FIXME: fix repeated code\n-fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> str {\n+fn ast_fn_constrs_str(decl: ast::fn_decl, constrs: [@ast::constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::constr in constrs {\n@@ -1685,7 +1684,7 @@ fn ast_fn_constrs_str(decl: &ast::fn_decl, constrs: &[@ast::constr]) -> str {\n     ret s;\n }\n \n-fn proto_to_str(p: &ast::proto) -> str {\n+fn proto_to_str(p: ast::proto) -> str {\n     ret alt p {\n           ast::proto_fn. { \"fn\" }\n           ast::proto_iter. { \"iter\" }\n@@ -1694,16 +1693,16 @@ fn proto_to_str(p: &ast::proto) -> str {\n         };\n }\n \n-fn ty_constr_to_str(c: &@ast::ty_constr) -> str {\n-    fn ty_constr_path_to_str(p: &ast::path) -> str { \"*.\" + path_to_str(p) }\n+fn ty_constr_to_str(c: @ast::ty_constr) -> str {\n+    fn ty_constr_path_to_str(p: ast::path) -> str { \"*.\" + path_to_str(p) }\n \n     ret path_to_str(c.node.path) +\n             constr_args_to_str::<ast::path>(ty_constr_path_to_str,\n                                             c.node.args);\n }\n \n \n-fn ast_ty_constrs_str(constrs: &[@ast::ty_constr]) -> str {\n+fn ast_ty_constrs_str(constrs: [@ast::ty_constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @ast::ty_constr in constrs {"}, {"sha": "7261c357940a54a14049868aac6f614466d13c68", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -21,7 +21,7 @@ fn mk<@T>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n     ret {map: m, mutable vect: [], hasher: hasher, eqer: eqer};\n }\n \n-fn intern<@T>(itr: &interner<T>, val: &T) -> uint {\n+fn intern<@T>(itr: interner<T>, val: T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n       none. {\n@@ -33,7 +33,7 @@ fn intern<@T>(itr: &interner<T>, val: &T) -> uint {\n     }\n }\n \n-fn get<@T>(itr: &interner<T>, idx: uint) -> T { ret itr.vect[idx]; }\n+fn get<@T>(itr: interner<T>, idx: uint) -> T { ret itr.vect[idx]; }\n \n-fn len<T>(itr: &interner<T>) -> uint { ret vec::len(itr.vect); }\n+fn len<T>(itr: interner<T>) -> uint { ret vec::len(itr.vect); }\n "}, {"sha": "e4d0abb8f19f476a903e98abfb263634eb4f9999", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -19,20 +19,20 @@ tag vt<E> { mk_vt(visitor<E>); }\n type visitor<E> =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n-    @{visit_mod: fn(&_mod, &span, &E, &vt<E>),\n-      visit_view_item: fn(&@view_item, &E, &vt<E>),\n-      visit_native_item: fn(&@native_item, &E, &vt<E>),\n-      visit_item: fn(&@item, &E, &vt<E>),\n-      visit_local: fn(&@local, &E, &vt<E>),\n-      visit_block: fn(&ast::blk, &E, &vt<E>),\n-      visit_stmt: fn(&@stmt, &E, &vt<E>),\n-      visit_arm: fn(&arm, &E, &vt<E>),\n-      visit_pat: fn(&@pat, &E, &vt<E>),\n-      visit_decl: fn(&@decl, &E, &vt<E>),\n-      visit_expr: fn(&@expr, &E, &vt<E>),\n-      visit_ty: fn(&@ty, &E, &vt<E>),\n-      visit_constr: fn(&path, &span, node_id, &E, &vt<E>),\n-      visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id, &E, &vt<E>)};\n+    @{visit_mod: fn(_mod, span, E, vt<E>),\n+      visit_view_item: fn(@view_item, E, vt<E>),\n+      visit_native_item: fn(@native_item, E, vt<E>),\n+      visit_item: fn(@item, E, vt<E>),\n+      visit_local: fn(@local, E, vt<E>),\n+      visit_block: fn(ast::blk, E, vt<E>),\n+      visit_stmt: fn(@stmt, E, vt<E>),\n+      visit_arm: fn(arm, E, vt<E>),\n+      visit_pat: fn(@pat, E, vt<E>),\n+      visit_decl: fn(@decl, E, vt<E>),\n+      visit_expr: fn(@expr, E, vt<E>),\n+      visit_ty: fn(@ty, E, vt<E>),\n+      visit_constr: fn(path, span, node_id, E, vt<E>),\n+      visit_fn: fn(_fn, [ty_param], span, fn_ident, node_id, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod::<E>(_, _, _, _),\n@@ -51,11 +51,11 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _)};\n }\n \n-fn visit_crate<E>(c: &crate, e: &E, v: &vt<E>) {\n+fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n     v.visit_mod(c.node.module, c.span, e, v);\n }\n \n-fn visit_crate_directive<E>(cd: &@crate_directive, e: &E, v: &vt<E>) {\n+fn visit_crate_directive<E>(cd: @crate_directive, e: E, v: vt<E>) {\n     alt cd.node {\n       cdir_src_mod(_, _, _) { }\n       cdir_dir_mod(_, _, cdirs, _) {\n@@ -69,20 +69,20 @@ fn visit_crate_directive<E>(cd: &@crate_directive, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_mod<E>(m: &_mod, _sp: &span, e: &E, v: &vt<E>) {\n+fn visit_mod<E>(m: _mod, _sp: span, e: E, v: vt<E>) {\n     for vi: @view_item in m.view_items { v.visit_view_item(vi, e, v); }\n     for i: @item in m.items { v.visit_item(i, e, v); }\n }\n \n-fn visit_view_item<E>(_vi: &@view_item, _e: &E, _v: &vt<E>) { }\n+fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n \n-fn visit_local<E>(loc: &@local, e: &E, v: &vt<E>) {\n+fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n     alt loc.node.init { none. { } some(i) { v.visit_expr(i.expr, e, v); } }\n }\n \n-fn visit_item<E>(i: &@item, e: &E, v: &vt<E>) {\n+fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(f, tp) { v.visit_fn(f, tp, i.span, some(i.ident), i.id, e, v); }\n@@ -110,7 +110,7 @@ fn visit_item<E>(i: &@item, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n+fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n     alt t.node {\n       ty_nil. {/* no-op */ }\n       ty_bot. {/* no-op */ }\n@@ -156,12 +156,12 @@ fn visit_ty<E>(t: &@ty, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_constr<E>(_operator: &path, _sp: &span, _id: node_id, _e: &E,\n-                   _v: &vt<E>) {\n+fn visit_constr<E>(_operator: path, _sp: span, _id: node_id, _e: E,\n+                   _v: vt<E>) {\n     // default\n }\n \n-fn visit_pat<E>(p: &@pat, e: &E, v: &vt<E>) {\n+fn visit_pat<E>(p: @pat, e: E, v: vt<E>) {\n     alt p.node {\n       pat_tag(path, children) {\n         for tp: @ty in path.node.types { v.visit_ty(tp, e, v); }\n@@ -176,41 +176,41 @@ fn visit_pat<E>(p: &@pat, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_native_item<E>(ni: &@native_item, e: &E, v: &vt<E>) {\n+fn visit_native_item<E>(ni: @native_item, e: E, v: vt<E>) {\n     alt ni.node {\n       native_item_fn(_, fd, _) { visit_fn_decl(fd, e, v); }\n       native_item_ty. { }\n     }\n }\n \n-fn visit_fn_decl<E>(fd: &fn_decl, e: &E, v: &vt<E>) {\n+fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     for a: arg in fd.inputs { v.visit_ty(a.ty, e, v); }\n     for c: @constr in fd.constraints {\n         v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n     }\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn<E>(f: &_fn, _tp: &[ty_param], _sp: &span, _i: &fn_ident,\n-               _id: node_id, e: &E, v: &vt<E>) {\n+fn visit_fn<E>(f: _fn, _tp: [ty_param], _sp: span, _i: fn_ident, _id: node_id,\n+               e: E, v: vt<E>) {\n     visit_fn_decl(f.decl, e, v);\n     v.visit_block(f.body, e, v);\n }\n \n-fn visit_block<E>(b: &ast::blk, e: &E, v: &vt<E>) {\n+fn visit_block<E>(b: ast::blk, e: E, v: vt<E>) {\n     for s: @stmt in b.node.stmts { v.visit_stmt(s, e, v); }\n     visit_expr_opt(b.node.expr, e, v);\n }\n \n-fn visit_stmt<E>(s: &@stmt, e: &E, v: &vt<E>) {\n+fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n     alt s.node {\n       stmt_decl(d, _) { v.visit_decl(d, e, v); }\n       stmt_expr(ex, _) { v.visit_expr(ex, e, v); }\n       stmt_crate_directive(cd) { visit_crate_directive(cd, e, v); }\n     }\n }\n \n-fn visit_decl<E>(d: &@decl, e: &E, v: &vt<E>) {\n+fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n     alt d.node {\n       decl_local(locs) {\n         for loc: @ast::local in locs { v.visit_local(loc, e, v); }\n@@ -219,15 +219,15 @@ fn visit_decl<E>(d: &@decl, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_expr_opt<E>(eo: option::t<@expr>, e: &E, v: &vt<E>) {\n+fn visit_expr_opt<E>(eo: option::t<@expr>, e: E, v: vt<E>) {\n     alt eo { none. { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n-fn visit_exprs<E>(exprs: &[@expr], e: &E, v: &vt<E>) {\n+fn visit_exprs<E>(exprs: [@expr], e: E, v: vt<E>) {\n     for ex: @expr in exprs { v.visit_expr(ex, e, v); }\n }\n \n-fn visit_mac<E>(m: mac, e: &E, v: &vt<E>) {\n+fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n     alt m.node {\n       ast::mac_invoc(pth, arg, body) { visit_expr(arg, e, v); }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n@@ -236,7 +236,7 @@ fn visit_mac<E>(m: mac, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n+fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n     alt ex.node {\n       expr_vec(es, _) { visit_exprs(es, e, v); }\n       expr_rec(flds, base) {\n@@ -329,7 +329,7 @@ fn visit_expr<E>(ex: &@expr, e: &E, v: &vt<E>) {\n     }\n }\n \n-fn visit_arm<E>(a: &arm, e: &E, v: &vt<E>) {\n+fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n     for p: @pat in a.pats { v.visit_pat(p, e, v); }\n     visit_expr_opt(a.guard, e, v);\n     v.visit_block(a.body, e, v);\n@@ -341,99 +341,99 @@ fn visit_arm<E>(a: &arm, e: &E, v: &vt<E>) {\n type simple_visitor =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n-    @{visit_mod: fn(&_mod, &span),\n-      visit_view_item: fn(&@view_item),\n-      visit_native_item: fn(&@native_item),\n-      visit_item: fn(&@item),\n-      visit_local: fn(&@local),\n-      visit_block: fn(&ast::blk),\n-      visit_stmt: fn(&@stmt),\n-      visit_arm: fn(&arm),\n-      visit_pat: fn(&@pat),\n-      visit_decl: fn(&@decl),\n-      visit_expr: fn(&@expr),\n-      visit_ty: fn(&@ty),\n-      visit_constr: fn(&path, &span, node_id),\n-      visit_fn: fn(&_fn, &[ty_param], &span, &fn_ident, node_id)};\n+    @{visit_mod: fn(_mod, span),\n+      visit_view_item: fn(@view_item),\n+      visit_native_item: fn(@native_item),\n+      visit_item: fn(@item),\n+      visit_local: fn(@local),\n+      visit_block: fn(ast::blk),\n+      visit_stmt: fn(@stmt),\n+      visit_arm: fn(arm),\n+      visit_pat: fn(@pat),\n+      visit_decl: fn(@decl),\n+      visit_expr: fn(@expr),\n+      visit_ty: fn(@ty),\n+      visit_constr: fn(path, span, node_id),\n+      visit_fn: fn(_fn, [ty_param], span, fn_ident, node_id)};\n \n fn default_simple_visitor() -> simple_visitor {\n-    ret @{visit_mod: fn (_m: &_mod, _sp: &span) { },\n-          visit_view_item: fn (_vi: &@view_item) { },\n-          visit_native_item: fn (_ni: &@native_item) { },\n-          visit_item: fn (_i: &@item) { },\n-          visit_local: fn (_l: &@local) { },\n-          visit_block: fn (_b: &ast::blk) { },\n-          visit_stmt: fn (_s: &@stmt) { },\n-          visit_arm: fn (_a: &arm) { },\n-          visit_pat: fn (_p: &@pat) { },\n-          visit_decl: fn (_d: &@decl) { },\n-          visit_expr: fn (_e: &@expr) { },\n-          visit_ty: fn (_t: &@ty) { },\n-          visit_constr: fn (_p: &path, _sp: &span, _id: node_id) { },\n+    ret @{visit_mod: fn (_m: _mod, _sp: span) { },\n+          visit_view_item: fn (_vi: @view_item) { },\n+          visit_native_item: fn (_ni: @native_item) { },\n+          visit_item: fn (_i: @item) { },\n+          visit_local: fn (_l: @local) { },\n+          visit_block: fn (_b: ast::blk) { },\n+          visit_stmt: fn (_s: @stmt) { },\n+          visit_arm: fn (_a: arm) { },\n+          visit_pat: fn (_p: @pat) { },\n+          visit_decl: fn (_d: @decl) { },\n+          visit_expr: fn (_e: @expr) { },\n+          visit_ty: fn (_t: @ty) { },\n+          visit_constr: fn (_p: path, _sp: span, _id: node_id) { },\n           visit_fn:\n-              fn (_f: &_fn, _tps: &[ty_param], _sp: &span, _ident: &fn_ident,\n+              fn (_f: _fn, _tps: [ty_param], _sp: span, _ident: fn_ident,\n                   _id: node_id) {\n               }};\n }\n \n-fn mk_simple_visitor(v: &simple_visitor) -> vt<()> {\n-    fn v_mod(f: fn(&_mod, &span), m: &_mod, sp: &span, e: &(), v: &vt<()>) {\n+fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n+    fn v_mod(f: fn(_mod, span), m: _mod, sp: span, e: (), v: vt<()>) {\n         f(m, sp);\n         visit_mod(m, sp, e, v);\n     }\n-    fn v_view_item(f: fn(&@view_item), vi: &@view_item, e: &(), v: &vt<()>) {\n+    fn v_view_item(f: fn(@view_item), vi: @view_item, e: (), v: vt<()>) {\n         f(vi);\n         visit_view_item(vi, e, v);\n     }\n-    fn v_native_item(f: fn(&@native_item), ni: &@native_item, e: &(),\n-                     v: &vt<()>) {\n+    fn v_native_item(f: fn(@native_item), ni: @native_item, e: (),\n+                     v: vt<()>) {\n         f(ni);\n         visit_native_item(ni, e, v);\n     }\n-    fn v_item(f: fn(&@item), i: &@item, e: &(), v: &vt<()>) {\n+    fn v_item(f: fn(@item), i: @item, e: (), v: vt<()>) {\n         f(i);\n         visit_item(i, e, v);\n     }\n-    fn v_local(f: fn(&@local), l: &@local, e: &(), v: &vt<()>) {\n+    fn v_local(f: fn(@local), l: @local, e: (), v: vt<()>) {\n         f(l);\n         visit_local(l, e, v);\n     }\n-    fn v_block(f: fn(&ast::blk), bl: &ast::blk, e: &(), v: &vt<()>) {\n+    fn v_block(f: fn(ast::blk), bl: ast::blk, e: (), v: vt<()>) {\n         f(bl);\n         visit_block(bl, e, v);\n     }\n-    fn v_stmt(f: fn(&@stmt), st: &@stmt, e: &(), v: &vt<()>) {\n+    fn v_stmt(f: fn(@stmt), st: @stmt, e: (), v: vt<()>) {\n         f(st);\n         visit_stmt(st, e, v);\n     }\n-    fn v_arm(f: fn(&arm), a: &arm, e: &(), v: &vt<()>) {\n+    fn v_arm(f: fn(arm), a: arm, e: (), v: vt<()>) {\n         f(a);\n         visit_arm(a, e, v);\n     }\n-    fn v_pat(f: fn(&@pat), p: &@pat, e: &(), v: &vt<()>) {\n+    fn v_pat(f: fn(@pat), p: @pat, e: (), v: vt<()>) {\n         f(p);\n         visit_pat(p, e, v);\n     }\n-    fn v_decl(f: fn(&@decl), d: &@decl, e: &(), v: &vt<()>) {\n+    fn v_decl(f: fn(@decl), d: @decl, e: (), v: vt<()>) {\n         f(d);\n         visit_decl(d, e, v);\n     }\n-    fn v_expr(f: fn(&@expr), ex: &@expr, e: &(), v: &vt<()>) {\n+    fn v_expr(f: fn(@expr), ex: @expr, e: (), v: vt<()>) {\n         f(ex);\n         visit_expr(ex, e, v);\n     }\n-    fn v_ty(f: fn(&@ty), ty: &@ty, e: &(), v: &vt<()>) {\n+    fn v_ty(f: fn(@ty), ty: @ty, e: (), v: vt<()>) {\n         f(ty);\n         visit_ty(ty, e, v);\n     }\n-    fn v_constr(f: fn(&path, &span, node_id), pt: &path, sp: &span,\n-                id: node_id, e: &(), v: &vt<()>) {\n+    fn v_constr(f: fn(path, span, node_id), pt: path, sp: span, id: node_id,\n+                e: (), v: vt<()>) {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n-    fn v_fn(f: fn(&_fn, &[ty_param], &span, &fn_ident, node_id), ff: &_fn,\n-            tps: &[ty_param], sp: &span, ident: &fn_ident, id: node_id,\n-            e: &(), v: &vt<()>) {\n+    fn v_fn(f: fn(_fn, [ty_param], span, fn_ident, node_id), ff: _fn,\n+            tps: [ty_param], sp: span, ident: fn_ident, id: node_id, e: (),\n+            v: vt<()>) {\n         f(ff, tps, sp, ident, id);\n         visit_fn(ff, tps, sp, ident, id, e, v);\n     }"}, {"sha": "81cafb0648efbfe455763aaf3b814907647a1959", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -30,11 +30,11 @@ import print::pp::mk_printer;\n \n type flag = hashmap<str, ()>;\n \n-fn def_eq(a: &ast::def_id, b: &ast::def_id) -> bool {\n+fn def_eq(a: ast::def_id, b: ast::def_id) -> bool {\n     ret a.crate == b.crate && a.node == b.node;\n }\n \n-fn hash_def(d: &ast::def_id) -> uint {\n+fn hash_def(d: ast::def_id) -> uint {\n     let h = 5381u;\n     h = (h << 5u) + h ^ (d.crate as uint);\n     h = (h << 5u) + h ^ (d.node as uint);\n@@ -47,43 +47,43 @@ fn new_def_hash<@V>() -> std::map::hashmap<ast::def_id, V> {\n     ret std::map::mk_hashmap::<ast::def_id, V>(hasher, eqer);\n }\n \n-fn field_expr(f: &ast::field) -> @ast::expr { ret f.node.expr; }\n+fn field_expr(f: ast::field) -> @ast::expr { ret f.node.expr; }\n \n-fn field_exprs(fields: &[ast::field]) -> [@ast::expr] {\n+fn field_exprs(fields: [ast::field]) -> [@ast::expr] {\n     let es = [];\n     for f: ast::field in fields { es += [f.node.expr]; }\n     ret es;\n }\n \n-fn log_expr(e: &ast::expr) { log print::pprust::expr_to_str(@e); }\n+fn log_expr(e: ast::expr) { log print::pprust::expr_to_str(@e); }\n \n-fn log_expr_err(e: &ast::expr) { log_err print::pprust::expr_to_str(@e); }\n+fn log_expr_err(e: ast::expr) { log_err print::pprust::expr_to_str(@e); }\n \n-fn log_ty_err(t: &@ty) { log_err print::pprust::ty_to_str(t); }\n+fn log_ty_err(t: @ty) { log_err print::pprust::ty_to_str(t); }\n \n-fn log_pat_err(p: &@pat) { log_err print::pprust::pat_to_str(p); }\n+fn log_pat_err(p: @pat) { log_err print::pprust::pat_to_str(p); }\n \n-fn log_block(b: &ast::blk) { log print::pprust::block_to_str(b); }\n+fn log_block(b: ast::blk) { log print::pprust::block_to_str(b); }\n \n-fn log_block_err(b: &ast::blk) { log_err print::pprust::block_to_str(b); }\n+fn log_block_err(b: ast::blk) { log_err print::pprust::block_to_str(b); }\n \n-fn log_item_err(i: &@ast::item) { log_err print::pprust::item_to_str(i); }\n+fn log_item_err(i: @ast::item) { log_err print::pprust::item_to_str(i); }\n \n-fn log_fn(f: &ast::_fn, name: &ast::ident, params: &[ast::ty_param]) {\n+fn log_fn(f: ast::_fn, name: ast::ident, params: [ast::ty_param]) {\n     log print::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_fn_err(f: &ast::_fn, name: &ast::ident, params: &[ast::ty_param]) {\n+fn log_fn_err(f: ast::_fn, name: ast::ident, params: [ast::ty_param]) {\n     log_err print::pprust::fun_to_str(f, name, params);\n }\n \n-fn log_stmt(st: &ast::stmt) { log print::pprust::stmt_to_str(st); }\n+fn log_stmt(st: ast::stmt) { log print::pprust::stmt_to_str(st); }\n \n-fn log_stmt_err(st: &ast::stmt) { log_err print::pprust::stmt_to_str(st); }\n+fn log_stmt_err(st: ast::stmt) { log_err print::pprust::stmt_to_str(st); }\n \n-fn has_nonlocal_exits(b: &ast::blk) -> bool {\n+fn has_nonlocal_exits(b: ast::blk) -> bool {\n     let has_exits = @mutable false;\n-    fn visit_expr(flag: @mutable bool, e: &@ast::expr) {\n+    fn visit_expr(flag: @mutable bool, e: @ast::expr) {\n         alt e.node {\n           ast::expr_break. { *flag = true; }\n           ast::expr_cont. { *flag = true; }\n@@ -97,11 +97,11 @@ fn has_nonlocal_exits(b: &ast::blk) -> bool {\n     ret *has_exits;\n }\n \n-fn local_rhs_span(l: &@ast::local, def: &span) -> span {\n+fn local_rhs_span(l: @ast::local, def: span) -> span {\n     alt l.node.init { some(i) { ret i.expr.span; } _ { ret def; } }\n }\n \n-fn lit_eq(l: &@ast::lit, m: &@ast::lit) -> bool {\n+fn lit_eq(l: @ast::lit, m: @ast::lit) -> bool {\n     alt l.node {\n       ast::lit_str(s) {\n         alt m.node { ast::lit_str(t) { ret s == t } _ { ret false; } }\n@@ -150,7 +150,7 @@ fn call_kind_str(c: call_kind) -> str {\n     }\n }\n \n-fn is_main_name(path: &[ast::ident]) -> bool {\n+fn is_main_name(path: [ast::ident]) -> bool {\n     str::eq(option::get(std::vec::last(path)), \"main\")\n }\n "}, {"sha": "51500ef2b114f3bbeb6be4e4101cb39de812363f", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -21,23 +21,23 @@ import syntax::ast;\n import middle::ast_map;\n import metadata::csearch;\n \n-fn mode_str(m: &ty::mode) -> str {\n+fn mode_str(m: ty::mode) -> str {\n     alt m {\n       ast::by_ref. { \"\" }\n       ast::by_mut_ref. { \"&\" }\n       ast::by_move. { \"-\" }\n     }\n }\n \n-fn mode_str_1(m: &ty::mode) -> str {\n+fn mode_str_1(m: ty::mode) -> str {\n     alt m { ast::by_ref. { \"ref\" } _ { mode_str(m) } }\n }\n \n-fn fn_ident_to_string(id: ast::node_id, i: &ast::fn_ident) -> str {\n+fn fn_ident_to_string(id: ast::node_id, i: ast::fn_ident) -> str {\n     ret alt i { none. { \"anon\" + int::str(id) } some(s) { s } };\n }\n \n-fn get_id_ident(cx: &ctxt, id: ast::def_id) -> str {\n+fn get_id_ident(cx: ctxt, id: ast::def_id) -> str {\n     if id.crate != ast::local_crate {\n         alt cx.ext_map.find(id) {\n           some(j) { str::connect(j, \"::\") }\n@@ -54,15 +54,15 @@ fn get_id_ident(cx: &ctxt, id: ast::def_id) -> str {\n     }\n }\n \n-fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n-    fn fn_input_to_str(cx: &ctxt, input: &{mode: middle::ty::mode, ty: t}) ->\n+fn ty_to_str(cx: ctxt, typ: t) -> str {\n+    fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n        str {\n         let s = mode_str(input.mode);\n         ret s + ty_to_str(cx, input.ty);\n     }\n-    fn fn_to_str(cx: &ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n-                 inputs: &[arg], output: t, cf: ast::controlflow,\n-                 constrs: &[@constr]) -> str {\n+    fn fn_to_str(cx: ctxt, proto: ast::proto, ident: option::t<ast::ident>,\n+                 inputs: [arg], output: t, cf: ast::controlflow,\n+                 constrs: [@constr]) -> str {\n         let s = proto_to_str(proto);\n         alt ident { some(i) { s += \" \"; s += i; } _ { } }\n         s += \"(\";\n@@ -79,14 +79,14 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         s += constrs_str(constrs);\n         ret s;\n     }\n-    fn method_to_str(cx: &ctxt, m: &method) -> str {\n+    fn method_to_str(cx: ctxt, m: method) -> str {\n         ret fn_to_str(cx, m.proto, some::<ast::ident>(m.ident), m.inputs,\n                       m.output, m.cf, m.constrs) + \";\";\n     }\n-    fn field_to_str(cx: &ctxt, f: &field) -> str {\n+    fn field_to_str(cx: ctxt, f: field) -> str {\n         ret f.ident + \": \" + mt_to_str(cx, f.mt);\n     }\n-    fn mt_to_str(cx: &ctxt, m: &mt) -> str {\n+    fn mt_to_str(cx: ctxt, m: mt) -> str {\n         let mstr;\n         alt m.mut {\n           ast::mut. { mstr = \"mutable \"; }\n@@ -151,18 +151,18 @@ fn ty_to_str(cx: &ctxt, typ: &t) -> str {\n         }\n }\n \n-fn ty_to_short_str(cx: &ctxt, typ: t) -> str {\n+fn ty_to_short_str(cx: ctxt, typ: t) -> str {\n     let s = encoder::encoded_ty(cx, typ);\n     if str::byte_len(s) >= 32u { s = str::substr(s, 0u, 32u); }\n     ret s;\n }\n \n-fn constr_to_str(c: &@constr) -> str {\n+fn constr_to_str(c: @constr) -> str {\n     ret path_to_str(c.node.path) +\n             pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n }\n \n-fn constrs_str(constrs: &[@constr]) -> str {\n+fn constrs_str(constrs: [@constr]) -> str {\n     let s = \"\";\n     let colon = true;\n     for c: @constr in constrs {\n@@ -172,7 +172,7 @@ fn constrs_str(constrs: &[@constr]) -> str {\n     ret s;\n }\n \n-fn ty_constr_to_str<Q>(c: &@ast::spanned<ast::constr_general_<ast::path, Q>>)\n+fn ty_constr_to_str<Q>(c: @ast::spanned<ast::constr_general_<ast::path, Q>>)\n    -> str {\n     ret path_to_str(c.node.path) +\n             constr_args_to_str::<ast::path>(path_to_str, c.node.args);"}, {"sha": "e8cad5edce5956468d2f0566e93fab5b432c3d92", "filename": "src/fuzzer/ast_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ffuzzer%2Fast_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ffuzzer%2Fast_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fast_match.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,8 +1,8 @@\n use std;\n import std::vec;\n \n-fn vec_equal<T>(v: &[T], u: &[T], element_equality_test: fn(&T, &T) -> bool)\n-   -> bool {\n+fn vec_equal<T>(v: [T], u: [T], element_equality_test: fn(T, T) -> bool) ->\n+   bool {\n     let Lv = vec::len(v);\n     if Lv != vec::len(u) { ret false; }\n     let i = 0u;\n@@ -13,7 +13,7 @@ fn vec_equal<T>(v: &[T], u: &[T], element_equality_test: fn(&T, &T) -> bool)\n     ret true;\n }\n \n-fn builtin_equal<T>(a: &T, b: &T) -> bool { ret a == b; }\n+fn builtin_equal<T>(a: T, b: T) -> bool { ret a == b; }\n \n fn main() {\n     assert (builtin_equal(5, 5));"}, {"sha": "95efec083f3d358e3c699d170bcc7c849c3972d4", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -20,22 +20,22 @@ import rustc::syntax::codemap;\n import rustc::syntax::parse::parser;\n import rustc::syntax::print::pprust;\n \n-fn write_file(filename: &str, content: &str) {\n+fn write_file(filename: str, content: str) {\n     io::file_writer(filename, [io::create, io::truncate]).write_str(content);\n     // Work around https://github.com/graydon/rust/issues/726\n     std::run::run_program(\"chmod\", [\"644\", filename]);\n }\n \n-fn file_contains(filename: &str, needle: &str) -> bool {\n+fn file_contains(filename: str, needle: str) -> bool {\n     let contents = io::read_whole_file_str(filename);\n     ret str::find(contents, needle) != -1;\n }\n \n-fn contains(haystack: &str, needle: &str) -> bool {\n+fn contains(haystack: str, needle: str) -> bool {\n     str::find(haystack, needle) != -1\n }\n \n-fn find_rust_files(files: &mutable [str], path: &str) {\n+fn find_rust_files(files: &[str], path: str) {\n     if str::ends_with(path, \".rs\") {\n         if file_contains(path, \"xfail-test\") {\n             //log_err \"Skipping \" + path + \" because it is marked as xfail-test\";\n@@ -48,7 +48,7 @@ fn find_rust_files(files: &mutable [str], path: &str) {\n     }\n }\n \n-fn safe_to_steal_expr(e: &@ast::expr) -> bool {\n+fn safe_to_steal_expr(e: @ast::expr) -> bool {\n     alt e.node {\n \n       // https://github.com/graydon/rust/issues/890\n@@ -89,27 +89,27 @@ fn safe_to_steal_expr(e: &@ast::expr) -> bool {\n     }\n }\n \n-fn safe_to_steal_ty(t: &@ast::ty) -> bool {\n+fn safe_to_steal_ty(t: @ast::ty) -> bool {\n     // Same restrictions\n     safe_to_replace_ty(t.node)\n }\n \n // Not type-parameterized: https://github.com/graydon/rust/issues/898\n-fn stash_expr_if(c: fn(&@ast::expr)->bool, es: @mutable [ast::expr], e: &@ast::expr) {\n+fn stash_expr_if(c: fn(@ast::expr)->bool, es: @mutable [ast::expr], e: @ast::expr) {\n     if c(e) {\n         *es += [*e];\n     } else {/* now my indices are wrong :( */ }\n }\n \n-fn stash_ty_if(c: fn(&@ast::ty)->bool, es: @mutable [ast::ty], e: &@ast::ty) {\n+fn stash_ty_if(c: fn(@ast::ty)->bool, es: @mutable [ast::ty], e: @ast::ty) {\n     if c(e) {\n         *es += [*e];\n     } else {/* now my indices are wrong :( */ }\n }\n \n type stolen_stuff = {exprs: [ast::expr], tys: [ast::ty]};\n \n-fn steal(crate: &ast::crate) -> stolen_stuff {\n+fn steal(crate: ast::crate) -> stolen_stuff {\n     let exprs = @mutable [];\n     let tys = @mutable [];\n     let v = visit::mk_simple_visitor(@{\n@@ -140,11 +140,11 @@ fn safe_to_replace_ty(t: ast::ty_) -> bool {\n }\n \n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: &ast::crate, i: uint, newexpr: &ast::expr) ->\n+fn replace_expr_in_crate(crate: ast::crate, i: uint, newexpr: ast::expr) ->\n    ast::crate {\n     let j: @mutable uint = @mutable 0u;\n-    fn fold_expr_rep(j_: @mutable uint, i_: uint, newexpr_: &ast::expr_,\n-                     original: &ast::expr_, fld: fold::ast_fold) ->\n+    fn fold_expr_rep(j_: @mutable uint, i_: uint, newexpr_: ast::expr_,\n+                     original: ast::expr_, fld: fold::ast_fold) ->\n        ast::expr_ {\n         *j_ += 1u;\n         if i_ + 1u == *j_ && safe_to_replace_expr(original) {\n@@ -161,11 +161,11 @@ fn replace_expr_in_crate(crate: &ast::crate, i: uint, newexpr: &ast::expr) ->\n }\n \n // Replace the |i|th ty (in fold order) of |crate| with |newty|.\n-fn replace_ty_in_crate(crate: &ast::crate, i: uint, newty: &ast::ty) ->\n+fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty) ->\n    ast::crate {\n     let j: @mutable uint = @mutable 0u;\n-    fn fold_ty_rep(j_: @mutable uint, i_: uint, newty_: &ast::ty_,\n-                     original: &ast::ty_, fld: fold::ast_fold) ->\n+    fn fold_ty_rep(j_: @mutable uint, i_: uint, newty_: ast::ty_,\n+                     original: ast::ty_, fld: fold::ast_fold) ->\n        ast::ty_ {\n         *j_ += 1u;\n         if i_ + 1u == *j_ && safe_to_replace_ty(original) {\n@@ -194,21 +194,21 @@ fn as_str(f: fn(io::writer)) -> str {\n     ret w.get_str();\n }\n \n-fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n-                         filename: &str) {\n+fn check_variants_of_ast(crate: ast::crate, codemap: codemap::codemap,\n+                         filename: str) {\n     let stolen = steal(crate);\n     check_variants_T(crate, codemap, filename, \"expr\", stolen.exprs, pprust::expr_to_str, replace_expr_in_crate);\n     check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate);\n }\n \n fn check_variants_T<T>(\n-  crate: &ast::crate,\n-  codemap: &codemap::codemap,\n-  filename: &str,\n-  thing_label: &str,\n+  crate: ast::crate,\n+  codemap: codemap::codemap,\n+  filename: str,\n+  thing_label: str,\n   things: [T],\n-  stringifier: fn(&@T) -> str,\n-  replacer: fn(&ast::crate, uint, &T) -> ast::crate\n+  stringifier: fn(@T) -> str,\n+  replacer: fn(ast::crate, uint, T) -> ast::crate\n   ) {\n     log_err #fmt(\"%s contains %u %s objects\", filename, vec::len(things), thing_label);\n \n@@ -235,7 +235,7 @@ fn check_variants_T<T>(\n     }\n }\n \n-fn last_part(filename: &str) -> str {\n+fn last_part(filename: str) -> str {\n   let ix = str::rindex(filename, 47u8 /* '/' */);\n   assert ix >= 0;\n   str::slice(filename, ix as uint + 1u, str::byte_len(filename) - 3u)\n@@ -247,7 +247,7 @@ tag compile_result { known_bug(str); passed(str); failed(str); }\n // - that would find many \"false positives\" or unimportant bugs\n // - that would be tricky, requiring use of tasks or serialization or randomness.\n // This seems to find plenty of bugs as it is :)\n-fn check_whole_compiler(code: &str, suggested_filename: &str) {\n+fn check_whole_compiler(code: str, suggested_filename: str) {\n     let filename = \"test.rs\";\n     write_file(filename, code);\n     alt check_whole_compiler_inner(filename) {\n@@ -263,7 +263,7 @@ fn check_whole_compiler(code: &str, suggested_filename: &str) {\n     }\n }\n \n-fn check_whole_compiler_inner(filename: &str) -> compile_result {\n+fn check_whole_compiler_inner(filename: str) -> compile_result {\n     let p = std::run::program_output(\n             \"/Users/jruderman/code/rust/build/stage1/rustc\",\n             [\"-c\", filename]);\n@@ -312,7 +312,7 @@ fn check_whole_compiler_inner(filename: &str) -> compile_result {\n }\n \n \n-fn parse_and_print(code: &str) -> str {\n+fn parse_and_print(code: str) -> str {\n     let filename = \"tmp.rs\";\n     let sess = @{cm: codemap::new_codemap(), mutable next_id: 0};\n     //write_file(filename, code);\n@@ -324,7 +324,7 @@ fn parse_and_print(code: &str) -> str {\n                                         pprust::no_ann()));\n }\n \n-fn content_is_dangerous_to_modify(code: &str) -> bool {\n+fn content_is_dangerous_to_modify(code: str) -> bool {\n     let dangerous_patterns =\n         [\"#macro\", // not safe to steal things inside of it, because they have a special syntax\n          \"#\",      // strange representation of the arguments to #fmt, for example\n@@ -335,7 +335,7 @@ fn content_is_dangerous_to_modify(code: &str) -> bool {\n     ret false;\n }\n \n-fn content_is_confusing(code: &str) -> bool {\n+fn content_is_confusing(code: str) -> bool {\n     let confusing_patterns =\n         [\"self\",       // crazy rules enforced by parser rather than typechecker?\n         \"spawn\",       // precedence issues?\n@@ -347,15 +347,15 @@ fn content_is_confusing(code: &str) -> bool {\n     ret false;\n }\n \n-fn file_is_confusing(filename: &str) -> bool {\n+fn file_is_confusing(filename: str) -> bool {\n     let confusing_files = [];\n \n     for f in confusing_files { if contains(filename, f) { ret true; } }\n \n     ret false;\n }\n \n-fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n+fn check_roundtrip_convergence(code: str, maxIters: uint) {\n \n     let i = 0u;\n     let new = code;\n@@ -382,7 +382,7 @@ fn check_roundtrip_convergence(code: &str, maxIters: uint) {\n     }\n }\n \n-fn check_convergence(files: &[str]) {\n+fn check_convergence(files: [str]) {\n     log_err #fmt[\"pp convergence tests: %u files\", vec::len(files)];\n     for file in files {\n         if !file_is_confusing(file) {\n@@ -396,7 +396,7 @@ fn check_convergence(files: &[str]) {\n     }\n }\n \n-fn check_variants(files: &[str]) {\n+fn check_variants(files: [str]) {\n     for file in files {\n         if !file_is_confusing(file) {\n             let s = io::read_whole_file_str(file);"}, {"sha": "ffff5f2f9082e72b1ab05e39c59b80556f8b209b", "filename": "src/fuzzer/ivec_fuzz.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ffuzzer%2Fivec_fuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ffuzzer%2Fivec_fuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Fivec_fuzz.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -7,7 +7,7 @@ Idea: provide functions for 'exhaustive' and 'random' modification of vecs.\n   two functions, \"return the number of possible edits\" and \"return edit #n\"\n \n It would be nice if this could be data-driven, so the two functions could share information:\n-  type vec_modifier = rec(fn (&<T> v, uint i) -> [T] fun, uint lo, uint di);\n+  type vec_modifier = rec(fn (<T> v, uint i) -> [T] fun, uint lo, uint di);\n   const [vec_modifier] vec_modifiers = ~[rec(fun=vec_omit, 0u, 1u), ...];\n But that gives me \"error: internal compiler error unimplemented consts that's not a plain literal\".\n https://github.com/graydon/rust/issues/570\n@@ -22,22 +22,22 @@ import std::vec::slice;\n import std::vec::len;\n import std::int;\n \n-fn vec_omit<@T>(v: &[T], i: uint) -> [T] {\n+fn vec_omit<@T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + slice(v, i + 1u, len(v))\n }\n-fn vec_dup<@T>(v: &[T], i: uint) -> [T] {\n+fn vec_dup<@T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + [v[i]] + slice(v, i, len(v))\n }\n-fn vec_swadj<@T>(v: &[T], i: uint) -> [T] {\n+fn vec_swadj<@T>(v: [T], i: uint) -> [T] {\n     slice(v, 0u, i) + [v[i + 1u], v[i]] + slice(v, i + 2u, len(v))\n }\n-fn vec_prefix<@T>(v: &[T], i: uint) -> [T] { slice(v, 0u, i) }\n-fn vec_suffix<@T>(v: &[T], i: uint) -> [T] { slice(v, i, len(v)) }\n+fn vec_prefix<@T>(v: [T], i: uint) -> [T] { slice(v, 0u, i) }\n+fn vec_suffix<@T>(v: [T], i: uint) -> [T] { slice(v, i, len(v)) }\n \n-fn vec_poke<@T>(v: &[T], i: uint, x: &T) -> [T] {\n+fn vec_poke<@T>(v: [T], i: uint, x: T) -> [T] {\n     slice(v, 0u, i) + [x] + slice(v, i + 1u, len(v))\n }\n-fn vec_insert<@T>(v: &[T], i: uint, x: &T) -> [T] {\n+fn vec_insert<@T>(v: [T], i: uint, x: T) -> [T] {\n     slice(v, 0u, i) + [x] + slice(v, i, len(v))\n }\n \n@@ -48,7 +48,7 @@ iter ix(skip_low: uint, skip_high: uint, length: uint) -> uint {\n }\n \n // Returns a bunch of modified versions of v, some of which introduce new elements (borrowed from xs).\n-fn vec_edits<@T>(v: &[T], xs: &[T]) -> [[T]] {\n+fn vec_edits<@T>(v: [T], xs: [T]) -> [[T]] {\n     let edits: [[T]] = [];\n     let Lv: uint = len(v);\n \n@@ -79,7 +79,7 @@ fn vec_edits<@T>(v: &[T], xs: &[T]) -> [[T]] {\n }\n \n // Would be nice if this were built in: https://github.com/graydon/rust/issues/424\n-fn vec_to_str(v: &[int]) -> str {\n+fn vec_to_str(v: [int]) -> str {\n     let i = 0u;\n     let s = \"[\";\n     while i < len(v) {\n@@ -90,7 +90,7 @@ fn vec_to_str(v: &[int]) -> str {\n     ret s + \"]\";\n }\n \n-fn show_edits(a: &[int], xs: &[int]) {\n+fn show_edits(a: [int], xs: [int]) {\n     log_err \"=== Edits of \" + vec_to_str(a) + \" ===\";\n     let b = vec_edits(a, xs);\n     for each i: uint in ix(0u, 1u, len(b)) { log_err vec_to_str(b[i]); }"}, {"sha": "0c4bcfd267d38299ec4606f26a9cfe2c7331d6ce", "filename": "src/lib/aio.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -14,11 +14,11 @@ native \"rust\" mod rustrt {\n     fn aio_init();\n     fn aio_run();\n     fn aio_stop();\n-    fn aio_connect(host: *u8, port: int, connected: &chan<socket>);\n-    fn aio_serve(host: *u8, port: int, acceptChan: &chan<socket>) -> server;\n-    fn aio_writedata(s: socket, buf: *u8, size: uint, status: &chan<bool>);\n-    fn aio_read(s: socket, reader: &chan<[u8]>);\n-    fn aio_close_server(s: server, status: &chan<bool>);\n+    fn aio_connect(host: *u8, port: int, connected: chan<socket>);\n+    fn aio_serve(host: *u8, port: int, acceptChan: chan<socket>) -> server;\n+    fn aio_writedata(s: socket, buf: *u8, size: uint, status: chan<bool>);\n+    fn aio_read(s: socket, reader: chan<[u8]>);\n+    fn aio_close_server(s: server, status: chan<bool>);\n     fn aio_close_socket(s: socket);\n     fn aio_is_null_client(s: socket) -> bool;\n }"}, {"sha": "e47c72f1028a70041260fc6e61bbe01ec82aad22", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -35,7 +35,7 @@ fn create(nbits: uint, init: bool) -> t {\n     ret @{storage: storage, nbits: nbits};\n }\n \n-fn process(op: &block(uint, uint) -> uint, v0: &t, v1: &t) -> bool {\n+fn process(op: block(uint, uint) -> uint, v0: t, v1: t) -> bool {\n     let len = vec::len(v1.storage);\n     assert (vec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n@@ -51,21 +51,18 @@ fn process(op: &block(uint, uint) -> uint, v0: &t, v1: &t) -> bool {\n \n fn lor(w0: uint, w1: uint) -> uint { ret w0 | w1; }\n \n-fn union(v0: &t, v1: &t) -> bool { let sub = lor; ret process(sub, v0, v1); }\n+fn union(v0: t, v1: t) -> bool { let sub = lor; ret process(sub, v0, v1); }\n \n fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n \n-fn intersect(v0: &t, v1: &t) -> bool {\n+fn intersect(v0: t, v1: t) -> bool {\n     let sub = land;\n     ret process(sub, v0, v1);\n }\n \n fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n \n-fn assign(v0: &t, v1: t) -> bool {\n-    let sub = right;\n-    ret process(sub, v0, v1);\n-}\n+fn assign(v0: t, v1: t) -> bool { let sub = right; ret process(sub, v0, v1); }\n \n fn clone(v: t) -> t {\n     let storage = vec::init_elt_mut::<uint>(0u, v.nbits / uint_bits() + 1u);\n@@ -74,7 +71,7 @@ fn clone(v: t) -> t {\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n-fn get(v: &t, i: uint) -> bool {\n+fn get(v: t, i: uint) -> bool {\n     assert (i < v.nbits);\n     let bits = uint_bits();\n     let w = i / bits;\n@@ -83,7 +80,7 @@ fn get(v: &t, i: uint) -> bool {\n     ret x == 1u;\n }\n \n-fn equal(v0: &t, v1: &t) -> bool {\n+fn equal(v0: t, v1: t) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n \n@@ -96,32 +93,32 @@ fn equal(v0: &t, v1: &t) -> bool {\n     ret true;\n }\n \n-fn clear(v: &t) {\n+fn clear(v: t) {\n     for each i: uint in uint::range(0u, vec::len(v.storage)) {\n         v.storage[i] = 0u;\n     }\n }\n \n-fn set_all(v: &t) {\n+fn set_all(v: t) {\n     for each i: uint in uint::range(0u, v.nbits) { set(v, i, true); }\n }\n \n-fn invert(v: &t) {\n+fn invert(v: t) {\n     for each i: uint in uint::range(0u, vec::len(v.storage)) {\n         v.storage[i] = !v.storage[i];\n     }\n }\n \n \n /* v0 = v0 - v1 */\n-fn difference(v0: &t, v1: &t) -> bool {\n+fn difference(v0: t, v1: t) -> bool {\n     invert(v1);\n     let b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n-fn set(v: &t, i: uint, x: bool) {\n+fn set(v: t, i: uint, x: bool) {\n     assert (i < v.nbits);\n     let bits = uint_bits();\n     let w = i / bits;\n@@ -132,32 +129,32 @@ fn set(v: &t, i: uint, x: bool) {\n \n \n /* true if all bits are 1 */\n-fn is_true(v: &t) -> bool {\n+fn is_true(v: t) -> bool {\n     for i: uint in to_vec(v) { if i != 1u { ret false; } }\n     ret true;\n }\n \n \n /* true if all bits are non-1 */\n-fn is_false(v: &t) -> bool {\n+fn is_false(v: t) -> bool {\n     for i: uint in to_vec(v) { if i == 1u { ret false; } }\n     ret true;\n }\n \n fn init_to_vec(v: t, i: uint) -> uint { ret if get(v, i) { 1u } else { 0u }; }\n \n-fn to_vec(v: &t) -> [uint] {\n+fn to_vec(v: t) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n     ret vec::init_fn::<uint>(sub, v.nbits);\n }\n \n-fn to_str(v: &t) -> str {\n+fn to_str(v: t) -> str {\n     let rs = \"\";\n     for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n \n-fn eq_vec(v0: &t, v1: &[uint]) -> bool {\n+fn eq_vec(v0: t, v1: [uint]) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;\n     let i = 0u;"}, {"sha": "a4322c09be92f54ad3d242f2e4090f3e151a1a8e", "filename": "src/lib/box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbox.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,7 +1,7 @@\n \n export ptr_eq;\n \n-fn ptr_eq<T>(a: &@T, b: &@T) -> bool {\n+fn ptr_eq<T>(a: @T, b: @T) -> bool {\n     let a_ptr: uint = unsafe::reinterpret_cast(a);\n     let b_ptr: uint = unsafe::reinterpret_cast(b);\n     ret a_ptr == b_ptr;"}, {"sha": "7c3be729e836fcb7ba31142b7321418b27462887", "filename": "src/lib/comm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fcomm.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -38,7 +38,7 @@ resource port_ptr(po: *rustrt::rust_port) {\n \n tag port<~T> { port_t(@port_ptr); }\n \n-fn send<~T>(ch: &chan<T>, data: -T) {\n+fn send<~T>(ch: chan<T>, data: -T) {\n     let chan_t(t, p) = ch;\n     rustrt::chan_id_send(t, p, data);\n }\n@@ -47,8 +47,8 @@ fn port<~T>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n-fn recv<~T>(p: &port<T>) -> T { ret rusti::recv(***p) }\n+fn recv<~T>(p: port<T>) -> T { ret rusti::recv(***p) }\n \n-fn chan<~T>(p: &port<T>) -> chan<T> {\n+fn chan<~T>(p: port<T>) -> chan<T> {\n     chan_t(task::get_task_id(), rustrt::get_port_id(***p))\n }"}, {"sha": "6371eec349bf623eeff9e1eb3426056b2da3977c", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -10,21 +10,21 @@\n \n native \"rust\" mod rustrt {\n     fn debug_tydesc<T>();\n-    fn debug_opaque<T>(x: &T);\n+    fn debug_opaque<T>(x: T);\n     fn debug_box<T>(x: @T);\n-    fn debug_tag<T>(x: &T);\n-    fn debug_obj<T>(x: &T, nmethods: uint, nbytes: uint);\n-    fn debug_fn<T>(x: &T);\n+    fn debug_tag<T>(x: T);\n+    fn debug_obj<T>(x: T, nmethods: uint, nbytes: uint);\n+    fn debug_fn<T>(x: T);\n     fn debug_ptrcast<T, U>(x: @T) -> @U;\n }\n \n fn debug_tydesc<T>() { rustrt::debug_tydesc::<T>(); }\n \n-fn debug_opaque<T>(x: &T) { rustrt::debug_opaque::<T>(x); }\n+fn debug_opaque<T>(x: T) { rustrt::debug_opaque::<T>(x); }\n \n fn debug_box<T>(x: @T) { rustrt::debug_box::<T>(x); }\n \n-fn debug_tag<T>(x: &T) { rustrt::debug_tag::<T>(x); }\n+fn debug_tag<T>(x: T) { rustrt::debug_tag::<T>(x); }\n \n \n /**\n@@ -36,15 +36,15 @@ fn debug_tag<T>(x: &T) { rustrt::debug_tag::<T>(x); }\n  * this to at least be 4u, since an implicit captured tydesc pointer sits in\n  * the front of any obj's data tuple.x\n  */\n-fn debug_obj<T>(x: &T, nmethods: uint, nbytes: uint) {\n+fn debug_obj<T>(x: T, nmethods: uint, nbytes: uint) {\n     rustrt::debug_obj::<T>(x, nmethods, nbytes);\n }\n \n-fn debug_fn<T>(x: &T) { rustrt::debug_fn::<T>(x); }\n+fn debug_fn<T>(x: T) { rustrt::debug_fn::<T>(x); }\n \n fn ptr_cast<T, U>(x: @T) -> @U { ret rustrt::debug_ptrcast::<T, U>(x); }\n \n-fn refcount<T>(a: &@T) -> uint {\n+fn refcount<T>(a: @T) -> uint {\n     let p: *uint = unsafe::reinterpret_cast(a);\n     ret *p;\n }"}, {"sha": "246806c8daa00303b2fbac92ee342add92c2dc6e", "filename": "src/lib/deque.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -7,8 +7,8 @@\n type t<T> =\n     obj {\n         fn size() -> uint;\n-        fn add_front(&T);\n-        fn add_back(&T);\n+        fn add_front(T);\n+        fn add_back(T);\n         fn pop_front() -> T;\n         fn pop_back() -> T;\n         fn peek_front() -> T;\n@@ -28,7 +28,8 @@ fn create<@T>() -> t<T> {\n \n \n \n-    fn grow<@T>(nelts: uint, lo: uint, elts: &[mutable cell<T>]) ->\n+\n+    fn grow<@T>(nelts: uint, lo: uint, elts: [mutable cell<T>]) ->\n        [mutable cell<T>] {\n         assert (nelts == vec::len(elts));\n         let rv = [mutable];\n@@ -44,15 +45,15 @@ fn create<@T>() -> t<T> {\n \n         ret rv;\n     }\n-    fn get<@T>(elts: &[mutable cell<T>], i: uint) -> T {\n+    fn get<@T>(elts: [mutable cell<T>], i: uint) -> T {\n         ret alt elts[i] { option::some(t) { t } _ { fail } };\n     }\n     obj deque<@T>(mutable nelts: uint,\n                   mutable lo: uint,\n                   mutable hi: uint,\n                   mutable elts: [mutable cell<T>]) {\n         fn size() -> uint { ret nelts; }\n-        fn add_front(t: &T) {\n+        fn add_front(t: T) {\n             let oldlo: uint = lo;\n             if lo == 0u {\n                 lo = vec::len::<cell<T>>(elts) - 1u;\n@@ -65,7 +66,7 @@ fn create<@T>() -> t<T> {\n             elts[lo] = option::some::<T>(t);\n             nelts += 1u;\n         }\n-        fn add_back(t: &T) {\n+        fn add_back(t: T) {\n             if lo == hi && nelts != 0u {\n                 elts = grow::<T>(nelts, lo, elts);\n                 lo = 0u;"}, {"sha": "6b380850a617e3f460c388fddae9ef0a380c630b", "filename": "src/lib/ebml.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Febml.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -17,7 +17,7 @@ type ebml_state = {ebml_tag: ebml_tag, tag_pos: uint, data_pos: uint};\n // ebml reading\n type doc = {data: @[u8], start: uint, end: uint};\n \n-fn vint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n+fn vint_at(data: [u8], start: uint) -> {val: uint, next: uint} {\n     let a = data[start];\n     if a & 0x80u8 != 0u8 { ret {val: a & 0x7fu8 as uint, next: start + 1u}; }\n     if a & 0x40u8 != 0u8 {\n@@ -39,11 +39,11 @@ fn vint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n     } else { log_err \"vint too big\"; fail; }\n }\n \n-fn new_doc(data: &@[u8]) -> doc {\n+fn new_doc(data: @[u8]) -> doc {\n     ret {data: data, start: 0u, end: vec::len::<u8>(*data)};\n }\n \n-fn doc_at(data: &@[u8], start: uint) -> doc {\n+fn doc_at(data: @[u8], start: uint) -> doc {\n     let elt_tag = vint_at(*data, start);\n     let elt_size = vint_at(*data, elt_tag.next);\n     let end = elt_size.next + elt_size.val;\n@@ -98,7 +98,7 @@ iter tagged_docs(d: doc, tg: uint) -> doc {\n \n fn doc_data(d: doc) -> [u8] { ret vec::slice::<u8>(*d.data, d.start, d.end); }\n \n-fn be_uint_from_bytes(data: &@[u8], start: uint, size: uint) -> uint {\n+fn be_uint_from_bytes(data: @[u8], start: uint, size: uint) -> uint {\n     let sz = size;\n     assert (sz <= 4u);\n     let val = 0u;\n@@ -119,7 +119,7 @@ fn doc_as_uint(d: doc) -> uint {\n // ebml writing\n type writer = {writer: io::buf_writer, mutable size_positions: [uint]};\n \n-fn write_sized_vint(w: &io::buf_writer, n: uint, size: uint) {\n+fn write_sized_vint(w: io::buf_writer, n: uint, size: uint) {\n     let buf: [u8];\n     alt size {\n       1u { buf = [0x80u8 | (n as u8)]; }\n@@ -139,7 +139,7 @@ fn write_sized_vint(w: &io::buf_writer, n: uint, size: uint) {\n     w.write(buf);\n }\n \n-fn write_vint(w: &io::buf_writer, n: uint) {\n+fn write_vint(w: io::buf_writer, n: uint) {\n     if n < 0x7fu { write_sized_vint(w, n, 1u); ret; }\n     if n < 0x4000u { write_sized_vint(w, n, 2u); ret; }\n     if n < 0x200000u { write_sized_vint(w, n, 3u); ret; }\n@@ -148,14 +148,14 @@ fn write_vint(w: &io::buf_writer, n: uint) {\n     fail;\n }\n \n-fn create_writer(w: &io::buf_writer) -> writer {\n+fn create_writer(w: io::buf_writer) -> writer {\n     let size_positions: [uint] = [];\n     ret {writer: w, mutable size_positions: size_positions};\n }\n \n \n // TODO: Provide a function to write the standard ebml header.\n-fn start_tag(w: &writer, tag_id: uint) {\n+fn start_tag(w: writer, tag_id: uint) {\n     // Write the tag ID:\n \n     write_vint(w.writer, tag_id);\n@@ -166,7 +166,7 @@ fn start_tag(w: &writer, tag_id: uint) {\n     w.writer.write(zeroes);\n }\n \n-fn end_tag(w: &writer) {\n+fn end_tag(w: writer) {\n     let last_size_pos = vec::pop::<uint>(w.size_positions);\n     let cur_pos = w.writer.tell();\n     w.writer.seek(last_size_pos as int, io::seek_set);"}, {"sha": "73efdbb70f10b90d5e9c92f13726674d86cdf8a9", "filename": "src/lib/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Feither.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -6,28 +6,28 @@ import option::none;\n tag t<T, U> { left(T); right(U); }\n \n fn either<T, U,\n-          V>(f_left: &block(&T) -> V, f_right: &block(&U) -> V,\n-             value: &t<T, U>) -> V {\n+          V>(f_left: block(T) -> V, f_right: block(U) -> V, value: t<T, U>) ->\n+   V {\n     alt value { left(l) { f_left(l) } right(r) { f_right(r) } }\n }\n \n-fn lefts<T, U>(eithers: &[t<T, U>]) -> [T] {\n+fn lefts<T, U>(eithers: [t<T, U>]) -> [T] {\n     let result: [T] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { left(l) { result += [l] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn rights<T, U>(eithers: &[t<T, U>]) -> [U] {\n+fn rights<T, U>(eithers: [t<T, U>]) -> [U] {\n     let result: [U] = [];\n     for elt: t<T, U> in eithers {\n         alt elt { right(r) { result += [r] } _ {/* fallthrough */ } }\n     }\n     ret result;\n }\n \n-fn partition<T, U>(eithers: &[t<T, U>]) -> {lefts: [T], rights: [U]} {\n+fn partition<T, U>(eithers: [t<T, U>]) -> {lefts: [T], rights: [U]} {\n     let lefts: [T] = [];\n     let rights: [U] = [];\n     for elt: t<T, U> in eithers {"}, {"sha": "7a6452017416888127e32016af882da4b433b53a", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -68,13 +68,13 @@ mod ct {\n \n     // A fragment of the output sequence\n     tag piece { piece_string(str); piece_conv(conv); }\n-    type error_fn = fn(&str) -> ! ;\n+    type error_fn = fn(str) -> ! ;\n \n-    fn parse_fmt_string(s: &str, error: error_fn) -> [piece] {\n+    fn parse_fmt_string(s: str, error: error_fn) -> [piece] {\n         let pieces: [piece] = [];\n         let lim = str::byte_len(s);\n         let buf = \"\";\n-        fn flush_buf(buf: &str, pieces: &mutable [piece]) -> str {\n+        fn flush_buf(buf: str, pieces: &mutable [piece]) -> str {\n             if str::byte_len(buf) > 0u {\n                 let piece = piece_string(buf);\n                 pieces += [piece];\n@@ -103,7 +103,7 @@ mod ct {\n         buf = flush_buf(buf, pieces);\n         ret pieces;\n     }\n-    fn peek_num(s: &str, i: uint, lim: uint) ->\n+    fn peek_num(s: str, i: uint, lim: uint) ->\n        option::t<{num: uint, next: uint}> {\n         if i >= lim { ret none; }\n         let c = s[i];\n@@ -118,7 +118,7 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_conversion(s: &str, i: uint, lim: uint, error: error_fn) ->\n+    fn parse_conversion(s: str, i: uint, lim: uint, error: error_fn) ->\n        {piece: piece, next: uint} {\n         let parm = parse_parameter(s, i, lim);\n         let flags = parse_flags(s, parm.next, lim);\n@@ -133,7 +133,7 @@ mod ct {\n                              ty: ty.ty}),\n              next: ty.next};\n     }\n-    fn parse_parameter(s: &str, i: uint, lim: uint) ->\n+    fn parse_parameter(s: str, i: uint, lim: uint) ->\n        {param: option::t<int>, next: uint} {\n         if i >= lim { ret {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n@@ -148,14 +148,14 @@ mod ct {\n               }\n             };\n     }\n-    fn parse_flags(s: &str, i: uint, lim: uint) ->\n+    fn parse_flags(s: str, i: uint, lim: uint) ->\n        {flags: [flag], next: uint} {\n         let noflags: [flag] = [];\n         if i >= lim { ret {flags: noflags, next: i}; }\n \n         // FIXME: This recursion generates illegal instructions if the return\n         // value isn't boxed. Only started happening after the ivec conversion\n-        fn more_(f: flag, s: &str, i: uint, lim: uint) ->\n+        fn more_(f: flag, s: str, i: uint, lim: uint) ->\n            @{flags: [flag], next: uint} {\n             let next = parse_flags(s, i + 1u, lim);\n             let rest = next.flags;\n@@ -177,8 +177,7 @@ mod ct {\n                 *more(flag_alternate)\n             } else { {flags: noflags, next: i} };\n     }\n-    fn parse_count(s: &str, i: uint, lim: uint) ->\n-       {count: count, next: uint} {\n+    fn parse_count(s: str, i: uint, lim: uint) -> {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n             } else if s[i] == '*' as u8 {\n@@ -198,7 +197,7 @@ mod ct {\n                 }\n             };\n     }\n-    fn parse_precision(s: &str, i: uint, lim: uint) ->\n+    fn parse_precision(s: str, i: uint, lim: uint) ->\n        {count: count, next: uint} {\n         ret if i >= lim {\n                 {count: count_implied, next: i}\n@@ -214,7 +213,7 @@ mod ct {\n                 }\n             } else { {count: count_implied, next: i} };\n     }\n-    fn parse_type(s: &str, i: uint, lim: uint, error: error_fn) ->\n+    fn parse_type(s: str, i: uint, lim: uint, error: error_fn) ->\n        {ty: ty, next: uint} {\n         if i >= lim { error(\"missing type in conversion\"); }\n         let tstr = str::substr(s, i, 1u);\n@@ -270,7 +269,7 @@ mod rt {\n     // instead just use a bool per flag\n     type conv = {flags: [flag], width: count, precision: count, ty: ty};\n \n-    fn conv_int(cv: &conv, i: int) -> str {\n+    fn conv_int(cv: conv, i: int) -> str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let s = int_to_str_prec(i, radix, prec);\n@@ -283,7 +282,7 @@ mod rt {\n         }\n         ret pad(cv, s, pad_signed);\n     }\n-    fn conv_uint(cv: &conv, u: uint) -> str {\n+    fn conv_uint(cv: conv, u: uint) -> str {\n         let prec = get_int_precision(cv);\n         let rs =\n             alt cv.ty {\n@@ -295,17 +294,17 @@ mod rt {\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n-    fn conv_bool(cv: &conv, b: bool) -> str {\n+    fn conv_bool(cv: conv, b: bool) -> str {\n         let s = if b { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n \n         ret conv_str(cv, s);\n     }\n-    fn conv_char(cv: &conv, c: char) -> str {\n+    fn conv_char(cv: conv, c: char) -> str {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n-    fn conv_str(cv: &conv, s: &str) -> str {\n+    fn conv_str(cv: conv, s: str) -> str {\n         // For strings, precision is the maximum characters\n         // displayed\n \n@@ -346,7 +345,7 @@ mod rt {\n                 } else { s }\n             };\n     }\n-    fn get_int_precision(cv: &conv) -> uint {\n+    fn get_int_precision(cv: conv) -> uint {\n         ret alt cv.precision {\n               count_is(c) { c as uint }\n               count_implied. { 1u }\n@@ -360,7 +359,7 @@ mod rt {\n         ret str::unsafe_from_bytes(svec);\n     }\n     tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n-    fn pad(cv: &conv, s: &str, mode: pad_mode) -> str {\n+    fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n         let uwidth;\n         alt cv.width {\n           count_implied. { ret s; }\n@@ -388,7 +387,7 @@ mod rt {\n           pad_signed. { might_zero_pad = true; signed = true; }\n           pad_unsigned. { might_zero_pad = true; }\n         }\n-        fn have_precision(cv: &conv) -> bool {\n+        fn have_precision(cv: conv) -> bool {\n             ret alt cv.precision { count_implied. { false } _ { true } };\n         }\n         let zero_padding = false;\n@@ -414,7 +413,7 @@ mod rt {\n         }\n         ret padstr + s;\n     }\n-    fn have_flag(flags: &[flag], f: flag) -> bool {\n+    fn have_flag(flags: [flag], f: flag) -> bool {\n         for candidate: flag in flags { if candidate == f { ret true; } }\n         ret false;\n     }"}, {"sha": "d48c5487bd4630b10659524cd56695bbd0df3fd1", "filename": "src/lib/fs.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -10,7 +10,7 @@ fn path_sep() -> str { ret str::from_char(os_fs::path_sep); }\n \n type path = str;\n \n-fn dirname(p: &path) -> path {\n+fn dirname(p: path) -> path {\n     let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n         i = str::rindex(p, os_fs::alt_path_sep as u8);\n@@ -19,7 +19,7 @@ fn dirname(p: &path) -> path {\n     ret str::substr(p, 0u, i as uint);\n }\n \n-fn basename(p: &path) -> path {\n+fn basename(p: path) -> path {\n     let i: int = str::rindex(p, os_fs::path_sep as u8);\n     if i == -1 {\n         i = str::rindex(p, os_fs::alt_path_sep as u8);\n@@ -32,7 +32,7 @@ fn basename(p: &path) -> path {\n \n \n // FIXME: Need some typestate to avoid bounds check when len(pre) == 0\n-fn connect(pre: &path, post: &path) -> path {\n+fn connect(pre: path, post: path) -> path {\n     let len = str::byte_len(pre);\n     ret if pre[len - 1u] == os_fs::path_sep as u8 {\n \n@@ -41,11 +41,11 @@ fn connect(pre: &path, post: &path) -> path {\n         } else { pre + path_sep() + post };\n }\n \n-fn file_is_dir(p: &path) -> bool {\n+fn file_is_dir(p: path) -> bool {\n     ret str::as_buf(p, {|buf| rustrt::rust_file_is_dir(buf) != 0 });\n }\n \n-fn list_dir(p: &path) -> [str] {\n+fn list_dir(p: path) -> [str] {\n     let p = p;\n     let pl = str::byte_len(p);\n     if pl == 0u || p[pl - 1u] as char != os_fs::path_sep { p += path_sep(); }\n@@ -58,11 +58,11 @@ fn list_dir(p: &path) -> [str] {\n     ret full_paths;\n }\n \n-fn path_is_absolute(p: &path) -> bool { ret os_fs::path_is_absolute(p); }\n+fn path_is_absolute(p: path) -> bool { ret os_fs::path_is_absolute(p); }\n \n // FIXME: under Windows, we should prepend the current drive letter to paths\n // that start with a slash.\n-fn make_absolute(p: &path) -> path {\n+fn make_absolute(p: path) -> path {\n     if path_is_absolute(p) { ret p; } else { ret connect(getcwd(), p); }\n }\n "}, {"sha": "d8d6e217c95e16118701dd33bdf0e572eba4b85e", "filename": "src/lib/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffun_treemap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -29,7 +29,7 @@ type treemap<@K, @V> = @tree_node<K, V>;\n \n fn init<@K, @V>() -> treemap<K, V> { @empty }\n \n-fn insert<@K, @V>(m: &treemap<K, V>, k: &K, v: &V) -> treemap<K, V> {\n+fn insert<@K, @V>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n        @empty. { node(@k, @v, @empty, @empty) }\n        @node(@kk, vv, left, right) {\n@@ -42,7 +42,7 @@ fn insert<@K, @V>(m: &treemap<K, V>, k: &K, v: &V) -> treemap<K, V> {\n      }\n }\n \n-fn find<@K, @V>(m: &treemap<K, V>, k: &K) -> option<V> {\n+fn find<@K, @V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n       node(@kk, @v, left, right) {\n@@ -55,7 +55,7 @@ fn find<@K, @V>(m: &treemap<K, V>, k: &K) -> option<V> {\n \n \n // Performs an in-order traversal\n-fn traverse<@K, @V>(m: &treemap<K, V>, f: fn(&K, &V)) {\n+fn traverse<@K, @V>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty. { }\n       node(@k, @v, _, _) {"}, {"sha": "9137df4acf5dd69e18c22bced07fba2f902b10cd", "filename": "src/lib/generic_os.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgeneric_os.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,7 +3,7 @@ import str::sbuf;\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-fn getenv(n: &str) -> option::t<str> {\n+fn getenv(n: str) -> option::t<str> {\n     let s = str::as_buf(n, {|buf| os::libc::getenv(buf) });\n     ret if unsafe::reinterpret_cast(s) == 0 {\n             option::none::<str>\n@@ -15,7 +15,7 @@ fn getenv(n: &str) -> option::t<str> {\n \n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-fn setenv(n: &str, v: &str) {\n+fn setenv(n: str, v: str) {\n     // FIXME (868)\n     let _: () =\n         str::as_buf(n,\n@@ -30,7 +30,7 @@ fn setenv(n: &str, v: &str) {\n }\n \n #[cfg(target_os = \"win32\")]\n-fn getenv(n: &str) -> option::t<str> {\n+fn getenv(n: str) -> option::t<str> {\n     let nsize = 256u;\n     while true {\n         let v: [u8] = [];\n@@ -53,13 +53,18 @@ fn getenv(n: &str) -> option::t<str> {\n }\n \n #[cfg(target_os = \"win32\")]\n-fn setenv(n: &str, v: &str) {\n+fn setenv(n: str, v: str) {\n     // FIXME (868)\n-    let _: () = str::as_buf(n, {|nbuf|\n-        let _: () = str::as_buf(v, {|vbuf|\n-            os::kernel32::SetEnvironmentVariableA(nbuf, vbuf);\n-        });\n-    });\n+    let _: () =\n+        str::as_buf(n,\n+                    {|nbuf|\n+                        let _: () =\n+                            str::as_buf(v,\n+                                        {|vbuf|\n+                      os::kernel32::SetEnvironmentVariableA(nbuf,\n+                                                            vbuf);\n+                                        });\n+                    });\n }\n \n // Local Variables:"}, {"sha": "de2573c13b3387f1390094e77f5359f6c51cba59", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -37,45 +37,45 @@ tag occur { req; optional; multi; }\n \n type opt = {name: name, hasarg: hasarg, occur: occur};\n \n-fn mkname(nm: &str) -> name {\n+fn mkname(nm: str) -> name {\n     ret if str::char_len(nm) == 1u {\n             short(str::char_at(nm, 0u))\n         } else { long(nm) };\n }\n \n-fn reqopt(name: &str) -> opt {\n+fn reqopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: req};\n }\n \n-fn optopt(name: &str) -> opt {\n+fn optopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: optional};\n }\n \n-fn optflag(name: &str) -> opt {\n+fn optflag(name: str) -> opt {\n     ret {name: mkname(name), hasarg: no, occur: optional};\n }\n \n-fn optflagopt(name: &str) -> opt {\n+fn optflagopt(name: str) -> opt {\n     ret {name: mkname(name), hasarg: maybe, occur: optional};\n }\n \n-fn optmulti(name: &str) -> opt {\n+fn optmulti(name: str) -> opt {\n     ret {name: mkname(name), hasarg: yes, occur: multi};\n }\n \n tag optval { val(str); given; }\n \n type match = {opts: [opt], vals: [mutable [optval]], free: [str]};\n \n-fn is_arg(arg: &str) -> bool {\n+fn is_arg(arg: str) -> bool {\n     ret str::byte_len(arg) > 1u && arg[0] == '-' as u8;\n }\n \n-fn name_str(nm: &name) -> str {\n+fn name_str(nm: name) -> str {\n     ret alt nm { short(ch) { str::from_char(ch) } long(s) { s } };\n }\n \n-fn find_opt(opts: &[opt], nm: &name) -> option::t<uint> {\n+fn find_opt(opts: [opt], nm: name) -> option::t<uint> {\n     let i = 0u;\n     let l = vec::len::<opt>(opts);\n     while i < l { if opts[i].name == nm { ret some::<uint>(i); } i += 1u; }\n@@ -90,7 +90,7 @@ tag fail_ {\n     unexpected_argument(str);\n }\n \n-fn fail_str(f: &fail_) -> str {\n+fn fail_str(f: fail_) -> str {\n     ret alt f {\n           argument_missing(nm) { \"Argument to option '\" + nm + \"' missing.\" }\n           unrecognized_option(nm) { \"Unrecognized option: '\" + nm + \"'.\" }\n@@ -106,7 +106,7 @@ fn fail_str(f: &fail_) -> str {\n \n tag result { success(match); failure(fail_); }\n \n-fn getopts(args: &[str], opts: &[opt]) -> result {\n+fn getopts(args: [str], opts: [opt]) -> result {\n     let n_opts = vec::len::<opt>(opts);\n     fn f(_x: uint) -> [optval] { ret []; }\n     let vals = vec::init_fn_mut::<[optval]>(f, n_opts);\n@@ -200,32 +200,32 @@ fn getopts(args: &[str], opts: &[opt]) -> result {\n     ret success({opts: opts, vals: vals, free: free});\n }\n \n-fn opt_vals(m: &match, nm: &str) -> [optval] {\n+fn opt_vals(m: match, nm: str) -> [optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n           none. { log_err \"No option '\" + nm + \"' defined.\"; fail }\n         };\n }\n \n-fn opt_val(m: &match, nm: &str) -> optval { ret opt_vals(m, nm)[0]; }\n+fn opt_val(m: match, nm: str) -> optval { ret opt_vals(m, nm)[0]; }\n \n-fn opt_present(m: &match, nm: &str) -> bool {\n+fn opt_present(m: match, nm: str) -> bool {\n     ret vec::len::<optval>(opt_vals(m, nm)) > 0u;\n }\n \n-fn opt_str(m: &match, nm: &str) -> str {\n+fn opt_str(m: match, nm: str) -> str {\n     ret alt opt_val(m, nm) { val(s) { s } _ { fail } };\n }\n \n-fn opt_strs(m: &match, nm: &str) -> [str] {\n+fn opt_strs(m: match, nm: str) -> [str] {\n     let acc: [str] = [];\n     for v: optval in opt_vals(m, nm) {\n         alt v { val(s) { acc += [s]; } _ { } }\n     }\n     ret acc;\n }\n \n-fn opt_maybe_str(m: &match, nm: &str) -> option::t<str> {\n+fn opt_maybe_str(m: match, nm: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { none::<str> } };\n@@ -235,7 +235,7 @@ fn opt_maybe_str(m: &match, nm: &str) -> option::t<str> {\n /// Returns none if the option was not present, `def` if the option was\n /// present but no argument was provided, and the argument if the option was\n /// present and an argument was provided.\n-fn opt_default(m: &match, nm: &str, def: &str) -> option::t<str> {\n+fn opt_default(m: match, nm: str, def: str) -> option::t<str> {\n     let vals = opt_vals(m, nm);\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }"}, {"sha": "98d8bb5e157e196618f48bdb05e35b9aac3d283e", "filename": "src/lib/int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fint.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -32,9 +32,9 @@ pure fn nonnegative(x: int) -> bool { ret x >= 0; }\n \n \n // FIXME: Make sure this works with negative integers.\n-fn hash(x: &int) -> uint { ret x as uint; }\n+fn hash(x: int) -> uint { ret x as uint; }\n \n-fn eq_alias(x: &int, y: &int) -> bool { ret x == y; }\n+fn eq_alias(x: int, y: int) -> bool { ret x == y; }\n \n iter range(lo: int, hi: int) -> int {\n     let lo_: int = lo;"}, {"sha": "73460e50588e537b07de360d2194a85870aafa95", "filename": "src/lib/io.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -174,7 +174,7 @@ fn stdin() -> reader {\n     ret new_reader(FILE_buf_reader(rustrt::rust_get_stdin(), option::none));\n }\n \n-fn file_reader(path: &str) -> reader {\n+fn file_reader(path: str) -> reader {\n     let f =\n         str::as_buf(path,\n                     {|pathbuf|\n@@ -218,11 +218,11 @@ obj byte_buf_reader(bbuf: byte_buf) {\n     fn tell() -> uint { ret bbuf.pos; }\n }\n \n-fn new_byte_buf_reader(buf: &[u8]) -> buf_reader {\n+fn new_byte_buf_reader(buf: [u8]) -> buf_reader {\n     ret byte_buf_reader(@{buf: buf, mutable pos: 0u});\n }\n \n-fn string_reader(s: &str) -> reader {\n+fn string_reader(s: str) -> reader {\n     ret new_reader(new_byte_buf_reader(str::bytes(s)));\n }\n \n@@ -236,13 +236,13 @@ type buf_writer =\n     // FIXME: eventually u64\n \n     obj {\n-        fn write(&[u8]);\n+        fn write([u8]);\n         fn seek(int, seek_style);\n         fn tell() -> uint;\n     };\n \n obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n-    fn write(v: &[u8]) {\n+    fn write(v: [u8]) {\n         let len = vec::len::<u8>(v);\n         let vbuf = vec::unsafe::to_ptr::<u8>(v);\n         let nout = os::libc::fwrite(vbuf, len, 1u, f);\n@@ -257,7 +257,7 @@ obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n resource fd_res(fd: int) { os::libc::close(fd); }\n \n obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n-    fn write(v: &[u8]) {\n+    fn write(v: [u8]) {\n         let len = vec::len::<u8>(v);\n         let count = 0u;\n         let vbuf;\n@@ -282,7 +282,7 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n     }\n }\n \n-fn file_buf_writer(path: &str, flags: &[fileflag]) -> buf_writer {\n+fn file_buf_writer(path: str, flags: [fileflag]) -> buf_writer {\n     let fflags: int =\n         os::libc_constants::O_WRONLY() | os::libc_constants::O_BINARY();\n     for f: fileflag in flags {\n@@ -313,12 +313,12 @@ type writer =\n     // function will be provided for general encoded string output\n     obj {\n         fn get_buf_writer() -> buf_writer;\n-        fn write_str(&str);\n-        fn write_line(&str);\n+        fn write_str(str);\n+        fn write_line(str);\n         fn write_char(char);\n         fn write_int(int);\n         fn write_uint(uint);\n-        fn write_bytes(&[u8]);\n+        fn write_bytes([u8]);\n         fn write_le_uint(uint, uint);\n         fn write_le_int(int, uint);\n         fn write_be_uint(uint, uint);\n@@ -339,8 +339,8 @@ fn uint_to_be_bytes(n: uint, size: uint) -> [u8] {\n \n obj new_writer(out: buf_writer) {\n     fn get_buf_writer() -> buf_writer { ret out; }\n-    fn write_str(s: &str) { out.write(str::bytes(s)); }\n-    fn write_line(s: &str) {\n+    fn write_str(s: str) { out.write(str::bytes(s)); }\n+    fn write_line(s: str) {\n         out.write(str::bytes(s));\n         out.write(str::bytes(\"\\n\"));\n     }\n@@ -351,7 +351,7 @@ obj new_writer(out: buf_writer) {\n     }\n     fn write_int(n: int) { out.write(str::bytes(int::to_str(n, 10u))); }\n     fn write_uint(n: uint) { out.write(str::bytes(uint::to_str(n, 10u))); }\n-    fn write_bytes(bytes: &[u8]) { out.write(bytes); }\n+    fn write_bytes(bytes: [u8]) { out.write(bytes); }\n     fn write_le_uint(n: uint, size: uint) {\n         out.write(uint_to_le_bytes(n, size));\n     }\n@@ -363,13 +363,13 @@ obj new_writer(out: buf_writer) {\n     }\n }\n \n-fn file_writer(path: &str, flags: &[fileflag]) -> writer {\n+fn file_writer(path: str, flags: [fileflag]) -> writer {\n     ret new_writer(file_buf_writer(path, flags));\n }\n \n \n // FIXME: fileflags\n-fn buffered_file_buf_writer(path: &str) -> buf_writer {\n+fn buffered_file_buf_writer(path: str) -> buf_writer {\n     let f =\n         str::as_buf(path,\n                     {|pathbuf|\n@@ -396,7 +396,7 @@ type str_writer =\n type mutable_byte_buf = @{mutable buf: [mutable u8], mutable pos: uint};\n \n obj byte_buf_writer(buf: mutable_byte_buf) {\n-    fn write(v: &[u8]) {\n+    fn write(v: [u8]) {\n         // Fast path.\n \n         if buf.pos == vec::len(buf.buf) {\n@@ -453,11 +453,11 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     ret bpos as uint;\n }\n \n-fn read_whole_file_str(file: &str) -> str {\n+fn read_whole_file_str(file: str) -> str {\n     str::unsafe_from_bytes(read_whole_file(file))\n }\n \n-fn read_whole_file(file: &str) -> [u8] {\n+fn read_whole_file(file: str) -> [u8] {\n \n     // FIXME: There's a lot of copying here\n     file_reader(file).read_whole_stream()"}, {"sha": "5cd71d13b79b91880e100a89d348556c3ace39f0", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -54,7 +54,7 @@ fn exec_suffix() -> str { ret \"\"; }\n \n fn target_os() -> str { ret \"linux\"; }\n \n-fn dylib_filename(base: &str) -> str { ret \"lib\" + base + \".so\"; }\n+fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".so\"; }\n \n fn pipe() -> {in: int, out: int} {\n     let fds = {mutable in: 0, mutable out: 0};"}, {"sha": "b3484281b1cd0bd404e7c1b8ea07d4bb2a804ffd", "filename": "src/lib/list.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,7 +3,7 @@ import option::none;\n \n tag list<T> { cons(T, @list<T>); nil; }\n \n-fn from_vec<@T>(v: &[T]) -> list<T> {\n+fn from_vec<@T>(v: [T]) -> list<T> {\n     let l = nil::<T>;\n     // FIXME: This would be faster and more space efficient if it looped over\n     // a reverse vector iterator. Unfortunately generic iterators seem not to\n@@ -13,7 +13,7 @@ fn from_vec<@T>(v: &[T]) -> list<T> {\n     ret l;\n }\n \n-fn foldl<@T, @U>(ls_: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U {\n+fn foldl<@T, @U>(ls_: list<T>, u: U, f: block(T, U) -> U) -> U {\n     let accum: U = u;\n     let ls = ls_;\n     while true {\n@@ -25,8 +25,7 @@ fn foldl<@T, @U>(ls_: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U {\n     ret accum;\n }\n \n-fn find<@T, @U>(ls_: &list<T>, f: &block(&T) -> option::t<U>) ->\n-   option::t<U> {\n+fn find<@T, @U>(ls_: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -39,7 +38,7 @@ fn find<@T, @U>(ls_: &list<T>, f: &block(&T) -> option::t<U>) ->\n     ret none;\n }\n \n-fn has<@T>(ls_: &list<T>, elt: &T) -> bool {\n+fn has<@T>(ls_: list<T>, elt: T) -> bool {\n     let ls = ls_;\n     while true {\n         alt ls {\n@@ -50,20 +49,20 @@ fn has<@T>(ls_: &list<T>, elt: &T) -> bool {\n     ret false;\n }\n \n-fn length<@T>(ls: &list<T>) -> uint {\n-    fn count<T>(_t: &T, u: &uint) -> uint { ret u + 1u; }\n+fn length<@T>(ls: list<T>) -> uint {\n+    fn count<T>(_t: T, u: uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, count);\n }\n \n-fn cdr<@T>(ls: &list<T>) -> list<T> {\n+fn cdr<@T>(ls: list<T>) -> list<T> {\n     alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n }\n \n-fn car<@T>(ls: &list<T>) -> T {\n+fn car<@T>(ls: list<T>) -> T {\n     alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n }\n \n-fn append<@T>(l: &list<T>, m: &list<T>) -> list<T> {\n+fn append<@T>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }\n       cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }"}, {"sha": "3a63a9d2ffba1158e77f7a4cf0f538ed3c6dcd17", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -51,7 +51,7 @@ fn exec_suffix() -> str { ret \"\"; }\n \n fn target_os() -> str { ret \"macos\"; }\n \n-fn dylib_filename(base: &str) -> str { ret \"lib\" + base + \".dylib\"; }\n+fn dylib_filename(base: str) -> str { ret \"lib\" + base + \".dylib\"; }\n \n fn pipe() -> {in: int, out: int} {\n     let fds = {mutable in: 0, mutable out: 0};"}, {"sha": "81be20a662072743e939383f70af32887d0362c9", "filename": "src/lib/map.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,27 +1,27 @@\n /**\n  * Hashmap implementation.\n  */\n-type hashfn<K> = fn(&K) -> uint;\n+type hashfn<K> = fn(K) -> uint;\n \n-type eqfn<K> = fn(&K, &K) -> bool;\n+type eqfn<K> = fn(K, K) -> bool;\n \n type hashmap<K, V> =\n     obj {\n         fn size() -> uint;\n-        fn insert(&K, &V) -> bool;\n-        fn contains_key(&K) -> bool;\n-        fn get(&K) -> V;\n-        fn find(&K) -> option::t<V>;\n-        fn remove(&K) -> option::t<V>;\n+        fn insert(K, V) -> bool;\n+        fn contains_key(K) -> bool;\n+        fn get(K) -> V;\n+        fn find(K) -> option::t<V>;\n+        fn remove(K) -> option::t<V>;\n         fn rehash();\n         iter items() -> @{key: K, val: V};\n         iter keys() -> K;\n     };\n type hashset<K> = hashmap<K, ()>;\n \n-fn set_add<@K>(set: hashset<K>, key: &K) -> bool { ret set.insert(key, ()); }\n+fn set_add<@K>(set: hashset<K>, key: K) -> bool { ret set.insert(key, ()); }\n \n-fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n+fn mk_hashmap<@K, @V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n     let load_factor: util::rational = {num: 3, den: 4};\n@@ -54,9 +54,9 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n      */\n \n     fn insert_common<@K,\n-                     @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                         bkts: &[mutable bucket<K, V>], nbkts: uint, key: &K,\n-                         val: &V) -> bool {\n+                     @V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                         bkts: [mutable bucket<K, V>], nbkts: uint, key: K,\n+                         val: V) -> bool {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n         while i < nbkts {\n@@ -75,8 +75,8 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n         fail; // full table\n     }\n     fn find_common<@K,\n-                   @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                       bkts: &[mutable bucket<K, V>], nbkts: uint, key: &K) ->\n+                   @V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                       bkts: [mutable bucket<K, V>], nbkts: uint, key: K) ->\n        option::t<V> {\n         let i: uint = 0u;\n         let h: uint = hasher(key);\n@@ -97,9 +97,9 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n         ret option::none;\n     }\n     fn rehash<@K,\n-              @V>(hasher: &hashfn<K>, eqer: &eqfn<K>,\n-                  oldbkts: &[mutable bucket<K, V>], _noldbkts: uint,\n-                  newbkts: &[mutable bucket<K, V>], nnewbkts: uint) {\n+              @V>(hasher: hashfn<K>, eqer: eqfn<K>,\n+                  oldbkts: [mutable bucket<K, V>], _noldbkts: uint,\n+                  newbkts: [mutable bucket<K, V>], nnewbkts: uint) {\n         for b: bucket<K, V> in oldbkts {\n             alt b {\n               some(k_, v_) {\n@@ -119,7 +119,7 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n                     mutable nelts: uint,\n                     lf: util::rational) {\n         fn size() -> uint { ret nelts; }\n-        fn insert(key: &K, val: &V) -> bool {\n+        fn insert(key: K, val: V) -> bool {\n             let load: util::rational =\n                 {num: nelts + 1u as int, den: nbkts as int};\n             if !util::rational_leq(load, lf) {\n@@ -135,22 +135,22 @@ fn mk_hashmap<@K, @V>(hasher: &hashfn<K>, eqer: &eqfn<K>) -> hashmap<K, V> {\n             }\n             ret false;\n         }\n-        fn contains_key(key: &K) -> bool {\n+        fn contains_key(key: K) -> bool {\n             ret alt find_common(hasher, eqer, bkts, nbkts, key) {\n                   option::some(_) { true }\n                   _ { false }\n                 };\n         }\n-        fn get(key: &K) -> V {\n+        fn get(key: K) -> V {\n             ret alt find_common(hasher, eqer, bkts, nbkts, key) {\n                   option::some(val) { val }\n                   _ { fail }\n                 };\n         }\n-        fn find(key: &K) -> option::t<V> {\n+        fn find(key: K) -> option::t<V> {\n             be find_common(hasher, eqer, bkts, nbkts, key);\n         }\n-        fn remove(key: &K) -> option::t<V> {\n+        fn remove(key: K) -> option::t<V> {\n             let i: uint = 0u;\n             let h: uint = hasher(key);\n             while i < nbkts {\n@@ -199,14 +199,14 @@ fn new_str_hash<@V>() -> hashmap<str, V> {\n }\n \n fn new_int_hash<@V>() -> hashmap<int, V> {\n-    fn hash_int(x: &int) -> uint { ret x as uint; }\n-    fn eq_int(a: &int, b: &int) -> bool { ret a == b; }\n+    fn hash_int(x: int) -> uint { ret x as uint; }\n+    fn eq_int(a: int, b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n fn new_uint_hash<@V>() -> hashmap<uint, V> {\n-    fn hash_uint(x: &uint) -> uint { ret x; }\n-    fn eq_uint(a: &uint, b: &uint) -> bool { ret a == b; }\n+    fn hash_uint(x: uint) -> uint { ret x; }\n+    fn eq_uint(a: uint, b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);\n }\n "}, {"sha": "c7c042a54a92909ad0afc144c559a5ae224aecdb", "filename": "src/lib/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fnet.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -12,8 +12,8 @@ fn format_addr(ip: ip_addr) -> str {\n     }\n }\n \n-fn parse_addr(ip: &str) -> ip_addr {\n-    let parts = vec::map({|&s| uint::from_str(s) }, str::split(ip, \".\"[0]));\n+fn parse_addr(ip: str) -> ip_addr {\n+    let parts = vec::map({|s| uint::from_str(s) }, str::split(ip, \".\"[0]));\n     if vec::len(parts) != 4u { fail \"Too many dots in IP address\"; }\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)"}, {"sha": "c10c22ae18da10440acd26e2491de82c93401606", "filename": "src/lib/option.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,30 +2,30 @@\n \n tag t<@T> { none; some(T); }\n \n-fn get<@T>(opt: &t<T>) -> T {\n+fn get<@T>(opt: t<T>) -> T {\n     alt opt { some(x) { x } none. { fail \"option none\" } }\n }\n \n-fn map<@T, @U>(f: &block(&T) -> U, opt: &t<T>) -> t<U> {\n+fn map<@T, @U>(f: block(T) -> U, opt: t<T>) -> t<U> {\n     alt opt { some(x) { some(f(x)) } none. { none } }\n }\n \n-fn is_none<@T>(opt: &t<T>) -> bool {\n+fn is_none<@T>(opt: t<T>) -> bool {\n     alt opt { none. { true } some(_) { false } }\n }\n \n-fn is_some<@T>(opt: &t<T>) -> bool { !is_none(opt) }\n+fn is_some<@T>(opt: t<T>) -> bool { !is_none(opt) }\n \n-fn from_maybe<@T>(def: &T, opt: &t<T>) -> T {\n+fn from_maybe<@T>(def: T, opt: t<T>) -> T {\n     alt opt { some(x) { x } none. { def } }\n }\n \n-fn maybe<@T, @U>(def: &U, f: &block(&T) -> U, opt: &t<T>) -> U {\n+fn maybe<@T, @U>(def: U, f: block(T) -> U, opt: t<T>) -> U {\n     alt opt { none. { def } some(t) { f(t) } }\n }\n \n // Can be defined in terms of the above when/if we have const bind.\n-fn may<@T>(f: &block(&T), opt: &t<T>) {\n+fn may<@T>(f: block(T), opt: t<T>) {\n     alt opt { none. {/* nothing */ } some(t) { f(t); } }\n }\n "}, {"sha": "a20f9d7711f15f41eec81d27be47ddbcecb3473b", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,9 +1,9 @@\n \n native \"rust\" mod rustrt {\n-    fn rust_list_files(path: &str) -> [str];\n+    fn rust_list_files(path: str) -> [str];\n }\n \n-fn list_dir(path: &str) -> [str] {\n+fn list_dir(path: str) -> [str] {\n     ret rustrt::rust_list_files(path);\n \n     // FIXME: No idea why, but this appears to corrupt memory on OSX. I\n@@ -30,7 +30,7 @@ fn list_dir(path: &str) -> [str] {\n \n }\n \n-fn path_is_absolute(p: &str) -> bool { ret str::char_at(p, 0u) == '/'; }\n+fn path_is_absolute(p: str) -> bool { ret str::char_at(p, 0u) == '/'; }\n \n const path_sep: char = '/';\n "}, {"sha": "8d730732c3cd6d8cd04284cfef0c9786979e1348", "filename": "src/lib/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fptr.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,11 +1,11 @@\n // Unsafe pointer utility functions.\n \n native \"rust-intrinsic\" mod rusti {\n-    fn addr_of<T>(val: &T) -> *mutable T;\n+    fn addr_of<T>(val: T) -> *mutable T;\n     fn ptr_offset<T>(ptr: *T, count: uint) -> *T;\n }\n \n-fn addr_of<T>(val: &T) -> *mutable T { ret rusti::addr_of(val); }\n+fn addr_of<T>(val: T) -> *mutable T { ret rusti::addr_of(val); }\n fn offset<T>(ptr: *T, count: uint) -> *T {\n     ret rusti::ptr_offset(ptr, count);\n }"}, {"sha": "43fe4bc3d95e64b48cb12664ba536b90b6f1fdab", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -12,27 +12,27 @@ native \"rust\" mod rustrt {\n        int;\n }\n \n-fn arg_vec(prog: &str, args: &[@str]) -> [sbuf] {\n+fn arg_vec(prog: str, args: [@str]) -> [sbuf] {\n     let argptrs = str::as_buf(prog, {|buf| [buf] });\n     for arg in args { argptrs += str::as_buf(*arg, {|buf| [buf] }); }\n     argptrs += [unsafe::reinterpret_cast(0)];\n     ret argptrs;\n }\n \n-fn spawn_process(prog: &str, args: &[str], in_fd: int, out_fd: int,\n-                 err_fd: int) -> int {\n+fn spawn_process(prog: str, args: [str], in_fd: int, out_fd: int, err_fd: int)\n+   -> int {\n     // Note: we have to hold on to these vector references while we hold a\n     // pointer to their buffers\n     let prog = prog;\n-    let args = vec::map({|&arg| @arg }, args);\n+    let args = vec::map({|arg| @arg }, args);\n     let argv = arg_vec(prog, args);\n     let pid =\n         rustrt::rust_run_program(vec::unsafe::to_ptr(argv), in_fd, out_fd,\n                                  err_fd);\n     ret pid;\n }\n \n-fn run_program(prog: &str, args: &[str]) -> int {\n+fn run_program(prog: str, args: [str]) -> int {\n     ret os::waitpid(spawn_process(prog, args, 0, 0, 0));\n }\n \n@@ -49,7 +49,7 @@ type program =\n \n resource program_res(p: program) { p.destroy(); }\n \n-fn start_program(prog: &str, args: &[str]) -> @program_res {\n+fn start_program(prog: str, args: [str]) -> @program_res {\n     let pipe_input = os::pipe();\n     let pipe_output = os::pipe();\n     let pipe_err = os::pipe();\n@@ -100,7 +100,7 @@ fn start_program(prog: &str, args: &[str]) -> @program_res {\n                                  os::fd_FILE(pipe_err.in), false));\n }\n \n-fn read_all(rd: &io::reader) -> str {\n+fn read_all(rd: io::reader) -> str {\n     let buf = \"\";\n     while !rd.eof() {\n         let bytes = rd.read_bytes(4096u);\n@@ -109,7 +109,7 @@ fn read_all(rd: &io::reader) -> str {\n     ret buf;\n }\n \n-fn program_output(prog: &str, args: &[str]) ->\n+fn program_output(prog: str, args: [str]) ->\n    {status: int, out: str, err: str} {\n     let pr = start_program(prog, args);\n     pr.close_input();"}, {"sha": "313ec407e2622732c0fea35daa3d5699af22e10f", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -15,8 +15,8 @@ type sha1 =\n     // Reset the sha1 state for reuse. This is called\n     // automatically during construction\n     obj {\n-        fn input(&[u8]);\n-        fn input_str(&str);\n+        fn input([u8]);\n+        fn input_str(str);\n         fn result() -> [u8];\n         fn result_str() -> str;\n         fn reset();\n@@ -44,7 +44,7 @@ fn mk_sha1() -> sha1 {\n          mutable computed: bool,\n          work_buf: [mutable u32]};\n \n-    fn add_input(st: &sha1state, msg: &[u8]) {\n+    fn add_input(st: sha1state, msg: [u8]) {\n         // FIXME: Should be typestate precondition\n         assert (!st.computed);\n         for element: u8 in msg {\n@@ -62,7 +62,7 @@ fn mk_sha1() -> sha1 {\n             if st.msg_block_idx == msg_block_len { process_msg_block(st); }\n         }\n     }\n-    fn process_msg_block(st: &sha1state) {\n+    fn process_msg_block(st: sha1state) {\n         // FIXME: Make precondition\n         assert (vec::len(st.h) == digest_buf_len);\n         assert (vec::len(st.work_buf) == work_buf_len);\n@@ -142,7 +142,7 @@ fn mk_sha1() -> sha1 {\n     fn circular_shift(bits: u32, word: u32) -> u32 {\n         ret word << bits | word >> 32u32 - bits;\n     }\n-    fn mk_result(st: &sha1state) -> [u8] {\n+    fn mk_result(st: sha1state) -> [u8] {\n         if !st.computed { pad_msg(st); st.computed = true; }\n         let rs: [u8] = [];\n         for hpart: u32 in st.h {\n@@ -164,7 +164,7 @@ fn mk_sha1() -> sha1 {\n      * call process_msg_block() appropriately.  When it returns, it\n      * can be assumed that the message digest has been computed.\n      */\n-    fn pad_msg(st: &sha1state) {\n+    fn pad_msg(st: sha1state) {\n         // FIXME: Should be a precondition\n         assert (vec::len(st.msg_block) == msg_block_len);\n \n@@ -215,8 +215,8 @@ fn mk_sha1() -> sha1 {\n             st.h[4] = 0xC3D2E1F0u32;\n             st.computed = false;\n         }\n-        fn input(msg: &[u8]) { add_input(st, msg); }\n-        fn input_str(msg: &str) { add_input(st, str::bytes(msg)); }\n+        fn input(msg: [u8]) { add_input(st, msg); }\n+        fn input_str(msg: str) { add_input(st, str::bytes(msg)); }\n         fn result() -> [u8] { ret mk_result(st); }\n         fn result_str() -> str {\n             let r = mk_result(st);"}, {"sha": "5d706ea4b4fc8b43a2fdaba44c5d419e68c427d4", "filename": "src/lib/smallintmap.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsmallintmap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -14,31 +14,31 @@ fn mk<@T>() -> smallintmap<T> {\n     ret @{mutable v: v};\n }\n \n-fn insert<@T>(m: &smallintmap<T>, key: uint, val: &T) {\n+fn insert<@T>(m: smallintmap<T>, key: uint, val: T) {\n     vec::grow_set::<option::t<T>>(m.v, key, none::<T>, some::<T>(val));\n }\n \n-fn find<@T>(m: &smallintmap<T>, key: uint) -> option::t<T> {\n+fn find<@T>(m: smallintmap<T>, key: uint) -> option::t<T> {\n     if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n     ret none::<T>;\n }\n \n-fn get<@T>(m: &smallintmap<T>, key: uint) -> T {\n+fn get<@T>(m: smallintmap<T>, key: uint) -> T {\n     alt find::<T>(m, key) {\n       none::<T>. { log_err \"smallintmap::get(): key not present\"; fail; }\n       some::<T>(v) { ret v; }\n     }\n }\n \n-fn contains_key<@T>(m: &smallintmap<T>, key: uint) -> bool {\n+fn contains_key<@T>(m: smallintmap<T>, key: uint) -> bool {\n     ret !option::is_none(find::<T>(m, key));\n }\n \n-fn truncate<@T>(m: &smallintmap<T>, len: uint) {\n+fn truncate<@T>(m: smallintmap<T>, len: uint) {\n     m.v = vec::slice_mut::<option::t<T>>(m.v, 0u, len);\n }\n \n-fn max_key<T>(m: &smallintmap<T>) -> uint {\n+fn max_key<T>(m: smallintmap<T>) -> uint {\n     ret vec::len::<option::t<T>>(m.v);\n }\n "}, {"sha": "17e7c90ae385c297412bfdbcca8d426c8d9ae5be", "filename": "src/lib/sort.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -6,10 +6,10 @@ export merge_sort;\n export quick_sort;\n export quick_sort3;\n \n-type lteq<T> = block(&T, &T) -> bool;\n+type lteq<T> = block(T, T) -> bool;\n \n-fn merge_sort<@T>(le: &lteq<T>, v: &[T]) -> [T] {\n-    fn merge<@T>(le: &lteq<T>, a: &[T], b: &[T]) -> [T] {\n+fn merge_sort<@T>(le: lteq<T>, v: [T]) -> [T] {\n+    fn merge<@T>(le: lteq<T>, a: [T], b: [T]) -> [T] {\n         let rs: [T] = [];\n         let a_len: uint = len::<T>(a);\n         let a_ix: uint = 0u;\n@@ -33,14 +33,14 @@ fn merge_sort<@T>(le: &lteq<T>, v: &[T]) -> [T] {\n     ret merge::<T>(le, merge_sort::<T>(le, a), merge_sort::<T>(le, b));\n }\n \n-fn swap<@T>(arr: &[mutable T], x: uint, y: uint) {\n+fn swap<@T>(arr: [mutable T], x: uint, y: uint) {\n     let a = arr[x];\n     arr[x] = arr[y];\n     arr[y] = a;\n }\n \n-fn part<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n-            right: uint, pivot: uint) -> uint {\n+fn part<@T>(compare_func: lteq<T>, arr: [mutable T], left: uint, right: uint,\n+            pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     swap::<T>(arr, pivot, right);\n     let storage_index: uint = left;\n@@ -56,7 +56,7 @@ fn part<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n     ret storage_index;\n }\n \n-fn qsort<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n+fn qsort<@T>(compare_func: lteq<T>, arr: [mutable T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -69,7 +69,7 @@ fn qsort<@T>(compare_func: &lteq<T>, arr: &[mutable T], left: uint,\n     }\n }\n \n-fn quick_sort<@T>(compare_func: &lteq<T>, arr: &[mutable T]) {\n+fn quick_sort<@T>(compare_func: lteq<T>, arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n@@ -79,8 +79,8 @@ fn quick_sort<@T>(compare_func: &lteq<T>, arr: &[mutable T]) {\n // http://www.cs.princeton.edu/~rs/talks/QuicksortIsOptimal.pdf\n // According to these slides this is the algorithm of choice for\n // 'randomly ordered keys, abstract compare' & 'small number of key values'\n-fn qsort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n-              arr: &[mutable T], left: int, right: int) {\n+fn qsort3<@T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n+              arr: [mutable T], left: int, right: int) {\n     if right <= left { ret; }\n     let v: T = arr[right];\n     let i: int = left - 1;\n@@ -127,8 +127,8 @@ fn qsort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, i, right);\n }\n \n-fn quick_sort3<@T>(compare_func_lt: &lteq<T>, compare_func_eq: &lteq<T>,\n-                   arr: &[mutable T]) {\n+fn quick_sort3<@T>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n+                   arr: [mutable T]) {\n     if len::<T>(arr) == 0u { ret; }\n     qsort3::<T>(compare_func_lt, compare_func_eq, arr, 0,\n                 (len::<T>(arr) as int) - 1);"}, {"sha": "c6edc5cb574d78c505c8015eb252072d2cb790ff", "filename": "src/lib/str.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -10,11 +10,11 @@ native \"rust\" mod rustrt {\n     fn rust_str_push(s: &mutable str, ch: u8);\n }\n \n-fn eq(a: &str, b: &str) -> bool { a == b }\n+fn eq(a: str, b: str) -> bool { a == b }\n \n-fn lteq(a: &str, b: &str) -> bool { a <= b }\n+fn lteq(a: str, b: str) -> bool { a <= b }\n \n-fn hash(s: &str) -> uint {\n+fn hash(s: str) -> uint {\n     // djb hash.\n     // FIXME: replace with murmur.\n \n@@ -37,7 +37,7 @@ const tag_five_b: uint = 248u;\n const max_five_b: uint = 67108864u;\n const tag_six_b: uint = 252u;\n \n-fn is_utf8(v: &[u8]) -> bool {\n+fn is_utf8(v: [u8]) -> bool {\n     let i = 0u;\n     let total = vec::len::<u8>(v);\n     while i < total {\n@@ -54,19 +54,19 @@ fn is_utf8(v: &[u8]) -> bool {\n     ret true;\n }\n \n-fn is_ascii(s: &str) -> bool {\n+fn is_ascii(s: str) -> bool {\n     let i: uint = byte_len(s);\n     while i > 0u { i -= 1u; if s[i] & 128u8 != 0u8 { ret false; } }\n     ret true;\n }\n \n /// Returns true if the string has length 0\n-pure fn is_empty(s: &str) -> bool { for c: u8 in s { ret false; } ret true; }\n+pure fn is_empty(s: str) -> bool { for c: u8 in s { ret false; } ret true; }\n \n /// Returns true if the string has length greater than 0\n-pure fn is_not_empty(s: &str) -> bool { !is_empty(s) }\n+pure fn is_not_empty(s: str) -> bool { !is_empty(s) }\n \n-fn is_whitespace(s: &str) -> bool {\n+fn is_whitespace(s: str) -> bool {\n     let i = 0u;\n     let len = char_len(s);\n     while i < len {\n@@ -76,7 +76,7 @@ fn is_whitespace(s: &str) -> bool {\n     ret true;\n }\n \n-fn byte_len(s: &str) -> uint {\n+fn byte_len(s: str) -> uint {\n     let v: [u8] = unsafe::reinterpret_cast(s);\n     let vlen = vec::len(v);\n     unsafe::leak(v);\n@@ -85,14 +85,14 @@ fn byte_len(s: &str) -> uint {\n     ret vlen - 1u;\n }\n \n-fn bytes(s: &str) -> [u8] {\n+fn bytes(s: str) -> [u8] {\n     let v = unsafe::reinterpret_cast(s);\n     let vcopy = vec::slice(v, 0u, vec::len(v) - 1u);\n     unsafe::leak(v);\n     ret vcopy;\n }\n \n-fn unsafe_from_bytes(v: &[mutable? u8]) -> str {\n+fn unsafe_from_bytes(v: [mutable? u8]) -> str {\n     let vcopy: [u8] = v + [0u8];\n     let scopy: str = unsafe::reinterpret_cast(vcopy);\n     unsafe::leak(vcopy);\n@@ -136,7 +136,7 @@ fn from_char(ch: char) -> str {\n     ret buf;\n }\n \n-fn from_chars(chs: &[char]) -> str {\n+fn from_chars(chs: [char]) -> str {\n     let buf = \"\";\n     for ch: char in chs { push_utf8_bytes(buf, ch); }\n     ret buf;\n@@ -156,7 +156,7 @@ fn utf8_char_width(b: u8) -> uint {\n     ret 6u;\n }\n \n-fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n+fn char_range_at(s: str, i: uint) -> {ch: char, next: uint} {\n     let b0 = s[i];\n     let w = utf8_char_width(b0);\n     assert (w != 0u);\n@@ -178,9 +178,9 @@ fn char_range_at(s: &str, i: uint) -> {ch: char, next: uint} {\n     ret {ch: val as char, next: i};\n }\n \n-fn char_at(s: &str, i: uint) -> char { ret char_range_at(s, i).ch; }\n+fn char_at(s: str, i: uint) -> char { ret char_range_at(s, i).ch; }\n \n-fn char_len(s: &str) -> uint {\n+fn char_len(s: str) -> uint {\n     let i = 0u;\n     let len = 0u;\n     let total = byte_len(s);\n@@ -194,7 +194,7 @@ fn char_len(s: &str) -> uint {\n     ret len;\n }\n \n-fn to_chars(s: &str) -> [char] {\n+fn to_chars(s: str) -> [char] {\n     let buf: [char] = [];\n     let i = 0u;\n     let len = byte_len(s);\n@@ -225,23 +225,23 @@ fn shift_char(s: &mutable str) -> char {\n \n fn unshift_char(s: &mutable str, ch: char) { s = from_char(ch) + s; }\n \n-fn index(s: &str, c: u8) -> int {\n+fn index(s: str, c: u8) -> int {\n     let i: int = 0;\n     for k: u8 in s { if k == c { ret i; } i += 1; }\n     ret -1;\n }\n \n-fn rindex(s: &str, c: u8) -> int {\n+fn rindex(s: str, c: u8) -> int {\n     let n: int = byte_len(s) as int;\n     while n >= 0 { if s[n] == c { ret n; } n -= 1; }\n     ret n;\n }\n \n-fn find(haystack: &str, needle: &str) -> int {\n+fn find(haystack: str, needle: str) -> int {\n     let haystack_len: int = byte_len(haystack) as int;\n     let needle_len: int = byte_len(needle) as int;\n     if needle_len == 0 { ret 0; }\n-    fn match_at(haystack: &str, needle: &str, i: int) -> bool {\n+    fn match_at(haystack: str, needle: str, i: int) -> bool {\n         let j: int = i;\n         for c: u8 in needle { if haystack[j] != c { ret false; } j += 1; }\n         ret true;\n@@ -254,15 +254,15 @@ fn find(haystack: &str, needle: &str) -> int {\n     ret -1;\n }\n \n-fn starts_with(haystack: &str, needle: &str) -> bool {\n+fn starts_with(haystack: str, needle: str) -> bool {\n     let haystack_len: uint = byte_len(haystack);\n     let needle_len: uint = byte_len(needle);\n     if needle_len == 0u { ret true; }\n     if needle_len > haystack_len { ret false; }\n     ret eq(substr(haystack, 0u, needle_len), needle);\n }\n \n-fn ends_with(haystack: &str, needle: &str) -> bool {\n+fn ends_with(haystack: str, needle: str) -> bool {\n     let haystack_len: uint = byte_len(haystack);\n     let needle_len: uint = byte_len(needle);\n     ret if needle_len == 0u {\n@@ -275,11 +275,11 @@ fn ends_with(haystack: &str, needle: &str) -> bool {\n         };\n }\n \n-fn substr(s: &str, begin: uint, len: uint) -> str {\n+fn substr(s: str, begin: uint, len: uint) -> str {\n     ret slice(s, begin, begin + len);\n }\n \n-fn slice(s: &str, begin: uint, end: uint) -> str {\n+fn slice(s: str, begin: uint, end: uint) -> str {\n     // FIXME: Typestate precondition\n     assert (begin <= end);\n     assert (end <= byte_len(s));\n@@ -293,7 +293,7 @@ fn slice(s: &str, begin: uint, end: uint) -> str {\n     ret s2;\n }\n \n-fn safe_slice(s: &str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n+fn safe_slice(s: str, begin: uint, end: uint) : uint::le(begin, end) -> str {\n     // would need some magic to make this a precondition\n     assert (end <= byte_len(s));\n     ret slice(s, begin, end);\n@@ -317,11 +317,11 @@ fn pop_byte(s: &mutable str) -> u8 {\n \n fn push_byte(s: &mutable str, b: u8) { rustrt::rust_str_push(s, b); }\n \n-fn push_bytes(s: &mutable str, bytes: &[u8]) {\n+fn push_bytes(s: &mutable str, bytes: [u8]) {\n     for byte in bytes { rustrt::rust_str_push(s, byte); }\n }\n \n-fn split(s: &str, sep: u8) -> [str] {\n+fn split(s: str, sep: u8) -> [str] {\n     let v: [str] = [];\n     let accum: str = \"\";\n     let ends_with_sep: bool = false;\n@@ -336,13 +336,13 @@ fn split(s: &str, sep: u8) -> [str] {\n     ret v;\n }\n \n-fn concat(v: &[str]) -> str {\n+fn concat(v: [str]) -> str {\n     let s: str = \"\";\n     for ss: str in v { s += ss; }\n     ret s;\n }\n \n-fn connect(v: &[str], sep: &str) -> str {\n+fn connect(v: [str], sep: str) -> str {\n     let s: str = \"\";\n     let first: bool = true;\n     for ss: str in v {\n@@ -353,7 +353,7 @@ fn connect(v: &[str], sep: &str) -> str {\n }\n \n // FIXME: This only handles ASCII\n-fn to_upper(s: &str) -> str {\n+fn to_upper(s: str) -> str {\n     let outstr = \"\";\n     let ascii_a = 'a' as u8;\n     let ascii_z = 'z' as u8;\n@@ -369,7 +369,7 @@ fn to_upper(s: &str) -> str {\n }\n \n // FIXME: This is super-inefficient\n-fn replace(s: &str, from: &str, to: &str) : is_not_empty(from) -> str {\n+fn replace(s: str, from: str, to: str) : is_not_empty(from) -> str {\n     // FIXME (694): Shouldn't have to check this\n     check (is_not_empty(from));\n     if byte_len(s) == 0u {\n@@ -383,12 +383,12 @@ fn replace(s: &str, from: &str, to: &str) : is_not_empty(from) -> str {\n }\n \n // FIXME: Also not efficient\n-fn char_slice(s: &str, begin: uint, end: uint) -> str {\n+fn char_slice(s: str, begin: uint, end: uint) -> str {\n     from_chars(vec::slice(to_chars(s), begin, end))\n }\n \n-fn trim_left(s: &str) -> str {\n-    fn count_whities(s: &[char]) -> uint {\n+fn trim_left(s: str) -> str {\n+    fn count_whities(s: [char]) -> uint {\n         let i = 0u;\n         while i < vec::len(s) {\n             if !char::is_whitespace(s[i]) { break; }\n@@ -401,8 +401,8 @@ fn trim_left(s: &str) -> str {\n     ret from_chars(vec::slice(chars, whities, vec::len(chars)));\n }\n \n-fn trim_right(s: &str) -> str {\n-    fn count_whities(s: &[char]) -> uint {\n+fn trim_right(s: str) -> str {\n+    fn count_whities(s: [char]) -> uint {\n         let i = vec::len(s);\n         while 0u < i {\n             if !char::is_whitespace(s[i - 1u]) { break; }\n@@ -415,18 +415,18 @@ fn trim_right(s: &str) -> str {\n     ret from_chars(vec::slice(chars, 0u, whities));\n }\n \n-fn trim(s: &str) -> str { trim_left(trim_right(s)) }\n+fn trim(s: str) -> str { trim_left(trim_right(s)) }\n \n type sbuf = *u8;\n \n-fn buf(s: &str) -> sbuf {\n+fn buf(s: str) -> sbuf {\n     let saddr = ptr::addr_of(s);\n     let vaddr: *[u8] = unsafe::reinterpret_cast(saddr);\n     let buf = vec::to_ptr(*vaddr);\n     ret buf;\n }\n \n-fn as_buf<T>(s: &str, f: &block(sbuf) -> T) -> T { let buf = buf(s); f(buf) }\n+fn as_buf<T>(s: str, f: block(sbuf) -> T) -> T { let buf = buf(s); f(buf) }\n \n fn str_from_cstr(cstr: sbuf) -> str {\n     let res = \"\";"}, {"sha": "24a9582ba4c3f7c9d1eb180a9b3df0b58e466d1a", "filename": "src/lib/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -124,8 +124,8 @@ fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n     let ptrsize = sys::size_of::<*u8>();\n     let thunkfn: *mutable uint = cast(sp - ptrsize * 2u);\n     let thunkenv: *mutable uint = cast(sp - ptrsize);\n-    *thunkfn = cast(raw_thunk.code);\n-    *thunkenv = cast(raw_thunk.env);\n+    *thunkfn = cast(raw_thunk.code);;\n+    *thunkenv = cast(raw_thunk.env);;\n     // align the stack to 16 bytes\n     (**task_ptr).stack_ptr = cast(sp - ptrsize * 4u);\n \n@@ -136,7 +136,7 @@ fn spawn_inner(thunk: -fn(), notify: option<comm::chan<task_notification>>) ->\n         (**task_ptr).notify_chan = c;\n       }\n       none { }\n-    };\n+    }\n \n     // give the thunk environment's allocation to the new task\n     rustrt::migrate_alloc(cast(raw_thunk.env), id);"}, {"sha": "1ad70db6f17d356de6d3f8a664d1a01d75fd90d2", "filename": "src/lib/test.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftest.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -49,7 +49,7 @@ type test_desc = {name: test_name, fn: test_fn, ignore: bool};\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-fn test_main(args: &[str], tests: &[test_desc]) {\n+fn test_main(args: [str], tests: [test_desc]) {\n     check (vec::is_not_empty(args));\n     let opts =\n         alt parse_opts(args) {\n@@ -64,7 +64,7 @@ type test_opts = {filter: option::t<str>, run_ignored: bool};\n type opt_res = either::t<test_opts, str>;\n \n // Parses command line arguments into test options\n-fn parse_opts(args: &[str]) : vec::is_not_empty(args) -> opt_res {\n+fn parse_opts(args: [str]) : vec::is_not_empty(args) -> opt_res {\n \n     let args_ = vec::tail(args);\n     let opts = [getopts::optflag(\"ignored\")];\n@@ -94,15 +94,15 @@ type joinable = (task, comm::port<task::task_notification>);\n // In cases where test functions and closures it is not ok to just dump them\n // into a task and run them, so this transformation gives the caller a chance\n // to create the test task.\n-type test_to_task = fn(&fn()) -> joinable;\n+type test_to_task = fn(fn()) -> joinable;\n \n // A simple console test runner\n-fn run_tests_console(opts: &test_opts, tests: &[test_desc]) -> bool {\n+fn run_tests_console(opts: test_opts, tests: [test_desc]) -> bool {\n     run_tests_console_(opts, tests, default_test_to_task)\n }\n \n-fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n-                      to_task: &test_to_task) -> bool {\n+fn run_tests_console_(opts: test_opts, tests: [test_desc],\n+                      to_task: test_to_task) -> bool {\n \n     type test_state =\n         @{out: io::writer,\n@@ -175,20 +175,19 @@ fn run_tests_console_(opts: &test_opts, tests: &[test_desc],\n \n     ret success;\n \n-    fn write_ok(out: &io::writer, use_color: bool) {\n+    fn write_ok(out: io::writer, use_color: bool) {\n         write_pretty(out, \"ok\", term::color_green, use_color);\n     }\n \n-    fn write_failed(out: &io::writer, use_color: bool) {\n+    fn write_failed(out: io::writer, use_color: bool) {\n         write_pretty(out, \"FAILED\", term::color_red, use_color);\n     }\n \n-    fn write_ignored(out: &io::writer, use_color: bool) {\n+    fn write_ignored(out: io::writer, use_color: bool) {\n         write_pretty(out, \"ignored\", term::color_yellow, use_color);\n     }\n \n-    fn write_pretty(out: &io::writer, word: &str, color: u8,\n-                    use_color: bool) {\n+    fn write_pretty(out: io::writer, word: str, color: u8, use_color: bool) {\n         if use_color && term::color_supported() {\n             term::fg(out.get_buf_writer(), color);\n         }\n@@ -207,7 +206,7 @@ tag testevent {\n     te_result(test_desc, test_result);\n }\n \n-fn run_tests(opts: &test_opts, tests: &[test_desc], to_task: &test_to_task,\n+fn run_tests(opts: test_opts, tests: [test_desc], to_task: test_to_task,\n              callback: fn(testevent)) {\n \n     let filtered_tests = filter_tests(opts, tests);\n@@ -241,7 +240,7 @@ fn run_tests(opts: &test_opts, tests: &[test_desc], to_task: &test_to_task,\n \n fn get_concurrency() -> uint { rustrt::sched_threads() }\n \n-fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n+fn filter_tests(opts: test_opts, tests: [test_desc]) -> [test_desc] {\n     let filtered = tests;\n \n     // Remove tests that don't match the test filter\n@@ -256,7 +255,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n                 };\n \n             let filter =\n-                bind fn (test: &test_desc, filter_str: &str) ->\n+                bind fn (test: test_desc, filter_str: str) ->\n                         option::t<test_desc> {\n                          if str::find(test.name, filter_str) >= 0 {\n                              ret option::some(test);\n@@ -273,7 +272,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n             filtered\n         } else {\n             let filter =\n-                fn (test: &test_desc) -> option::t<test_desc> {\n+                fn (test: test_desc) -> option::t<test_desc> {\n                     if test.ignore {\n                         ret option::some({name: test.name,\n                                           fn: test.fn,\n@@ -288,7 +287,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n     // Sort the tests alphabetically\n     filtered =\n         {\n-            fn lteq(t1: &test_desc, t2: &test_desc) -> bool {\n+            fn lteq(t1: test_desc, t2: test_desc) -> bool {\n                 str::lteq(t1.name, t2.name)\n             }\n             sort::merge_sort(lteq, filtered)\n@@ -299,7 +298,7 @@ fn filter_tests(opts: &test_opts, tests: &[test_desc]) -> [test_desc] {\n \n type test_future = {test: test_desc, wait: fn() -> test_result};\n \n-fn run_test(test: &test_desc, to_task: &test_to_task) -> test_future {\n+fn run_test(test: test_desc, to_task: test_to_task) -> test_future {\n     if !test.ignore {\n         let test_task = to_task(test.fn);\n         ret {test: test,\n@@ -315,7 +314,7 @@ fn run_test(test: &test_desc, to_task: &test_to_task) -> test_future {\n \n // We need to run our tests in another task in order to trap test failures.\n // This function only works with functions that don't contain closures.\n-fn default_test_to_task(f: &fn()) -> joinable {\n+fn default_test_to_task(f: fn()) -> joinable {\n     fn run_task(f: fn()) { configure_test_task(); f(); }\n     ret task::spawn_joinable(bind run_task(f));\n }"}, {"sha": "bd65a58a8b3b38b19af62121add4223aad3d1c78", "filename": "src/lib/treemap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftreemap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -23,7 +23,7 @@ type treemap<@K, @V> = @mutable tree_node<K, V>;\n \n fn init<@K, @V>() -> treemap<K, V> { @mutable empty }\n \n-fn insert<@K, @V>(m: &treemap<K, V>, k: &K, v: &V) {\n+fn insert<@K, @V>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n       @empty. { *m = node(@k, @v, @mutable empty, @mutable empty); }\n       @node(@kk, _, _, _) {\n@@ -37,13 +37,14 @@ fn insert<@K, @V>(m: &treemap<K, V>, k: &K, v: &V) {\n     }\n }\n \n-fn find<@K, @V>(m: &treemap<K, V>, k: &K) -> option<V> {\n+fn find<@K, @V>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n       empty. { none }\n       node(@kk, @v, _, _) {\n         if k == kk {\n             some(v)\n         } else if k < kk {\n+\n             // Again, ugliness to unpack left and right individually.\n             alt *m { node(_, _, left, _) { find(left, k) } }\n         } else { alt *m { node(_, _, _, right) { find(right, k) } } }\n@@ -52,7 +53,7 @@ fn find<@K, @V>(m: &treemap<K, V>, k: &K) -> option<V> {\n }\n \n // Performs an in-order traversal\n-fn traverse<@K, @V>(m: &treemap<K, V>, f: fn(&K, &V)) {\n+fn traverse<@K, @V>(m: treemap<K, V>, f: fn(K, V)) {\n     alt *m {\n       empty. { }\n       node(k, v, _, _) {"}, {"sha": "1a8aacae1da562d57fecb59350451033741f8d91", "filename": "src/lib/ufind.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fufind.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -12,7 +12,7 @@ type ufind = {mutable nodes: [mutable node]};\n \n fn make() -> ufind { ret {mutable nodes: [mutable]}; }\n \n-fn make_set(ufnd: &ufind) -> uint {\n+fn make_set(ufnd: ufind) -> uint {\n     let idx = vec::len(ufnd.nodes);\n     ufnd.nodes += [mutable none::<uint>];\n     ret idx;\n@@ -21,30 +21,30 @@ fn make_set(ufnd: &ufind) -> uint {\n \n /// Creates sets as necessary to ensure that least `n` sets are present in the\n /// data structure.\n-fn grow(ufnd: &ufind, n: uint) {\n+fn grow(ufnd: ufind, n: uint) {\n     while set_count(ufnd) < n { make_set(ufnd); }\n }\n \n-fn find(ufnd: &ufind, n: uint) -> uint {\n+fn find(ufnd: ufind, n: uint) -> uint {\n     alt ufnd.nodes[n] {\n       none. { ret n; }\n       some(m) { let m_ = m; be find(ufnd, m_); }\n     }\n }\n \n-fn union(ufnd: &ufind, m: uint, n: uint) {\n+fn union(ufnd: ufind, m: uint, n: uint) {\n     let m_root = find(ufnd, m);\n     let n_root = find(ufnd, n);\n     if m_root < n_root {\n         ufnd.nodes[n_root] = some::<uint>(m_root);\n     } else if m_root > n_root { ufnd.nodes[m_root] = some::<uint>(n_root); }\n }\n \n-fn set_count(ufnd: &ufind) -> uint { ret vec::len::<node>(ufnd.nodes); }\n+fn set_count(ufnd: ufind) -> uint { ret vec::len::<node>(ufnd.nodes); }\n \n \n // Removes all sets with IDs greater than or equal to the given value.\n-fn prune(ufnd: &ufind, n: uint) {\n+fn prune(ufnd: ufind, n: uint) {\n     // TODO: Use \"slice\" once we get rid of \"mutable?\"\n \n     let len = vec::len::<node>(ufnd.nodes);"}, {"sha": "d992ade5a7273ede2535f52af2fd7eb04ffb45a2", "filename": "src/lib/uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fuint.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -39,7 +39,7 @@ fn next_power_of_two(n: uint) -> uint {\n     ret tmp + 1u;\n }\n \n-fn parse_buf(buf: &[u8], radix: uint) -> uint {\n+fn parse_buf(buf: [u8], radix: uint) -> uint {\n     if vec::len::<u8>(buf) == 0u {\n         log_err \"parse_buf(): buf is empty\";\n         fail;\n@@ -56,7 +56,7 @@ fn parse_buf(buf: &[u8], radix: uint) -> uint {\n     fail;\n }\n \n-fn from_str(s: &str) -> uint { parse_buf(str::bytes(s), 10u) }\n+fn from_str(s: str) -> uint { parse_buf(str::bytes(s), 10u) }\n \n fn to_str(num: uint, radix: uint) -> str {\n     let n = num;"}, {"sha": "d5f2a36340921b2ffc6650de5a4da0e2e4a430f8", "filename": "src/lib/unsafe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Funsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Funsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Funsafe.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,14 +1,14 @@\n // Unsafe operations.\n \n native \"rust-intrinsic\" mod rusti {\n-    fn cast<T, U>(src: &T) -> U;\n+    fn cast<T, U>(src: T) -> U;\n }\n \n native \"rust\" mod rustrt {\n     fn leak<@T>(thing: -T);\n }\n \n // Casts the value at `src` to U. The two types must have the same length.\n-fn reinterpret_cast<T, @U>(src: &T) -> U { ret rusti::cast(src); }\n+fn reinterpret_cast<T, @U>(src: T) -> U { ret rusti::cast(src); }\n \n fn leak<@T>(thing: -T) { rustrt::leak(thing); }"}, {"sha": "69418267e9e797cc47cc8ada2a983a94f26bba0d", "filename": "src/lib/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(x: &T) -> T { ret x; }\n+fn id<@T>(x: T) -> T { ret x; }\n \n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n@@ -9,13 +9,13 @@ type rational = {num: int, den: int};\n \n \n // : int::positive(*.den);\n-fn rational_leq(x: &rational, y: &rational) -> bool {\n+fn rational_leq(x: rational, y: rational) -> bool {\n     // NB: Uses the fact that rationals have positive denominators WLOG:\n \n     ret x.num * y.den <= y.num * x.den;\n }\n \n-fn orb(a: &bool, b: &bool) -> bool { ret a || b; }\n+fn orb(a: bool, b: bool) -> bool { ret a || b; }\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "c9970ccb5fcd9c1edf0f8532c2e8b88e046a8deb", "filename": "src/lib/vec.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -6,7 +6,7 @@ import uint::next_power_of_two;\n import ptr::addr_of;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn vec_len<T>(v: &[T]) -> uint;\n+    fn vec_len<T>(v: [T]) -> uint;\n }\n \n native \"rust\" mod rustrt {\n@@ -19,11 +19,11 @@ fn reserve<@T>(v: &mutable [mutable? T], n: uint) {\n     rustrt::vec_reserve_shared(v, n);\n }\n \n-fn len<T>(v: &[mutable? T]) -> uint { ret rusti::vec_len(v); }\n+fn len<T>(v: [mutable? T]) -> uint { ret rusti::vec_len(v); }\n \n type init_op<T> = fn(uint) -> T;\n \n-fn init_fn<@T>(op: &init_op<T>, n_elts: uint) -> [T] {\n+fn init_fn<@T>(op: init_op<T>, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -32,15 +32,15 @@ fn init_fn<@T>(op: &init_op<T>, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_fn_mut<@T>(op: &init_op<T>, n_elts: uint) -> [mutable T] {\n+fn init_fn_mut<@T>(op: init_op<T>, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n     while i < n_elts { v += [mutable op(i)]; i += 1u; }\n     ret v;\n }\n \n-fn init_elt<@T>(t: &T, n_elts: uint) -> [T] {\n+fn init_elt<@T>(t: T, n_elts: uint) -> [T] {\n     let v = [];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -49,7 +49,7 @@ fn init_elt<@T>(t: &T, n_elts: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn init_elt_mut<@T>(t: &T, n_elts: uint) -> [mutable T] {\n+fn init_elt_mut<@T>(t: T, n_elts: uint) -> [mutable T] {\n     let v = [mutable];\n     reserve(v, n_elts);\n     let i: uint = 0u;\n@@ -59,51 +59,51 @@ fn init_elt_mut<@T>(t: &T, n_elts: uint) -> [mutable T] {\n \n // FIXME: Possible typestate postcondition:\n // len(result) == len(v) (needs issue #586)\n-fn to_mut<@T>(v: &[T]) -> [mutable T] {\n+fn to_mut<@T>(v: [T]) -> [mutable T] {\n     let vres = [mutable];\n     for t: T in v { vres += [mutable t]; }\n     ret vres;\n }\n \n // Same comment as from_mut\n-fn from_mut<@T>(v: &[mutable T]) -> [T] {\n+fn from_mut<@T>(v: [mutable T]) -> [T] {\n     let vres = [];\n     for t: T in v { vres += [t]; }\n     ret vres;\n }\n \n // Predicates\n-pure fn is_empty<T>(v: &[mutable? T]) -> bool {\n+pure fn is_empty<T>(v: [mutable? T]) -> bool {\n     // FIXME: This would be easier if we could just call len\n     for t: T in v { ret false; }\n     ret true;\n }\n \n-pure fn is_not_empty<T>(v: &[mutable? T]) -> bool { ret !is_empty(v); }\n+pure fn is_not_empty<T>(v: [mutable? T]) -> bool { ret !is_empty(v); }\n \n // Accessors\n \n /// Returns the first element of a vector\n-fn head<@T>(v: &[mutable? T]) : is_not_empty(v) -> T { ret v[0]; }\n+fn head<@T>(v: [mutable? T]) : is_not_empty(v) -> T { ret v[0]; }\n \n /// Returns all but the first element of a vector\n-fn tail<@T>(v: &[mutable? T]) : is_not_empty(v) -> [mutable? T] {\n+fn tail<@T>(v: [mutable? T]) : is_not_empty(v) -> [mutable? T] {\n     ret slice(v, 1u, len(v));\n }\n \n /// Returns the last element of `v`.\n-fn last<@T>(v: &[mutable? T]) -> option::t<T> {\n+fn last<@T>(v: [mutable? T]) -> option::t<T> {\n     if len(v) == 0u { ret none; }\n     ret some(v[len(v) - 1u]);\n }\n \n /// Returns the last element of a non-empty vector `v`.\n-fn last_total<@T>(v: &[mutable? T]) : is_not_empty(v) -> T {\n+fn last_total<@T>(v: [mutable? T]) : is_not_empty(v) -> T {\n     ret v[len(v) - 1u];\n }\n \n /// Returns a copy of the elements from [`start`..`end`) from `v`.\n-fn slice<@T>(v: &[mutable? T], start: uint, end: uint) -> [T] {\n+fn slice<@T>(v: [mutable? T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = [];\n@@ -114,7 +114,7 @@ fn slice<@T>(v: &[mutable? T], start: uint, end: uint) -> [T] {\n }\n \n // TODO: Remove me once we have slots.\n-fn slice_mut<@T>(v: &[mutable? T], start: uint, end: uint) -> [mutable T] {\n+fn slice_mut<@T>(v: [mutable? T], start: uint, end: uint) -> [mutable T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let result = [mutable];\n@@ -151,14 +151,14 @@ fn pop<@T>(v: &mutable [mutable? T]) -> T {\n // Appending\n \n /// Expands the given vector in-place by appending `n` copies of `initval`.\n-fn grow<@T>(v: &mutable [T], n: uint, initval: &T) {\n+fn grow<@T>(v: &mutable [T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [initval]; i += 1u; }\n }\n \n // TODO: Remove me once we have slots.\n-fn grow_mut<@T>(v: &mutable [mutable T], n: uint, initval: &T) {\n+fn grow_mut<@T>(v: &mutable [mutable T], n: uint, initval: T) {\n     reserve(v, next_power_of_two(len(v) + n));\n     let i: uint = 0u;\n     while i < n { v += [mutable initval]; i += 1u; }\n@@ -175,15 +175,15 @@ fn grow_fn<@T>(v: &mutable [T], n: uint, init_fn: fn(uint) -> T) {\n /// Sets the element at position `index` to `val`. If `index` is past the end\n /// of the vector, expands the vector by replicating `initval` to fill the\n /// intervening space.\n-fn grow_set<@T>(v: &mutable [mutable T], index: uint, initval: &T, val: &T) {\n+fn grow_set<@T>(v: &mutable [mutable T], index: uint, initval: T, val: T) {\n     if index >= len(v) { grow_mut(v, index - len(v) + 1u, initval); }\n     v[index] = val;\n }\n \n \n // Functional utilities\n \n-fn map<@T, @U>(f: &block(&T) -> U, v: &[mutable? T]) -> [U] {\n+fn map<@T, @U>(f: block(T) -> U, v: [mutable? T]) -> [U] {\n     let result = [];\n     reserve(result, len(v));\n     for elem: T in v {\n@@ -193,7 +193,7 @@ fn map<@T, @U>(f: &block(&T) -> U, v: &[mutable? T]) -> [U] {\n     ret result;\n }\n \n-fn map2<@T, @U, @V>(f: &block(&T, &U) -> V, v0: &[T], v1: &[U]) -> [V] {\n+fn map2<@T, @U, @V>(f: block(T, U) -> V, v0: [T], v1: [U]) -> [V] {\n     let v0_len = len::<T>(v0);\n     if v0_len != len::<U>(v1) { fail; }\n     let u: [V] = [];\n@@ -202,8 +202,7 @@ fn map2<@T, @U, @V>(f: &block(&T, &U) -> V, v0: &[T], v1: &[U]) -> [V] {\n     ret u;\n }\n \n-fn filter_map<@T, @U>(f: &block(&T) -> option::t<U>, v: &[mutable? T]) ->\n-   [U] {\n+fn filter_map<@T, @U>(f: block(T) -> option::t<U>, v: [mutable? T]) -> [U] {\n     let result = [];\n     for elem: T in v {\n         let elem2 = elem; // satisfies alias checker\n@@ -215,53 +214,53 @@ fn filter_map<@T, @U>(f: &block(&T) -> option::t<U>, v: &[mutable? T]) ->\n     ret result;\n }\n \n-fn foldl<@T, @U>(p: &block(&U, &T) -> U, z: &U, v: &[mutable? T]) -> U {\n+fn foldl<@T, @U>(p: block(U, T) -> U, z: U, v: [mutable? T]) -> U {\n     let sz = len(v);\n     if sz == 0u { ret z; }\n     let first = v[0];\n     let rest = slice(v, 1u, sz);\n     ret p(foldl(p, z, rest), first);\n }\n \n-fn any<T>(f: &block(&T) -> bool, v: &[T]) -> bool {\n+fn any<T>(f: block(T) -> bool, v: [T]) -> bool {\n     for elem: T in v { if f(elem) { ret true; } }\n     ret false;\n }\n \n-fn all<T>(f: &block(&T) -> bool, v: &[T]) -> bool {\n+fn all<T>(f: block(T) -> bool, v: [T]) -> bool {\n     for elem: T in v { if !f(elem) { ret false; } }\n     ret true;\n }\n \n-fn member<T>(x: &T, v: &[T]) -> bool {\n+fn member<T>(x: T, v: [T]) -> bool {\n     for elt: T in v { if x == elt { ret true; } }\n     ret false;\n }\n \n-fn count<T>(x: &T, v: &[mutable? T]) -> uint {\n+fn count<T>(x: T, v: [mutable? T]) -> uint {\n     let cnt = 0u;\n     for elt: T in v { if x == elt { cnt += 1u; } }\n     ret cnt;\n }\n \n-fn find<@T>(f: &block(&T) -> bool, v: &[T]) -> option::t<T> {\n+fn find<@T>(f: block(T) -> bool, v: [T]) -> option::t<T> {\n     for elt: T in v { if f(elt) { ret some(elt); } }\n     ret none;\n }\n \n-fn position<@T>(x: &T, v: &[T]) -> option::t<uint> {\n+fn position<@T>(x: T, v: [T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if x == v[i] { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n-fn position_pred<T>(f: fn(&T) -> bool, v: &[T]) -> option::t<uint> {\n+fn position_pred<T>(f: fn(T) -> bool, v: [T]) -> option::t<uint> {\n     let i: uint = 0u;\n     while i < len(v) { if f(v[i]) { ret some::<uint>(i); } i += 1u; }\n     ret none;\n }\n \n-pure fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n+pure fn same_length<T, U>(xs: [T], ys: [U]) -> bool {\n     let xlen = unchecked{ vec::len(xs) };\n     let ylen = unchecked{ vec::len(ys) };\n     xlen == ylen\n@@ -271,13 +270,13 @@ pure fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n // saying the two result lists have the same length -- or, could\n // return a nominal record with a constraint saying that, instead of\n // returning a tuple (contingent on issue #869)\n-fn unzip<@T, @U>(v: &[(T, U)]) -> ([T], [U]) {\n+fn unzip<@T, @U>(v: [(T, U)]) -> ([T], [U]) {\n     let as = [], bs = [];\n     for (a, b) in v { as += [a]; bs += [b]; }\n     ret (as, bs);\n }\n \n-fn zip<@T, @U>(v: &[T], u: &[U]) : same_length(v, u) -> [(T, U)] {\n+fn zip<@T, @U>(v: [T], u: [U]) : same_length(v, u) -> [(T, U)] {\n     let zipped = [];\n     let sz = len(v), i = 0u;\n     assert (sz == len(u));\n@@ -286,22 +285,22 @@ fn zip<@T, @U>(v: &[T], u: &[U]) : same_length(v, u) -> [(T, U)] {\n }\n \n // Swaps two elements in a vector\n-fn swap<@T>(v: &[mutable T], a: uint, b: uint) {\n+fn swap<@T>(v: [mutable T], a: uint, b: uint) {\n     let t: T = v[a];\n     v[a] = v[b];\n     v[b] = t;\n }\n \n // In place vector reversal\n-fn reverse<@T>(v: &[mutable T]) {\n+fn reverse<@T>(v: [mutable T]) {\n     let i: uint = 0u;\n     let ln = len::<T>(v);\n     while i < ln / 2u { swap(v, i, ln - i - 1u); i += 1u; }\n }\n \n \n // Functional vector reversal. Returns a reversed copy of v.\n-fn reversed<@T>(v: &[T]) -> [T] {\n+fn reversed<@T>(v: [T]) -> [T] {\n     let rs: [T] = [];\n     let i = len::<T>(v);\n     if i == 0u { ret rs; } else { i -= 1u; }\n@@ -326,7 +325,7 @@ fn enum_uints(start: uint, end: uint) : uint::le(start, end) -> [uint] {\n }\n \n // Iterate over a list with with the indexes\n-iter iter2<@T>(v: &[T]) -> (uint, T) {\n+iter iter2<@T>(v: [T]) -> (uint, T) {\n     let i = 0u;\n     for x in v { put (i, x); i += 1u; }\n }\n@@ -343,13 +342,13 @@ mod unsafe {\n         (**repr).fill = new_len * sys::size_of::<T>();\n     }\n \n-    fn to_ptr<T>(v: &[T]) -> *T {\n+    fn to_ptr<T>(v: [T]) -> *T {\n         let repr: **vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n         ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n     }\n }\n \n-fn to_ptr<T>(v: &[T]) -> *T { ret unsafe::to_ptr(v); }\n+fn to_ptr<T>(v: [T]) -> *T { ret unsafe::to_ptr(v); }\n \n // Local Variables:\n // mode: rust;"}, {"sha": "067012491503d3cffb41e6625ef061da68af6283", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,16 +1,16 @@\n \n \n native \"rust\" mod rustrt {\n-    fn rust_list_files(path: &str) -> [str];\n+    fn rust_list_files(path: str) -> [str];\n     fn rust_file_is_dir(path: str) -> int;\n }\n \n-fn list_dir(path: &str) -> [str] {\n+fn list_dir(path: str) -> [str] {\n     let path = path + \"*\";\n     ret rustrt::rust_list_files(path);\n }\n \n-fn path_is_absolute(p: &str) -> bool {\n+fn path_is_absolute(p: str) -> bool {\n     ret str::char_at(p, 0u) == '/' ||\n             str::char_at(p, 1u) == ':' && str::char_at(p, 2u) == '\\\\';\n }"}, {"sha": "7cd3f58cdcadf9d3028f867e7c0a9721225b0bf9", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -49,7 +49,7 @@ fn exec_suffix() -> str { ret \".exe\"; }\n \n fn target_os() -> str { ret \"win32\"; }\n \n-fn dylib_filename(base: &str) -> str { ret base + \".dll\"; }\n+fn dylib_filename(base: str) -> str { ret base + \".dll\"; }\n \n fn pipe() -> {in: int, out: int} {\n     // Windows pipes work subtly differently than unix pipes, and their"}, {"sha": "aa79590a24687aeeca9f91397180b9eb59ee827b", "filename": "src/test/bench/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-iter.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -22,7 +22,7 @@ fn b8() -> str {\n     ret \"Go to the store and buy some more, # of beer on the wall.\";\n }\n \n-fn sub(t: &str, n: int) -> str {\n+fn sub(t: str, n: int) -> str {\n     let b: str = \"\";\n     let i: uint = 0u;\n     let ns: str;"}, {"sha": "2db6321d257a928b0e4e8f5615b036068697f0fc", "filename": "src/test/bench/99bob-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-simple.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -22,7 +22,7 @@ fn b8() -> str {\n     ret \"Go to the store and buy some more, # of beer on the wall.\";\n }\n \n-fn sub(t: &str, n: int) -> str {\n+fn sub(t: str, n: int) -> str {\n     let b: str = \"\";\n     let i: uint = 0u;\n     let ns: str;"}, {"sha": "2fbadc2461c53fb0316367665f3ac12a1f43bbda", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -23,16 +23,16 @@ obj myrandom(mutable last: u32) {\n \n type aminoacids = {ch: char, prob: u32};\n \n-fn make_cumulative(aa: &[aminoacids]) -> [aminoacids] {\n+fn make_cumulative(aa: [aminoacids]) -> [aminoacids] {\n     let cp: u32 = 0u32;\n     let ans: [aminoacids] = [];\n     for a: aminoacids in aa { cp += a.prob; ans += [{ch: a.ch, prob: cp}]; }\n     ret ans;\n }\n \n-fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n+fn select_random(r: u32, genelist: [aminoacids]) -> char {\n     if r < genelist[0].prob { ret genelist[0].ch; }\n-    fn bisect(v: &[aminoacids], lo: uint, hi: uint, target: u32) -> char {\n+    fn bisect(v: [aminoacids], lo: uint, hi: uint, target: u32) -> char {\n         if hi > lo + 1u {\n             let mid: uint = lo + (hi - lo) / 2u;\n             if target < v[mid].prob {\n@@ -43,7 +43,7 @@ fn select_random(r: u32, genelist: &[aminoacids]) -> char {\n     ret bisect(genelist, 0u, vec::len::<aminoacids>(genelist) - 1u, r);\n }\n \n-fn make_random_fasta(id: &str, desc: &str, genelist: &[aminoacids], n: int) {\n+fn make_random_fasta(id: str, desc: str, genelist: [aminoacids], n: int) {\n     log \">\" + id + \" \" + desc;\n     let rng = myrandom(std::rand::mk_rng().next());\n     let op: str = \"\";\n@@ -54,7 +54,7 @@ fn make_random_fasta(id: &str, desc: &str, genelist: &[aminoacids], n: int) {\n     if str::byte_len(op) > 0u { log op; }\n }\n \n-fn make_repeat_fasta(id: &str, desc: &str, s: &str, n: int) {\n+fn make_repeat_fasta(id: str, desc: str, s: str, n: int) {\n     log \">\" + id + \" \" + desc;\n     let op: str = \"\";\n     let sl: uint = str::byte_len(s);"}, {"sha": "92da06f186a824332dad170578e2ac359c220959", "filename": "src/test/bench/shootout-nbody.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Fshootout-nbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-nbody.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -56,7 +56,7 @@ mod NBodySystem {\n         ret bodies;\n     }\n \n-    fn advance(bodies: &[Body::props], dt: float) {\n+    fn advance(bodies: [Body::props], dt: float) {\n \n         let i: int = 0;\n         while i < 5 {\n@@ -70,7 +70,7 @@ mod NBodySystem {\n         while i < 5 { move(bodies[i], dt); i += 1; }\n     }\n \n-    fn advance_one(bi: &Body::props, bj: &Body::props, dt: float) {\n+    fn advance_one(bi: Body::props, bj: Body::props, dt: float) {\n         let dx: float = bi.x - bj.x;\n         let dy: float = bi.y - bj.y;\n         let dz: float = bi.z - bj.z;\n@@ -89,13 +89,13 @@ mod NBodySystem {\n         bj.vz += dz * bi.mass * mag;\n     }\n \n-    fn move(b: &Body::props, dt: float) {\n+    fn move(b: Body::props, dt: float) {\n         b.x += dt * b.vx;\n         b.y += dt * b.vy;\n         b.z += dt * b.vz;\n     }\n \n-    fn energy(bodies: &[Body::props]) -> float {\n+    fn energy(bodies: [Body::props]) -> float {\n         let dx: float;\n         let dy: float;\n         let dz: float;\n@@ -194,7 +194,7 @@ mod Body {\n              mass: SOLAR_MASS};\n     }\n \n-    fn offsetMomentum(props: &Body::props, px: float, py: float, pz: float) {\n+    fn offsetMomentum(props: Body::props, px: float, py: float, pz: float) {\n         props.vx = -px / SOLAR_MASS;\n         props.vy = -py / SOLAR_MASS;\n         props.vz = -pz / SOLAR_MASS;"}, {"sha": "1531a3f61b299ba95a294d732cb7a845609260e1", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -49,7 +49,7 @@ fn fib(n: int) -> int {\n \n type config = {stress: bool};\n \n-fn parse_opts(argv: &[str]) -> config {\n+fn parse_opts(argv: [str]) -> config {\n     let opts = [getopts::optflag(\"stress\")];\n \n     let opt_args = vec::slice(argv, 1u, vec::len(argv));"}, {"sha": "24df1508f9f9c3abd2d5f8a921554829426a6d39", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -29,7 +29,7 @@ import std::comm::port;\n import std::comm::recv;\n import std::comm::send;\n \n-fn map(filename: &[u8], emit: &map_reduce::putter<[u8], int>) {\n+fn map(filename: [u8], emit: map_reduce::putter<[u8], int>) {\n     let f = io::file_reader(str::unsafe_from_bytes(filename));\n \n     while true {\n@@ -40,7 +40,7 @@ fn map(filename: &[u8], emit: &map_reduce::putter<[u8], int>) {\n     }\n }\n \n-fn reduce(word: &[u8], get: &map_reduce::getter<int>) {\n+fn reduce(word: [u8], get: map_reduce::getter<int>) {\n     let count = 0;\n \n     while true { alt get() { some(_) { count += 1; } none. { break } } }\n@@ -53,15 +53,15 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter<~K, ~V> = fn(&K, &V);\n+    type putter<~K, ~V> = fn(K, V);\n \n     // FIXME: the first K1 parameter should probably be a -, but that\n     // doesn't parse at the moment.\n-    type mapper<~K1, ~K2, ~V> = fn(&K1, &putter<K2, V>);\n+    type mapper<~K1, ~K2, ~V> = fn(K1, putter<K2, V>);\n \n     type getter<~V> = fn() -> option<V>;\n \n-    type reducer<~K, ~V> = fn(&K, &getter<V>);\n+    type reducer<~K, ~V> = fn(K, getter<V>);\n \n     tag ctrl_proto<~K, ~V> {\n         find_reducer(K, chan<chan<reduce_proto<V>>>);\n@@ -72,7 +72,7 @@ mod map_reduce {\n \n     fn start_mappers<~K1, ~K2,\n                      ~V>(map: mapper<K1, K2, V>,\n-                         ctrl: chan<ctrl_proto<K2, V>>, inputs: &[K1]) ->\n+                         ctrl: chan<ctrl_proto<K2, V>>, inputs: [K1]) ->\n        [joinable_task] {\n         let tasks = [];\n         for i in inputs {\n@@ -89,8 +89,8 @@ mod map_reduce {\n         let intermediates = treemap::init();\n \n         fn emit<~K2,\n-                ~V>(im: &treemap::treemap<K2, chan<reduce_proto<V>>>,\n-                    ctrl: &chan<ctrl_proto<K2, V>>, key: &K2, val: &V) {\n+                ~V>(im: treemap::treemap<K2, chan<reduce_proto<V>>>,\n+                    ctrl: chan<ctrl_proto<K2, V>>, key: K2, val: V) {\n             let c;\n             alt treemap::find(im, key) {\n               some(_c) { c = _c }\n@@ -107,7 +107,7 @@ mod map_reduce {\n \n         map(input, bind emit(intermediates, ctrl, _, _));\n \n-        fn finish<~K, ~V>(k: &K, v: &chan<reduce_proto<V>>) {\n+        fn finish<~K, ~V>(k: K, v: chan<reduce_proto<V>>) {\n             send(v, release);\n         }\n         treemap::traverse(intermediates, finish);\n@@ -124,7 +124,7 @@ mod map_reduce {\n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get<~V>(p: &port<reduce_proto<V>>, ref_count: &mutable int,\n+        fn get<~V>(p: port<reduce_proto<V>>, ref_count: &mutable int,\n                    is_done: &mutable bool) -> option<V> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n@@ -148,7 +148,7 @@ mod map_reduce {\n \n     fn map_reduce<~K1, ~K2,\n                   ~V>(map: mapper<K1, K2, V>, reduce: reducer<K2, V>,\n-                      inputs: &[K1]) {\n+                      inputs: [K1]) {\n         let ctrl = port();\n \n         // This task becomes the master control task. It task::_spawns\n@@ -190,7 +190,7 @@ mod map_reduce {\n             }\n         }\n \n-        fn finish<~K, ~V>(k: &K, v: &chan<reduce_proto<V>>) { send(v, done); }\n+        fn finish<~K, ~V>(k: K, v: chan<reduce_proto<V>>) { send(v, done); }\n         treemap::traverse(reducers, finish);\n \n         for t in tasks { task::join(t); }"}, {"sha": "9ec856b9c47d8560bdd8145b206079641b30f4bb", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -29,7 +29,7 @@ import std::comm::port;\n import std::comm::recv;\n import std::comm::send;\n \n-fn map(filename: &str, emit: map_reduce::putter) {\n+fn map(filename: str, emit: map_reduce::putter) {\n     let f = io::file_reader(filename);\n \n \n@@ -38,7 +38,7 @@ fn map(filename: &str, emit: map_reduce::putter) {\n     }\n }\n \n-fn reduce(word: &str, get: map_reduce::getter) {\n+fn reduce(word: str, get: map_reduce::getter) {\n     let count = 0;\n \n \n@@ -52,13 +52,13 @@ mod map_reduce {\n     export reducer;\n     export map_reduce;\n \n-    type putter = fn(&str, int);\n+    type putter = fn(str, int);\n \n-    type mapper = fn(&str, putter);\n+    type mapper = fn(str, putter);\n \n     type getter = fn() -> option<int>;\n \n-    type reducer = fn(&str, getter);\n+    type reducer = fn(str, getter);\n \n     tag ctrl_proto {\n         find_reducer(str, chan<chan<reduce_proto>>);\n@@ -67,7 +67,7 @@ mod map_reduce {\n \n     tag reduce_proto { emit_val(int); done; ref; release; }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[str]) ->\n+    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: [str]) ->\n        [joinable_task] {\n         let tasks = [];\n         for i: str in inputs {\n@@ -76,12 +76,12 @@ mod map_reduce {\n         ret tasks;\n     }\n \n-    fn map_task(ctrl: chan<ctrl_proto>, input: &str) {\n+    fn map_task(ctrl: chan<ctrl_proto>, input: str) {\n         // log_err \"map_task \" + input;\n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap<str, chan<reduce_proto>>,\n-                ctrl: chan<ctrl_proto>, key: &str, val: int) {\n+        fn emit(im: map::hashmap<str, chan<reduce_proto>>,\n+                ctrl: chan<ctrl_proto>, key: str, val: int) {\n             let c;\n             alt im.find(key) {\n               some(_c) {\n@@ -109,15 +109,15 @@ mod map_reduce {\n         send(ctrl, mapper_done);\n     }\n \n-    fn reduce_task(key: &str, out: chan<chan<reduce_proto>>) {\n+    fn reduce_task(key: str, out: chan<chan<reduce_proto>>) {\n         let p = port();\n \n         send(out, chan(p));\n \n         let ref_count = 0;\n         let is_done = false;\n \n-        fn get(p: &port<reduce_proto>, ref_count: &mutable int,\n+        fn get(p: port<reduce_proto>, ref_count: &mutable int,\n                is_done: &mutable bool) -> option<int> {\n             while !is_done || ref_count > 0 {\n                 alt recv(p) {\n@@ -139,7 +139,7 @@ mod map_reduce {\n         reduce(key, bind get(p, ref_count, is_done));\n     }\n \n-    fn map_reduce(inputs: &[str]) {\n+    fn map_reduce(inputs: [str]) {\n         let ctrl = port::<ctrl_proto>();\n \n         // This task becomes the master control task. It task::_spawns"}, {"sha": "37d56439c11a3c91efb7bedce95406f48edfd8f0", "filename": "src/test/compile-fail/block-coerce-no.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,9 +3,9 @@\n // Make sure that fn-to-block coercion isn't incorrectly lifted over\n // other tycons.\n \n-fn coerce(b: &block()) -> fn() {\n-    fn lol(f: &fn(&block()) -> fn(), g: &block()) -> fn() { ret f(g); }\n-    fn fn_id(f: &fn()) -> fn() { ret f }\n+fn coerce(b: block()) -> fn() {\n+    fn lol(f: fn(block()) -> fn(), g: block()) -> fn() { ret f(g); }\n+    fn fn_id(f: fn()) -> fn() { ret f }\n     ret lol(fn_id, b);\n }\n "}, {"sha": "f6819fee5c68a37f6192406771d30ebb45e9346b", "filename": "src/test/compile-fail/block-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-copy.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: mismatched kinds\n \n-fn lol(f: &block()) -> block() { ret f; }\n+fn lol(f: block()) -> block() { ret f; }\n fn main() { let i = 8; let f = lol(block () { log_err i; }); f(); }"}, {"sha": "72cd09b18ab0f96a967d78d1ebda6435003b0948", "filename": "src/test/compile-fail/block-deinitializes-upvar.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-deinitializes-upvar.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,10 +1,10 @@\n // error-pattern:Tried to deinitialize a variable declared in a different\n-fn force(f: &block() -> int) -> int { ret f(); }\n+fn force(f: block() -> int) -> int { ret f(); }\n fn main() {\n-    let x = @{x:17, y:2};\n-    let y = @{x:5, y:5};\n+    let x = @{x: 17, y: 2};\n+    let y = @{x: 5, y: 5};\n \n-    let f =  {|&i| log_err i; x <- y; ret 7; };\n+    let f = {|i| log_err i; x <- y; ret 7; };\n     assert (f(5) == 7);\n     log_err x;\n     log_err y;"}, {"sha": "f7d895ac383ecdaac496b15b478aaed06f691ff9", "filename": "src/test/compile-fail/block-require-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-require-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-require-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-require-return.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,3 +1,3 @@\n // error-pattern: not all control paths return\n-fn force(f: &block() -> int) -> int { f() }\n-fn main() { log_err force({ | | }); }\n+fn force(f: block() -> int) -> int { f() }\n+fn main() { log_err force({|| }); }"}, {"sha": "7ad58e45a430ece3cd2466fd43636204d1cd8f16", "filename": "src/test/compile-fail/block-uninit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-uninit.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,4 +1,4 @@\n // error-pattern: Unsatisfied precondition constraint\n \n-fn force(f: &block()) { f(); }\n+fn force(f: block()) { f(); }\n fn main() { let x: int; force(block () { log_err x; }); }"}, {"sha": "a78546e0412eb5dbcc9454e61d3f8b62f34ba497", "filename": "src/test/compile-fail/nested-ty-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnested-ty-params.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:Attempt to use a type argument out of scope\n-fn hd<U>(v: &[U]) -> U {\n-    fn hd1(w: &[U]) -> U { ret w[0]; }\n+fn hd<U>(v: [U]) -> U {\n+    fn hd1(w: [U]) -> U { ret w[0]; }\n \n     ret hd1(v);\n }"}, {"sha": "b1bfb15bff30cc46a5ef8971723d7dbf887c7b47", "filename": "src/test/compile-fail/not-a-pred-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -9,4 +9,5 @@ fn main() {\n \n \n \n+\n }"}, {"sha": "334cba2a27115f17c8d590c734b68a9080cb4918", "filename": "src/test/compile-fail/type-arg-out-of-scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-arg-out-of-scope.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n // error-pattern:Attempt to use a type argument out of scope\n-fn foo<T>(x: &T) {\n-    fn bar(f: fn(&T) -> T) { }\n+fn foo<T>(x: T) {\n+    fn bar(f: fn(T) -> T) { }\n }\n fn main() { foo(1); }"}, {"sha": "7038f6bdbb1ff12e8f3f6157c3c1dc044e60d241", "filename": "src/test/compile-fail/unsafe-alias.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-alias.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,10 +1,8 @@\n // error-pattern:may alias with argument\n \n-fn foo(x: &{mutable x: int}, f: fn()) { log x; }\n+fn foo(x: {mutable x: int}, f: fn()) { log x; }\n \n-fn whoknows(x: @mutable {mutable x: int}) {\n-    *x = {mutable x: 10};\n-}\n+fn whoknows(x: @mutable {mutable x: int}) { *x = {mutable x: 10}; }\n \n fn main() {\n     let box = @mutable {mutable x: 1};"}, {"sha": "3fac666bad499320b3064159db6f984e73793fd2", "filename": "src/test/compile-fail/unsafe-mutable-alias.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-mutable-alias.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,7 +1,8 @@\n // error-pattern:mutable alias to a variable that roots another alias\n \n-fn f(a: &{mutable x: int}, b: &mutable {mutable x: int}) -> int {\n-    b.x += 1; ret a.x + b.x;\n+fn f(a: {mutable x: int}, b: &mutable {mutable x: int}) -> int {\n+    b.x += 1;\n+    ret a.x + b.x;\n }\n \n fn main() { let i = {mutable x: 4}; log f(i, i); }"}, {"sha": "d4dec3c3f00a945719cce9b97549a273ba667773", "filename": "src/test/compile-fail/writing-through-read-alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,6 +4,6 @@\n \n type point = {x: int, y: int, z: int};\n \n-fn f(p: &point) { p.x = 13; }\n+fn f(p: point) { p.x = 13; }\n \n fn main() { let x: point = {x: 10, y: 11, z: 12}; f(x); }"}, {"sha": "6f0b853e6a958370e7115415f003ca3056c816b5", "filename": "src/test/compiletest/compiletest.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fcompiletest.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -27,7 +27,7 @@ fn main(args: [str]) {\n     run_tests(config);\n }\n \n-fn parse_config(args: &[str]) -> config {\n+fn parse_config(args: [str]) -> config {\n     let opts =\n         [getopts::reqopt(\"compile-lib-path\"), getopts::reqopt(\"run-lib-path\"),\n          getopts::reqopt(\"rustc-path\"), getopts::reqopt(\"src-base\"),\n@@ -61,7 +61,7 @@ fn parse_config(args: &[str]) -> config {\n          verbose: getopts::opt_present(match, \"verbose\")};\n }\n \n-fn log_config(config: &config) {\n+fn log_config(config: config) {\n     let c = config;\n     logv(c, #fmt[\"configuration:\"]);\n     logv(c, #fmt[\"compile_lib_path: %s\", config.compile_lib_path]);\n@@ -83,11 +83,11 @@ fn opt_str(maybestr: option::t<str>) -> str {\n     alt maybestr { option::some(s) { s } option::none. { \"(none)\" } }\n }\n \n-fn str_opt(maybestr: &str) -> option::t<str> {\n+fn str_opt(maybestr: str) -> option::t<str> {\n     if maybestr != \"(none)\" { option::some(maybestr) } else { option::none }\n }\n \n-fn str_mode(s: &str) -> mode {\n+fn str_mode(s: str) -> mode {\n     alt s {\n       \"compile-fail\" { mode_compile_fail }\n       \"run-fail\" { mode_run_fail }\n@@ -106,15 +106,15 @@ fn mode_str(mode: mode) -> str {\n     }\n }\n \n-fn run_tests(config: &config) {\n+fn run_tests(config: config) {\n     let opts = test_opts(config);\n     let cx = {config: config, procsrv: procsrv::mk()};\n     let tests = make_tests(cx);\n     test::run_tests_console_(opts, tests.tests, tests.to_task);\n     procsrv::close(cx.procsrv);\n }\n \n-fn test_opts(config: &config) -> test::test_opts {\n+fn test_opts(config: config) -> test::test_opts {\n     {filter:\n          alt config.filter {\n            option::some(s) { option::some(s) }\n@@ -124,9 +124,9 @@ fn test_opts(config: &config) -> test::test_opts {\n }\n \n type tests_and_conv_fn =\n-    {tests: [test::test_desc], to_task: fn(&fn()) -> test::joinable};\n+    {tests: [test::test_desc], to_task: fn(fn()) -> test::joinable};\n \n-fn make_tests(cx: &cx) -> tests_and_conv_fn {\n+fn make_tests(cx: cx) -> tests_and_conv_fn {\n     log #fmt[\"making tests from %s\", cx.config.src_base];\n     let configport = port::<[u8]>();\n     let tests = [];\n@@ -140,7 +140,7 @@ fn make_tests(cx: &cx) -> tests_and_conv_fn {\n     ret {tests: tests, to_task: bind closure_to_task(cx, configport, _)};\n }\n \n-fn is_test(config: &config, testfile: &str) -> bool {\n+fn is_test(config: config, testfile: str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         alt config.mode { mode_pretty. { [\".rs\"] } _ { [\".rc\", \".rs\"] } };\n@@ -160,14 +160,14 @@ fn is_test(config: &config, testfile: &str) -> bool {\n     ret valid;\n }\n \n-fn make_test(cx: &cx, testfile: &str, configport: &port<[u8]>) ->\n+fn make_test(cx: cx, testfile: str, configport: port<[u8]>) ->\n    test::test_desc {\n     {name: make_test_name(cx.config, testfile),\n      fn: make_test_closure(testfile, chan(configport)),\n      ignore: header::is_test_ignored(cx.config, testfile)}\n }\n \n-fn make_test_name(config: &config, testfile: &str) -> str {\n+fn make_test_name(config: config, testfile: str) -> str {\n     #fmt[\"[%s] %s\", mode_str(config.mode), testfile]\n }\n \n@@ -190,8 +190,7 @@ up. Then we'll spawn that data into another task and return the task.\n Really convoluted. Need to think up of a better definition for tests.\n */\n \n-fn make_test_closure(testfile: &str, configchan: chan<[u8]>) ->\n-   test::test_fn {\n+fn make_test_closure(testfile: str, configchan: chan<[u8]>) -> test::test_fn {\n     bind send_config(testfile, configchan)\n }\n \n@@ -209,7 +208,7 @@ break up the config record and pass everything individually to the spawned\n function.\n */\n \n-fn closure_to_task(cx: cx, configport: port<[u8]>, testfn: &fn()) ->\n+fn closure_to_task(cx: cx, configport: port<[u8]>, testfn: fn()) ->\n    test::joinable {\n     testfn();\n     let testfile = recv(configport);"}, {"sha": "9f896c48e7432715b7adc6e07b9186a142c031a8", "filename": "src/test/compiletest/header.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fheader.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -23,7 +23,7 @@ type test_props = {\n };\n \n // Load any test directives embedded in the file\n-fn load_props(testfile: &str) -> test_props {\n+fn load_props(testfile: str) -> test_props {\n     let error_patterns = [];\n     let compile_flags = option::none;\n     let pp_exact = option::none;\n@@ -54,7 +54,7 @@ fn load_props(testfile: &str) -> test_props {\n     };\n }\n \n-fn is_test_ignored(config: &config, testfile: &str) -> bool {\n+fn is_test_ignored(config: config, testfile: str) -> bool {\n     let found = false;\n     for each ln: str in iter_header(testfile) {\n         // FIXME: Can't return or break from iterator\n@@ -66,7 +66,7 @@ fn is_test_ignored(config: &config, testfile: &str) -> bool {\n     ret found;\n }\n \n-iter iter_header(testfile: &str) -> str {\n+iter iter_header(testfile: str) -> str {\n     let rdr = io::file_reader(testfile);\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n@@ -81,15 +81,15 @@ iter iter_header(testfile: &str) -> str {\n     }\n }\n \n-fn parse_error_pattern(line: &str) -> option::t<str> {\n+fn parse_error_pattern(line: str) -> option::t<str> {\n     parse_name_value_directive(line, \"error-pattern\")\n }\n \n-fn parse_compile_flags(line: &str) -> option::t<str> {\n+fn parse_compile_flags(line: str) -> option::t<str> {\n     parse_name_value_directive(line, \"compile-flags\")\n }\n \n-fn parse_pp_exact(line: &str, testfile: &str) -> option::t<str> {\n+fn parse_pp_exact(line: str, testfile: str) -> option::t<str> {\n     alt parse_name_value_directive(line, \"pp-exact\") {\n       option::some(s) { option::some(s) }\n       option::none. {\n@@ -102,12 +102,12 @@ fn parse_pp_exact(line: &str, testfile: &str) -> option::t<str> {\n     }\n }\n \n-fn parse_name_directive(line: &str, directive: &str) -> bool {\n+fn parse_name_directive(line: str, directive: str) -> bool {\n     str::find(line, directive) >= 0\n }\n \n-fn parse_name_value_directive(line: &str,\n-                              directive: &str) -> option::t<str> {\n+fn parse_name_value_directive(line: str,\n+                              directive: str) -> option::t<str> {\n     let keycolon = directive + \":\";\n     if str::find(line, keycolon) >= 0 {\n         let colon = str::find(line, keycolon) as uint;"}, {"sha": "ae98853976e89f63d050a4c61b29baa48e4f81cb", "filename": "src/test/compiletest/procsrv.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fprocsrv.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -47,15 +47,15 @@ fn mk() -> handle {\n     ret {task: option::some(task), chan: recv(setupport)};\n }\n \n-fn from_chan(ch: &reqchan) -> handle { {task: option::none, chan: ch} }\n+fn from_chan(ch: reqchan) -> handle { {task: option::none, chan: ch} }\n \n-fn close(handle: &handle) {\n+fn close(handle: handle) {\n     send(handle.chan, stop);\n     task::join(option::get(handle.task));\n }\n \n-fn run(handle: &handle, lib_path: &str, prog: &str, args: &[str],\n-       input: &option::t<str>) -> {status: int, out: str, err: str} {\n+fn run(handle: handle, lib_path: str, prog: str, args: [str],\n+       input: option::t<str>) -> {status: int, out: str, err: str} {\n     let p = port();\n     let ch = chan(p);\n     send(handle.chan,\n@@ -70,7 +70,7 @@ fn run(handle: &handle, lib_path: &str, prog: &str, args: &[str],\n     ret {status: status, out: output, err: errput};\n }\n \n-fn writeclose(fd: int, s: &option::t<str>) {\n+fn writeclose(fd: int, s: option::t<str>) {\n     if option::is_some(s) {\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n         writer.write_str(option::get(s));\n@@ -151,7 +151,7 @@ fn worker(p: port<request>) {\n     }\n }\n \n-fn with_lib_path<@T>(path: &str, f: fn() -> T) -> T {\n+fn with_lib_path<@T>(path: str, f: fn() -> T) -> T {\n     let maybe_oldpath = getenv(util::lib_path_env_var());\n     append_lib_path(path);\n     let res = f();\n@@ -164,17 +164,17 @@ fn with_lib_path<@T>(path: &str, f: fn() -> T) -> T {\n     ret res;\n }\n \n-fn append_lib_path(path: &str) { export_lib_path(util::make_new_path(path)); }\n+fn append_lib_path(path: str) { export_lib_path(util::make_new_path(path)); }\n \n-fn export_lib_path(path: &str) { setenv(util::lib_path_env_var(), path); }\n+fn export_lib_path(path: str) { setenv(util::lib_path_env_var(), path); }\n \n-fn clone_vecstr(v: &[str]) -> [[u8]] {\n+fn clone_vecstr(v: [str]) -> [[u8]] {\n     let r = [];\n     for t: str in vec::slice(v, 0u, vec::len(v)) { r += [str::bytes(t)]; }\n     ret r;\n }\n \n-fn clone_vecu8str(v: &[[u8]]) -> [str] {\n+fn clone_vecu8str(v: [[u8]]) -> [str] {\n     let r = [];\n     for t in vec::slice(v, 0u, vec::len(v)) {\n         r += [str::unsafe_from_bytes(t)];"}, {"sha": "a715985b2cd252b46b428ee7ea1a1ff403544c6f", "filename": "src/test/compiletest/runtest.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Fruntest.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -18,7 +18,7 @@ import util::logv;\n \n export run;\n \n-fn run(cx: &cx, _testfile: -[u8]) {\n+fn run(cx: cx, _testfile: -[u8]) {\n     let testfile = str::unsafe_from_bytes(_testfile);\n     if cx.config.verbose {\n         // We're going to be dumping a lot of info. Start on a new line.\n@@ -34,7 +34,7 @@ fn run(cx: &cx, _testfile: -[u8]) {\n     }\n }\n \n-fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_cfail_test(cx: cx, props: test_props, testfile: str) {\n     let procres = compile_test(cx, props, testfile);\n \n     if procres.status == 0 {\n@@ -44,7 +44,7 @@ fn run_cfail_test(cx: &cx, props: &test_props, testfile: &str) {\n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_rfail_test(cx: cx, props: test_props, testfile: str) {\n     let procres = compile_test(cx, props, testfile);\n \n     if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n@@ -67,7 +67,7 @@ fn run_rfail_test(cx: &cx, props: &test_props, testfile: &str) {\n     check_error_patterns(props, testfile, procres);\n }\n \n-fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_rpass_test(cx: cx, props: test_props, testfile: str) {\n     let procres = compile_test(cx, props, testfile);\n \n     if procres.status != 0 { fatal_procres(\"compilation failed!\", procres); }\n@@ -78,7 +78,7 @@ fn run_rpass_test(cx: &cx, props: &test_props, testfile: &str) {\n     if procres.status != 0 { fatal_procres(\"test run failed!\", procres); }\n }\n \n-fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n+fn run_pretty_test(cx: cx, props: test_props, testfile: str) {\n     if option::is_some(props.pp_exact) {\n         logv(cx.config, \"testing for exact pretty-printing\");\n     } else { logv(cx.config, \"testing for converging pretty-printing\"); }\n@@ -131,18 +131,18 @@ fn run_pretty_test(cx: &cx, props: &test_props, testfile: &str) {\n \n     ret;\n \n-    fn print_source(cx: &cx, testfile: &str, src: &str) -> procres {\n+    fn print_source(cx: cx, testfile: str, src: str) -> procres {\n         compose_and_run(cx, testfile, make_pp_args,\n                         cx.config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_pp_args(config: &config, _testfile: &str) -> procargs {\n+    fn make_pp_args(config: config, _testfile: str) -> procargs {\n         let prog = config.rustc_path;\n         let args = [\"-\", \"--pretty\", \"normal\"];\n         ret {prog: prog, args: args};\n     }\n \n-    fn compare_source(expected: &str, actual: &str) {\n+    fn compare_source(expected: str, actual: str) {\n         if expected != actual {\n             error(\"pretty-printed source does match expected source\");\n             let msg =\n@@ -162,20 +162,19 @@ actual:\\n\\\n         }\n     }\n \n-    fn typecheck_source(cx: &cx, testfile: &str, src: &str) -> procres {\n+    fn typecheck_source(cx: cx, testfile: str, src: str) -> procres {\n         compose_and_run(cx, testfile, make_typecheck_args,\n                         cx.config.compile_lib_path, option::some(src))\n     }\n \n-    fn make_typecheck_args(config: &config, _testfile: &str) -> procargs {\n+    fn make_typecheck_args(config: config, _testfile: str) -> procargs {\n         let prog = config.rustc_path;\n         let args = [\"-\", \"--no-trans\", \"--lib\"];\n         ret {prog: prog, args: args};\n     }\n }\n \n-fn check_error_patterns(props: &test_props, testfile: &str,\n-                        procres: &procres) {\n+fn check_error_patterns(props: test_props, testfile: str, procres: procres) {\n     if vec::is_empty(props.error_patterns) {\n         fatal(\"no error pattern specified in \" + testfile);\n     }\n@@ -216,26 +215,25 @@ type procargs = {prog: str, args: [str]};\n \n type procres = {status: int, stdout: str, stderr: str, cmdline: str};\n \n-fn compile_test(cx: &cx, props: &test_props, testfile: &str) -> procres {\n+fn compile_test(cx: cx, props: test_props, testfile: str) -> procres {\n     compose_and_run(cx, testfile, bind make_compile_args(_, props, _),\n                     cx.config.compile_lib_path, option::none)\n }\n \n-fn exec_compiled_test(cx: &cx, props: &test_props, testfile: &str) ->\n-   procres {\n+fn exec_compiled_test(cx: cx, props: test_props, testfile: str) -> procres {\n     compose_and_run(cx, testfile, bind make_run_args(_, props, _),\n                     cx.config.run_lib_path, option::none)\n }\n \n-fn compose_and_run(cx: &cx, testfile: &str,\n-                   make_args: fn(&config, &str) -> procargs, lib_path: &str,\n+fn compose_and_run(cx: cx, testfile: str,\n+                   make_args: fn(config, str) -> procargs, lib_path: str,\n                    input: option::t<str>) -> procres {\n     let procargs = make_args(cx.config, testfile);\n     ret program_output(cx, testfile, lib_path, procargs.prog, procargs.args,\n                        input);\n }\n \n-fn make_compile_args(config: &config, props: &test_props, testfile: &str) ->\n+fn make_compile_args(config: config, props: test_props, testfile: str) ->\n    procargs {\n     let prog = config.rustc_path;\n     let args = [testfile, \"-o\", make_exe_name(config, testfile)];\n@@ -249,11 +247,11 @@ fn make_compile_args(config: &config, props: &test_props, testfile: &str) ->\n     ret {prog: prog, args: args};\n }\n \n-fn make_exe_name(config: &config, testfile: &str) -> str {\n+fn make_exe_name(config: config, testfile: str) -> str {\n     output_base_name(config, testfile) + os::exec_suffix()\n }\n \n-fn make_run_args(config: &config, props: &test_props, testfile: &str) ->\n+fn make_run_args(config: config, props: test_props, testfile: str) ->\n    procargs {\n     let toolargs =\n         if !props.no_valgrind {\n@@ -271,14 +269,14 @@ fn make_run_args(config: &config, props: &test_props, testfile: &str) ->\n     ret {prog: args[0], args: vec::slice(args, 1u, vec::len(args))};\n }\n \n-fn split_maybe_args(argstr: &option::t<str>) -> [str] {\n-    fn rm_whitespace(v: &[str]) -> [str] {\n-        fn flt(s: &str) -> option::t<str> {\n+fn split_maybe_args(argstr: option::t<str>) -> [str] {\n+    fn rm_whitespace(v: [str]) -> [str] {\n+        fn flt(s: str) -> option::t<str> {\n             if !is_whitespace(s) { option::some(s) } else { option::none }\n         }\n \n         // FIXME: This should be in std\n-        fn is_whitespace(s: &str) -> bool {\n+        fn is_whitespace(s: str) -> bool {\n             for c: u8 in s { if c != ' ' as u8 { ret false; } }\n             ret true;\n         }\n@@ -291,8 +289,8 @@ fn split_maybe_args(argstr: &option::t<str>) -> [str] {\n     }\n }\n \n-fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n-                  args: &[str], input: option::t<str>) -> procres {\n+fn program_output(cx: cx, testfile: str, lib_path: str, prog: str,\n+                  args: [str], input: option::t<str>) -> procres {\n     let cmdline =\n         {\n             let cmdline = make_cmdline(lib_path, prog, args);\n@@ -307,43 +305,41 @@ fn program_output(cx: &cx, testfile: &str, lib_path: &str, prog: &str,\n          cmdline: cmdline};\n }\n \n-fn make_cmdline(libpath: &str, prog: &str, args: &[str]) -> str {\n+fn make_cmdline(libpath: str, prog: str, args: [str]) -> str {\n     #fmt[\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n          str::connect(args, \" \")]\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n-fn lib_path_cmd_prefix(path: &str) -> str {\n+fn lib_path_cmd_prefix(path: str) -> str {\n     #fmt[\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path)]\n }\n \n-fn dump_output(config: &config, testfile: &str, out: &str, err: &str) {\n+fn dump_output(config: config, testfile: str, out: str, err: str) {\n     dump_output_file(config, testfile, out, \"out\");\n     dump_output_file(config, testfile, err, \"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n #[cfg(target_os = \"win32\")]\n #[cfg(target_os = \"linux\")]\n-fn dump_output_file(config: &config, testfile: &str, out: &str,\n-                    extension: &str) {\n+fn dump_output_file(config: config, testfile: str, out: str, extension: str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer = io::file_writer(outfile, [io::create, io::truncate]);\n     writer.write_str(out);\n }\n \n // FIXME (726): Can't use file_writer on mac\n #[cfg(target_os = \"macos\")]\n-fn dump_output_file(config: &config, testfile: &str, out: &str,\n-                    extension: &str) {\n+fn dump_output_file(config: config, testfile: str, out: str, extension: str) {\n }\n \n-fn make_out_name(config: &config, testfile: &str, extension: &str) -> str {\n+fn make_out_name(config: config, testfile: str, extension: str) -> str {\n     output_base_name(config, testfile) + \".\" + extension\n }\n \n-fn output_base_name(config: &config, testfile: &str) -> str {\n+fn output_base_name(config: config, testfile: str) -> str {\n     let base = config.build_base;\n     let filename =\n         {\n@@ -354,7 +350,7 @@ fn output_base_name(config: &config, testfile: &str) -> str {\n     #fmt[\"%s%s.%s\", base, filename, config.stage_id]\n }\n \n-fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n+fn maybe_dump_to_stdout(config: config, out: str, err: str) {\n     if config.verbose {\n         let sep1 = #fmt[\"------%s------------------------------\", \"stdout\"];\n         let sep2 = #fmt[\"------%s------------------------------\", \"stderr\"];\n@@ -367,11 +363,11 @@ fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     }\n }\n \n-fn error(err: &str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n+fn error(err: str) { io::stdout().write_line(#fmt[\"\\nerror: %s\", err]); }\n \n-fn fatal(err: &str) -> ! { error(err); fail; }\n+fn fatal(err: str) -> ! { error(err); fail; }\n \n-fn fatal_procres(err: &str, procres: procres) -> ! {\n+fn fatal_procres(err: str, procres: procres) -> ! {\n     let msg =\n         #fmt[\"\\n\\\n error: %s\\n\\"}, {"sha": "855aeb26e99bd475fc9b16312d73d1947e58480a", "filename": "src/test/compiletest/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompiletest%2Futil.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,7 +5,7 @@ import std::str;\n \n import common::config;\n \n-fn make_new_path(path: &str) -> str {\n+fn make_new_path(path: str) -> str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n@@ -24,7 +24,7 @@ fn lib_path_env_var() -> str { \"DYLD_LIBRARY_PATH\" }\n #[cfg(target_os = \"win32\")]\n fn lib_path_env_var() -> str { \"PATH\" }\n \n-fn logv(config: &config, s: &str) {\n+fn logv(config: config, s: str) {\n     log s;\n     if config.verbose { io::stdout().write_line(s); }\n }"}, {"sha": "75474a17a751a8466a06d4b1b3c99baf3c5fc958", "filename": "src/test/run-fail/port-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-fail%2Fport-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-fail%2Fport-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fport-type.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,7 +5,7 @@ import std::comm::port;\n import std::comm::send;\n import std::comm::recv;\n \n-fn echo<~T>(c: &chan<T>, oc: &chan<chan<T>>) {\n+fn echo<~T>(c: chan<T>, oc: chan<chan<T>>) {\n     // Tests that the type argument in port gets\n     // visited\n     let p = port::<T>();"}, {"sha": "9b7e0001f3cc1e208ecf8a6f82496482df02edae", "filename": "src/test/run-pass/alias-uninit-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falias-uninit-value.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -9,7 +9,7 @@ tag sty { ty_nil; }\n \n type raw_t = {struct: sty, cname: option::t<str>, hash: uint};\n \n-fn mk_raw_ty(st: sty, cname: &option::t<str>) -> raw_t {\n+fn mk_raw_ty(st: sty, cname: option::t<str>) -> raw_t {\n     ret {struct: st, cname: cname, hash: 0u};\n }\n "}, {"sha": "e6cf1dec958ae27b1d03c9f1cf4806e05c1bad81", "filename": "src/test/run-pass/alt-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Falt-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Falt-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-join.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,7 +5,7 @@ import std::option::t;\n import std::option::none;\n import std::option::some;\n \n-fn foo<T>(y: &option::t<T>) {\n+fn foo<T>(y: option::t<T>) {\n     let x: int;\n     let rs: [int] = [];\n     /* tests that x doesn't get put in the precondition for the"}, {"sha": "32ce6ed6ef9ad39dbad8ed15053a7b16a2f4f9b7", "filename": "src/test/run-pass/argument-passing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargument-passing.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -6,13 +6,13 @@ fn f1(a: {mutable x: int}, b: &mutable int, c: -int) -> int {\n     ret r;\n }\n \n-fn f2(a: int, f: block(x: int)) -> int { f(1); ret a; }\n+fn f2(a: int, f: block(int)) -> int { f(1); ret a; }\n \n fn main() {\n     let a = {mutable x: 1}, b = 2, c = 3;\n     assert (f1(a, b, c) == 6);\n     assert (a.x == 0);\n     assert (b == 10);\n-    assert (f2(a.x, {| x | a.x = 50; }) == 0);\n+    assert (f2(a.x, {|x| a.x = 50; }) == 0);\n     assert (a.x == 50);\n }"}, {"sha": "8def06bfe98538a14f94cf383c66499c69dda8d0", "filename": "src/test/run-pass/auto-instantiate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-instantiate.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,6 +2,6 @@\n \n \n // -*- rust -*-\n-fn f<@T, @U>(x: &T, y: &U) -> {a: T, b: U} { ret {a: x, b: y}; }\n+fn f<@T, @U>(x: T, y: U) -> {a: T, b: U} { ret {a: x, b: y}; }\n \n fn main() { log f({x: 3, y: 4, z: 5}, 4).a.x; log f(5, 6).a; }"}, {"sha": "29a8527e6f3192af01f1f94f7d04b3279ea2947d", "filename": "src/test/run-pass/autobind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fautobind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fautobind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautobind.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,9 +1,9 @@\n-fn f<@T>(x: &[T]) -> T { ret x[0]; }\n+fn f<@T>(x: [T]) -> T { ret x[0]; }\n \n-fn g(act: fn(&[int]) -> int) -> int { ret act([1, 2, 3]); }\n+fn g(act: fn([int]) -> int) -> int { ret act([1, 2, 3]); }\n \n fn main() {\n     assert (g(f) == 1);\n-    let f1: fn(&[str]) -> str = f;\n+    let f1: fn([str]) -> str = f;\n     assert (f1([\"x\", \"y\", \"z\"]) == \"x\");\n }"}, {"sha": "266ad2ddbed9b4bda6aa15a99f66ce5c8f09b59c", "filename": "src/test/run-pass/bind-parameterized-args-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-parameterized-args-2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n-    fn echo<T>(c: int, x: fn(&T)) { log_err \"wee\"; }\n+    fn echo<T>(c: int, x: fn(T)) { log_err \"wee\"; }\n \n     let y = bind echo(42, _);\n \n-    y(fn (i: &str) { });\n+    y(fn (i: str) { });\n }"}, {"sha": "d1feb5ac91d0d509dfc4e65725d5918ea8737bd3", "filename": "src/test/run-pass/bind-parameterized-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-parameterized-args.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,7 +1,7 @@\n fn main() {\n-    fn echo<T>(c: int, x: &[T]) { }\n+    fn echo<T>(c: int, x: [T]) { }\n \n-    let y: fn(&[int]) = bind echo(42, _);\n+    let y: fn([int]) = bind echo(42, _);\n \n     y([1]);\n }"}, {"sha": "7e70c9d633a495ab2c5385c6a8a05b08115f96f4", "filename": "src/test/run-pass/block-fn-coerce.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-fn-coerce.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,4 +1,4 @@\n-fn force(f: &block() -> int) -> int { ret f(); }\n+fn force(f: block() -> int) -> int { ret f(); }\n fn main() {\n     let f = fn () -> int { ret 7 };\n     assert (force(f) == 7);"}, {"sha": "7b10e124c6400c9f5e7c60411cb36dafc8b8980b", "filename": "src/test/run-pass/block-iter-1.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-1.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,10 +1,9 @@\n-fn iter_vec<T>(v: &[T], f: &block(&T)) { for x: T in v { f(x); } }\n+fn iter_vec<T>(v: [T], f: block(T)) { for x: T in v { f(x); } }\n \n fn main() {\n     let v = [1, 2, 3, 4, 5, 6, 7];\n     let odds = 0;\n-    iter_vec(v,\n-             {|&i| log_err i; if i % 2 == 1 { odds += 1; } log_err odds; });\n+    iter_vec(v, {|i| log_err i; if i % 2 == 1 { odds += 1; } log_err odds; });\n     log_err odds;\n     assert (odds == 4);\n }"}, {"sha": "f80cd2704403bf8cbe0a372276f864b0de75681a", "filename": "src/test/run-pass/block-iter-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-iter-2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,9 +1,9 @@\n-fn iter_vec<T>(v: &[T], f: &block(&T)) { for x: T in v { f(x); } }\n+fn iter_vec<T>(v: [T], f: block(T)) { for x: T in v { f(x); } }\n \n fn main() {\n     let v = [1, 2, 3, 4, 5];\n     let sum = 0;\n-    iter_vec(v, {|&i| iter_vec(v, {|&j| log_err i * j; sum += i * j; }); });\n+    iter_vec(v, {|i| iter_vec(v, {|j| log_err i * j; sum += i * j; }); });\n     log_err sum;\n     assert (sum == 225);\n }"}, {"sha": "da677abebac12739d54bde8b5df0d8d6471f305f", "filename": "src/test/run-pass/block-vec-map2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-vec-map2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,7 +3,7 @@ import std::vec;\n \n fn main() {\n     let v =\n-        std::vec::map2({|&i, &b| if b { -i } else { i } }, [1, 2, 3, 4, 5],\n+        std::vec::map2({|i, b| if b { -i } else { i } }, [1, 2, 3, 4, 5],\n                        [true, false, false, true, true]);\n     log_err v;\n     assert (v == [-1, 2, 3, -4, -5]);"}, {"sha": "54558d1785aaf03cb247021d45e93e8481dc0dc2", "filename": "src/test/run-pass/box-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,7 +2,7 @@\n \n type box<T> = {c: @T};\n \n-fn unbox<@T>(b: &box<T>) -> T { ret *b.c; }\n+fn unbox<@T>(b: box<T>) -> T { ret *b.c; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "827dbb908b4d19d0311f79e28cdb6820d8be944c", "filename": "src/test/run-pass/double-unbox.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fdouble-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fdouble-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdouble-unbox.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n type quux = {bar: int};\n \n-fn g(i: &int) { }\n+fn g(i: int) { }\n fn f(foo: @@quux) { g(foo.bar); }\n \n fn main() { }"}, {"sha": "ce270d7b06b6e1943f2676ad3093e364e692042e", "filename": "src/test/run-pass/drop-parametric-closure-with-bound-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-parametric-closure-with-bound-box.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn f<T>(i: @int, t: &T) { }\n+fn f<T>(i: @int, t: T) { }\n \n fn main() { let x = bind f::<char>(@0xdeafbeef, _); }"}, {"sha": "ce11b0a990ed1d260f03a5b17b3eb6af9358f0f7", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn(@T, @T) -> bool;\n \n-fn test_generic<T>(expected: @T, eq: &compare<T>) {\n+fn test_generic<T>(expected: @T, eq: compare<T>) {\n     let actual: @T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }"}, {"sha": "ec67c72ae0d473e3ac190974304b8e318f16791c", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,15 +2,15 @@\n \n \n // -*- rust -*-\n-type compare<T> = fn(&T, &T) -> bool;\n+type compare<T> = fn(T, T) -> bool;\n \n-fn test_generic<T>(expected: &T, eq: &compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }\n \n fn test_vec() {\n-    fn compare_box(v1: &@int, v2: &@int) -> bool { ret v1 == v2; }\n+    fn compare_box(v1: @int, v2: @int) -> bool { ret v1 == v2; }\n     let eq = bind compare_box(_, _);\n     test_generic::<@int>(@1, eq);\n }"}, {"sha": "d42e669b9ed927c2b107b14784d3b05c4c7f1f89", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,23 +2,23 @@\n \n \n // -*- rust -*-\n-type compare<T> = fn(&T, &T) -> bool;\n+type compare<T> = fn(T, T) -> bool;\n \n-fn test_generic<T>(expected: &T, eq: &compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = alt true { true { expected } };\n     assert (eq(expected, actual));\n }\n \n fn test_bool() {\n-    fn compare_bool(b1: &bool, b2: &bool) -> bool { ret b1 == b2; }\n+    fn compare_bool(b1: bool, b2: bool) -> bool { ret b1 == b2; }\n     let eq = bind compare_bool(_, _);\n     test_generic::<bool>(true, eq);\n }\n \n fn test_rec() {\n     type t = {a: int, b: int};\n \n-    fn compare_rec(t1: &t, t2: &t) -> bool { ret t1 == t2; }\n+    fn compare_rec(t1: t, t2: t) -> bool { ret t1 == t2; }\n     let eq = bind compare_rec(_, _);\n     test_generic::<t>({a: 1, b: 2}, eq);\n }"}, {"sha": "28e5de3a83048a06719a1278dae562843394ff8d", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn(@T, @T) -> bool;\n \n-fn test_generic<T>(expected: @T, eq: &compare<T>) {\n+fn test_generic<T>(expected: @T, eq: compare<T>) {\n     let actual: @T = { expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "e51e30525e0cb4042fec29f415b4b9fbef8892d8", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,15 +2,15 @@\n \n \n // -*- rust -*-\n-type compare<T> = fn(&T, &T) -> bool;\n+type compare<T> = fn(T, T) -> bool;\n \n-fn test_generic<T>(expected: &T, eq: &compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }\n \n fn test_vec() {\n-    fn compare_vec(v1: &@int, v2: &@int) -> bool { ret v1 == v2; }\n+    fn compare_vec(v1: @int, v2: @int) -> bool { ret v1 == v2; }\n     let eq = bind compare_vec(_, _);\n     test_generic::<@int>(@1, eq);\n }"}, {"sha": "48e4a9dff200426c33c34a7a91b11b32c7e4a355", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,23 +4,23 @@\n // -*- rust -*-\n \n // Tests for standalone blocks as expressions with dynamic type sizes\n-type compare<T> = fn(&T, &T) -> bool;\n+type compare<T> = fn(T, T) -> bool;\n \n-fn test_generic<T>(expected: &T, eq: &compare<T>) {\n+fn test_generic<T>(expected: T, eq: compare<T>) {\n     let actual: T = { expected };\n     assert (eq(expected, actual));\n }\n \n fn test_bool() {\n-    fn compare_bool(b1: &bool, b2: &bool) -> bool { ret b1 == b2; }\n+    fn compare_bool(b1: bool, b2: bool) -> bool { ret b1 == b2; }\n     let eq = bind compare_bool(_, _);\n     test_generic::<bool>(true, eq);\n }\n \n fn test_rec() {\n     type t = {a: int, b: int};\n \n-    fn compare_rec(t1: &t, t2: &t) -> bool { ret t1 == t2; }\n+    fn compare_rec(t1: t, t2: t) -> bool { ret t1 == t2; }\n     let eq = bind compare_rec(_, _);\n     test_generic::<t>({a: 1, b: 2}, eq);\n }"}, {"sha": "30ba5fa79e4bee19ab792176f553a06f99f5b9b5", "filename": "src/test/run-pass/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-fn.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -9,7 +9,7 @@ fn test_vec() {\n }\n \n fn test_generic() {\n-    fn f<T>(t: &T) -> T { t }\n+    fn f<T>(t: T) -> T { t }\n     assert (f(10) == 10);\n }\n "}, {"sha": "4b23d1a6e3f082464d54b4dffba221d0e96a5541", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n type compare<T> = fn(@T, @T) -> bool;\n \n-fn test_generic<T>(expected: @T, not_expected: @T, eq: &compare<T>) {\n+fn test_generic<T>(expected: @T, not_expected: @T, eq: compare<T>) {\n     let actual: @T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }"}, {"sha": "fd56d79dab9f87335a77ba77159a731dadba6dc2", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,15 +2,15 @@\n \n \n // -*- rust -*-\n-type compare<T> = fn(&T, &T) -> bool;\n+type compare<T> = fn(T, T) -> bool;\n \n-fn test_generic<T>(expected: &T, not_expected: &T, eq: &compare<T>) {\n+fn test_generic<T>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }\n \n fn test_vec() {\n-    fn compare_box(v1: &@int, v2: &@int) -> bool { ret v1 == v2; }\n+    fn compare_box(v1: @int, v2: @int) -> bool { ret v1 == v2; }\n     let eq = bind compare_box(_, _);\n     test_generic::<@int>(@1, @2, eq);\n }"}, {"sha": "154290319c11e6268e821279f6a80d6cfa6672ea", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,23 +4,23 @@\n // -*- rust -*-\n \n // Tests for if as expressions with dynamic type sizes\n-type compare<T> = fn(&T, &T) -> bool;\n+type compare<T> = fn(T, T) -> bool;\n \n-fn test_generic<T>(expected: &T, not_expected: &T, eq: &compare<T>) {\n+fn test_generic<T>(expected: T, not_expected: T, eq: compare<T>) {\n     let actual: T = if true { expected } else { not_expected };\n     assert (eq(expected, actual));\n }\n \n fn test_bool() {\n-    fn compare_bool(b1: &bool, b2: &bool) -> bool { ret b1 == b2; }\n+    fn compare_bool(b1: bool, b2: bool) -> bool { ret b1 == b2; }\n     let eq = bind compare_bool(_, _);\n     test_generic::<bool>(true, false, eq);\n }\n \n fn test_rec() {\n     type t = {a: int, b: int};\n \n-    fn compare_rec(t1: &t, t2: &t) -> bool { ret t1 == t2; }\n+    fn compare_rec(t1: t, t2: t) -> bool { ret t1 == t2; }\n     let eq = bind compare_rec(_, _);\n     test_generic::<t>({a: 1, b: 2}, {a: 2, b: 3}, eq);\n }"}, {"sha": "53f93347c7424d7237661cc03f59c1b6c040a055", "filename": "src/test/run-pass/fixed-point-bind-box.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-box.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,12 +1,12 @@\n-fn fix_help<A, @B>(f: @fn(@fn(&A) -> B, &A) -> B, x: &A) -> B {\n+fn fix_help<A, @B>(f: @fn(@fn(A) -> B, A) -> B, x: A) -> B {\n     ret f(@bind fix_help(f, _), x);\n }\n \n-fn fix<A, @B>(f: @fn(@fn(&A) -> B, &A) -> B) -> @fn(&A) -> B {\n+fn fix<A, @B>(f: @fn(@fn(A) -> B, A) -> B) -> @fn(A) -> B {\n     ret @bind fix_help(f, _);\n }\n \n-fn fact_(f: @fn(&int) -> int, n: &int) -> int {\n+fn fact_(f: @fn(int) -> int, n: int) -> int {\n     // fun fact 0 = 1\n     ret if n == 0 { 1 } else { n * f(n - 1) };\n }"}, {"sha": "960ef4e20a621b8c12d519a226904ceaeffc690c", "filename": "src/test/run-pass/foreach-box-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-box-drop.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,6 +4,6 @@ obj ob<K>(k: K) {\n     iter foo() -> @{a: K} { put @{a: k}; }\n }\n \n-fn x(o: &ob<str>) { for each i: @{a: str} in o.foo() { } }\n+fn x(o: ob<str>) { for each i: @{a: str} in o.foo() { } }\n \n fn main() { let o = ob::<str>(\"hi\" + \"there\"); x(o); }"}, {"sha": "cf7e8ba499c24e32f82aa98ff0af12830df1f58c", "filename": "src/test/run-pass/generic-alias-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-box.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(t: &T) -> T { ret t; }\n+fn id<@T>(t: T) -> T { ret t; }\n \n fn main() {\n     let expected = @100;"}, {"sha": "8d584534fd86218a22442d0518814fcd7f858dde", "filename": "src/test/run-pass/generic-bind-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind-2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(t: &T) -> T { ret t; }\n+fn id<@T>(t: T) -> T { ret t; }\n \n fn main() {\n     let t = {a: 1, b: 2, c: 3, d: 4, e: 5, f: 6, g: 7};"}, {"sha": "320b22c0beecc8493fd0000c6eb09484a9c4afea", "filename": "src/test/run-pass/generic-bind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-bind.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn id<@T>(t: &T) -> T { ret t; }\n+fn id<@T>(t: T) -> T { ret t; }\n \n fn main() {\n     let t = {_0: 1, _1: 2, _2: 3, _3: 4, _4: 5, _5: 6, _6: 7};"}, {"sha": "3e37834f47b1e49b7e3f08bc3e703019b1ea6c04", "filename": "src/test/run-pass/generic-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-box.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn box<T>(x: &{x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { ret @x; }\n+fn box<T>(x: {x: T, y: T, z: T}) -> @{x: T, y: T, z: T} { ret @x; }\n \n fn main() {\n     let x: @{x: int, y: int, z: int} = box::<int>({x: 1, y: 2, z: 3});"}, {"sha": "a889021378fe234eee4c741bf381aa7a434d7761", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,8 +1,8 @@\n \n \n-fn g<@X>(x: &X) -> X { ret x; }\n+fn g<@X>(x: X) -> X { ret x; }\n \n-fn f<@T>(t: &T) -> {a: T, b: T} {\n+fn f<@T>(t: T) -> {a: T, b: T} {\n     type pair = {a: T, b: T};\n \n     let x: pair = {a: t, b: t};"}, {"sha": "ad89b7fe55640cd73283981866e37ebd2bdd9e57", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn f<T>(t: &T) { let t1: T = t; }\n+fn f<T>(t: T) { let t1: T = t; }\n \n fn main() { let x = {x: @10, y: @12}; f(x); }"}, {"sha": "7573bff74e85070aa2ecaf8d46e0ba6daaf26aee", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,7 +2,7 @@\n \n type recbox<T> = {x: @T};\n \n-fn reclift<T>(t: &T) -> recbox<T> { ret {x: @t}; }\n+fn reclift<T>(t: T) -> recbox<T> { ret {x: @t}; }\n \n fn main() {\n     let foo: int = 17;"}, {"sha": "b1f5a06ee3497b43ab5a0b508b845bc24de32bd0", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,6 +4,6 @@\n // -*- rust -*-\n \n // Issue #45: infer type parameters in function applications\n-fn id<@T>(x: &T) -> T { ret x; }\n+fn id<@T>(x: T) -> T { ret x; }\n \n fn main() { let x: int = 42; let y: int = id(x); assert (x == y); }"}, {"sha": "d72f32eeb1022a66acc6ebe06e1a90b373123db1", "filename": "src/test/run-pass/generic-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,7 +2,7 @@\n \n \n // -*- rust -*-\n-fn id<@T>(x: &T) -> T { ret x; }\n+fn id<@T>(x: T) -> T { ret x; }\n \n type triple = {x: int, y: int, z: int};\n "}, {"sha": "9d363906487c390bb551e8b238b044e5f35140cb", "filename": "src/test/run-pass/generic-iter-frame.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-iter-frame.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,6 +4,6 @@\n // Contrived example? No. It showed up in rustc's resolve pass.\n iter i() { put (); }\n \n-fn foo<T>(t: &T) { let x: int = 10; for each j: () in i() { log x; } }\n+fn foo<T>(t: T) { let x: int = 10; for each j: () in i() { log x; } }\n \n fn main() { foo(0xdeadbeef_u); }"}, {"sha": "7226345d9c062e560369db251ff20946f7c01e1a", "filename": "src/test/run-pass/generic-obj.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -6,8 +6,8 @@ obj buf<@T>(data: {_0: T, _1: T, _2: T}) {\n             ret data._0;\n         } else { if i == 1 { ret data._1; } else { ret data._2; } }\n     }\n-    fn take(t: &T) { }\n-    fn take2(t: &T) { }\n+    fn take(t: T) { }\n+    fn take2(t: T) { }\n }\n \n fn main() {"}, {"sha": "d6f8dad88bc5ede54fe249c7adb300eb566a818e", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,7 +2,7 @@\n \n tag foo<T> { arm(T); }\n \n-fn altfoo<T>(f: &foo<T>) {\n+fn altfoo<T>(f: foo<T>) {\n     let hit = false;\n     alt f { arm::<T>(x) { log \"in arm\"; hit = true; } }\n     assert (hit);"}, {"sha": "36955938ef306a64cc054515fd5d1bd8f3b73a38", "filename": "src/test/run-pass/generic-temporary.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-temporary.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,12 +2,12 @@\n \n fn mk() -> int { ret 1; }\n \n-fn chk(a: &int) { log a; assert (a == 1); }\n+fn chk(a: int) { log a; assert (a == 1); }\n \n-fn apply<T>(produce: fn() -> T, consume: fn(&T)) { consume(produce()); }\n+fn apply<T>(produce: fn() -> T, consume: fn(T)) { consume(produce()); }\n \n fn main() {\n     let produce: fn() -> int = mk;\n-    let consume: fn(&int) = chk;\n+    let consume: fn(int) = chk;\n     apply::<int>(produce, consume);\n }"}, {"sha": "08bf75b733bee9dabca1c9b3196b8b4f1984c612", "filename": "src/test/run-pass/generic-tup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tup.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,4 +1,4 @@\n-fn get_third<@T>(t: &(T, T, T)) -> T { let (_, _, x) = t; ret x; }\n+fn get_third<@T>(t: (T, T, T)) -> T { let (_, _, x) = t; ret x; }\n \n fn main() {\n     log get_third((1, 2, 3));"}, {"sha": "ebfbd8b4c7b6aaedfdf82b495178cc07302fe538", "filename": "src/test/run-pass/generic-type-synonym.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,6 +4,6 @@ type foo<T> = {a: T};\n \n type bar<T> = foo<T>;\n \n-fn takebar<T>(b: &bar<T>) { }\n+fn takebar<T>(b: bar<T>) { }\n \n fn main() { }"}, {"sha": "0b6b07791d9d335504e5c85e6cc52087c4fc302c", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -19,29 +19,29 @@ import std::comm::send;\n import std::comm::recv;\n import std::comm;\n \n-fn map(filename: &str, emit: map_reduce::putter) { emit(filename, \"1\"); }\n+fn map(filename: str, emit: map_reduce::putter) { emit(filename, \"1\"); }\n \n mod map_reduce {\n     export putter;\n     export mapper;\n     export map_reduce;\n \n-    type putter = fn(&str, &str);\n+    type putter = fn(str, str);\n \n-    type mapper = fn(&str, putter);\n+    type mapper = fn(str, putter);\n \n     tag ctrl_proto { find_reducer([u8], chan<int>); mapper_done; }\n \n-    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: &[str]) {\n+    fn start_mappers(ctrl: chan<ctrl_proto>, inputs: [str]) {\n         for i: str in inputs { task::spawn(bind map_task(ctrl, i)); }\n     }\n \n     fn map_task(ctrl: chan<ctrl_proto>, input: -str) {\n \n         let intermediates = map::new_str_hash();\n \n-        fn emit(im: &map::hashmap<str, int>, ctrl: chan<ctrl_proto>,\n-                key: &str, val: &str) {\n+        fn emit(im: map::hashmap<str, int>, ctrl: chan<ctrl_proto>, key: str,\n+                val: str) {\n             let c;\n             alt im.find(key) {\n               some(_c) { c = _c }\n@@ -61,7 +61,7 @@ mod map_reduce {\n         send(ctrl, mapper_done);\n     }\n \n-    fn map_reduce(inputs: &[str]) {\n+    fn map_reduce(inputs: [str]) {\n         let ctrl = port();\n \n         // This task becomes the master control task. It spawns others"}, {"sha": "20487ed6f4c13da88186b701c7235bd9c63fc831", "filename": "src/test/run-pass/interior-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finterior-vec.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,7 +1,7 @@\n import rusti::vec_len;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn vec_len<T>(v: &[T]) -> uint;\n+    fn vec_len<T>(v: [T]) -> uint;\n }\n \n fn main() {"}, {"sha": "27bbc2506b08dbbae45413e5bb50068dc7f7f437", "filename": "src/test/run-pass/issue-333.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fissue-333.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fissue-333.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-333.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n-fn quux<@T>(x: &T) -> T { let f = id::<T>; ret f(x); }\n+fn quux<@T>(x: T) -> T { let f = id::<T>; ret f(x); }\n \n-fn id<@T>(x: &T) -> T { ret x; }\n+fn id<@T>(x: T) -> T { ret x; }\n \n fn main() { assert (quux(10) == 10); }"}, {"sha": "f9378b213177895a2641d2c0b9d2ae62eb141d6f", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,4 +1,4 @@\n-fn double<T>(a: &T) -> [T] { ret [a] + [a]; }\n+fn double<T>(a: T) -> [T] { ret [a] + [a]; }\n \n fn double_int(a: int) -> [int] { ret [a] + [a]; }\n "}, {"sha": "2c527e4953d057faab979fd6bb252e0ee41e242f", "filename": "src/test/run-pass/lambda-no-leak.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-no-leak.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n // Make sure we don't leak lambdas in silly ways.\n-fn force(f: &fn()) { f() }\n+fn force(f: fn()) { f() }\n fn main() {\n     let x = 7;\n     lambda () { log_err x; }"}, {"sha": "6fb6d759723c1fa5840cef4756b90632417e2c0a", "filename": "src/test/run-pass/leak-box-as-tydesc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fleak-box-as-tydesc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fleak-box-as-tydesc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fleak-box-as-tydesc.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn leaky<T>(t: &T) { }\n+fn leaky<T>(t: T) { }\n \n fn main() { let x = @10; leaky::<@int>(x); }"}, {"sha": "191e3e4b3c7053b867c388e4b75dd5c504bb2e75", "filename": "src/test/run-pass/newtype-polymorphic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype-polymorphic.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,8 +1,8 @@\n tag myvec<X> = [X];\n \n-fn myvec_deref<@X>(mv: &myvec<X>) -> [X] { ret *mv; }\n+fn myvec_deref<@X>(mv: myvec<X>) -> [X] { ret *mv; }\n \n-fn myvec_elt<@X>(mv: &myvec<X>) -> X { ret mv[0]; }\n+fn myvec_elt<@X>(mv: myvec<X>) -> X { ret mv[0]; }\n \n fn main() {\n     let mv = myvec([1, 2, 3]);"}, {"sha": "f1869f8e21b2f12d7483e80dd6402763b89be1d1", "filename": "src/test/run-pass/newtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n-tag mytype = {compute: fn(&mytype) -> int, val: int};\n+tag mytype = {compute: fn(mytype) -> int, val: int};\n \n-fn compute(i: &mytype) -> int { ret i.val + 20; }\n+fn compute(i: mytype) -> int { ret i.val + 20; }\n \n fn main() {\n     let myval = mytype({compute: compute, val: 30});"}, {"sha": "0f1558975a280a6214bd059909aad6ddc82a8bca", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,19 +2,19 @@ use std;\n \n import std::list::*;\n \n-pure fn pure_length_go<@T>(ls: &list<T>, acc: uint) -> uint {\n+pure fn pure_length_go<@T>(ls: list<T>, acc: uint) -> uint {\n     alt ls { nil. { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n }\n \n-pure fn pure_length<@T>(ls: &list<T>) -> uint { pure_length_go(ls, 0u) }\n+pure fn pure_length<@T>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<@T>(ls: &list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<@T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<@T>(ls: &list<T>) : nonempty_list(ls) -> T { car(ls) }\n+fn safe_head<@T>(ls: list<T>) : nonempty_list(ls) -> T { car(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "9aa6694892d104f4b0733473693699bc50049f86", "filename": "src/test/run-pass/or-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2For-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2For-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2For-pattern.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n tag blah { a(int, int, uint); b(int, int); c; }\n \n-fn or_alt(q: &blah) -> int {\n+fn or_alt(q: blah) -> int {\n     alt q { a(x, y, _) | b(x, y) { ret x + y; } c. { ret 0; } }\n }\n "}, {"sha": "adc6432d0166e1f830b7968d753acfcac398b71e", "filename": "src/test/run-pass/readalias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Freadalias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Freadalias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freadalias.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,6 +4,6 @@\n // -*- rust -*-\n type point = {x: int, y: int, z: int};\n \n-fn f(p: &point) { assert (p.z == 12); }\n+fn f(p: point) { assert (p.z == 12); }\n \n fn main() { let x: point = {x: 10, y: 11, z: 12}; f(x); }"}, {"sha": "e5375403dfe86a8094603ee8cb8b7eed057de808", "filename": "src/test/run-pass/rec-tup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Frec-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Frec-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-tup.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,8 +3,8 @@ type point = {x: int, y: int};\n \n type rect = (point, point);\n \n-fn fst(r: &rect) -> point { let (fst, _) = r; ret fst; }\n-fn snd(r: &rect) -> point { let (_, snd) = r; ret snd; }\n+fn fst(r: rect) -> point { let (fst, _) = r; ret fst; }\n+fn snd(r: rect) -> point { let (_, snd) = r; ret snd; }\n \n fn f(r: rect, x1: int, y1: int, x2: int, y2: int) {\n     assert (fst(r).x == x1);"}, {"sha": "06228674e3f8bea1b3fb9b7b97d4e7f6839a578c", "filename": "src/test/run-pass/record-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Frecord-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Frecord-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frecord-pat.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -2,7 +2,7 @@ tag t1 { a(int); b(uint); }\n type t2 = {x: t1, y: int};\n tag t3 { c(t2, uint); }\n \n-fn m(in: &t3) -> int {\n+fn m(in: t3) -> int {\n     alt in {\n       c({x: a(m), _}, _) { ret m; }\n       c({x: b(m), y: y}, z) { ret (m + z as int) + y; }"}, {"sha": "2df6dddb2a487d29d756ccd9051292e3797d7928", "filename": "src/test/run-pass/resource-destruct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fresource-destruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-destruct.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n resource shrinky_pointer(i: @mutable int) { *i -= 1; }\n \n-fn look_at(pt: &shrinky_pointer) -> int { ret **pt; }\n+fn look_at(pt: shrinky_pointer) -> int { ret **pt; }\n \n fn main() {\n     let my_total = @mutable 10;"}, {"sha": "814503c194b08fb71c195c0bba7ddd2917a9f9a2", "filename": "src/test/run-pass/resource-generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fresource-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresource-generic.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,8 +1,8 @@\n-resource finish<T>(arg: {val: T, fin: fn(&T)}) { arg.fin(arg.val); }\n+resource finish<T>(arg: {val: T, fin: fn(T)}) { arg.fin(arg.val); }\n \n fn main() {\n     let box = @mutable 10;\n-    fn dec_box(i: &@mutable int) { *i -= 1; }\n+    fn dec_box(i: @mutable int) { *i -= 1; }\n \n     { let i <- finish({val: box, fin: dec_box}); }\n     assert (*box == 9);"}, {"sha": "9ab1d758fea905cbe348fb8435f894daf444e133", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -6,7 +6,7 @@ import std::comm::port;\n // tests that ctrl's type gets inferred properly\n type command<~K, ~V> = {key: K, val: V};\n \n-fn cache_server<~K, ~V>(c: &chan<chan<command<K, V>>>) {\n+fn cache_server<~K, ~V>(c: chan<chan<command<K, V>>>) {\n     let ctrl = port();\n     send(c, chan(ctrl));\n }"}, {"sha": "10c1e45017de50d9de963ff929dccecf02483dbc", "filename": "src/test/run-pass/size-and-align.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fsize-and-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsize-and-align.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -4,7 +4,7 @@\n // -*- rust -*-\n tag clam<T> { a(T, int); b; }\n \n-fn uhoh<T>(v: &[clam<T>]) {\n+fn uhoh<T>(v: [clam<T>]) {\n     alt v[1] {\n       a::<T>(t, u) { log \"incorrect\"; log u; fail; }\n       b::<T>. { log \"correct\"; }"}, {"sha": "71c3fb99d0336f911a97d8b15d1ed14dedf77d7d", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,4 +1,4 @@\n-fn swap<@T>(v: &[mutable T], i: int, j: int) { v[i] <-> v[j]; }\n+fn swap<@T>(v: [mutable T], i: int, j: int) { v[i] <-> v[j]; }\n \n fn main() {\n     let a: [mutable int] = [mutable 0, 1, 2, 3, 4, 5, 6];"}, {"sha": "c241a68e7f1bd93b331b28f4c9214e71eb036244", "filename": "src/test/run-pass/syntax-extension-fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-fmt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,7 +1,7 @@\n use std;\n import std::str;\n \n-fn test(actual: &str, expected: &str) {\n+fn test(actual: str, expected: str) {\n     log actual;\n     log expected;\n     assert (str::eq(actual, expected));"}, {"sha": "529bb14a9b6072cccd2e2e36d78004f86a5c0467", "filename": "src/test/run-pass/tag-and-generic-obj.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftag-and-generic-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftag-and-generic-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-and-generic-obj.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -3,7 +3,7 @@\n tag colour { red; green; }\n \n obj foo<T>() {\n-    fn meth(x: &T) { }\n+    fn meth(x: T) { }\n }\n \n fn main() { foo::<colour>().meth(red); }"}, {"sha": "2d6a88e625ccbe025371f041863f9d650d293170", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n-fn p_foo<T>(pinned: &T) { }\n-fn s_foo<@T>(shared: &T) { }\n-fn u_foo<~T>(unique: &T) { }\n+fn p_foo<T>(pinned: T) { }\n+fn s_foo<@T>(shared: T) { }\n+fn u_foo<~T>(unique: T) { }\n \n resource r(i: int) { }\n "}, {"sha": "56ad610fcdfc054f42fe1de3ff49ca91427afc04", "filename": "src/test/run-pass/type-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftype-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftype-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n \n \n-type lteq<T> = fn(&T) -> bool;\n+type lteq<T> = fn(T) -> bool;\n \n fn main(args: [str]) { }"}, {"sha": "d734769c7692c989b6508ee85adc5ddb78afad65", "filename": "src/test/run-pass/type-params-in-for-each.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-params-in-for-each.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,7 +5,7 @@ iter range(lo: uint, hi: uint) -> uint {\n     while lo_ < hi { put lo_; lo_ += 1u; }\n }\n \n-fn create_index<T>(index: &[{a: T, b: uint}], hash_fn: fn(&T) -> uint) {\n+fn create_index<T>(index: [{a: T, b: uint}], hash_fn: fn(T) -> uint) {\n     for each i: uint in range(0u, 256u) { let bucket: [T] = []; }\n }\n "}, {"sha": "9c7cfc39963c5b6070860d5e8b4f194fc680e61f", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,24 +5,24 @@ import std::list::*;\n \n // Can't easily be written as a \"pure fn\" because there's\n // no syntax for specifying that f is pure.\n-fn pure_foldl<@T, @U>(ls: &list<T>, u: &U, f: &block(&T, &U) -> U) -> U {\n+fn pure_foldl<@T, @U>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n     alt ls { nil. { u } cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) } }\n }\n \n // Shows how to use an \"unchecked\" block to call a general\n // fn from a pure fn\n-pure fn pure_length<@T>(ls: &list<T>) -> uint {\n-    fn count<T>(_t: &T, u: &uint) -> uint { u + 1u }\n+pure fn pure_length<@T>(ls: list<T>) -> uint {\n+    fn count<T>(_t: T, u: uint) -> uint { u + 1u }\n     unchecked{ pure_foldl(ls, 0u, count) }\n }\n \n-pure fn nonempty_list<@T>(ls: &list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<@T>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"tag refinement\", if we implement those.\n-fn safe_head<@T>(ls: &list<T>) : nonempty_list(ls) -> T { car(ls) }\n+fn safe_head<@T>(ls: list<T>) : nonempty_list(ls) -> T { car(ls) }\n \n fn main() {\n     let mylist = cons(@1u, @nil);"}, {"sha": "e1656c8dda93718c8cf5a898f7abd9d7877e94b7", "filename": "src/test/run-pass/use-uninit-alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fuse-uninit-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fuse-uninit-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-uninit-alt.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn foo<T>(o: &myoption<T>) -> int {\n+fn foo<T>(o: myoption<T>) -> int {\n     let x: int = 5;\n     alt o { none::<T>. { } some::<T>(t) { x += 1; } }\n     ret x;"}, {"sha": "f702694d75a90f77b1821533e67c357067b30a30", "filename": "src/test/run-pass/use-uninit-alt2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fuse-uninit-alt2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fuse-uninit-alt2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuse-uninit-alt2.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,6 +1,6 @@\n \n \n-fn foo<T>(o: &myoption<T>) -> int {\n+fn foo<T>(o: myoption<T>) -> int {\n     let x: int;\n     alt o { none::<T>. { fail; } some::<T>(t) { x = 5; } }\n     ret x;"}, {"sha": "725dec057a98d59cca5291cfaad28f972987633a", "filename": "src/test/run-pass/vec-push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fvec-push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Frun-pass%2Fvec-push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-push.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,5 +1,5 @@\n \n \n-fn push<T>(v: &mutable [mutable? T], t: &T) { v += [t]; }\n+fn push<T>(v: &mutable [mutable? T], t: T) { v += [t]; }\n \n fn main() { let v = [1, 2, 3]; push(v, 1); }"}, {"sha": "104d68f03bba0110419998c45b150b22f1677b6c", "filename": "src/test/stdtest/deque.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -79,9 +79,9 @@ fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n     assert (deq.get(3) == d);\n }\n \n-type eqfn<T> = fn(&T, &T) -> bool;\n+type eqfn<T> = fn(T, T) -> bool;\n \n-fn test_parameterized<@T>(e: eqfn<T>, a: &T, b: &T, c: &T, d: &T) {\n+fn test_parameterized<@T>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n     let deq: deque::t<T> = deque::create::<T>();\n     assert (deq.size() == 0u);\n     deq.add_front(a);\n@@ -119,9 +119,9 @@ type reccy = {x: int, y: int, t: taggy};\n \n #[test]\n fn test() {\n-    fn inteq(a: &int, b: &int) -> bool { ret a == b; }\n-    fn intboxeq(a: &@int, b: &@int) -> bool { ret a == b; }\n-    fn taggyeq(a: &taggy, b: &taggy) -> bool {\n+    fn inteq(a: int, b: int) -> bool { ret a == b; }\n+    fn intboxeq(a: @int, b: @int) -> bool { ret a == b; }\n+    fn taggyeq(a: taggy, b: taggy) -> bool {\n         alt a {\n           one(a1) { alt b { one(b1) { ret a1 == b1; } _ { ret false; } } }\n           two(a1, a2) {\n@@ -138,7 +138,7 @@ fn test() {\n           }\n         }\n     }\n-    fn taggypareq<@T>(a: &taggypar<T>, b: &taggypar<T>) -> bool {\n+    fn taggypareq<@T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n         alt a {\n           onepar::<T>(a1) {\n             alt b { onepar::<T>(b1) { ret a1 == b1; } _ { ret false; } }\n@@ -159,7 +159,7 @@ fn test() {\n           }\n         }\n     }\n-    fn reccyeq(a: &reccy, b: &reccy) -> bool {\n+    fn reccyeq(a: reccy, b: reccy) -> bool {\n         ret a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n     }\n     log \"*** test boxes\";"}, {"sha": "966a04f70f42cb2d34771a83175d08ccb1d5a651", "filename": "src/test/stdtest/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Feither.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,16 +5,16 @@ import std::vec::len;\n #[test]\n fn test_either_left() {\n     let val = left(10);\n-    fn f_left(x: &int) -> bool { x == 10 }\n-    fn f_right(_x: &uint) -> bool { false }\n+    fn f_left(x: int) -> bool { x == 10 }\n+    fn f_right(_x: uint) -> bool { false }\n     assert (either(f_left, f_right, val));\n }\n \n #[test]\n fn test_either_right() {\n     let val = right(10u);\n-    fn f_left(_x: &int) -> bool { false }\n-    fn f_right(x: &uint) -> bool { x == 10u }\n+    fn f_left(_x: int) -> bool { false }\n+    fn f_right(x: uint) -> bool { x == 10u }\n     assert (either(f_left, f_right, val));\n }\n "}, {"sha": "7906d277a10d370740ca7acbfd785ffacaf8aa70", "filename": "src/test/stdtest/list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Flist.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -17,15 +17,15 @@ fn test_from_vec() {\n #[test]\n fn test_foldl() {\n     let l = from_vec([0, 1, 2, 3, 4]);\n-    fn add(a: &int, b: &uint) -> uint { ret (a as uint) + b; }\n+    fn add(a: int, b: uint) -> uint { ret (a as uint) + b; }\n     let rs = list::foldl(l, 0u, add);\n     assert (rs == 10u);\n }\n \n #[test]\n fn test_find_success() {\n     let l = from_vec([0, 1, 2]);\n-    fn match(i: &int) -> option::t<int> {\n+    fn match(i: int) -> option::t<int> {\n         ret if i == 2 { option::some(i) } else { option::none::<int> };\n     }\n     let rs = list::find(l, match);\n@@ -35,7 +35,7 @@ fn test_find_success() {\n #[test]\n fn test_find_fail() {\n     let l = from_vec([0, 1, 2]);\n-    fn match(_i: &int) -> option::t<int> { ret option::none::<int>; }\n+    fn match(_i: int) -> option::t<int> { ret option::none::<int>; }\n     let rs = list::find(l, match);\n     assert (rs == option::none::<int>);\n }"}, {"sha": "ff978085a27b7d2e9c3f816d4f2c547f89318b43", "filename": "src/test/stdtest/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -11,7 +11,7 @@ import std::option;\n #[test]\n fn test_simple() {\n     log \"*** starting test_simple\";\n-    fn eq_uint(x: &uint, y: &uint) -> bool { ret x == y; }\n+    fn eq_uint(x: uint, y: uint) -> bool { ret x == y; }\n     let hasher_uint: map::hashfn<uint> = util::id;\n     let eqer_uint: map::eqfn<uint> = eq_uint;\n     let hasher_str: map::hashfn<str> = str::hash;\n@@ -83,7 +83,7 @@ fn test_simple() {\n fn test_growth() {\n     log \"*** starting test_growth\";\n     let num_to_insert: uint = 64u;\n-    fn eq_uint(x: &uint, y: &uint) -> bool { ret x == y; }\n+    fn eq_uint(x: uint, y: uint) -> bool { ret x == y; }\n     log \"uint -> uint\";\n     let hasher_uint: map::hashfn<uint> = util::id;\n     let eqer_uint: map::eqfn<uint> = eq_uint;\n@@ -157,8 +157,8 @@ fn test_growth() {\n fn test_removal() {\n     log \"*** starting test_removal\";\n     let num_to_insert: uint = 64u;\n-    fn eq(x: &uint, y: &uint) -> bool { ret x == y; }\n-    fn hash(u: &uint) -> uint {\n+    fn eq(x: uint, y: uint) -> bool { ret x == y; }\n+    fn hash(u: uint) -> uint {\n         // This hash function intentionally causes collisions between\n         // consecutive integer pairs.\n "}, {"sha": "ad2a82ef4263888721ae6a10445223dbd7a476df", "filename": "src/test/stdtest/qsort.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -5,9 +5,9 @@ import std::sort;\n import std::vec;\n import std::int;\n \n-fn check_sort(v1: &[mutable int], v2: &[mutable int]) {\n+fn check_sort(v1: [mutable int], v2: [mutable int]) {\n     let len = std::vec::len::<int>(v1);\n-    fn ltequal(a: &int, b: &int) -> bool { ret a <= b; }\n+    fn ltequal(a: int, b: int) -> bool { ret a <= b; }\n     let f = ltequal;\n     std::sort::quick_sort::<int>(f, v1);\n     let i = 0u;\n@@ -46,7 +46,7 @@ fn test_simple() {\n \n     let expected = [1, 2, 3];\n \n-    fn lteq(a: &int, b: &int) -> bool { int::le(a, b) }\n+    fn lteq(a: int, b: int) -> bool { int::le(a, b) }\n     sort::quick_sort(lteq, names);\n \n     let immut_names = vec::from_mut(names);"}, {"sha": "6688a175e8d0b989a6e402f33b8defb7e665d269", "filename": "src/test/stdtest/qsort3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fqsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fqsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort3.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,10 +1,10 @@\n \n use std;\n \n-fn check_sort(v1: &[mutable int], v2: &[mutable int]) {\n+fn check_sort(v1: [mutable int], v2: [mutable int]) {\n     let len = std::vec::len::<int>(v1);\n-    fn lt(a: &int, b: &int) -> bool { ret a < b; }\n-    fn equal(a: &int, b: &int) -> bool { ret a == b; }\n+    fn lt(a: int, b: int) -> bool { ret a < b; }\n+    fn equal(a: int, b: int) -> bool { ret a == b; }\n     let f1 = lt;\n     let f2 = equal;\n     std::sort::quick_sort3::<int>(f1, f2, v1);"}, {"sha": "218889c766b06f4dad7e6c4a3b8528bc38fe3756", "filename": "src/test/stdtest/run.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -45,7 +45,7 @@ fn test_pipes() {\n     log actual;\n     assert (expected == actual);\n \n-    fn writeclose(fd: int, s: &str) {\n+    fn writeclose(fd: int, s: str) {\n         let writer = io::new_writer(io::fd_buf_writer(fd, option::none));\n         writer.write_str(s);\n "}, {"sha": "9b47b7f1f098d9a2843d913feb991300289d8e3f", "filename": "src/test/stdtest/sha1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -50,7 +50,7 @@ fn test() {\n                0xfau8, 0xd3u8, 0xe8u8, 0x5au8, 0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n                0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n     let tests = fips_180_1_tests + wikipedia_tests;\n-    fn check_vec_eq(v0: &[u8], v1: &[u8]) {\n+    fn check_vec_eq(v0: [u8], v1: [u8]) {\n         assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n         let len = vec::len::<u8>(v0);\n         let i = 0u;"}, {"sha": "e27124dd015a6db41d34a6eb43fe9c06f305f3b8", "filename": "src/test/stdtest/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -1,9 +1,9 @@\n \n use std;\n \n-fn check_sort(v1: &[int], v2: &[int]) {\n+fn check_sort(v1: [int], v2: [int]) {\n     let len = std::vec::len::<int>(v1);\n-    fn lteq(a: &int, b: &int) -> bool { ret a <= b; }\n+    fn lteq(a: int, b: int) -> bool { ret a <= b; }\n     let f = lteq;\n     let v3 = std::sort::merge_sort::<int>(f, v1);\n     let i = 0u;"}, {"sha": "5e79bb6fc206ac9a8ddc80648e36de44aa076cd1", "filename": "src/test/stdtest/str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstr.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -39,7 +39,7 @@ fn test_index_and_rindex() {\n \n #[test]\n fn test_split() {\n-    fn t(s: &str, c: char, i: int, k: &str) {\n+    fn t(s: str, c: char, i: int, k: str) {\n         log \"splitting: \" + s;\n         log i;\n         let v = str::split(s, c as u8);\n@@ -59,7 +59,7 @@ fn test_split() {\n \n #[test]\n fn test_find() {\n-    fn t(haystack: &str, needle: &str, i: int) {\n+    fn t(haystack: str, needle: str, i: int) {\n         let j: int = str::find(haystack, needle);\n         log \"searched for \" + needle;\n         log j;\n@@ -74,7 +74,7 @@ fn test_find() {\n \n #[test]\n fn test_substr() {\n-    fn t(a: &str, b: &str, start: int) {\n+    fn t(a: str, b: str, start: int) {\n         assert (str::eq(str::substr(a, start as uint, str::byte_len(b)), b));\n     }\n     t(\"hello\", \"llo\", 2);\n@@ -84,7 +84,7 @@ fn test_substr() {\n \n #[test]\n fn test_concat() {\n-    fn t(v: &[str], s: &str) { assert (str::eq(str::concat(v), s)); }\n+    fn t(v: [str], s: str) { assert (str::eq(str::concat(v), s)); }\n     t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \"youknowI'mnogood\");\n     let v: [str] = [];\n     t(v, \"\");\n@@ -93,7 +93,7 @@ fn test_concat() {\n \n #[test]\n fn test_connect() {\n-    fn t(v: &[str], sep: &str, s: &str) {\n+    fn t(v: [str], sep: str, s: str) {\n         assert (str::eq(str::connect(v, sep), s));\n     }\n     t([\"you\", \"know\", \"I'm\", \"no\", \"good\"], \" \", \"you know I'm no good\");"}, {"sha": "3d7bd4fd74733807065c174b3def26a5390b6b34", "filename": "src/test/stdtest/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -40,7 +40,7 @@ fn traverse_in_order() {\n     insert(m, 1, ());\n \n     let n = 0;\n-    fn t(n: &mutable int, k: &int, v: &()) { assert (n == k); n += 1; }\n+    fn t(n: &mutable int, k: int, v: ()) { assert (n == k); n += 1; }\n     traverse(m, bind t(n, _, _));\n }\n "}, {"sha": "a9cda6c73d6e932f2ebf0c52288a477e0b612ef1", "filename": "src/test/stdtest/vec.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=fc6b7c8b381bcb506eab0f50c69b6cc18aafacb2", "patch": "@@ -8,15 +8,15 @@ import std::option::some;\n \n fn square(n: uint) -> uint { ret n * n; }\n \n-fn square_alias(n: &uint) -> uint { ret n * n; }\n+fn square_alias(n: uint) -> uint { ret n * n; }\n \n-pure fn is_three(n: &uint) -> bool { ret n == 3u; }\n+pure fn is_three(n: uint) -> bool { ret n == 3u; }\n \n-fn square_if_odd(n: &uint) -> option::t<uint> {\n+fn square_if_odd(n: uint) -> option::t<uint> {\n     ret if n % 2u == 1u { some(n * n) } else { none };\n }\n \n-fn add(x: &uint, y: &uint) -> uint { ret x + y; }\n+fn add(x: uint, y: uint) -> uint { ret x + y; }\n \n #[test]\n fn test_unsafe_ptrs() {\n@@ -228,7 +228,7 @@ fn test_map() {\n \n #[test]\n fn test_map2() {\n-    fn times(x: &int, y: &int) -> int { ret x * y; }\n+    fn times(x: int, y: int) -> int { ret x * y; }\n     let f = times;\n     let v0 = [1, 2, 3, 4, 5];\n     let v1 = [5, 4, 3, 2, 1];\n@@ -254,12 +254,12 @@ fn test_filter_map() {\n     assert (w[1] == 9u);\n     assert (w[2] == 25u);\n \n-    fn halve(i: &int) -> option::t<int> {\n+    fn halve(i: int) -> option::t<int> {\n         if i % 2 == 0 {\n             ret option::some::<int>(i / 2);\n         } else { ret option::none::<int>; }\n     }\n-    fn halve_for_sure(i: &int) -> int { ret i / 2; }\n+    fn halve_for_sure(i: int) -> int { ret i / 2; }\n     let all_even: [int] = [0, 2, 8, 6];\n     let all_odd1: [int] = [1, 7, 3];\n     let all_odd2: [int] = [];\n@@ -328,8 +328,8 @@ fn test_position() {\n \n #[test]\n fn test_position_pred() {\n-    fn less_than_three(i: &int) -> bool { ret i < 3; }\n-    fn is_eighteen(i: &int) -> bool { ret i == 18; }\n+    fn less_than_three(i: int) -> bool { ret i < 3; }\n+    fn is_eighteen(i: int) -> bool { ret i == 18; }\n     let v1: [int] = [5, 4, 3, 2, 1];\n     assert (position_pred(less_than_three, v1) == option::some::<uint>(3u));\n     assert (position_pred(is_eighteen, v1) == option::none::<uint>);"}]}