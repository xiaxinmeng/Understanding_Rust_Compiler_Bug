{"sha": "237885cc53fa9dc6e1fe140b767ef3b2f4093c62", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNzg4NWNjNTNmYTlkYzZlMWZlMTQwYjc2N2VmM2IyZjQwOTNjNjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-31T18:01:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-31T18:01:48Z"}, "message": "auto merge of #11917 : thestinger/rust/intrinsic, r=alexcrichton", "tree": {"sha": "9458a2a47e5621f6320900ed966051b3a97bf247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9458a2a47e5621f6320900ed966051b3a97bf247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/237885cc53fa9dc6e1fe140b767ef3b2f4093c62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/237885cc53fa9dc6e1fe140b767ef3b2f4093c62", "html_url": "https://github.com/rust-lang/rust/commit/237885cc53fa9dc6e1fe140b767ef3b2f4093c62", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/237885cc53fa9dc6e1fe140b767ef3b2f4093c62/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bec01ad17c6a519c38063d99b8863bf1f801f226", "url": "https://api.github.com/repos/rust-lang/rust/commits/bec01ad17c6a519c38063d99b8863bf1f801f226", "html_url": "https://github.com/rust-lang/rust/commit/bec01ad17c6a519c38063d99b8863bf1f801f226"}, {"sha": "e532e8d55d4f8a327b7163606c537fe3e358b03a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e532e8d55d4f8a327b7163606c537fe3e358b03a", "html_url": "https://github.com/rust-lang/rust/commit/e532e8d55d4f8a327b7163606c537fe3e358b03a"}], "stats": {"total": 273, "additions": 137, "deletions": 136}, "files": [{"sha": "b662d08062fdf36b5a95d979084c06ef64331fc6", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 54, "deletions": 58, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/237885cc53fa9dc6e1fe140b767ef3b2f4093c62/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237885cc53fa9dc6e1fe140b767ef3b2f4093c62/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=237885cc53fa9dc6e1fe140b767ef3b2f4093c62", "patch": "@@ -29,27 +29,68 @@ use util::ppaux::ty_to_str;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n \n+pub fn get_simple_intrinsic(ccx: @CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n+    let nm = ccx.sess.str_of(item.ident);\n+    let name = nm.as_slice();\n+\n+    match name {\n+        \"sqrtf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sqrt.f32\"))),\n+        \"sqrtf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sqrt.f64\"))),\n+        \"powif32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.powi.f32\"))),\n+        \"powif64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.powi.f64\"))),\n+        \"sinf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sin.f32\"))),\n+        \"sinf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.sin.f64\"))),\n+        \"cosf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.cos.f32\"))),\n+        \"cosf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.cos.f64\"))),\n+        \"powf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.pow.f32\"))),\n+        \"powf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.pow.f64\"))),\n+        \"expf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp.f32\"))),\n+        \"expf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp.f64\"))),\n+        \"exp2f32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp2.f32\"))),\n+        \"exp2f64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.exp2.f64\"))),\n+        \"logf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log.f32\"))),\n+        \"logf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log.f64\"))),\n+        \"log10f32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log10.f32\"))),\n+        \"log10f64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log10.f64\"))),\n+        \"log2f32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log2.f32\"))),\n+        \"log2f64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.log2.f64\"))),\n+        \"fmaf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fma.f32\"))),\n+        \"fmaf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fma.f64\"))),\n+        \"fabsf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fabs.f32\"))),\n+        \"fabsf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.fabs.f64\"))),\n+        \"copysignf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.copysign.f32\"))),\n+        \"copysignf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.copysign.f64\"))),\n+        \"floorf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.floor.f32\"))),\n+        \"floorf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.floor.f64\"))),\n+        \"ceilf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ceil.f32\"))),\n+        \"ceilf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ceil.f64\"))),\n+        \"truncf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.trunc.f32\"))),\n+        \"truncf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.trunc.f64\"))),\n+        \"rintf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.rint.f32\"))),\n+        \"rintf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.rint.f64\"))),\n+        \"nearbyintf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.nearbyint.f32\"))),\n+        \"nearbyintf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.nearbyint.f64\"))),\n+        \"roundf32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.round.f32\"))),\n+        \"roundf64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.round.f64\"))),\n+        \"ctpop8\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i8\"))),\n+        \"ctpop16\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i16\"))),\n+        \"ctpop32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i32\"))),\n+        \"ctpop64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.ctpop.i64\"))),\n+        \"bswap16\" => Some(ccx.intrinsics.get_copy(&(\"llvm.bswap.i16\"))),\n+        \"bswap32\" => Some(ccx.intrinsics.get_copy(&(\"llvm.bswap.i32\"))),\n+        \"bswap64\" => Some(ccx.intrinsics.get_copy(&(\"llvm.bswap.i64\"))),\n+        _ => None\n+    }\n+}\n+\n pub fn trans_intrinsic(ccx: @CrateContext,\n                        decl: ValueRef,\n                        item: &ast::ForeignItem,\n                        path: ast_map::Path,\n                        substs: @param_substs,\n-                       _attributes: &[ast::Attribute],\n                        ref_id: Option<ast::NodeId>) {\n     debug!(\"trans_intrinsic(item.ident={})\", ccx.sess.str_of(item.ident));\n \n-    fn simple_llvm_intrinsic(bcx: &Block, name: &'static str, num_args: uint) {\n-        assert!(num_args <= 4);\n-        let mut args = [0 as ValueRef, ..4];\n-        let first_real_arg = bcx.fcx.arg_pos(0u);\n-        for i in range(0u, num_args) {\n-            args[i] = get_param(bcx.fcx.llfn, first_real_arg + i);\n-        }\n-        let llfn = bcx.ccx().intrinsics.get_copy(&name);\n-        let llcall = Call(bcx, llfn, args.slice(0, num_args), []);\n-        Ret(bcx, llcall);\n-    }\n-\n     fn with_overflow_instrinsic(bcx: &Block, name: &'static str, t: ty::t) {\n         let first_real_arg = bcx.fcx.arg_pos(0u);\n         let a = get_param(bcx.fcx.llfn, first_real_arg);\n@@ -431,48 +472,6 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         \"copy_nonoverlapping_memory\" => copy_intrinsic(bcx, false, substs.tys[0]),\n         \"copy_memory\" => copy_intrinsic(bcx, true, substs.tys[0]),\n         \"set_memory\" => memset_intrinsic(bcx, substs.tys[0]),\n-        \"sqrtf32\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f32\", 1),\n-        \"sqrtf64\" => simple_llvm_intrinsic(bcx, \"llvm.sqrt.f64\", 1),\n-        \"powif32\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f32\", 2),\n-        \"powif64\" => simple_llvm_intrinsic(bcx, \"llvm.powi.f64\", 2),\n-        \"sinf32\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f32\", 1),\n-        \"sinf64\" => simple_llvm_intrinsic(bcx, \"llvm.sin.f64\", 1),\n-        \"cosf32\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f32\", 1),\n-        \"cosf64\" => simple_llvm_intrinsic(bcx, \"llvm.cos.f64\", 1),\n-        \"powf32\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f32\", 2),\n-        \"powf64\" => simple_llvm_intrinsic(bcx, \"llvm.pow.f64\", 2),\n-        \"expf32\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f32\", 1),\n-        \"expf64\" => simple_llvm_intrinsic(bcx, \"llvm.exp.f64\", 1),\n-        \"exp2f32\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f32\", 1),\n-        \"exp2f64\" => simple_llvm_intrinsic(bcx, \"llvm.exp2.f64\", 1),\n-        \"logf32\" => simple_llvm_intrinsic(bcx, \"llvm.log.f32\", 1),\n-        \"logf64\" => simple_llvm_intrinsic(bcx, \"llvm.log.f64\", 1),\n-        \"log10f32\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f32\", 1),\n-        \"log10f64\" => simple_llvm_intrinsic(bcx, \"llvm.log10.f64\", 1),\n-        \"log2f32\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f32\", 1),\n-        \"log2f64\" => simple_llvm_intrinsic(bcx, \"llvm.log2.f64\", 1),\n-        \"fmaf32\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f32\", 3),\n-        \"fmaf64\" => simple_llvm_intrinsic(bcx, \"llvm.fma.f64\", 3),\n-        \"fabsf32\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f32\", 1),\n-        \"fabsf64\" => simple_llvm_intrinsic(bcx, \"llvm.fabs.f64\", 1),\n-        \"copysignf32\" => simple_llvm_intrinsic(bcx, \"llvm.copysign.f32\", 2),\n-        \"copysignf64\" => simple_llvm_intrinsic(bcx, \"llvm.copysign.f64\", 2),\n-        \"floorf32\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f32\", 1),\n-        \"floorf64\" => simple_llvm_intrinsic(bcx, \"llvm.floor.f64\", 1),\n-        \"ceilf32\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f32\", 1),\n-        \"ceilf64\" => simple_llvm_intrinsic(bcx, \"llvm.ceil.f64\", 1),\n-        \"truncf32\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f32\", 1),\n-        \"truncf64\" => simple_llvm_intrinsic(bcx, \"llvm.trunc.f64\", 1),\n-        \"rintf32\" => simple_llvm_intrinsic(bcx, \"llvm.rint.f32\", 1),\n-        \"rintf64\" => simple_llvm_intrinsic(bcx, \"llvm.rint.f64\", 1),\n-        \"nearbyintf32\" => simple_llvm_intrinsic(bcx, \"llvm.nearbyint.f32\", 1),\n-        \"nearbyintf64\" => simple_llvm_intrinsic(bcx, \"llvm.nearbyint.f64\", 1),\n-        \"roundf32\" => simple_llvm_intrinsic(bcx, \"llvm.round.f32\", 1),\n-        \"roundf64\" => simple_llvm_intrinsic(bcx, \"llvm.round.f64\", 1),\n-        \"ctpop8\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i8\", 1),\n-        \"ctpop16\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i16\", 1),\n-        \"ctpop32\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i32\", 1),\n-        \"ctpop64\" => simple_llvm_intrinsic(bcx, \"llvm.ctpop.i64\", 1),\n         \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n         \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n         \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),\n@@ -481,9 +480,6 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         \"cttz16\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\"),\n         \"cttz32\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\"),\n         \"cttz64\" => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\"),\n-        \"bswap16\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i16\", 1),\n-        \"bswap32\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i32\", 1),\n-        \"bswap64\" => simple_llvm_intrinsic(bcx, \"llvm.bswap.i64\", 1),\n \n         \"volatile_load\" => volatile_load_intrinsic(bcx),\n         \"volatile_store\" => volatile_store_intrinsic(bcx),"}, {"sha": "25c536f2a6db2836f6bd684704951851e88289ff", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 83, "deletions": 78, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/237885cc53fa9dc6e1fe140b767ef3b2f4093c62/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/237885cc53fa9dc6e1fe140b767ef3b2f4093c62/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=237885cc53fa9dc6e1fe140b767ef3b2f4093c62", "patch": "@@ -223,90 +223,95 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     };\n \n     let lldecl = match map_node {\n-      ast_map::NodeItem(i, _) => {\n-          match *i {\n-            ast::Item {\n-                node: ast::ItemFn(decl, _, _, _, body),\n-                ..\n-            } => {\n-                let d = mk_lldecl();\n-                set_llvm_fn_attrs(i.attrs, d);\n-                trans_fn(ccx, pt, decl, body, d, Some(psubsts), fn_id.node, []);\n-                d\n-            }\n-            _ => {\n-              ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n-            }\n-          }\n-      }\n-      ast_map::NodeForeignItem(i, _, _, _) => {\n-          let d = mk_lldecl();\n-          intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n-                                     ref_id);\n-          d\n-      }\n-      ast_map::NodeVariant(v, enum_item, _) => {\n-        let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n-        let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n-        let d = mk_lldecl();\n-        set_inline_hint(d);\n-        match v.node.kind {\n-            ast::TupleVariantKind(ref args) => {\n-                trans_enum_variant(ccx,\n-                                   enum_item.id,\n-                                   v,\n-                                   (*args).clone(),\n-                                   this_tv.disr_val,\n-                                   Some(psubsts),\n-                                   d);\n-            }\n-            ast::StructVariantKind(_) =>\n-                ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n-        }\n-        d\n-      }\n-      ast_map::NodeMethod(mth, _, _) => {\n-        let d = mk_lldecl();\n-        set_llvm_fn_attrs(mth.attrs, d);\n-        trans_fn(ccx, pt, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n-        d\n-      }\n-      ast_map::NodeTraitMethod(method, _, pt) => {\n-          match *method {\n-              ast::Provided(mth) => {\n+        ast_map::NodeItem(i, _) => {\n+            match *i {\n+              ast::Item {\n+                  node: ast::ItemFn(decl, _, _, _, body),\n+                  ..\n+              } => {\n                   let d = mk_lldecl();\n-                  set_llvm_fn_attrs(mth.attrs, d);\n-                  trans_fn(ccx, (*pt).clone(), mth.decl, mth.body,\n-                           d, Some(psubsts), mth.id, []);\n+                  set_llvm_fn_attrs(i.attrs, d);\n+                  trans_fn(ccx, pt, decl, body, d, Some(psubsts), fn_id.node, []);\n                   d\n               }\n               _ => {\n-                ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\",\n-                                         map_node))\n+                ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n               }\n-          }\n-      }\n-      ast_map::NodeStructCtor(struct_def, _, _) => {\n-        let d = mk_lldecl();\n-        set_inline_hint(d);\n-        base::trans_tuple_struct(ccx,\n-                                 struct_def.fields,\n-                                 struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n-                                                            didn't have a ctor id\"),\n-                                 Some(psubsts),\n-                                 d);\n-        d\n-      }\n+            }\n+        }\n+        ast_map::NodeForeignItem(i, _, _, _) => {\n+            let simple = intrinsic::get_simple_intrinsic(ccx, i);\n+            match simple {\n+                Some(decl) => decl,\n+                None => {\n+                    let d = mk_lldecl();\n+                    intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, ref_id);\n+                    d\n+                }\n+            }\n+        }\n+        ast_map::NodeVariant(v, enum_item, _) => {\n+            let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n+            let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n+            let d = mk_lldecl();\n+            set_inline_hint(d);\n+            match v.node.kind {\n+                ast::TupleVariantKind(ref args) => {\n+                    trans_enum_variant(ccx,\n+                                       enum_item.id,\n+                                       v,\n+                                       (*args).clone(),\n+                                       this_tv.disr_val,\n+                                       Some(psubsts),\n+                                       d);\n+                }\n+                ast::StructVariantKind(_) =>\n+                    ccx.tcx.sess.bug(\"can't monomorphize struct variants\"),\n+            }\n+            d\n+        }\n+        ast_map::NodeMethod(mth, _, _) => {\n+            let d = mk_lldecl();\n+            set_llvm_fn_attrs(mth.attrs, d);\n+            trans_fn(ccx, pt, mth.decl, mth.body, d, Some(psubsts), mth.id, []);\n+            d\n+        }\n+        ast_map::NodeTraitMethod(method, _, pt) => {\n+            match *method {\n+                ast::Provided(mth) => {\n+                    let d = mk_lldecl();\n+                    set_llvm_fn_attrs(mth.attrs, d);\n+                    trans_fn(ccx, (*pt).clone(), mth.decl, mth.body,\n+                             d, Some(psubsts), mth.id, []);\n+                    d\n+                }\n+                _ => {\n+                    ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\",\n+                                             map_node))\n+                }\n+            }\n+        }\n+        ast_map::NodeStructCtor(struct_def, _, _) => {\n+            let d = mk_lldecl();\n+            set_inline_hint(d);\n+            base::trans_tuple_struct(ccx,\n+                                     struct_def.fields,\n+                                     struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n+                                                                didn't have a ctor id\"),\n+                                     Some(psubsts),\n+                                     d);\n+            d\n+        }\n \n-      // Ugh -- but this ensures any new variants won't be forgotten\n-      ast_map::NodeExpr(..) |\n-      ast_map::NodeStmt(..) |\n-      ast_map::NodeArg(..) |\n-      ast_map::NodeBlock(..) |\n-      ast_map::NodeCalleeScope(..) |\n-      ast_map::NodeLocal(..) => {\n-        ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n-      }\n+        // Ugh -- but this ensures any new variants won't be forgotten\n+        ast_map::NodeExpr(..) |\n+        ast_map::NodeStmt(..) |\n+        ast_map::NodeArg(..) |\n+        ast_map::NodeBlock(..) |\n+        ast_map::NodeCalleeScope(..) |\n+        ast_map::NodeLocal(..) => {\n+            ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n+        }\n     };\n \n     {"}]}