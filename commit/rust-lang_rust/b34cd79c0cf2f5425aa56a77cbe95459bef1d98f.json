{"sha": "b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "node_id": "C_kwDOAAsO6NoAKGIzNGNkNzljMGNmMmY1NDI1YWE1NmE3N2NiZTk1NDU5YmVmMWQ5OGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-16T22:01:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-16T22:01:49Z"}, "message": "Auto merge of #8188 - jamesmcm:recursive_display_impl, r=camsteffen\n\nnew lint: `recursive_format_impl`\n\nThe to_string_in_display lint is renamed to recursive_format_impl\nA check is added for the use of self formatted with Display or Debug inside any format string in the same impl\nThe to_string_in_display check is kept as is - like in the format_in_format_args lint\n\nThis is my first contribution so please check it for better / more idiomatic checks + error messages. Note the format macro paths are shared with the `format_in_format_args` lint - maybe those could be moved to clippy utils too.\n\nThis relates to issues #2691 and #7830\n\n------\n\nchangelog: Renamed `to_string_in_display` lint to [`recursive_format_impl`] with new check for any use of self as Display or Debug inside the same format trait impl.", "tree": {"sha": "764a0bb732ad879f301360a9680bbe3ab8068126", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/764a0bb732ad879f301360a9680bbe3ab8068126"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "html_url": "https://github.com/rust-lang/rust/commit/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4931cab709401cc8350598eab9bd51031c89565a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4931cab709401cc8350598eab9bd51031c89565a", "html_url": "https://github.com/rust-lang/rust/commit/4931cab709401cc8350598eab9bd51031c89565a"}, {"sha": "b162b11abc4c5275b2bf2f2f4679f0b6d72be2cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b162b11abc4c5275b2bf2f2f4679f0b6d72be2cb", "html_url": "https://github.com/rust-lang/rust/commit/b162b11abc4c5275b2bf2f2f4679f0b6d72be2cb"}], "stats": {"total": 961, "additions": 685, "deletions": 276}, "files": [{"sha": "c3da1d1f69a3f4ce3b463abd3a8a96f7a50675a3", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -1438,7 +1438,7 @@ Released 2020-11-19\n * [`manual_strip`] [#6038](https://github.com/rust-lang/rust-clippy/pull/6038)\n * [`map_err_ignore`] [#5998](https://github.com/rust-lang/rust-clippy/pull/5998)\n * [`rc_buffer`] [#6044](https://github.com/rust-lang/rust-clippy/pull/6044)\n-* [`to_string_in_display`] [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n+* `to_string_in_display` [#5831](https://github.com/rust-lang/rust-clippy/pull/5831)\n * `single_char_push_str` [#5881](https://github.com/rust-lang/rust-clippy/pull/5881)\n \n ### Moves and Deprecations\n@@ -1481,7 +1481,7 @@ Released 2020-11-19\n   [#5949](https://github.com/rust-lang/rust-clippy/pull/5949)\n * [`doc_markdown`]: allow using \"GraphQL\" without backticks\n   [#5996](https://github.com/rust-lang/rust-clippy/pull/5996)\n-* [`to_string_in_display`]: avoid linting when calling `to_string()` on anything that is not `self`\n+* `to_string_in_display`: avoid linting when calling `to_string()` on anything that is not `self`\n   [#5971](https://github.com/rust-lang/rust-clippy/pull/5971)\n * [`indexing_slicing`] and [`out_of_bounds_indexing`] treat references to arrays as arrays\n   [#6034](https://github.com/rust-lang/rust-clippy/pull/6034)\n@@ -3385,6 +3385,7 @@ Released 2018-09-13\n [`range_zip_with_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_zip_with_len\n [`rc_buffer`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_buffer\n [`rc_mutex`]: https://rust-lang.github.io/rust-clippy/master/index.html#rc_mutex\n+[`recursive_format_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#recursive_format_impl\n [`redundant_allocation`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_allocation\n [`redundant_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_clone\n [`redundant_closure`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_closure\n@@ -3459,7 +3460,6 @@ Released 2018-09-13\n [`tabs_in_doc_comments`]: https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments\n [`temporary_assignment`]: https://rust-lang.github.io/rust-clippy/master/index.html#temporary_assignment\n [`to_digit_is_some`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_digit_is_some\n-[`to_string_in_display`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_display\n [`to_string_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#to_string_in_format_args\n [`todo`]: https://rust-lang.github.io/rust-clippy/master/index.html#todo\n [`too_many_arguments`]: https://rust-lang.github.io/rust-clippy/master/index.html#too_many_arguments"}, {"sha": "ac3708636decf5dbfa312a5d669fe54f2d79279d", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::macros::{FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::is_diag_trait_item;\n+use clippy_utils::macros::{is_format_macro, FormatArgsArg, FormatArgsExpn};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{is_diag_trait_item, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n@@ -65,34 +65,14 @@ declare_clippy_lint! {\n \n declare_lint_pass!(FormatArgs => [FORMAT_IN_FORMAT_ARGS, TO_STRING_IN_FORMAT_ARGS]);\n \n-const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n-    &paths::FORMAT_ARGS_MACRO,\n-    &paths::ASSERT_EQ_MACRO,\n-    &paths::ASSERT_MACRO,\n-    &paths::ASSERT_NE_MACRO,\n-    &paths::EPRINT_MACRO,\n-    &paths::EPRINTLN_MACRO,\n-    &paths::PRINT_MACRO,\n-    &paths::PRINTLN_MACRO,\n-    &paths::WRITE_MACRO,\n-    &paths::WRITELN_MACRO,\n-];\n-\n-const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n-\n impl<'tcx> LateLintPass<'tcx> for FormatArgs {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         if_chain! {\n             if let Some(format_args) = FormatArgsExpn::parse(cx, expr);\n             let expr_expn_data = expr.span.ctxt().outer_expn_data();\n             let outermost_expn_data = outermost_expn_data(expr_expn_data);\n             if let Some(macro_def_id) = outermost_expn_data.macro_def_id;\n-            if FORMAT_MACRO_PATHS\n-                .iter()\n-                .any(|path| match_def_path(cx, macro_def_id, path))\n-                || FORMAT_MACRO_DIAG_ITEMS\n-                    .iter()\n-                    .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id));\n+            if is_format_macro(cx, macro_def_id);\n             if let ExpnKind::Macro(_, name) = outermost_expn_data.kind;\n             if let Some(args) = format_args.args();\n             then {"}, {"sha": "de0ff5369079b426ce83d5b5d5b2280e5c8854b8", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -241,6 +241,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(ranges::MANUAL_RANGE_CONTAINS),\n     LintId::of(ranges::RANGE_ZIP_WITH_LEN),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n+    LintId::of(recursive_format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(redundant_closure_call::REDUNDANT_CLOSURE_CALL),\n     LintId::of(redundant_field_names::REDUNDANT_FIELD_NAMES),\n@@ -267,7 +268,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n     LintId::of(temporary_assignment::TEMPORARY_ASSIGNMENT),\n     LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n     LintId::of(transmute::CROSSPOINTER_TRANSMUTE),\n     LintId::of(transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n     LintId::of(transmute::TRANSMUTE_BYTES_TO_STR),"}, {"sha": "18fe44282ed0e70020a8f456db67d1da00a558d6", "filename": "clippy_lints/src/lib.register_correctness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.register_correctness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_correctness.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -52,12 +52,12 @@ store.register_group(true, \"clippy::correctness\", Some(\"clippy_correctness\"), ve\n     LintId::of(ptr::INVALID_NULL_PTR_USAGE),\n     LintId::of(ptr::MUT_FROM_REF),\n     LintId::of(ranges::REVERSED_EMPTY_RANGES),\n+    LintId::of(recursive_format_impl::RECURSIVE_FORMAT_IMPL),\n     LintId::of(regex::INVALID_REGEX),\n     LintId::of(self_assignment::SELF_ASSIGNMENT),\n     LintId::of(serde_api::SERDE_API_MISUSE),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(swap::ALMOST_SWAPPED),\n-    LintId::of(to_string_in_display::TO_STRING_IN_DISPLAY),\n     LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),"}, {"sha": "97e22e9a1f9c2f72f1478234b1af6fa9c7cae10b", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -416,6 +416,7 @@ store.register_lints(&[\n     ranges::RANGE_PLUS_ONE,\n     ranges::RANGE_ZIP_WITH_LEN,\n     ranges::REVERSED_EMPTY_RANGES,\n+    recursive_format_impl::RECURSIVE_FORMAT_IMPL,\n     redundant_clone::REDUNDANT_CLONE,\n     redundant_closure_call::REDUNDANT_CLOSURE_CALL,\n     redundant_else::REDUNDANT_ELSE,\n@@ -460,7 +461,6 @@ store.register_lints(&[\n     tabs_in_doc_comments::TABS_IN_DOC_COMMENTS,\n     temporary_assignment::TEMPORARY_ASSIGNMENT,\n     to_digit_is_some::TO_DIGIT_IS_SOME,\n-    to_string_in_display::TO_STRING_IN_DISPLAY,\n     trailing_empty_array::TRAILING_EMPTY_ARRAY,\n     trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS,\n     trait_bounds::TYPE_REPETITION_IN_BOUNDS,"}, {"sha": "93b1d178ac259fea4ca8de7eab21c0942ebbcb08", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -332,6 +332,7 @@ mod ptr_eq;\n mod ptr_offset_with_cast;\n mod question_mark;\n mod ranges;\n+mod recursive_format_impl;\n mod redundant_clone;\n mod redundant_closure_call;\n mod redundant_else;\n@@ -364,7 +365,6 @@ mod swap;\n mod tabs_in_doc_comments;\n mod temporary_assignment;\n mod to_digit_is_some;\n-mod to_string_in_display;\n mod trailing_empty_array;\n mod trait_bounds;\n mod transmute;\n@@ -704,7 +704,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| Box::new(modulo_arithmetic::ModuloArithmetic));\n     store.register_early_pass(|| Box::new(reference::DerefAddrOf));\n     store.register_early_pass(|| Box::new(double_parens::DoubleParens));\n-    store.register_late_pass(|| Box::new(to_string_in_display::ToStringInDisplay::new()));\n+    store.register_late_pass(|| Box::new(recursive_format_impl::RecursiveFormatImpl::new()));\n     store.register_early_pass(|| Box::new(unsafe_removed_from_name::UnsafeNameRemoval));\n     store.register_early_pass(|| Box::new(else_if_without_else::ElseIfWithoutElse));\n     store.register_early_pass(|| Box::new(int_plus_one::IntPlusOne));\n@@ -938,6 +938,7 @@ pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n     ls.register_renamed(\"clippy::disallowed_type\", \"clippy::disallowed_types\");\n     ls.register_renamed(\"clippy::disallowed_method\", \"clippy::disallowed_methods\");\n     ls.register_renamed(\"clippy::ref_in_deref\", \"clippy::needless_borrow\");\n+    ls.register_renamed(\"clippy::to_string_in_display\", \"clippy::recursive_format_impl\");\n \n     // uplifted lints\n     ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");"}, {"sha": "5bb9740749b6c0b3032a945813646c24ef08ff7c", "filename": "clippy_lints/src/recursive_format_impl.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Frecursive_format_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_lints%2Fsrc%2Frecursive_format_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frecursive_format_impl.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -0,0 +1,190 @@\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::macros::{is_format_macro, root_macro_call_first_node, FormatArgsArg, FormatArgsExpn};\n+use clippy_utils::{is_diag_trait_item, path_to_local, peel_ref_operators};\n+use if_chain::if_chain;\n+use rustc_hir::{Expr, ExprKind, Impl, Item, ItemKind, QPath};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{sym, symbol::kw, Symbol};\n+\n+#[derive(Clone, Copy)]\n+enum FormatTrait {\n+    Debug,\n+    Display,\n+}\n+\n+impl FormatTrait {\n+    fn name(self) -> Symbol {\n+        match self {\n+            FormatTrait::Debug => sym::Debug,\n+            FormatTrait::Display => sym::Display,\n+        }\n+    }\n+}\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for format trait implementations (e.g. `Display`) with a recursive call to itself\n+    /// which uses `self` as a parameter.\n+    /// This is typically done indirectly with the `write!` macro or with `to_string()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// This will lead to infinite recursion and a stack overflow.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.to_string())\n+    ///     }\n+    /// }\n+    ///\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Structure(i32);\n+    /// impl fmt::Display for Structure {\n+    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    ///         write!(f, \"{}\", self.0)\n+    ///     }\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.48.0\"]\n+    pub RECURSIVE_FORMAT_IMPL,\n+    correctness,\n+    \"Format trait method called while implementing the same Format trait\"\n+}\n+\n+#[derive(Default)]\n+pub struct RecursiveFormatImpl {\n+    // Whether we are inside Display or Debug trait impl - None for neither\n+    format_trait_impl: Option<FormatTrait>,\n+}\n+\n+impl RecursiveFormatImpl {\n+    pub fn new() -> Self {\n+        Self {\n+            format_trait_impl: None,\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(RecursiveFormatImpl => [RECURSIVE_FORMAT_IMPL]);\n+\n+impl<'tcx> LateLintPass<'tcx> for RecursiveFormatImpl {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if let Some(format_trait_impl) = is_format_trait_impl(cx, item) {\n+            self.format_trait_impl = Some(format_trait_impl);\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        // Assume no nested Impl of Debug and Display within eachother\n+        if is_format_trait_impl(cx, item).is_some() {\n+            self.format_trait_impl = None;\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        match self.format_trait_impl {\n+            Some(FormatTrait::Display) => {\n+                check_to_string_in_display(cx, expr);\n+                check_self_in_format_args(cx, expr, FormatTrait::Display);\n+            },\n+            Some(FormatTrait::Debug) => {\n+                check_self_in_format_args(cx, expr, FormatTrait::Debug);\n+            },\n+            None => {},\n+        }\n+    }\n+}\n+\n+fn check_to_string_in_display(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        // Get the hir_id of the object we are calling the method on\n+        if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n+        // Is the method to_string() ?\n+        if path.ident.name == sym!(to_string);\n+        // Is the method a part of the ToString trait? (i.e. not to_string() implemented\n+        // separately)\n+        if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+        if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n+        // Is the method is called on self\n+        if let ExprKind::Path(QPath::Resolved(_, path)) = self_arg.kind;\n+        if let [segment] = path.segments;\n+        if segment.ident.name == kw::SelfLower;\n+        then {\n+            span_lint(\n+                cx,\n+                RECURSIVE_FORMAT_IMPL,\n+                expr.span,\n+                \"using `self.to_string` in `fmt::Display` implementation will cause infinite recursion\",\n+            );\n+        }\n+    }\n+}\n+\n+fn check_self_in_format_args<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, impl_trait: FormatTrait) {\n+    // Check each arg in format calls - do we ever use Display on self (directly or via deref)?\n+    if_chain! {\n+        if let Some(outer_macro) = root_macro_call_first_node(cx, expr);\n+        if let macro_def_id = outer_macro.def_id;\n+        if let Some(format_args) = FormatArgsExpn::find_nested(cx, expr, outer_macro.expn);\n+        if is_format_macro(cx, macro_def_id);\n+        if let Some(args) = format_args.args();\n+        then {\n+            for arg in args {\n+                if arg.format_trait != impl_trait.name() {\n+                    continue;\n+                }\n+                check_format_arg_self(cx, expr, &arg, impl_trait);\n+            }\n+        }\n+    }\n+}\n+\n+fn check_format_arg_self(cx: &LateContext<'_>, expr: &Expr<'_>, arg: &FormatArgsArg<'_>, impl_trait: FormatTrait) {\n+    // Handle multiple dereferencing of references e.g. &&self\n+    // Handle dereference of &self -> self that is equivalent (i.e. via *self in fmt() impl)\n+    // Since the argument to fmt is itself a reference: &self\n+    let reference = peel_ref_operators(cx, arg.value);\n+    let map = cx.tcx.hir();\n+    // Is the reference self?\n+    let symbol_ident = impl_trait.name().to_ident_string();\n+    if path_to_local(reference).map(|x| map.name(x)) == Some(kw::SelfLower) {\n+        span_lint(\n+            cx,\n+            RECURSIVE_FORMAT_IMPL,\n+            expr.span,\n+            &format!(\n+                \"using `self` as `{}` in `impl {}` will cause infinite recursion\",\n+                &symbol_ident, &symbol_ident\n+            ),\n+        );\n+    }\n+}\n+\n+fn is_format_trait_impl(cx: &LateContext<'_>, item: &Item<'_>) -> Option<FormatTrait> {\n+    if_chain! {\n+        // Are we at an Impl?\n+        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind;\n+        if let Some(did) = trait_ref.trait_def_id();\n+        if let Some(name) = cx.tcx.get_diagnostic_name(did);\n+        then {\n+            // Is Impl for Debug or Display?\n+            match name {\n+                sym::Debug => Some(FormatTrait::Debug),\n+                sym::Display => Some(FormatTrait::Display),\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "03060d78fc5af39d325068a721a991b9e96a7e83", "filename": "clippy_lints/src/to_string_in_display.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4931cab709401cc8350598eab9bd51031c89565a/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4931cab709401cc8350598eab9bd51031c89565a/clippy_lints%2Fsrc%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_string_in_display.rs?ref=4931cab709401cc8350598eab9bd51031c89565a", "patch": "@@ -1,123 +0,0 @@\n-use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{is_diag_trait_item, match_def_path, path_to_local_id, paths};\n-use if_chain::if_chain;\n-use rustc_hir::{Expr, ExprKind, HirId, Impl, ImplItem, ImplItemKind, Item, ItemKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::sym;\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for uses of `to_string()` in `Display` traits.\n-    ///\n-    /// ### Why is this bad?\n-    /// Usually `to_string` is implemented indirectly\n-    /// via `Display`. Hence using it while implementing `Display` would\n-    /// lead to infinite recursion.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// struct Structure(i32);\n-    /// impl fmt::Display for Structure {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-    ///         write!(f, \"{}\", self.to_string())\n-    ///     }\n-    /// }\n-    ///\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// use std::fmt;\n-    ///\n-    /// struct Structure(i32);\n-    /// impl fmt::Display for Structure {\n-    ///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-    ///         write!(f, \"{}\", self.0)\n-    ///     }\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.48.0\"]\n-    pub TO_STRING_IN_DISPLAY,\n-    correctness,\n-    \"`to_string` method used while implementing `Display` trait\"\n-}\n-\n-#[derive(Default)]\n-pub struct ToStringInDisplay {\n-    in_display_impl: bool,\n-    self_hir_id: Option<HirId>,\n-}\n-\n-impl ToStringInDisplay {\n-    pub fn new() -> Self {\n-        Self {\n-            in_display_impl: false,\n-            self_hir_id: None,\n-        }\n-    }\n-}\n-\n-impl_lint_pass!(ToStringInDisplay => [TO_STRING_IN_DISPLAY]);\n-\n-impl LateLintPass<'_> for ToStringInDisplay {\n-    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n-        if is_display_impl(cx, item) {\n-            self.in_display_impl = true;\n-        }\n-    }\n-\n-    fn check_item_post(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n-        if is_display_impl(cx, item) {\n-            self.in_display_impl = false;\n-            self.self_hir_id = None;\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &ImplItem<'_>) {\n-        if_chain! {\n-            if self.in_display_impl;\n-            if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n-            let body = cx.tcx.hir().body(*body_id);\n-            if !body.params.is_empty();\n-            then {\n-                let self_param = &body.params[0];\n-                self.self_hir_id = Some(self_param.pat.hir_id);\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if_chain! {\n-            if self.in_display_impl;\n-            if let Some(self_hir_id) = self.self_hir_id;\n-            if let ExprKind::MethodCall(path, [ref self_arg, ..], _) = expr.kind;\n-            if path.ident.name == sym!(to_string);\n-            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n-            if is_diag_trait_item(cx, expr_def_id, sym::ToString);\n-            if path_to_local_id(self_arg, self_hir_id);\n-            then {\n-                span_lint(\n-                    cx,\n-                    TO_STRING_IN_DISPLAY,\n-                    expr.span,\n-                    \"using `to_string` in `fmt::Display` implementation might lead to infinite recursion\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn is_display_impl(cx: &LateContext<'_>, item: &Item<'_>) -> bool {\n-    if_chain! {\n-        if let ItemKind::Impl(Impl { of_trait: Some(trait_ref), .. }) = &item.kind;\n-        if let Some(did) = trait_ref.trait_def_id();\n-        then {\n-            match_def_path(cx, did, &paths::DISPLAY_TRAIT)\n-        } else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "256f884ae1994787a773e91c69d283087032875d", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -1,6 +1,7 @@\n #![allow(clippy::similar_names)] // `expr` and `expn`\n \n use crate::visitors::expr_visitor_no_bodies;\n+use crate::{match_def_path, paths};\n \n use arrayvec::ArrayVec;\n use if_chain::if_chain;\n@@ -13,6 +14,31 @@ use rustc_span::hygiene::{self, MacroKind, SyntaxContext};\n use rustc_span::{sym, ExpnData, ExpnId, ExpnKind, Span, Symbol};\n use std::ops::ControlFlow;\n \n+const FORMAT_MACRO_PATHS: &[&[&str]] = &[\n+    &paths::FORMAT_ARGS_MACRO,\n+    &paths::ASSERT_EQ_MACRO,\n+    &paths::ASSERT_MACRO,\n+    &paths::ASSERT_NE_MACRO,\n+    &paths::EPRINT_MACRO,\n+    &paths::EPRINTLN_MACRO,\n+    &paths::PRINT_MACRO,\n+    &paths::PRINTLN_MACRO,\n+    &paths::WRITE_MACRO,\n+    &paths::WRITELN_MACRO,\n+];\n+\n+const FORMAT_MACRO_DIAG_ITEMS: &[Symbol] = &[sym::format_macro, sym::std_panic_macro];\n+\n+/// Returns true if a given Macro `DefId` is a format macro (e.g. `println!`)\n+pub fn is_format_macro(cx: &LateContext<'_>, macro_def_id: DefId) -> bool {\n+    FORMAT_MACRO_PATHS\n+        .iter()\n+        .any(|path| match_def_path(cx, macro_def_id, path))\n+        || FORMAT_MACRO_DIAG_ITEMS\n+            .iter()\n+            .any(|diag_item| cx.tcx.is_diagnostic_item(*diag_item, macro_def_id))\n+}\n+\n /// A macro call, like `vec![1, 2, 3]`.\n ///\n /// Use `tcx.item_name(macro_call.def_id)` to get the macro name."}, {"sha": "48c0e89e4d2b2e023f78405516ab5635c6789212", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -33,6 +33,7 @@ pub const BTREEMAP_INSERT: [&str; 6] = [\"alloc\", \"collections\", \"btree\", \"map\",\n pub const CLONE_TRAIT_METHOD: [&str; 4] = [\"core\", \"clone\", \"Clone\", \"clone\"];\n pub const COW: [&str; 3] = [\"alloc\", \"borrow\", \"Cow\"];\n pub const CSTRING_AS_C_STR: [&str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"as_c_str\"];\n+pub const DEBUG_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Debug\"];\n pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"default\"];\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible"}, {"sha": "9241bf7ed74025b8508ace83be7a2819fe66d09e", "filename": "tests/ui/recursive_format_impl.rs", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frecursive_format_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frecursive_format_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursive_format_impl.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -0,0 +1,321 @@\n+#![warn(clippy::recursive_format_impl)]\n+#![allow(\n+    clippy::inherent_to_string_shadow_display,\n+    clippy::to_string_in_format_args,\n+    clippy::deref_addrof\n+)]\n+\n+use std::fmt;\n+\n+struct A;\n+impl A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+trait B {\n+    fn fmt(&self) {}\n+}\n+\n+impl B for A {\n+    fn fmt(&self) {\n+        self.to_string();\n+    }\n+}\n+\n+impl fmt::Display for A {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+fn fmt(a: A) {\n+    a.to_string();\n+}\n+\n+struct C;\n+\n+impl C {\n+    // Doesn't trigger if to_string defined separately\n+    // i.e. not using ToString trait (from Display)\n+    fn to_string(&self) -> String {\n+        String::from(\"I am C\")\n+    }\n+}\n+\n+impl fmt::Display for C {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.to_string())\n+    }\n+}\n+\n+enum D {\n+    E(String),\n+    F,\n+}\n+\n+impl std::fmt::Display for D {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match &self {\n+            Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+            Self::F => write!(f, \"F\"),\n+        }\n+    }\n+}\n+\n+// Check for use of self as Display, in Display impl\n+// Triggers on direct use of self\n+struct G {}\n+\n+impl std::fmt::Display for G {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+// Triggers on reference to self\n+struct H {}\n+\n+impl std::fmt::Display for H {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", &self)\n+    }\n+}\n+\n+impl std::fmt::Debug for H {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", &self)\n+    }\n+}\n+\n+// Triggers on multiple reference to self\n+struct H2 {}\n+\n+impl std::fmt::Display for H2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{}\", &&&self)\n+    }\n+}\n+\n+// Doesn't trigger on correct deref\n+struct I {}\n+\n+impl std::ops::Deref for I {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for I {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &**self)\n+    }\n+}\n+\n+impl std::fmt::Debug for I {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?}\", &**self)\n+    }\n+}\n+\n+// Doesn't trigger on multiple correct deref\n+struct I2 {}\n+\n+impl std::ops::Deref for I2 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for I2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", **&&&**self)\n+    }\n+}\n+\n+// Doesn't trigger on multiple correct deref\n+struct I3 {}\n+\n+impl std::ops::Deref for I3 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for I3 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &&**&&&**self)\n+    }\n+}\n+\n+// Does trigger when deref resolves to self\n+struct J {}\n+\n+impl std::ops::Deref for J {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &*self)\n+    }\n+}\n+\n+impl std::fmt::Debug for J {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?}\", &*self)\n+    }\n+}\n+\n+struct J2 {}\n+\n+impl std::ops::Deref for J2 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", *self)\n+    }\n+}\n+\n+struct J3 {}\n+\n+impl std::ops::Deref for J3 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J3 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", **&&*self)\n+    }\n+}\n+\n+struct J4 {}\n+\n+impl std::ops::Deref for J4 {\n+    type Target = str;\n+\n+    fn deref(&self) -> &Self::Target {\n+        \"test\"\n+    }\n+}\n+\n+impl std::fmt::Display for J4 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", &&**&&*self)\n+    }\n+}\n+\n+// Doesn't trigger on Debug from Display\n+struct K {}\n+\n+impl std::fmt::Debug for K {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"test\")\n+    }\n+}\n+\n+impl std::fmt::Display for K {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?}\", self)\n+    }\n+}\n+\n+// Doesn't trigger on Display from Debug\n+struct K2 {}\n+\n+impl std::fmt::Debug for K2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{}\", self)\n+    }\n+}\n+\n+impl std::fmt::Display for K2 {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"test\")\n+    }\n+}\n+\n+// Doesn't trigger on struct fields\n+struct L {\n+    field1: u32,\n+    field2: i32,\n+}\n+\n+impl std::fmt::Display for L {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{},{}\", self.field1, self.field2)\n+    }\n+}\n+\n+impl std::fmt::Debug for L {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        write!(f, \"{:?},{:?}\", self.field1, self.field2)\n+    }\n+}\n+\n+// Doesn't trigger on nested enum matching\n+enum Tree {\n+    Leaf,\n+    Node(Vec<Tree>),\n+}\n+\n+impl std::fmt::Display for Tree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Tree::Leaf => write!(f, \"*\"),\n+            Tree::Node(children) => {\n+                write!(f, \"(\")?;\n+                for child in children.iter() {\n+                    write!(f, \"{},\", child)?;\n+                }\n+                write!(f, \")\")\n+            },\n+        }\n+    }\n+}\n+\n+impl std::fmt::Debug for Tree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Tree::Leaf => write!(f, \"*\"),\n+            Tree::Node(children) => {\n+                write!(f, \"(\")?;\n+                for child in children.iter() {\n+                    write!(f, \"{:?},\", child)?;\n+                }\n+                write!(f, \")\")\n+            },\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let a = A;\n+    a.to_string();\n+    a.fmt();\n+    fmt(a);\n+\n+    let c = C;\n+    c.to_string();\n+}"}, {"sha": "6171696ed69d4f7432cb0bd7488bc4f00ae18f80", "filename": "tests/ui/recursive_format_impl.stderr", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frecursive_format_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frecursive_format_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frecursive_format_impl.stderr?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -0,0 +1,91 @@\n+error: using `self.to_string` in `fmt::Display` implementation will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:29:25\n+   |\n+LL |         write!(f, \"{}\", self.to_string())\n+   |                         ^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::recursive-format-impl` implied by `-D warnings`\n+\n+error: unnecessary use of `to_string`\n+  --> $DIR/recursive_format_impl.rs:61:50\n+   |\n+LL |             Self::E(string) => write!(f, \"E {}\", string.to_string()),\n+   |                                                  ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n+   = note: this error originates in the macro `$crate::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:73:9\n+   |\n+LL |         write!(f, \"{}\", self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:82:9\n+   |\n+LL |         write!(f, \"{}\", &self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Debug` in `impl Debug` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:88:9\n+   |\n+LL |         write!(f, \"{:?}\", &self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:97:9\n+   |\n+LL |         write!(f, \"{}\", &&&self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:171:9\n+   |\n+LL |         write!(f, \"{}\", &*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Debug` in `impl Debug` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:177:9\n+   |\n+LL |         write!(f, \"{:?}\", &*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:193:9\n+   |\n+LL |         write!(f, \"{}\", *self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:209:9\n+   |\n+LL |         write!(f, \"{}\", **&&*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: using `self` as `Display` in `impl Display` will cause infinite recursion\n+  --> $DIR/recursive_format_impl.rs:225:9\n+   |\n+LL |         write!(f, \"{}\", &&**&&*self)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: this error originates in the macro `write` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "24a0c812291982371e67496695f2eb1b8275abe5", "filename": "tests/ui/rename.fixed", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.fixed?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -20,6 +20,7 @@\n #![allow(clippy::match_result_ok)]\n #![allow(clippy::disallowed_types)]\n #![allow(clippy::disallowed_methods)]\n+#![allow(clippy::recursive_format_impl)]\n // uplifted lints\n #![allow(invalid_value)]\n #![allow(array_into_iter)]\n@@ -55,6 +56,7 @@\n #![warn(clippy::disallowed_types)]\n #![warn(clippy::disallowed_methods)]\n #![warn(clippy::needless_borrow)]\n+#![warn(clippy::recursive_format_impl)]\n // uplifted lints\n #![warn(invalid_value)]\n #![warn(array_into_iter)]"}, {"sha": "ea64234c680d37f5ef8b7951100723a5a33a3054", "filename": "tests/ui/rename.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.rs?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -20,6 +20,7 @@\n #![allow(clippy::match_result_ok)]\n #![allow(clippy::disallowed_types)]\n #![allow(clippy::disallowed_methods)]\n+#![allow(clippy::recursive_format_impl)]\n // uplifted lints\n #![allow(invalid_value)]\n #![allow(array_into_iter)]\n@@ -55,6 +56,7 @@\n #![warn(clippy::disallowed_type)]\n #![warn(clippy::disallowed_method)]\n #![warn(clippy::ref_in_deref)]\n+#![warn(clippy::to_string_in_display)]\n // uplifted lints\n #![warn(clippy::invalid_ref)]\n #![warn(clippy::into_iter_on_array)]"}, {"sha": "8b132a7838470cbd90aba6f1e1c36be73274e8bc", "filename": "tests/ui/rename.stderr", "status": "modified", "additions": 40, "deletions": 34, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b34cd79c0cf2f5425aa56a77cbe95459bef1d98f/tests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.stderr?ref=b34cd79c0cf2f5425aa56a77cbe95459bef1d98f", "patch": "@@ -1,202 +1,208 @@\n error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n-  --> $DIR/rename.rs:34:9\n+  --> $DIR/rename.rs:35:9\n    |\n LL | #![warn(clippy::stutter)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n-  --> $DIR/rename.rs:35:9\n+  --> $DIR/rename.rs:36:9\n    |\n LL | #![warn(clippy::new_without_default_derive)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n-  --> $DIR/rename.rs:36:9\n+  --> $DIR/rename.rs:37:9\n    |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:37:9\n+  --> $DIR/rename.rs:38:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:38:9\n+  --> $DIR/rename.rs:39:9\n    |\n LL | #![warn(clippy::option_and_then_some)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n-  --> $DIR/rename.rs:39:9\n+  --> $DIR/rename.rs:40:9\n    |\n LL | #![warn(clippy::box_vec)]\n    |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n \n error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:40:9\n+  --> $DIR/rename.rs:41:9\n    |\n LL | #![warn(clippy::block_in_if_condition_expr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n-  --> $DIR/rename.rs:41:9\n+  --> $DIR/rename.rs:42:9\n    |\n LL | #![warn(clippy::block_in_if_condition_stmt)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:42:9\n+  --> $DIR/rename.rs:43:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:43:9\n+  --> $DIR/rename.rs:44:9\n    |\n LL | #![warn(clippy::option_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n-  --> $DIR/rename.rs:44:9\n+  --> $DIR/rename.rs:45:9\n    |\n LL | #![warn(clippy::result_map_unwrap_or_else)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:45:9\n+  --> $DIR/rename.rs:46:9\n    |\n LL | #![warn(clippy::option_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n-  --> $DIR/rename.rs:46:9\n+  --> $DIR/rename.rs:47:9\n    |\n LL | #![warn(clippy::result_unwrap_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:47:9\n+  --> $DIR/rename.rs:48:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n-  --> $DIR/rename.rs:48:9\n+  --> $DIR/rename.rs:49:9\n    |\n LL | #![warn(clippy::result_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n error: lint `clippy::for_loop_over_option` has been renamed to `clippy::for_loops_over_fallibles`\n-  --> $DIR/rename.rs:49:9\n+  --> $DIR/rename.rs:50:9\n    |\n LL | #![warn(clippy::for_loop_over_option)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n error: lint `clippy::for_loop_over_result` has been renamed to `clippy::for_loops_over_fallibles`\n-  --> $DIR/rename.rs:50:9\n+  --> $DIR/rename.rs:51:9\n    |\n LL | #![warn(clippy::for_loop_over_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n-  --> $DIR/rename.rs:51:9\n+  --> $DIR/rename.rs:52:9\n    |\n LL | #![warn(clippy::identity_conversion)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n-  --> $DIR/rename.rs:52:9\n+  --> $DIR/rename.rs:53:9\n    |\n LL | #![warn(clippy::zero_width_space)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n-  --> $DIR/rename.rs:53:9\n+  --> $DIR/rename.rs:54:9\n    |\n LL | #![warn(clippy::single_char_push_str)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n-  --> $DIR/rename.rs:54:9\n+  --> $DIR/rename.rs:55:9\n    |\n LL | #![warn(clippy::if_let_some_result)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n-  --> $DIR/rename.rs:55:9\n+  --> $DIR/rename.rs:56:9\n    |\n LL | #![warn(clippy::disallowed_type)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n-  --> $DIR/rename.rs:56:9\n+  --> $DIR/rename.rs:57:9\n    |\n LL | #![warn(clippy::disallowed_method)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n-  --> $DIR/rename.rs:57:9\n+  --> $DIR/rename.rs:58:9\n    |\n LL | #![warn(clippy::ref_in_deref)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n-error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n+error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n   --> $DIR/rename.rs:59:9\n    |\n+LL | #![warn(clippy::to_string_in_display)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n+\n+error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n+  --> $DIR/rename.rs:61:9\n+   |\n LL | #![warn(clippy::invalid_ref)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:60:9\n+  --> $DIR/rename.rs:62:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n error: lint `clippy::unused_label` has been renamed to `unused_labels`\n-  --> $DIR/rename.rs:61:9\n+  --> $DIR/rename.rs:63:9\n    |\n LL | #![warn(clippy::unused_label)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:64:9\n    |\n LL | #![warn(clippy::drop_bounds)]\n    |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n-  --> $DIR/rename.rs:63:9\n+  --> $DIR/rename.rs:65:9\n    |\n LL | #![warn(clippy::temporary_cstring_as_ptr)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n-  --> $DIR/rename.rs:64:9\n+  --> $DIR/rename.rs:66:9\n    |\n LL | #![warn(clippy::panic_params)]\n    |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n-  --> $DIR/rename.rs:65:9\n+  --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n-  --> $DIR/rename.rs:66:9\n+  --> $DIR/rename.rs:68:9\n    |\n LL | #![warn(clippy::invalid_atomic_ordering)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n \n error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:67:9\n+  --> $DIR/rename.rs:69:9\n    |\n LL | #![warn(clippy::mem_discriminant_non_enum)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n-error: aborting due to 33 previous errors\n+error: aborting due to 34 previous errors\n "}, {"sha": "3ccdcd1117b5a5d47dcf87f95b30acbdba631e13", "filename": "tests/ui/to_string_in_display.rs", "status": "removed", "additions": 0, "deletions": 69, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4931cab709401cc8350598eab9bd51031c89565a/tests%2Fui%2Fto_string_in_display.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4931cab709401cc8350598eab9bd51031c89565a/tests%2Fui%2Fto_string_in_display.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.rs?ref=4931cab709401cc8350598eab9bd51031c89565a", "patch": "@@ -1,69 +0,0 @@\n-#![warn(clippy::to_string_in_display)]\n-#![allow(clippy::inherent_to_string_shadow_display, clippy::to_string_in_format_args)]\n-\n-use std::fmt;\n-\n-struct A;\n-impl A {\n-    fn fmt(&self) {\n-        self.to_string();\n-    }\n-}\n-\n-trait B {\n-    fn fmt(&self) {}\n-}\n-\n-impl B for A {\n-    fn fmt(&self) {\n-        self.to_string();\n-    }\n-}\n-\n-impl fmt::Display for A {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_string())\n-    }\n-}\n-\n-fn fmt(a: A) {\n-    a.to_string();\n-}\n-\n-struct C;\n-\n-impl C {\n-    fn to_string(&self) -> String {\n-        String::from(\"I am C\")\n-    }\n-}\n-\n-impl fmt::Display for C {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.to_string())\n-    }\n-}\n-\n-enum D {\n-    E(String),\n-    F,\n-}\n-\n-impl std::fmt::Display for D {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match &self {\n-            Self::E(string) => write!(f, \"E {}\", string.to_string()),\n-            Self::F => write!(f, \"F\"),\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let a = A;\n-    a.to_string();\n-    a.fmt();\n-    fmt(a);\n-\n-    let c = C;\n-    c.to_string();\n-}"}, {"sha": "80189ca1f0aeeedc70fb70c0ffe4b75d509f12c3", "filename": "tests/ui/to_string_in_display.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4931cab709401cc8350598eab9bd51031c89565a/tests%2Fui%2Fto_string_in_display.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4931cab709401cc8350598eab9bd51031c89565a/tests%2Fui%2Fto_string_in_display.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_string_in_display.stderr?ref=4931cab709401cc8350598eab9bd51031c89565a", "patch": "@@ -1,19 +0,0 @@\n-error: using `to_string` in `fmt::Display` implementation might lead to infinite recursion\n-  --> $DIR/to_string_in_display.rs:25:25\n-   |\n-LL |         write!(f, \"{}\", self.to_string())\n-   |                         ^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::to-string-in-display` implied by `-D warnings`\n-\n-error: unnecessary use of `to_string`\n-  --> $DIR/to_string_in_display.rs:55:50\n-   |\n-LL |             Self::E(string) => write!(f, \"E {}\", string.to_string()),\n-   |                                                  ^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n-   = note: this error originates in the macro `$crate::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n-error: aborting due to 2 previous errors\n-"}]}