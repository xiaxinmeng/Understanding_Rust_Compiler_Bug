{"sha": "1851f0802e148bb7fa0bfd7dabcb7397bf371b0b", "node_id": "C_kwDOAAsO6NoAKDE4NTFmMDgwMmUxNDhiYjdmYTBiZmQ3ZGFiY2I3Mzk3YmYzNzFiMGI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-26T15:29:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-26T15:29:01Z"}, "message": "Auto merge of #97046 - conradludgate:faster-ascii-case-conv-path, r=thomcc\n\nimprove case conversion happy path\n\nSomeone shared the source code for [Go's string case conversion](https://github.com/golang/go/blob/19156a54741d4f353c9e8e0860197ca95a6ee6ca/src/strings/strings.go#L558-L616).\n\nIt features a hot path for ascii-only strings (although I assume for reasons specific to go, they've opted for a read safe hot loop).\n\nI've borrowed these ideas and also kept our existing code to provide a fast path + seamless utf-8 correct path fallback.\n\n(Naive) Benchmarks can be found here https://github.com/conradludgate/case-conv\n\nFor the cases where non-ascii is found near the start, the performance of this algorithm does fall back to original speeds and has not had any measurable speed loss", "tree": {"sha": "7e6f122ecd392e2ab7698fe3dab91de707fb27d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e6f122ecd392e2ab7698fe3dab91de707fb27d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b", "html_url": "https://github.com/rust-lang/rust/commit/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab98933fa75d72e882b86feac1a0be3a5b02cb0", "html_url": "https://github.com/rust-lang/rust/commit/1ab98933fa75d72e882b86feac1a0be3a5b02cb0"}, {"sha": "d0f993070929428f7a484cfce66d5690e709006d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0f993070929428f7a484cfce66d5690e709006d", "html_url": "https://github.com/rust-lang/rust/commit/d0f993070929428f7a484cfce66d5690e709006d"}], "stats": {"total": 88, "additions": 83, "deletions": 5}, "files": [{"sha": "39dfd98ddccfb8aef35fd13a1379d3dfaeaad797", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=1851f0802e148bb7fa0bfd7dabcb7397bf371b0b", "patch": "@@ -383,15 +383,23 @@ impl str {\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_lowercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        for (i, c) in self[..].char_indices() {\n+        let out = convert_while_ascii(self.as_bytes(), u8::to_ascii_lowercase);\n+\n+        // Safety: we know this is a valid char boundary since\n+        // out.len() is only progressed if ascii bytes are found\n+        let rest = unsafe { self.get_unchecked(out.len()..) };\n+\n+        // Safety: We have written only valid ASCII to our vec\n+        let mut s = unsafe { String::from_utf8_unchecked(out) };\n+\n+        for (i, c) in rest[..].char_indices() {\n             if c == '\u03a3' {\n                 // \u03a3 maps to \u03c3, except at the end of a word where it maps to \u03c2.\n                 // This is the only conditional (contextual) but language-independent mapping\n                 // in `SpecialCasing.txt`,\n                 // so hard-code it rather than have a generic \"condition\" mechanism.\n                 // See https://github.com/rust-lang/rust/issues/26035\n-                map_uppercase_sigma(self, i, &mut s)\n+                map_uppercase_sigma(rest, i, &mut s)\n             } else {\n                 match conversions::to_lower(c) {\n                     [a, '\\0', _] => s.push(a),\n@@ -466,8 +474,16 @@ impl str {\n                   without modifying the original\"]\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n-        let mut s = String::with_capacity(self.len());\n-        for c in self[..].chars() {\n+        let out = convert_while_ascii(self.as_bytes(), u8::to_ascii_uppercase);\n+\n+        // Safety: we know this is a valid char boundary since\n+        // out.len() is only progressed if ascii bytes are found\n+        let rest = unsafe { self.get_unchecked(out.len()..) };\n+\n+        // Safety: We have written only valid ASCII to our vec\n+        let mut s = unsafe { String::from_utf8_unchecked(out) };\n+\n+        for c in rest.chars() {\n             match conversions::to_upper(c) {\n                 [a, '\\0', _] => s.push(a),\n                 [a, b, '\\0'] => {\n@@ -619,3 +635,51 @@ impl str {\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     unsafe { Box::from_raw(Box::into_raw(v) as *mut str) }\n }\n+\n+/// Converts the bytes while the bytes are still ascii.\n+/// For better average performance, this is happens in chunks of `2*size_of::<usize>()`.\n+/// Returns a vec with the converted bytes.\n+#[inline]\n+#[cfg(not(test))]\n+#[cfg(not(no_global_oom_handling))]\n+fn convert_while_ascii(b: &[u8], convert: fn(&u8) -> u8) -> Vec<u8> {\n+    let mut out = Vec::with_capacity(b.len());\n+\n+    const USIZE_SIZE: usize = mem::size_of::<usize>();\n+    const MAGIC_UNROLL: usize = 2;\n+    const N: usize = USIZE_SIZE * MAGIC_UNROLL;\n+    const NONASCII_MASK: usize = usize::from_ne_bytes([0x80; USIZE_SIZE]);\n+\n+    let mut i = 0;\n+    unsafe {\n+        while i + N <= b.len() {\n+            // Safety: we have checks the sizes `b` and `out` to know that our\n+            let in_chunk = b.get_unchecked(i..i + N);\n+            let out_chunk = out.spare_capacity_mut().get_unchecked_mut(i..i + N);\n+\n+            let mut bits = 0;\n+            for j in 0..MAGIC_UNROLL {\n+                // read the bytes 1 usize at a time (unaligned since we haven't checked the alignment)\n+                // safety: in_chunk is valid bytes in the range\n+                bits |= in_chunk.as_ptr().cast::<usize>().add(j).read_unaligned();\n+            }\n+            // if our chunks aren't ascii, then return only the prior bytes as init\n+            if bits & NONASCII_MASK != 0 {\n+                break;\n+            }\n+\n+            // perform the case conversions on N bytes (gets heavily autovec'd)\n+            for j in 0..N {\n+                // safety: in_chunk and out_chunk is valid bytes in the range\n+                let out = out_chunk.get_unchecked_mut(j);\n+                out.write(convert(in_chunk.get_unchecked(j)));\n+            }\n+\n+            // mark these bytes as initialised\n+            i += N;\n+        }\n+        out.set_len(i);\n+    }\n+\n+    out\n+}"}, {"sha": "7379569dd68fe4a189f4218c860fab7d482f9164", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1851f0802e148bb7fa0bfd7dabcb7397bf371b0b/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=1851f0802e148bb7fa0bfd7dabcb7397bf371b0b", "patch": "@@ -1772,6 +1772,20 @@ fn to_lowercase() {\n     assert_eq!(\"\u0391\u03a3\u0391\".to_lowercase(), \"\u03b1\u03c3\u03b1\");\n     assert_eq!(\"\u0391\u03a3'\u0391\".to_lowercase(), \"\u03b1\u03c3'\u03b1\");\n     assert_eq!(\"\u0391\u03a3''\u0391\".to_lowercase(), \"\u03b1\u03c3''\u03b1\");\n+\n+    // a really long string that has it's lowercase form\n+    // even longer. this tests that implementations don't assume\n+    // an incorrect upper bound on allocations\n+    let upper = str::repeat(\"\u0130\", 512);\n+    let lower = str::repeat(\"i\u0307\", 512);\n+    assert_eq!(upper.to_lowercase(), lower);\n+\n+    // a really long ascii-only string.\n+    // This test that the ascii hot-path\n+    // functions correctly\n+    let upper = str::repeat(\"A\", 511);\n+    let lower = str::repeat(\"a\", 511);\n+    assert_eq!(upper.to_lowercase(), lower);\n }\n \n #[test]"}]}