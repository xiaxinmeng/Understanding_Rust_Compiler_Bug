{"sha": "43c07244b32d7aea97e02ededa5797308515e26b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzYzA3MjQ0YjMyZDdhZWE5N2UwMmVkZWRhNTc5NzMwODUxNWUyNmI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-03-08T20:36:22Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-03-08T20:41:32Z"}, "message": "librustc: Fix up fallout from the automatic conversion.", "tree": {"sha": "b7366c4e6b0005a20bb54123e6c72ec7ec86e6f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7366c4e6b0005a20bb54123e6c72ec7ec86e6f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43c07244b32d7aea97e02ededa5797308515e26b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43c07244b32d7aea97e02ededa5797308515e26b", "html_url": "https://github.com/rust-lang/rust/commit/43c07244b32d7aea97e02ededa5797308515e26b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43c07244b32d7aea97e02ededa5797308515e26b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e", "html_url": "https://github.com/rust-lang/rust/commit/3b6e9d4a7a944db06300ae51e151ac62cdaa4a8e"}], "stats": {"total": 1930, "additions": 1172, "deletions": 758}, "files": [{"sha": "d297df1301ea7983d281b99357de447f7fc159ed", "filename": "src/librustc/back/archive.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farchive.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -98,9 +98,17 @@ impl Archive {\n             let archive = os::make_absolute(&self.dst);\n             run_ar(self.sess, \"x\", Some(loc.path()), [&archive,\n                                                       &Path::new(file)]);\n-            fs::File::open(&loc.path().join(file)).read_to_end().unwrap()\n+            let result: Vec<u8> =\n+                fs::File::open(&loc.path().join(file)).read_to_end()\n+                                                      .unwrap()\n+                                                      .move_iter()\n+                                                      .collect();\n+            result\n         } else {\n-            run_ar(self.sess, \"p\", None, [&self.dst, &Path::new(file)]).output\n+            run_ar(self.sess,\n+                   \"p\",\n+                   None,\n+                   [&self.dst, &Path::new(file)]).output.move_iter().collect()\n         }\n     }\n \n@@ -124,7 +132,7 @@ impl Archive {\n         if lto {\n             ignore.push(object.as_slice());\n         }\n-        self.add_archive(rlib, name, ignore)\n+        self.add_archive(rlib, name, ignore.as_slice())\n     }\n \n     /// Adds an arbitrary file to this archive"}, {"sha": "c15c55927a9c8b6e14bbb9b2c99ceb7443525244", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -34,6 +34,7 @@ use std::str;\n use std::io;\n use std::io::Process;\n use std::io::fs;\n+use std::vec_ng::Vec;\n use flate;\n use serialize::hex::ToHex;\n use extra::tempfile::TempDir;\n@@ -106,6 +107,7 @@ pub mod write {\n     use std::io::Process;\n     use std::libc::{c_uint, c_int};\n     use std::str;\n+    use std::vec_ng::Vec;\n \n     // On android, we by default compile for armv7 processors. This enables\n     // things like double word CAS instructions (rather than emulating them)\n@@ -222,7 +224,7 @@ pub mod write {\n \n             if sess.lto() {\n                 time(sess.time_passes(), \"all lto passes\", (), |()|\n-                     lto::run(sess, llmod, tm, trans.reachable));\n+                     lto::run(sess, llmod, tm, trans.reachable.as_slice()));\n \n                 if sess.opts.cg.save_temps {\n                     output.with_extension(\"lto.bc\").with_c_str(|buf| {\n@@ -931,7 +933,8 @@ fn link_rlib(sess: Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write(trans.metadata) {\n+            match fs::File::create(&metadata).write(trans.metadata\n+                                                         .as_slice()) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(format!(\"failed to write {}: {}\",\n@@ -1035,7 +1038,7 @@ fn link_natively(sess: Session, dylib: bool, obj_filename: &Path,\n     // Invoke the system linker\n     debug!(\"{} {}\", cc_prog, cc_args.connect(\" \"));\n     let prog = time(sess.time_passes(), \"running linker\", (), |()|\n-                    Process::output(cc_prog, cc_args));\n+                    Process::output(cc_prog, cc_args.as_slice()));\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n@@ -1198,7 +1201,7 @@ fn link_args(sess: Session,\n     // where extern libraries might live, based on the\n     // addl_lib_search_paths\n     if !sess.opts.cg.no_rpath {\n-        args.push_all(rpath::get_rpath_flags(sess, out_filename));\n+        args.push_all(rpath::get_rpath_flags(sess, out_filename).as_slice());\n     }\n \n     // Stack growth requires statically linking a __morestack function\n@@ -1210,7 +1213,7 @@ fn link_args(sess: Session,\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n-    args.push_all(sess.opts.cg.link_args);\n+    args.push_all(sess.opts.cg.link_args.as_slice());\n     let used_link_args = sess.cstore.get_used_link_args();\n     let used_link_args = used_link_args.borrow();\n     for arg in used_link_args.get().iter() {"}, {"sha": "bc24660e306732bb5c6ae1411d1407640861a336", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -11,6 +11,7 @@\n use back::target_strs;\n use driver::session::sess_os_to_meta_os;\n use metadata::loader::meta_section_name;\n+use std::vec_ng::Vec;\n use syntax::abi;\n \n pub fn get_target_strs(target_triple: ~str, target_os: abi::Os) -> target_strs::t {"}, {"sha": "9b543bb50cc5ca9dc22a1b09ac2edff60603952a", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -15,6 +15,7 @@ use metadata::filesearch;\n \n use collections::HashSet;\n use std::{os, vec};\n+use std::vec_ng::Vec;\n use syntax::abi;\n \n fn not_win32(os: abi::Os) -> bool {\n@@ -49,7 +50,7 @@ pub fn get_rpath_flags(sess: session::Session, out_filename: &Path) -> Vec<~str>\n \n     let rpaths = get_rpaths(os, sysroot, output, libs,\n                             sess.opts.target_triple);\n-    flags.push_all(rpaths_to_flags(rpaths));\n+    flags.push_all(rpaths_to_flags(rpaths.as_slice()).as_slice());\n     flags\n }\n \n@@ -100,16 +101,16 @@ fn get_rpaths(os: abi::Os,\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths);\n-    log_rpaths(\"absolute\", abs_rpaths);\n-    log_rpaths(\"fallback\", fallback_rpaths);\n+    log_rpaths(\"relative\", rel_rpaths.as_slice());\n+    log_rpaths(\"absolute\", abs_rpaths.as_slice());\n+    log_rpaths(\"fallback\", fallback_rpaths.as_slice());\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(abs_rpaths);\n-    rpaths.push_all(fallback_rpaths);\n+    rpaths.push_all(abs_rpaths.as_slice());\n+    rpaths.push_all(fallback_rpaths.as_slice());\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths);\n+    let rpaths = minimize_rpaths(rpaths.as_slice());\n     return rpaths;\n }\n "}, {"sha": "c2a1a5598d5b08267298c7947fcb2fe5fb6a23d3", "filename": "src/librustc/back/target_strs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fback%2Ftarget_strs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Ftarget_strs.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -10,6 +10,8 @@\n \n #[allow(non_camel_case_types)];\n \n+use std::vec_ng::Vec;\n+\n pub struct t {\n     module_asm: ~str,\n     meta_sect_name: ~str,"}, {"sha": "2a92ef496c7be2c1a4cb2c44889f9c6eb621a191", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -11,8 +11,8 @@\n \n use back::link;\n use back::{arm, x86, x86_64, mips};\n-use driver::session::{Aggressive, CrateTypeExecutable, FullDebugInfo, LimitedDebugInfo,\n-                      NoDebugInfo};\n+use driver::session::{Aggressive, CrateTypeExecutable, CrateType,\n+                      FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n use driver::session::{Session, Session_, No, Less, Default};\n use driver::session;\n use front;\n@@ -36,7 +36,6 @@ use std::io;\n use std::io::fs;\n use std::io::MemReader;\n use std::os;\n-use std::vec;\n use std::vec_ng::Vec;\n use std::vec_ng;\n use collections::HashMap;\n@@ -434,7 +433,7 @@ pub fn phase_5_run_llvm_passes(sess: Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             link::write::run_passes(sess,\n                                     trans,\n-                                    sess.opts.output_types,\n+                                    sess.opts.output_types.as_slice(),\n                                     outputs));\n     }\n }\n@@ -767,18 +766,21 @@ pub fn host_triple() -> ~str {\n \n pub fn build_session_options(matches: &getopts::Matches)\n                              -> @session::Options {\n-    let crate_types = matches.opt_strs(\"crate-type\").flat_map(|s| {\n-        s.split(',').map(|part| {\n-            match part {\n+    let mut crate_types: Vec<CrateType> = Vec::new();\n+    let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n+    for unparsed_crate_type in unparsed_crate_types.iter() {\n+        for part in unparsed_crate_type.split(',') {\n+            let new_part = match part {\n                 \"lib\"       => session::default_lib_output(),\n                 \"rlib\"      => session::CrateTypeRlib,\n                 \"staticlib\" => session::CrateTypeStaticlib,\n                 \"dylib\"     => session::CrateTypeDylib,\n                 \"bin\"       => session::CrateTypeExecutable,\n                 _ => early_error(format!(\"unknown crate type: `{}`\", part))\n-            }\n-        }).collect()\n-    });\n+            };\n+            crate_types.push(new_part)\n+        }\n+    }\n \n     let parse_only = matches.opt_present(\"parse-only\");\n     let no_trans = matches.opt_present(\"no-trans\");\n@@ -793,8 +795,10 @@ pub fn build_session_options(matches: &getopts::Matches)\n \n         let level_short = level_name.slice_chars(0, 1);\n         let level_short = level_short.to_ascii().to_upper().into_str();\n-        let flags = vec_ng::append(matches.opt_strs(level_short),\n-                                matches.opt_strs(level_name));\n+        let flags = vec_ng::append(matches.opt_strs(level_short)\n+                                          .move_iter()\n+                                          .collect(),\n+                                   matches.opt_strs(level_name));\n         for lint_name in flags.iter() {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n             match lint_dict.find_equiv(&lint_name) {\n@@ -828,23 +832,24 @@ pub fn build_session_options(matches: &getopts::Matches)\n         unsafe { llvm::LLVMSetDebug(1); }\n     }\n \n-    let mut output_types = if parse_only || no_trans {\n-        Vec::new()\n-    } else {\n-        matches.opt_strs(\"emit\").flat_map(|s| {\n-            s.split(',').map(|part| {\n-                match part.as_slice() {\n+    let mut output_types = Vec::new();\n+    if !parse_only && !no_trans {\n+        let unparsed_output_types = matches.opt_strs(\"emit\");\n+        for unparsed_output_type in unparsed_output_types.iter() {\n+            for part in unparsed_output_type.split(',') {\n+                let output_type = match part.as_slice() {\n                     \"asm\"  => link::OutputTypeAssembly,\n                     \"ir\"   => link::OutputTypeLlvmAssembly,\n                     \"bc\"   => link::OutputTypeBitcode,\n                     \"obj\"  => link::OutputTypeObject,\n                     \"link\" => link::OutputTypeExe,\n                     _ => early_error(format!(\"unknown emission type: `{}`\", part))\n-                }\n-            }).collect()\n-        })\n+                };\n+                output_types.push(output_type)\n+            }\n+        }\n     };\n-    output_types.sort();\n+    output_types.as_mut_slice().sort();\n     output_types.dedup();\n     if output_types.len() == 0 {\n         output_types.push(link::OutputTypeExe);\n@@ -890,7 +895,7 @@ pub fn build_session_options(matches: &getopts::Matches)\n         Path::new(s.as_slice())\n     }).move_iter().collect();\n \n-    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n+    let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\").move_iter().collect());\n     let test = matches.opt_present(\"test\");\n     let write_dependency_info = (matches.opt_present(\"dep-info\"),\n                                  matches.opt_str(\"dep-info\").map(|p| Path::new(p)));\n@@ -1187,7 +1192,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts([~\"--test\"], optgroups()) {\n+            &match getopts([~\"--test\"], optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => fail!(\"test_switch_implies_cfg_test: {}\", f.to_err_msg())\n             };\n@@ -1202,7 +1207,8 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n-            &match getopts([~\"--test\", ~\"--cfg=test\"], optgroups()) {\n+            &match getopts([~\"--test\", ~\"--cfg=test\"],\n+                           optgroups().as_slice()) {\n               Ok(m) => m,\n               Err(f) => {\n                 fail!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\","}, {"sha": "4845060dd12a39b0c59fd12badc2ae3a3333c600", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -320,19 +320,9 @@ pub fn basic_options() -> @Options {\n         crate_types: Vec::new(),\n         gc: false,\n         optimize: No,\n-<<<<<<< HEAD\n         debuginfo: NoDebugInfo,\n-        lint_opts: ~[],\n-        output_types: ~[],\n-||||||| merged common ancestors\n-        debuginfo: false,\n-        lint_opts: ~[],\n-        output_types: ~[],\n-=======\n-        debuginfo: false,\n         lint_opts: Vec::new(),\n         output_types: Vec::new(),\n->>>>>>> librustc: Automatically change uses of `~[T]` to `Vec<T>` in rustc.\n         addl_lib_search_paths: @RefCell::new(HashSet::new()),\n         maybe_sysroot: None,\n         target_triple: host_triple(),\n@@ -403,7 +393,8 @@ macro_rules! cgoptions(\n             }\n         }\n \n-        fn parse_list(slot: &mut Vec<~str> , v: Option<&str>) -> bool {\n+        fn parse_list(slot: &mut ::std::vec_ng::Vec<~str>, v: Option<&str>)\n+                      -> bool {\n             match v {\n                 Some(s) => {\n                     for s in s.words() {\n@@ -489,7 +480,7 @@ pub fn collect_crate_types(session: &Session,\n     // If we're generating a test executable, then ignore all other output\n     // styles at all other locations\n     if session.opts.test {\n-        return Vec<CrateTypeExecutable> ;\n+        return vec!(CrateTypeExecutable)\n     }\n     let mut base = session.opts.crate_types.clone();\n     let mut iter = attrs.iter().filter_map(|a| {\n@@ -525,7 +516,7 @@ pub fn collect_crate_types(session: &Session,\n     if base.len() == 0 {\n         base.push(CrateTypeExecutable);\n     }\n-    base.sort();\n+    base.as_mut_slice().sort();\n     base.dedup();\n     return base;\n }"}, {"sha": "514d2a4a6e1183381babbef8674c15154886681e", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n+use std::vec_ng::Vec;\n use syntax::fold::Folder;\n use syntax::{ast, fold, attr};\n use syntax::codemap;"}, {"sha": "6246000074db8d2656703bc4acebc66f32b9cef7", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -31,6 +31,7 @@ use syntax::parse::token;\n use driver::session::Session;\n \n use std::cell::Cell;\n+use std::vec_ng::Vec;\n \n /// This is a list of all known features since the beginning of time. This list\n /// can never shrink, it may only be expanded (in order to prevent old programs"}, {"sha": "703722ccb1cdbf8aec93bbca5451ae01e0feb355", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -93,7 +93,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n             path.get().push(i.ident);\n         }\n         debug!(\"current path: {}\",\n-               ast_util::path_name_i(self.cx.path.get()));\n+               ast_util::path_name_i(self.cx.path.get().as_slice()));\n \n         if is_test_fn(&self.cx, i) || is_bench_fn(i) {\n             match i.node {\n@@ -432,11 +432,12 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n     let span = test.span;\n     let path = test.path.clone();\n \n-    debug!(\"encoding {}\", ast_util::path_name_i(path));\n+    debug!(\"encoding {}\", ast_util::path_name_i(path.as_slice()));\n \n     let name_lit: ast::Lit =\n         nospan(ast::LitStr(token::intern_and_get_ident(\n-                    ast_util::path_name_i(path)), ast::CookedStr));\n+                    ast_util::path_name_i(path.as_slice())),\n+                    ast::CookedStr));\n \n     let name_expr = @ast::Expr {\n           id: ast::DUMMY_NODE_ID,"}, {"sha": "af0acee07fd217db8adeceaa6c9dd996f53c62de", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -53,8 +53,8 @@ use std::io;\n use std::os;\n use std::str;\n use std::task;\n-use std::vec;\n use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::diagnostic::Emitter;\n use syntax::diagnostic;\n@@ -149,7 +149,7 @@ Additional help:\n     -C help             Print codegen options\n     -W help             Print 'lint' options and default settings\n     -Z help             Print internal options for debugging rustc\\n\",\n-              getopts::usage(message, d::optgroups()));\n+              getopts::usage(message, d::optgroups().as_slice()));\n }\n \n pub fn describe_warnings() {\n@@ -165,7 +165,7 @@ Available lint options:\n     let mut lint_dict = lint_dict.move_iter()\n                                  .map(|(k, v)| (v, k))\n                                  .collect::<Vec<(lint::LintSpec, &'static str)> >();\n-    lint_dict.sort();\n+    lint_dict.as_mut_slice().sort();\n \n     let mut max_key = 0;\n     for &(_, name) in lint_dict.iter() {\n@@ -224,7 +224,7 @@ pub fn run_compiler(args: &[~str]) {\n     if args.is_empty() { usage(binary); return; }\n \n     let matches =\n-        &match getopts::getopts(args, d::optgroups()) {\n+        &match getopts::getopts(args, d::optgroups().as_slice()) {\n           Ok(m) => m,\n           Err(f) => {\n             d::early_error(f.to_err_msg());\n@@ -236,8 +236,10 @@ pub fn run_compiler(args: &[~str]) {\n         return;\n     }\n \n-    let lint_flags = vec_ng::append(matches.opt_strs(\"W\"),\n-                                 matches.opt_strs(\"warn\"));\n+    let lint_flags = vec_ng::append(matches.opt_strs(\"W\")\n+                                           .move_iter()\n+                                           .collect(),\n+                                    matches.opt_strs(\"warn\"));\n     if lint_flags.iter().any(|x| x == &~\"help\") {\n         describe_warnings();\n         return;\n@@ -312,8 +314,8 @@ pub fn run_compiler(args: &[~str]) {\n     if crate_id || crate_name || crate_file_name {\n         let attrs = parse_crate_attrs(sess, &input);\n         let t_outputs = d::build_output_filenames(&input, &odir, &ofile,\n-                                                  attrs, sess);\n-        let id = link::find_crate_id(attrs, &t_outputs);\n+                                                  attrs.as_slice(), sess);\n+        let id = link::find_crate_id(attrs.as_slice(), &t_outputs);\n \n         if crate_id {\n             println!(\"{}\", id.to_str());\n@@ -322,7 +324,8 @@ pub fn run_compiler(args: &[~str]) {\n             println!(\"{}\", id.name);\n         }\n         if crate_file_name {\n-            let crate_types = session::collect_crate_types(&sess, attrs);\n+            let crate_types = session::collect_crate_types(&sess,\n+                                                           attrs.as_slice());\n             for &style in crate_types.iter() {\n                 let fname = link::filename_for_input(&sess, style, &id,\n                                                      &t_outputs.with_extension(\"\"));"}, {"sha": "7769d53865a6d8d7a23c44e1617866d9c06f8e55", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -58,8 +58,10 @@ pub fn read_crates(sess: Session,\n         visit::walk_crate(&mut v, krate, ());\n     }\n     let crate_cache = e.crate_cache.borrow();\n-    dump_crates(*crate_cache.get());\n-    warn_if_multiple_versions(&mut e, sess.diagnostic(), *crate_cache.get());\n+    dump_crates(crate_cache.get().as_slice());\n+    warn_if_multiple_versions(&mut e,\n+                              sess.diagnostic(),\n+                              crate_cache.get().as_slice());\n }\n \n struct ReadCrateVisitor<'a> {\n@@ -121,7 +123,7 @@ fn warn_if_multiple_versions(e: &mut Env,\n struct Env {\n     sess: Session,\n     os: loader::Os,\n-    crate_cache: @RefCell<vec!(cache_entry)>,\n+    crate_cache: @RefCell<Vec<cache_entry>>,\n     next_crate_num: ast::CrateNum,\n     intr: @IdentInterner\n }"}, {"sha": "360ab4eefe0cecf4b77df9b93cf5f6ba34f7d49f", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -18,9 +18,10 @@ use metadata::decoder;\n use middle::ty;\n use middle::typeck;\n \n-use std::vec;\n use reader = serialize::ebml::reader;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::diagnostic::expect;\n@@ -93,7 +94,8 @@ pub fn get_item_path(tcx: ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem> {\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    vec_ng::append(vec!(ast_map::PathMod(token::intern(cdata.name))), path)\n+    vec_ng::append(vec!(ast_map::PathMod(token::intern(cdata.name))),\n+                   path.as_slice())\n }\n \n pub enum found_ast {"}, {"sha": "1d683ec60da0d6c164c8b1e4115204934e4c3e2f", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -18,6 +18,7 @@ use metadata::decoder;\n use metadata::loader;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n use extra::c_vec::CVec;\n use syntax::ast;"}, {"sha": "caf4670b40a9f999e6487b24016c437444a495c2", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -33,7 +33,7 @@ use std::io;\n use std::io::extensions::u64_from_be_bytes;\n use std::option;\n use std::rc::Rc;\n-use std::vec;\n+use std::vec_ng::Vec;\n use serialize::ebml::reader;\n use serialize::ebml;\n use serialize::Decodable;\n@@ -304,7 +304,7 @@ fn item_path(item_doc: ebml::Doc) -> Vec<ast_map::PathElem> {\n     let len_doc = reader::get_doc(path_doc, tag_path_len);\n     let len = reader::doc_as_u32(len_doc) as uint;\n \n-    let mut result = vec::with_capacity(len);\n+    let mut result = Vec::with_capacity(len);\n     reader::docs(path_doc, |tag, elt_doc| {\n         if tag == tag_path_elem_mod {\n             let s = elt_doc.as_str_slice();\n@@ -682,7 +682,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt, id: ast::NodeId,\n                           -> csearch::found_ast {\n     debug!(\"Looking up item: {}\", id);\n     let item_doc = lookup_item(id, cdata.data());\n-    let path = item_path(item_doc).init().to_owned();\n+    let path = Vec::from_slice(item_path(item_doc).init());\n     match decode_inlined_item(cdata, tcx, path, item_doc) {\n         Ok(ref ii) => csearch::found(*ii),\n         Err(path) => {\n@@ -1072,7 +1072,7 @@ fn get_attributes(md: ebml::Doc) -> Vec<ast::Attribute> {\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n             assert_eq!(meta_items.len(), 1u);\n-            let meta_item = meta_items[0];\n+            let meta_item = *meta_items.get(0);\n             attrs.push(\n                 codemap::Spanned {\n                     node: ast::Attribute_ {"}, {"sha": "91c0d093653f72f16ce55aab509f59c0e1baf5bc", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -32,6 +32,7 @@ use std::hash;\n use std::hash::Hash;\n use std::io::MemWriter;\n use std::str;\n+use std::vec_ng::Vec;\n use collections::HashMap;\n use syntax::abi::AbiSet;\n use syntax::ast::*;\n@@ -367,9 +368,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 encode_index(ebml_w, bkts, write_i64);\n             }\n         }\n-        if vi[i].disr_val != disr_val {\n-            encode_disr_val(ecx, ebml_w, vi[i].disr_val);\n-            disr_val = vi[i].disr_val;\n+        if vi.get(i).disr_val != disr_val {\n+            encode_disr_val(ecx, ebml_w, vi.get(i).disr_val);\n+            disr_val = vi.get(i).disr_val;\n         }\n         encode_bounds_and_type(ebml_w, ecx,\n                                &lookup_item_type(ecx.tcx, def_id));\n@@ -1390,7 +1391,7 @@ fn create_index<T:Clone + Hash + 'static>(\n     }\n     for elt in index.iter() {\n         let h = hash::hash(&elt.val) as uint;\n-        let mut bucket = buckets[h % 256].borrow_mut();\n+        let mut bucket = buckets.get_mut(h % 256).borrow_mut();\n         bucket.get().push((*elt).clone());\n     }\n \n@@ -1770,7 +1771,7 @@ pub static metadata_encoding_version : &'static [u8] =\n pub fn encode_metadata(parms: EncodeParams, krate: &Crate) -> Vec<u8> {\n     let mut wr = MemWriter::new();\n     encode_metadata_inner(&mut wr, parms, krate);\n-    wr.unwrap()\n+    wr.unwrap().move_iter().collect()\n }\n \n fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate) {\n@@ -1822,7 +1823,7 @@ fn encode_metadata_inner(wr: &mut MemWriter, parms: EncodeParams, krate: &Crate)\n \n     let mut i = ebml_w.writer.tell().unwrap();\n     let crate_attrs = synthesize_crate_attrs(&ecx, krate);\n-    encode_attributes(&mut ebml_w, crate_attrs);\n+    encode_attributes(&mut ebml_w, crate_attrs.as_slice());\n     ecx.stats.attr_bytes.set(ebml_w.writer.tell().unwrap() - i);\n \n     i = ebml_w.writer.tell().unwrap();"}, {"sha": "9f6b78354e2e67c7855d543073a5055ea7dba40f", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -14,6 +14,7 @@ use std::cell::RefCell;\n use std::option;\n use std::os;\n use std::io::fs;\n+use std::vec_ng::Vec;\n use collections::HashSet;\n \n pub enum FileMatch { FileMatches, FileDoesntMatch }"}, {"sha": "7628c90d95df1658c10b580816494842ae7a3d05", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -31,6 +31,7 @@ use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::str;\n use std::vec;\n+use std::vec_ng::Vec;\n \n use collections::{HashMap, HashSet};\n use flate;\n@@ -205,7 +206,7 @@ impl<'a> Context<'a> {\n         // libraries or not.\n         match libraries.len() {\n             0 => None,\n-            1 => Some(libraries[0]),\n+            1 => Some(libraries.move_iter().next().unwrap()),\n             _ => {\n                 self.sess.span_err(self.span,\n                     format!(\"multiple matching crates for `{}`\","}, {"sha": "17e334d05fbab1ea510e31dd7cd0f22089171fbd", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -20,6 +20,7 @@ use middle::ty;\n \n use std::str;\n use std::uint;\n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::abi;\n use syntax::ast;"}, {"sha": "be3180596e02be89920c8caeec770d7ace9547b2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -19,6 +19,7 @@ use std::io;\n use std::io::MemWriter;\n use std::str;\n use std::fmt;\n+use std::vec_ng::Vec;\n \n use middle::ty::param_ty;\n use middle::ty;"}, {"sha": "5959f5a9d02dd632f1541035d34afa77266665a7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -654,15 +654,15 @@ pub fn encode_vtable_res(ecx: &e::EncodeContext,\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(*dr, |ebml_w, param_tables| {\n+    ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n         encode_vtable_param_res(ecx, ebml_w, *param_tables);\n     })\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n                      ebml_w: &mut writer::Encoder,\n                      param_tables: typeck::vtable_param_res) {\n-    ebml_w.emit_from_vec(*param_tables, |ebml_w, vtable_origin| {\n+    ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n         encode_vtable_origin(ecx, ebml_w, vtable_origin)\n     })\n }\n@@ -679,7 +679,7 @@ pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n                     ebml_w.emit_def_id(def_id)\n                 });\n                 ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    ebml_w.emit_tys(ecx, *tys);\n+                    ebml_w.emit_tys(ecx, tys.as_slice());\n                 });\n                 ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n                     encode_vtable_res(ecx, ebml_w, vtable_res);\n@@ -718,13 +718,17 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                       -> typeck::vtable_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_param_res(tcx, cdata))\n+             .move_iter()\n+             .collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n                              tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n         @self.read_to_vec(|this|\n                           this.read_vtable_origin(tcx, cdata))\n+             .move_iter()\n+             .collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n@@ -985,7 +989,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_node_type_subst, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_tys(ecx, **tys)\n+                    ebml_w.emit_tys(ecx, tys.as_slice())\n                 })\n             })\n         }\n@@ -998,7 +1002,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_freevars, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(**fv, |ebml_w, fv_entry| {\n+                    ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n                         encode_freevar_entry(ebml_w, *fv_entry)\n                     })\n                 })\n@@ -1077,7 +1081,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.tag(c::tag_table_capture_map, |ebml_w| {\n                 ebml_w.id(id);\n                 ebml_w.tag(c::tag_table_val, |ebml_w| {\n-                    ebml_w.emit_from_vec(*cap_vars.borrow(), |ebml_w, cap_var| {\n+                    ebml_w.emit_from_vec(cap_vars.borrow().as_slice(),\n+                                         |ebml_w, cap_var| {\n                         cap_var.encode(ebml_w);\n                     })\n                 })\n@@ -1139,6 +1144,8 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                       tcx: ty::ctxt,\n                       cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n         self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n+            .move_iter()\n+            .collect()\n     }\n \n     fn read_ty(&mut self, xcx: @ExtendedDecodeContext) -> ty::t {\n@@ -1170,7 +1177,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys(&mut self, xcx: @ExtendedDecodeContext) -> Vec<ty::t> {\n-        self.read_to_vec(|this| this.read_ty(xcx) )\n+        self.read_to_vec(|this| this.read_ty(xcx)).move_iter().collect()\n     }\n \n     fn read_type_param_def(&mut self, xcx: @ExtendedDecodeContext)\n@@ -1197,7 +1204,9 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                                                        0,\n                                                        |this| {\n                                     Rc::new(this.read_to_vec(|this|\n-                                                             this.read_type_param_def(xcx)))\n+                                                             this.read_type_param_def(xcx))\n+                                                .move_iter()\n+                                                .collect())\n                             }),\n                             region_param_defs:\n                                 this.read_struct_field(\"region_param_defs\",\n@@ -1357,7 +1366,7 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     c::tag_table_freevars => {\n                         let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n                             @val_dsr.read_freevar_entry(xcx)\n-                        });\n+                        }).move_iter().collect();\n                         let mut freevars = dcx.tcx.freevars.borrow_mut();\n                         freevars.get().insert(id, fv_info);\n                     }\n@@ -1394,7 +1403,9 @@ fn decode_side_tables(xcx: @ExtendedDecodeContext,\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n-                                val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx));\n+                                val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx))\n+                                       .move_iter()\n+                                       .collect();\n                         let mut capture_map = dcx.maps\n                                                  .capture_map\n                                                  .borrow_mut();"}, {"sha": "53a363b44f88d403394f45c34b62cf2cef0e2ba9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -22,6 +22,7 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;"}, {"sha": "d6666eb6293102a3149fa5363d680a40cc32a125", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -27,6 +27,7 @@ use util::common::indenter;\n use util::ppaux::{Repr};\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;"}, {"sha": "aa296bf0a622b9b5e8e68c6a6cf4ed6423eac05e", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -12,7 +12,8 @@\n  * Computes the restrictions that result from a borrow.\n  */\n \n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use middle::borrowck::*;\n use mc = middle::mem_categorization;\n use middle::ty;\n@@ -173,9 +174,11 @@ impl<'a> RestrictionsContext<'a> {\n             Safe => Safe,\n             SafeIf(base_lp, base_vec) => {\n                 let lp = @LpExtend(base_lp, mc, elem);\n-                SafeIf(lp, vec::append_one(base_vec,\n-                                           Restriction {loan_path: lp,\n-                                                        set: restrictions}))\n+                SafeIf(lp, vec_ng::append_one(base_vec,\n+                                              Restriction {\n+                                                  loan_path: lp,\n+                                                  set: restrictions\n+                                              }))\n             }\n         }\n     }"}, {"sha": "9767b50ae96031fb7fbba7164183da504593253e", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -24,6 +24,7 @@ use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::ops::{BitOr, BitAnd};\n use std::result::{Result};\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -146,7 +147,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                                                       body);\n \n     check_loans::check_loans(this, &loan_dfcx, flowed_moves,\n-                             *all_loans.get(), body);\n+                             all_loans.get().as_slice(), body);\n \n     visit::walk_fn(this, fk, decl, body, sp, id, ());\n }"}, {"sha": "e1434a8ac4e9758a046f7ca1f1336055f37a1dfa", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -17,6 +17,7 @@ comments in the section \"Moves and initialization\" and in `doc.rs`.\n \n use std::cell::RefCell;\n use std::uint;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use middle::borrowck::*;\n use middle::dataflow::DataFlowContext;\n@@ -184,47 +185,47 @@ impl MoveData {\n \n     fn path_loan_path(&self, index: MovePathIndex) -> @LoanPath {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].loan_path\n+        paths.get().get(index.get()).loan_path\n     }\n \n     fn path_parent(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].parent\n+        paths.get().get(index.get()).parent\n     }\n \n     fn path_first_move(&self, index: MovePathIndex) -> MoveIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].first_move\n+        paths.get().get(index.get()).first_move\n     }\n \n     fn path_first_child(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].first_child\n+        paths.get().get(index.get()).first_child\n     }\n \n     fn path_next_sibling(&self, index: MovePathIndex) -> MovePathIndex {\n         let paths = self.paths.borrow();\n-        paths.get()[index.get()].next_sibling\n+        paths.get().get(index.get()).next_sibling\n     }\n \n     fn set_path_first_move(&self,\n                            index: MovePathIndex,\n                            first_move: MoveIndex) {\n         let mut paths = self.paths.borrow_mut();\n-        paths.get()[index.get()].first_move = first_move\n+        paths.get().get_mut(index.get()).first_move = first_move\n     }\n \n     fn set_path_first_child(&self,\n                             index: MovePathIndex,\n                             first_child: MovePathIndex) {\n         let mut paths = self.paths.borrow_mut();\n-        paths.get()[index.get()].first_child = first_child\n+        paths.get().get_mut(index.get()).first_child = first_child\n     }\n \n     fn move_next_move(&self, index: MoveIndex) -> MoveIndex {\n         //! Type safe indexing operator\n         let moves = self.moves.borrow();\n-        moves.get()[index.get()].next_move\n+        moves.get().get(index.get()).next_move\n     }\n \n     fn is_var_path(&self, index: MovePathIndex) -> bool {\n@@ -605,7 +606,7 @@ impl FlowedMoveData {\n \n         self.dfcx_moves.each_gen_bit_frozen(id, |index| {\n             let moves = self.move_data.moves.borrow();\n-            let move = &moves.get()[index];\n+            let move = moves.get().get(index);\n             let moved_path = move.path;\n             f(move, self.move_data.path_loan_path(moved_path))\n         })\n@@ -644,7 +645,7 @@ impl FlowedMoveData {\n \n         self.dfcx_moves.each_bit_on_entry_frozen(id, |index| {\n             let moves = self.move_data.moves.borrow();\n-            let move = &moves.get()[index];\n+            let move = moves.get().get(index);\n             let moved_path = move.path;\n             if base_indices.iter().any(|x| x == &moved_path) {\n                 // Scenario 1 or 2: `loan_path` or some base path of\n@@ -702,7 +703,7 @@ impl FlowedMoveData {\n \n         self.dfcx_assign.each_bit_on_entry_frozen(id, |index| {\n             let var_assignments = self.move_data.var_assignments.borrow();\n-            let assignment = &var_assignments.get()[index];\n+            let assignment = var_assignments.get().get(index);\n             if assignment.path == loan_path_index && !f(assignment) {\n                 false\n             } else {"}, {"sha": "ec1ddd99cc6bff8cb8f671ab9ae2f81bc5917c57", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -12,6 +12,7 @@ use middle::cfg::*;\n use middle::graph;\n use middle::typeck;\n use middle::ty;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::opt_vec;\n@@ -328,7 +329,7 @@ impl CFGBuilder {\n \n             ast::ExprRet(v) => {\n                 let v_exit = self.opt_expr(v, pred);\n-                let loop_scope = self.loop_scopes[0];\n+                let loop_scope = *self.loop_scopes.get(0);\n                 self.add_exiting_edge(expr, v_exit,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_node(expr.id, [])\n@@ -377,7 +378,7 @@ impl CFGBuilder {\n                 let base_exit = self.opt_expr(base, pred);\n                 let field_exprs: Vec<@ast::Expr> =\n                     fields.iter().map(|f| f.expr).collect();\n-                self.straightline(expr, base_exit, field_exprs)\n+                self.straightline(expr, base_exit, field_exprs.as_slice())\n             }\n \n             ast::ExprRepeat(elem, count, _) => {"}, {"sha": "680caf101bf72e5ec1a980294fcdf0f52dbb541e", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -15,6 +15,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux;\n \n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::{ast_util, ast_map};\n use syntax::visit::Visitor;"}, {"sha": "fddad9214e8f086676fc1163a069941c91c30ce1", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 46, "deletions": 29, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -21,7 +21,8 @@ use util::ppaux::ty_to_str;\n \n use std::cmp;\n use std::iter;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast::*;\n use syntax::ast_util::{unguarded_pat, walk_pat};\n use syntax::codemap::{DUMMY_SP, Span};\n@@ -152,7 +153,7 @@ fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n             });\n \n             let v = vec!(*pat);\n-            match is_useful(cx, &seen, v) {\n+            match is_useful(cx, &seen, v.as_slice()) {\n               not_useful => {\n                 cx.tcx.sess.span_err(pat.span, \"unreachable pattern\");\n               }\n@@ -250,10 +251,14 @@ enum ctor {\n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n-    if m.len() == 0u { return useful_; }\n-    if m[0].len() == 0u { return not_useful; }\n-    let real_pat = match m.iter().find(|r| r[0].id != 0) {\n-      Some(r) => r[0], None => v[0]\n+    if m.len() == 0u {\n+        return useful_;\n+    }\n+    if m.get(0).len() == 0u {\n+        return not_useful\n+    }\n+    let real_pat = match m.iter().find(|r| r.get(0).id != 0) {\n+      Some(r) => *r.get(0), None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n                   else { ty::node_id_to_type(cx.tcx, real_pat.id) };\n@@ -290,7 +295,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n               }\n               ty::ty_unboxed_vec(..) | ty::ty_vec(..) => {\n                 let max_len = m.rev_iter().fold(0, |max_len, r| {\n-                  match r[0].node {\n+                  match r.get(0).node {\n                     PatVec(ref before, _, ref after) => {\n                       cmp::max(before.len() + after.len(), max_len)\n                     }\n@@ -313,7 +318,9 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n           }\n           Some(ref ctor) => {\n             match is_useful(cx,\n-                            &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n+                            &m.iter().filter_map(|r| {\n+                                default(cx, r.as_slice())\n+                            }).collect::<matrix>(),\n                             v.tail()) {\n               useful_ => useful(left_ty, (*ctor).clone()),\n               ref u => (*u).clone(),\n@@ -334,10 +341,12 @@ fn is_useful_specialized(cx: &MatchCheckCtxt,\n                              ctor: ctor,\n                              arity: uint,\n                              lty: ty::t)\n-                          -> useful {\n-    let ms = m.iter().filter_map(|r| specialize(cx, *r, &ctor, arity, lty)).collect::<matrix>();\n+                             -> useful {\n+    let ms = m.iter().filter_map(|r| {\n+        specialize(cx, r.as_slice(), &ctor, arity, lty)\n+    }).collect::<matrix>();\n     let could_be_useful = is_useful(\n-        cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap());\n+        cx, &ms, specialize(cx, v, &ctor, arity, lty).unwrap().as_slice());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n       ref u => (*u).clone(),\n@@ -408,14 +417,14 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(..) | ty::ty_tup(_) |\n       ty::ty_struct(..) => {\n         for r in m.iter() {\n-            if !is_wild(cx, r[0]) { return None; }\n+            if !is_wild(cx, *r.get(0)) { return None; }\n         }\n         return Some(single);\n       }\n       ty::ty_enum(eid, _) => {\n         let mut found = Vec::new();\n         for r in m.iter() {\n-            let r = pat_ctor_id(cx, r[0]);\n+            let r = pat_ctor_id(cx, *r.get(0));\n             for id in r.iter() {\n                 if !found.contains(id) {\n                     found.push((*id).clone());\n@@ -437,7 +446,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut true_found = false;\n         let mut false_found = false;\n         for r in m.iter() {\n-            match pat_ctor_id(cx, r[0]) {\n+            match pat_ctor_id(cx, *r.get(0)) {\n               None => (),\n               Some(val(const_bool(true))) => true_found = true,\n               Some(val(const_bool(false))) => false_found = true,\n@@ -452,7 +461,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n         let mut missing = true;\n         let mut wrong = false;\n         for r in m.iter() {\n-          match r[0].node {\n+          match r.get(0).node {\n             PatVec(ref before, ref slice, ref after) => {\n               let count = before.len() + after.len();\n               if (count < n && slice.is_none()) || count > n {\n@@ -475,7 +484,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n \n         // Find the lengths and slices of all vector patterns.\n         let mut vec_pat_lens = m.iter().filter_map(|r| {\n-            match r[0].node {\n+            match r.get(0).node {\n                 PatVec(ref before, ref slice, ref after) => {\n                     Some((before.len() + after.len(), slice.is_some()))\n                 }\n@@ -566,10 +575,11 @@ fn specialize(cx: &MatchCheckCtxt,\n         Pat{id: pat_id, node: n, span: pat_span} =>\n             match n {\n             PatWild => {\n-                Some(vec_ng::append(vec::from_elem(arity, wild()), r.tail()))\n+                Some(vec_ng::append(Vec::from_elem(arity, wild()), r.tail()))\n             }\n             PatWildMulti => {\n-                Some(vec_ng::append(vec::from_elem(arity, wild_multi()), r.tail()))\n+                Some(vec_ng::append(Vec::from_elem(arity, wild_multi()),\n+                                    r.tail()))\n             }\n             PatIdent(_, _, _) => {\n                 let opt_def = {\n@@ -579,7 +589,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 match opt_def {\n                     Some(DefVariant(_, id, _)) => {\n                         if variant(id) == *ctor_id {\n-                            Some(r.tail().to_owned())\n+                            Some(Vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n@@ -617,15 +627,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(r.tail().to_owned())\n+                            Some(Vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n                     }\n                     _ => {\n                         Some(\n                             vec_ng::append(\n-                                vec::from_elem(arity, wild()),\n+                                Vec::from_elem(arity, wild()),\n                                 r.tail()\n                             )\n                         )\n@@ -668,15 +678,15 @@ fn specialize(cx: &MatchCheckCtxt,\n                             _ => fail!(\"type error\")\n                         };\n                         if match_ {\n-                            Some(r.tail().to_owned())\n+                            Some(Vec::from_slice(r.tail()))\n                         } else {\n                             None\n                         }\n                     }\n                     DefVariant(_, id, _) if variant(id) == *ctor_id => {\n                         let args = match args {\n                             Some(args) => args.iter().map(|x| *x).collect(),\n-                            None => vec::from_elem(arity, wild())\n+                            None => Vec::from_elem(arity, wild())\n                         };\n                         Some(vec_ng::append(args, r.tail()))\n                     }\n@@ -689,7 +699,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                             Some(args) => {\n                                 new_args = args.iter().map(|x| *x).collect()\n                             }\n-                            None => new_args = vec::from_elem(arity, wild())\n+                            None => new_args = Vec::from_elem(arity, wild())\n                         }\n                         Some(vec_ng::append(new_args, r.tail()))\n                     }\n@@ -781,13 +791,17 @@ fn specialize(cx: &MatchCheckCtxt,\n                     single => true,\n                     _ => fail!(\"type error\")\n                 };\n-                if match_ { Some(r.tail().to_owned()) } else { None }\n+                if match_ {\n+                    Some(Vec::from_slice(r.tail()))\n+                } else {\n+                    None\n+                }\n             }\n             PatRange(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n                     val(ref v) => ((*v).clone(), (*v).clone()),\n                     range(ref lo, ref hi) => ((*lo).clone(), (*hi).clone()),\n-                    single => return Some(r.tail().to_owned()),\n+                    single => return Some(Vec::from_slice(r.tail())),\n                     _ => fail!(\"type error\")\n                 };\n                 let v_lo = eval_const_expr(cx.tcx, lo);\n@@ -797,7 +811,7 @@ fn specialize(cx: &MatchCheckCtxt,\n                 let m2 = compare_const_vals(&c_hi, &v_hi);\n                 match (m1, m2) {\n                     (Some(val1), Some(val2)) if val1 >= 0 && val2 <= 0 => {\n-                        Some(r.tail().to_owned())\n+                        Some(Vec::from_slice(r.tail()))\n                     },\n                     (Some(_), Some(_)) => None,\n                     _ => {\n@@ -850,8 +864,11 @@ fn specialize(cx: &MatchCheckCtxt,\n }\n \n fn default(cx: &MatchCheckCtxt, r: &[@Pat]) -> Option<Vec<@Pat> > {\n-    if is_wild(cx, r[0]) { Some(r.tail().to_owned()) }\n-    else { None }\n+    if is_wild(cx, r[0]) {\n+        Some(Vec::from_slice(r.tail()))\n+    } else {\n+        None\n+    }\n }\n \n fn check_local(v: &mut CheckMatchVisitor,"}, {"sha": "aaa623bd7b2fd527597d4bb85f3a7baa47e70252", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -27,6 +27,7 @@ use syntax::{ast, ast_map, ast_util};\n use std::cell::RefCell;\n use collections::HashMap;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n \n //\n // This pass classifies expressions by their constant-ness."}, {"sha": "ba3fc34023d1828917b192a3dde7fef5970a95fc", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -20,6 +20,7 @@\n use std::io;\n use std::uint;\n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n@@ -79,7 +80,8 @@ struct PropagationContext<'a, O> {\n \n struct LoopScope<'a> {\n     loop_id: ast::NodeId,\n-    break_bits: Vec<uint> }\n+    break_bits: Vec<uint>\n+}\n \n impl<O:DataFlowOperator> pprust::PpAnn for DataFlowContext<O> {\n     fn pre(&self, node: pprust::AnnNode) -> io::IoResult<()> {\n@@ -467,12 +469,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 let mut body_bits = in_out.to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: in_out.to_owned()\n+                    break_bits: Vec::from_slice(in_out)\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n                 let new_loop_scope = loop_scopes.pop().unwrap();\n-                copy_bits(new_loop_scope.break_bits, in_out);\n+                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n             ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n@@ -491,14 +493,14 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n-                    break_bits: in_out.to_owned()\n+                    break_bits: Vec::from_slice(in_out)\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n \n                 let new_loop_scope = loop_scopes.pop().unwrap();\n                 assert_eq!(new_loop_scope.loop_id, expr.id);\n-                copy_bits(new_loop_scope.break_bits, in_out);\n+                copy_bits(new_loop_scope.break_bits.as_slice(), in_out);\n             }\n \n             ast::ExprMatch(discr, ref arms) => {\n@@ -689,7 +691,9 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n                      in_out: &mut [uint]) {\n         self.pop_scopes(from_expr, to_scope, in_out);\n         self.dfcx.apply_kill(from_expr.id, in_out);\n-        join_bits(&self.dfcx.oper, in_out, to_scope.break_bits);\n+        join_bits(&self.dfcx.oper,\n+                  in_out,\n+                  to_scope.break_bits.as_mut_slice());\n         debug!(\"break_from_to(from_expr={}, to_scope={}) final break_bits={}\",\n                from_expr.repr(self.tcx()),\n                to_scope.loop_id,\n@@ -767,10 +771,12 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n         }\n     }\n \n-    fn find_scope<'a>(&self,\n-                      expr: &ast::Expr,\n-                      label: Option<ast::Ident>,\n-                      loop_scopes: &'a mut Vec<LoopScope> ) -> &'a mut LoopScope {\n+    fn find_scope<'a,'b>(\n+                  &self,\n+                  expr: &ast::Expr,\n+                  label: Option<ast::Ident>,\n+                  loop_scopes: &'a mut Vec<LoopScope<'b>>)\n+                  -> &'a mut LoopScope<'b> {\n         let index = match label {\n             None => {\n                 let len = loop_scopes.len();\n@@ -800,7 +806,7 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             }\n         };\n \n-        &mut loop_scopes[index]\n+        loop_scopes.get_mut(index)\n     }\n \n     fn is_method_call(&self, expr: &ast::Expr) -> bool {"}, {"sha": "d226f2561b7bdae0d4e5dea031fa5f112f08e288", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -19,6 +19,7 @@ use middle::typeck;\n use util::nodemap::NodeSet;\n \n use collections::HashSet;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, def_id_of_def, is_local};"}, {"sha": "a4ff72d55f259f5cfa2ad1d9cdd0409bcb8992ba", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -11,6 +11,7 @@\n \n use driver::session;\n use driver::session::Session;\n+use std::vec_ng::Vec;\n use syntax::ast::{Crate, Name, NodeId, Item, ItemFn};\n use syntax::ast_map;\n use syntax::attr;"}, {"sha": "8b8807e46f5dd103caa9c585f4acbb0f1be108d2", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -17,6 +17,7 @@ use middle::resolve;\n use middle::ty;\n use util::nodemap::{NodeMap, NodeSet};\n \n+use std::vec_ng::Vec;\n use syntax::codemap::Span;\n use syntax::{ast, ast_util};\n use syntax::visit;"}, {"sha": "160a541bc34dd7da361e5d5dc8199b488cb15c97", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -35,7 +35,7 @@ be indexed by the direction (see the type `Direction`).\n */\n \n use std::uint;\n-use std::vec;\n+use std::vec_ng::Vec;\n \n pub struct Graph<N,E> {\n     priv nodes: Vec<Node<N>> ,\n@@ -77,27 +77,32 @@ impl EdgeIndex {\n \n impl<N,E> Graph<N,E> {\n     pub fn new() -> Graph<N,E> {\n-        Graph {nodes: Vec::new(), edges: Vec::new()}\n+        Graph {\n+            nodes: Vec::new(),\n+            edges: Vec::new(),\n+        }\n     }\n \n     pub fn with_capacity(num_nodes: uint,\n                          num_edges: uint) -> Graph<N,E> {\n-        Graph {nodes: vec::with_capacity(num_nodes),\n-               edges: vec::with_capacity(num_edges)}\n+        Graph {\n+            nodes: Vec::with_capacity(num_nodes),\n+            edges: Vec::with_capacity(num_edges),\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n     // Simple accessors\n \n     #[inline]\n     pub fn all_nodes<'a>(&'a self) -> &'a [Node<N>] {\n-        let nodes: &'a [Node<N>] = self.nodes;\n+        let nodes: &'a [Node<N>] = self.nodes.as_slice();\n         nodes\n     }\n \n     #[inline]\n     pub fn all_edges<'a>(&'a self) -> &'a [Edge<E>] {\n-        let edges: &'a [Edge<E>] = self.edges;\n+        let edges: &'a [Edge<E>] = self.edges.as_slice();\n         edges\n     }\n \n@@ -118,15 +123,15 @@ impl<N,E> Graph<N,E> {\n     }\n \n     pub fn mut_node_data<'a>(&'a mut self, idx: NodeIndex) -> &'a mut N {\n-        &mut self.nodes[idx.get()].data\n+        &mut self.nodes.get_mut(idx.get()).data\n     }\n \n     pub fn node_data<'a>(&'a self, idx: NodeIndex) -> &'a N {\n-        &self.nodes[idx.get()].data\n+        &self.nodes.get(idx.get()).data\n     }\n \n     pub fn node<'a>(&'a self, idx: NodeIndex) -> &'a Node<N> {\n-        &self.nodes[idx.get()]\n+        self.nodes.get(idx.get())\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -143,8 +148,10 @@ impl<N,E> Graph<N,E> {\n         let idx = self.next_edge_index();\n \n         // read current first of the list of edges from each node\n-        let source_first = self.nodes[source.get()].first_edge[Outgoing.repr];\n-        let target_first = self.nodes[target.get()].first_edge[Incoming.repr];\n+        let source_first = self.nodes.get(source.get())\n+                                     .first_edge[Outgoing.repr];\n+        let target_first = self.nodes.get(target.get())\n+                                     .first_edge[Incoming.repr];\n \n         // create the new edge, with the previous firsts from each node\n         // as the next pointers\n@@ -156,38 +163,38 @@ impl<N,E> Graph<N,E> {\n         });\n \n         // adjust the firsts for each node target be the next object.\n-        self.nodes[source.get()].first_edge[Outgoing.repr] = idx;\n-        self.nodes[target.get()].first_edge[Incoming.repr] = idx;\n+        self.nodes.get_mut(source.get()).first_edge[Outgoing.repr] = idx;\n+        self.nodes.get_mut(target.get()).first_edge[Incoming.repr] = idx;\n \n         return idx;\n     }\n \n     pub fn mut_edge_data<'a>(&'a mut self, idx: EdgeIndex) -> &'a mut E {\n-        &mut self.edges[idx.get()].data\n+        &mut self.edges.get_mut(idx.get()).data\n     }\n \n     pub fn edge_data<'a>(&'a self, idx: EdgeIndex) -> &'a E {\n-        &self.edges[idx.get()].data\n+        &self.edges.get(idx.get()).data\n     }\n \n     pub fn edge<'a>(&'a self, idx: EdgeIndex) -> &'a Edge<E> {\n-        &self.edges[idx.get()]\n+        self.edges.get(idx.get())\n     }\n \n     pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the index of the first edge adjacent to `node`.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.nodes[node.get()].first_edge[dir.repr]\n+        self.nodes.get(node.get()).first_edge[dir.repr]\n     }\n \n     pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n         //! Accesses the next edge in a given direction.\n         //! This is useful if you wish to modify the graph while walking\n         //! the linked list of edges.\n \n-        self.edges[edge.get()].next_edge[dir.repr]\n+        self.edges.get(edge.get()).next_edge[dir.repr]\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -231,7 +238,7 @@ impl<N,E> Graph<N,E> {\n \n         let mut edge_idx = self.first_adjacent(node, dir);\n         while edge_idx != InvalidEdgeIndex {\n-            let edge = &self.edges[edge_idx.get()];\n+            let edge = self.edges.get(edge_idx.get());\n             if !f(edge_idx, edge) {\n                 return false;\n             }"}, {"sha": "90c86cb5e74e2613573bed75859fbf1a0283df28", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -16,6 +16,7 @@ use middle::typeck;\n use util::ppaux::{Repr, ty_to_str};\n use util::ppaux::UserString;\n \n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::attr;\n use syntax::codemap::Span;"}, {"sha": "ccf81840a418538efacc328ff31d7d34eff81c34", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -33,6 +33,7 @@ use syntax::visit;\n use collections::HashMap;\n use std::iter::Enumerate;\n use std::vec;\n+use std::vec_ng::Vec;\n \n // The actual lang items defined come at the end of this file in one handy table.\n // So you probably just want to nip down to the end.\n@@ -72,10 +73,12 @@ impl LanguageItems {\n     }\n \n     pub fn require(&self, it: LangItem) -> Result<ast::DefId, ~str> {\n-        match self.items[it as uint] {\n-            Some(id) => Ok(id),\n-            None => Err(format!(\"requires `{}` lang_item\",\n-                             LanguageItems::item_name(it as uint)))\n+        match self.items.get(it as uint) {\n+            &Some(id) => Ok(id),\n+            &None => {\n+                Err(format!(\"requires `{}` lang_item\",\n+                            LanguageItems::item_name(it as uint)))\n+            }\n         }\n     }\n \n@@ -95,7 +98,7 @@ impl LanguageItems {\n \n     $(\n         pub fn $method(&self) -> Option<ast::DefId> {\n-            self.items[$variant as uint]\n+            *self.items.get($variant as uint)\n         }\n     )*\n }\n@@ -147,18 +150,18 @@ impl LanguageItemCollector {\n \n     pub fn collect_item(&mut self, item_index: uint, item_def_id: ast::DefId) {\n         // Check for duplicates.\n-        match self.items.items[item_index] {\n-            Some(original_def_id) if original_def_id != item_def_id => {\n+        match self.items.items.get(item_index) {\n+            &Some(original_def_id) if original_def_id != item_def_id => {\n                 self.session.err(format!(\"duplicate entry for `{}`\",\n                                       LanguageItems::item_name(item_index)));\n             }\n-            Some(_) | None => {\n+            &Some(_) | &None => {\n                 // OK.\n             }\n         }\n \n         // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n+        *self.items.items.get_mut(item_index) = Some(item_def_id);\n     }\n \n     pub fn collect_local_language_items(&mut self, krate: &ast::Crate) {"}, {"sha": "ddf75d1f0b652d9638d172fb83d3f8108c665be6", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -45,7 +45,6 @@ use middle::ty;\n use middle::typeck::astconv::{ast_ty_to_ty, AstConv};\n use middle::typeck::infer;\n use middle::typeck;\n-use std::to_str::ToStr;\n use util::ppaux::{ty_to_str};\n \n use std::cmp;\n@@ -54,10 +53,12 @@ use std::i16;\n use std::i32;\n use std::i64;\n use std::i8;\n+use std::to_str::ToStr;\n use std::u16;\n use std::u32;\n use std::u64;\n use std::u8;\n+use std::vec_ng::Vec;\n use collections::SmallIntMap;\n use syntax::ast_map;\n use syntax::ast_util::IdVisitingOperation;\n@@ -1091,7 +1092,7 @@ fn check_unused_result(cx: &Context, s: &ast::Stmt) {\n                 }\n             } else {\n                 csearch::get_item_attrs(cx.tcx.sess.cstore, did, |attrs| {\n-                    if attr::contains_name(attrs, \"must_use\") {\n+                    if attr::contains_name(attrs.as_slice(), \"must_use\") {\n                         cx.span_lint(UnusedMustUse, s.span,\n                                      \"unused result which must be used\");\n                         warned = true;"}, {"sha": "04f2b2f28231935aaf3a229c0d5503a93c8be6a0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -116,7 +116,7 @@ use std::fmt;\n use std::io;\n use std::str;\n use std::uint;\n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::parse::token::special_idents;\n@@ -260,7 +260,7 @@ pub struct IrMaps {\n     num_vars: Cell<uint>,\n     live_node_map: RefCell<NodeMap<LiveNode>>,\n     variable_map: RefCell<NodeMap<Variable>>,\n-    capture_info_map: RefCell<NodeMap<@~[CaptureInfo]>>,\n+    capture_info_map: RefCell<NodeMap<@Vec<CaptureInfo> >>,\n     var_kinds: RefCell<Vec<VarKind> >,\n     lnks: RefCell<Vec<LiveNodeKind> >,\n }\n@@ -339,11 +339,11 @@ impl IrMaps {\n \n     pub fn variable_name(&self, var: Variable) -> ~str {\n         let var_kinds = self.var_kinds.borrow();\n-        match var_kinds.get()[var.get()] {\n-            Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n+        match var_kinds.get().get(var.get()) {\n+            &Local(LocalInfo { ident: nm, .. }) | &Arg(_, nm) => {\n                 token::get_ident(nm).get().to_str()\n             },\n-            ImplicitRet => ~\"<implicit-ret>\"\n+            &ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n@@ -364,7 +364,7 @@ impl IrMaps {\n \n     pub fn lnk(&self, ln: LiveNode) -> LiveNodeKind {\n         let lnks = self.lnks.borrow();\n-        lnks.get()[ln.get()]\n+        *lnks.get().get(ln.get())\n     }\n }\n \n@@ -607,9 +607,9 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n         ir: ir,\n         tcx: ir.tcx,\n         s: specials,\n-        successors: @RefCell::new(vec::from_elem(ir.num_live_nodes.get(),\n+        successors: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get(),\n                                                  invalid_node())),\n-        users: @RefCell::new(vec::from_elem(ir.num_live_nodes.get() *\n+        users: @RefCell::new(Vec::from_elem(ir.num_live_nodes.get() *\n                                             ir.num_vars.get(),\n                                             invalid_users())),\n         loop_scope: @RefCell::new(Vec::new()),\n@@ -686,7 +686,7 @@ impl Liveness {\n                          -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let users = self.users.borrow();\n-        let reader = users.get()[self.idx(ln, var)].reader;\n+        let reader = users.get().get(self.idx(ln, var)).reader;\n         if reader.is_valid() {Some(self.ir.lnk(reader))} else {None}\n     }\n \n@@ -697,30 +697,30 @@ impl Liveness {\n                         -> Option<LiveNodeKind> {\n         let successor = {\n             let successors = self.successors.borrow();\n-            successors.get()[ln.get()]\n+            *successors.get().get(ln.get())\n         };\n         self.live_on_entry(successor, var)\n     }\n \n     pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert!(ln.is_valid());\n         let users = self.users.borrow();\n-        users.get()[self.idx(ln, var)].used\n+        users.get().get(self.idx(ln, var)).used\n     }\n \n     pub fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n                              -> Option<LiveNodeKind> {\n         assert!(ln.is_valid());\n         let users = self.users.borrow();\n-        let writer = users.get()[self.idx(ln, var)].writer;\n+        let writer = users.get().get(self.idx(ln, var)).writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n     pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n                             -> Option<LiveNodeKind> {\n         let successor = {\n             let successors = self.successors.borrow();\n-            successors.get()[ln.get()]\n+            *successors.get().get(ln.get())\n         };\n         self.assigned_on_entry(successor, var)\n     }\n@@ -795,14 +795,14 @@ impl Liveness {\n                 write!(wr,\n                        \"[ln({}) of kind {:?} reads\",\n                        ln.get(),\n-                       lnks.and_then(|lnks| Some(lnks.get()[ln.get()])));\n+                       lnks.and_then(|lnks| Some(*lnks.get().get(ln.get()))));\n             }\n             let users = self.users.try_borrow();\n             match users {\n                 Some(users) => {\n-                    self.write_vars(wr, ln, |idx| users.get()[idx].reader);\n+                    self.write_vars(wr, ln, |idx| users.get().get(idx).reader);\n                     write!(wr, \"  writes\");\n-                    self.write_vars(wr, ln, |idx| users.get()[idx].writer);\n+                    self.write_vars(wr, ln, |idx| users.get().get(idx).writer);\n                 }\n                 None => {\n                     write!(wr, \"  (users borrowed)\");\n@@ -811,7 +811,9 @@ impl Liveness {\n             let successors = self.successors.try_borrow();\n             match successors {\n                 Some(successors) => {\n-                    write!(wr, \"  precedes {}]\", successors.get()[ln.get()].to_str());\n+                    write!(wr,\n+                           \"  precedes {}]\",\n+                           successors.get().get(ln.get()).to_str());\n                 }\n                 None => {\n                     write!(wr, \"  precedes (successors borrowed)]\");\n@@ -824,7 +826,7 @@ impl Liveness {\n     pub fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n         {\n             let mut successors = self.successors.borrow_mut();\n-            successors.get()[ln.get()] = succ_ln;\n+            *successors.get().get_mut(ln.get()) = succ_ln;\n         }\n \n         // It is not necessary to initialize the\n@@ -841,12 +843,12 @@ impl Liveness {\n         // more efficient version of init_empty() / merge_from_succ()\n         {\n             let mut successors = self.successors.borrow_mut();\n-            successors.get()[ln.get()] = succ_ln;\n+            *successors.get().get_mut(ln.get()) = succ_ln;\n         }\n \n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             let mut users = self.users.borrow_mut();\n-            users.get()[idx] = users.get()[succ_idx]\n+            *users.get().get_mut(idx) = *users.get().get(succ_idx)\n         });\n         debug!(\"init_from_succ(ln={}, succ={})\",\n                self.ln_str(ln), self.ln_str(succ_ln));\n@@ -862,12 +864,12 @@ impl Liveness {\n         let mut changed = false;\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n             let mut users = self.users.borrow_mut();\n-            changed |= copy_if_invalid(users.get()[succ_idx].reader,\n-                                       &mut users.get()[idx].reader);\n-            changed |= copy_if_invalid(users.get()[succ_idx].writer,\n-                                       &mut users.get()[idx].writer);\n-            if users.get()[succ_idx].used && !users.get()[idx].used {\n-                users.get()[idx].used = true;\n+            changed |= copy_if_invalid(users.get().get(succ_idx).reader,\n+                                       &mut users.get().get_mut(idx).reader);\n+            changed |= copy_if_invalid(users.get().get(succ_idx).writer,\n+                                       &mut users.get().get_mut(idx).writer);\n+            if users.get().get(succ_idx).used && !users.get().get(idx).used {\n+                users.get().get_mut(idx).used = true;\n                 changed = true;\n             }\n         });\n@@ -893,8 +895,8 @@ impl Liveness {\n     pub fn define(&self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n         let mut users = self.users.borrow_mut();\n-        users.get()[idx].reader = invalid_node();\n-        users.get()[idx].writer = invalid_node();\n+        users.get().get_mut(idx).reader = invalid_node();\n+        users.get().get_mut(idx).writer = invalid_node();\n \n         debug!(\"{} defines {} (idx={}): {}\", writer.to_str(), var.to_str(),\n                idx, self.ln_str(writer));\n@@ -904,7 +906,7 @@ impl Liveness {\n     pub fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n         let mut users = self.users.borrow_mut();\n-        let user = &mut users.get()[idx];\n+        let user = users.get().get_mut(idx);\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();"}, {"sha": "ba93e52bc48eced6ad2a2c2c86f0433ec5db7bc1", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -65,6 +65,7 @@\n use middle::ty;\n use util::ppaux::{ty_to_str, region_ptr_to_str, Repr};\n \n+use std::vec_ng::Vec;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap::Span;"}, {"sha": "16655474d3a85ef4834c487c4815f95536444ce4", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -139,6 +139,7 @@ use util::nodemap::{NodeMap, NodeSet};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::ast_util;\n use syntax::visit;"}, {"sha": "3e645491699ecaf063c5a5120e48ff7bc175e847", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -12,6 +12,7 @@\n use middle::resolve;\n \n use collections::HashMap;\n+use std::vec_ng::Vec;\n use syntax::ast::*;\n use syntax::ast_util::{path_to_ident, walk_pat};\n use syntax::codemap::Span;"}, {"sha": "fac7e7a36e69cbb38c1199cee408e2c8c53fd08b", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -21,6 +21,7 @@ use middle::privacy;\n use util::nodemap::NodeSet;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::HashSet;\n use syntax::ast;\n use syntax::ast_map;"}, {"sha": "15d228662c753a3454c946f806e801b64064d540", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -27,6 +27,7 @@ use middle::ty;\n use util::nodemap::NodeMap;\n \n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n@@ -287,7 +288,7 @@ impl RegionMaps {\n         let mut i = 0;\n         while i < queue.len() {\n             let free_region_map = self.free_region_map.borrow();\n-            match free_region_map.get().find(&queue[i]) {\n+            match free_region_map.get().find(queue.get(i)) {\n                 Some(parents) => {\n                     for parent in parents.iter() {\n                         if *parent == sup {\n@@ -369,7 +370,7 @@ impl RegionMaps {\n         // where they diverge.  If one vector is a suffix of the other,\n         // then the corresponding scope is a superscope of the other.\n \n-        if a_ancestors[a_index] != b_ancestors[b_index] {\n+        if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n             return None;\n         }\n \n@@ -380,8 +381,8 @@ impl RegionMaps {\n             if b_index == 0u { return Some(scope_b); }\n             a_index -= 1u;\n             b_index -= 1u;\n-            if a_ancestors[a_index] != b_ancestors[b_index] {\n-                return Some(a_ancestors[a_index + 1u]);\n+            if *a_ancestors.get(a_index) != *b_ancestors.get(b_index) {\n+                return Some(*a_ancestors.get(a_index + 1u));\n             }\n         }\n "}, {"sha": "77e44c137a983099ec4ad230cc2b258d3a28112f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -34,6 +34,7 @@ use syntax::visit::Visitor;\n use std::cell::{Cell, RefCell};\n use std::uint;\n use std::mem::replace;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n \n // Definition mapping\n@@ -826,7 +827,7 @@ fn Resolver(session: Session,\n \n         primitive_type_table: @PrimitiveTypeTable(),\n \n-        namespaces: Vec<TypeNS, ValueNS > ,\n+        namespaces: vec!(TypeNS, ValueNS),\n \n         def_map: @RefCell::new(NodeMap::new()),\n         export_map2: @RefCell::new(NodeMap::new()),\n@@ -1972,7 +1973,7 @@ impl Resolver {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n-                       self.idents_to_str(directive.module_path),\n+                       self.idents_to_str(directive.module_path.as_slice()),\n                        token::get_ident(target));\n \n                 let mut import_resolutions = module_.import_resolutions\n@@ -2085,13 +2086,14 @@ impl Resolver {\n         let import_count = imports.get().len();\n         while module.resolved_import_count.get() < import_count {\n             let import_index = module.resolved_import_count.get();\n-            let import_directive = imports.get()[import_index];\n+            let import_directive = *imports.get().get(import_index);\n             match self.resolve_import_for_module(module, import_directive) {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n                     let msg = format!(\"failed to resolve import `{}`\",\n                                    self.import_path_to_str(\n-                                       import_directive.module_path,\n+                                       import_directive.module_path\n+                                                       .as_slice(),\n                                        *import_directive.subclass));\n                     self.resolve_error(import_directive.span, msg);\n                 }\n@@ -2128,7 +2130,7 @@ impl Resolver {\n                                              .iter()\n                                              .map(|seg| seg.identifier)\n                                              .collect();\n-        self.idents_to_str(identifiers)\n+        self.idents_to_str(identifiers.as_slice())\n     }\n \n     fn import_directive_subclass_to_str(&mut self,\n@@ -2169,7 +2171,7 @@ impl Resolver {\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in \\\n                 `{}`\",\n-               self.idents_to_str(*module_path),\n+               self.idents_to_str(module_path.as_slice()),\n                self.module_to_str(module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -2178,7 +2180,7 @@ impl Resolver {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_,\n-                                           *module_path,\n+                                           module_path.as_slice(),\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -3274,15 +3276,15 @@ impl Resolver {\n         if index != import_count {\n             let sn = self.session\n                          .codemap\n-                         .span_to_snippet(imports.get()[index].span)\n+                         .span_to_snippet(imports.get().get(index).span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                self.resolve_error(imports.get()[index].span,\n+                self.resolve_error(imports.get().get(index).span,\n                                    \"unresolved import\");\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                sn.slice(0, sn.len()));\n-                self.resolve_error(imports.get()[index].span, err);\n+                self.resolve_error(imports.get().get(index).span, err);\n             }\n         }\n \n@@ -3520,7 +3522,7 @@ impl Resolver {\n \n         let mut rib_index = rib_index + 1;\n         while rib_index < ribs.len() {\n-            match ribs[rib_index].kind {\n+            match ribs.get(rib_index).kind {\n                 NormalRibKind => {\n                     // Nothing to do. Continue.\n                 }\n@@ -3621,7 +3623,7 @@ impl Resolver {\n         while i != 0 {\n             i -= 1;\n             let binding_opt = {\n-                let bindings = ribs[i].bindings.borrow();\n+                let bindings = ribs.get(i).bindings.borrow();\n                 bindings.get().find_copy(&name)\n             };\n             match binding_opt {\n@@ -4492,8 +4494,9 @@ impl Resolver {\n                                     {\n                                         let mut value_ribs =\n                                             this.value_ribs.borrow_mut();\n-                                        let last_rib = value_ribs.get()[\n-                                            value_ribs.get().len() - 1];\n+                                        let length = value_ribs.get().len();\n+                                        let last_rib = value_ribs.get().get(\n+                                            length - 1);\n                                         let mut bindings =\n                                             last_rib.bindings.borrow_mut();\n                                         bindings.get().insert(renamed,\n@@ -4518,8 +4521,9 @@ impl Resolver {\n                                     {\n                                         let mut value_ribs =\n                                             this.value_ribs.borrow_mut();\n-                                        let last_rib = value_ribs.get()[\n-                                                value_ribs.get().len() - 1];\n+                                        let length = value_ribs.get().len();\n+                                        let last_rib = value_ribs.get().get(\n+                                                length - 1);\n                                         let mut bindings =\n                                             last_rib.bindings.borrow_mut();\n                                         bindings.get().insert(renamed,\n@@ -5064,7 +5068,7 @@ impl Resolver {\n         while j != 0 {\n             j -= 1;\n             let value_ribs = this.value_ribs.borrow();\n-            let bindings = value_ribs.get()[j].bindings.borrow();\n+            let bindings = value_ribs.get().get(j).bindings.borrow();\n             for (&k, _) in bindings.get().iter() {\n                 maybes.push(token::get_name(k));\n                 values.push(uint::MAX);\n@@ -5073,20 +5077,20 @@ impl Resolver {\n \n         let mut smallest = 0;\n         for (i, other) in maybes.iter().enumerate() {\n-            values[i] = name.lev_distance(other.get());\n+            *values.get_mut(i) = name.lev_distance(other.get());\n \n-            if values[i] <= values[smallest] {\n+            if *values.get(i) <= *values.get(smallest) {\n                 smallest = i;\n             }\n         }\n \n         if values.len() > 0 &&\n-            values[smallest] != uint::MAX &&\n-            values[smallest] < name.len() + 2 &&\n-            values[smallest] <= max_distance &&\n-            name != maybes[smallest].get() {\n+            *values.get(smallest) != uint::MAX &&\n+            *values.get(smallest) < name.len() + 2 &&\n+            *values.get(smallest) <= max_distance &&\n+            name != maybes.get(smallest).get() {\n \n-            Some(maybes[smallest].get().to_str())\n+            Some(maybes.get(smallest).get().to_str())\n \n         } else {\n             None\n@@ -5212,8 +5216,8 @@ impl Resolver {\n                     let def_like = DlDef(DefLabel(expr.id));\n                     {\n                         let mut label_ribs = this.label_ribs.borrow_mut();\n-                        let rib = label_ribs.get()[label_ribs.get().len() -\n-                                                   1];\n+                        let length = label_ribs.get().len();\n+                        let rib = label_ribs.get().get(length - 1);\n                         let mut bindings = rib.bindings.borrow_mut();\n                         let renamed = mtwt::resolve(label);\n                         bindings.get().insert(renamed, def_like);\n@@ -5516,7 +5520,9 @@ impl Resolver {\n         if idents.len() == 0 {\n             return ~\"???\";\n         }\n-        return self.idents_to_str(idents.move_rev_iter().collect::<Vec<ast::Ident> >());\n+        return self.idents_to_str(idents.move_rev_iter()\n+                                        .collect::<Vec<ast::Ident>>()\n+                                        .as_slice());\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "6c48440421f6f8c60f8862ccf09e71711c36a1d8", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -16,6 +16,7 @@ use middle::ty_fold::TypeFolder;\n use util::ppaux::Repr;\n \n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n \n@@ -88,7 +89,7 @@ impl<'a> TypeFolder for SubstFolder<'a> {\n         match ty::get(t).sty {\n             ty::ty_param(p) => {\n                 if p.idx < self.substs.tps.len() {\n-                    self.substs.tps[p.idx]\n+                    *self.substs.tps.get(p.idx)\n                 } else {\n                     let root_msg = match self.root_ty {\n                         Some(root) => format!(\" in the substitution of `{}`\","}, {"sha": "4f190c5d697aae9146c11e1d27ac8f49454d92b7", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 103, "deletions": 62, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -223,9 +223,10 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, vec_map_to_str};\n \n-use std::cell::Cell;\n use collections::HashMap;\n-use std::vec;\n+use std::cell::Cell;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::ast::Ident;\n use syntax::ast_util::path_to_ident;\n@@ -438,9 +439,9 @@ impl<'a,'b> Repr for Match<'a,'b> {\n \n fn has_nested_bindings(m: &[Match], col: uint) -> bool {\n     for br in m.iter() {\n-        match br.pats[col].node {\n-          ast::PatIdent(_, _, Some(_)) => return true,\n-          _ => ()\n+        match br.pats.get(col).node {\n+            ast::PatIdent(_, _, Some(_)) => return true,\n+            _ => ()\n         }\n     }\n     return false;\n@@ -451,22 +452,22 @@ fn expand_nested_bindings<'r,'b>(\n                           m: &[Match<'r,'b>],\n                           col: uint,\n                           val: ValueRef)\n-                          -> vec!(Match<'r,'b>) {\n+                          -> Vec<Match<'r,'b>> {\n     debug!(\"expand_nested_bindings(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    m.map(|br| {\n-        match br.pats[col].node {\n+    m.iter().map(|br| {\n+        match br.pats.get(col).node {\n             ast::PatIdent(_, ref path, Some(inner)) => {\n                 let pats = vec_ng::append(\n-                    br.pats.slice(0u, col).to_owned(),\n+                    Vec::from_slice(br.pats.slice(0u, col)),\n                     vec_ng::append(vec!(inner),\n                                 br.pats.slice(col + 1u,\n-                                           br.pats.len())));\n+                                           br.pats.len())).as_slice());\n \n                 let mut res = Match {\n                     pats: pats,\n@@ -478,7 +479,7 @@ fn expand_nested_bindings<'r,'b>(\n             }\n             _ => (*br).clone(),\n         }\n-    })\n+    }).collect()\n }\n \n fn assert_is_binding_or_wild(bcx: &Block, p: @ast::Pat) {\n@@ -499,7 +500,7 @@ fn enter_match<'r,'b>(\n                col: uint,\n                val: ValueRef,\n                e: enter_pat)\n-               -> vec!(Match<'r,'b>) {\n+               -> Vec<Match<'r,'b>> {\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -509,14 +510,14 @@ fn enter_match<'r,'b>(\n \n     let mut result = Vec::new();\n     for br in m.iter() {\n-        match e(br.pats[col]) {\n+        match e(*br.pats.get(col)) {\n             Some(sub) => {\n                 let pats =\n                     vec_ng::append(\n                         vec_ng::append(sub, br.pats.slice(0u, col)),\n                         br.pats.slice(col + 1u, br.pats.len()));\n \n-                let this = br.pats[col];\n+                let this = *br.pats.get(col);\n                 let mut bound_ptrs = br.bound_ptrs.clone();\n                 match this.node {\n                     ast::PatIdent(_, ref path, None) => {\n@@ -549,7 +550,7 @@ fn enter_default<'r,'b>(\n                  col: uint,\n                  val: ValueRef,\n                  chk: &FailureHandler)\n-                 -> vec!(Match<'r,'b>) {\n+                 -> Vec<Match<'r,'b>> {\n     debug!(\"enter_default(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -620,7 +621,7 @@ fn enter_opt<'r,'b>(\n              col: uint,\n              variant_size: uint,\n              val: ValueRef)\n-             -> vec!(Match<'r,'b>) {\n+             -> Vec<Match<'r,'b>> {\n     debug!(\"enter_opt(bcx={}, m={}, opt={:?}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -651,7 +652,7 @@ fn enter_opt<'r,'b>(\n                 if opt_eq(tcx, &variant_opt(bcx, p.id), opt) {\n                     // FIXME: Must we clone?\n                     match *subpats {\n-                        None => Some(vec::from_elem(variant_size, dummy)),\n+                        None => Some(Vec::from_elem(variant_size, dummy)),\n                         Some(ref subpats) => {\n                             Some((*subpats).iter().map(|x| *x).collect())\n                         }\n@@ -761,7 +762,7 @@ fn enter_opt<'r,'b>(\n                 // cause the default match to fire spuriously.\n                 match *opt {\n                     vec_len(..) => None,\n-                    _ => Some(vec::from_elem(variant_size, dummy))\n+                    _ => Some(Vec::from_elem(variant_size, dummy))\n                 }\n             }\n         };\n@@ -777,7 +778,7 @@ fn enter_rec_or_struct<'r,'b>(\n                        col: uint,\n                        fields: &[ast::Ident],\n                        val: ValueRef)\n-                       -> vec!(Match<'r,'b>) {\n+                       -> Vec<Match<'r,'b>> {\n     debug!(\"enter_rec_or_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -800,7 +801,7 @@ fn enter_rec_or_struct<'r,'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(fields.len(), dummy))\n+                Some(Vec::from_elem(fields.len(), dummy))\n             }\n         }\n     })\n@@ -813,7 +814,7 @@ fn enter_tup<'r,'b>(\n              col: uint,\n              val: ValueRef,\n              n_elts: uint)\n-             -> vec!(Match<'r,'b>) {\n+             -> Vec<Match<'r,'b>> {\n     debug!(\"enter_tup(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -833,7 +834,7 @@ fn enter_tup<'r,'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(n_elts, dummy))\n+                Some(Vec::from_elem(n_elts, dummy))\n             }\n         }\n     })\n@@ -846,7 +847,7 @@ fn enter_tuple_struct<'r,'b>(\n                       col: uint,\n                       val: ValueRef,\n                       n_elts: uint)\n-                      -> vec!(Match<'r,'b>) {\n+                      -> Vec<Match<'r,'b>> {\n     debug!(\"enter_tuple_struct(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -862,7 +863,7 @@ fn enter_tuple_struct<'r,'b>(\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(n_elts, dummy))\n+                Some(Vec::from_elem(n_elts, dummy))\n             }\n         }\n     })\n@@ -874,7 +875,7 @@ fn enter_uniq<'r,'b>(\n               m: &[Match<'r,'b>],\n               col: uint,\n               val: ValueRef)\n-              -> vec!(Match<'r,'b>) {\n+              -> Vec<Match<'r,'b>> {\n     debug!(\"enter_uniq(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -903,7 +904,7 @@ fn enter_region<'r,\n                 m: &[Match<'r,'b>],\n                 col: uint,\n                 val: ValueRef)\n-                -> vec!(Match<'r,'b>) {\n+                -> Vec<Match<'r,'b>> {\n     debug!(\"enter_region(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -945,15 +946,18 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n             // to add, then extend its range. Otherwise, make a new\n             // vec_len with a range just covering the new entry.\n             Some(&vec_len(len2, vlo2, (start, end)))\n-                 if len == len2 && vlo == vlo2 =>\n-                 set[set.len() - 1] = vec_len(len, vlo, (start, end+1)),\n+                 if len == len2 && vlo == vlo2 => {\n+                let length = set.len();\n+                 *set.get_mut(length - 1) =\n+                     vec_len(len, vlo, (start, end+1))\n+            }\n             _ => set.push(vec_len(len, vlo, (i, i)))\n         }\n     }\n \n     let mut found = Vec::new();\n     for (i, br) in m.iter().enumerate() {\n-        let cur = br.pats[col];\n+        let cur = *br.pats.get(col);\n         match cur.node {\n             ast::PatLit(l) => {\n                 add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n@@ -1030,7 +1034,7 @@ fn extract_variant_args<'a>(\n                         val: ValueRef)\n                         -> ExtractedBlock<'a> {\n     let _icx = push_ctxt(\"match::extract_variant_args\");\n-    let args = vec::from_fn(adt::num_args(repr, disr_val), |i| {\n+    let args = Vec::from_fn(adt::num_args(repr, disr_val), |i| {\n         adt::trans_field_ptr(bcx, repr, val, disr_val, i)\n     });\n \n@@ -1065,7 +1069,7 @@ fn extract_vec_elems<'a>(\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n-    let mut elems = vec::from_fn(elem_count, |i| {\n+    let mut elems = Vec::from_fn(elem_count, |i| {\n         match slice {\n             None => GEPi(bcx, base, [i]),\n             Some(n) if i < n => GEPi(bcx, base, [i]),\n@@ -1091,7 +1095,7 @@ fn extract_vec_elems<'a>(\n         Store(bcx, slice_begin,\n               GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n         Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n-        elems[n] = scratch.val;\n+        *elems.get_mut(n) = scratch.val;\n     }\n \n     ExtractedBlock { vals: elems, bcx: bcx }\n@@ -1111,9 +1115,9 @@ fn collect_record_or_struct_fields<'a>(\n     let mut fields: Vec<ast::Ident> = Vec::new();\n     let mut found = false;\n     for br in m.iter() {\n-        match br.pats[col].node {\n+        match br.pats.get(col).node {\n           ast::PatStruct(_, ref fs, _) => {\n-            match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n+            match ty::get(node_id_type(bcx, br.pats.get(col).id)).sty {\n               ty::ty_struct(..) => {\n                    extend(&mut fields, fs.as_slice());\n                    found = true;\n@@ -1142,7 +1146,7 @@ fn collect_record_or_struct_fields<'a>(\n \n fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n-        let pat_id = br.pats[col].id;\n+        let pat_id = br.pats.get(col).id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         let root_map = bcx.ccx().maps.root_map.borrow();\n         root_map.get().contains_key(&key)\n@@ -1156,7 +1160,7 @@ fn pats_require_rooting(bcx: &Block, m: &[Match], col: uint) -> bool {\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n         ($m).iter().any(|br| {\n-            match br.pats[col].node {\n+            match br.pats.get(col).node {\n                 $pattern => true,\n                 _ => false\n             }\n@@ -1178,7 +1182,7 @@ fn any_tup_pat(m: &[Match], col: uint) -> bool {\n \n fn any_tuple_struct_pat(bcx: &Block, m: &[Match], col: uint) -> bool {\n     m.iter().any(|br| {\n-        let pat = br.pats[col];\n+        let pat = *br.pats.get(col);\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n                 let def_map = bcx.tcx().def_map.borrow();\n@@ -1255,10 +1259,10 @@ fn pick_col(m: &[Match]) -> uint {\n           _ => 0u\n         }\n     }\n-    let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n+    let mut scores = Vec::from_elem(m[0].pats.len(), 0u);\n     for br in m.iter() {\n         for (i, p) in br.pats.iter().enumerate() {\n-            scores[i] += score(*p);\n+            *scores.get_mut(i) += score(*p);\n         }\n     }\n     let mut max_score = 0u;\n@@ -1511,7 +1515,12 @@ fn compile_submatch<'r,\n \n     if has_nested_bindings(m, col) {\n         let expanded = expand_nested_bindings(bcx, m, col, val);\n-        compile_submatch_continue(bcx, expanded, vals, chk, col, val)\n+        compile_submatch_continue(bcx,\n+                                  expanded.as_slice(),\n+                                  vals,\n+                                  chk,\n+                                  col,\n+                                  val)\n     } else {\n         compile_submatch_continue(bcx, m, vals, chk, col, val)\n     }\n@@ -1529,15 +1538,15 @@ fn compile_submatch_continue<'r,\n     let tcx = bcx.tcx();\n     let dm = tcx.def_map;\n \n-    let vals_left = vec_ng::append(vals.slice(0u, col).to_owned(),\n-                                vals.slice(col + 1u, vals.len()));\n+    let vals_left = vec_ng::append(Vec::from_slice(vals.slice(0u, col)),\n+                                   vals.slice(col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n     for br in m.iter() {\n         // Find a real id (we're adding placeholder wildcard patterns, but\n         // each column is guaranteed to have at least one real pattern)\n         if pat_id == 0 {\n-            pat_id = br.pats[col].id;\n+            pat_id = br.pats.get(col).id;\n         }\n     }\n \n@@ -1556,8 +1565,14 @@ fn compile_submatch_continue<'r,\n                         });\n                 compile_submatch(\n                         bcx,\n-                        enter_rec_or_struct(bcx, dm, m, col, *rec_fields, val),\n-                        vec_ng::append(rec_vals, vals_left),\n+                        enter_rec_or_struct(bcx,\n+                                            dm,\n+                                            m,\n+                                            col,\n+                                            rec_fields.as_slice(),\n+                                            val).as_slice(),\n+                        vec_ng::append(rec_vals,\n+                                       vals_left.as_slice()).as_slice(),\n                         chk);\n             });\n             return;\n@@ -1572,11 +1587,19 @@ fn compile_submatch_continue<'r,\n           ty::ty_tup(ref elts) => elts.len(),\n           _ => ccx.sess.bug(\"non-tuple type in tuple pattern\")\n         };\n-        let tup_vals = vec::from_fn(n_tup_elts, |i| {\n+        let tup_vals = Vec::from_fn(n_tup_elts, |i| {\n             adt::trans_field_ptr(bcx, tup_repr, val, 0, i)\n         });\n-        compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n-                         vec_ng::append(tup_vals, vals_left), chk);\n+        compile_submatch(bcx,\n+                         enter_tup(bcx,\n+                                   dm,\n+                                   m,\n+                                   col,\n+                                   val,\n+                                   n_tup_elts).as_slice(),\n+                         vec_ng::append(tup_vals,\n+                                        vals_left.as_slice()).as_slice(),\n+                         chk);\n         return;\n     }\n \n@@ -1594,28 +1617,35 @@ fn compile_submatch_continue<'r,\n         }\n \n         let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n-        let llstructvals = vec::from_fn(struct_element_count, |i| {\n+        let llstructvals = Vec::from_fn(struct_element_count, |i| {\n             adt::trans_field_ptr(bcx, struct_repr, val, 0, i)\n         });\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n-                                            struct_element_count),\n-                         vec_ng::append(llstructvals, vals_left),\n+                                            struct_element_count).as_slice(),\n+                         vec_ng::append(llstructvals,\n+                                        vals_left.as_slice()).as_slice(),\n                          chk);\n         return;\n     }\n \n     if any_uniq_pat(m, col) {\n         let llbox = Load(bcx, val);\n-        compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n-                         vec_ng::append(vec!(llbox), vals_left), chk);\n+        compile_submatch(bcx,\n+                         enter_uniq(bcx, dm, m, col, val).as_slice(),\n+                         vec_ng::append(vec!(llbox),\n+                                        vals_left.as_slice()).as_slice(),\n+                         chk);\n         return;\n     }\n \n     if any_region_pat(m, col) {\n         let loaded_val = Load(bcx, val);\n-        compile_submatch(bcx, enter_region(bcx, dm, m, col, val),\n-                         vec_ng::append(vec!(loaded_val), vals_left), chk);\n+        compile_submatch(bcx,\n+                         enter_region(bcx, dm, m, col, val).as_slice(),\n+                         vec_ng::append(vec!(loaded_val),\n+                                        vals_left.as_slice()).as_slice(),\n+                         chk);\n         return;\n     }\n \n@@ -1626,7 +1656,7 @@ fn compile_submatch_continue<'r,\n     let mut test_val = val;\n     debug!(\"test_val={}\", bcx.val_to_str(test_val));\n     if opts.len() > 0u {\n-        match opts[0] {\n+        match *opts.get(0) {\n             var(_, repr) => {\n                 let (the_kind, val_opt) = adt::trans_switch(bcx, repr, val);\n                 kind = the_kind;\n@@ -1795,12 +1825,20 @@ fn compile_submatch_continue<'r,\n             lit(_) | range(_, _) => ()\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n-        let opt_vals = vec_ng::append(unpacked, vals_left);\n+        let opt_vals = vec_ng::append(unpacked, vals_left.as_slice());\n \n         match branch_chk {\n-            None => compile_submatch(opt_cx, opt_ms, opt_vals, chk),\n+            None => {\n+                compile_submatch(opt_cx,\n+                                 opt_ms.as_slice(),\n+                                 opt_vals.as_slice(),\n+                                 chk)\n+            }\n             Some(branch_chk) => {\n-                compile_submatch(opt_cx, opt_ms, opt_vals, &branch_chk)\n+                compile_submatch(opt_cx,\n+                                 opt_ms.as_slice(),\n+                                 opt_vals.as_slice(),\n+                                 &branch_chk)\n             }\n         }\n     }\n@@ -1811,7 +1849,10 @@ fn compile_submatch_continue<'r,\n             Br(bcx, else_cx.llbb);\n         }\n         if kind != single {\n-            compile_submatch(else_cx, defaults, vals_left, chk);\n+            compile_submatch(else_cx,\n+                             defaults.as_slice(),\n+                             vals_left.as_slice(),\n+                             chk);\n         }\n     }\n }\n@@ -1921,7 +1962,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         }\n     };\n     let lldiscr = discr_datum.val;\n-    compile_submatch(bcx, matches, [lldiscr], &chk);\n+    compile_submatch(bcx, matches.as_slice(), [lldiscr], &chk);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1944,7 +1985,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs);\n+    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.as_slice());\n     return bcx;\n }\n "}, {"sha": "00a93b66ce0175b59d46fb91548f4bed3200fb58", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 62, "deletions": 33, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -53,17 +53,18 @@ use middle::trans::_match;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n use middle::ty::Disr;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::ast;\n use syntax::attr;\n use syntax::attr::IntType;\n use util::ppaux::ty_to_str;\n \n-use middle::trans::type_::Type;\n-\n type Hint = attr::ReprAttr;\n \n \n@@ -136,7 +137,7 @@ pub fn represent_type(cx: &CrateContext, t: ty::t) -> @Repr {\n fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n     match ty::get(t).sty {\n         ty::ty_tup(ref elems) => {\n-            return Univariant(mk_struct(cx, *elems, false), false)\n+            return Univariant(mk_struct(cx, elems.as_slice(), false), false)\n         }\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx, def_id);\n@@ -147,7 +148,7 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let dtor = ty::ty_dtor(cx.tcx, def_id).has_drop_flag();\n             if dtor { ftys.push(ty::mk_bool()); }\n \n-            return Univariant(mk_struct(cx, ftys, packed), dtor)\n+            return Univariant(mk_struct(cx, ftys.as_slice(), packed), dtor)\n         }\n         ty::ty_enum(def_id, ref substs) => {\n             let cases = get_cases(cx.tcx, def_id, substs);\n@@ -185,23 +186,29 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n                 // Equivalent to a struct/tuple/newtype.\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n-                return Univariant(mk_struct(cx, cases[0].tys, false), false)\n+                return Univariant(mk_struct(cx,\n+                                            cases.get(0).tys.as_slice(),\n+                                            false),\n+                                  false)\n             }\n \n             if cases.len() == 2 && hint == attr::ReprAny {\n                 // Nullable pointer optimization\n                 let mut discr = 0;\n                 while discr < 2 {\n-                    if cases[1 - discr].is_zerolen(cx) {\n-                        match cases[discr].find_ptr() {\n+                    if cases.get(1 - discr).is_zerolen(cx) {\n+                        match cases.get(discr).find_ptr() {\n                             Some(ptrfield) => {\n                                 return NullablePointer {\n-                                    nndiscr: discr,\n+                                    nndiscr: discr as u64,\n                                     nonnull: mk_struct(cx,\n-                                                       cases[discr].tys,\n+                                                       cases.get(discr)\n+                                                            .tys\n+                                                            .as_slice(),\n                                                        false),\n                                     ptrfield: ptrfield,\n-                                    nullfields: cases[1 - discr].tys.clone()\n+                                    nullfields: cases.get(1 - discr).tys\n+                                                                    .clone()\n                                 }\n                             }\n                             None => { }\n@@ -216,8 +223,12 @@ fn represent_type_uncached(cx: &CrateContext, t: ty::t) -> Repr {\n             let bounds = IntBounds { ulo: 0, uhi: (cases.len() - 1) as u64,\n                                      slo: 0, shi: (cases.len() - 1) as i64 };\n             let ity = range_to_inttype(cx, hint, &bounds);\n-            let discr = vec!(ty_of_inttype(ity));\n-            return General(ity, cases.map(|c| mk_struct(cx, discr + c.tys, false)))\n+            return General(ity, cases.map(|c| {\n+                let discr = vec!(ty_of_inttype(ity));\n+                mk_struct(cx,\n+                          vec_ng::append(discr, c.tys.as_slice()).as_slice(),\n+                          false)\n+            }))\n         }\n         _ => cx.sess.bug(\"adt::represent_type called on non-ADT type\")\n     }\n@@ -256,7 +267,7 @@ pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n struct Case { discr: Disr, tys: Vec<ty::t> }\n impl Case {\n     fn is_zerolen(&self, cx: &CrateContext) -> bool {\n-        mk_struct(cx, self.tys, false).size == 0\n+        mk_struct(cx, self.tys.as_slice(), false).size == 0\n     }\n     fn find_ptr(&self) -> Option<uint> {\n         self.tys.iter().position(|&ty| mono_data_classify(ty) == MonoNonNull)\n@@ -280,7 +291,7 @@ fn mk_struct(cx: &CrateContext, tys: &[ty::t], packed: bool) -> Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec) /*bad*/as u64,\n         align: machine::llalign_of_min(cx, llty_rec) /*bad*/as u64,\n         packed: packed,\n-        fields: tys.to_owned(),\n+        fields: Vec::from_slice(tys),\n     }\n }\n \n@@ -393,7 +404,8 @@ pub fn finish_type_of(cx: &CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n         CEnum(..) | General(..) => { }\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false), st.packed)\n+            llty.set_struct_body(struct_llfields(cx, st, false).as_slice(),\n+                                 st.packed)\n     }\n }\n \n@@ -402,7 +414,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n         Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n             match name {\n-                None => Type::struct_(struct_llfields(cx, st, sizing), st.packed),\n+                None => {\n+                    Type::struct_(struct_llfields(cx, st, sizing).as_slice(),\n+                                  st.packed)\n+                }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(name) }\n             }\n         }\n@@ -441,10 +456,10 @@ fn generic_type_of(cx: &CrateContext, r: &Repr, name: Option<&str>, sizing: bool\n                            Type::array(&discr_ty, align / discr_size - 1),\n                            pad_ty);\n             match name {\n-                None => Type::struct_(fields, false),\n+                None => Type::struct_(fields.as_slice(), false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(name);\n-                    llty.set_struct_body(fields, false);\n+                    llty.set_struct_body(fields.as_slice(), false);\n                     llty\n                 }\n             }\n@@ -517,7 +532,7 @@ fn nullable_bitdiscr(bcx: &Block, nonnull: &Struct, nndiscr: Disr, ptrfield: uin\n                      scrutinee: ValueRef) -> ValueRef {\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     let llptr = Load(bcx, GEPi(bcx, scrutinee, [0, ptrfield]));\n-    let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+    let llptrty = type_of::type_of(bcx.ccx(), *nonnull.fields.get(ptrfield));\n     ICmp(bcx, cmp, llptr, C_null(llptrty))\n }\n \n@@ -598,7 +613,8 @@ pub fn trans_start_init(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr) {\n         NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n-                let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n+                let llptrty = type_of::type_of(bcx.ccx(),\n+                                               *nonnull.fields.get(ptrfield));\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n         }\n@@ -623,7 +639,7 @@ pub fn num_args(r: &Repr, discr: Disr) -> uint {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n-        General(_, ref cases) => cases[discr].fields.len() - 1,\n+        General(_, ref cases) => cases.get(discr as uint).fields.len() - 1,\n         NullablePointer{ nonnull: ref nonnull, nndiscr,\n                          nullfields: ref nullfields, .. } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n@@ -638,11 +654,11 @@ pub fn deref_ty(ccx: &CrateContext, r: &Repr) -> ty::t {\n             ccx.sess.bug(\"deref of c-like enum\")\n         }\n         Univariant(ref st, _) => {\n-            st.fields[0]\n+            *st.fields.get(0)\n         }\n         General(_, ref cases) => {\n             assert!(cases.len() == 1);\n-            cases[0].fields[0]\n+            *cases.get(0).fields.get(0)\n         }\n         NullablePointer{ .. } => {\n             ccx.sess.bug(\"deref of nullable ptr\")\n@@ -665,7 +681,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n             struct_field_ptr(bcx, st, val, ix, false)\n         }\n         General(_, ref cases) => {\n-            struct_field_ptr(bcx, &cases[discr], val, ix + 1, true)\n+            struct_field_ptr(bcx, cases.get(discr as uint), val, ix + 1, true)\n         }\n         NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields,\n                          nndiscr, .. } => {\n@@ -674,7 +690,7 @@ pub fn trans_field_ptr(bcx: &Block, r: &Repr, val: ValueRef, discr: Disr,\n             } else {\n                 // The unit-like case might have a nonzero number of unit-like fields.\n                 // (e.g., Result or Either with () as one side.)\n-                let ty = type_of::type_of(bcx.ccx(), nullfields[ix]);\n+                let ty = type_of::type_of(bcx.ccx(), *nullfields.get(ix));\n                 assert_eq!(machine::llsize_of_alloc(bcx.ccx(), ty), 0);\n                 // The contents of memory at this pointer can't matter, but use\n                 // the value that's \"reasonable\" in case of pointer comparison.\n@@ -690,7 +706,7 @@ fn struct_field_ptr(bcx: &Block, st: &Struct, val: ValueRef, ix: uint,\n \n     let val = if needs_cast {\n         let fields = st.fields.map(|&ty| type_of::type_of(ccx, ty));\n-        let real_ty = Type::struct_(fields, st.packed);\n+        let real_ty = Type::struct_(fields.as_slice(), st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -737,27 +753,40 @@ pub fn trans_const(ccx: &CrateContext, r: &Repr, discr: Disr,\n             C_integral(ll_inttype(ccx, ity), discr as u64, true)\n         }\n         General(ity, ref cases) => {\n-            let case = &cases[discr];\n+            let case = cases.get(discr as uint);\n             let max_sz = cases.iter().map(|x| x.size).max().unwrap();\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n-            let contents = build_const_struct(ccx, case, vec!(lldiscr) + vals);\n-            C_struct(contents + &[padding(max_sz - case.size)], false)\n+            let contents = build_const_struct(ccx,\n+                                              case,\n+                                              vec_ng::append(\n+                                                  vec!(lldiscr),\n+                                                  vals).as_slice());\n+            C_struct(vec_ng::append(\n+                        contents,\n+                        &[padding(max_sz - case.size)]).as_slice(),\n+                     false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(contents, st.packed)\n+            C_struct(contents.as_slice(), st.packed)\n         }\n         NullablePointer{ nonnull: ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n-                C_struct(build_const_struct(ccx, nonnull, vals), false)\n+                C_struct(build_const_struct(ccx,\n+                                            nonnull,\n+                                            vals.as_slice()).as_slice(),\n+                         false)\n             } else {\n                 let vals = nonnull.fields.map(|&ty| {\n                     // Always use null even if it's not the `ptrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n-                }).collect::<Vec<ValueRef> >();\n-                C_struct(build_const_struct(ccx, nonnull, vals), false)\n+                }).move_iter().collect::<Vec<ValueRef> >();\n+                C_struct(build_const_struct(ccx,\n+                                            nonnull,\n+                                            vals.as_slice()).as_slice(),\n+                         false)\n             }\n         }\n     }"}, {"sha": "adcef0278f8b474f199a21d39bdc8dca6f7a95e7", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -12,8 +12,6 @@\n # Translation of inline assembly.\n */\n \n-use std::c_str::ToCStr;\n-\n use lib;\n use middle::trans::build::*;\n use middle::trans::callee;\n@@ -22,9 +20,10 @@ use middle::trans::cleanup;\n use middle::trans::cleanup::CleanupMethods;\n use middle::trans::expr;\n use middle::trans::type_of;\n-\n use middle::trans::type_::Type;\n \n+use std::c_str::ToCStr;\n+use std::vec_ng::Vec;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n@@ -88,9 +87,9 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     let output_type = if num_outputs == 0 {\n         Type::void()\n     } else if num_outputs == 1 {\n-        output_types[0]\n+        *output_types.get(0)\n     } else {\n-        Type::struct_(output_types, false)\n+        Type::struct_(output_types.as_slice(), false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "362f5fbacf089bdc0f773f6aeecd53b91a179abb", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 48, "deletions": 25, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -73,11 +73,12 @@ use util::sha2::Sha256;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n+use collections::HashMap;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n use std::libc::c_uint;\n use std::local_data;\n+use std::vec_ng::Vec;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic, OsWin32};\n use syntax::ast_map::PathName;\n use syntax::ast_util::{local_def, is_local};\n@@ -99,7 +100,7 @@ local_data_key!(task_local_insn_key: Vec<&'static str> )\n pub fn with_insn_ctxt(blk: |&[&'static str]|) {\n     local_data::get(task_local_insn_key, |c| {\n         match c {\n-            Some(ctx) => blk(*ctx),\n+            Some(ctx) => blk(ctx.as_slice()),\n             None => ()\n         }\n     })\n@@ -543,7 +544,7 @@ pub fn get_res_dtor(ccx: @CrateContext,\n         let tsubsts = ty::substs {\n             regions: ty::ErasedRegions,\n             self_ty: None,\n-            tps: substs.to_owned()\n+            tps: Vec::from_slice(substs),\n         };\n \n         let vtables = typeck::check::vtable::trans_resolve_method(ccx.tcx, did.node, &tsubsts);\n@@ -752,8 +753,8 @@ pub fn iter_structural_ty<'r,\n \n           match adt::trans_switch(cx, repr, av) {\n               (_match::single, None) => {\n-                  cx = iter_variant(cx, repr, av, variants[0],\n-                                    substs.tps, f);\n+                  cx = iter_variant(cx, repr, av, *variants.get(0),\n+                                    substs.tps.as_slice(), f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n                   cx = f(cx, lldiscrim_a, ty::mk_int());\n@@ -775,8 +776,12 @@ pub fn iter_structural_ty<'r,\n                                                 in iter_structural_ty\")\n                       }\n                       let variant_cx =\n-                          iter_variant(variant_cx, repr, av, *variant,\n-                                       substs.tps, |x,y,z| f(x,y,z));\n+                          iter_variant(variant_cx,\n+                                       repr,\n+                                       av,\n+                                       *variant,\n+                                       substs.tps.as_slice(),\n+                                       |x,y,z| f(x,y,z));\n                       Br(variant_cx, next_cx.llbb);\n                   }\n                   cx = next_cx;\n@@ -876,7 +881,11 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             match fn_ty.abis.for_target(ccx.sess.targ_cfg.os,\n                                         ccx.sess.targ_cfg.arch) {\n                 Some(Rust) | Some(RustIntrinsic) => {\n-                    get_extern_rust_fn(ccx, fn_ty.sig.inputs, fn_ty.sig.output, name, did)\n+                    get_extern_rust_fn(ccx,\n+                                       fn_ty.sig.inputs.as_slice(),\n+                                       fn_ty.sig.output,\n+                                       name,\n+                                       did)\n                 }\n                 Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n@@ -889,7 +898,11 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n             }\n         }\n         ty::ty_closure(ref f) => {\n-            get_extern_rust_fn(ccx, f.sig.inputs, f.sig.output, name, did)\n+            get_extern_rust_fn(ccx,\n+                               f.sig.inputs.as_slice(),\n+                               f.sig.output,\n+                               name,\n+                               did)\n         }\n         _ => {\n             let llty = type_of(ccx, t);\n@@ -935,7 +948,7 @@ pub fn invoke<'a>(\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs,\n+                              llargs.as_slice(),\n                               normal_bcx.llbb,\n                               landing_pad,\n                               attributes);\n@@ -951,7 +964,7 @@ pub fn invoke<'a>(\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs, attributes);\n+        let llresult = Call(bcx, llfn, llargs.as_slice(), attributes);\n         return (llresult, bcx);\n     }\n }\n@@ -1231,7 +1244,10 @@ pub fn new_fn_ctxt<'a>(ccx: @CrateContext,\n     let substd_output_type = match param_substs {\n         None => output_type,\n         Some(substs) => {\n-            ty::subst_tps(ccx.tcx, substs.tys, substs.self_ty, output_type)\n+            ty::subst_tps(ccx.tcx,\n+                          substs.tys.as_slice(),\n+                          substs.self_ty,\n+                          output_type)\n         }\n     };\n     let uses_outptr = type_of::return_uses_outptr(ccx, substd_output_type);\n@@ -1289,7 +1305,7 @@ pub fn init_function<'a>(\n         None => output_type,\n         Some(substs) => {\n             ty::subst_tps(fcx.ccx.tcx,\n-                          substs.tys,\n+                          substs.tys.as_slice(),\n                           substs.self_ty,\n                           output_type)\n         }\n@@ -1472,7 +1488,7 @@ pub fn trans_closure<'a>(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     bcx = copy_args_to_allocas(&fcx,\n                                arg_scope,\n@@ -1583,7 +1599,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n     let no_substs: &[ty::t] = [];\n     let ty_param_substs = match param_substs {\n         Some(ref substs) => {\n-            let v: &[ty::t] = substs.tys;\n+            let v: &[ty::t] = substs.tys.as_slice();\n             v\n         }\n         None => {\n@@ -1612,7 +1628,7 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: @CrateContext,\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys);\n+    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.as_slice());\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n@@ -1636,7 +1652,7 @@ pub fn trans_enum_def(ccx: @CrateContext, enum_definition: &ast::EnumDef,\n                       id: ast::NodeId, vi: @Vec<@ty::VariantInfo> ,\n                       i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n-        let disr_val = vi[*i].disr_val;\n+        let disr_val = vi.get(*i).disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n@@ -1801,7 +1817,11 @@ fn register_fn(ccx: @CrateContext,\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, false, f.sig.inputs, f.sig.output, sym);\n+    let llfn = decl_rust_fn(ccx,\n+                            false,\n+                            f.sig.inputs.as_slice(),\n+                            f.sig.output,\n+                            sym);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -1893,8 +1913,10 @@ pub fn create_entry_wrapper(ccx: @CrateContext,\n                 (rust_main, args)\n             };\n \n-            let result = llvm::LLVMBuildCall(bld, start_fn,\n-                                             args.as_ptr(), args.len() as c_uint,\n+            let result = llvm::LLVMBuildCall(bld,\n+                                             start_fn,\n+                                             args.as_ptr(),\n+                                             args.len() as c_uint,\n                                              noname());\n \n             llvm::LLVMBuildRet(bld, result);\n@@ -2476,7 +2498,7 @@ pub fn create_module_map(ccx: &CrateContext) -> (ValueRef, uint) {\n         elts.push(elt);\n     }\n     unsafe {\n-        llvm::LLVMSetInitializer(map, C_array(elttype, elts));\n+        llvm::LLVMSetInitializer(map, C_array(elttype, elts.as_slice()));\n     }\n     return (map, keys.len())\n }\n@@ -2564,7 +2586,8 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n         });\n         lib::llvm::SetLinkage(vec_elements, lib::llvm::InternalLinkage);\n \n-        llvm::LLVMSetInitializer(vec_elements, C_array(ccx.int_type, subcrates));\n+        llvm::LLVMSetInitializer(vec_elements,\n+                                 C_array(ccx.int_type, subcrates.as_slice()));\n         let (mod_map, mod_count) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n@@ -2613,7 +2636,7 @@ pub fn write_metadata(cx: &CrateContext, krate: &ast::Crate) -> Vec<u8> {\n     let encode_parms = crate_ctxt_to_encode_parms(cx, encode_inlined_item);\n     let metadata = encoder::encode_metadata(encode_parms, krate);\n     let compressed = encoder::metadata_encoding_version +\n-                        flate::deflate_bytes(metadata).as_slice();\n+                        flate::deflate_bytes(metadata.as_slice()).as_slice();\n     let llmeta = C_bytes(compressed);\n     let llconst = C_struct([llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}_{}\", cx.link_meta.crateid.name,\n@@ -2744,12 +2767,12 @@ pub fn trans_crate(sess: session::Session,\n     let link_meta = ccx.link_meta.clone();\n     let llmod = ccx.llmod;\n \n-    let mut reachable = {\n+    let mut reachable: Vec<~str> = {\n         let reachable_map = ccx.reachable.borrow();\n         reachable_map.get().iter().filter_map(|id| {\n             let item_symbols = ccx.item_symbols.borrow();\n             item_symbols.get().find(id).map(|s| s.to_owned())\n-        }).to_owned_vec()\n+        }).collect()\n     };\n \n     // Make sure that some other crucial symbols are not eliminated from the"}, {"sha": "15e74b1b55d434c93f91e787e68c50c53a977772", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -17,8 +17,10 @@ use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n-use std::libc::{c_uint, c_ulonglong, c_char};\n+\n use collections::HashMap;\n+use std::libc::{c_uint, c_ulonglong, c_char};\n+use std::vec_ng::Vec;\n use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n@@ -542,7 +544,7 @@ impl<'a> Builder<'a> {\n         } else {\n             let v = ixs.iter().map(|i| C_i32(*i as i32)).collect::<Vec<ValueRef> >();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v)\n+            self.inbounds_gep(base, v.as_slice())\n         }\n     }\n "}, {"sha": "b8ab8d81d2f1adede8e7dfdc2f0513f7dd0b9f04", "filename": "src/librustc/middle/trans/cabi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -16,6 +16,7 @@ use middle::trans::cabi_x86_64;\n use middle::trans::cabi_arm;\n use middle::trans::cabi_mips;\n use middle::trans::type_::Type;\n+use std::vec_ng::Vec;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n #[deriving(Clone, Eq)]"}, {"sha": "341844a3be0a0c7d134c392396447ff806743b4c", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -14,11 +14,11 @@ use lib::llvm::{llvm, Integer, Pointer, Float, Double, Struct, Array};\n use lib::llvm::StructRetAttribute;\n use middle::trans::cabi::{FnType, ArgType};\n use middle::trans::context::CrateContext;\n-\n use middle::trans::type_::Type;\n \n use std::cmp;\n use std::option::{None, Some};\n+use std::vec_ng::Vec;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;"}, {"sha": "4bd695422a2bf77ae53b66fe722cbb1d360506db", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -17,9 +17,10 @@ use lib::llvm::StructRetAttribute;\n use middle::trans::context::CrateContext;\n use middle::trans::context::task_llcx;\n use middle::trans::cabi::*;\n-\n use middle::trans::type_::Type;\n \n+use std::vec_ng::Vec;\n+\n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n }\n@@ -155,7 +156,7 @@ fn coerce_to_int(size: uint) -> Vec<Type> {\n fn struct_ty(ty: Type) -> Type {\n     let size = ty_size(ty) * 8;\n     let fields = coerce_to_int(size);\n-    return Type::struct_(fields, false);\n+    return Type::struct_(fields.as_slice(), false);\n }\n \n pub fn compute_abi_info(_ccx: &CrateContext,"}, {"sha": "194197e50118b42326057df0bacecdb6455c8c0f", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -15,6 +15,7 @@ use super::cabi::*;\n use super::common::*;\n use super::machine::*;\n use middle::trans::type_::Type;\n+use std::vec_ng::Vec;\n \n pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],"}, {"sha": "d3ffa7865a228a7290d9284cd74b5d6ceb52d197", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -18,11 +18,10 @@ use lib::llvm::{Struct, Array, Attribute};\n use lib::llvm::{StructRetAttribute, ByValAttribute};\n use middle::trans::cabi::*;\n use middle::trans::context::CrateContext;\n-\n use middle::trans::type_::Type;\n \n use std::cmp;\n-use std::vec;\n+use std::vec_ng::Vec;\n \n #[deriving(Clone, Eq)]\n enum RegClass {\n@@ -220,7 +219,7 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n                 unify(cls, ix + off / 8u, SSEDs);\n             }\n             Struct => {\n-                classify_struct(ty.field_types(), cls, ix, off);\n+                classify_struct(ty.field_types().as_slice(), cls, ix, off);\n             }\n             Array => {\n                 let len = ty.array_length();\n@@ -282,13 +281,13 @@ fn classify_ty(ty: Type) -> Vec<RegClass> {\n     }\n \n     let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = vec::from_elem(words, NoClass);\n+    let mut cls = Vec::from_elem(words, NoClass);\n     if words > 4 {\n-        all_mem(cls);\n+        all_mem(cls.as_mut_slice());\n         return cls;\n     }\n-    classify(ty, cls, 0, 0);\n-    fixup(ty, cls);\n+    classify(ty, cls.as_mut_slice(), 0, 0);\n+    fixup(ty, cls.as_mut_slice());\n     return cls;\n }\n \n@@ -329,7 +328,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n         }\n         i += 1u;\n     }\n-    return Type::struct_(tys, false);\n+    return Type::struct_(tys.as_slice(), false);\n }\n \n pub fn compute_abi_info(_ccx: &CrateContext,\n@@ -342,10 +341,13 @@ pub fn compute_abi_info(_ccx: &CrateContext,\n                  -> ArgType {\n         if !ty.is_reg_ty() {\n             let cls = classify_ty(ty);\n-            if is_mem_cls(cls) {\n+            if is_mem_cls(cls.as_slice()) {\n                 ArgType::indirect(ty, Some(attr))\n             } else {\n-                ArgType::direct(ty, Some(llreg_ty(cls)), None, None)\n+                ArgType::direct(ty,\n+                                Some(llreg_ty(cls.as_slice())),\n+                                None,\n+                                None)\n             }\n         } else {\n             ArgType::direct(ty, None, None, None)"}, {"sha": "1ede187245e6dff0620c6d090dbecb99eb52974e", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -48,6 +48,8 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n@@ -174,7 +176,12 @@ pub fn trans_fn_ref(bcx: &Block, def_id: ast::DefId,\n     debug!(\"trans_fn_ref(def_id={}, ref_id={:?}, type_params={}, vtables={})\",\n            def_id.repr(bcx.tcx()), ref_id, type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n-    trans_fn_ref_with_vtables(bcx, def_id, ref_id, is_method, type_params, vtables)\n+    trans_fn_ref_with_vtables(bcx,\n+                              def_id,\n+                              ref_id,\n+                              is_method,\n+                              type_params.as_slice(),\n+                              vtables)\n }\n \n fn trans_fn_ref_with_vtables_to_callee<'a>(bcx: &'a Block<'a>,\n@@ -221,7 +228,8 @@ fn resolve_default_method_vtables(bcx: &Block,\n         None => vec::from_elem(num_method_vtables, @Vec::new())\n     };\n \n-    let param_vtables = @(*trait_vtables_fixed + method_vtables);\n+    let param_vtables = @(vec_ng::append((*trait_vtables_fixed).clone(),\n+                                          method_vtables));\n \n     let self_vtables = resolve_param_vtables_under_param_substs(\n         bcx.tcx(), param_substs, impl_res.self_vtables);\n@@ -272,7 +280,7 @@ pub fn trans_fn_ref_with_vtables(\n \n     let substs = ty::substs { regions: ty::ErasedRegions,\n                               self_ty: None,\n-                              tps: /*bad*/ type_params.to_owned() };\n+                              tps: /*bad*/ Vec::from_slice(type_params) };\n \n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_method(tcx, def_id) {\n@@ -683,7 +691,11 @@ pub fn trans_call_inner<'a>(\n         }\n \n         // Invoke the actual rust fn and update bcx/llresult.\n-        let (llret, b) = base::invoke(bcx, llfn, llargs, attrs, call_info);\n+        let (llret, b) = base::invoke(bcx,\n+                                      llfn,\n+                                      llargs,\n+                                      attrs.as_slice(),\n+                                      call_info);\n         bcx = b;\n         llresult = llret;\n \n@@ -712,8 +724,12 @@ pub fn trans_call_inner<'a>(\n             ArgExprs(a) => a.iter().map(|x| expr_ty(bcx, *x)).collect(),\n             _ => fail!(\"expected arg exprs.\")\n         };\n-        bcx = foreign::trans_native_call(bcx, callee_ty,\n-                                         llfn, opt_llretslot.unwrap(), llargs, arg_tys);\n+        bcx = foreign::trans_native_call(bcx,\n+                                         callee_ty,\n+                                         llfn,\n+                                         opt_llretslot.unwrap(),\n+                                         llargs.as_slice(),\n+                                         arg_tys);\n     }\n \n     // If the caller doesn't care about the result of this fn call,\n@@ -770,7 +786,7 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n                     assert!(variadic);\n                     expr_ty_adjusted(cx, *arg_expr)\n                 } else {\n-                    arg_tys[i]\n+                    *arg_tys.get(i)\n                 };\n                 llargs.push(unpack_result!(bcx, {\n                     trans_arg_expr(bcx, arg_ty, *arg_expr,\n@@ -783,7 +799,7 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n             assert!(!variadic);\n \n             llargs.push(unpack_result!(bcx, {\n-                trans_arg_expr(bcx, arg_tys[0], arg_expr,\n+                trans_arg_expr(bcx, *arg_tys.get(0), arg_expr,\n                                arg_cleanup_scope,\n                                DontAutorefArg)\n             }));\n@@ -793,7 +809,7 @@ fn trans_args<'a>(cx: &'a Block<'a>,\n                     assert_eq!(arg_tys.len(), 2);\n \n                     llargs.push(unpack_result!(bcx, {\n-                        trans_arg_expr(bcx, arg_tys[1], arg2_expr,\n+                        trans_arg_expr(bcx, *arg_tys.get(1), arg2_expr,\n                                        arg_cleanup_scope,\n                                        DoAutorefArg)\n                     }));"}, {"sha": "be5eab0e8eca735b8d3fc6a8097b15f4a0349be9", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -349,7 +349,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n         assert!(self.is_valid_custom_scope(custom_scope));\n \n         let mut scopes = self.scopes.borrow_mut();\n-        let scope = &mut scopes.get()[custom_scope.index];\n+        let scope = scopes.get().get_mut(custom_scope.index);\n         scope.cleanups.push(cleanup);\n         scope.clear_cached_exits();\n     }\n@@ -433,7 +433,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n     fn is_valid_custom_scope(&self, custom_scope: CustomScopeIndex) -> bool {\n         let scopes = self.scopes.borrow();\n         custom_scope.index < scopes.get().len() &&\n-            scopes.get()[custom_scope.index].kind.is_temp()\n+            scopes.get().get(custom_scope.index).kind.is_temp()\n     }\n \n     fn trans_scope_cleanups(&self, // cannot borrow self, will recurse"}, {"sha": "f18456a674dd257d5c5adf5568569b217de8cc1e", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -27,6 +27,7 @@ use util::ppaux::Repr;\n use util::ppaux::ty_to_str;\n \n use arena::TypedArena;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -139,12 +140,12 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     // is the actual types that will be stored in the map, not the\n     // logical types as the user sees them, so by-ref upvars must be\n     // converted to ptrs.\n-    let bound_tys = bound_values.map(|bv| {\n+    let bound_tys = bound_values.iter().map(|bv| {\n         match bv.action {\n             EnvCopy | EnvMove => bv.datum.ty,\n             EnvRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n         }\n-    });\n+    }).collect();\n     let cdata_ty = ty::mk_tup(tcx, bound_tys);\n     debug!(\"cdata_ty={}\", ty_to_str(tcx, cdata_ty));\n     return cdata_ty;\n@@ -199,7 +200,7 @@ pub fn store_environment<'a>(\n     let tcx = ccx.tcx;\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values);\n+    let cdata_ty = mk_closure_tys(tcx, bound_values.as_slice());\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -387,7 +388,11 @@ pub fn trans_expr_fn<'a>(\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, s);\n+    let llfn = decl_internal_rust_fn(ccx,\n+                                     true,\n+                                     f.sig.inputs.as_slice(),\n+                                     f.sig.output,\n+                                     s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -396,11 +401,17 @@ pub fn trans_expr_fn<'a>(\n         let capture_map = ccx.maps.capture_map.borrow();\n         capture_map.get().get_copy(&id)\n     };\n-    let ClosureResult {llbox, cdata_ty, bcx} = build_closure(bcx, *cap_vars.borrow(), sigil);\n+    let ClosureResult {llbox, cdata_ty, bcx} =\n+        build_closure(bcx, cap_vars.borrow().as_slice(), sigil);\n     trans_closure(ccx, decl, body, llfn,\n                   bcx.fcx.param_substs, id,\n                   [], ty::ty_fn_ret(fty),\n-                  |bcx| load_environment(bcx, cdata_ty, *cap_vars.borrow(), sigil));\n+                  |bcx| {\n+                      load_environment(bcx,\n+                                       cdata_ty,\n+                                       cap_vars.borrow().as_slice(),\n+                                       sigil)\n+                  });\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n \n     bcx\n@@ -447,9 +458,13 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n         mangle_internal_name_by_path_and_seq(path, \"as_closure\")\n     });\n     let llfn = if is_local {\n-        decl_internal_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n+        decl_internal_rust_fn(ccx,\n+                              true,\n+                              f.sig.inputs.as_slice(),\n+                              f.sig.output,\n+                              name)\n     } else {\n-        decl_rust_fn(ccx, true, f.sig.inputs, f.sig.output, name)\n+        decl_rust_fn(ccx, true, f.sig.inputs.as_slice(), f.sig.output, name)\n     };\n \n     {\n@@ -470,7 +485,9 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     init_function(&fcx, true, f.sig.output, None);\n     let bcx = fcx.entry_bcx.get().unwrap();\n \n-    let args = create_datums_for_fn_args(&fcx, ty::ty_fn_args(closure_ty));\n+    let args = create_datums_for_fn_args(&fcx,\n+                                         ty::ty_fn_args(closure_ty)\n+                                            .as_slice());\n     let mut llargs = Vec::new();\n     match fcx.llretptr.get() {\n         Some(llretptr) => {\n@@ -480,7 +497,7 @@ pub fn get_wrapper_for_bare_fn(ccx: @CrateContext,\n     }\n     llargs.extend(&mut args.iter().map(|arg| arg.val));\n \n-    let retval = Call(bcx, fn_ptr, llargs, []);\n+    let retval = Call(bcx, fn_ptr, llargs.as_slice(), []);\n     if type_is_zero_size(ccx, f.sig.output) || fcx.llretptr.get().is_some() {\n         RetVoid(bcx);\n     } else {"}, {"sha": "4194f3ff57c06c8b5409b76d690fd7ebc815cc74", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -32,10 +32,11 @@ use util::ppaux::Repr;\n use util::nodemap::NodeMap;\n \n use arena::TypedArena;\n+use collections::HashMap;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n use std::libc::{c_uint, c_longlong, c_ulonglong, c_char};\n+use std::vec_ng::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathName};\n@@ -50,8 +51,9 @@ fn type_is_newtype_immediate(ccx: &CrateContext, ty: ty::t) -> bool {\n         ty::ty_struct(def_id, ref substs) => {\n             let fields = ty::struct_fields(ccx.tcx, def_id, substs);\n             fields.len() == 1 &&\n-                fields[0].ident.name == token::special_idents::unnamed_field.name &&\n-                type_is_immediate(ccx, fields[0].mt.ty)\n+                fields.get(0).ident.name ==\n+                    token::special_idents::unnamed_field.name &&\n+                type_is_immediate(ccx, fields.get(0).mt.ty)\n         }\n         _ => false\n     }\n@@ -781,7 +783,7 @@ pub fn align_to(cx: &Block, off: ValueRef, align: ValueRef) -> ValueRef {\n pub fn monomorphize_type(bcx: &Block, t: ty::t) -> ty::t {\n     match bcx.fcx.param_substs {\n         Some(substs) => {\n-            ty::subst_tps(bcx.tcx(), substs.tys, substs.self_ty, t)\n+            ty::subst_tps(bcx.tcx(), substs.tys.as_slice(), substs.self_ty, t)\n         }\n         _ => {\n             assert!(!ty::type_has_params(t));\n@@ -824,7 +826,7 @@ pub fn node_id_type_params(bcx: &Block, id: ast::NodeId, is_method: bool) -> Vec\n     match bcx.fcx.param_substs {\n       Some(substs) => {\n         params.iter().map(|t| {\n-            ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n+            ty::subst_tps(tcx, substs.tys.as_slice(), substs.self_ty, *t)\n         }).collect()\n       }\n       _ => params\n@@ -881,10 +883,13 @@ pub fn resolve_vtable_under_param_substs(tcx: ty::ctxt,\n             let tys = match param_substs {\n                 Some(substs) => {\n                     tys.iter().map(|t| {\n-                        ty::subst_tps(tcx, substs.tys, substs.self_ty, *t)\n+                        ty::subst_tps(tcx,\n+                                      substs.tys.as_slice(),\n+                                      substs.self_ty,\n+                                      *t)\n                     }).collect()\n                 }\n-                _ => tys.to_owned()\n+                _ => Vec::from_slice(tys.as_slice())\n             };\n             typeck::vtable_static(\n                 trait_id, tys,\n@@ -918,10 +923,10 @@ pub fn find_vtable(tcx: ty::ctxt,\n         typeck::param_numbered(n) => {\n             let tables = ps.vtables\n                 .expect(\"vtables missing where they are needed\");\n-            tables[n]\n+            *tables.get(n)\n         }\n     };\n-    param_bounds[n_bound].clone()\n+    param_bounds.get(n_bound).clone()\n }\n \n pub fn dummy_substs(tps: Vec<ty::t> ) -> ty::substs {"}, {"sha": "f1e6fff533985cfd12f5ca505793d124d8254966", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -25,15 +25,16 @@ use middle::trans::consts;\n use middle::trans::expr;\n use middle::trans::inline;\n use middle::trans::machine;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::ty;\n use util::ppaux::{Repr, ty_to_str};\n \n-use middle::trans::type_::Type;\n-\n use std::c_str::ToCStr;\n use std::libc::c_uint;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::{ast, ast_util};\n \n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: ast::Lit)\n@@ -303,8 +304,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n     let map_list = |exprs: &[@ast::Expr]| {\n         exprs.iter().map(|&e| const_expr(cx, e, is_local))\n              .fold((Vec::new(), true),\n-                   |(L, all_inlineable), (val, inlineable)| {\n-                (vec::append_one(L, val), all_inlineable && inlineable)\n+                   |(l, all_inlineable), (val, inlineable)| {\n+                (vec_ng::append_one(l, val), all_inlineable && inlineable)\n              })\n     };\n     unsafe {\n@@ -533,7 +534,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n               let ety = ty::expr_ty(cx.tcx, e);\n               let repr = adt::represent_type(cx, ety);\n               let (vals, inlineable) = map_list(es.as_slice());\n-              (adt::trans_const(cx, repr, 0, vals), inlineable)\n+              (adt::trans_const(cx, repr, 0, vals.as_slice()), inlineable)\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx, e);\n@@ -667,7 +668,8 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                       let ety = ty::expr_ty(cx.tcx, e);\n                       let repr = adt::represent_type(cx, ety);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, repr, 0, arg_vals), inlineable)\n+                      (adt::trans_const(cx, repr, 0, arg_vals.as_slice()),\n+                       inlineable)\n                   }\n                   Some(ast::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx, e);\n@@ -676,8 +678,10 @@ fn const_expr_unadjusted(cx: @CrateContext, e: &ast::Expr,\n                                                            enum_did,\n                                                            variant_did);\n                       let (arg_vals, inlineable) = map_list(args.as_slice());\n-                      (adt::trans_const(cx, repr, vinfo.disr_val, arg_vals),\n-                       inlineable)\n+                      (adt::trans_const(cx,\n+                                        repr,\n+                                        vinfo.disr_val,\n+                                        arg_vals.as_slice()), inlineable)\n                   }\n                   _ => cx.sess.span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "517bef52a9939f448373d31f1212e39674c007b4", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -33,6 +33,7 @@ use std::cell::{Cell, RefCell};\n use std::c_str::ToCStr;\n use std::local_data;\n use std::libc::c_uint;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::parse::token::InternedString;"}, {"sha": "261660c13bb2a39316c47fc2bffacd1ca2d3a00a", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -343,7 +343,10 @@ pub fn trans_fail<'a>(\n     let v_filename = PointerCast(bcx, v_filename, Type::i8p());\n     let args = vec!(v_str, v_filename, C_int(ccx, v_line));\n     let did = langcall(bcx, Some(sp), \"\", FailFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n+    let bcx = callee::trans_lang_call(bcx,\n+                                      did,\n+                                      args.as_slice(),\n+                                      Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n }\n@@ -358,7 +361,10 @@ pub fn trans_fail_bounds_check<'a>(\n     let (filename, line) = filename_and_line_num_from_span(bcx, sp);\n     let args = vec!(filename, line, index, len);\n     let did = langcall(bcx, Some(sp), \"\", FailBoundsCheckFnLangItem);\n-    let bcx = callee::trans_lang_call(bcx, did, args, Some(expr::Ignore)).bcx;\n+    let bcx = callee::trans_lang_call(bcx,\n+                                      did,\n+                                      args.as_slice(),\n+                                      Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "0e7c371b43d7f10554d49e9a8ef7cbe542dfb785", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 65, "deletions": 44, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -149,6 +149,7 @@ use std::libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n use std::sync::atomics;\n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token;\n@@ -725,7 +726,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                 let return_type = match param_substs {\n                     None => return_type,\n                     Some(substs) => {\n-                        ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, return_type)\n+                        ty::subst_tps(cx.tcx,\n+                                      substs.tys.as_slice(),\n+                                      substs.self_ty,\n+                                      return_type)\n                     }\n                 };\n \n@@ -740,7 +744,10 @@ pub fn create_function_debug_context(cx: &CrateContext,\n             let arg_type = match param_substs {\n                 None => arg_type,\n                 Some(substs) => {\n-                    ty::subst_tps(cx.tcx, substs.tys, substs.self_ty, arg_type)\n+                    ty::subst_tps(cx.tcx,\n+                                  substs.tys.as_slice(),\n+                                  substs.self_ty,\n+                                  arg_type)\n                 }\n             };\n \n@@ -771,7 +778,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         name_to_append_suffix_to.push_char('<');\n \n         // The list to be filled with template parameters:\n-        let mut template_params: Vec<DIDescriptor> = vec::with_capacity(generics.ty_params.len() + 1);\n+        let mut template_params: Vec<DIDescriptor> =\n+            Vec::with_capacity(generics.ty_params.len() + 1);\n \n         // Handle self type\n         if has_self_type {\n@@ -814,12 +822,12 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         let actual_types = match param_substs {\n             Some(param_substs) => &param_substs.tys,\n             None => {\n-                return create_DIArray(DIB(cx), template_params);\n+                return create_DIArray(DIB(cx), template_params.as_slice());\n             }\n         };\n \n         for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n-            let actual_type = actual_types[index];\n+            let actual_type = *actual_types.get(index);\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n             name_to_append_suffix_to.push_str(actual_type_name);\n@@ -850,7 +858,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n \n         name_to_append_suffix_to.push_char('>');\n \n-        return create_DIArray(DIB(cx), template_params);\n+        return create_DIArray(DIB(cx), template_params.as_slice());\n     }\n }\n \n@@ -1250,7 +1258,7 @@ impl RecursiveTypeDescription {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions,\n+                                              member_descriptions.as_slice(),\n                                               file_metadata,\n                                               codemap::DUMMY_SP);\n                 return metadata_stub;\n@@ -1300,7 +1308,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n         llvm_type: tuple_llvm_type,\n         file_metadata: file_metadata,\n         member_description_factory: TupleMD(TupleMemberDescriptionFactory {\n-            component_types: component_types.to_owned(),\n+            component_types: Vec::from_slice(component_types),\n             span: span,\n         })\n     }\n@@ -1331,7 +1339,7 @@ impl GeneralMemberDescriptionFactory {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          self.variants[i],\n+                                          *self.variants.get(i),\n                                           Some(self.discriminant_type_metadata),\n                                           self.containing_scope,\n                                           self.file_metadata,\n@@ -1343,7 +1351,7 @@ impl GeneralMemberDescriptionFactory {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              member_descriptions,\n+                                              member_descriptions.as_slice(),\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n                 MemberDescription {\n@@ -1387,8 +1395,11 @@ fn describe_enum_variant(cx: &CrateContext,\n                          file_metadata: DIFile,\n                          span: Span)\n                       -> (DICompositeType, Type, MemberDescriptionFactory) {\n-    let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n-                                          struct_def.packed);\n+    let variant_llvm_type =\n+        Type::struct_(struct_def.fields\n+                                .map(|&t| type_of::type_of(cx, t))\n+                                .as_slice(),\n+                      struct_def.packed);\n     // Could some consistency checks here: size, align, field count, discr type\n \n     // Find the source code location of the variant's definition\n@@ -1491,7 +1502,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                     loc.line as c_uint,\n                     bytes_to_bits(discriminant_size),\n                     bytes_to_bits(discriminant_align),\n-                    create_DIArray(DIB(cx), enumerators_metadata),\n+                    create_DIArray(DIB(cx), enumerators_metadata.as_slice()),\n                     discriminant_base_type_metadata)\n             }\n         })\n@@ -1507,13 +1518,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n             assert!(variants.len() == 1);\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_enum_variant(cx,\n-                                                                     struct_def,\n-                                                                     variants[0],\n-                                                                     None,\n-                                                                     containing_scope,\n-                                                                     file_metadata,\n-                                                                     span);\n+                 member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          struct_def,\n+                                          *variants.get(0),\n+                                          None,\n+                                          containing_scope,\n+                                          file_metadata,\n+                                          span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1565,13 +1577,14 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n-                 member_description_factory) = describe_enum_variant(cx,\n-                                                                     struct_def,\n-                                                                     variants[nndiscr],\n-                                                                     None,\n-                                                                     containing_scope,\n-                                                                     file_metadata,\n-                                                                     span);\n+                 member_description_factory) =\n+                    describe_enum_variant(cx,\n+                                          struct_def,\n+                                          *variants.get(nndiscr as uint),\n+                                          None,\n+                                          containing_scope,\n+                                          file_metadata,\n+                                          span);\n             UnfinishedMetadata {\n                 cache_id: cache_id_for_type(enum_type),\n                 metadata_stub: metadata_stub,\n@@ -1679,7 +1692,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata);\n+        let type_array = create_DIArray(DIB(cx), member_metadata.as_slice());\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -1739,7 +1752,9 @@ fn boxed_type_metadata(cx: &CrateContext,\n \n     let box_llvm_type = Type::at_box(cx, content_llvm_type);\n     let member_llvm_types = box_llvm_type.field_types();\n-    assert!(box_layout_is_correct(cx, member_llvm_types, content_llvm_type));\n+    assert!(box_layout_is_correct(cx,\n+                                  member_llvm_types.as_slice(),\n+                                  content_llvm_type));\n \n     let int_type = ty::mk_int();\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx);\n@@ -1748,31 +1763,31 @@ fn boxed_type_metadata(cx: &CrateContext,\n     let member_descriptions = [\n         MemberDescription {\n             name: ~\"refcnt\",\n-            llvm_type: member_llvm_types[0],\n+            llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, int_type, codemap::DUMMY_SP),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"drop_glue\",\n-            llvm_type: member_llvm_types[1],\n+            llvm_type: *member_llvm_types.get(1),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"prev\",\n-            llvm_type: member_llvm_types[2],\n+            llvm_type: *member_llvm_types.get(2),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"next\",\n-            llvm_type: member_llvm_types[3],\n+            llvm_type: *member_llvm_types.get(3),\n             type_metadata: nil_pointer_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"val\",\n-            llvm_type: member_llvm_types[4],\n+            llvm_type: *member_llvm_types.get(4),\n             type_metadata: content_type_metadata,\n             offset: ComputedMemberOffset,\n         }\n@@ -1859,19 +1874,19 @@ fn vec_metadata(cx: &CrateContext,\n     let member_descriptions = [\n         MemberDescription {\n             name: ~\"fill\",\n-            llvm_type: member_llvm_types[0],\n+            llvm_type: *member_llvm_types.get(0),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"alloc\",\n-            llvm_type: member_llvm_types[1],\n+            llvm_type: *member_llvm_types.get(1),\n             type_metadata: int_type_metadata,\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"elements\",\n-            llvm_type: member_llvm_types[2],\n+            llvm_type: *member_llvm_types.get(2),\n             type_metadata: array_type_metadata,\n             offset: ComputedMemberOffset,\n         }\n@@ -1904,20 +1919,22 @@ fn vec_slice_metadata(cx: &CrateContext,\n     let slice_type_name = ppaux::ty_to_str(cx.tcx, vec_type);\n \n     let member_llvm_types = slice_llvm_type.field_types();\n-    assert!(slice_layout_is_correct(cx, member_llvm_types, element_type));\n+    assert!(slice_layout_is_correct(cx,\n+                                    member_llvm_types.as_slice(),\n+                                    element_type));\n \n     let data_ptr_type = ty::mk_ptr(cx.tcx, ty::mt { ty: element_type, mutbl: ast::MutImmutable });\n \n     let member_descriptions = [\n         MemberDescription {\n             name: ~\"data_ptr\",\n-            llvm_type: member_llvm_types[0],\n+            llvm_type: *member_llvm_types.get(0),\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n             offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: ~\"length\",\n-            llvm_type: member_llvm_types[1],\n+            llvm_type: *member_llvm_types.get(1),\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n             offset: ComputedMemberOffset,\n         },\n@@ -1954,7 +1971,8 @@ fn subroutine_type_metadata(cx: &CrateContext,\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let mut signature_metadata: Vec<DIType> = vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> =\n+        Vec::with_capacity(signature.inputs.len() + 1);\n \n     // return type\n     signature_metadata.push(match ty::get(signature.output).sty {\n@@ -1971,7 +1989,7 @@ fn subroutine_type_metadata(cx: &CrateContext,\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n             file_metadata,\n-            create_DIArray(DIB(cx), signature_metadata))\n+            create_DIArray(DIB(cx), signature_metadata.as_slice()))\n     };\n }\n \n@@ -1993,7 +2011,7 @@ fn trait_metadata(cx: &CrateContext,\n                ident_string.get();\n     // Add type and region parameters\n     let name = ppaux::parameterized(cx.tcx, name, &substs.regions,\n-                                    substs.tps, def_id, true);\n+                                    substs.tps.as_slice(), def_id, true);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id);\n \n@@ -2121,7 +2139,10 @@ fn type_metadata(cx: &CrateContext,\n             }\n         },\n         ty::ty_tup(ref elements) => {\n-            prepare_tuple_metadata(cx, t, *elements, usage_site_span).finalize(cx)\n+            prepare_tuple_metadata(cx,\n+                                   t,\n+                                   elements.as_slice(),\n+                                   usage_site_span).finalize(cx)\n         }\n         _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };"}, {"sha": "be0faf2b6445d6f38791225912d65d2579570475", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -71,6 +71,7 @@ use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n \n use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::codemap;\n@@ -743,7 +744,7 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n             let numbered_fields: Vec<(uint, @ast::Expr)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-            trans_adt(bcx, repr, 0, numbered_fields, None, dest)\n+            trans_adt(bcx, repr, 0, numbered_fields.as_slice(), None, dest)\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n@@ -973,7 +974,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n \n     match ty::get(ty).sty {\n         ty::ty_struct(did, ref substs) => {\n-            op(0, struct_fields(tcx, did, substs))\n+            op(0, struct_fields(tcx, did, substs).as_slice())\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -995,7 +996,9 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n                             op(variant_info.disr_val,\n-                               struct_fields(tcx, variant_id, substs))\n+                               struct_fields(tcx,\n+                                             variant_id,\n+                                             substs).as_slice())\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\"}, {"sha": "374c85ffa6af105bacb413085b35744abea5422e", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -27,6 +27,7 @@ use middle::ty::FnSig;\n use middle::ty;\n use std::cmp;\n use std::libc::c_uint;\n+use std::vec_ng::Vec;\n use syntax::abi::{Cdecl, Aapcs, C, AbiSet, Win64};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall, System};\n use syntax::codemap::Span;\n@@ -196,14 +197,14 @@ pub fn trans_native_call<'a>(\n         ty::ty_bare_fn(ref fn_ty) => (fn_ty.abis, fn_ty.sig.clone()),\n         _ => ccx.sess.bug(\"trans_native_call called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys);\n+    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.as_slice());\n     let ret_def = !return_type_is_void(bcx.ccx(), fn_sig.output);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys,\n+                                         llsig.llarg_tys.as_slice(),\n                                          llsig.llret_ty,\n                                          ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys;\n+    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.as_slice();\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -228,7 +229,8 @@ pub fn trans_native_call<'a>(\n         let mut llarg_rust = llarg_rust;\n \n         // Does Rust pass this argument by pointer?\n-        let rust_indirect = type_of::arg_is_indirect(ccx, passed_arg_tys[i]);\n+        let rust_indirect = type_of::arg_is_indirect(ccx,\n+                                                     *passed_arg_tys.get(i));\n \n         debug!(\"argument {}, llarg_rust={}, rust_indirect={}, arg_ty={}\",\n                i,\n@@ -239,7 +241,10 @@ pub fn trans_native_call<'a>(\n         // Ensure that we always have the Rust value indirectly,\n         // because it makes bitcasting easier.\n         if !rust_indirect {\n-            let scratch = base::alloca(bcx, type_of::type_of(ccx, passed_arg_tys[i]), \"__arg\");\n+            let scratch =\n+                base::alloca(bcx,\n+                             type_of::type_of(ccx, *passed_arg_tys.get(i)),\n+                             \"__arg\");\n             Store(bcx, llarg_rust, scratch);\n             llarg_rust = scratch;\n         }\n@@ -295,7 +300,11 @@ pub fn trans_native_call<'a>(\n         None\n     };\n     let attrs = sret_attr.as_slice();\n-    let llforeign_retval = CallWithConv(bcx, llfn, llargs_foreign, cc, attrs);\n+    let llforeign_retval = CallWithConv(bcx,\n+                                        llfn,\n+                                        llargs_foreign.as_slice(),\n+                                        cc,\n+                                        attrs);\n \n     // If the function we just called does not use an outpointer,\n     // store the result into the rust outpointer. Cast the outpointer\n@@ -466,7 +475,11 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                ccx.tcx.map.path_to_str(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, false, f.sig.inputs, f.sig.output, ps);\n+        let llfn = base::decl_internal_rust_fn(ccx,\n+                                               false,\n+                                               f.sig.inputs.as_slice(),\n+                                               f.sig.output,\n+                                               ps);\n         base::set_llvm_fn_attrs(attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, None, id, []);\n         llfn\n@@ -579,10 +592,10 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n         for i in range(0, tys.fn_sig.inputs.len()) {\n-            let rust_ty = tys.fn_sig.inputs[i];\n-            let llrust_ty = tys.llsig.llarg_tys[i];\n+            let rust_ty = *tys.fn_sig.inputs.get(i);\n+            let llrust_ty = *tys.llsig.llarg_tys.get(i);\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n-            let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n+            let llforeign_arg_ty = *tys.fn_ty.arg_tys.get(i);\n             let foreign_indirect = llforeign_arg_ty.is_indirect();\n \n             // skip padding\n@@ -730,7 +743,7 @@ fn foreign_signature(ccx: &CrateContext, fn_sig: &ty::FnSig, arg_tys: &[ty::t])\n      * values by pointer like we do.\n      */\n \n-    let llarg_tys = arg_tys.map(|&arg| type_of(ccx, arg));\n+    let llarg_tys = arg_tys.iter().map(|&arg| type_of(ccx, arg)).collect();\n     let llret_ty = type_of::type_of(ccx, fn_sig.output);\n     LlvmSignature {\n         llarg_tys: llarg_tys,\n@@ -750,10 +763,10 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess.bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs);\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let ret_def = !return_type_is_void(ccx, fn_sig.output);\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys,\n+                                       llsig.llarg_tys.as_slice(),\n                                        llsig.llret_ty,\n                                        ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -762,9 +775,9 @@ fn foreign_types_for_fn_ty(ccx: &CrateContext,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx),\n-           ccx.tn.types_to_str(llsig.llarg_tys),\n+           ccx.tn.types_to_str(llsig.llarg_tys.as_slice()),\n            ccx.tn.type_to_str(llsig.llret_ty),\n-           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty)),\n+           ccx.tn.types_to_str(fn_ty.arg_tys.map(|t| t.ty).as_slice()),\n            ccx.tn.type_to_str(fn_ty.ret_ty.ty),\n            ret_def);\n \n@@ -810,9 +823,9 @@ fn lltype_for_fn_from_foreign_types(tys: &ForeignTypes) -> Type {\n     }\n \n     if tys.fn_sig.variadic {\n-        Type::variadic_func(llargument_tys, &llreturn_ty)\n+        Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys, &llreturn_ty)\n+        Type::func(llargument_tys.as_slice(), &llreturn_ty)\n     }\n }\n "}, {"sha": "6d4737eeff12dc74ee6cd3acbd4c0eb5c82e16a7", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -245,7 +245,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n \n     // Find and call the actual destructor\n     let dtor_addr = get_res_dtor(bcx.ccx(), dtor_did,\n-                                 class_did, substs.tps.clone());\n+                                 class_did, substs.tps.as_slice());\n \n     // The second argument is the \"self\" argument for drop\n     let params = unsafe {\n@@ -262,7 +262,7 @@ fn trans_struct_drop<'a>(bcx: &'a Block<'a>,\n     // destructors if the user destructor fails.\n     let field_scope = bcx.fcx.push_custom_cleanup_scope();\n \n-    let self_arg = PointerCast(bcx, v0, params[0]);\n+    let self_arg = PointerCast(bcx, v0, *params.get(0));\n     let args = vec!(self_arg);\n \n     // Add all the fields as a value which needs to be cleaned at the end of"}, {"sha": "1a5d794c1a45405067e2dfe1485e330daacaadf5", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -25,6 +25,7 @@ use middle::trans::machine;\n use middle::trans::machine::llsize_of;\n use middle::trans::type_::Type;\n use middle::ty;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::parse::token;\n@@ -212,7 +213,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         let order = if split.len() == 2 {\n             lib::llvm::SequentiallyConsistent\n         } else {\n-            match split[2] {\n+            match *split.get(2) {\n                 \"relaxed\" => lib::llvm::Monotonic,\n                 \"acq\"     => lib::llvm::Acquire,\n                 \"rel\"     => lib::llvm::Release,\n@@ -221,7 +222,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         };\n \n-        match split[1] {\n+        match *split.get(1) {\n             \"cxchg\" => {\n                 let old = AtomicCmpXchg(bcx, get_param(decl, first_real_arg),\n                                         get_param(decl, first_real_arg + 1u),\n@@ -284,7 +285,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             RetVoid(bcx);\n         }\n         \"size_of\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty) as uint));\n         }\n@@ -294,7 +295,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // if the value is non-immediate. Note that, with\n             // intrinsics, there are no argument cleanups to\n             // concern ourselves with, so we can use an rvalue datum.\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let mode = appropriate_rvalue_mode(ccx, tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty,\n@@ -303,17 +304,17 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             RetVoid(bcx);\n         }\n         \"min_align_of\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty) as uint));\n         }\n         \"pref_align_of\"=> {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Ret(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty) as uint));\n         }\n         \"get_tydesc\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_visit_glue(ccx, static_ti);\n \n@@ -328,7 +329,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         \"type_id\" => {\n             let hash = ty::hash_crate_independent(\n                 ccx.tcx,\n-                substs.tys[0],\n+                *substs.tys.get(0),\n                 &ccx.link_meta.crate_hash);\n             // NB: This needs to be kept in lockstep with the TypeId struct in\n             //     libstd/unstable/intrinsics.rs\n@@ -342,7 +343,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         }\n         \"init\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             match bcx.fcx.llretptr.get() {\n                 Some(ptr) => { Store(bcx, C_null(lltp_ty), ptr); RetVoid(bcx); }\n@@ -352,7 +353,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n         }\n         \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n-            let retty = substs.tys[0];\n+            let retty = *substs.tys.get(0);\n             if type_is_immediate(ccx, retty) && !return_type_is_void(ccx, retty) {\n                 unsafe {\n                     Ret(bcx, lib::llvm::llvm::LLVMGetUndef(type_of(ccx, retty).to_ref()));\n@@ -365,7 +366,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             RetVoid(bcx);\n         }\n         \"transmute\" => {\n-            let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n+            let (in_type, out_type) = (*substs.tys.get(0), *substs.tys.get(1));\n             let llintype = type_of::type_of(ccx, in_type);\n             let llouttype = type_of::type_of(ccx, out_type);\n \n@@ -432,11 +433,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             }\n         }\n         \"needs_drop\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             Ret(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)));\n         }\n         \"owns_managed\" => {\n-            let tp_ty = substs.tys[0];\n+            let tp_ty = *substs.tys.get(0);\n             Ret(bcx, C_bool(ty::type_contents(ccx.tcx, tp_ty).owns_managed()));\n         }\n         \"visit_tydesc\" => {\n@@ -452,9 +453,11 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let lladdr = InBoundsGEP(bcx, ptr, [offset]);\n             Ret(bcx, lladdr);\n         }\n-        \"copy_nonoverlapping_memory\" => copy_intrinsic(bcx, false, substs.tys[0]),\n-        \"copy_memory\" => copy_intrinsic(bcx, true, substs.tys[0]),\n-        \"set_memory\" => memset_intrinsic(bcx, substs.tys[0]),\n+        \"copy_nonoverlapping_memory\" => {\n+            copy_intrinsic(bcx, false, *substs.tys.get(0))\n+        }\n+        \"copy_memory\" => copy_intrinsic(bcx, true, *substs.tys.get(0)),\n+        \"set_memory\" => memset_intrinsic(bcx, *substs.tys.get(0)),\n         \"ctlz8\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\"),\n         \"ctlz16\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\"),\n         \"ctlz32\" => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\"),"}, {"sha": "cfc88d163c0b05d240cd9ac158dd75b00e9806c1", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -25,16 +25,16 @@ use middle::trans::expr::{SaveIn, Ignore};\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::monomorphize;\n+use middle::trans::type_::Type;\n use middle::trans::type_of::*;\n use middle::ty;\n use middle::typeck;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n-use middle::trans::type_::Type;\n-\n use std::c_str::ToCStr;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::parse::token;\n use syntax::{ast, ast_map, visit};\n \n@@ -202,18 +202,21 @@ pub fn trans_static_method_callee(bcx: &Block,\n     let vtbls = ccx.maps.vtable_map.borrow().get().get_copy(&expr_id);\n     let vtbls = resolve_vtables_in_fn_ctxt(bcx.fcx, vtbls);\n \n-    match vtbls[bound_index][0] {\n-        typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n+    match vtbls.get(bound_index).get(0) {\n+        &typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name(ccx, impl_did, mname);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, expr_id, false,\n-                    *rcvr_substs, rcvr_origins);\n+                    rcvr_substs.as_slice(), rcvr_origins);\n \n-            let llfn = trans_fn_ref_with_vtables(bcx, mth_id, expr_id,\n-                                                 false, callee_substs,\n+            let llfn = trans_fn_ref_with_vtables(bcx,\n+                                                 mth_id,\n+                                                 expr_id,\n+                                                 false,\n+                                                 callee_substs.as_slice(),\n                                                  Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, expr_id);\n@@ -268,14 +271,14 @@ fn trans_monomorphized_callee<'a>(bcx: &'a Block<'a>,\n           let (callee_substs, callee_origins) =\n               combine_impl_and_methods_tps(\n                   bcx, mth_id, expr_id, true,\n-                  *rcvr_substs, rcvr_origins);\n+                  rcvr_substs.as_slice(), rcvr_origins);\n \n           // translate the function\n           let llfn = trans_fn_ref_with_vtables(bcx,\n                                                mth_id,\n                                                expr_id,\n                                                true,\n-                                               callee_substs,\n+                                               callee_substs.as_slice(),\n                                                Some(callee_origins));\n \n           Callee { bcx: bcx, data: Fn(llfn) }\n@@ -316,8 +319,8 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     let node_substs = node_id_type_params(bcx, expr_id, is_method);\n     debug!(\"rcvr_substs={:?}\", rcvr_substs.repr(ccx.tcx));\n     let ty_substs\n-        = vec_ng::append(rcvr_substs.to_owned(),\n-                      node_substs.tailn(node_substs.len() - n_m_tps));\n+        = vec_ng::append(Vec::from_slice(rcvr_substs),\n+                         node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps={:?}\", n_m_tps);\n     debug!(\"node_substs={:?}\", node_substs.repr(ccx.tcx));\n     debug!(\"ty_substs={:?}\", ty_substs.repr(ccx.tcx));\n@@ -327,11 +330,11 @@ fn combine_impl_and_methods_tps(bcx: &Block,\n     // exist, in which case we need to make them.\n     let r_m_origins = match node_vtables(bcx, expr_id) {\n         Some(vt) => vt,\n-        None => @vec::from_elem(node_substs.len(), @Vec::new())\n+        None => @Vec::from_elem(node_substs.len(), @Vec::new())\n     };\n     let vtables\n-        = @vec_ng::append(rcvr_origins.to_owned(),\n-                       r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n+        = @vec_ng::append(Vec::from_slice(rcvr_origins.as_slice()),\n+                          r_m_origins.tailn(r_m_origins.len() - n_m_tps));\n \n     (ty_substs, vtables)\n }\n@@ -460,7 +463,7 @@ pub fn get_vtable(bcx: &Block,\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n     // Check the cache.\n-    let hash_id = (self_ty, vtable_id(ccx, &origins[0]));\n+    let hash_id = (self_ty, vtable_id(ccx, origins.get(0)));\n     {\n         let vtables = ccx.vtables.borrow();\n         match vtables.get().find(&hash_id) {\n@@ -470,18 +473,25 @@ pub fn get_vtable(bcx: &Block,\n     }\n \n     // Not in the cache. Actually build it.\n-    let methods = origins.flat_map(|origin| {\n+    let mut methods = Vec::new();\n+    for origin in origins.iter() {\n         match *origin {\n             typeck::vtable_static(id, ref substs, sub_vtables) => {\n-                emit_vtable_methods(bcx, id, *substs, sub_vtables)\n+                let vtable_methods = emit_vtable_methods(bcx,\n+                                                         id,\n+                                                         substs.as_slice(),\n+                                                         sub_vtables);\n+                for vtable_method in vtable_methods.move_iter() {\n+                    methods.push(vtable_method)\n+                }\n             }\n             _ => ccx.sess.bug(\"get_vtable: expected a static origin\"),\n         }\n-    });\n+    }\n \n     // Generate a destructor for the vtable.\n     let drop_glue = glue::get_drop_glue(ccx, self_ty);\n-    let vtable = make_vtable(ccx, drop_glue, methods);\n+    let vtable = make_vtable(ccx, drop_glue, methods.as_slice());\n \n     let mut vtables = ccx.vtables.borrow_mut();\n     vtables.get().insert(hash_id, vtable);\n@@ -501,7 +511,7 @@ pub fn make_vtable(ccx: &CrateContext,\n             components.push(ptr)\n         }\n \n-        let tbl = C_struct(components, false);\n+        let tbl = C_struct(components.as_slice(), false);\n         let sym = token::gensym(\"vtable\");\n         let vt_gvar = format!(\"vtable{}\", sym).with_c_str(|buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl).to_ref(), buf)\n@@ -589,7 +599,7 @@ pub fn trans_trait_cast<'a>(bcx: &'a Block<'a>,\n             *vtable_map.get().get(&id)\n         };\n         let res = resolve_vtables_in_fn_ctxt(bcx.fcx, res);\n-        res[0]\n+        *res.get(0)\n     };\n     let vtable = get_vtable(bcx, v_ty, origins);\n     let llvtabledest = GEPi(bcx, lldest, [0u, abi::trt_field_vtable]);"}, {"sha": "ecfc1aae3d99bb2b270f36fbd6ab163060f406e0", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -23,6 +23,7 @@ use middle::ty;\n use middle::typeck;\n use util::ppaux::Repr;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n@@ -51,7 +52,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let mut must_cast = false;\n \n     let psubsts = @param_substs {\n-        tys: real_substs.tps.to_owned(),\n+        tys: real_substs.tps.clone(),\n         vtables: vtables,\n         self_ty: real_substs.self_ty.clone(),\n         self_vtables: self_vtables\n@@ -124,7 +125,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     debug!(\"monomorphic_fn about to subst into {}\", llitem_ty.repr(ccx.tcx));\n     let mono_ty = match is_static_provided {\n-        None => ty::subst_tps(ccx.tcx, psubsts.tys,\n+        None => ty::subst_tps(ccx.tcx, psubsts.tys.as_slice(),\n                               psubsts.self_ty, llitem_ty),\n         Some(num_method_ty_params) => {\n             // Static default methods are a little unfortunate, in\n@@ -186,7 +187,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     let mk_lldecl = || {\n         let lldecl = decl_internal_rust_fn(ccx, false,\n-                                           f.sig.inputs,\n+                                           f.sig.inputs.as_slice(),\n                                            f.sig.output, s);\n         let mut monomorphized = ccx.monomorphized.borrow_mut();\n         monomorphized.get().insert(hash_id, lldecl);"}, {"sha": "6c87ae94ba4b3e12c8f1d5771699e50e87f3c49a", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 46, "deletions": 39, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -28,7 +28,8 @@ use util::ppaux::ty_to_str;\n use arena::TypedArena;\n use std::libc::c_uint;\n use std::option::{Some,None};\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::ast_map;\n@@ -93,12 +94,12 @@ impl<'a> Reflector<'a> {\n     pub fn visit(&mut self, ty_name: &str, args: &[ValueRef]) {\n         let fcx = self.bcx.fcx;\n         let tcx = self.bcx.tcx();\n-        let mth_idx = ty::method_idx(\n-            token::str_to_ident(~\"visit_\" + ty_name),\n-            *self.visitor_methods).expect(format!(\"couldn't find visit method \\\n-                                                for {}\", ty_name));\n+        let mth_idx = ty::method_idx(token::str_to_ident(~\"visit_\" + ty_name),\n+                                     self.visitor_methods.as_slice()).expect(\n+                format!(\"couldn't find visit method for {}\", ty_name));\n         let mth_ty =\n-            ty::mk_bare_fn(tcx, self.visitor_methods[mth_idx].fty.clone());\n+            ty::mk_bare_fn(tcx,\n+                           self.visitor_methods.get(mth_idx).fty.clone());\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -134,7 +135,8 @@ impl<'a> Reflector<'a> {\n         match vstore {\n             ty::vstore_fixed(n) => {\n                 let extra = vec_ng::append(vec!(self.c_uint(n)),\n-                                        self.c_size_and_align(t));\n+                                           self.c_size_and_align(t)\n+                                               .as_slice());\n                 (~\"fixed\", extra)\n             }\n             ty::vstore_slice(_) => (~\"slice\", Vec::new()),\n@@ -172,50 +174,50 @@ impl<'a> Reflector<'a> {\n \n           ty::ty_unboxed_vec(ref mt) => {\n               let values = self.c_mt(mt);\n-              self.visit(\"vec\", values)\n+              self.visit(\"vec\", values.as_slice())\n           }\n \n           // Should rename to str_*/vec_*.\n           ty::ty_str(vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              self.visit(~\"estr_\" + name, extra)\n+              self.visit(~\"estr_\" + name, extra.as_slice())\n           }\n           ty::ty_vec(ref mt, vst) => {\n               let (name, extra) = self.vstore_name_and_extra(t, vst);\n-              let extra = extra + self.c_mt(mt);\n-              self.visit(~\"evec_\" + name, extra)\n+              let extra = vec_ng::append(extra, self.c_mt(mt).as_slice());\n+              self.visit(~\"evec_\" + name, extra.as_slice())\n           }\n           // Should remove mt from box and uniq.\n           ty::ty_box(typ) => {\n               let extra = self.c_mt(&ty::mt {\n                   ty: typ,\n                   mutbl: ast::MutImmutable,\n               });\n-              self.visit(\"box\", extra)\n+              self.visit(\"box\", extra.as_slice())\n           }\n           ty::ty_uniq(typ) => {\n               let extra = self.c_mt(&ty::mt {\n                   ty: typ,\n                   mutbl: ast::MutImmutable,\n               });\n-              self.visit(\"uniq\", extra)\n+              self.visit(\"uniq\", extra.as_slice())\n           }\n           ty::ty_ptr(ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"ptr\", extra)\n+              self.visit(\"ptr\", extra.as_slice())\n           }\n           ty::ty_rptr(_, ref mt) => {\n               let extra = self.c_mt(mt);\n-              self.visit(\"rptr\", extra)\n+              self.visit(\"rptr\", extra.as_slice())\n           }\n \n           ty::ty_tup(ref tys) => {\n-              let extra = vec!(self.c_uint(tys.len()))\n-                  + self.c_size_and_align(t);\n-              self.bracketed(\"tup\", extra, |this| {\n+              let extra = vec_ng::append(vec!(self.c_uint(tys.len())),\n+                                         self.c_size_and_align(t).as_slice());\n+              self.bracketed(\"tup\", extra.as_slice(), |this| {\n                   for (i, t) in tys.iter().enumerate() {\n                       let extra = vec!(this.c_uint(i), this.c_tydesc(*t));\n-                      this.visit(\"tup_field\", extra);\n+                      this.visit(\"tup_field\", extra.as_slice());\n                   }\n               })\n           }\n@@ -230,9 +232,9 @@ impl<'a> Reflector<'a> {\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval));\n-            self.visit(\"enter_fn\", extra);\n+            self.visit(\"enter_fn\", extra.as_slice());\n             self.visit_sig(retval, &fty.sig);\n-            self.visit(\"leave_fn\", extra);\n+            self.visit(\"leave_fn\", extra.as_slice());\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n@@ -245,33 +247,33 @@ impl<'a> Reflector<'a> {\n                           self.c_uint(sigilval),\n                           self.c_uint(fty.sig.inputs.len()),\n                           self.c_uint(retval));\n-            self.visit(\"enter_fn\", extra);\n+            self.visit(\"enter_fn\", extra.as_slice());\n             self.visit_sig(retval, &fty.sig);\n-            self.visit(\"leave_fn\", extra);\n+            self.visit(\"leave_fn\", extra.as_slice());\n           }\n \n           ty::ty_struct(did, ref substs) => {\n               let fields = ty::struct_fields(tcx, did, substs);\n               let mut named_fields = false;\n               if !fields.is_empty() {\n-                  named_fields =\n-                        fields[0].ident.name != special_idents::unnamed_field.name;\n+                  named_fields = fields.get(0).ident.name !=\n+                      special_idents::unnamed_field.name;\n               }\n \n-              let extra = vec!(\n+              let extra = vec_ng::append(vec!(\n                   self.c_slice(token::intern_and_get_ident(ty_to_str(tcx,\n                                                                      t))),\n                   self.c_bool(named_fields),\n                   self.c_uint(fields.len())\n-              ) + self.c_size_and_align(t);\n-              self.bracketed(\"class\", extra, |this| {\n+              ), self.c_size_and_align(t).as_slice());\n+              self.bracketed(\"class\", extra.as_slice(), |this| {\n                   for (i, field) in fields.iter().enumerate() {\n-                      let extra = vec!(\n+                      let extra = vec_ng::append(vec!(\n                         this.c_uint(i),\n                         this.c_slice(token::get_ident(field.ident)),\n                         this.c_bool(named_fields)\n-                      ) + this.c_mt(&field.mt);\n-                      this.visit(\"class_field\", extra);\n+                      ), this.c_mt(&field.mt).as_slice());\n+                      this.visit(\"class_field\", extra.as_slice());\n                   }\n               })\n           }\n@@ -319,16 +321,20 @@ impl<'a> Reflector<'a> {\n                 llfdecl\n             };\n \n-            let enum_args = vec!(self.c_uint(variants.len()), make_get_disr())\n-                + self.c_size_and_align(t);\n-            self.bracketed(\"enum\", enum_args, |this| {\n+            let enum_args = vec_ng::append(vec!(self.c_uint(variants.len()),\n+                                                make_get_disr()),\n+                                           self.c_size_and_align(t)\n+                                               .as_slice());\n+            self.bracketed(\"enum\", enum_args.as_slice(), |this| {\n                 for (i, v) in variants.iter().enumerate() {\n                     let name = token::get_ident(v.name);\n                     let variant_args = vec!(this.c_uint(i),\n                                          C_u64(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name));\n-                    this.bracketed(\"enum_variant\", variant_args, |this| {\n+                    this.bracketed(\"enum_variant\",\n+                                   variant_args.as_slice(),\n+                                   |this| {\n                         for (j, a) in v.args.iter().enumerate() {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n@@ -337,7 +343,8 @@ impl<'a> Reflector<'a> {\n                             let field_args = vec!(this.c_uint(j),\n                                                offset,\n                                                this.c_tydesc(*a));\n-                            this.visit(\"enum_variant_field\", field_args);\n+                            this.visit(\"enum_variant_field\",\n+                                       field_args.as_slice());\n                         }\n                     })\n                 }\n@@ -356,7 +363,7 @@ impl<'a> Reflector<'a> {\n           ty::ty_err => self.leaf(\"err\"),\n           ty::ty_param(ref p) => {\n               let extra = vec!(self.c_uint(p.idx));\n-              self.visit(\"param\", extra)\n+              self.visit(\"param\", extra.as_slice())\n           }\n           ty::ty_self(..) => self.leaf(\"self\")\n         }\n@@ -368,12 +375,12 @@ impl<'a> Reflector<'a> {\n             let extra = vec!(self.c_uint(i),\n                          self.c_uint(modeval),\n                          self.c_tydesc(*arg));\n-            self.visit(\"fn_input\", extra);\n+            self.visit(\"fn_input\", extra.as_slice());\n         }\n         let extra = vec!(self.c_uint(retval),\n                       self.c_bool(sig.variadic),\n                       self.c_tydesc(sig.output));\n-        self.visit(\"fn_output\", extra);\n+        self.visit(\"fn_output\", extra.as_slice());\n     }\n }\n "}, {"sha": "3127231259d85a09268073a71efb1d4b69b446e1", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -20,8 +20,9 @@ use syntax::ast;\n use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n \n use std::c_str::ToCStr;\n-use std::vec;\n use std::cast;\n+use std::vec;\n+use std::vec_ng::Vec;\n \n use std::libc::{c_uint};\n \n@@ -301,8 +302,8 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts = vec::from_elem(n_elts, 0 as TypeRef);\n-            llvm::LLVMGetStructElementTypes(self.to_ref(), &mut elts[0]);\n+            let mut elts = Vec::from_elem(n_elts, 0 as TypeRef);\n+            llvm::LLVMGetStructElementTypes(self.to_ref(), elts.get_mut(0));\n             cast::transmute(elts)\n         }\n     }\n@@ -314,7 +315,7 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let args = vec::from_elem(n_args, 0 as TypeRef);\n+            let args = Vec::from_elem(n_args, 0 as TypeRef);\n             llvm::LLVMGetParamTypes(self.to_ref(), args.as_ptr());\n             cast::transmute(args)\n         }"}, {"sha": "de3aff0fff61358599d8ef0b0a3ee096bd0c45d9", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -19,6 +19,7 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::opt_vec;\n \n@@ -62,21 +63,24 @@ pub fn type_of_rust_fn(cx: &CrateContext, has_env: bool,\n \n     // Use the output as the actual return value if it's immediate.\n     if use_out_pointer || return_type_is_void(cx, output) {\n-        Type::func(atys, &Type::void())\n+        Type::func(atys.as_slice(), &Type::void())\n     } else {\n-        Type::func(atys, &lloutputtype)\n+        Type::func(atys.as_slice(), &lloutputtype)\n     }\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n     match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n-            type_of_rust_fn(cx, true, f.sig.inputs, f.sig.output)\n+            type_of_rust_fn(cx, true, f.sig.inputs.as_slice(), f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abis.is_rust() || f.abis.is_intrinsic() {\n-                type_of_rust_fn(cx, false, f.sig.inputs, f.sig.output)\n+                type_of_rust_fn(cx,\n+                                false,\n+                                f.sig.inputs.as_slice(),\n+                                f.sig.output)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -216,7 +220,7 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n         let repr = adt::represent_type(cx, t);\n-        let name = llvm_type_name(cx, an_enum, did, substs.tps);\n+        let name = llvm_type_name(cx, an_enum, did, substs.tps.as_slice());\n         adt::incomplete_type_of(cx, repr, name)\n       }\n       ty::ty_box(typ) => {\n@@ -277,7 +281,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n               // in *after* placing it into the type cache. This prevents\n               // infinite recursion with recursive struct types.\n               let repr = adt::represent_type(cx, t);\n-              let name = llvm_type_name(cx, a_struct, did, substs.tps);\n+              let name = llvm_type_name(cx,\n+                                        a_struct,\n+                                        did,\n+                                        substs.tps.as_slice());\n               adt::incomplete_type_of(cx, repr, name)\n           }\n       }"}, {"sha": "4d0f6704379d553a8bda75756846182200333493", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -40,7 +40,8 @@ use std::fmt;\n use std::hash::{Hash, sip};\n use std::ops;\n use std::rc::Rc;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use collections::{HashMap, HashSet};\n use syntax::ast::*;\n use syntax::ast_util::{is_local, lit_is_str};\n@@ -279,7 +280,7 @@ pub struct ctxt_ {\n     // of this node.  This only applies to nodes that refer to entities\n     // parameterized by type parameters, such as generic fns, types, or\n     // other items.\n-    node_type_substs: RefCell<NodeMap<vec!(t)>>,\n+    node_type_substs: RefCell<NodeMap<Vec<t>>>,\n \n     // Maps from a method to the method \"descriptor\"\n     methods: RefCell<DefIdMap<@Method>>,\n@@ -460,7 +461,7 @@ pub struct ClosureTy {\n #[deriving(Clone, Eq, Hash)]\n pub struct FnSig {\n     binder_id: ast::NodeId,\n-    inputs: vec!(t),\n+    inputs: Vec<t>,\n     output: t,\n     variadic: bool\n }\n@@ -683,7 +684,7 @@ pub enum RegionSubsts {\n #[deriving(Clone, Eq, Hash)]\n pub struct substs {\n     self_ty: Option<ty::t>,\n-    tps: vec!(t),\n+    tps: Vec<t>,\n     regions: RegionSubsts,\n }\n \n@@ -755,7 +756,7 @@ pub enum sty {\n     ty_closure(ClosureTy),\n     ty_trait(DefId, substs, TraitStore, ast::Mutability, BuiltinBounds),\n     ty_struct(DefId, substs),\n-    ty_tup(vec!(t)),\n+    ty_tup(Vec<t>),\n \n     ty_param(param_ty), // type parameter\n     ty_self(DefId), /* special, implicit `self` type parameter;\n@@ -1410,7 +1411,7 @@ pub fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n     mk_t(cx, ty_unboxed_vec(mt {ty: ty, mutbl: ast::MutImmutable}))\n }\n \n-pub fn mk_tup(cx: ctxt, ts: vec!(t)) -> t { mk_t(cx, ty_tup(ts)) }\n+pub fn mk_tup(cx: ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: ctxt, fty: ClosureTy) -> t {\n     mk_t(cx, ty_closure(fty))\n@@ -1431,7 +1432,7 @@ pub fn mk_ctor_fn(cx: ctxt,\n                    abis: AbiSet::Rust(),\n                    sig: FnSig {\n                     binder_id: binder_id,\n-                    inputs: input_args,\n+                    inputs: Vec::from_slice(input_args),\n                     output: output,\n                     variadic: false\n                    }\n@@ -1665,7 +1666,7 @@ pub fn simd_type(cx: ctxt, ty: t) -> t {\n     match get(ty).sty {\n         ty_struct(did, ref substs) => {\n             let fields = lookup_struct_fields(cx, did);\n-            lookup_field_type(cx, did, fields[0].id, substs)\n+            lookup_field_type(cx, did, fields.get(0).id, substs)\n         }\n         _ => fail!(\"simd_type called on invalid type\")\n     }\n@@ -1683,7 +1684,7 @@ pub fn simd_size(cx: ctxt, ty: t) -> uint {\n \n pub fn get_element_type(ty: t, i: uint) -> t {\n     match get(ty).sty {\n-      ty_tup(ref ts) => return ts[i],\n+      ty_tup(ref ts) => return *ts.get(i),\n       _ => fail!(\"get_element_type called on invalid type\")\n     }\n }\n@@ -2196,22 +2197,25 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds, |f| tc_mt(cx, f.mt, cache));\n+                    TypeContents::union(flds.as_slice(),\n+                                        |f| tc_mt(cx, f.mt, cache));\n                 if ty::has_dtor(cx, did) {\n                     res = res | TC::OwnsDtor;\n                 }\n                 apply_lang_items(cx, did, res)\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(*tys, |ty| tc_ty(cx, *ty, cache))\n+                TypeContents::union(tys.as_slice(),\n+                                    |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let res =\n-                    TypeContents::union(variants, |variant| {\n-                        TypeContents::union(variant.args, |arg_ty| {\n+                    TypeContents::union(variants.as_slice(), |variant| {\n+                        TypeContents::union(variant.args.as_slice(),\n+                                            |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n                     });\n@@ -2231,7 +2235,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 let tp_def = ty_param_defs.get().get(&p.def_id.node);\n                 kind_bounds_to_contents(cx,\n                                         tp_def.bounds.builtin_bounds,\n-                                        tp_def.bounds.trait_bounds)\n+                                        tp_def.bounds.trait_bounds.as_slice())\n             }\n \n             ty_self(def_id) => {\n@@ -2924,7 +2928,7 @@ pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n \n // Returns a vec of all the input and output types of fty.\n pub fn tys_in_fn_sig(sig: &FnSig) -> Vec<t> {\n-    vec::append_one(sig.inputs.map(|a| *a), sig.output)\n+    vec_ng::append_one(sig.inputs.map(|a| *a), sig.output)\n }\n \n // Type accessors for AST nodes\n@@ -3211,7 +3215,7 @@ impl AutoRef {\n }\n \n pub struct ParamsTy {\n-    params: vec!(t),\n+    params: Vec<t>,\n     ty: t\n }\n \n@@ -3249,7 +3253,7 @@ pub fn method_call_type_param_defs(tcx: ctxt, origin: typeck::MethodOrigin)\n             let trait_type_param_defs =\n                 lookup_trait_def(tcx, trt_id).generics.type_param_defs();\n             Rc::new(vec_ng::append(\n-                trait_type_param_defs.to_owned(),\n+                Vec::from_slice(trait_type_param_defs),\n                 ty::trait_method(tcx,\n                                  trt_id,\n                                  n_mth).generics.type_param_defs()))\n@@ -3430,9 +3434,11 @@ pub fn expr_kind(tcx: ctxt,\n                 None => fail!(\"no def for place\"),\n             };\n             let def_id = ast_util::def_id_of_def(definition);\n-            match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n-                Some(item_def_id) if def_id == item_def_id => RvalueDatumExpr,\n-                Some(_) | None => RvalueDpsExpr,\n+            match tcx.lang_items.items.get(ExchangeHeapLangItem as uint) {\n+                &Some(item_def_id) if def_id == item_def_id => {\n+                    RvalueDatumExpr\n+                }\n+                &Some(_) | &None => RvalueDpsExpr,\n             }\n         }\n \n@@ -3829,7 +3835,7 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n }\n \n pub fn trait_method(cx: ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n-    let method_def_id = ty::trait_method_def_ids(cx, trait_did)[idx];\n+    let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n     ty::method(cx, method_def_id)\n }\n \n@@ -3932,7 +3938,7 @@ pub fn ty_to_def_id(ty: t) -> Option<ast::DefId> {\n // Enum information\n #[deriving(Clone)]\n pub struct VariantInfo {\n-    args: vec!(t),\n+    args: Vec<t>,\n     arg_names: Option<Vec<ast::Ident> >,\n     ctor_ty: t,\n     name: ast::Ident,\n@@ -3953,7 +3959,11 @@ impl VariantInfo {\n \n         match ast_variant.node.kind {\n             ast::TupleVariantKind(ref args) => {\n-                let arg_tys = if args.len() > 0 { ty_fn_args(ctor_ty).map(|a| *a) } else { Vec::new() };\n+                let arg_tys = if args.len() > 0 {\n+                    ty_fn_args(ctor_ty).map(|a| *a)\n+                } else {\n+                    Vec::new()\n+                };\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -3972,13 +3982,13 @@ impl VariantInfo {\n                 assert!(fields.len() > 0);\n \n                 let arg_tys = ty_fn_args(ctor_ty).map(|a| *a);\n-                let arg_names = fields.map(|field| {\n+                let arg_names = fields.iter().map(|field| {\n                     match field.node.kind {\n                         NamedField(ident, _) => ident,\n                         UnnamedField => cx.sess.bug(\n                             \"enum_variants: all fields in struct must have a name\")\n                     }\n-                });\n+                }).collect();\n \n                 return VariantInfo {\n                     args: arg_tys,\n@@ -4168,8 +4178,10 @@ pub fn enum_variant_with_id(cx: ctxt,\n     let variants = enum_variants(cx, enum_id);\n     let mut i = 0;\n     while i < variants.len() {\n-        let variant = variants[i];\n-        if variant.id == variant_id { return variant; }\n+        let variant = *variants.get(i);\n+        if variant.id == variant_id {\n+            return variant\n+        }\n         i += 1;\n     }\n     cx.sess.bug(\"enum_variant_with_id(): no variant exists with that ID\");\n@@ -4341,7 +4353,7 @@ pub fn lookup_struct_field(cx: ctxt,\n }\n \n fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n-    fields.map(|field| {\n+    fields.iter().map(|field| {\n         match field.node.kind {\n             NamedField(ident, visibility) => {\n                 field_ty {\n@@ -4358,7 +4370,7 @@ fn struct_field_tys(fields: &[StructField]) -> Vec<field_ty> {\n                 }\n             }\n         }\n-    })\n+    }).collect()\n }\n \n // Returns a list of fields corresponding to the struct's items. trans uses\n@@ -4450,7 +4462,7 @@ pub fn is_binopable(cx: ctxt, ty: t, op: ast::BinOp) -> bool {\n }\n \n pub fn ty_params_to_tys(tcx: ty::ctxt, generics: &ast::Generics) -> Vec<t> {\n-    vec::from_fn(generics.ty_params.len(), |i| {\n+    Vec::from_fn(generics.ty_params.len(), |i| {\n         let id = generics.ty_params.get(i).id;\n         ty::mk_param(tcx, i, ast_util::local_def(id))\n     })\n@@ -4502,18 +4514,20 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n                        -> substs {\n             substs { regions: ErasedRegions,\n                      self_ty: ty_fold::fold_opt_ty(self, substs.self_ty),\n-                     tps: ty_fold::fold_ty_vec(self, substs.tps) }\n+                     tps: ty_fold::fold_ty_vec(self, substs.tps.as_slice()) }\n         }\n \n         fn fold_sig(&mut self,\n                     sig: &ty::FnSig)\n                     -> ty::FnSig {\n             // The binder-id is only relevant to bound regions, which\n             // are erased at trans time.\n-            ty::FnSig { binder_id: ast::DUMMY_NODE_ID,\n-                        inputs: ty_fold::fold_ty_vec(self, sig.inputs),\n-                        output: self.fold_ty(sig.output),\n-                        variadic: sig.variadic }\n+            ty::FnSig {\n+                binder_id: ast::DUMMY_NODE_ID,\n+                inputs: ty_fold::fold_ty_vec(self, sig.inputs.as_slice()),\n+                output: self.fold_ty(sig.output),\n+                variadic: sig.variadic,\n+            }\n         }\n     }\n }\n@@ -4615,14 +4629,15 @@ pub fn each_bound_trait_and_supertraits(tcx: ctxt,\n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n             debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n-                   i, trait_refs[i].repr(tcx));\n+                   i, trait_refs.get(i).repr(tcx));\n \n-            if !f(trait_refs[i]) {\n+            if !f(*trait_refs.get(i)) {\n                 return false;\n             }\n \n             // Add supertraits to supertrait_set\n-            let supertrait_refs = trait_ref_supertraits(tcx, trait_refs[i]);\n+            let supertrait_refs = trait_ref_supertraits(tcx,\n+                                                        *trait_refs.get(i));\n             for &supertrait_ref in supertrait_refs.iter() {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n@@ -4646,7 +4661,7 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n     let mut total = 0;\n     for type_param_def in type_param_defs.iter() {\n         each_bound_trait_and_supertraits(\n-            tcx, type_param_def.bounds.trait_bounds, |_| {\n+            tcx, type_param_def.bounds.trait_bounds.as_slice(), |_| {\n             total += 1;\n             true\n         });\n@@ -5078,7 +5093,7 @@ pub fn construct_parameter_environment(\n     let num_item_type_params = item_type_params.len();\n     let num_method_type_params = method_type_params.len();\n     let num_type_params = num_item_type_params + num_method_type_params;\n-    let type_params = vec::from_fn(num_type_params, |i| {\n+    let type_params = Vec::from_fn(num_type_params, |i| {\n             let def_id = if i < num_item_type_params {\n                 item_type_params[i].def_id\n             } else {\n@@ -5106,7 +5121,7 @@ pub fn construct_parameter_environment(\n     //\n \n     let self_bound_substd = self_bound.map(|b| b.subst(tcx, &free_substs));\n-    let type_param_bounds_substd = vec::from_fn(num_type_params, |i| {\n+    let type_param_bounds_substd = Vec::from_fn(num_type_params, |i| {\n         if i < num_item_type_params {\n             (*item_type_params[i].bounds).subst(tcx, &free_substs)\n         } else {"}, {"sha": "769924c02c864d3a3f7a9bb51b6594b14a4a0b11", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -13,6 +13,8 @@\n use middle::ty;\n use util::ppaux::Repr;\n \n+use std::vec_ng::Vec;\n+\n pub trait TypeFolder {\n     fn tcx(&self) -> ty::ctxt;\n \n@@ -84,10 +86,8 @@ pub fn fold_opt_ty<T:TypeFolder>(this: &mut T,\n     t.map(|t| this.fold_ty(t))\n }\n \n-pub fn fold_ty_vec<T:TypeFolder>(this: &mut T,\n-                                 tys: &[ty::t])\n-                                 -> Vec<ty::t> {\n-    tys.map(|t| this.fold_ty(*t))\n+pub fn fold_ty_vec<T:TypeFolder>(this: &mut T, tys: &[ty::t]) -> Vec<ty::t> {\n+    tys.iter().map(|t| this.fold_ty(*t)).collect()\n }\n \n pub fn super_fold_ty<T:TypeFolder>(this: &mut T,\n@@ -110,14 +110,14 @@ pub fn super_fold_substs<T:TypeFolder>(this: &mut T,\n \n     ty::substs { regions: regions,\n                  self_ty: fold_opt_ty(this, substs.self_ty),\n-                 tps: fold_ty_vec(this, substs.tps), }\n+                 tps: fold_ty_vec(this, substs.tps.as_slice()), }\n }\n \n pub fn super_fold_sig<T:TypeFolder>(this: &mut T,\n                                     sig: &ty::FnSig)\n                                     -> ty::FnSig {\n     ty::FnSig { binder_id: sig.binder_id,\n-                inputs: fold_ty_vec(this, sig.inputs),\n+                inputs: fold_ty_vec(this, sig.inputs.as_slice()),\n                 output: this.fold_ty(sig.output),\n                 variadic: sig.variadic }\n }\n@@ -166,7 +166,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n                      bounds)\n         }\n         ty::ty_tup(ref ts) => {\n-            ty::ty_tup(fold_ty_vec(this, *ts))\n+            ty::ty_tup(fold_ty_vec(this, ts.as_slice()))\n         }\n         ty::ty_bare_fn(ref f) => {\n             ty::ty_bare_fn(this.fold_bare_fn_ty(f))"}, {"sha": "40e836ac0d9adb565c16f27e2c50cb43b9526126", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -136,7 +136,7 @@ fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n                 }\n \n                 Ok(rs) => {\n-                    rs[0]\n+                    *rs.get(0)\n                 }\n             }\n         }\n@@ -791,7 +791,11 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n         let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n-            if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n+            if i < e.inputs.len() {\n+                Some(*e.inputs.get(i))\n+            } else {\n+                None\n+            }\n         });\n         ty_of_arg(this, &rb, a, expected_arg_ty)\n     }).collect();"}, {"sha": "6c59ce09e05cb057c4f4f179d834fddab56bf620", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -319,7 +319,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             Some(&(index, ref mut used)) => {\n                 *used = true;\n-                let class_field = class_fields[index];\n+                let class_field = *class_fields.get(index);\n                 let field_type = ty::lookup_field_type(tcx,\n                                                        class_id,\n                                                        class_field.id,\n@@ -585,7 +585,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: &ast::Pat, expected: ty::t) {\n         match *s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n                 for (i, elt) in elts.iter().enumerate() {\n-                    check_pat(pcx, *elt, ex_elts[i]);\n+                    check_pat(pcx, *elt, *ex_elts.get(i));\n                 }\n                 fcx.write_ty(pat.id, expected);\n             }"}, {"sha": "0cf0fa5897aa91fdef9fb67a670492ad36de5f1a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -100,7 +100,8 @@ use util::ppaux::Repr;\n use std::cell::RefCell;\n use collections::HashSet;\n use std::result;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n@@ -450,7 +451,7 @@ impl<'a> LookupContext<'a> {\n                 self.get_method_index(new_trait_ref, trait_ref, method_num);\n             let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n-            m.fty.sig.inputs[0] =\n+            *m.fty.sig.inputs.get_mut(0) =\n                 self.construct_transformed_self_ty_for_object(\n                     did, &rcvr_substs, &m);\n \n@@ -476,7 +477,13 @@ impl<'a> LookupContext<'a> {\n                param_ty);\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n-            self.fcx.inh.param_env.type_param_bounds[param_ty.idx].trait_bounds,\n+            self.fcx\n+                .inh\n+                .param_env\n+                .type_param_bounds\n+                .get(param_ty.idx)\n+                .trait_bounds\n+                .as_slice(),\n             restrict_to,\n             param_numbered(param_ty.idx));\n     }\n@@ -541,10 +548,9 @@ impl<'a> LookupContext<'a> {\n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             match trait_methods.iter().position(|m| {\n                 m.explicit_self != ast::SelfStatic &&\n-                m.ident.name == self.m_name })\n-            {\n+                m.ident.name == self.m_name }) {\n                 Some(pos) => {\n-                    let method = trait_methods[pos];\n+                    let method = *trait_methods.get(pos);\n \n                     match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n                         Some(cand) => {\n@@ -599,13 +605,16 @@ impl<'a> LookupContext<'a> {\n                impl_info.methods.map(|m| m.ident).repr(self.tcx()));\n \n         let idx = {\n-            match impl_info.methods.iter().position(|m| m.ident.name == self.m_name) {\n+            match impl_info.methods\n+                           .iter()\n+                           .position(|m| m.ident.name == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }\n         };\n \n-        let method = ty::method(self.tcx(), impl_info.methods[idx].def_id);\n+        let method = ty::method(self.tcx(),\n+                                impl_info.methods.get(idx).def_id);\n \n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n@@ -899,7 +908,8 @@ impl<'a> LookupContext<'a> {\n             candidates.iter().map(|c| (*c).clone()).\n                 filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n \n-        let relevant_candidates = self.merge_candidates(relevant_candidates);\n+        let relevant_candidates =\n+            self.merge_candidates(relevant_candidates.as_slice());\n \n         if relevant_candidates.len() == 0 {\n             return None;\n@@ -914,7 +924,7 @@ impl<'a> LookupContext<'a> {\n             }\n         }\n \n-        Some(self.confirm_candidate(rcvr_ty, &relevant_candidates[0]))\n+        Some(self.confirm_candidate(rcvr_ty, relevant_candidates.get(0)))\n     }\n \n     fn merge_candidates(&self, candidates: &[Candidate]) -> Vec<Candidate> {\n@@ -1004,14 +1014,15 @@ impl<'a> LookupContext<'a> {\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n-                self.supplied_tps.to_owned()\n+                Vec::from_slice(self.supplied_tps)\n             }\n         };\n \n         // Construct the full set of type parameters for the method,\n         // which is equal to the class tps + the method tps.\n         let all_substs = substs {\n-            tps: vec_ng::append(candidate.rcvr_substs.tps.clone(), m_substs),\n+            tps: vec_ng::append(candidate.rcvr_substs.tps.clone(),\n+                                m_substs.as_slice()),\n             regions: candidate.rcvr_substs.regions.clone(),\n             self_ty: candidate.rcvr_substs.self_ty,\n         };\n@@ -1031,7 +1042,7 @@ impl<'a> LookupContext<'a> {\n                 let args = fn_sig.inputs.slice_from(1).iter().map(|t| {\n                     t.subst(tcx, &all_substs)\n                 });\n-                Some(fn_sig.inputs[0]).move_iter().chain(args).collect()\n+                Some(*fn_sig.inputs.get(0)).move_iter().chain(args).collect()\n             }\n             _ => fn_sig.inputs.subst(tcx, &all_substs)\n         };\n@@ -1050,7 +1061,7 @@ impl<'a> LookupContext<'a> {\n             self.fcx.infcx().next_region_var(\n                 infer::BoundRegionInFnCall(self.expr.span, br))\n         });\n-        let transformed_self_ty = fn_sig.inputs[0];\n+        let transformed_self_ty = *fn_sig.inputs.get(0);\n         let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n             sig: fn_sig,\n             purity: bare_fn_ty.purity,\n@@ -1118,7 +1129,7 @@ impl<'a> LookupContext<'a> {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n             ast::SelfRegion(..) | ast::SelfUniq => {\n-                let transformed_self_ty = method_ty.fty.sig.inputs[0];\n+                let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n                 match ty::get(transformed_self_ty).sty {\n                     ty::ty_rptr(r, mt) => { // must be SelfRegion\n                         ty::mk_trait(self.tcx(), trait_def_id,"}, {"sha": "3c98f3defd6e610eeb820f3fbdaa182ae6502389", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -118,6 +118,8 @@ use collections::HashMap;\n use std::mem::replace;\n use std::result;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::abi::AbiSet;\n use syntax::ast::{Provided, Required};\n use syntax::ast;\n@@ -902,7 +904,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                 bound_region: ty::BrNamed(l.def_id, l.ident)})).\n         collect();\n     let dummy_substs = ty::substs {\n-        tps: vec_ng::append(dummy_impl_tps, dummy_method_tps),\n+        tps: vec_ng::append(dummy_impl_tps, dummy_method_tps.as_slice()),\n         regions: ty::NonerasedRegions(dummy_impl_regions),\n         self_ty: None };\n \n@@ -929,7 +931,7 @@ fn compare_impl_method(tcx: ty::ctxt,\n                      self_ty: self_ty } = trait_substs.subst(tcx, &dummy_substs);\n         let substs = substs {\n             regions: trait_regions,\n-            tps: vec_ng::append(trait_tps, dummy_method_tps),\n+            tps: vec_ng::append(trait_tps, dummy_method_tps.as_slice()),\n             self_ty: self_ty,\n         };\n         debug!(\"trait_fty (pre-subst): {} substs={}\",\n@@ -988,7 +990,7 @@ impl FnCtxt {\n impl RegionScope for infer::InferCtxt {\n     fn anon_regions(&self, span: Span, count: uint)\n                     -> Result<Vec<ty::Region> , ()> {\n-        Ok(vec::from_fn(count, |_| {\n+        Ok(Vec::from_fn(count, |_| {\n             self.next_region_var(infer::MiscVariable(span))\n         }))\n     }\n@@ -1672,7 +1674,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         let args = args.slice_from(1);\n         if ty::type_is_error(method_fn_ty) {\n             let err_inputs = err_args(args.len());\n-            check_argument_types(fcx, sp, err_inputs, callee_expr,\n+            check_argument_types(fcx, sp, err_inputs.as_slice(), callee_expr,\n                                  args, deref_args, false);\n             method_fn_ty\n         } else {\n@@ -1713,10 +1715,10 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         let supplied_arg_count = args.len();\n         let expected_arg_count = fn_inputs.len();\n         let formal_tys = if expected_arg_count == supplied_arg_count {\n-            fn_inputs.map(|a| *a)\n+            fn_inputs.iter().map(|a| *a).collect()\n         } else if variadic {\n             if supplied_arg_count >= expected_arg_count {\n-                fn_inputs.map(|a| *a)\n+                fn_inputs.iter().map(|a| *a).collect()\n             } else {\n                 let msg = format!(\n                     \"this function takes at least {nexpected, plural, =1{# parameter} \\\n@@ -1782,7 +1784,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n                 if is_block == check_blocks {\n                     debug!(\"checking the argument\");\n-                    let mut formal_ty = formal_tys[i];\n+                    let mut formal_ty = *formal_tys.get(i);\n \n                     match deref_args {\n                         DoDerefArgs => {\n@@ -1841,7 +1843,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n     }\n \n     fn err_args(len: uint) -> Vec<ty::t> {\n-        vec::from_fn(len, |_| ty::mk_err())\n+        Vec::from_fn(len, |_| ty::mk_err())\n     }\n \n     fn write_call(fcx: @FnCtxt, call_expr: &ast::Expr, output: ty::t) {\n@@ -1892,7 +1894,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n         });\n \n         // Call the generic checker.\n-        check_argument_types(fcx, call_expr.span, fn_sig.inputs, f,\n+        check_argument_types(fcx, call_expr.span, fn_sig.inputs.as_slice(), f,\n                              args, DontDerefArgs, fn_sig.variadic);\n \n         write_call(fcx, call_expr, fn_sig.output);\n@@ -2310,7 +2312,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                 // field\n                 debug!(\"class named {}\", ppaux::ty_to_str(tcx, base_t));\n                 let cls_items = ty::lookup_struct_fields(tcx, base_id);\n-                match lookup_field_ty(tcx, base_id, cls_items,\n+                match lookup_field_ty(tcx, base_id, cls_items.as_slice(),\n                                       field, &(*substs)) {\n                     Some(field_ty) => {\n                         // (2) look up what field's type is, and return it\n@@ -2330,7 +2332,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                              base,\n                              field,\n                              expr_t,\n-                             tps,\n+                             tps.as_slice(),\n                              DontDerefArgs,\n                              CheckTraitsAndInherentMethods,\n                              AutoderefReceiver) {\n@@ -2484,7 +2486,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                            class_id,\n                                            id,\n                                            substitutions,\n-                                           class_fields,\n+                                           class_fields.as_slice(),\n                                            fields,\n                                            base_expr.is_none());\n         if ty::type_is_error(fcx.node_ty(id)) {\n@@ -2542,7 +2544,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                        variant_id,\n                                        id,\n                                        substitutions,\n-                                       variant_fields,\n+                                       variant_fields.as_slice(),\n                                        fields,\n                                        true);\n         fcx.write_ty(id, enum_type);\n@@ -2621,18 +2623,21 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                   // places: the exchange heap and the managed heap.\n                   let definition = lookup_def(fcx, path.span, place.id);\n                   let def_id = ast_util::def_id_of_def(definition);\n-                  match tcx.lang_items.items[ExchangeHeapLangItem as uint] {\n-                      Some(item_def_id) if def_id == item_def_id => {\n+                  match tcx.lang_items\n+                           .items\n+                           .get(ExchangeHeapLangItem as uint) {\n+                      &Some(item_def_id) if def_id == item_def_id => {\n                           fcx.write_ty(id, ty::mk_uniq(tcx,\n                                                        fcx.expr_ty(subexpr)));\n                           checked = true\n                       }\n-                      Some(_) | None => {}\n+                      &Some(_) | &None => {}\n                   }\n                   if !checked {\n                       match tcx.lang_items\n-                               .items[ManagedHeapLangItem as uint] {\n-                          Some(item_def_id) if def_id == item_def_id => {\n+                               .items\n+                               .get(ManagedHeapLangItem as uint) {\n+                          &Some(item_def_id) if def_id == item_def_id => {\n                               // Assign the magic `Gc<T>` struct.\n                               let gc_struct_id =\n                                   match tcx.lang_items\n@@ -2661,7 +2666,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                               fcx.write_ty(id, sty);\n                               checked = true\n                           }\n-                          Some(_) | None => {}\n+                          &Some(_) | &None => {}\n                       }\n                   }\n               }\n@@ -2750,7 +2755,8 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n                                     ty::ty_struct(did, ref substs) => {\n                                         let fields = ty::struct_fields(fcx.tcx(), did, substs);\n                                         fields.len() == 1\n-                                        && fields[0].ident == token::special_idents::unnamed_field\n+                                        && fields.get(0).ident ==\n+                                        token::special_idents::unnamed_field\n                                     }\n                                     _ => false\n                                 };\n@@ -3129,7 +3135,7 @@ fn check_expr_with_unifier(fcx: @FnCtxt,\n \n         let elt_ts = elts.iter().enumerate().map(|(i, e)| {\n             let opt_hint = match flds {\n-                Some(ref fs) if i < fs.len() => Some(fs[i]),\n+                Some(ref fs) if i < fs.len() => Some(*fs.get(i)),\n                 _ => None\n             };\n             check_expr_with_opt_hint(fcx, *e, opt_hint);\n@@ -3492,7 +3498,7 @@ pub fn check_simd(tcx: ty::ctxt, sp: Span, id: ast::NodeId) {\n                 tcx.sess.span_err(sp, \"SIMD vector cannot be empty\");\n                 return;\n             }\n-            let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n+            let e = ty::lookup_field_type(tcx, did, fields.get(0).id, substs);\n             if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n                 tcx.sess.span_err(sp, \"SIMD vector should be homogeneous\");\n@@ -3805,7 +3811,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n                                    .enumerate() {\n             match self_parameter_index {\n                 Some(index) if index == i => {\n-                    tps.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    tps.push(*fcx.infcx().next_ty_vars(1).get(0));\n                     pushed = true;\n                 }\n                 _ => {}\n@@ -3829,7 +3835,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n         for (i, default) in defaults.skip(ty_substs_len).enumerate() {\n             match self_parameter_index {\n                 Some(index) if index == i + ty_substs_len => {\n-                    substs.tps.push(fcx.infcx().next_ty_vars(1)[0]);\n+                    substs.tps.push(*fcx.infcx().next_ty_vars(1).get(0));\n                     pushed = true;\n                 }\n                 _ => {}\n@@ -3848,7 +3854,7 @@ pub fn instantiate_path(fcx: @FnCtxt,\n \n         // If the self parameter goes at the end, insert it there.\n         if !pushed && self_parameter_index.is_some() {\n-            substs.tps.push(fcx.infcx().next_ty_vars(1)[0])\n+            substs.tps.push(*fcx.infcx().next_ty_vars(1).get(0))\n         }\n \n         assert_eq!(substs.tps.len(), ty_param_count)\n@@ -4028,7 +4034,7 @@ pub fn check_intrinsic_type(ccx: @CrateCtxt, it: &ast::ForeignItem) {\n         assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n \n         //We only care about the operation here\n-        match split[1] {\n+        match *split.get(1) {\n             \"cxchg\" => (1, vec!(ty::mk_mut_rptr(tcx,\n                                              ty::ReLateBound(it.id, ty::BrAnon(0)),\n                                              param(ccx, 0)),"}, {"sha": "d0bb1f32fb8fff053975f261eccbd672de774697", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -13,7 +13,9 @@\n use middle::ty;\n use middle::ty_fold;\n use middle::ty_fold::TypeFolder;\n+\n use collections::HashMap;\n+use std::vec_ng::Vec;\n use util::ppaux::Repr;\n use util::ppaux;\n "}, {"sha": "32e1dfd98db57772f5e828e8231ae6306e41dd9d", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -26,9 +26,10 @@ use util::common::indenter;\n use util::ppaux;\n use util::ppaux::Repr;\n \n-use std::cell::RefCell;\n use collections::HashSet;\n+use std::cell::RefCell;\n use std::result;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::codemap::Span;\n@@ -100,13 +101,13 @@ fn lookup_vtables(vcx: &VtableContext,\n \n     // We do this backwards for reasons discussed above.\n     assert_eq!(substs.tps.len(), type_param_defs.len());\n-    let mut result =\n+    let mut result: Vec<vtable_param_res> =\n         substs.tps.rev_iter()\n         .zip(type_param_defs.rev_iter())\n         .map(|(ty, def)|\n                    lookup_vtables_for_param(vcx, location_info, Some(substs),\n                                             &*def.bounds, *ty, is_early))\n-        .to_owned_vec();\n+        .collect();\n     result.reverse();\n \n     assert_eq!(substs.tps.len(), result.len());\n@@ -134,7 +135,10 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n     // ty is the value supplied for the type parameter A...\n     let mut param_result = Vec::new();\n \n-    ty::each_bound_trait_and_supertraits(tcx, type_param_bounds.trait_bounds, |trait_ref| {\n+    ty::each_bound_trait_and_supertraits(tcx,\n+                                         type_param_bounds.trait_bounds\n+                                                          .as_slice(),\n+                                         |trait_ref| {\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n@@ -252,7 +256,11 @@ fn lookup_vtable(vcx: &VtableContext,\n     let vtable_opt = match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, ..}) => {\n             let type_param_bounds: &[@ty::TraitRef] =\n-                vcx.param_env.type_param_bounds[n].trait_bounds;\n+                vcx.param_env\n+                   .type_param_bounds\n+                   .get(n)\n+                   .trait_bounds\n+                   .as_slice();\n             lookup_vtable_from_bounds(vcx,\n                                       location_info,\n                                       type_param_bounds,\n@@ -392,7 +400,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // the type self_ty, and substs is bound to [T].\n         debug!(\"The self ty is {} and its substs are {}\",\n                vcx.infcx.ty_to_str(for_ty),\n-               vcx.infcx.tys_to_str(substs.tps));\n+               vcx.infcx.tys_to_str(substs.tps.as_slice()));\n \n         // Next, we unify trait_ref -- the type that we want to cast\n         // to -- with of_trait_ref -- the trait that im implements. At\n@@ -445,7 +453,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         debug!(\"The fixed-up substs are {} - \\\n                 they will be unified with the bounds for \\\n                 the target ty, {}\",\n-               vcx.infcx.tys_to_str(substs_f.tps),\n+               vcx.infcx.tys_to_str(substs_f.tps.as_slice()),\n                vcx.infcx.trait_ref_to_str(trait_ref));\n \n         // Next, we unify the fixed-up substitutions for the impl self\n@@ -465,14 +473,14 @@ fn search_for_vtable(vcx: &VtableContext,\n \n     match found.len() {\n         0 => { return None }\n-        1 => return Some(found[0].clone()),\n+        1 => return Some(found.get(0).clone()),\n         _ => {\n             if !is_early {\n                 vcx.tcx().sess.span_err(\n                     location_info.span,\n                     \"multiple applicable methods in scope\");\n             }\n-            return Some(found[0].clone());\n+            return Some(found.get(0).clone());\n         }\n     }\n }\n@@ -701,11 +709,15 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n             debug!(\"vtable resolution on parameter bounds for method call {}\",\n                    ex.repr(fcx.tcx()));\n             let type_param_defs = ty::method_call_type_param_defs(cx.tcx, method.origin);\n-            if has_trait_bounds(*type_param_defs.borrow()) {\n+            if has_trait_bounds(type_param_defs.borrow().as_slice()) {\n                 let substs = fcx.method_ty_substs(ex.id);\n                 let vcx = fcx.vtable_context();\n-                let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n-                                           *type_param_defs.borrow(), &substs, is_early);\n+                let vtbls = lookup_vtables(&vcx,\n+                                           &location_info_for_expr(ex),\n+                                           type_param_defs.borrow()\n+                                                          .as_slice(),\n+                                           &substs,\n+                                           is_early);\n                 if !is_early {\n                     insert_vtables(fcx, ex.id, vtbls);\n                 }\n@@ -817,7 +829,7 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n                             substs: &ty::substs) -> Option<vtable_res> {\n     let generics = ty::lookup_item_type(tcx, ast_util::local_def(id)).generics;\n     let type_param_defs = generics.type_param_defs.borrow();\n-    if has_trait_bounds(*type_param_defs) {\n+    if has_trait_bounds(type_param_defs.as_slice()) {\n         let vcx = VtableContext {\n             infcx: &infer::new_infer_ctxt(tcx),\n             param_env: &ty::construct_parameter_environment(tcx, None, [], [], [], id)\n@@ -827,7 +839,11 @@ pub fn trans_resolve_method(tcx: ty::ctxt, id: ast::NodeId,\n             span: tcx.map.span(id)\n         };\n \n-        Some(lookup_vtables(&vcx, &loc_info, *type_param_defs, substs, false))\n+        Some(lookup_vtables(&vcx,\n+                            &loc_info,\n+                            type_param_defs.as_slice(),\n+                            substs,\n+                            false))\n     } else {\n         None\n     }"}, {"sha": "ced9db069545beb8301b0ca5407bc070793f9953", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -28,6 +28,7 @@ use middle::typeck::write_ty_to_tcx;\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::print::pprust::pat_to_str;\n@@ -54,12 +55,12 @@ fn resolve_type_vars_in_type(fcx: @FnCtxt, sp: Span, typ: ty::t)\n \n fn resolve_type_vars_in_types(fcx: @FnCtxt, sp: Span, tys: &[ty::t])\n                           -> Vec<ty::t> {\n-    tys.map(|t| {\n+    tys.iter().map(|t| {\n         match resolve_type_vars_in_type(fcx, sp, *t) {\n             Some(t1) => t1,\n             None => ty::mk_err()\n         }\n-    })\n+    }).collect()\n }\n \n fn resolve_method_map_entry(wbcx: &mut WbCtxt, sp: Span, id: ast::NodeId) {\n@@ -122,7 +123,9 @@ fn resolve_vtable_map_entry(fcx: @FnCtxt, sp: Span, id: ast::NodeId) {\n                       origin: &vtable_origin) -> vtable_origin {\n         match origin {\n             &vtable_static(def_id, ref tys, origins) => {\n-                let r_tys = resolve_type_vars_in_types(fcx, sp, *tys);\n+                let r_tys = resolve_type_vars_in_types(fcx,\n+                                                       sp,\n+                                                       tys.as_slice());\n                 let r_origins = resolve_origins(fcx, sp, origins);\n                 vtable_static(def_id, r_tys, r_origins)\n             }"}, {"sha": "e85d71fa982ce0d140bdf835578d9f63d20c385f", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -46,10 +46,11 @@ use syntax::opt_vec;\n use syntax::parse::token;\n use syntax::visit;\n \n-use std::cell::RefCell;\n use collections::HashSet;\n+use std::cell::RefCell;\n use std::rc::Rc;\n-use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n \n struct UniversalQuantificationResult {\n     monotype: t,\n@@ -355,7 +356,8 @@ impl CoherenceChecker {\n             let new_generics = ty::Generics {\n                 type_param_defs:\n                     Rc::new(vec_ng::append(\n-                        impl_poly_type.generics.type_param_defs().to_owned(),\n+                        Vec::from_slice(impl_poly_type.generics\n+                                                      .type_param_defs()),\n                             new_method_ty.generics.type_param_defs())),\n                 region_param_defs:\n                     impl_poly_type.generics.region_param_defs.clone()\n@@ -722,7 +724,7 @@ impl CoherenceChecker {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;\n             }\n-            let method_def_id = impl_info.methods[0].def_id;\n+            let method_def_id = impl_info.methods.get(0).def_id;\n \n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {\n@@ -789,10 +791,10 @@ pub fn make_substs_for_receiver_types(tcx: ty::ctxt,\n         num_trait_type_parameters + method.generics.type_param_defs().len();\n \n     // the new method type will have the type parameters from the impl + method\n-    let combined_tps = vec::from_fn(num_method_type_parameters, |i| {\n+    let combined_tps = Vec::from_fn(num_method_type_parameters, |i| {\n         if i < num_trait_type_parameters {\n             // replace type parameters that come from trait with new value\n-            trait_ref.substs.tps[i]\n+            *trait_ref.substs.tps.get(i)\n         } else {\n             // replace type parameters that belong to method with another\n             // type parameter, this time with the index adjusted"}, {"sha": "18fbb47aad1b28c02c303be109f54ccf5225cf0e", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -46,6 +46,8 @@ use util::ppaux::Repr;\n \n use std::rc::Rc;\n use std::vec;\n+use std::vec_ng::Vec;\n+use std::vec_ng;\n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n@@ -324,7 +326,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let substs = substs {\n             regions: ty::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n-            tps: non_shifted_trait_tps + shifted_method_tps\n+            tps: vec_ng::append(Vec::from_slice(non_shifted_trait_tps),\n+                                shifted_method_tps)\n         };\n \n         // create the type of `foo`, applying the substitution above\n@@ -339,7 +342,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n         let mut new_type_param_defs = Vec::new();\n         let substd_type_param_defs =\n             trait_ty_generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n+        new_type_param_defs.push_all(substd_type_param_defs.borrow()\n+                                                           .as_slice());\n \n         // add in the \"self\" type parameter\n         let self_trait_def = get_trait_def(ccx, local_def(trait_id));\n@@ -356,7 +360,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n \n         // add in the type parameters from the method\n         let substd_type_param_defs = m.generics.type_param_defs.subst(tcx, &substs);\n-        new_type_param_defs.push_all(*substd_type_param_defs.borrow());\n+        new_type_param_defs.push_all(substd_type_param_defs.borrow()\n+                                                           .as_slice());\n \n         debug!(\"static method {} type_param_defs={} ty={}, substs={}\",\n                m.def_id.repr(tcx),\n@@ -495,7 +500,8 @@ fn convert_methods(ccx: &CrateCtxt,\n                 ty_param_bounds_and_ty {\n                     generics: ty::Generics {\n                         type_param_defs: Rc::new(vec_ng::append(\n-                            rcvr_ty_generics.type_param_defs().to_owned(),\n+                            Vec::from_slice(\n+                                rcvr_ty_generics.type_param_defs()),\n                             m_ty_generics.type_param_defs())),\n                         region_param_defs: rcvr_ty_generics.region_param_defs.clone(),\n                     },"}, {"sha": "32b6da40b085577643871a60857e5964ca85efac", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -63,6 +63,7 @@ use util::common::indent;\n use util::ppaux::Repr;\n \n use std::result;\n+use std::vec_ng::Vec;\n use syntax::ast::{Onceness, Purity};\n use syntax::ast;\n use syntax::opt_vec;\n@@ -92,7 +93,7 @@ pub trait Combine {\n         if as_.len() == bs.len() {\n             result::fold_(as_.iter().zip(bs.iter())\n                           .map(|(a, b)| eq_tys(self, *a, *b)))\n-                .then(|| Ok(as_.to_owned()))\n+                .then(|| Ok(Vec::from_slice(as_)))\n         } else {\n             Err(ty::terr_ty_param_size(expected_found(self,\n                                                       as_.len(),\n@@ -180,7 +181,7 @@ pub trait Combine {\n             }\n         }\n \n-        let tps = if_ok!(self.tps(as_.tps, bs.tps));\n+        let tps = if_ok!(self.tps(as_.tps.as_slice(), bs.tps.as_slice()));\n         let self_ty = if_ok!(self.self_tys(as_.self_ty, bs.self_ty));\n         let regions = if_ok!(relate_region_params(self,\n                                                   item_def_id,\n@@ -409,7 +410,9 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n         return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n     }\n \n-    let inputs = if_ok!(argvecs(this, a.inputs, b.inputs));\n+    let inputs = if_ok!(argvecs(this,\n+                                a.inputs.as_slice(),\n+                                b.inputs.as_slice()));\n     let output = if_ok!(this.tys(a.output, b.output));\n     Ok(FnSig {binder_id: a.binder_id,\n               inputs: inputs,"}, {"sha": "68b609000f41b08db67fdda9dc4e0568fb152cb4", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -155,10 +155,16 @@ impl<'f> Combine for Glb<'f> {\n             fold_regions_in_sig(\n                 self.get_ref().infcx.tcx,\n                 &sig0,\n-                |r| generalize_region(self, snapshot,\n-                                      new_vars, sig0.binder_id,\n-                                      &a_map, a_vars, b_vars,\n-                                      r));\n+                |r| {\n+                generalize_region(self,\n+                                  snapshot,\n+                                  new_vars.as_slice(),\n+                                  sig0.binder_id,\n+                                  &a_map,\n+                                  a_vars.as_slice(),\n+                                  b_vars.as_slice(),\n+                                  r)\n+            });\n         debug!(\"sig1 = {}\", sig1.inf_str(self.get_ref().infcx));\n         return Ok(sig1);\n "}, {"sha": "a97f1561c8dbb9dbe9f6d7d927a67c6fd44ab30f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -43,9 +43,11 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::unify::*;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n-use collections::HashMap;\n use util::common::indenter;\n \n+use collections::HashMap;\n+use std::vec_ng::Vec;\n+\n pub trait LatticeValue {\n     fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n     fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;"}, {"sha": "0f2b2da397e9d128f39c6f3acdb91b21a5e34b96", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -143,7 +143,7 @@ impl<'f> Combine for Lub<'f> {\n             fold_regions_in_sig(\n                 self.get_ref().infcx.tcx,\n                 &sig0,\n-                |r| generalize_region(self, snapshot, new_vars,\n+                |r| generalize_region(self, snapshot, new_vars.as_slice(),\n                                       sig0.binder_id, &a_map, r));\n         return Ok(sig1);\n "}, {"sha": "5500d9afc6750affc7b90ca9f53e2eeeba851937", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -21,6 +21,7 @@ pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n+use collections::HashMap;\n use collections::SmallIntMap;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n@@ -37,9 +38,8 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{Cell, RefCell};\n-use collections::HashMap;\n use std::result;\n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n@@ -623,7 +623,7 @@ impl InferCtxt {\n     }\n \n     pub fn next_ty_vars(&self, n: uint) -> Vec<ty::t> {\n-        vec::from_fn(n, |_i| self.next_ty_var())\n+        Vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -660,7 +660,7 @@ impl InferCtxt {\n                             origin: RegionVariableOrigin,\n                             count: uint)\n                             -> Vec<ty::Region> {\n-        vec::from_fn(count, |_| self.next_region_var(origin))\n+        Vec::from_fn(count, |_| self.next_region_var(origin))\n     }\n \n     pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {"}, {"sha": "57168eaec89099b30f2fbb1ff8a7908c009b8762", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -27,6 +27,7 @@ use util::ppaux::{Repr};\n use std::cell::{Cell, RefCell};\n use std::uint;\n use std::vec;\n+use std::vec_ng::Vec;\n use collections::{HashMap, HashSet};\n use syntax::ast;\n use syntax::opt_vec;\n@@ -354,11 +355,11 @@ impl RegionVarBindings {\n             None => {\n                 let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    var_origins.get()[rid.to_uint()].span(),\n+                    var_origins.get().get(rid.to_uint()).span(),\n                     format!(\"attempt to resolve region variable before \\\n                              values have been computed!\"))\n             }\n-            Some(ref values) => values[rid.to_uint()]\n+            Some(ref values) => *values.get(rid.to_uint())\n         };\n \n         debug!(\"RegionVarBindings: resolve_var({:?}={})={:?}\",\n@@ -457,7 +458,7 @@ impl RegionVarBindings {\n         let mut result_index = 0;\n         while result_index < result_set.len() {\n             // nb: can't use uint::range() here because result_set grows\n-            let r = result_set[result_index];\n+            let r = *result_set.get(result_index);\n \n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n@@ -466,18 +467,18 @@ impl RegionVarBindings {\n                 // nb: can't use uint::range() here as we move result_set\n                 let regs = {\n                     let undo_log = self.undo_log.borrow();\n-                    match undo_log.get()[undo_index] {\n-                        AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n+                    match undo_log.get().get(undo_index) {\n+                        &AddConstraint(ConstrainVarSubVar(ref a, ref b)) => {\n                             Some((ReInfer(ReVar(*a)),\n                                   ReInfer(ReVar(*b))))\n                         }\n-                        AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n+                        &AddConstraint(ConstrainRegSubVar(ref a, ref b)) => {\n                             Some((*a, ReInfer(ReVar(*b))))\n                         }\n-                        AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n+                        &AddConstraint(ConstrainVarSubReg(ref a, ref b)) => {\n                             Some((ReInfer(ReVar(*a)), *b))\n                         }\n-                        AddConstraint(ConstrainRegSubReg(a, b)) => {\n+                        &AddConstraint(ConstrainRegSubReg(a, b)) => {\n                             Some((a, b))\n                         }\n                         _ => {\n@@ -563,7 +564,7 @@ impl RegionVarBindings {\n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             let var_origins = self.var_origins.borrow();\n             self.tcx.sess.span_bug(\n-                var_origins.get()[v_id.to_uint()].span(),\n+                var_origins.get().get(v_id.to_uint()).span(),\n                 format!(\"lub_concrete_regions invoked with \\\n                       non-concrete regions: {:?}, {:?}\", a, b));\n           }\n@@ -668,7 +669,7 @@ impl RegionVarBindings {\n             (_, ReInfer(ReVar(v_id))) => {\n                 let var_origins = self.var_origins.borrow();\n                 self.tcx.sess.span_bug(\n-                    var_origins.get()[v_id.to_uint()].span(),\n+                    var_origins.get().get(v_id.to_uint()).span(),\n                     format!(\"glb_concrete_regions invoked with \\\n                           non-concrete regions: {:?}, {:?}\", a, b));\n             }\n@@ -782,14 +783,14 @@ impl RegionVarBindings {\n                              errors: &mut OptVec<RegionResolutionError>)\n                              -> Vec<VarValue> {\n         let mut var_data = self.construct_var_data();\n-        self.expansion(var_data);\n-        self.contraction(var_data);\n-        self.collect_concrete_region_errors(errors);\n-        self.extract_values_and_collect_conflicts(var_data, errors)\n+        self.expansion(var_data.as_mut_slice());\n+        self.contraction(var_data.as_mut_slice());\n+        self.collect_concrete_region_errors(&mut *errors);\n+        self.extract_values_and_collect_conflicts(var_data.as_slice(), errors)\n     }\n \n     fn construct_var_data(&self) -> Vec<VarData> {\n-        vec::from_fn(self.num_vars(), |_| {\n+        Vec::from_fn(self.num_vars(), |_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -1071,7 +1072,7 @@ impl RegionVarBindings {\n             }\n         }\n \n-        vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n+        Vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n     }\n \n     fn construct_graph(&self) -> RegionGraph {\n@@ -1143,7 +1144,7 @@ impl RegionVarBindings {\n                     {\n                         let var_origins = self.var_origins.borrow();\n                         errors.push(SubSupConflict(\n-                            var_origins.get()[node_idx.to_uint()],\n+                            *var_origins.get().get(node_idx.to_uint()),\n                             lower_bound.origin,\n                             lower_bound.region,\n                             upper_bound.origin,\n@@ -1156,7 +1157,7 @@ impl RegionVarBindings {\n \n         let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            var_origins.get()[node_idx.to_uint()].span(),\n+            var_origins.get().get(node_idx.to_uint()).span(),\n             format!(\"collect_error_for_expanding_node() could not find error \\\n                   for var {:?}, lower_bounds={}, upper_bounds={}\",\n                  node_idx,\n@@ -1190,7 +1191,7 @@ impl RegionVarBindings {\n                   Err(_) => {\n                     let var_origins = self.var_origins.borrow();\n                     errors.push(SupSupConflict(\n-                        var_origins.get()[node_idx.to_uint()],\n+                        *var_origins.get().get(node_idx.to_uint()),\n                         upper_bound_1.origin,\n                         upper_bound_1.region,\n                         upper_bound_2.origin,\n@@ -1203,7 +1204,7 @@ impl RegionVarBindings {\n \n         let var_origins = self.var_origins.borrow();\n         self.tcx.sess.span_bug(\n-            var_origins.get()[node_idx.to_uint()].span(),\n+            var_origins.get().get(node_idx.to_uint()).span(),\n             format!(\"collect_error_for_contracting_node() could not find error \\\n                   for var {:?}, upper_bounds={}\",\n                  node_idx,"}, {"sha": "d4ee567ba41b7ffaa1a893a8d7fea48cf4cb3930", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -58,6 +58,7 @@ use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n \n+use std::vec_ng::Vec;\n use syntax::ast;\n \n pub static resolve_nested_tvar: uint = 0b0000000001;"}, {"sha": "b58fa905ca4eb1dc25abf3cd77d1d8ada4b1c3f7", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -17,6 +17,7 @@ use middle::typeck::infer::{Bounds, uok, ures};\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::to_str::InferStr;\n use std::cell::RefCell;\n+use std::vec_ng::Vec;\n use syntax::ast;\n \n #[deriving(Clone)]"}, {"sha": "86f642a228d89104926daf3e460faaa0f45ee1b7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -72,6 +72,7 @@ use util::nodemap::{DefIdMap, NodeMap};\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::vec_ng::Vec;\n use collections::List;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;"}, {"sha": "eb633eb2eee01012f184fd0d263cc2ab1bf0cadd", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -12,7 +12,7 @@\n use middle::ty;\n \n use std::cell::Cell;\n-use std::vec;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::codemap::Span;\n use syntax::opt_vec::OptVec;\n@@ -69,7 +69,7 @@ impl RegionScope for BindingRscope {\n                     -> Result<Vec<ty::Region> , ()> {\n         let idx = self.anon_bindings.get();\n         self.anon_bindings.set(idx + count);\n-        Ok(vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n+        Ok(Vec::from_fn(count, |i| ty::ReLateBound(self.binder_id,\n                                                    ty::BrAnon(idx + i))))\n     }\n }"}, {"sha": "3712f04635878c680b40fa7ff1818d325c0b1f4e", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -196,8 +196,8 @@ use collections::HashMap;\n use arena;\n use arena::Arena;\n use middle::ty;\n-use std::vec;\n use std::fmt;\n+use std::vec_ng::Vec;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::opt_vec;\n@@ -561,7 +561,7 @@ impl<'a> ConstraintContext<'a> {\n             // variance not yet inferred, so return a symbolic\n             // variance.\n             let InferredIndex(index) = self.inferred_index(param_def_id.node);\n-            self.terms_cx.inferred_infos[index].term\n+            self.terms_cx.inferred_infos.get(index).term\n         } else {\n             // Parameter on an item defined within another crate:\n             // variance already inferred, just look it up.\n@@ -749,7 +749,7 @@ impl<'a> ConstraintContext<'a> {\n             let variance_decl =\n                 self.declared_variance(p.def_id, def_id, TypeParam, i);\n             let variance_i = self.xform(variance, variance_decl);\n-            self.add_constraints_from_ty(substs.tps[i], variance_i);\n+            self.add_constraints_from_ty(*substs.tps.get(i), variance_i);\n         }\n \n         match substs.regions {\n@@ -842,7 +842,7 @@ struct SolveContext<'a> {\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n     let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n-    let solutions = vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n+    let solutions = Vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,\n         constraints: constraints,\n@@ -867,18 +867,21 @@ impl<'a> SolveContext<'a> {\n                 let Constraint { inferred, variance: term } = *constraint;\n                 let InferredIndex(inferred) = inferred;\n                 let variance = self.evaluate(term);\n-                let old_value = self.solutions[inferred];\n+                let old_value = *self.solutions.get(inferred);\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n                     debug!(\"Updating inferred {} (node {}) \\\n                             from {:?} to {:?} due to {}\",\n                             inferred,\n-                            self.terms_cx.inferred_infos[inferred].param_id,\n+                            self.terms_cx\n+                                .inferred_infos\n+                                .get(inferred)\n+                                .param_id,\n                             old_value,\n                             new_value,\n                             term.to_str());\n \n-                    self.solutions[inferred] = new_value;\n+                    *self.solutions.get_mut(inferred) = new_value;\n                     changed = true;\n                 }\n             }\n@@ -901,25 +904,28 @@ impl<'a> SolveContext<'a> {\n         let mut index = 0;\n         let num_inferred = self.terms_cx.num_inferred();\n         while index < num_inferred {\n-            let item_id = inferred_infos[index].item_id;\n+            let item_id = inferred_infos.get(index).item_id;\n             let mut item_variances = ty::ItemVariances {\n                 self_param: None,\n                 type_params: opt_vec::Empty,\n                 region_params: opt_vec::Empty\n             };\n             while index < num_inferred &&\n-                  inferred_infos[index].item_id == item_id {\n-                let info = &inferred_infos[index];\n+                  inferred_infos.get(index).item_id == item_id {\n+                let info = inferred_infos.get(index);\n                 match info.kind {\n                     SelfParam => {\n                         assert!(item_variances.self_param.is_none());\n-                        item_variances.self_param = Some(solutions[index]);\n+                        item_variances.self_param =\n+                            Some(*solutions.get(index));\n                     }\n                     TypeParam => {\n-                        item_variances.type_params.push(solutions[index]);\n+                        item_variances.type_params\n+                                      .push(*solutions.get(index));\n                     }\n                     RegionParam => {\n-                        item_variances.region_params.push(solutions[index]);\n+                        item_variances.region_params\n+                                      .push(*solutions.get(index));\n                     }\n                 }\n                 index += 1;\n@@ -958,7 +964,7 @@ impl<'a> SolveContext<'a> {\n             }\n \n             InferredTerm(InferredIndex(index)) => {\n-                self.solutions[index]\n+                *self.solutions.get(index)\n             }\n         }\n     }"}, {"sha": "fb417390905ae7f3d12ba7b4c1f4340b25b3be24", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -16,6 +16,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n \n use std::local_data;\n+use std::vec_ng::Vec;\n \n use time;\n "}, {"sha": "ecba394b88e244e3896fe6a603efd694d604470a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -22,6 +22,8 @@ use middle::ty::{ty_nil, ty_param, ty_ptr, ty_rptr, ty_self, ty_tup};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_unboxed_vec, ty_infer};\n use middle::ty;\n use middle::typeck;\n+\n+use std::vec_ng::Vec;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n@@ -476,12 +478,17 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       ty_self(..) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let base = ty::item_path_str(cx, did);\n-        parameterized(cx, base, &substs.regions, substs.tps, did, false)\n+        parameterized(cx,\n+                      base,\n+                      &substs.regions,\n+                      substs.tps.as_slice(),\n+                      did,\n+                      false)\n       }\n       ty_trait(did, ref substs, s, mutbl, ref bounds) => {\n         let base = ty::item_path_str(cx, did);\n         let ty = parameterized(cx, base, &substs.regions,\n-                               substs.tps, did, true);\n+                               substs.tps.as_slice(), did, true);\n         let bound_sep = if bounds.is_empty() { \"\" } else { \":\" };\n         let bound_str = bounds.repr(cx);\n         format!(\"{}{}{}{}{}\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n@@ -521,7 +528,7 @@ pub fn parameterized(cx: ctxt,\n     let num_defaults = if has_defaults {\n         // We should have a borrowed version of substs instead of cloning.\n         let mut substs = ty::substs {\n-            tps: tps.to_owned(),\n+            tps: Vec::from_slice(tps),\n             regions: regions.clone(),\n             self_ty: None\n         };\n@@ -612,7 +619,7 @@ impl<T:Repr> Repr for OptVec<T> {\n // autoderef cannot convert the &[T] handler\n impl<T:Repr> Repr for Vec<T> {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        repr_vec(tcx, *self)\n+        repr_vec(tcx, self.as_slice())\n     }\n }\n \n@@ -989,10 +996,10 @@ impl UserString for ty::TraitRef {\n             let mut all_tps = self.substs.tps.clone();\n             for &t in self.substs.self_ty.iter() { all_tps.push(t); }\n             parameterized(tcx, base, &self.substs.regions,\n-                          all_tps, self.def_id, true)\n+                          all_tps.as_slice(), self.def_id, true)\n         } else {\n             parameterized(tcx, base, &self.substs.regions,\n-                          self.substs.tps, self.def_id, true)\n+                          self.substs.tps.as_slice(), self.def_id, true)\n         }\n     }\n }"}, {"sha": "c5e75b52bf33c819a8457cb2204d7fdcbcba5fc1", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43c07244b32d7aea97e02ededa5797308515e26b/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=43c07244b32d7aea97e02ededa5797308515e26b", "patch": "@@ -14,8 +14,8 @@\n \n use std::iter::range_step;\n use std::num::Zero;\n-use std::vec;\n use std::vec::bytes::{MutableByteVector, copy_memory};\n+use std::vec_ng::Vec;\n use serialize::hex::ToHex;\n \n /// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n@@ -254,15 +254,15 @@ pub trait Digest {\n     /// Convenience function that retrieves the result of a digest as a\n     /// newly allocated vec of bytes.\n     fn result_bytes(&mut self) -> Vec<u8> {\n-        let mut buf = vec::from_elem((self.output_bits()+7)/8, 0u8);\n-        self.result(buf);\n+        let mut buf = Vec::from_elem((self.output_bits()+7)/8, 0u8);\n+        self.result(buf.as_mut_slice());\n         buf\n     }\n \n     /// Convenience function that retrieves the result of a digest as a\n     /// ~str in hexadecimal format.\n     fn result_str(&mut self) -> ~str {\n-        self.result_bytes().to_hex()\n+        self.result_bytes().as_slice().to_hex()\n     }\n }\n \n@@ -527,6 +527,7 @@ mod tests {\n     use super::{Digest, Sha256, FixedBuffer};\n     use std::num::Bounded;\n     use std::vec;\n+    use std::vec_ng::Vec;\n     use std::rand::isaac::IsaacRng;\n     use std::rand::Rng;\n     use serialize::hex::FromHex;\n@@ -594,7 +595,7 @@ mod tests {\n \n         let mut sh = ~Sha256::new();\n \n-        test_hash(sh, tests);\n+        test_hash(sh, tests.as_slice());\n     }\n \n     /// Feed 1,000,000 'a's into the digest with varying input sizes and check that the result is\n@@ -619,7 +620,12 @@ mod tests {\n         let result_bytes = digest.result_bytes();\n \n         assert_eq!(expected, result_str.as_slice());\n-        assert_eq!(expected.from_hex().unwrap(), result_bytes);\n+\n+        let expected_vec: Vec<u8> = expected.from_hex()\n+                                            .unwrap()\n+                                            .move_iter()\n+                                            .collect();\n+        assert_eq!(expected_vec, result_bytes);\n     }\n \n     #[test]"}]}