{"sha": "178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OGE4ZjExMzlkZGFkMmFhNTljZTBlNTRjZjEwNjU5ZGM0ZWVkMzA=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-04-12T16:53:29Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-15T13:20:19Z"}, "message": "Rename GenericParam to GenericParamDef", "tree": {"sha": "a51e673defd1c748c62423feaf405b52b3b24796", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a51e673defd1c748c62423feaf405b52b3b24796"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "html_url": "https://github.com/rust-lang/rust/commit/178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15d2759d909ccb4b3146654a76845ef5e1d5f6cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d2759d909ccb4b3146654a76845ef5e1d5f6cb", "html_url": "https://github.com/rust-lang/rust/commit/15d2759d909ccb4b3146654a76845ef5e1d5f6cb"}], "stats": {"total": 76, "additions": 38, "deletions": 38}, "files": [{"sha": "35c92dd48aa406bf9412d0312144a08cf5199fbb", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -753,7 +753,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n     }\n }\n \n-impl_stable_hash_for!(enum ty::GenericParam {\n+impl_stable_hash_for!(enum ty::GenericParamDef {\n     Lifetime(lt),\n     Type(ty)\n });"}, {"sha": "3fe12e342ebab113073858723786a279bfc22e3a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -758,16 +758,16 @@ impl ty::EarlyBoundRegion {\n }\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum GenericParam {\n+pub enum GenericParamDef {\n     Lifetime(RegionParameterDef),\n     Type(TypeParameterDef),\n }\n \n-impl GenericParam {\n+impl GenericParamDef {\n     pub fn index(&self) -> u32 {\n         match self {\n-            GenericParam::Lifetime(lt) => lt.index,\n-            GenericParam::Type(ty)     => ty.index,\n+            GenericParamDef::Lifetime(lt) => lt.index,\n+            GenericParamDef::Type(ty)     => ty.index,\n         }\n     }\n }\n@@ -785,7 +785,7 @@ impl GenericParam {\n pub struct Generics {\n     pub parent: Option<DefId>,\n     pub parent_count: usize,\n-    pub params: Vec<GenericParam>,\n+    pub params: Vec<GenericParamDef>,\n \n     /// Reverse map to each `TypeParameterDef`'s `index` field\n     pub type_param_to_index: FxHashMap<DefId, u32>,\n@@ -801,7 +801,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n \n     pub fn lifetimes(&self) -> impl DoubleEndedIterator<Item = &RegionParameterDef> {\n         self.params.iter().filter_map(|p| {\n-            if let GenericParam::Lifetime(lt) = p {\n+            if let GenericParamDef::Lifetime(lt) = p {\n                 Some(lt)\n             } else {\n                 None\n@@ -811,7 +811,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n \n     pub fn types(&self) -> impl DoubleEndedIterator<Item = &TypeParameterDef> {\n         self.params.iter().filter_map(|p| {\n-            if let GenericParam::Type(ty) = p {\n+            if let GenericParamDef::Type(ty) = p {\n                 Some(ty)\n             } else {\n                 None\n@@ -821,7 +821,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n \n     pub fn requires_monomorphization(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         if self.params.iter().any(|p| {\n-            if let GenericParam::Type(_) = p { true } else { false }\n+            if let GenericParamDef::Type(_) = p { true } else { false }\n         }) {\n             return true;\n         }\n@@ -841,7 +841,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n         if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n             // We're currently assuming that lifetimes precede other generic parameters.\n             match self.params[index as usize - self.has_self as usize] {\n-                ty::GenericParam::Lifetime(ref lt) => lt,\n+                ty::GenericParamDef::Lifetime(ref lt) => lt,\n                 _ => bug!(\"expected region parameter, but found another generic parameter\")\n             }\n         } else {\n@@ -891,13 +891,13 @@ impl<'a, 'gcx, 'tcx> Generics {\n             if let Some(_) = (idx as usize).checked_sub(type_param_offset) {\n                 assert!(!is_separated_self, \"found a Self after type_param_offset\");\n                 match self.params[idx as usize] {\n-                    ty::GenericParam::Type(ref ty) => ty,\n+                    ty::GenericParamDef::Type(ref ty) => ty,\n                     _ => bug!(\"expected type parameter, but found another generic parameter\")\n                 }\n             } else {\n                 assert!(is_separated_self, \"non-Self param before type_param_offset\");\n                 match self.params[type_param_offset] {\n-                    ty::GenericParam::Type(ref ty) => ty,\n+                    ty::GenericParamDef::Type(ref ty) => ty,\n                     _ => bug!(\"expected type parameter, but found another generic parameter\")\n                 }\n             }"}, {"sha": "ed342e1d37e5754b15e0289a61f1ecd7b8557a26", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -253,10 +253,10 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n         for def in &defs.params {\n             let param = match def {\n-                ty::GenericParam::Lifetime(ref lt) => {\n+                ty::GenericParamDef::Lifetime(ref lt) => {\n                     mk_region(lt, substs).into()\n                 }\n-                ty::GenericParam::Type(ref ty) => {\n+                ty::GenericParamDef::Type(ref ty) => {\n                     if skip_self {\n                         skip_self = false;\n                         continue"}, {"sha": "03b685c82e7c818ab4f50bd3496655f610ecb0dd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -970,8 +970,8 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                    .map(|param| (param.def_id, param.index))\n                                    .collect();\n \n-    let lifetimes = regions.into_iter().map(|lt| ty::GenericParam::Lifetime(lt));\n-    let types = types.into_iter().map(|ty| ty::GenericParam::Type(ty));\n+    let lifetimes = regions.into_iter().map(|lt| ty::GenericParamDef::Lifetime(lt));\n+    let types = types.into_iter().map(|ty| ty::GenericParamDef::Type(ty));\n     let params = lifetimes.chain(types).collect();\n \n     tcx.alloc_generics(ty::Generics {"}, {"sha": "f35a4c080e50e18d0c2de523938443831025fe24", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -491,7 +491,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n         &self,\n         tcx: TyCtxt<'b, 'c, 'd>,\n         pred: ty::Predicate<'d>,\n-    ) -> FxHashSet<GenericParam> {\n+    ) -> FxHashSet<GenericParamDef> {\n         pred.walk_tys()\n             .flat_map(|t| {\n                 let mut regions = FxHashSet();\n@@ -502,7 +502,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                         // We only care about late bound regions, as we need to add them\n                         // to the 'for<>' section\n                         &ty::ReLateBound(_, ty::BoundRegion::BrNamed(_, name)) => {\n-                            Some(GenericParam::Lifetime(Lifetime(name.to_string())))\n+                            Some(GenericParamDef::Lifetime(Lifetime(name.to_string())))\n                         }\n                         &ty::ReVar(_) | &ty::ReEarlyBound(_) => None,\n                         _ => panic!(\"Unexpected region type {:?}\", r),\n@@ -850,7 +850,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n \n         for p in generic_params.iter_mut() {\n             match p {\n-                &mut GenericParam::Type(ref mut ty) => {\n+                &mut GenericParamDef::Type(ref mut ty) => {\n                     // We never want something like 'impl<T=Foo>'\n                     ty.default.take();\n "}, {"sha": "4797b5a912a705fcdf815e4f97c5da7ce8ac04c2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -1484,7 +1484,7 @@ impl<'a, 'tcx> Clean<TyParamBound> for (&'a ty::TraitRef<'tcx>, Vec<TypeBinding>\n                         if let &ty::RegionKind::ReLateBound(..) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n-                                late_bounds.push(GenericParam::Lifetime(lt));\n+                                late_bounds.push(GenericParamDef::Lifetime(lt));\n                             }\n                         }\n                     }\n@@ -1718,34 +1718,34 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n-pub enum GenericParam {\n+pub enum GenericParamDef {\n     Lifetime(Lifetime),\n     Type(TyParam),\n }\n \n-impl GenericParam {\n+impl GenericParamDef {\n     pub fn is_synthetic_type_param(&self) -> bool {\n-        if let GenericParam::Type(ref t) = *self {\n+        if let GenericParamDef::Type(ref t) = *self {\n             t.synthetic.is_some()\n         } else {\n             false\n         }\n     }\n }\n \n-impl Clean<GenericParam> for hir::GenericParam {\n-    fn clean(&self, cx: &DocContext) -> GenericParam {\n+impl Clean<GenericParamDef> for hir::GenericParam {\n+    fn clean(&self, cx: &DocContext) -> GenericParamDef {\n         match *self {\n-            hir::GenericParam::Lifetime(ref l) => GenericParam::Lifetime(l.clean(cx)),\n-            hir::GenericParam::Type(ref t) => GenericParam::Type(t.clean(cx)),\n+            hir::GenericParam::Lifetime(ref l) => GenericParamDef::Lifetime(l.clean(cx)),\n+            hir::GenericParam::Type(ref t) => GenericParamDef::Type(t.clean(cx)),\n         }\n     }\n }\n \n // maybe use a Generic enum and use Vec<Generic>?\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Default, Hash)]\n pub struct Generics {\n-    pub params: Vec<GenericParam>,\n+    pub params: Vec<GenericParamDef>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n \n@@ -1774,7 +1774,7 @@ impl Clean<Generics> for hir::Generics {\n                 WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds } => {\n                     if bounds.is_empty() {\n                         for param in &mut g.params {\n-                            if let GenericParam::Type(ref mut type_param) = *param {\n+                            if let GenericParamDef::Type(ref mut type_param) = *param {\n                                 if &type_param.name == name {\n                                     mem::swap(bounds, &mut type_param.bounds);\n                                     break\n@@ -1851,11 +1851,11 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n         Generics {\n             params: gens.lifetimes()\n                         .into_iter()\n-                        .map(|lp| GenericParam::Lifetime(lp.clean(cx)))\n+                        .map(|lp| GenericParamDef::Lifetime(lp.clean(cx)))\n                         .chain(\n                             simplify::ty_params(stripped_typarams)\n                                 .into_iter()\n-                                .map(|tp| GenericParam::Type(tp))\n+                                .map(|tp| GenericParamDef::Type(tp))\n                         )\n                         .collect(),\n             where_predicates: simplify::where_clauses(cx, where_predicates),\n@@ -2348,7 +2348,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct PolyTrait {\n     pub trait_: Type,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: Vec<GenericParamDef>,\n }\n \n /// A representation of a Type suitable for hyperlinking purposes. Ideally one can get the original\n@@ -3413,7 +3413,7 @@ impl Clean<Item> for doctree::Typedef {\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct BareFunctionDecl {\n     pub unsafety: hir::Unsafety,\n-    pub generic_params: Vec<GenericParam>,\n+    pub generic_params: Vec<GenericParamDef>,\n     pub decl: FnDecl,\n     pub abi: Abi,\n }\n@@ -4172,7 +4172,7 @@ struct RegionDeps<'tcx> {\n #[derive(Eq, PartialEq, Hash, Debug)]\n enum SimpleBound {\n     RegionBound(Lifetime),\n-    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParam>, hir::TraitBoundModifier)\n+    TraitBound(Vec<PathSegment>, Vec<SimpleBound>, Vec<GenericParamDef>, hir::TraitBoundModifier)\n }\n \n enum AutoTraitResult {"}, {"sha": "0323e2b1f522ee5b38d19081fb833779a8517bee", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -117,11 +117,11 @@ impl<'a> fmt::Display for TyParamBounds<'a> {\n     }\n }\n \n-impl fmt::Display for clean::GenericParam {\n+impl fmt::Display for clean::GenericParamDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::GenericParam::Lifetime(ref lp) => write!(f, \"{}\", lp),\n-            clean::GenericParam::Type(ref tp) => {\n+            clean::GenericParamDef::Lifetime(ref lp) => write!(f, \"{}\", lp),\n+            clean::GenericParamDef::Type(ref tp) => {\n                 f.write_str(&tp.name)?;\n \n                 if !tp.bounds.is_empty() {"}, {"sha": "5be9000d2a5ce93dc3445fe986e991a85d3515ff", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/178a8f1139ddad2aa59ce0e54cf10659dc4eed30/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=178a8f1139ddad2aa59ce0e54cf10659dc4eed30", "patch": "@@ -1437,7 +1437,7 @@ impl DocFolder for Cache {\n impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n         for param in &generics.params {\n-            if let clean::GenericParam::Type(ref typ) = *param {\n+            if let clean::GenericParamDef::Type(ref typ) = *param {\n                 self.typarams.insert(typ.did, typ.name.clone());\n             }\n         }"}]}