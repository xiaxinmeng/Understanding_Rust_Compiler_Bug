{"sha": "1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOTdhMjc0YTM3ZjZlN2M0OGFkOGNjOGE0MDJjMjhkODNjYjk4YjU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-06-30T11:51:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-04T08:38:54Z"}, "message": "Add basic support for \"other\" kinds of values for function pointers, determined by the machine instance.\n\nSo far, however, calling such a function will fail.", "tree": {"sha": "299152a32829d8e47cadf16d9f4ede805f5a9756", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/299152a32829d8e47cadf16d9f4ede805f5a9756"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "html_url": "https://github.com/rust-lang/rust/commit/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b43eb4235ac43c822d903ad26ed806f34cc1a14a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b43eb4235ac43c822d903ad26ed806f34cc1a14a", "html_url": "https://github.com/rust-lang/rust/commit/b43eb4235ac43c822d903ad26ed806f34cc1a14a"}], "stats": {"total": 171, "additions": 107, "deletions": 64}, "files": [{"sha": "a5c52324c89c23f2c3e3bf7919905d94e4389ba0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -316,6 +316,7 @@ impl interpret::MayLeak for ! {\n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKinds = !;\n     type PointerTag = ();\n+    type ExtraFnVal = !;\n \n     type FrameExtra = ();\n     type MemoryExtra = ();"}, {"sha": "3ef525979f8c9ecce2f61480797957cc8557d081", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n use rustc::mir::CastKind;\n \n-use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate};\n+use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -86,7 +86,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             def_id,\n                             substs,\n                         ).ok_or_else(|| InterpError::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(instance?);\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance?));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n@@ -115,7 +115,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(instance);\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_immediate(val, dest)?;\n                     }"}, {"sha": "02ba00508441c0b8e36ae923f6f67000e7632193", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -67,6 +67,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Copy + Eq + Hash + 'static;\n \n+    /// Machines can define extra (non-instance) things that represent values of function pointers.\n+    /// For example, Miri uses this to return a fucntion pointer from `dlsym`\n+    /// that can later be called to execute the right thing.\n+    type ExtraFnVal: ::std::fmt::Debug + Copy;\n+\n     /// Extra data stored in every call frame.\n     type FrameExtra;\n "}, {"sha": "fab559bf39db4e6b8a839bed75b4bf90ed84c984", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 77, "deletions": 44, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -10,7 +10,7 @@ use std::collections::VecDeque;\n use std::ptr;\n use std::borrow::Cow;\n \n-use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n+use rustc::ty::{self, Instance, query::TyCtxtAt};\n use rustc::ty::layout::{Align, TargetDataLayout, Size, HasDataLayout};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n@@ -54,6 +54,26 @@ pub enum AllocCheck {\n     MaybeDead,\n }\n \n+/// The value of a function pointer.\n+#[derive(Debug, Copy, Clone)]\n+pub enum FnVal<'tcx, Other> {\n+    Instance(Instance<'tcx>),\n+    Other(Other),\n+}\n+\n+impl<'tcx, Other> FnVal<'tcx, Other> {\n+    pub fn as_instance(self) -> InterpResult<'tcx, Instance<'tcx>> {\n+        match self {\n+            FnVal::Instance(instance) =>\n+                Ok(instance),\n+            FnVal::Other(_) =>\n+                err!(MachineError(\n+                    format!(\"Expected instance function pointer, got 'other' pointer\")\n+                )),\n+        }\n+    }\n+}\n+\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -69,16 +89,20 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) alloc_map: M::MemoryMap,\n \n+    /// Map for \"extra\" function pointers.\n+    extra_fn_ptr_map: FxHashMap<AllocId, M::ExtraFnVal>,\n+\n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n+    // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n     /// Extra data added by the machine.\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub(super) tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxtAt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -98,6 +122,7 @@ where\n     fn clone(&self) -> Self {\n         Memory {\n             alloc_map: self.alloc_map.clone(),\n+            extra_fn_ptr_map: self.extra_fn_ptr_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n             extra: (),\n             tcx: self.tcx,\n@@ -109,6 +134,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n+            extra_fn_ptr_map: FxHashMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n             extra: M::MemoryExtra::default(),\n             tcx,\n@@ -120,8 +146,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr.with_tag(M::tag_static_base_pointer(ptr.alloc_id, &self))\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n-        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n+    pub fn create_fn_alloc(\n+        &mut self,\n+        fn_val: FnVal<'tcx, M::ExtraFnVal>,\n+    ) -> Pointer<M::PointerTag>\n+    {\n+        let id = match fn_val {\n+            FnVal::Instance(instance) => self.tcx.alloc_map.lock().create_fn_alloc(instance),\n+            FnVal::Other(extra) => {\n+                // TODO: Should we have a cache here?\n+                let id = self.tcx.alloc_map.lock().reserve();\n+                let old = self.extra_fn_ptr_map.insert(id, extra);\n+                assert!(old.is_none());\n+                id\n+            }\n+        };\n         self.tag_static_base_pointer(Pointer::from(id))\n     }\n \n@@ -495,56 +534,50 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n+        // Regular allocations.\n         if let Ok(alloc) = self.get(id) {\n-            return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n+            Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align))\n         }\n-        // can't do this in the match argument, we may get cycle errors since the lock would get\n-        // dropped after the match.\n-        let alloc = self.tcx.alloc_map.lock().get(id);\n-        // Could also be a fn ptr or extern static\n-        match alloc {\n-            Some(GlobalAlloc::Function(..)) => {\n-                if let AllocCheck::Dereferencable = liveness {\n-                    // The caller requested no function pointers.\n-                    err!(DerefFunctionPointer)\n-                } else {\n-                    Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n-                }\n+        // Function pointers.\n+        else if let Ok(_) = self.get_fn_alloc(id) {\n+            if let AllocCheck::Dereferencable = liveness {\n+                // The caller requested no function pointers.\n+                err!(DerefFunctionPointer)\n+            } else {\n+                Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n             }\n-            // `self.get` would also work, but can cause cycles if a static refers to itself\n-            Some(GlobalAlloc::Static(did)) => {\n-                // The only way `get` couldn't have worked here is if this is an extern static\n-                assert!(self.tcx.is_foreign_item(did));\n-                // Use size and align of the type\n-                let ty = self.tcx.type_of(did);\n-                let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                Ok((layout.size, layout.align.abi))\n+        }\n+        // The rest must be dead.\n+        else if let AllocCheck::MaybeDead = liveness {\n+            // Deallocated pointers are allowed, we should be able to find\n+            // them in the map.\n+            Ok(*self.dead_alloc_map.get(&id)\n+                .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n+        } else {\n+            err!(DanglingPointerDeref)\n+        }\n+    }\n+\n+    fn get_fn_alloc(&self, id: AllocId) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        trace!(\"reading fn ptr: {}\", id);\n+        if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n+            Ok(FnVal::Other(*extra))\n+        } else {\n+            match self.tcx.alloc_map.lock().get(id) {\n+                Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n+                _ => Err(InterpError::ExecuteMemory.into()),\n             }\n-            _ => {\n-                if let Ok(alloc) = self.get(id) {\n-                    Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align))\n-                }\n-                else if let AllocCheck::MaybeDead = liveness {\n-                    // Deallocated pointers are allowed, we should be able to find\n-                    // them in the map.\n-                    Ok(*self.dead_alloc_map.get(&id)\n-                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n-                } else {\n-                    err!(DanglingPointerDeref)\n-                }\n-            },\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx, Instance<'tcx>> {\n+    pub fn get_fn(\n+        &self,\n+        ptr: Pointer<M::PointerTag>,\n+    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n-        trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(GlobalAlloc::Function(instance)) => Ok(instance),\n-            _ => Err(InterpError::ExecuteMemory.into()),\n-        }\n+        self.get_fn_alloc(ptr.alloc_id)\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "45d24347e4efd45618c3a5ff2eb41b80beefc01c", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -24,7 +24,7 @@ pub use self::eval_context::{\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n-pub use self::memory::{Memory, MemoryKind, AllocCheck};\n+pub use self::memory::{Memory, MemoryKind, AllocCheck, FnVal};\n \n pub use self::machine::{Machine, AllocMap, MayLeak};\n "}, {"sha": "4440d677a41d4ec58f12c51f7a7c29ce3d1de7f9", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -6,9 +6,9 @@ use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{InterpResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n-    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpResult, PointerArithmetic, InterpError, Scalar,\n+    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -76,16 +76,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n-                let (fn_def, abi) = match func.layout.ty.sty {\n+                let (fn_val, abi) = match func.layout.ty.sty {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n                         let fn_ptr = self.force_ptr(self.read_scalar(func)?.not_undef()?)?;\n-                        let instance = self.memory.get_fn(fn_ptr)?;\n-                        (instance, caller_abi)\n+                        let fn_val = self.memory.get_fn(fn_ptr)?;\n+                        (fn_val, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n-                        (self.resolve(def_id, substs)?, sig.abi())\n+                        (FnVal::Instance(self.resolve(def_id, substs)?), sig.abi())\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n@@ -94,7 +94,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let args = self.eval_operands(args)?;\n                 self.eval_fn_call(\n-                    fn_def,\n+                    fn_val,\n                     terminator.source_info.span,\n                     abi,\n                     &args[..],\n@@ -228,14 +228,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this function -- pushing the stack frame and initializing the arguments.\n     fn eval_fn_call(\n         &mut self,\n-        instance: ty::Instance<'tcx>,\n+        fn_val: FnVal<'tcx, M::ExtraFnVal>,\n         span: Span,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"eval_fn_call: {:#?}\", instance);\n+        trace!(\"eval_fn_call: {:#?}\", fn_val);\n+\n+        let instance = fn_val.as_instance()?;\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n@@ -432,7 +434,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 )?.expect(\"cannot be a ZST\");\n                 let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n                     .read_ptr_sized(self, vtable_slot)?.to_ptr()?;\n-                let instance = self.memory.get_fn(fn_ptr)?;\n+                let drop_fn = self.memory.get_fn(fn_ptr)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -447,7 +449,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret)\n             }\n         }\n     }\n@@ -482,7 +484,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);\n \n         self.eval_fn_call(\n-            instance,\n+            FnVal::Instance(instance),\n             span,\n             Abi::Rust,\n             &[arg.into()],"}, {"sha": "35eb01392f4d556cc57c8fc39f0837daad13b858", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1297a274a37f6e7c48ad8cc8a402c28d83cb98b5/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=1297a274a37f6e7c48ad8cc8a402c28d83cb98b5", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n-use super::{InterpCx, InterpError, Machine, MemoryKind};\n+use super::{InterpCx, InterpError, Machine, MemoryKind, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -56,7 +56,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tcx = &*self.tcx;\n \n         let drop = Instance::resolve_drop_in_place(*tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop);\n+        let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // no need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n@@ -84,7 +84,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     def_id,\n                     substs,\n                 ).ok_or_else(|| InterpError::TooGeneric)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory\n                     .get_mut(method_ptr.alloc_id)?\n@@ -113,7 +113,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .get(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n             .to_ptr()?;\n-        let drop_instance = self.memory.get_fn(drop_fn)?;\n+        // We *need* an instance here, no other kind of function value, to be able\n+        // to determine the type.\n+        let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);"}]}