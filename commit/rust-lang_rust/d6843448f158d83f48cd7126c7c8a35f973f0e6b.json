{"sha": "d6843448f158d83f48cd7126c7c8a35f973f0e6b", "node_id": "C_kwDOAAsO6NoAKGQ2ODQzNDQ4ZjE1OGQ4M2Y0OGNkNzEyNmM3YzhhMzVmOTczZjBlNmI", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-12T17:58:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-12T17:58:16Z"}, "message": "Rollup merge of #95794 - nnethercote:parse_tt-a-few-more-tweaks, r=petrochenkov\n\n`parse_tt`: a few more tweaks\n\nr? `@petrochenkov`", "tree": {"sha": "6b5ee0ab6038daafd33396f28a30182c7185335b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b5ee0ab6038daafd33396f28a30182c7185335b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6843448f158d83f48cd7126c7c8a35f973f0e6b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiVb25CRBK7hj4Ov3rIwAA+U4IAESrOHbM0isOOoeuNmqYqczJ\nCFqgWSJr/Qp++8N9roolZgKXnO3wBgBG4HWftOgZpCIxA7IiQ+bodno1X3nFOWrY\nzsf1e+0l2xPrN+PCizEEi+XF6o2EqlFKaxhnfBmMrSpAnLtzWuzgqTZsDFWGEM9P\nPnYg458gfGwlfnh41w64e2F9Go+OhC398Wn0MFsr7JX7uHZCe3ZGe0mDprw7rZM9\nUU4x/DYYzWqJyxEEV36wM1B/wgXLvwN/8T2D2mziRtWqqamzW74SBhmBzhEpAwaE\n6xPOT5tJFf9FrYjZJYqADBfZKH/0dUW8Ch3o9yBLpM6VGKU43TuCAb4l4ZgJ+9c=\n=S/Ib\n-----END PGP SIGNATURE-----\n", "payload": "tree 6b5ee0ab6038daafd33396f28a30182c7185335b\nparent 7644de5eda500fd6bac5ee66d6be0130a2ae83f1\nparent edd7f2cdab424ff8ed64a84f784a5c1273bcb138\nauthor Mara Bos <m-ou.se@m-ou.se> 1649786296 +0200\ncommitter GitHub <noreply@github.com> 1649786296 +0200\n\nRollup merge of #95794 - nnethercote:parse_tt-a-few-more-tweaks, r=petrochenkov\n\n`parse_tt`: a few more tweaks\n\nr? `@petrochenkov`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6843448f158d83f48cd7126c7c8a35f973f0e6b", "html_url": "https://github.com/rust-lang/rust/commit/d6843448f158d83f48cd7126c7c8a35f973f0e6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6843448f158d83f48cd7126c7c8a35f973f0e6b/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7644de5eda500fd6bac5ee66d6be0130a2ae83f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7644de5eda500fd6bac5ee66d6be0130a2ae83f1", "html_url": "https://github.com/rust-lang/rust/commit/7644de5eda500fd6bac5ee66d6be0130a2ae83f1"}, {"sha": "edd7f2cdab424ff8ed64a84f784a5c1273bcb138", "url": "https://api.github.com/repos/rust-lang/rust/commits/edd7f2cdab424ff8ed64a84f784a5c1273bcb138", "html_url": "https://github.com/rust-lang/rust/commit/edd7f2cdab424ff8ed64a84f784a5c1273bcb138"}], "stats": {"total": 41, "additions": 13, "deletions": 28}, "files": [{"sha": "b5f56d7d6dc84dfca36d278889ce39ee7bec294f", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d6843448f158d83f48cd7126c7c8a35f973f0e6b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6843448f158d83f48cd7126c7c8a35f973f0e6b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=d6843448f158d83f48cd7126c7c8a35f973f0e6b", "patch": "@@ -81,22 +81,12 @@ use rustc_session::parse::ParseSess;\n use rustc_span::symbol::MacroRulesNormalizedIdent;\n use rustc_span::Span;\n \n-use smallvec::{smallvec, SmallVec};\n-\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use std::borrow::Cow;\n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n-// One element is enough to cover 95-99% of vectors for most benchmarks. Also, vectors longer than\n-// one frequently have many elements, not just two or three.\n-type NamedMatchVec = SmallVec<[NamedMatch; 1]>;\n-\n-// This type is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(NamedMatchVec, 48);\n-\n /// A unit within a matcher that a `MatcherPos` can refer to. Similar to (and derived from)\n /// `mbe::TokenTree`, but designed specifically for fast and easy traversal during matching.\n /// Notable differences to `mbe::TokenTree`:\n@@ -221,7 +211,11 @@ struct MatcherPos {\n     /// with one element per metavar decl in the matcher. Each element records token trees matched\n     /// against the relevant metavar by the black box parser. An element will be a `MatchedSeq` if\n     /// the corresponding metavar decl is within a sequence.\n-    matches: Lrc<NamedMatchVec>,\n+    ///\n+    /// It is critical to performance that this is an `Lrc`, because it gets cloned frequently when\n+    /// processing sequences. Mostly for sequence-ending possibilities that must be tried but end\n+    /// up failing.\n+    matches: Lrc<Vec<NamedMatch>>,\n }\n \n // This type is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -246,18 +240,12 @@ impl MatcherPos {\n                 let mut curr = &mut matches[metavar_idx];\n                 for _ in 0..seq_depth - 1 {\n                     match curr {\n-                        MatchedSeq(seq) => {\n-                            let seq = Lrc::make_mut(seq);\n-                            curr = seq.last_mut().unwrap();\n-                        }\n+                        MatchedSeq(seq) => curr = seq.last_mut().unwrap(),\n                         _ => unreachable!(),\n                     }\n                 }\n                 match curr {\n-                    MatchedSeq(seq) => {\n-                        let seq = Lrc::make_mut(seq);\n-                        seq.push(m);\n-                    }\n+                    MatchedSeq(seq) => seq.push(m),\n                     _ => unreachable!(),\n                 }\n             }\n@@ -350,7 +338,7 @@ pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n /// ```\n #[derive(Debug, Clone)]\n crate enum NamedMatch {\n-    MatchedSeq(Lrc<NamedMatchVec>),\n+    MatchedSeq(Vec<NamedMatch>),\n \n     // A metavar match of type `tt`.\n     MatchedTokenTree(rustc_ast::tokenstream::TokenTree),\n@@ -388,7 +376,7 @@ pub struct TtParser {\n \n     /// Pre-allocate an empty match array, so it can be cloned cheaply for macros with many rules\n     /// that have no metavars.\n-    empty_matches: Lrc<NamedMatchVec>,\n+    empty_matches: Lrc<Vec<NamedMatch>>,\n }\n \n impl TtParser {\n@@ -398,7 +386,7 @@ impl TtParser {\n             cur_mps: vec![],\n             next_mps: vec![],\n             bb_mps: vec![],\n-            empty_matches: Lrc::new(smallvec![]),\n+            empty_matches: Lrc::new(vec![]),\n         }\n     }\n \n@@ -452,11 +440,7 @@ impl TtParser {\n                 } => {\n                     // Install an empty vec for each metavar within the sequence.\n                     for metavar_idx in next_metavar..next_metavar + num_metavar_decls {\n-                        mp.push_match(\n-                            metavar_idx,\n-                            seq_depth,\n-                            MatchedSeq(self.empty_matches.clone()),\n-                        );\n+                        mp.push_match(metavar_idx, seq_depth, MatchedSeq(vec![]));\n                     }\n \n                     if op == KleeneOp::ZeroOrMore || op == KleeneOp::ZeroOrOne {"}, {"sha": "f5c7186bc4b18e3f86ef7d94ffff5bcadfcee442", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6843448f158d83f48cd7126c7c8a35f973f0e6b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6843448f158d83f48cd7126c7c8a35f973f0e6b/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=d6843448f158d83f48cd7126c7c8a35f973f0e6b", "patch": "@@ -439,7 +439,8 @@ pub fn compile_declarative_macro(\n     let argument_gram = mbe::macro_parser::compute_locs(&sess.parse_sess, &argument_gram);\n \n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n-    let mut tt_parser = TtParser::new(def.ident);\n+    let mut tt_parser =\n+        TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n     let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n         Success(m) => m,\n         Failure(token, msg) => {"}]}