{"sha": "92019986aa6532256277ca999006bdc77e9a95ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMDE5OTg2YWE2NTMyMjU2Mjc3Y2E5OTkwMDZiZGM3N2U5YTk1YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-29T03:04:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-29T03:04:46Z"}, "message": "Auto merge of #71518 - felix91gr:const_prop_bugfix_just_block_prop, r=wesleywiser\n\nConst-prop bugfix: only add propagation inside own block for user variables\n\nA testing spinoff of #71298. This one only adds the const-prop for locals that are user variables.", "tree": {"sha": "b43095843c66b38b14a03891ee6c55d4baa4f127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b43095843c66b38b14a03891ee6c55d4baa4f127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92019986aa6532256277ca999006bdc77e9a95ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92019986aa6532256277ca999006bdc77e9a95ad", "html_url": "https://github.com/rust-lang/rust/commit/92019986aa6532256277ca999006bdc77e9a95ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92019986aa6532256277ca999006bdc77e9a95ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825cf51ad7d2578fcd60a0b7b107d7b0ab3017ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/825cf51ad7d2578fcd60a0b7b107d7b0ab3017ff", "html_url": "https://github.com/rust-lang/rust/commit/825cf51ad7d2578fcd60a0b7b107d7b0ab3017ff"}, {"sha": "16ebaf9273a41d89d8d04e90c7b145076f3e1611", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ebaf9273a41d89d8d04e90c7b145076f3e1611", "html_url": "https://github.com/rust-lang/rust/commit/16ebaf9273a41d89d8d04e90c7b145076f3e1611"}], "stats": {"total": 859, "additions": 818, "deletions": 41}, "files": [{"sha": "09d8f89676a66609a77e632eaeebf66de4e20f08", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 70, "deletions": 21, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -274,6 +274,8 @@ struct ConstPropagator<'mir, 'tcx> {\n     // Because we have `MutVisitor` we can't obtain the `SourceInfo` from a `Location`. So we store\n     // the last known `SourceInfo` here and just keep revisiting it.\n     source_info: Option<SourceInfo>,\n+    // Locals we need to forget at the end of the current block\n+    locals_of_current_block: BitSet<Local>,\n }\n \n impl<'mir, 'tcx> LayoutOf for ConstPropagator<'mir, 'tcx> {\n@@ -343,6 +345,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             //FIXME(wesleywiser) we can't steal this because `Visitor::super_visit_body()` needs it\n             local_decls: body.local_decls.clone(),\n             source_info: None,\n+            locals_of_current_block: BitSet::new_empty(body.local_decls.len()),\n         }\n     }\n \n@@ -357,8 +360,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn remove_const(&mut self, local: Local) {\n-        self.ecx.frame_mut().locals[local] =\n+    /// Remove `local` from the pool of `Locals`. Allows writing to them,\n+    /// but not reading from them anymore.\n+    fn remove_const(ecx: &mut InterpCx<'mir, 'tcx, ConstPropMachine<'mir, 'tcx>>, local: Local) {\n+        ecx.frame_mut().locals[local] =\n             LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n     }\n \n@@ -389,6 +394,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n+    /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n         if c.needs_subst() {\n@@ -429,11 +435,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n+    /// Returns the value, if any, of evaluating `place`.\n     fn eval_place(&mut self, place: Place<'tcx>) -> Option<OpTy<'tcx>> {\n         trace!(\"eval_place(place={:?})\", place);\n         self.use_ecx(|this| this.ecx.eval_place_to_op(place, None))\n     }\n \n+    /// Returns the value, if any, of evaluating `op`. Calls upon `eval_constant`\n+    /// or `eval_place`, depending on the variant of `Operand` used.\n     fn eval_operand(&mut self, op: &Operand<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         match *op {\n             Operand::Constant(ref c) => self.eval_constant(c, source_info),\n@@ -592,6 +601,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         })\n     }\n \n+    /// Creates a new `Operand::Constant` from a `Scalar` value\n     fn operand_from_scalar(&self, scalar: Scalar, ty: Ty<'tcx>, span: Span) -> Operand<'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span,\n@@ -637,6 +647,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                     // Found a value represented as a pair. For now only do cont-prop if type of\n                     // Rvalue is also a pair with two scalars. The more general case is more\n                     // complicated to implement so we'll do it later.\n+                    // FIXME: implement the general case stated above ^.\n                     let ty = &value.layout.ty.kind;\n                     // Only do it for tuples\n                     if let ty::Tuple(substs) = ty {\n@@ -673,6 +684,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n+    /// Returns `true` if and only if this `op` should be const-propagated into.\n     fn should_const_prop(&mut self, op: OpTy<'tcx>) -> bool {\n         let mir_opt_level = self.tcx.sess.opts.debugging_opts.mir_opt_level;\n \n@@ -704,6 +716,8 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n enum ConstPropMode {\n     /// The `Local` can be propagated into and reads of this `Local` can also be propagated.\n     FullConstProp,\n+    /// The `Local` can only be propagated into and from its own block.\n+    OnlyInsideOwnBlock,\n     /// The `Local` can be propagated into but reads cannot be propagated.\n     OnlyPropagateInto,\n     /// No propagation is allowed at all.\n@@ -712,28 +726,41 @@ enum ConstPropMode {\n \n struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n-    // false at the beginning, once set, there are not allowed to be any more assignments\n+    // False at the beginning. Once set, no more assignments are allowed to that local.\n     found_assignment: BitSet<Local>,\n+    // Cache of locals' information\n+    local_kinds: IndexVec<Local, LocalKind>,\n }\n \n impl CanConstProp {\n-    /// returns true if `local` can be propagated\n+    /// Returns true if `local` can be propagated\n     fn check(body: &Body<'_>) -> IndexVec<Local, ConstPropMode> {\n         let mut cpv = CanConstProp {\n             can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n             found_assignment: BitSet::new_empty(body.local_decls.len()),\n+            local_kinds: IndexVec::from_fn_n(\n+                |local| body.local_kind(local),\n+                body.local_decls.len(),\n+            ),\n         };\n         for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n-            // cannot use args at all\n-            // cannot use locals because if x < y { y - x } else { x - y } would\n+            // Cannot use args at all\n+            // Cannot use locals because if x < y { y - x } else { x - y } would\n             //        lint for x != y\n             // FIXME(oli-obk): lint variables until they are used in a condition\n             // FIXME(oli-obk): lint if return value is constant\n-            let local_kind = body.local_kind(local);\n-\n-            if local_kind == LocalKind::Arg || local_kind == LocalKind::Var {\n+            if cpv.local_kinds[local] == LocalKind::Arg {\n                 *val = ConstPropMode::OnlyPropagateInto;\n-                trace!(\"local {:?} can't be const propagated because it's not a temporary\", local);\n+                trace!(\n+                    \"local {:?} can't be const propagated because it's a function argument\",\n+                    local\n+                );\n+            } else if cpv.local_kinds[local] == LocalKind::Var {\n+                *val = ConstPropMode::OnlyInsideOwnBlock;\n+                trace!(\n+                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n+                    local\n+                );\n             }\n         }\n         cpv.visit_body(&body);\n@@ -759,8 +786,12 @@ impl<'tcx> Visitor<'tcx> for CanConstProp {\n             | NonMutatingUse(NonMutatingUseContext::Move)\n             | NonMutatingUse(NonMutatingUseContext::Inspect)\n             | NonMutatingUse(NonMutatingUseContext::Projection)\n-            | MutatingUse(MutatingUseContext::Projection)\n             | NonUse(_) => {}\n+            MutatingUse(MutatingUseContext::Projection) => {\n+                if self.local_kinds[local] != LocalKind::Temp {\n+                    self.can_const_prop[local] = ConstPropMode::NoPropagation;\n+                }\n+            }\n             _ => {\n                 trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n                 self.can_const_prop[local] = ConstPropMode::NoPropagation;\n@@ -797,25 +828,35 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                 if let Some(local) = place.as_local() {\n                     let can_const_prop = self.can_const_prop[local];\n                     if let Some(()) = self.const_prop(rval, place_layout, source_info, place) {\n-                        if can_const_prop == ConstPropMode::FullConstProp\n-                            || can_const_prop == ConstPropMode::OnlyPropagateInto\n-                        {\n+                        if can_const_prop != ConstPropMode::NoPropagation {\n+                            // This will return None for Locals that are from other blocks,\n+                            // so it should be okay to propagate from here on down.\n                             if let Some(value) = self.get_const(local) {\n                                 if self.should_const_prop(value) {\n                                     trace!(\"replacing {:?} with {:?}\", rval, value);\n                                     self.replace_with_const(rval, value, statement.source_info);\n-\n-                                    if can_const_prop == ConstPropMode::FullConstProp {\n+                                    if can_const_prop == ConstPropMode::FullConstProp\n+                                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                                    {\n                                         trace!(\"propagated into {:?}\", local);\n                                     }\n                                 }\n+                                if can_const_prop == ConstPropMode::OnlyInsideOwnBlock {\n+                                    trace!(\n+                                        \"found local restricted to its block. Will remove it from const-prop after block is finished. Local: {:?}\",\n+                                        local\n+                                    );\n+                                    self.locals_of_current_block.insert(local);\n+                                }\n                             }\n                         }\n                     }\n-                    if self.can_const_prop[local] != ConstPropMode::FullConstProp {\n+                    if self.can_const_prop[local] == ConstPropMode::OnlyPropagateInto\n+                        || self.can_const_prop[local] == ConstPropMode::NoPropagation\n+                    {\n                         trace!(\"can't propagate into {:?}\", local);\n                         if local != RETURN_PLACE {\n-                            self.remove_const(local);\n+                            Self::remove_const(&mut self.ecx, local);\n                         }\n                     }\n                 }\n@@ -850,11 +891,11 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                     let expected = ScalarMaybeUndef::from(Scalar::from_bool(*expected));\n                     let value_const = self.ecx.read_scalar(value).unwrap();\n                     if expected != value_const {\n-                        // poison all places this operand references so that further code\n+                        // Poison all places this operand references so that further code\n                         // doesn't use the invalid value\n                         match cond {\n                             Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                self.remove_const(place.local);\n+                                Self::remove_const(&mut self.ecx, place.local);\n                             }\n                             Operand::Constant(_) => {}\n                         }\n@@ -916,7 +957,7 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                     }\n                 }\n             }\n-            //none of these have Operands to const-propagate\n+            // None of these have Operands to const-propagate\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n@@ -931,5 +972,13 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n             //FIXME(wesleywiser) Call does have Operands that could be const-propagated\n             TerminatorKind::Call { .. } => {}\n         }\n+        // We remove all Locals which are restricted in propagation to their containing blocks.\n+        // We wouldn't need to clone, but the borrow checker can't see that we're not aliasing\n+        // the locals_of_current_block field, so we need to clone it first.\n+        // let ecx = &mut self.ecx;\n+        for local in self.locals_of_current_block.iter() {\n+            Self::remove_const(&mut self.ecx, local);\n+        }\n+        self.locals_of_current_block.clear();\n     }\n }"}, {"sha": "0cd1f37c9a7879292521ac9da3e6a45a6be60525", "filename": "src/test/mir-opt/const_prop/bad_op_div_by_zero.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,6 @@\n+// EMIT_MIR rustc.main.ConstProp.diff\n+#[allow(unconditional_panic)]\n+fn main() {\n+    let y = 0;\n+    let _z = 1 / y;\n+}"}, {"sha": "333bf0e320b6effe8db3a15251aaa8f325e1e8fa", "filename": "src/test/mir-opt/const_prop/bad_op_div_by_zero/rustc.main.ConstProp.diff", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_div_by_zero%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,117 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/bad_op_div_by_zero.rs:3:11: 3:11\n+      let _1: i32;                         // in scope 0 at $DIR/bad_op_div_by_zero.rs:4:9: 4:10\n+      let mut _3: i32;                     // in scope 0 at $DIR/bad_op_div_by_zero.rs:5:18: 5:19\n+      let mut _4: bool;                    // in scope 0 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+      let mut _5: bool;                    // in scope 0 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+      let mut _6: bool;                    // in scope 0 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+      let mut _7: bool;                    // in scope 0 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+      scope 1 {\n+          debug y => _1;                   // in scope 1 at $DIR/bad_op_div_by_zero.rs:4:9: 4:10\n+          let _2: i32;                     // in scope 1 at $DIR/bad_op_div_by_zero.rs:5:9: 5:11\n+          scope 2 {\n+              debug _z => _2;              // in scope 2 at $DIR/bad_op_div_by_zero.rs:5:9: 5:11\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/bad_op_div_by_zero.rs:4:9: 4:10\n+          _1 = const 0i32;                 // scope 0 at $DIR/bad_op_div_by_zero.rs:4:13: 4:14\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_div_by_zero.rs:4:13: 4:14\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:5:9: 5:11\n+          StorageLive(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:5:18: 5:19\n+-         _3 = _1;                         // scope 1 at $DIR/bad_op_div_by_zero.rs:5:18: 5:19\n+-         _4 = Eq(_3, const 0i32);         // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++         _3 = const 0i32;                 // scope 1 at $DIR/bad_op_div_by_zero.rs:5:18: 5:19\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // + span: $DIR/bad_op_div_by_zero.rs:5:18: 5:19\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n++         _4 = const true;                 // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          assert(!move _4, \"attempt to divide by zero\") -> bb1; // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+      }\n+  \n+      bb1: {\n+-         _5 = Eq(_3, const -1i32);        // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++         _5 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+-                                          // + ty: i32\n+-                                          // + val: Value(Scalar(0xffffffff))\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0xffffffff)) }\n+-         _6 = Eq(const 1i32, const std::i32::MIN); // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n++         _6 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+-                                          // + ty: i32\n+-                                          // + val: Value(Scalar(0x00000001))\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:15\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n++                                          // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n++         _7 = const false;                // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+-                                          // + ty: i32\n+-                                          // + val: Value(Scalar(0x80000000))\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0x80000000)) }\n+-         _7 = BitAnd(move _5, move _6);   // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+-         assert(!move _7, \"attempt to divide with overflow\") -> bb2; // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n++         assert(!const false, \"attempt to divide with overflow\") -> bb2; // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+      }\n+  \n+      bb2: {\n+          _2 = Div(const 1i32, move _3);   // scope 1 at $DIR/bad_op_div_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_div_by_zero.rs:5:14: 5:15\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n+          StorageDead(_3);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:5:18: 5:19\n+          _0 = const ();                   // scope 0 at $DIR/bad_op_div_by_zero.rs:3:11: 6:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_div_by_zero.rs:3:11: 6:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/bad_op_div_by_zero.rs:6:1: 6:2\n+          StorageDead(_1);                 // scope 0 at $DIR/bad_op_div_by_zero.rs:6:1: 6:2\n+          return;                          // scope 0 at $DIR/bad_op_div_by_zero.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "26bccbb90ec82f7c9b82d44a995e9f4c364797a3", "filename": "src/test/mir-opt/const_prop/bad_op_mod_by_zero.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,6 @@\n+// EMIT_MIR rustc.main.ConstProp.diff\n+#[allow(unconditional_panic)]\n+fn main() {\n+    let y = 0;\n+    let _z = 1 % y;\n+}"}, {"sha": "c081b46366e9b56151b58dd7239888b833f189b6", "filename": "src/test/mir-opt/const_prop/bad_op_mod_by_zero/rustc.main.ConstProp.diff", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_mod_by_zero%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,117 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/bad_op_mod_by_zero.rs:3:11: 3:11\n+      let _1: i32;                         // in scope 0 at $DIR/bad_op_mod_by_zero.rs:4:9: 4:10\n+      let mut _3: i32;                     // in scope 0 at $DIR/bad_op_mod_by_zero.rs:5:18: 5:19\n+      let mut _4: bool;                    // in scope 0 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+      let mut _5: bool;                    // in scope 0 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+      let mut _6: bool;                    // in scope 0 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+      let mut _7: bool;                    // in scope 0 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+      scope 1 {\n+          debug y => _1;                   // in scope 1 at $DIR/bad_op_mod_by_zero.rs:4:9: 4:10\n+          let _2: i32;                     // in scope 1 at $DIR/bad_op_mod_by_zero.rs:5:9: 5:11\n+          scope 2 {\n+              debug _z => _2;              // in scope 2 at $DIR/bad_op_mod_by_zero.rs:5:9: 5:11\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/bad_op_mod_by_zero.rs:4:9: 4:10\n+          _1 = const 0i32;                 // scope 0 at $DIR/bad_op_mod_by_zero.rs:4:13: 4:14\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_mod_by_zero.rs:4:13: 4:14\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:9: 5:11\n+          StorageLive(_3);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:18: 5:19\n+-         _3 = _1;                         // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:18: 5:19\n+-         _4 = Eq(_3, const 0i32);         // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++         _3 = const 0i32;                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:18: 5:19\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // + span: $DIR/bad_op_mod_by_zero.rs:5:18: 5:19\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n++         _4 = const true;                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x01))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          assert(!move _4, \"attempt to calculate the remainder with a divisor of zero\") -> bb1; // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+      }\n+  \n+      bb1: {\n+-         _5 = Eq(_3, const -1i32);        // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++         _5 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+-                                          // + ty: i32\n+-                                          // + val: Value(Scalar(0xffffffff))\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0xffffffff)) }\n+-         _6 = Eq(const 1i32, const std::i32::MIN); // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n++         _6 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+-                                          // + ty: i32\n+-                                          // + val: Value(Scalar(0x00000001))\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:15\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n++                                          // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n++         _7 = const false;                // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+-                                          // + ty: i32\n+-                                          // + val: Value(Scalar(0x80000000))\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+-                                          // + literal: Const { ty: i32, val: Value(Scalar(0x80000000)) }\n+-         _7 = BitAnd(move _5, move _6);   // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+-         assert(!move _7, \"attempt to calculate the remainder with overflow\") -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n++         assert(!const false, \"attempt to calculate the remainder with overflow\") -> bb2; // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+      }\n+  \n+      bb2: {\n+          _2 = Rem(const 1i32, move _3);   // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:14: 5:19\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_mod_by_zero.rs:5:14: 5:15\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n+          StorageDead(_3);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:5:18: 5:19\n+          _0 = const ();                   // scope 0 at $DIR/bad_op_mod_by_zero.rs:3:11: 6:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_mod_by_zero.rs:3:11: 6:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_2);                 // scope 1 at $DIR/bad_op_mod_by_zero.rs:6:1: 6:2\n+          StorageDead(_1);                 // scope 0 at $DIR/bad_op_mod_by_zero.rs:6:1: 6:2\n+          return;                          // scope 0 at $DIR/bad_op_mod_by_zero.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "e517e467c372cc2bcff3f8c908aa2cc47ad1e16e", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,9 @@\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n+// EMIT_MIR rustc.main.ConstProp.diff\n+#[allow(unconditional_panic)]\n+fn main() {\n+    let a: *const [_] = &[1, 2, 3];\n+    unsafe {\n+        let _b = (*a)[3];\n+    }\n+}"}, {"sha": "8ecb77752bb395b4f47e119746eb4cbb4a89531e", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices/32bit/rustc.main.ConstProp.diff", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F32bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F32bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F32bit%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,83 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:4:11: 4:11\n+      let _1: *const [i32] as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:9: 5:10\n+      let mut _2: *const [i32; 3];         // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+      let _3: &[i32; 3];                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+      let _4: [i32; 3];                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:26: 5:35\n+      let _6: usize;                       // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+      let mut _7: usize;                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+      let mut _8: bool;                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+      let mut _9: &[i32; 3];               // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:9: 5:10\n+          scope 2 {\n+              let _5: i32;                 // in scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:13: 7:15\n+              scope 3 {\n+                  debug _b => _5;          // in scope 3 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:13: 7:15\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:9: 5:10\n+          StorageLive(_2);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          StorageLive(_3);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          _9 = const main::promoted[0];    // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+                                           // ty::Const\n+                                           // + ty: &[i32; 3]\n+                                           // + val: Unevaluated(DefId(0:3 ~ bad_op_unsafe_oob_for_slices[317d]::main[0]), [], Some(promoted[0]))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+                                           // + literal: Const { ty: &[i32; 3], val: Unevaluated(DefId(0:3 ~ bad_op_unsafe_oob_for_slices[317d]::main[0]), [], Some(promoted[0])) }\n+          _3 = _9;                         // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          _2 = &raw const (*_3);           // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          _1 = move _2 as *const [i32] (Pointer(Unsize)); // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          StorageDead(_2);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:34: 5:35\n+          StorageDead(_3);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:35: 5:36\n+          StorageLive(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:13: 7:15\n+          StorageLive(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+          _6 = const 3usize;               // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x00000003))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x00000003)) }\n+-         _7 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+-         _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++         _7 = const 3usize;               // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x00000003))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x00000003)) }\n++         _8 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          assert(move _8, \"index out of bounds: the len is {} but the index is {}\", move _7, _6) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+      }\n+  \n+      bb1: {\n+          _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+          StorageDead(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:25: 7:26\n+          _0 = const ();                   // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:6:5: 8:6\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:6:5: 8:6\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:8:5: 8:6\n+          StorageDead(_1);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:9:1: 9:2\n+          return;                          // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:9:2: 9:2\n+      }\n+  }\n+  "}, {"sha": "2778ec02724df89826fcc9fc5c4dce22edff18bf", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices/64bit/rustc.main.ConstProp.diff", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F64bit%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F64bit%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices%2F64bit%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,83 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:4:11: 4:11\n+      let _1: *const [i32] as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:9: 5:10\n+      let mut _2: *const [i32; 3];         // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+      let _3: &[i32; 3];                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+      let _4: [i32; 3];                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:26: 5:35\n+      let _6: usize;                       // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+      let mut _7: usize;                   // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+      let mut _8: bool;                    // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+      let mut _9: &[i32; 3];               // in scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+      scope 1 {\n+          debug a => _1;                   // in scope 1 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:9: 5:10\n+          scope 2 {\n+              let _5: i32;                 // in scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:13: 7:15\n+              scope 3 {\n+                  debug _b => _5;          // in scope 3 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:13: 7:15\n+              }\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:9: 5:10\n+          StorageLive(_2);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          StorageLive(_3);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          _9 = const main::promoted[0];    // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+                                           // ty::Const\n+                                           // + ty: &[i32; 3]\n+                                           // + val: Unevaluated(DefId(0:3 ~ bad_op_unsafe_oob_for_slices[317d]::main[0]), [], Some(promoted[0]))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+                                           // + literal: Const { ty: &[i32; 3], val: Unevaluated(DefId(0:3 ~ bad_op_unsafe_oob_for_slices[317d]::main[0]), [], Some(promoted[0])) }\n+          _3 = _9;                         // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          _2 = &raw const (*_3);           // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          _1 = move _2 as *const [i32] (Pointer(Unsize)); // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n+          StorageDead(_2);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:34: 5:35\n+          StorageDead(_3);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:35: 5:36\n+          StorageLive(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:13: 7:15\n+          StorageLive(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+          _6 = const 3usize;               // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+                                           // ty::Const\n+                                           // + ty: usize\n+                                           // + val: Value(Scalar(0x0000000000000003))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:23: 7:24\n+                                           // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }\n+-         _7 = Len((*_1));                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+-         _8 = Lt(_6, _7);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++         _7 = const 3usize;               // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // ty::Const\n++                                          // + ty: usize\n++                                          // + val: Value(Scalar(0x0000000000000003))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // + literal: Const { ty: usize, val: Value(Scalar(0x0000000000000003)) }\n++         _8 = const false;                // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          assert(move _8, \"index out of bounds: the len is {} but the index is {}\", move _7, _6) -> bb1; // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+      }\n+  \n+      bb1: {\n+          _5 = (*_1)[_6];                  // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:18: 7:25\n+          StorageDead(_6);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:7:25: 7:26\n+          _0 = const ();                   // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:6:5: 8:6\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:6:5: 8:6\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_5);                 // scope 2 at $DIR/bad_op_unsafe_oob_for_slices.rs:8:5: 8:6\n+          StorageDead(_1);                 // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:9:1: 9:2\n+          return;                          // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:9:2: 9:2\n+      }\n+  }\n+  "}, {"sha": "a740e69dca263e4aa4c462286bdd1914ce20f589", "filename": "src/test/mir-opt/const_prop/scalar_literal_propagation.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,8 @@\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let x = 1;\n+    consume(x);\n+}\n+\n+#[inline(never)]\n+fn consume(_: u32) { }"}, {"sha": "0183ff7716cbb6853a8bdfa5132ed040c26978ef", "filename": "src/test/mir-opt/const_prop/scalar_literal_propagation/rustc.main.ConstProp.diff", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fscalar_literal_propagation%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,55 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/scalar_literal_propagation.rs:2:11: 2:11\n+      let _1: u32;                         // in scope 0 at $DIR/scalar_literal_propagation.rs:3:9: 3:10\n+      let _2: ();                          // in scope 0 at $DIR/scalar_literal_propagation.rs:4:5: 4:15\n+      let mut _3: u32;                     // in scope 0 at $DIR/scalar_literal_propagation.rs:4:13: 4:14\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/scalar_literal_propagation.rs:3:9: 3:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/scalar_literal_propagation.rs:3:9: 3:10\n+          _1 = const 1u32;                 // scope 0 at $DIR/scalar_literal_propagation.rs:3:13: 3:14\n+                                           // ty::Const\n+                                           // + ty: u32\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+                                           // + span: $DIR/scalar_literal_propagation.rs:3:13: 3:14\n+                                           // + literal: Const { ty: u32, val: Value(Scalar(0x00000001)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/scalar_literal_propagation.rs:4:5: 4:15\n+          StorageLive(_3);                 // scope 1 at $DIR/scalar_literal_propagation.rs:4:13: 4:14\n+-         _3 = _1;                         // scope 1 at $DIR/scalar_literal_propagation.rs:4:13: 4:14\n++         _3 = const 1u32;                 // scope 1 at $DIR/scalar_literal_propagation.rs:4:13: 4:14\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000001))\n++                                          // mir::Constant\n++                                          // + span: $DIR/scalar_literal_propagation.rs:4:13: 4:14\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000001)) }\n+          _2 = const consume(move _3) -> bb1; // scope 1 at $DIR/scalar_literal_propagation.rs:4:5: 4:15\n+                                           // ty::Const\n+                                           // + ty: fn(u32) {consume}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/scalar_literal_propagation.rs:4:5: 4:12\n+                                           // + literal: Const { ty: fn(u32) {consume}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 1 at $DIR/scalar_literal_propagation.rs:4:14: 4:15\n+          StorageDead(_2);                 // scope 1 at $DIR/scalar_literal_propagation.rs:4:15: 4:16\n+          _0 = const ();                   // scope 0 at $DIR/scalar_literal_propagation.rs:2:11: 5:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/scalar_literal_propagation.rs:2:11: 5:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/scalar_literal_propagation.rs:5:1: 5:2\n+          return;                          // scope 0 at $DIR/scalar_literal_propagation.rs:5:2: 5:2\n+      }\n+  }\n+  "}, {"sha": "015607cbab1a0d8061ac43039c4ef8ece7b3c7d7", "filename": "src/test/mir-opt/const_prop/tuple_literal_propagation.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,9 @@\n+// EMIT_MIR rustc.main.ConstProp.diff\n+fn main() {\n+    let x = (1, 2);\n+\n+    consume(x);\n+}\n+\n+#[inline(never)]\n+fn consume(_: (u32, u32)) { }"}, {"sha": "1511b361f587ff0db022d899797cc7dc9a7b6960", "filename": "src/test/mir-opt/const_prop/tuple_literal_propagation/rustc.main.ConstProp.diff", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Ftuple_literal_propagation%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,69 @@\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/tuple_literal_propagation.rs:2:11: 2:11\n+      let _1: (u32, u32);                  // in scope 0 at $DIR/tuple_literal_propagation.rs:3:9: 3:10\n+      let _2: ();                          // in scope 0 at $DIR/tuple_literal_propagation.rs:5:5: 5:15\n+      let mut _3: (u32, u32);              // in scope 0 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n+      scope 1 {\n+          debug x => _1;                   // in scope 1 at $DIR/tuple_literal_propagation.rs:3:9: 3:10\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/tuple_literal_propagation.rs:3:9: 3:10\n+          _1 = (const 1u32, const 2u32);   // scope 0 at $DIR/tuple_literal_propagation.rs:3:13: 3:19\n+                                           // ty::Const\n+                                           // + ty: u32\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/tuple_literal_propagation.rs:3:14: 3:15\n++                                          // + span: $DIR/tuple_literal_propagation.rs:3:13: 3:19\n+                                           // + literal: Const { ty: u32, val: Value(Scalar(0x00000001)) }\n+                                           // ty::Const\n+                                           // + ty: u32\n+                                           // + val: Value(Scalar(0x00000002))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/tuple_literal_propagation.rs:3:17: 3:18\n++                                          // + span: $DIR/tuple_literal_propagation.rs:3:13: 3:19\n+                                           // + literal: Const { ty: u32, val: Value(Scalar(0x00000002)) }\n+          StorageLive(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:5: 5:15\n+          StorageLive(_3);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n+-         _3 = _1;                         // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++         _3 = (const 1u32, const 2u32);   // scope 1 at $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000001))\n++                                          // mir::Constant\n++                                          // + span: $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000001)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000002))\n++                                          // mir::Constant\n++                                          // + span: $DIR/tuple_literal_propagation.rs:5:13: 5:14\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000002)) }\n+          _2 = const consume(move _3) -> bb1; // scope 1 at $DIR/tuple_literal_propagation.rs:5:5: 5:15\n+                                           // ty::Const\n+                                           // + ty: fn((u32, u32)) {consume}\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/tuple_literal_propagation.rs:5:5: 5:12\n+                                           // + literal: Const { ty: fn((u32, u32)) {consume}, val: Value(Scalar(<ZST>)) }\n+      }\n+  \n+      bb1: {\n+          StorageDead(_3);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:14: 5:15\n+          StorageDead(_2);                 // scope 1 at $DIR/tuple_literal_propagation.rs:5:15: 5:16\n+          _0 = const ();                   // scope 0 at $DIR/tuple_literal_propagation.rs:2:11: 6:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/tuple_literal_propagation.rs:2:11: 6:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/tuple_literal_propagation.rs:6:1: 6:2\n+          return;                          // scope 0 at $DIR/tuple_literal_propagation.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "24e91b3ff611c484c3ad91596c6f663296486d75", "filename": "src/test/mir-opt/simplify-arm-identity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -2,6 +2,7 @@\n // Regression test for issue #66856.\n //\n // compile-flags: -Zmir-opt-level=2\n+// EMIT_MIR_FOR_EACH_BIT_WIDTH\n \n enum Src {\n     Foo(u8),"}, {"sha": "bf24bfb2c57411797fb45814663a742d56ac3fb0", "filename": "src/test/mir-opt/simplify-arm-identity/32bit/rustc.main.SimplifyArmIdentity.diff", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F32bit%2Frustc.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F32bit%2Frustc.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F32bit%2Frustc.main.SimplifyArmIdentity.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,53 @@\n+- // MIR for `main` before SimplifyArmIdentity\n++ // MIR for `main` after SimplifyArmIdentity\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/simplify-arm-identity.rs:17:11: 17:11\n+      let _1: Src as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/simplify-arm-identity.rs:18:9: 18:10\n+      let mut _2: Dst;                     // in scope 0 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+      let mut _3: isize;                   // in scope 0 at $DIR/simplify-arm-identity.rs:20:9: 20:20\n+      let mut _5: u8;                      // in scope 0 at $DIR/simplify-arm-identity.rs:20:33: 20:34\n+      scope 1 {\n+          debug e => _1;                   // in scope 1 at $DIR/simplify-arm-identity.rs:18:9: 18:10\n+          let _4: u8;                      // in scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n+          scope 2 {\n+          }\n+          scope 3 {\n+              debug x => _4;               // in scope 3 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/simplify-arm-identity.rs:18:9: 18:10\n+          ((_1 as Foo).0: u8) = const 0u8; // scope 0 at $DIR/simplify-arm-identity.rs:18:18: 18:29\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:18:27: 18:28\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          discriminant(_1) = 0;            // scope 0 at $DIR/simplify-arm-identity.rs:18:18: 18:29\n+          StorageLive(_2);                 // scope 1 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+          _3 = const 0isize;               // scope 1 at $DIR/simplify-arm-identity.rs:20:9: 20:20\n+                                           // ty::Const\n+                                           // + ty: isize\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:20:9: 20:20\n+                                           // + literal: Const { ty: isize, val: Value(Scalar(0x00000000)) }\n+          _4 = ((_1 as Foo).0: u8);        // scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n+          ((_2 as Foo).0: u8) = move _4;   // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          discriminant(_2) = 0;            // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          StorageDead(_2);                 // scope 1 at $DIR/simplify-arm-identity.rs:22:6: 22:7\n+          _0 = const ();                   // scope 0 at $DIR/simplify-arm-identity.rs:17:11: 23:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:17:11: 23:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/simplify-arm-identity.rs:23:1: 23:2\n+          return;                          // scope 0 at $DIR/simplify-arm-identity.rs:23:2: 23:2\n+      }\n+  }\n+  "}, {"sha": "ff7183e57d2cfd46e8158d6606a53ca33d482a4f", "filename": "src/test/mir-opt/simplify-arm-identity/64bit/rustc.main.SimplifyArmIdentity.diff", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F64bit%2Frustc.main.SimplifyArmIdentity.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F64bit%2Frustc.main.SimplifyArmIdentity.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify-arm-identity%2F64bit%2Frustc.main.SimplifyArmIdentity.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,53 @@\n+- // MIR for `main` before SimplifyArmIdentity\n++ // MIR for `main` after SimplifyArmIdentity\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/simplify-arm-identity.rs:17:11: 17:11\n+      let _1: Src as UserTypeProjection { base: UserType(0), projs: [] }; // in scope 0 at $DIR/simplify-arm-identity.rs:18:9: 18:10\n+      let mut _2: Dst;                     // in scope 0 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+      let mut _3: isize;                   // in scope 0 at $DIR/simplify-arm-identity.rs:20:9: 20:20\n+      let mut _5: u8;                      // in scope 0 at $DIR/simplify-arm-identity.rs:20:33: 20:34\n+      scope 1 {\n+          debug e => _1;                   // in scope 1 at $DIR/simplify-arm-identity.rs:18:9: 18:10\n+          let _4: u8;                      // in scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n+          scope 2 {\n+          }\n+          scope 3 {\n+              debug x => _4;               // in scope 3 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n+          }\n+      }\n+  \n+      bb0: {\n+          StorageLive(_1);                 // scope 0 at $DIR/simplify-arm-identity.rs:18:9: 18:10\n+          ((_1 as Foo).0: u8) = const 0u8; // scope 0 at $DIR/simplify-arm-identity.rs:18:18: 18:29\n+                                           // ty::Const\n+                                           // + ty: u8\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:18:27: 18:28\n+                                           // + literal: Const { ty: u8, val: Value(Scalar(0x00)) }\n+          discriminant(_1) = 0;            // scope 0 at $DIR/simplify-arm-identity.rs:18:18: 18:29\n+          StorageLive(_2);                 // scope 1 at $DIR/simplify-arm-identity.rs:19:18: 22:6\n+          _3 = const 0isize;               // scope 1 at $DIR/simplify-arm-identity.rs:20:9: 20:20\n+                                           // ty::Const\n+                                           // + ty: isize\n+                                           // + val: Value(Scalar(0x0000000000000000))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:20:9: 20:20\n+                                           // + literal: Const { ty: isize, val: Value(Scalar(0x0000000000000000)) }\n+          _4 = ((_1 as Foo).0: u8);        // scope 1 at $DIR/simplify-arm-identity.rs:20:18: 20:19\n+          ((_2 as Foo).0: u8) = move _4;   // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          discriminant(_2) = 0;            // scope 3 at $DIR/simplify-arm-identity.rs:20:24: 20:35\n+          StorageDead(_2);                 // scope 1 at $DIR/simplify-arm-identity.rs:22:6: 22:7\n+          _0 = const ();                   // scope 0 at $DIR/simplify-arm-identity.rs:17:11: 23:2\n+                                           // ty::Const\n+                                           // + ty: ()\n+                                           // + val: Value(Scalar(<ZST>))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify-arm-identity.rs:17:11: 23:2\n+                                           // + literal: Const { ty: (), val: Value(Scalar(<ZST>)) }\n+          StorageDead(_1);                 // scope 0 at $DIR/simplify-arm-identity.rs:23:1: 23:2\n+          return;                          // scope 0 at $DIR/simplify-arm-identity.rs:23:2: 23:2\n+      }\n+  }\n+  "}, {"sha": "b8e1ea6f981faa1b4ae181b396c0f3cc1118324d", "filename": "src/test/mir-opt/simplify_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_match.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -1,7 +1,7 @@\n #[inline(never)]\n fn noop() {}\n \n-// EMIT_MIR rustc.main.SimplifyBranches-after-copy-prop.diff\n+// EMIT_MIR rustc.main.ConstProp.diff\n fn main() {\n     match { let x = false; x } {\n         true => noop(),"}, {"sha": "8003112c46c4bbc2776209bb87a76edc3f843cbd", "filename": "src/test/mir-opt/simplify_match/rustc.main.ConstProp.diff", "status": "renamed", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify_match%2Frustc.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fmir-opt%2Fsimplify_match%2Frustc.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_match%2Frustc.main.ConstProp.diff?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -1,5 +1,5 @@\n-- // MIR for `main` before SimplifyBranches-after-copy-prop\n-+ // MIR for `main` after SimplifyBranches-after-copy-prop\n+- // MIR for `main` before ConstProp\n++ // MIR for `main` after ConstProp\n   \n   fn main() -> () {\n       let mut _0: ();                      // return place in scope 0 at $DIR/simplify_match.rs:5:11: 5:11\n@@ -10,19 +10,32 @@\n       }\n   \n       bb0: {\n-          nop;                             // scope 0 at $DIR/simplify_match.rs:6:11: 6:31\n-          nop;                             // scope 0 at $DIR/simplify_match.rs:6:17: 6:18\n-          nop;                             // scope 0 at $DIR/simplify_match.rs:6:21: 6:26\n-          nop;                             // scope 1 at $DIR/simplify_match.rs:6:28: 6:29\n-          nop;                             // scope 0 at $DIR/simplify_match.rs:6:30: 6:31\n--         switchInt(const false) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:7:9: 7:13\n--                                          // ty::Const\n--                                          // + ty: bool\n--                                          // + val: Value(Scalar(0x00))\n--                                          // mir::Constant\n--                                          // + span: $DIR/simplify_match.rs:6:21: 6:26\n--                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n-+         goto -> bb1;                     // scope 0 at $DIR/simplify_match.rs:7:9: 7:13\n+          StorageLive(_1);                 // scope 0 at $DIR/simplify_match.rs:6:11: 6:31\n+          StorageLive(_2);                 // scope 0 at $DIR/simplify_match.rs:6:17: 6:18\n+          _2 = const false;                // scope 0 at $DIR/simplify_match.rs:6:21: 6:26\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+                                           // + span: $DIR/simplify_match.rs:6:21: 6:26\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+-         _1 = _2;                         // scope 1 at $DIR/simplify_match.rs:6:28: 6:29\n++         _1 = const false;                // scope 1 at $DIR/simplify_match.rs:6:28: 6:29\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/simplify_match.rs:6:28: 6:29\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/simplify_match.rs:6:30: 6:31\n+-         switchInt(_1) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:7:9: 7:13\n++         switchInt(const false) -> [false: bb1, otherwise: bb2]; // scope 0 at $DIR/simplify_match.rs:7:9: 7:13\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/simplify_match.rs:7:9: 7:13\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n       }\n   \n       bb1: {\n@@ -47,7 +60,7 @@\n       }\n   \n       bb3: {\n-          nop;                             // scope 0 at $DIR/simplify_match.rs:10:1: 10:2\n+          StorageDead(_1);                 // scope 0 at $DIR/simplify_match.rs:10:1: 10:2\n           return;                          // scope 0 at $DIR/simplify_match.rs:10:2: 10:2\n       }\n   }", "previous_filename": "src/test/mir-opt/simplify_match/rustc.main.SimplifyBranches-after-copy-prop.diff"}, {"sha": "ba93563154a3b3958189e8d5fd82cadb58dfad3f", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -1,5 +1,5 @@\n // error-pattern:attempt to divide by zero\n-\n+#[allow(unconditional_panic)]\n fn main() {\n     let y = 0;\n     let _z = 1 / y;"}, {"sha": "2575de7cc58336fbd85028a9be61dd0cb1c060c8", "filename": "src/test/run-fail/dst-raw-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -1,6 +1,6 @@\n // Test bounds checking for DST raw slices\n // error-pattern:index out of bounds\n-\n+#[allow(unconditional_panic)]\n fn main() {\n     let a: *const [_] = &[1, 2, 3];\n     unsafe {"}, {"sha": "f70b3ac920c6116258ae0ccd79ece1d8171b1171", "filename": "src/test/run-fail/mod-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Frun-fail%2Fmod-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmod-zero.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -1,5 +1,5 @@\n // error-pattern:attempt to calculate the remainder with a divisor of zero\n-\n+#[allow(unconditional_panic)]\n fn main() {\n     let y = 0;\n     let _z = 1 % y;"}, {"sha": "0940dbe6a5e87bc2de526500c0a2aea0462974f4", "filename": "src/test/ui/mir/mir_detects_invalid_ops.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.rs?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,24 @@\n+// build-fail\n+\n+fn main() {\n+    divide_by_zero();\n+    mod_by_zero();\n+    oob_error_for_slices();\n+}\n+\n+fn divide_by_zero() {\n+    let y = 0;\n+    let _z = 1 / y; //~ ERROR this operation will panic at runtime [unconditional_panic]\n+}\n+\n+fn mod_by_zero() {\n+    let y = 0;\n+    let _z = 1 % y; //~ ERROR this operation will panic at runtime [unconditional_panic]\n+}\n+\n+fn oob_error_for_slices() {\n+    let a: *const [_] = &[1, 2, 3];\n+    unsafe {\n+        let _b = (*a)[3]; //~ ERROR this operation will panic at runtime [unconditional_panic]\n+    }\n+}"}, {"sha": "41f03789f237f62cf0b260d3b9a4613e07c1c18e", "filename": "src/test/ui/mir/mir_detects_invalid_ops.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92019986aa6532256277ca999006bdc77e9a95ad/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_detects_invalid_ops.stderr?ref=92019986aa6532256277ca999006bdc77e9a95ad", "patch": "@@ -0,0 +1,22 @@\n+error: this operation will panic at runtime\n+  --> $DIR/mir_detects_invalid_ops.rs:11:14\n+   |\n+LL |     let _z = 1 / y;\n+   |              ^^^^^ attempt to divide by zero\n+   |\n+   = note: `#[deny(unconditional_panic)]` on by default\n+\n+error: this operation will panic at runtime\n+  --> $DIR/mir_detects_invalid_ops.rs:16:14\n+   |\n+LL |     let _z = 1 % y;\n+   |              ^^^^^ attempt to calculate the remainder with a divisor of zero\n+\n+error: this operation will panic at runtime\n+  --> $DIR/mir_detects_invalid_ops.rs:22:18\n+   |\n+LL |         let _b = (*a)[3];\n+   |                  ^^^^^^^ index out of bounds: the len is 3 but the index is 3\n+\n+error: aborting due to 3 previous errors\n+"}]}