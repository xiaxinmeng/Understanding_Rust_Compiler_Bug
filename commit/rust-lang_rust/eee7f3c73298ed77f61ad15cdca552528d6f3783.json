{"sha": "eee7f3c73298ed77f61ad15cdca552528d6f3783", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlZTdmM2M3MzI5OGVkNzdmNjFhZDE1Y2RjYTU1MjUyOGQ2ZjM3ODM=", "commit": {"author": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-03-11T05:00:52Z"}, "committer": {"name": "James Miller", "email": "james@aatch.net", "date": "2016-03-29T23:59:57Z"}, "message": "Add and use a break critical edges transform\n\nThis is a fairly standard transform that inserts blocks along critical\nedges so code can be inserted along the edge without it affecting other\nedges. The main difference is that it considers a Drop or Call\nterminator that would require an `invoke` instruction in LLVM a critical\nedge. This is because we can't actually insert code after an invoke, so\nit ends up looking similar to a critical edge anyway.\n\nThe transform is run just before translation right now.", "tree": {"sha": "3a168f9e0637b07d1ee6a7ace59ae202135ee8ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a168f9e0637b07d1ee6a7ace59ae202135ee8ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eee7f3c73298ed77f61ad15cdca552528d6f3783", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eee7f3c73298ed77f61ad15cdca552528d6f3783", "html_url": "https://github.com/rust-lang/rust/commit/eee7f3c73298ed77f61ad15cdca552528d6f3783", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eee7f3c73298ed77f61ad15cdca552528d6f3783/comments", "author": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aatch", "id": 342416, "node_id": "MDQ6VXNlcjM0MjQxNg==", "avatar_url": "https://avatars.githubusercontent.com/u/342416?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aatch", "html_url": "https://github.com/Aatch", "followers_url": "https://api.github.com/users/Aatch/followers", "following_url": "https://api.github.com/users/Aatch/following{/other_user}", "gists_url": "https://api.github.com/users/Aatch/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aatch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aatch/subscriptions", "organizations_url": "https://api.github.com/users/Aatch/orgs", "repos_url": "https://api.github.com/users/Aatch/repos", "events_url": "https://api.github.com/users/Aatch/events{/privacy}", "received_events_url": "https://api.github.com/users/Aatch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a28e60aa6eb0ed074fa5e6875e60cb2f038605", "html_url": "https://github.com/rust-lang/rust/commit/60a28e60aa6eb0ed074fa5e6875e60cb2f038605"}], "stats": {"total": 269, "additions": 227, "deletions": 42}, "files": [{"sha": "03f6ce355b85a8a6f75ac20e4e7213dc615fbba3", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=eee7f3c73298ed77f61ad15cdca552528d6f3783", "patch": "@@ -932,7 +932,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n-                                       mir_map: MirMap<'tcx>,\n+                                       mut mir_map: MirMap<'tcx>,\n                                        analysis: ty::CrateAnalysis)\n                                        -> trans::CrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n@@ -941,6 +941,13 @@ pub fn phase_4_translate_to_llvm<'tcx>(tcx: &TyCtxt<'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n+    time(time_passes,\n+         \"erasing regions from MIR\",\n+         || mir::transform::erase_regions::erase_regions(tcx, &mut mir_map));\n+\n+    time(time_passes, \"breaking critical edges\",\n+         || mir::transform::break_critical_edges::break_critical_edges(&mut mir_map));\n+\n     // Option dance to work around the lack of stack once closures.\n     time(time_passes,\n          \"translation\","}, {"sha": "5e64da0ec90e65aecfaf726356dd0afa01e41757", "filename": "src/librustc_mir/transform/break_critical_edges.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fbreak_critical_edges.rs?ref=eee7f3c73298ed77f61ad15cdca552528d6f3783", "patch": "@@ -0,0 +1,180 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use std::mem;\n+\n+use rustc_back::slice;\n+use rustc::mir::repr::*;\n+use rustc::mir::mir_map::MirMap;\n+\n+use traversal;\n+\n+/**\n+ * Breaks critical edges in the MIR.\n+ *\n+ * Critical edges are edges that are neither the only edge leaving a\n+ * block, nor the only edge entering one.\n+ *\n+ * When you want something to happen \"along\" an edge, you can either\n+ * do at the end of the predecessor block, or at the start of the\n+ * successor block. Critical edges have to be broken in order to prevent\n+ * \"edge actions\" from affecting other edges.\n+ *\n+ * This function will break those edges by inserting new blocks along them.\n+ *\n+ * A special case is Drop and Call terminators with unwind/cleanup successors,\n+ * They use `invoke` in LLVM, which terminates a block, meaning that code cannot\n+ * be inserted after them, so even if an edge is the only edge leaving a block\n+ * like that, we still insert blocks if the edge is one of many entering the\n+ * target.\n+ *\n+ * NOTE: Simplify CFG will happily undo most of the work this pass does.\n+ *\n+ */\n+pub fn break_critical_edges<'tcx>(mir_map: &mut MirMap<'tcx>) {\n+    for (_, mir) in &mut mir_map.map {\n+        break_critical_edges_fn(mir);\n+    }\n+}\n+\n+/*\n+ * Predecessor map for tracking the predecessors of a block\n+ */\n+struct PredMap {\n+    preds: Vec<BlockPredecessors>\n+}\n+\n+/**\n+ * Most blocks only have one predecessor, so we can cut down on\n+ * some allocation by not using Vec until we have more than one.\n+ */\n+#[derive(Clone)]\n+enum BlockPredecessors {\n+    None,\n+    One(BasicBlock),\n+    Some(Vec<BasicBlock>)\n+}\n+\n+impl PredMap {\n+    pub fn new(n: usize) -> PredMap {\n+        let preds = vec![BlockPredecessors::None; n];\n+\n+        PredMap {\n+            preds: preds\n+        }\n+    }\n+\n+    fn ensure_len(&mut self, bb: BasicBlock) {\n+        let idx = bb.index();\n+        while self.preds.len() <= idx {\n+            self.preds.push(BlockPredecessors::None);\n+        }\n+    }\n+\n+    pub fn add_pred(&mut self, target: BasicBlock, pred: BasicBlock) {\n+        self.ensure_len(target);\n+\n+        let preds = mem::replace(&mut self.preds[target.index()], BlockPredecessors::None);\n+        match preds {\n+            BlockPredecessors::None => {\n+                self.preds[target.index()] = BlockPredecessors::One(pred);\n+            }\n+            BlockPredecessors::One(bb) => {\n+                self.preds[target.index()] = BlockPredecessors::Some(vec![bb, pred]);\n+            }\n+            BlockPredecessors::Some(mut preds) => {\n+                preds.push(pred);\n+                self.preds[target.index()] = BlockPredecessors::Some(preds);\n+            }\n+        }\n+    }\n+\n+    pub fn remove_pred(&mut self, target: BasicBlock, pred: BasicBlock) {\n+        self.ensure_len(target);\n+\n+        let preds = mem::replace(&mut self.preds[target.index()], BlockPredecessors::None);\n+        match preds {\n+            BlockPredecessors::None => {}\n+            BlockPredecessors::One(bb) if bb == pred => {}\n+\n+            BlockPredecessors::One(bb) => {\n+                self.preds[target.index()] = BlockPredecessors::One(bb);\n+            }\n+\n+            BlockPredecessors::Some(mut preds) => {\n+                preds.retain(|&bb| bb != pred);\n+                self.preds[target.index()] = BlockPredecessors::Some(preds);\n+            }\n+        }\n+    }\n+\n+    pub fn get_preds(&self, bb: BasicBlock) -> &[BasicBlock] {\n+        match self.preds[bb.index()] {\n+            BlockPredecessors::None => &[],\n+            BlockPredecessors::One(ref bb) => slice::ref_slice(bb),\n+            BlockPredecessors::Some(ref bbs) => &bbs[..]\n+        }\n+    }\n+}\n+\n+\n+fn break_critical_edges_fn(mir: &mut Mir) {\n+    let mut pred_map = PredMap::new(mir.basic_blocks.len());\n+\n+    // Build the precedecessor map for the MIR\n+    for (pred, data) in traversal::preorder(mir) {\n+        if let Some(ref term) = data.terminator {\n+            for &tgt in term.successors().iter() {\n+                pred_map.add_pred(tgt, pred);\n+            }\n+        }\n+    }\n+\n+    // We need a place to store the new blocks generated\n+    let mut new_blocks = Vec::new();\n+\n+    let bbs = mir.all_basic_blocks();\n+    let cur_len = mir.basic_blocks.len();\n+\n+    for &bb in &bbs {\n+        let data = mir.basic_block_data_mut(bb);\n+\n+        if let Some(ref mut term) = data.terminator {\n+            let is_invoke = term_is_invoke(term);\n+            let succs = term.successors_mut();\n+            if succs.len() > 1 || (succs.len() > 0 && is_invoke) {\n+                for tgt in succs {\n+                    let num_preds = pred_map.get_preds(*tgt).len();\n+                    if num_preds > 1 {\n+                        // It's a critical edge, break it\n+                        let goto = Terminator::Goto { target: *tgt };\n+                        let data = BasicBlockData::new(Some(goto));\n+                        // Get the index it will be when inserted into the MIR\n+                        let idx = cur_len + new_blocks.len();\n+                        new_blocks.push(data);\n+                        *tgt = BasicBlock::new(idx);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    debug!(\"Broke {} N edges\", new_blocks.len());\n+\n+    mir.basic_blocks.extend_from_slice(&new_blocks);\n+}\n+\n+// Returns true if the terminator would use an invoke in LLVM.\n+fn term_is_invoke(term: &Terminator) -> bool {\n+    match *term {\n+        Terminator::Call { cleanup: Some(_), .. } |\n+        Terminator::Drop { unwind: Some(_), .. } => true,\n+        _ => false\n+    }\n+}"}, {"sha": "a52a8edc211730eb31b5b5a6e20c11a3b8ead040", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=eee7f3c73298ed77f61ad15cdca552528d6f3783", "patch": "@@ -13,3 +13,4 @@ pub mod simplify_cfg;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n+pub mod break_critical_edges;"}, {"sha": "1efbe5df1625f37d811dbc28da11fb98f3808859", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 11, "deletions": 35, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=eee7f3c73298ed77f61ad15cdca552528d6f3783", "patch": "@@ -300,33 +300,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Many different ways to call a function handled here\n                 if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {\n-                    // We translate the copy into a temporary block. The temporary block is\n-                    // necessary because the current block has already been terminated (by\n-                    // `invoke`) and we cannot really translate into the target block\n-                    // because:\n-                    //  * The target block may have more than a single precedesor;\n-                    //  * Some LLVM insns cannot have a preceeding store insn (phi,\n-                    //    cleanuppad), and adding/prepending the store now may render\n-                    //    those other instructions invalid.\n-                    //\n-                    // NB: This approach still may break some LLVM code. For example if the\n-                    // target block starts with a `phi` (which may only match on immediate\n-                    // precedesors), it cannot know about this temporary block thus\n-                    // resulting in an invalid code:\n-                    //\n-                    // this:\n-                    //     \u2026\n-                    //     %0 = \u2026\n-                    //     %1 = invoke to label %temp \u2026\n-                    // temp:\n-                    //     store ty %1, ty* %dest\n-                    //     br label %actualtargetblock\n-                    // actualtargetblock:            ; preds: %temp, \u2026\n-                    //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n-                    //                               ; immediate precedesors\n-\n-                    let ret_bcx = if destination.is_some() {\n-                        self.fcx.new_block(\"\", None)\n+                    let ret_bcx = if let Some((_, target)) = *destination {\n+                        self.blocks[target.index()]\n                     } else {\n                         self.unreachable_block()\n                     };\n@@ -343,15 +318,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         self.set_operand_dropped(bcx, op);\n                     });\n \n-                    if let Some((_, target)) = *destination {\n+                    if destination.is_some() {\n                         let ret_bcx = ret_bcx.build();\n-                        if let Some(ret_dest) = ret_dest {\n-                            fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n-                        }\n-                        for op in args {\n-                            self.set_operand_dropped(&ret_bcx, op);\n-                        }\n-                        ret_bcx.br(self.llblock(target));\n+                        ret_bcx.at_start(|ret_bcx| {\n+                            if let Some(ret_dest) = ret_dest {\n+                                fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n+                            }\n+                            for op in args {\n+                                self.set_operand_dropped(&ret_bcx, op);\n+                            }\n+                        });\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());"}, {"sha": "27e09d04a9d1c19f7692653cd53f8359e833c41b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eee7f3c73298ed77f61ad15cdca552528d6f3783/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=eee7f3c73298ed77f61ad15cdca552528d6f3783", "patch": "@@ -19,10 +19,11 @@ use common::{self, Block, BlockAndBuilder, FunctionContext};\n use std::ops::Deref;\n use std::rc::Rc;\n \n+use rustc_data_structures::bitvec::BitVector;\n+\n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use rustc_mir::traversal;\n \n-use self::lvalue::LvalueRef;\n use self::operand::OperandRef;\n \n #[derive(Clone)]\n@@ -98,7 +99,7 @@ enum TempRef<'tcx> {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n+pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let bcx = fcx.init(false, None).build();\n     let mir = bcx.mir();\n \n@@ -135,8 +136,13 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let block_bcxs: Vec<Block<'blk,'tcx>> =\n         mir_blocks.iter()\n                   .map(|&bb|{\n-                      // FIXME(#30941) this doesn't handle msvc-style exceptions\n-                      fcx.new_block(&format!(\"{:?}\", bb), None)\n+                      if bb == mir::START_BLOCK {\n+                          fcx.new_block(\"start\", None)\n+                      } else if bb == mir::END_BLOCK {\n+                          fcx.new_block(\"end\", None)\n+                      } else {\n+                          fcx.new_block(&format!(\"{:?}\", bb), None)\n+                      }\n                   })\n                   .collect();\n \n@@ -145,7 +151,7 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     bcx.br(start_bcx.llbb);\n \n     let mut mircx = MirContext {\n-        mir: mir,\n+        mir: mir.clone(),\n         fcx: fcx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n@@ -155,13 +161,28 @@ pub fn trans_mir<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         args: args,\n     };\n \n-    let rpo = traversal::reverse_postorder(mir);\n+    let mut visited = BitVector::new(mir_blocks.len());\n+\n+    let rpo = traversal::reverse_postorder(&mir);\n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n+        visited.insert(bb.index());\n         mircx.trans_block(bb);\n     }\n \n+    // Add unreachable instructions at the end of unreachable blocks\n+    // so they're actually terminated.\n+    // TODO: Remove the blocks from the function\n+    for &bb in &mir_blocks {\n+        if !visited.contains(bb.index()) {\n+            mircx.blocks[bb.index()].build().unreachable();\n+        }\n+    }\n+\n+\n     fcx.cleanup();\n+\n+    debug!(\"trans_mir: {:?}\", ::trans::value::Value(fcx.llfn));\n }\n \n /// Produce, for each argument, a `ValueRef` pointing at the"}]}