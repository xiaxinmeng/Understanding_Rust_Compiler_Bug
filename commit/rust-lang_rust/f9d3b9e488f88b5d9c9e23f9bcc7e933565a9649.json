{"sha": "f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZDNiOWU0ODhmODhiNWQ5YzllMjNmOWJjYzdlOTMzNTY1YTk2NDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T16:51:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T16:51:28Z"}, "message": "auto merge of #15220 : vhbit/rust/treemap-str-equiv, r=alexcrichton\n\n- it allows to lookup using any str-equiv object, making TreeMaps finally usable (for example, it is much easier to work with JSON with lookup values being static strs)\r\n- actually provides pretty flexible solution which could be extended to other equivalent types (although it might be not that performant)", "tree": {"sha": "3437346107b429e6552492d113b8f81c88508d8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3437346107b429e6552492d113b8f81c88508d8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649", "html_url": "https://github.com/rust-lang/rust/commit/f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f3291e0c7d9d189553b16c52dda3851423534a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3291e0c7d9d189553b16c52dda3851423534a5", "html_url": "https://github.com/rust-lang/rust/commit/3f3291e0c7d9d189553b16c52dda3851423534a5"}, {"sha": "be7a17062b103b31798afcd525c51a9642038465", "url": "https://api.github.com/repos/rust-lang/rust/commits/be7a17062b103b31798afcd525c51a9642038465", "html_url": "https://github.com/rust-lang/rust/commit/be7a17062b103b31798afcd525c51a9642038465"}], "stats": {"total": 163, "additions": 136, "deletions": 27}, "files": [{"sha": "e0242af3c9973c327dd6e1b4fcc3db3ea39ec2f1", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 136, "deletions": 27, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=f9d3b9e488f88b5d9c9e23f9bcc7e933565a9649", "patch": "@@ -88,40 +88,18 @@ impl<K: Ord, V> Mutable for TreeMap<K, V> {\n }\n \n impl<K: Ord, V> Map<K, V> for TreeMap<K, V> {\n+    // See comments on tree_find_with\n+    #[inline]\n     fn find<'a>(&'a self, key: &K) -> Option<&'a V> {\n-        let mut current = &self.root;\n-        loop {\n-            match *current {\n-              Some(ref r) => {\n-                match key.cmp(&r.key) {\n-                  Less => current = &r.left,\n-                  Greater => current = &r.right,\n-                  Equal => return Some(&r.value)\n-                }\n-              }\n-              None => return None\n-            }\n-        }\n+        tree_find_with(&self.root, |k2| key.cmp(k2))\n     }\n }\n \n impl<K: Ord, V> MutableMap<K, V> for TreeMap<K, V> {\n+    // See comments on def_tree_find_mut_with\n     #[inline]\n     fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V> {\n-        let mut current = &mut self.root;\n-        loop {\n-            let temp = current; // hack to appease borrowck\n-            match *temp {\n-              Some(ref mut r) => {\n-                match key.cmp(&r.key) {\n-                  Less => current = &mut r.left,\n-                  Greater => current = &mut r.right,\n-                  Equal => return Some(&mut r.value)\n-                }\n-              }\n-              None => return None\n-            }\n-        }\n+        tree_find_mut_with(&mut self.root, |x| key.cmp(x))\n     }\n \n     fn swap(&mut self, key: K, value: V) -> Option<V> {\n@@ -194,6 +172,55 @@ impl<K: Ord, V> TreeMap<K, V> {\n     }\n }\n \n+impl<K, V> TreeMap<K, V> {\n+    /// Return the value for which f(key) returns Equal. f is invoked\n+    /// with current key and helps to navigate the tree\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::ascii::StrAsciiExt;\n+    ///\n+    /// let mut t = collections::treemap::TreeMap::new();\n+    /// t.insert(\"Content-Type\", \"application/xml\");\n+    /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n+    ///\n+    /// let ua_key = \"user-agent\";\n+    /// let ua = t.find_with(|&k| {\n+    ///    ua_key.cmp(&k.to_ascii_lower().as_slice())\n+    /// });\n+    ///\n+    /// assert_eq!(*ua.unwrap(), \"Curl-Rust/0.1\");\n+    /// ```\n+    #[inline]\n+    pub fn find_with<'a>(&'a self, f:|&K| -> Ordering) -> Option<&'a V> {\n+        tree_find_with(&self.root, f)\n+    }\n+\n+    /// Return the value for which f(key) returns Equal. f is invoked\n+    /// with current key and helps to navigate the tree\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut t = collections::treemap::TreeMap::new();\n+    /// t.insert(\"Content-Type\", \"application/xml\");\n+    /// t.insert(\"User-Agent\", \"Curl-Rust/0.1\");\n+    ///\n+    /// let new_ua = \"Safari/156.0\";\n+    /// match t.find_mut_with(|k| \"User-Agent\".cmp(k)) {\n+    ///    Some(x) => *x = new_ua,\n+    ///    None => fail!(),\n+    /// }\n+    ///\n+    /// assert_eq!(t.find(&\"User-Agent\"), Some(&new_ua));\n+    /// ```\n+    #[inline]\n+    pub fn find_mut_with<'a>(&'a mut self, f:|&K| -> Ordering) -> Option<&'a mut V> {\n+        tree_find_mut_with(&mut self.root, f)\n+    }\n+}\n+\n // range iterators.\n \n macro_rules! bound_setup {\n@@ -853,6 +880,51 @@ fn split<K: Ord, V>(node: &mut Box<TreeNode<K, V>>) {\n     }\n }\n \n+// Next 2 functions have the same conventions\n+//\n+// The only difference is that non-mutable version uses loop instead\n+// of recursion (performance considerations)\n+// It seems to be impossible to avoid recursion with mutability\n+//\n+// So convention is that comparator is gets at input current key\n+// and returns search_key cmp cur_key (i.e. search_key.cmp(cur_key))\n+fn tree_find_with<'r, K, V>(node: &'r Option<Box<TreeNode<K, V>>>,\n+                            f: |&K| -> Ordering) -> Option<&'r V> {\n+    let mut current: &'r Option<Box<TreeNode<K, V>>> = node;\n+    loop {\n+        match *current {\n+            Some(ref r) => {\n+                match f(&r.key) {\n+                    Less => current = &r.left,\n+                    Greater => current = &r.right,\n+                    Equal => return Some(&r.value)\n+                }\n+            }\n+            None => return None\n+        }\n+    }\n+}\n+\n+// See comments above tree_find_with\n+fn tree_find_mut_with<'r, K, V>(node: &'r mut Option<Box<TreeNode<K, V>>>,\n+                                f: |&K| -> Ordering) -> Option<&'r mut V> {\n+\n+    let mut current = node;\n+    loop {\n+        let temp = current; // hack to appease borrowck\n+        match *temp {\n+            Some(ref mut r) => {\n+                match f(&r.key) {\n+                    Less => current = &mut r.left,\n+                    Greater => current = &mut r.right,\n+                    Equal => return Some(&mut r.value)\n+                }\n+            }\n+            None => return None\n+        }\n+    }\n+}\n+\n fn insert<K: Ord, V>(node: &mut Option<Box<TreeNode<K, V>>>,\n                           key: K, value: V) -> Option<V> {\n     match *node {\n@@ -1024,6 +1096,30 @@ mod test_treemap {\n         assert_eq!(m.find(&2), None);\n     }\n \n+    #[test]\n+    fn find_with_empty() {\n+        let m: TreeMap<&'static str,int> = TreeMap::new();\n+        assert!(m.find_with(|k| \"test\".cmp(k)) == None);\n+    }\n+\n+    #[test]\n+    fn find_with_not_found() {\n+        let mut m = TreeMap::new();\n+        assert!(m.insert(\"test1\", 2i));\n+        assert!(m.insert(\"test2\", 3i));\n+        assert!(m.insert(\"test3\", 3i));\n+        assert_eq!(m.find_with(|k| \"test4\".cmp(k)), None);\n+    }\n+\n+    #[test]\n+    fn find_with_found() {\n+        let mut m = TreeMap::new();\n+        assert!(m.insert(\"test1\", 2i));\n+        assert!(m.insert(\"test2\", 3i));\n+        assert!(m.insert(\"test3\", 4i));\n+        assert_eq!(m.find_with(|k| \"test2\".cmp(k)), Some(&3i));\n+    }\n+\n     #[test]\n     fn test_find_mut() {\n         let mut m = TreeMap::new();\n@@ -1037,6 +1133,19 @@ mod test_treemap {\n         assert_eq!(m.find(&5), Some(&new));\n     }\n \n+    #[test]\n+    fn test_find_with_mut() {\n+        let mut m = TreeMap::new();\n+        assert!(m.insert(\"t1\", 12i));\n+        assert!(m.insert(\"t2\", 8));\n+        assert!(m.insert(\"t5\", 14));\n+        let new = 100;\n+        match m.find_mut_with(|k| \"t5\".cmp(k)) {\n+          None => fail!(), Some(x) => *x = new\n+        }\n+        assert_eq!(m.find_with(|k| \"t5\".cmp(k)), Some(&new));\n+    }\n+\n     #[test]\n     fn insert_replace() {\n         let mut m = TreeMap::new();"}]}