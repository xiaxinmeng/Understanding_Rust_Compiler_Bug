{"sha": "34b42eeb657dfe051ebaf0f95ba5a428441b04af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0YjQyZWViNjU3ZGZlMDUxZWJhZjBmOTViYTVhNDI4NDQxYjA0YWY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-21T16:37:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-21T16:37:34Z"}, "message": "change list so that it must be used in a purely boxed fashion\n\nThe old way was inconsistent---the head was unboxed but the\ntail was boxed.  This resulted in numerous needless copies and\nalso made the borrow check unhappy, because the head tended to be\nstored in mutable memory.", "tree": {"sha": "20084857a9512d54046f82dd9448714fe123b2ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20084857a9512d54046f82dd9448714fe123b2ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34b42eeb657dfe051ebaf0f95ba5a428441b04af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34b42eeb657dfe051ebaf0f95ba5a428441b04af", "html_url": "https://github.com/rust-lang/rust/commit/34b42eeb657dfe051ebaf0f95ba5a428441b04af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34b42eeb657dfe051ebaf0f95ba5a428441b04af/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e73bb6ea06cf52b52cb403c84106873519f1220", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e73bb6ea06cf52b52cb403c84106873519f1220", "html_url": "https://github.com/rust-lang/rust/commit/8e73bb6ea06cf52b52cb403c84106873519f1220"}], "stats": {"total": 255, "additions": 127, "deletions": 128}, "files": [{"sha": "163deef06408b24626473b779a31c492b8493a6b", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -3,9 +3,10 @@\n export arena, arena_with_size;\n \n import list;\n+import list::{list, cons, nil};\n \n type chunk = {data: [u8], mut fill: uint};\n-type arena = {mut chunks: list::list<@chunk>};\n+type arena = {mut chunks: @list<@chunk>};\n \n fn chunk(size: uint) -> @chunk {\n     let mut v = [];\n@@ -14,7 +15,7 @@ fn chunk(size: uint) -> @chunk {\n }\n \n fn arena_with_size(initial_size: uint) -> arena {\n-    ret {mut chunks: list::cons(chunk(initial_size), @list::nil)};\n+    ret {mut chunks: @cons(chunk(initial_size), @nil)};\n }\n \n fn arena() -> arena {\n@@ -28,7 +29,7 @@ impl arena for arena {\n         let chunk_size = vec::capacity(head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n         head = chunk(uint::next_power_of_two(new_min_chunk_size + 1u));\n-        self.chunks = list::cons(head, @self.chunks);\n+        self.chunks = @cons(head, self.chunks);\n \n         ret self.alloc(n_bytes, align);\n     }"}, {"sha": "cc582d370bf426f453495b562587786502e53c5e", "filename": "src/libstd/list.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -11,7 +11,7 @@ enum list<T> {\n \n #[doc = \"Create a list from a vector\"]\n fn from_vec<T: copy>(v: [const T]) -> @list<T> {\n-    @vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n+    vec::foldr(v, @nil::<T>, { |h, t| @cons(h, t) })\n }\n \n #[doc = \"\n@@ -43,7 +43,7 @@ is returned. If `f` matches no elements then none is returned.\n fn find<T: copy>(ls: @list<T>, f: fn(T) -> bool) -> option<T> {\n     let mut ls = ls;\n     loop {\n-        ls = alt ls {\n+        ls = alt *ls {\n           cons(hd, tl) {\n             if f(hd) { ret some(hd); }\n             tl\n@@ -82,7 +82,7 @@ fn len<T>(ls: @list<T>) -> uint {\n }\n \n #[doc = \"Returns all but the first element of a list\"]\n-pure fn tail<T: copy>(ls: @list<T>) -> list<T> {\n+pure fn tail<T: copy>(ls: @list<T>) -> @list<T> {\n     alt *ls {\n         cons(_, tl) { ret tl; }\n         nil { fail \"list empty\" }\n@@ -98,7 +98,7 @@ pure fn head<T: copy>(ls: @list<T>) -> T {\n pure fn append<T: copy>(l: @list<T>, m: @list<T>) -> @list<T> {\n     alt *l {\n       nil { ret m; }\n-      cons(x, xs) { let rest = append(*xs, m); ret @cons(x, @rest); }\n+      cons(x, xs) { let rest = append(xs, m); ret @cons(x, rest); }\n     }\n }\n \n@@ -117,12 +117,13 @@ fn iter<T>(l: @list<T>, f: fn(T)) {\n }\n \n #[doc = \"Iterate over a list\"]\n-fn each<T>(l: list<T>, f: fn(T) -> bool) {\n+fn each<T>(l: @list<T>, f: fn(T) -> bool) {\n     let mut cur = l;\n     loop {\n         cur = alt *cur {\n           cons(hd, tl) {\n             if !f(hd) { ret; }\n+            tl\n           }\n           nil { break; }\n         }\n@@ -163,7 +164,7 @@ mod tests {\n     #[test]\n     fn test_from_vec_empty() {\n         let empty : @list::list<int> = from_vec([]);\n-        assert (empty == list::nil::<int>);\n+        assert (empty == @list::nil::<int>);\n     }\n \n     #[test]\n@@ -208,7 +209,7 @@ mod tests {\n     fn test_find_fail() {\n         fn match(&&_i: int) -> bool { ret false; }\n         let l = from_vec([0, 1, 2]);\n-        let empty = list::nil::<int>;\n+        let empty = @list::nil::<int>;\n         assert (list::find(l, match) == option::none::<int>);\n         assert (list::find(empty, match) == option::none::<int>);\n     }"}, {"sha": "d41371579358eb643cf79fb9d71f9d1bd25c8ba1", "filename": "src/rustc/middle/alias.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Falias.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -33,7 +33,7 @@ type binding = @{node_id: node_id,\n \n // FIXME it may be worthwhile to use a linked list of bindings instead\n type scope = {bs: [binding],\n-              invalid: @mut list<@invalid>};\n+              invalid: @mut @list<@invalid>};\n \n fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option<node_id>,\n               unsafe_tys: [unsafe_ty]) -> binding {\n@@ -68,7 +68,7 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n-    let sc = {bs: [], invalid: @mut list::nil};\n+    let sc = {bs: [], invalid: @mut @list::nil};\n     visit::visit_crate(*crate, sc, visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n     ret (cx.copy_map, cx.ref_map);\n@@ -88,7 +88,7 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n         check_loop(*cx, sc) {|| v.visit_block(body, sc, v);}\n       }\n       ast::proto_box | ast::proto_uniq | ast::proto_bare {\n-        let sc = {bs: [], invalid: @mut list::nil};\n+        let sc = {bs: [], invalid: @mut @list::nil};\n         v.visit_block(body, sc, v);\n       }\n     }\n@@ -400,7 +400,7 @@ fn check_var(cx: ctx, ex: @ast::expr, p: @ast::path, id: ast::node_id,\n                 if ty_can_unsafely_include(cx, unsafe_ty, var_t, assign) {\n                     let inv = @{reason: val_taken, node_id: b.node_id,\n                                 sp: ex.span, path: p};\n-                    *sc.invalid = list::cons(inv, @*sc.invalid);\n+                    *sc.invalid = @list::cons(inv, *sc.invalid);\n                 }\n             }\n         } else if b.node_id == my_defnum {\n@@ -418,7 +418,7 @@ fn check_lval(cx: @ctx, dest: @ast::expr, sc: scope, v: vt<scope>) {\n             if b.root_var == some(dnum) {\n                 let inv = @{reason: overwritten, node_id: b.node_id,\n                             sp: dest.span, path: p};\n-                *sc.invalid = list::cons(inv, @*sc.invalid);\n+                *sc.invalid = @list::cons(inv, *sc.invalid);\n             }\n         }\n       }\n@@ -791,46 +791,43 @@ fn unsafe_set(from: option<unsafe_ty>) -> [unsafe_ty] {\n     alt from { some(t) { [t] } _ { [] } }\n }\n \n-fn find_invalid(id: node_id, lst: list<@invalid>)\n-    -> option<@invalid> {\n+fn find_invalid(id: node_id, lst: @list<@invalid>) -> option<@invalid> {\n     let mut cur = lst;\n     loop {\n-        alt cur {\n+        alt *cur {\n           list::nil { ret none; }\n           list::cons(head, tail) {\n             if head.node_id == id { ret some(head); }\n-            cur = *tail;\n+            cur = tail;\n           }\n         }\n     };\n }\n \n-fn join_invalid(a: list<@invalid>, b: list<@invalid>) -> list<@invalid> {\n+fn join_invalid(a: @list<@invalid>, b: @list<@invalid>) -> @list<@invalid> {\n     let mut result = a;\n     list::iter(b) {|elt|\n         let mut found = false;\n         list::iter(a) {|e| if e == elt { found = true; } }\n-        if !found { result = list::cons(elt, @result); }\n+        if !found { result = @list::cons(elt, result); }\n     }\n     result\n }\n \n-fn filter_invalid(src: list<@invalid>, bs: [binding]) -> list<@invalid> {\n-    let mut out = list::nil, cur = src;\n-    while cur != list::nil {\n-        alt cur {\n+fn filter_invalid(src: @list<@invalid>, bs: [binding]) -> @list<@invalid> {\n+    let mut out = @list::nil, cur = src;\n+    loop {\n+        alt *cur {\n           list::cons(head, tail) {\n             let p = vec::position(bs, {|b| b.node_id == head.node_id});\n-            if !is_none(p) { out = list::cons(head, @out); }\n-            cur = *tail;\n+            if !is_none(p) { out = @list::cons(head, out); }\n+            cur = tail;\n           }\n           list::nil {\n-            // typestate would help...\n-            unreachable();\n+            ret out;\n           }\n         }\n     }\n-    ret out;\n }\n \n fn err(cx: ctx, sp: span, err: str) {"}, {"sha": "0c49196a0cde7116103875da807f2c90f90c8bc1", "filename": "src/rustc/middle/last_use.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flast_use.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -37,7 +37,7 @@ enum seen { unset, seen(node_id), }\n enum block_type { func, lp, }\n \n enum use { var_use(node_id), close_over(node_id), }\n-type set = [{def: node_id, uses: list<use>}];\n+type set = [{def: node_id, uses: @list<use>}];\n type bl = @{type: block_type, mut second: bool, mut exits: [set]};\n \n enum use_id { path(node_id), close(node_id, node_id) }\n@@ -52,7 +52,7 @@ type ctx = {last_uses: std::map::hashmap<use_id, bool>,\n             tcx: ty::ctxt,\n             // The current set of local last uses\n             mut current: set,\n-            mut blocks: list<bl>};\n+            mut blocks: @list<bl>};\n \n fn find_last_uses(c: @crate, def_map: resolve::def_map,\n                   ref_map: alias::ref_map, tcx: ty::ctxt)\n@@ -67,7 +67,7 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map,\n               ref_map: ref_map,\n               tcx: tcx,\n               mut current: [],\n-              mut blocks: nil};\n+              mut blocks: @nil};\n     visit::visit_crate(*c, cx, v);\n     let mini_table = std::map::int_hash();\n     for cx.last_uses.each {|key, val|\n@@ -136,7 +136,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n             option::iter(def_is_owned_local(cx, my_def)) {|nid|\n                 clear_in_current(cx, nid, false);\n                 cx.current += [{def: nid,\n-                                uses: cons(var_use(ex.id), @nil)}];\n+                                uses: @cons(var_use(ex.id), @nil)}];\n             }\n           }\n         }\n@@ -249,13 +249,13 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n                 option::iter(def_is_owned_local(cx, v.def)) {|nid|\n                     clear_in_current(cx, nid, false);\n                     cx.current += [{def: nid,\n-                                    uses: cons(close_over(id), @nil)}];\n+                                    uses: @cons(close_over(id), @nil)}];\n                 }\n             }\n           }\n           _ {}\n         }\n-        let mut old_cur = [], old_blocks = nil;\n+        let mut old_cur = [], old_blocks = @nil;\n         cx.blocks <-> old_blocks;\n         cx.current <-> old_cur;\n         visit::visit_fn(fk, decl, body, sp, id, cx, v);\n@@ -268,7 +268,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n \n fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n     let local = @{type: tp, mut second: false, mut exits: []};\n-    cx.blocks = cons(local, @cx.blocks);\n+    cx.blocks = @cons(local, cx.blocks);\n     visit();\n     local.second = true;\n     local.exits = [];\n@@ -281,23 +281,20 @@ fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n \n fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n     let mut cur = cx.blocks;\n-    while cur != nil {\n-        alt cur {\n+    loop {\n+        alt *cur {\n           cons(b, tail) {\n             if (b.type == tp) {\n                 if !b.second { b.exits += [cx.current]; }\n                 ret true;\n             }\n-            cur = *tail;\n+            cur = tail;\n           }\n           nil {\n-            // typestate can't use the while loop condition --\n-            // *sigh*\n-            unreachable();\n+            ret false;\n           }\n         }\n     }\n-    ret false;\n }\n \n fn join_branches(branches: [set]) -> set {\n@@ -312,7 +309,7 @@ fn join_branches(branches: [set]) -> set {\n                     for vec::each(branches[j]) {|elt2|\n                         if elt2.def == elt.def {\n                             list::iter(elt2.uses) {|e|\n-                                if !list::has(nne, e) { nne = cons(e, @nne); }\n+                                if !list::has(nne, e) { nne = @cons(e, nne); }\n                             }\n                         }\n                     }"}, {"sha": "a1f955326d063cd8ed6954cb4493673fec3b7a60", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -42,10 +42,10 @@ enum scope {\n     scope_method(node_id, [ast::ty_param]),\n }\n \n-type scopes = list<scope>;\n+type scopes = @list<scope>;\n \n fn top_scope() -> scopes {\n-    cons(scope_crate, @cons(scope_toplevel, @nil))\n+    @cons(scope_crate, @cons(scope_toplevel, @nil))\n }\n \n enum import_state {\n@@ -91,7 +91,7 @@ enum mod_index_entry {\n                     node_id, span),\n }\n \n-type mod_index = hashmap<ident, list<mod_index_entry>>;\n+type mod_index = hashmap<ident, @list<mod_index_entry>>;\n \n // A tuple of an imported def and the view_path from its originating import\n type glob_imp_def = {def: def, path: @ast::view_path};\n@@ -229,7 +229,7 @@ fn iter_effective_import_paths(vi: ast::view_item,\n // resolve through them.\n fn map_crate(e: @env, c: @ast::crate) {\n \n-    fn index_vi(e: @env, i: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n+    fn index_vi(e: @env, i: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n         iter_effective_import_paths(*i) { |vp|\n             alt vp.node {\n               ast::view_path_simple(name, path, id) {\n@@ -262,7 +262,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n         path\n     }\n \n-    fn index_i(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n+    fn index_i(e: @env, i: @ast::item, &&sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(e, i, sc, v);\n         alt i.node {\n           ast::item_mod(md) {\n@@ -291,7 +291,7 @@ fn map_crate(e: @env, c: @ast::crate) {\n     // re-export of anything that was exported at the glob-target location.\n     // So we wind up reusing the glob-import machinery when looking at\n     // glob exports. They just do re-exporting in a later step.\n-    fn link_glob(e: @env, vi: @ast::view_item, sc: scopes, _v: vt<scopes>) {\n+    fn link_glob(e: @env, vi: @ast::view_item, &&sc: scopes, _v: vt<scopes>) {\n         iter_effective_import_paths(*vi) { |vp|\n             alt vp.node {\n               ast::view_path_glob(path, _) {\n@@ -429,7 +429,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n     e.used_imports.track = false;\n     e.sess.abort_if_errors();\n \n-    fn walk_item(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n+    fn walk_item(e: @env, i: @ast::item, &&sc: scopes, v: vt<scopes>) {\n         visit_item_with_scope(e, i, sc, v);\n         alt i.node {\n           /* At this point, the code knows what ifaces the iface refs\n@@ -447,7 +447,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         }\n     }\n \n-    fn walk_expr(e: @env, exp: @ast::expr, sc: scopes, v: vt<scopes>) {\n+    fn walk_expr(e: @env, exp: @ast::expr, &&sc: scopes, v: vt<scopes>) {\n         visit::visit_expr(exp, sc, v);\n         alt exp.node {\n           ast::expr_path(p) {\n@@ -463,7 +463,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           _ { }\n         }\n     }\n-    fn walk_ty(e: @env, t: @ast::ty, sc: scopes, v: vt<scopes>) {\n+    fn walk_ty(e: @env, t: @ast::ty, &&sc: scopes, v: vt<scopes>) {\n         visit::visit_ty(t, sc, v);\n         alt t.node {\n           ast::ty_path(p, id) {\n@@ -473,7 +473,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           _ { }\n         }\n     }\n-    fn walk_tps(e: @env, tps: [ast::ty_param], sc: scopes, v: vt<scopes>) {\n+    fn walk_tps(e: @env, tps: [ast::ty_param], &&sc: scopes, v: vt<scopes>) {\n         let outer_current_tp = e.current_tp;\n         let mut current = 0u;\n         for tps.each {|tp|\n@@ -488,11 +488,11 @@ fn resolve_names(e: @env, c: @ast::crate) {\n         }\n         e.current_tp = outer_current_tp;\n     }\n-    fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id, sc: scopes,\n-                   _v: vt<scopes>) {\n+    fn walk_constr(e: @env, p: @ast::path, sp: span, id: node_id,\n+                   &&sc: scopes, _v: vt<scopes>) {\n         maybe_insert(e, id, lookup_path_strict(*e, sc, sp, p, ns_val));\n     }\n-    fn walk_pat(e: @env, pat: @ast::pat, sc: scopes, v: vt<scopes>) {\n+    fn walk_pat(e: @env, pat: @ast::pat, &&sc: scopes, v: vt<scopes>) {\n         visit::visit_pat(pat, sc, v);\n         alt pat.node {\n           ast::pat_enum(p, _) {\n@@ -534,7 +534,8 @@ fn resolve_names(e: @env, c: @ast::crate) {\n   This is used in more than one context, thus should only call generic\n   visit methods. Called both from map_crate and resolve_names.\n  */\n-fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n+fn visit_item_with_scope(e: @env, i: @ast::item,\n+                         &&sc: scopes, v: vt<scopes>) {\n     // Some magic here. Items with the !resolve_unexported attribute\n     // cause us to consider every name to be exported when resolving their\n     // contents. This is used to allow the test runner to run unexported\n@@ -544,34 +545,34 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         attr::contains_name(attr::attr_metas(i.attrs),\n                             \"!resolve_unexported\");\n \n-    let sc = cons(scope_item(i), @sc);\n+    let sc = @cons(scope_item(i), sc);\n     alt i.node {\n       ast::item_impl(tps, _, ifce, sty, methods) {\n         visit::visit_ty_params(tps, sc, v);\n         option::iter(ifce) {|p| visit::visit_path(p.path, sc, v)};\n         v.visit_ty(sty, sc, v);\n         for methods.each {|m|\n             v.visit_ty_params(m.tps, sc, v);\n-            let msc = cons(scope_method(m.self_id, tps + m.tps), @sc);\n+            let msc = @cons(scope_method(m.self_id, tps + m.tps), sc);\n             v.visit_fn(visit::fk_method(m.ident, [], m),\n                        m.decl, m.body, m.span, m.id, msc, v);\n         }\n       }\n       ast::item_iface(tps, _, methods) {\n         visit::visit_ty_params(tps, sc, v);\n         for methods.each {|m|\n-            let msc = cons(scope_method(i.id, tps + m.tps), @sc);\n+            let msc = @cons(scope_method(i.id, tps + m.tps), sc);\n             for m.decl.inputs.each {|a| v.visit_ty(a.ty, msc, v); }\n             v.visit_ty(m.decl.output, msc, v);\n         }\n       }\n       ast::item_class(tps, ifaces, members, ctor, m_dtor, _) {\n         visit::visit_ty_params(tps, sc, v);\n         // Can maybe skip this now that we require self on class fields\n-        let class_scope = cons(scope_item(i), @sc);\n+        let class_scope = @cons(scope_item(i), sc);\n         /* visit the constructor... */\n-        let ctor_scope = cons(scope_method(ctor.node.self_id, tps),\n-                              @class_scope);\n+        let ctor_scope = @cons(scope_method(ctor.node.self_id, tps),\n+                               class_scope);\n         /* visit the iface refs in the class scope */\n         for ifaces.each {|p|\n             visit::visit_path(p.path, class_scope, v);\n@@ -581,8 +582,8 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n                             ctor.node.body, ctor.span, ctor.node.id,\n                             ctor_scope, v);\n         option::iter(m_dtor) {|dtor|\n-          let dtor_scope = cons(scope_method(dtor.node.self_id, tps),\n-                              @class_scope);\n+          let dtor_scope = @cons(scope_method(dtor.node.self_id, tps),\n+                                 class_scope);\n \n           visit_fn_with_scope(e, visit::fk_dtor(tps, dtor.node.self_id,\n                                                 local_def(i.id)),\n@@ -594,8 +595,8 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n         for members.each {|cm|\n             alt cm.node {\n               class_method(m) {\n-                  let msc = cons(scope_method(m.self_id, tps + m.tps),\n-                                 @class_scope);\n+                  let msc = @cons(scope_method(m.self_id, tps + m.tps),\n+                                  class_scope);\n                   visit_fn_with_scope(e,\n                      visit::fk_item_fn(m.ident, tps), m.decl, m.body,\n                                  m.span, m.id, msc, v); }\n@@ -609,14 +610,14 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n     e.resolve_unexported = old_resolve_unexported;\n }\n \n-fn visit_native_item_with_scope(ni: @ast::native_item, sc: scopes,\n+fn visit_native_item_with_scope(ni: @ast::native_item, &&sc: scopes,\n                                 v: vt<scopes>) {\n-    visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n+    visit::visit_native_item(ni, @cons(scope_native_item(ni), sc), v);\n }\n \n fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n                        body: ast::blk, sp: span,\n-                       id: node_id, sc: scopes, v: vt<scopes>) {\n+                       id: node_id, &&sc: scopes, v: vt<scopes>) {\n     // is this a main fn declaration?\n     alt fk {\n       visit::fk_item_fn(nm, _) {\n@@ -644,12 +645,12 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n         scope_fn_expr(decl, id, []) }\n     };\n \n-    visit::visit_fn(fk, decl, body, sp, id, cons(scope, @sc), v);\n+    visit::visit_fn(fk, decl, body, sp, id, @cons(scope, sc), v);\n }\n \n-fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n+fn visit_block_with_scope(b: ast::blk, &&sc: scopes, v: vt<scopes>) {\n     let pos = @mut 0u, loc = @mut 0u;\n-    let block_sc = cons(scope_block(b, pos, loc), @sc);\n+    let block_sc = @cons(scope_block(b, pos, loc), sc);\n     for b.node.view_items.each {|vi| v.visit_view_item(vi, block_sc, v); }\n     for b.node.stmts.each {|stmt|\n         v.visit_stmt(stmt, block_sc, v);;\n@@ -659,7 +660,7 @@ fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {\n     visit::visit_expr_opt(b.node.expr, block_sc, v);\n }\n \n-fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n+fn visit_decl_with_scope(d: @decl, &&sc: scopes, v: vt<scopes>) {\n     let loc_pos = alt list::head(sc) {\n       scope_block(_, _, pos) { pos }\n       _ { @mut 0u }\n@@ -672,9 +673,9 @@ fn visit_decl_with_scope(d: @decl, sc: scopes, v: vt<scopes>) {\n     }\n }\n \n-fn visit_arm_with_scope(a: ast::arm, sc: scopes, v: vt<scopes>) {\n+fn visit_arm_with_scope(a: ast::arm, &&sc: scopes, v: vt<scopes>) {\n     for a.pats.each {|p| v.visit_pat(p, sc, v); }\n-    let sc_inner = cons(scope_arm(a), @sc);\n+    let sc_inner = @cons(scope_arm(a), sc);\n     visit::visit_expr_opt(a.guard, sc_inner, v);\n     v.visit_block(a.body, sc_inner, v);\n }\n@@ -709,7 +710,7 @@ fn visit_local_with_scope(e: @env, loc: @local, &&sc: scopes, v:vt<scopes>) {\n }\n \n \n-fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n+fn follow_import(e: env, &&sc: scopes, path: [ident], sp: span) ->\n    option<def> {\n     let path_len = vec::len(path);\n     let mut dcur = lookup_in_scope_strict(e, sc, sp, path[0], ns_module);\n@@ -738,7 +739,7 @@ fn follow_import(e: env, sc: scopes, path: [ident], sp: span) ->\n     } else { ret none; }\n }\n \n-fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n+fn resolve_constr(e: @env, c: @ast::constr, &&sc: scopes, _v: vt<scopes>) {\n     alt lookup_path_strict(*e, sc, c.span, c.node.path, ns_val) {\n        some(d@ast::def_fn(_,ast::pure_fn)) {\n          e.def_map.insert(c.node.id, d);\n@@ -753,7 +754,7 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n \n // Import resolution\n fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n-                  ids: [ast::ident], sp: codemap::span, sc: scopes) {\n+                  ids: [ast::ident], sp: codemap::span, &&sc: scopes) {\n     fn register(e: env, id: node_id, cx: ctxt, sp: codemap::span,\n                 name: ast::ident, lookup: fn(namespace) -> option<def>,\n                 impls: [@_impl]) {\n@@ -768,7 +769,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n     }\n     // Temporarily disable this import and the imports coming after during\n     // resolution of this import.\n-    fn find_imports_after(e: env, id: node_id, sc: scopes) -> [node_id] {\n+    fn find_imports_after(e: env, id: node_id, &&sc: scopes) -> [node_id] {\n         fn lst(my_id: node_id, vis: [@view_item]) -> [node_id] {\n             let mut imports = [], found = false;\n             for vis.each {|vi|\n@@ -790,7 +791,7 @@ fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n             }\n             imports\n         }\n-        alt sc {\n+        alt *sc {\n           cons(scope_item(@{node: item_mod(m), _}), _) {\n             lst(id, m.view_items)\n           }\n@@ -922,7 +923,7 @@ fn mk_unresolved_msg(id: ident, kind: str) -> str {\n }\n \n // Lookup helpers\n-fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: @ast::path,\n+fn lookup_path_strict(e: env, &&sc: scopes, sp: span, pth: @ast::path,\n                       ns: namespace) -> option<def> {\n     let n_idents = vec::len(pth.idents);\n     let headns = if n_idents == 1u { ns } else { ns_module };\n@@ -951,7 +952,7 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: @ast::path,\n     }\n }\n \n-fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n+fn lookup_in_scope_strict(e: env, &&sc: scopes, sp: span, name: ident,\n                           ns: namespace) -> option<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns, true) {\n       none {\n@@ -998,7 +999,7 @@ fn def_is_ty_arg(d: def) -> bool {\n     ret alt d { ast::def_ty_param(_, _) { true } _ { false } };\n }\n \n-fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n+fn lookup_in_scope(e: env, &&sc: scopes, sp: span, name: ident, ns: namespace,\n                    check_capture: bool) -> option<def> {\n \n     fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n@@ -1113,7 +1114,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n     let mut left_fn_level2 = false;\n     let mut sc = sc;\n     loop {\n-        alt copy sc {\n+        alt *sc {\n           nil { ret none; }\n           cons(hd, tl) {\n               alt in_scope(e, sp, name, hd, ns) {\n@@ -1152,7 +1153,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace,\n                   _ { }\n                 }\n             }\n-            sc = *tl;\n+            sc = tl;\n         }\n       }\n     };\n@@ -1450,15 +1451,15 @@ fn is_exported(e: env, i: ident, m: @indexed_mod) -> bool {\n // A list search function. Applies `f` to each element of `v`, starting from\n // the first. When `f` returns `some(x)`, `list_search` returns `some(x)`. If\n // `f` returns `none` for every element, `list_search` returns `none`.\n-fn list_search<T: copy, U: copy>(ls: list<T>, f: fn(T) -> option<U>)\n+fn list_search<T: copy, U: copy>(ls: @list<T>, f: fn(T) -> option<U>)\n         -> option<U> {\n     let mut ls = ls;\n     loop {\n-        ls = alt ls {\n+        ls = alt *ls {\n           cons(hd, tl) {\n             let result = f(hd);\n             if !is_none(result) { ret result; }\n-            *tl\n+            tl\n           }\n           nil { ret none; }\n         };\n@@ -1585,16 +1586,16 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n \n \n // Module indexing\n-fn add_to_index(index: hashmap<ident, list<mod_index_entry>>, id: ident,\n+fn add_to_index(index: hashmap<ident, @list<mod_index_entry>>, id: ident,\n                 ent: mod_index_entry) {\n     alt index.find(id) {\n-      none { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n-      some(prev) { index.insert(id, cons(ent, @prev)); }\n+      none { index.insert(id, @cons(ent, @nil)); }\n+      some(prev) { index.insert(id, @cons(ent, prev)); }\n     }\n }\n \n fn index_view_items(view_items: [@ast::view_item],\n-                    index: hashmap<ident, list<mod_index_entry>>) {\n+                    index: hashmap<ident, @list<mod_index_entry>>) {\n     for view_items.each {|vi|\n         alt vi.node {\n           ast::view_item_use(ident, _, id) {\n@@ -1624,7 +1625,7 @@ fn index_view_items(view_items: [@ast::view_item],\n }\n \n fn index_mod(md: ast::_mod) -> mod_index {\n-    let index = str_hash::<list<mod_index_entry>>();\n+    let index = str_hash::<@list<mod_index_entry>>();\n \n     index_view_items(md.view_items, index);\n \n@@ -1664,7 +1665,7 @@ fn index_mod(md: ast::_mod) -> mod_index {\n \n \n fn index_nmod(md: ast::native_mod) -> mod_index {\n-    let index = str_hash::<list<mod_index_entry>>();\n+    let index = str_hash::<@list<mod_index_entry>>();\n \n     index_view_items(md.view_items, index);\n \n@@ -1718,7 +1719,7 @@ fn check_for_collisions(e: @env, c: ast::crate) {\n     visit::visit_crate(c, (), visit::mk_vt(v));\n }\n \n-fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n+fn check_mod_name(e: env, name: ident, entries: @list<mod_index_entry>) {\n     let mut saw_mod = false;\n     let mut saw_type = false;\n     let mut saw_value = false;\n@@ -1727,7 +1728,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n         e.sess.span_fatal(sp, \"duplicate definition of \" + word + name);\n     }\n     loop {\n-        alt entries {\n+        alt *entries {\n           cons(entry, rest) {\n             if !is_none(lookup_in_mie(e, entry, ns_val)) {\n                 if saw_value {\n@@ -1744,7 +1745,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n                     dup(e, mie_span(entry), \"module \", name);\n                 } else { saw_mod = true; }\n             }\n-            entries = *rest;\n+            entries = rest;\n           }\n           nil { break; }\n         }\n@@ -2149,10 +2150,10 @@ type method_info = {did: def_id, n_tps: uint, ident: ast::ident};\n    * methods: the item's methods\n */\n type _impl = {did: def_id, ident: ast::ident, methods: [@method_info]};\n-type iscopes = list<@[@_impl]>;\n+type iscopes = @list<@[@_impl]>;\n \n fn resolve_impls(e: @env, c: @ast::crate) {\n-    visit::visit_crate(*c, nil, visit::mk_vt(@{\n+    visit::visit_crate(*c, @nil, visit::mk_vt(@{\n         visit_block: bind visit_block_with_impl_scope(e, _, _, _),\n         visit_mod: bind visit_mod_with_impl_scope(e, _, _, _, _, _),\n         visit_expr: bind resolve_impl_in_expr(e, _, _, _)\n@@ -2310,7 +2311,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n     }\n }\n \n-fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n+fn visit_block_with_impl_scope(e: @env, b: ast::blk, &&sc: iscopes,\n                                v: vt<iscopes>) {\n     let mut impls = [];\n     for b.node.view_items.each {|vi|\n@@ -2324,27 +2325,28 @@ fn visit_block_with_impl_scope(e: @env, b: ast::blk, sc: iscopes,\n           _ {}\n         }\n     }\n-    let sc = if vec::len(impls) > 0u { cons(@impls, @sc) } else { sc };\n+    let sc = if vec::len(impls) > 0u { @cons(@impls, sc) } else { sc };\n     visit::visit_block(b, sc, v);\n }\n \n fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, id: node_id,\n-                             sc: iscopes, v: vt<iscopes>) {\n+                             &&sc: iscopes, v: vt<iscopes>) {\n     let mut impls = [];\n     for m.view_items.each {|vi|\n         find_impls_in_view_item(*e, vi, impls, some(sc));\n     }\n     for m.items.each {|i| find_impls_in_item(*e, i, impls, none, none); }\n     let impls = @impls;\n     visit::visit_mod(m, s, id, if vec::len(*impls) > 0u {\n-                                   cons(impls, @sc)\n+                                   @cons(impls, sc)\n                                } else {\n                                    sc\n                                }, v);\n-    e.impl_map.insert(id, cons(impls, @nil));\n+    e.impl_map.insert(id, @cons(impls, @nil));\n }\n \n-fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n+fn resolve_impl_in_expr(e: @env, x: @ast::expr,\n+                        &&sc: iscopes, v: vt<iscopes>) {\n     alt x.node {\n       // Store the visible impls in all exprs that might need them\n       ast::expr_field(_, _, _) | ast::expr_path(_) | ast::expr_cast(_, _) |"}, {"sha": "56240abbfaae1203c8e5e9ede019ffde9317dd59", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -5267,7 +5267,7 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n \n     fn impl_map(cx: @crate_ctxt,\n                 id: ast::node_id) -> [(ast::ident, ast::def_id)] {\n-        alt cx.maps.impl_map.get(id) {\n+        alt *cx.maps.impl_map.get(id) {\n           list::cons(impls, @list::nil) {\n             (*impls).map {|i|\n                 (i.ident, i.did)"}, {"sha": "8511a260d0bac88e7f01c2ac8c1dd08f85b16394", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -19,6 +19,7 @@\n \n import std::map::hashmap;\n import std::list;\n+import std::list::{list, cons, nil};\n import driver::session::session;\n import metadata::csearch;\n import syntax::ast::*, syntax::ast_util, syntax::visit;\n@@ -98,19 +99,19 @@ fn type_needs(cx: ctx, use: uint, ty: ty::t) {\n     let mut done = true;\n     // Optimization -- don't descend type if all params already have this use\n     for vec::each(cx.uses) {|u| if u & use != use { done = false } }\n-    if !done { type_needs_inner(cx, use, ty, list::nil); }\n+    if !done { type_needs_inner(cx, use, ty, @nil); }\n }\n \n fn type_needs_inner(cx: ctx, use: uint, ty: ty::t,\n-                    enums_seen: list::list<def_id>) {\n+                    enums_seen: @list<def_id>) {\n     ty::maybe_walk_ty(ty) {|ty|\n         if ty::type_has_params(ty) {\n             alt ty::get(ty).struct {\n               ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _) |\n               ty::ty_box(_) | ty::ty_iface(_, _) { false }\n               ty::ty_enum(did, substs) {\n                 if option::is_none(list::find(enums_seen, {|id| id == did})) {\n-                    let seen = list::cons(did, @enums_seen);\n+                    let seen = @cons(did, enums_seen);\n                     for vec::each(*ty::enum_variants(cx.ccx.tcx, did)) {|v|\n                         for vec::each(v.args) {|aty|\n                             let t = ty::subst(cx.ccx.tcx, substs, aty);"}, {"sha": "deb2ecd5c15fbe75e32902a2718884af2ada2dc6", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -105,7 +105,7 @@ impl methods for isr_alist {\n     }\n \n     fn find(br: ty::bound_region) -> option<ty::region> {\n-        for list::each(*self) { |isr|\n+        for list::each(self) { |isr|\n             let (isr_br, isr_r) = isr;\n             if isr_br == br { ret some(isr_r); }\n         }"}, {"sha": "e1c361bfb0f51bdd834d80db47f71c5d6cfba9b6", "filename": "src/rustdoc/reexport_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustdoc%2Freexport_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Frustdoc%2Freexport_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Freexport_pass.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -271,7 +271,7 @@ fn for_each_reexported_impl(\n         mod_id: ast::node_id\n     ) {\n         let all_impls = all_impls(m);\n-        alt check ctxt.impl_map.get(mod_id) {\n+        alt check *ctxt.impl_map.get(mod_id) {\n           list::cons(impls, @list::nil) {\n             for vec::each(*impls) {|i|\n                 // This impl is not an item in the current mod"}, {"sha": "c6c1b44df487d6be169988cfab6e98bde1ad2fe1", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -12,7 +12,7 @@ fn check_log<T>(exp: str, v: T) {\n \n fn main() {\n     let x = list::from_vec([a(22u), b(\"hi\")]);\n-    let exp = \"cons(a(22), @cons(b(\\\"hi\\\"), @nil))\";\n+    let exp = \"@cons(a(22), @cons(b(\\\"hi\\\"), @nil))\";\n     assert #fmt[\"%?\", x] == exp;\n     check_log(exp, x);\n }"}, {"sha": "86a06ab5aa5100c6e964fa72b651675a4b22102e", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -2,25 +2,25 @@ use std;\n \n import std::list::*;\n \n-pure fn pure_length_go<T: copy>(ls: list<T>, acc: uint) -> uint {\n-    alt ls { nil { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n+pure fn pure_length_go<T: copy>(ls: @list<T>, acc: uint) -> uint {\n+    alt *ls { nil { acc } cons(_, tl) { pure_length_go(tl, acc + 1u) } }\n }\n \n-pure fn pure_length<T: copy>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }\n+pure fn pure_length<T: copy>(ls: @list<T>) -> uint { pure_length_go(ls, 0u) }\n \n-pure fn nonempty_list<T: copy>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T: copy>(ls: @list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"enum refinement\", if we implement those.\n-fn safe_head<T: copy>(ls: list<T>) : nonempty_list(ls) -> T {\n+fn safe_head<T: copy>(ls: @list<T>) : nonempty_list(ls) -> T {\n     check is_not_empty(ls);\n     ret head(ls);\n }\n \n fn main() {\n-    let mylist = cons(@1u, @nil);\n+    let mylist = @cons(@1u, @nil);\n     // Again, a way to eliminate such \"obvious\" checks seems\n     // desirable. (Tags could have postconditions.)\n     check (nonempty_list(mylist));"}, {"sha": "157a7aca6eaf98b5e5f0134ae397d9d2369948ec", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34b42eeb657dfe051ebaf0f95ba5a428441b04af/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=34b42eeb657dfe051ebaf0f95ba5a428441b04af", "patch": "@@ -7,33 +7,33 @@ import std::list::*;\n \n // Can't easily be written as a \"pure fn\" because there's\n // no syntax for specifying that f is pure.\n-fn pure_foldl<T: copy, U: copy>(ls: list<T>, u: U, f: fn(T, U) -> U) -> U {\n-    alt ls {\n+fn pure_foldl<T: copy, U: copy>(ls: @list<T>, u: U, f: fn(T, U) -> U) -> U {\n+    alt *ls {\n         nil { u }\n-        cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n+        cons(hd, tl) { f(hd, pure_foldl(tl, f(hd, u), f)) }\n     }\n }\n \n // Shows how to use an \"unchecked\" block to call a general\n // fn from a pure fn\n-pure fn pure_length<T: copy>(ls: list<T>) -> uint {\n+pure fn pure_length<T: copy>(ls: @list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n     unchecked{ pure_foldl(ls, 0u, count(_, _)) }\n }\n \n-pure fn nonempty_list<T: copy>(ls: list<T>) -> bool { pure_length(ls) > 0u }\n+pure fn nonempty_list<T: copy>(ls: @list<T>) -> bool { pure_length(ls) > 0u }\n \n // Of course, the compiler can't take advantage of the\n // knowledge that ls is a cons node. Future work.\n // Also, this is pretty contrived since nonempty_list\n // could be a \"enum refinement\", if we implement those.\n-fn safe_head<T: copy>(ls: list<T>) : nonempty_list(ls) -> T {\n+fn safe_head<T: copy>(ls: @list<T>) : nonempty_list(ls) -> T {\n     check is_not_empty(ls);\n     ret head(ls)\n }\n \n fn main() {\n-    let mylist = cons(@1u, @nil);\n+    let mylist = @cons(@1u, @nil);\n     // Again, a way to eliminate such \"obvious\" checks seems\n     // desirable. (Tags could have postconditions.)\n     check (nonempty_list(mylist));"}]}