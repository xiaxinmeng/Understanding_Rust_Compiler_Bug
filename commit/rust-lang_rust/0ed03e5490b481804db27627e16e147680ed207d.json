{"sha": "0ed03e5490b481804db27627e16e147680ed207d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZDAzZTU0OTBiNDgxODA0ZGIyNzYyN2UxNmUxNDc2ODBlZDIwN2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T03:00:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-13T03:00:20Z"}, "message": "Auto merge of #43348 - kennytm:fix-24658-doc-every-platform, r=alexcrichton\n\nExpose all OS-specific modules in libstd doc.\n\n1. Uses the special `--cfg dox` configuration passed by rustbuild when running `rustdoc`. Changes the `#[cfg(platform)]` into `#[cfg(any(dox, platform))]` so that platform-specific API are visible to rustdoc.\n\n2. Since platform-specific implementations often won't compile correctly on other platforms, `rustdoc` is changed to apply `everybody_loops` to the functions during documentation and doc-test harness.\n\n3. Since platform-specific code are documented on all platforms now, it could confuse users who found a useful API but is non-portable. Also, their examples will be doc-tested, so must be excluded when not testing on the native platform. An undocumented attribute `#[doc(cfg(...))]` is introduced to serve the above purposed.\n\nFixes #24658 (Does _not_ fully implement #1998).", "tree": {"sha": "44a0874cff604868f309f50a2de1e9e13876d816", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44a0874cff604868f309f50a2de1e9e13876d816"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ed03e5490b481804db27627e16e147680ed207d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ed03e5490b481804db27627e16e147680ed207d", "html_url": "https://github.com/rust-lang/rust/commit/0ed03e5490b481804db27627e16e147680ed207d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ed03e5490b481804db27627e16e147680ed207d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14fb329e0a691f04308d0a006d8e744595e8c8dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/14fb329e0a691f04308d0a006d8e744595e8c8dc", "html_url": "https://github.com/rust-lang/rust/commit/14fb329e0a691f04308d0a006d8e744595e8c8dc"}, {"sha": "3093bb85f94e6f3c4707674c8b70c28ecfbf3bf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3093bb85f94e6f3c4707674c8b70c28ecfbf3bf9", "html_url": "https://github.com/rust-lang/rust/commit/3093bb85f94e6f3c4707674c8b70c28ecfbf3bf9"}], "stats": {"total": 1336, "additions": 1261, "deletions": 75}, "files": [{"sha": "ddc538e12144ac5ff5a2d692d5aba400c4ca3843", "filename": "src/doc/unstable-book/src/language-features/doc-cfg.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -0,0 +1,42 @@\n+# `doc_cfg`\n+\n+The tracking issue for this feature is: [#43781]\n+\n+------\n+\n+The `doc_cfg` feature allows an API be documented as only available in some specific platforms.\n+This attribute has two effects:\n+\n+1. In the annotated item's documentation, there will be a message saying \"This is supported on\n+    (platform) only\".\n+\n+2. The item's doc-tests will only run on the specific platform.\n+\n+This feature was introduced as part of PR [#43348] to allow the platform-specific parts of the\n+standard library be documented.\n+\n+```rust\n+#![feature(doc_cfg)]\n+\n+#[cfg(any(windows, feature = \"documentation\"))]\n+#[doc(cfg(windows))]\n+/// The application's icon in the notification area (a.k.a. system tray).\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// extern crate my_awesome_ui_library;\n+/// use my_awesome_ui_library::current_app;\n+/// use my_awesome_ui_library::windows::notification;\n+///\n+/// let icon = current_app().get::<notification::Icon>();\n+/// icon.show();\n+/// icon.show_message(\"Hello\");\n+/// ```\n+pub struct Icon {\n+    // ...\n+}\n+```\n+\n+[#43781]: https://github.com/rust-lang/rust/issues/43781\n+[#43348]: https://github.com/rust-lang/rust/issues/43348\n\\ No newline at end of file"}, {"sha": "ef6a4b209290129ebecbc17e0cfbe9eb14a0387f", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -44,6 +44,7 @@ use std::io::{self, Write};\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n+use std::mem;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n@@ -618,52 +619,53 @@ impl UserIdentifiedItem {\n     }\n }\n \n-struct ReplaceBodyWithLoop {\n+// Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n+pub struct ReplaceBodyWithLoop {\n     within_static_or_const: bool,\n }\n \n impl ReplaceBodyWithLoop {\n-    fn new() -> ReplaceBodyWithLoop {\n+    pub fn new() -> ReplaceBodyWithLoop {\n         ReplaceBodyWithLoop { within_static_or_const: false }\n     }\n+\n+    fn run<R, F: FnOnce(&mut Self) -> R>(&mut self, is_const: bool, action: F) -> R {\n+        let old_const = mem::replace(&mut self.within_static_or_const, is_const);\n+        let ret = action(self);\n+        self.within_static_or_const = old_const;\n+        ret\n+    }\n }\n \n impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n-        match i {\n-            ast::ItemKind::Static(..) |\n-            ast::ItemKind::Const(..) => {\n-                self.within_static_or_const = true;\n-                let ret = fold::noop_fold_item_kind(i, self);\n-                self.within_static_or_const = false;\n-                return ret;\n-            }\n-            _ => fold::noop_fold_item_kind(i, self),\n-        }\n+        let is_const = match i {\n+            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n+            ast::ItemKind::Fn(_, _, ref constness, _, _, _) =>\n+                constness.node == ast::Constness::Const,\n+            _ => false,\n+        };\n+        self.run(is_const, |s| fold::noop_fold_item_kind(i, s))\n     }\n \n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        match i.node {\n-            ast::TraitItemKind::Const(..) => {\n-                self.within_static_or_const = true;\n-                let ret = fold::noop_fold_trait_item(i, self);\n-                self.within_static_or_const = false;\n-                return ret;\n-            }\n-            _ => fold::noop_fold_trait_item(i, self),\n-        }\n+        let is_const = match i.node {\n+            ast::TraitItemKind::Const(..) => true,\n+            ast::TraitItemKind::Method(ast::MethodSig { ref constness, .. }, _) =>\n+                constness.node == ast::Constness::Const,\n+            _ => false,\n+        };\n+        self.run(is_const, |s| fold::noop_fold_trait_item(i, s))\n     }\n \n     fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        match i.node {\n-            ast::ImplItemKind::Const(..) => {\n-                self.within_static_or_const = true;\n-                let ret = fold::noop_fold_impl_item(i, self);\n-                self.within_static_or_const = false;\n-                return ret;\n-            }\n-            _ => fold::noop_fold_impl_item(i, self),\n-        }\n+        let is_const = match i.node {\n+            ast::ImplItemKind::Const(..) => true,\n+            ast::ImplItemKind::Method(ast::MethodSig { ref constness, .. }, _) =>\n+                constness.node == ast::Constness::Const,\n+            _ => false,\n+        };\n+        self.run(is_const, |s| fold::noop_fold_impl_item(i, s))\n     }\n \n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {"}, {"sha": "da8c3a5cf206bc67042e1e5d73ecf78cebc03061", "filename": "src/librustdoc/clean/cfg.rs", "status": "added", "additions": 889, "deletions": 0, "changes": 889, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -0,0 +1,889 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Representation of a `#[doc(cfg(...))]` attribute.\n+\n+// FIXME: Once RFC #1868 is implemented, switch to use those structures instead.\n+\n+use std::mem;\n+use std::fmt::{self, Write};\n+use std::ops;\n+use std::ascii::AsciiExt;\n+\n+use syntax::symbol::Symbol;\n+use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind, LitKind};\n+use syntax::parse::ParseSess;\n+use syntax::feature_gate::Features;\n+\n+use syntax_pos::Span;\n+\n+use html::escape::Escape;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq)]\n+pub enum Cfg {\n+    /// Accepts all configurations.\n+    True,\n+    /// Denies all configurations.\n+    False,\n+    /// A generic configration option, e.g. `test` or `target_os = \"linux\"`.\n+    Cfg(Symbol, Option<Symbol>),\n+    /// Negate a configuration requirement, i.e. `not(x)`.\n+    Not(Box<Cfg>),\n+    /// Union of a list of configuration requirements, i.e. `any(...)`.\n+    Any(Vec<Cfg>),\n+    /// Intersection of a list of configuration requirements, i.e. `all(...)`.\n+    All(Vec<Cfg>),\n+}\n+\n+#[derive(PartialEq, Debug)]\n+pub struct InvalidCfgError {\n+    pub msg: &'static str,\n+    pub span: Span,\n+}\n+\n+impl Cfg {\n+    /// Parses a `NestedMetaItem` into a `Cfg`.\n+    fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n+        match nested_cfg.node {\n+            NestedMetaItemKind::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItemKind::Literal(ref lit) => Err(InvalidCfgError {\n+                msg: \"unexpected literal\",\n+                span: lit.span,\n+            }),\n+        }\n+    }\n+\n+    /// Parses a `MetaItem` into a `Cfg`.\n+    ///\n+    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g. `unix` or\n+    /// `target_os = \"redox\"`.\n+    ///\n+    /// If the content is not properly formatted, it will return an error indicating what and where\n+    /// the error is.\n+    pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+        let name = cfg.name();\n+        match cfg.node {\n+            MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n+            MetaItemKind::NameValue(ref lit) => match lit.node {\n+                LitKind::Str(value, _) => Ok(Cfg::Cfg(name, Some(value))),\n+                _ => Err(InvalidCfgError {\n+                    // FIXME: if the main #[cfg] syntax decided to support non-string literals,\n+                    // this should be changed as well.\n+                    msg: \"value of cfg option should be a string literal\",\n+                    span: lit.span,\n+                }),\n+            },\n+            MetaItemKind::List(ref items) => {\n+                let mut sub_cfgs = items.iter().map(Cfg::parse_nested);\n+                match &*name.as_str() {\n+                    \"all\" => sub_cfgs.fold(Ok(Cfg::True), |x, y| Ok(x? & y?)),\n+                    \"any\" => sub_cfgs.fold(Ok(Cfg::False), |x, y| Ok(x? | y?)),\n+                    \"not\" => if sub_cfgs.len() == 1 {\n+                        Ok(!sub_cfgs.next().unwrap()?)\n+                    } else {\n+                        Err(InvalidCfgError {\n+                            msg: \"expected 1 cfg-pattern\",\n+                            span: cfg.span,\n+                        })\n+                    },\n+                    _ => Err(InvalidCfgError {\n+                        msg: \"invalid predicate\",\n+                        span: cfg.span,\n+                    }),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Checks whether the given configuration can be matched in the current session.\n+    ///\n+    /// Equivalent to `attr::cfg_matches`.\n+    // FIXME: Actually make use of `features`.\n+    pub fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+        match *self {\n+            Cfg::False => false,\n+            Cfg::True => true,\n+            Cfg::Not(ref child) => !child.matches(parse_sess, features),\n+            Cfg::All(ref sub_cfgs) => {\n+                sub_cfgs.iter().all(|sub_cfg| sub_cfg.matches(parse_sess, features))\n+            },\n+            Cfg::Any(ref sub_cfgs) => {\n+                sub_cfgs.iter().any(|sub_cfg| sub_cfg.matches(parse_sess, features))\n+            },\n+            Cfg::Cfg(name, value) => parse_sess.config.contains(&(name, value)),\n+        }\n+    }\n+\n+    /// Whether the configuration consists of just `Cfg` or `Not`.\n+    fn is_simple(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Cfg(..) | Cfg::Not(..) => true,\n+            Cfg::All(..) | Cfg::Any(..) => false,\n+        }\n+    }\n+\n+    /// Whether the configuration consists of just `Cfg`, `Not` or `All`.\n+    fn is_all(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Cfg(..) | Cfg::Not(..) | Cfg::All(..) => true,\n+            Cfg::Any(..) => false,\n+        }\n+    }\n+\n+    /// Renders the configuration for human display, as a short HTML description.\n+    pub(crate) fn render_short_html(&self) -> String {\n+        let mut msg = Html(self).to_string();\n+        if self.should_capitalize_first_letter() {\n+            if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n+                msg[i .. i+1].make_ascii_uppercase();\n+            }\n+        }\n+        msg\n+    }\n+\n+    /// Renders the configuration for long display, as a long HTML description.\n+    pub(crate) fn render_long_html(&self) -> String {\n+        let mut msg = format!(\"This is supported on <strong>{}</strong>\", Html(self));\n+        if self.should_append_only_to_description() {\n+            msg.push_str(\" only\");\n+        }\n+        msg.push('.');\n+        msg\n+    }\n+\n+    fn should_capitalize_first_letter(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Not(..) => true,\n+            Cfg::Any(ref sub_cfgs) | Cfg::All(ref sub_cfgs) => {\n+                sub_cfgs.first().map(Cfg::should_capitalize_first_letter).unwrap_or(false)\n+            },\n+            Cfg::Cfg(name, _) => match &*name.as_str() {\n+                \"debug_assertions\" | \"target_endian\" => true,\n+                _ => false,\n+            },\n+        }\n+    }\n+\n+    fn should_append_only_to_description(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True => false,\n+            Cfg::Any(..) | Cfg::All(..) | Cfg::Cfg(..) => true,\n+            Cfg::Not(ref child) => match **child {\n+                Cfg::Cfg(..) => true,\n+                _ => false,\n+            }\n+        }\n+    }\n+}\n+\n+impl ops::Not for Cfg {\n+    type Output = Cfg;\n+    fn not(self) -> Cfg {\n+        match self {\n+            Cfg::False => Cfg::True,\n+            Cfg::True => Cfg::False,\n+            Cfg::Not(cfg) => *cfg,\n+            s => Cfg::Not(Box::new(s)),\n+        }\n+    }\n+}\n+\n+impl ops::BitAndAssign for Cfg {\n+    fn bitand_assign(&mut self, other: Cfg) {\n+        match (self, other) {\n+            (&mut Cfg::False, _) | (_, Cfg::True) => {},\n+            (s, Cfg::False) => *s = Cfg::False,\n+            (s @ &mut Cfg::True, b) => *s = b,\n+            (&mut Cfg::All(ref mut a), Cfg::All(ref mut b)) => a.append(b),\n+            (&mut Cfg::All(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (s, Cfg::All(mut a)) => {\n+                let b = mem::replace(s, Cfg::True);\n+                a.push(b);\n+                *s = Cfg::All(a);\n+            },\n+            (s, b) => {\n+                let a = mem::replace(s, Cfg::True);\n+                *s = Cfg::All(vec![a, b]);\n+            },\n+        }\n+    }\n+}\n+\n+impl ops::BitAnd for Cfg {\n+    type Output = Cfg;\n+    fn bitand(mut self, other: Cfg) -> Cfg {\n+        self &= other;\n+        self\n+    }\n+}\n+\n+impl ops::BitOrAssign for Cfg {\n+    fn bitor_assign(&mut self, other: Cfg) {\n+        match (self, other) {\n+            (&mut Cfg::True, _) | (_, Cfg::False) => {},\n+            (s, Cfg::True) => *s = Cfg::True,\n+            (s @ &mut Cfg::False, b) => *s = b,\n+            (&mut Cfg::Any(ref mut a), Cfg::Any(ref mut b)) => a.append(b),\n+            (&mut Cfg::Any(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (s, Cfg::Any(mut a)) => {\n+                let b = mem::replace(s, Cfg::True);\n+                a.push(b);\n+                *s = Cfg::Any(a);\n+            },\n+            (s, b) => {\n+                let a = mem::replace(s, Cfg::True);\n+                *s = Cfg::Any(vec![a, b]);\n+            },\n+        }\n+    }\n+}\n+\n+impl ops::BitOr for Cfg {\n+    type Output = Cfg;\n+    fn bitor(mut self, other: Cfg) -> Cfg {\n+        self |= other;\n+        self\n+    }\n+}\n+\n+struct Html<'a>(&'a Cfg);\n+\n+fn write_with_opt_paren<T: fmt::Display>(\n+    fmt: &mut fmt::Formatter,\n+    has_paren: bool,\n+    obj: T,\n+) -> fmt::Result {\n+    if has_paren {\n+        fmt.write_char('(')?;\n+    }\n+    obj.fmt(fmt)?;\n+    if has_paren {\n+        fmt.write_char(')')?;\n+    }\n+    Ok(())\n+}\n+\n+\n+impl<'a> fmt::Display for Html<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.0 {\n+            Cfg::Not(ref child) => match **child {\n+                Cfg::Any(ref sub_cfgs) => {\n+                    let separator = if sub_cfgs.iter().all(Cfg::is_simple) {\n+                        \" nor \"\n+                    } else {\n+                        \", nor \"\n+                    };\n+                    for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                        fmt.write_str(if i == 0 { \"neither \" } else { separator })?;\n+                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg))?;\n+                    }\n+                    Ok(())\n+                }\n+                ref simple @ Cfg::Cfg(..) => write!(fmt, \"non-{}\", Html(simple)),\n+                ref c => write!(fmt, \"not ({})\", Html(c)),\n+            },\n+\n+            Cfg::Any(ref sub_cfgs) => {\n+                let separator = if sub_cfgs.iter().all(Cfg::is_simple) {\n+                    \" or \"\n+                } else {\n+                    \", or \"\n+                };\n+                for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                    if i != 0 {\n+                        fmt.write_str(separator)?;\n+                    }\n+                    write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg))?;\n+                }\n+                Ok(())\n+            },\n+\n+            Cfg::All(ref sub_cfgs) => {\n+                for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                    if i != 0 {\n+                        fmt.write_str(\" and \")?;\n+                    }\n+                    write_with_opt_paren(fmt, !sub_cfg.is_simple(), Html(sub_cfg))?;\n+                }\n+                Ok(())\n+            },\n+\n+            Cfg::True => fmt.write_str(\"everywhere\"),\n+            Cfg::False => fmt.write_str(\"nowhere\"),\n+\n+            Cfg::Cfg(name, value) => {\n+                let n = &*name.as_str();\n+                let human_readable = match (n, value) {\n+                    (\"unix\", None) => \"Unix\",\n+                    (\"windows\", None) => \"Windows\",\n+                    (\"debug_assertions\", None) => \"debug-assertions enabled\",\n+                    (\"target_os\", Some(os)) => match &*os.as_str() {\n+                        \"android\" => \"Android\",\n+                        \"bitrig\" => \"Bitrig\",\n+                        \"dragonfly\" => \"DragonFly BSD\",\n+                        \"emscripten\" => \"Emscripten\",\n+                        \"freebsd\" => \"FreeBSD\",\n+                        \"fuchsia\" => \"Fuchsia\",\n+                        \"haiku\" => \"Haiku\",\n+                        \"ios\" => \"iOS\",\n+                        \"l4re\" => \"L4Re\",\n+                        \"linux\" => \"Linux\",\n+                        \"macos\" => \"macOS\",\n+                        \"nacl\" => \"NaCl\",\n+                        \"netbsd\" => \"NetBSD\",\n+                        \"openbsd\" => \"OpenBSD\",\n+                        \"redox\" => \"Redox\",\n+                        \"solaris\" => \"Solaris\",\n+                        \"windows\" => \"Windows\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_arch\", Some(arch)) => match &*arch.as_str() {\n+                        \"aarch64\" => \"AArch64\",\n+                        \"arm\" => \"ARM\",\n+                        \"asmjs\" => \"asm.js\",\n+                        \"mips\" => \"MIPS\",\n+                        \"mips64\" => \"MIPS-64\",\n+                        \"msp430\" => \"MSP430\",\n+                        \"powerpc\" => \"PowerPC\",\n+                        \"powerpc64\" => \"PowerPC-64\",\n+                        \"s390x\" => \"s390x\",\n+                        \"sparc64\" => \"SPARC64\",\n+                        \"wasm32\" => \"WebAssembly\",\n+                        \"x86\" => \"x86\",\n+                        \"x86_64\" => \"x86-64\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_vendor\", Some(vendor)) => match &*vendor.as_str() {\n+                        \"apple\" => \"Apple\",\n+                        \"pc\" => \"PC\",\n+                        \"rumprun\" => \"Rumprun\",\n+                        \"sun\" => \"Sun\",\n+                        _ => \"\"\n+                    },\n+                    (\"target_env\", Some(env)) => match &*env.as_str() {\n+                        \"gnu\" => \"GNU\",\n+                        \"msvc\" => \"MSVC\",\n+                        \"musl\" => \"musl\",\n+                        \"newlib\" => \"Newlib\",\n+                        \"uclibc\" => \"uClibc\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_endian\", Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n+                    (\"target_pointer_width\", Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n+                    _ => \"\",\n+                };\n+                if !human_readable.is_empty() {\n+                    fmt.write_str(human_readable)\n+                } else if let Some(v) = value {\n+                    write!(fmt, \"<code>{}=\\\"{}\\\"</code>\", Escape(n), Escape(&*v.as_str()))\n+                } else {\n+                    write!(fmt, \"<code>{}</code>\", Escape(n))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Cfg;\n+\n+    use syntax::symbol::Symbol;\n+    use syntax::ast::*;\n+    use syntax::codemap::dummy_spanned;\n+    use syntax_pos::DUMMY_SP;\n+\n+    fn word_cfg(s: &str) -> Cfg {\n+        Cfg::Cfg(Symbol::intern(s), None)\n+    }\n+\n+    fn name_value_cfg(name: &str, value: &str) -> Cfg {\n+        Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n+    }\n+\n+    #[test]\n+    fn test_cfg_not() {\n+        assert_eq!(!Cfg::False, Cfg::True);\n+        assert_eq!(!Cfg::True, Cfg::False);\n+        assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n+        assert_eq!(\n+            !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(\n+            !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n+    }\n+\n+    #[test]\n+    fn test_cfg_and() {\n+        let mut x = Cfg::False;\n+        x &= Cfg::True;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test\");\n+        x &= Cfg::False;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test2\");\n+        x &= Cfg::True;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::True;\n+        x &= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x &= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x &= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y &= x;\n+        assert_eq!(y, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cfg_or() {\n+        let mut x = Cfg::True;\n+        x |= Cfg::False;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test\");\n+        x |= Cfg::True;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test2\");\n+        x |= Cfg::False;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::False;\n+        x |= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x |= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x |= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y |= x;\n+        assert_eq!(y, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_parse_ok() {\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::Word,\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n+                Symbol::intern(\"done\"),\n+                StrStyle::Cooked,\n+            ))),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"any\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"any\"),\n+                    node: MetaItemKind::List(vec![\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                            name: Symbol::intern(\"a\"),\n+                            node: MetaItemKind::Word,\n+                            span: DUMMY_SP,\n+                        })),\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                            name: Symbol::intern(\"all\"),\n+                            node: MetaItemKind::List(vec![\n+                                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                                    name: Symbol::intern(\"b\"),\n+                                    node: MetaItemKind::Word,\n+                                    span: DUMMY_SP,\n+                                })),\n+                                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                                    name: Symbol::intern(\"c\"),\n+                                    node: MetaItemKind::Word,\n+                                    span: DUMMY_SP,\n+                                })),\n+                            ]),\n+                            span: DUMMY_SP,\n+                        })),\n+                    ]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"c\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n+    }\n+\n+    #[test]\n+    fn test_parse_err() {\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"foo\"),\n+            node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"foo\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"any\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+    }\n+\n+    #[test]\n+    fn test_render_short_html() {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_short_html(),\n+            \"Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n+            \"macOS\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n+            \"16-bit\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n+            \"Little-endian\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_short_html(),\n+            \"Non-Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n+            \"Unix and Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n+            \"Unix or Windows\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix and Windows and debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix or Windows or debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_short_html(),\n+            \"Neither Unix nor Windows nor debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_short_html(),\n+            \"Unix and x86-64, or Windows and 64-bit\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n+            \"Not (Unix and Windows)\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_short_html(),\n+            \"(Debug-assertions enabled or Windows) and Unix\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_render_long_html() {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_long_html(),\n+            \"This is supported on <strong>Unix</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n+            \"This is supported on <strong>macOS</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n+            \"This is supported on <strong>16-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n+            \"This is supported on <strong>little-endian</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>non-Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows and debug-assertions enabled</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows or debug-assertions enabled</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n+                enabled</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n+            \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix</strong> \\\n+                only.\"\n+        );\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "57e72c3a40bf520bd641ccea0d8cb4a9741eb633", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -52,8 +52,11 @@ use visit_ast;\n use html::item_type::ItemType;\n \n pub mod inline;\n+pub mod cfg;\n mod simplify;\n \n+use self::cfg::Cfg;\n+\n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).clean(cx)\n@@ -536,31 +539,67 @@ impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n pub struct Attributes {\n     pub doc_strings: Vec<String>,\n     pub other_attrs: Vec<ast::Attribute>,\n+    pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n }\n \n impl Attributes {\n-    pub fn from_ast(attrs: &[ast::Attribute]) -> Attributes {\n+    /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n+    fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n+        use syntax::ast::NestedMetaItemKind::MetaItem;\n+\n+        if let ast::MetaItemKind::List(ref nmis) = mi.node {\n+            if nmis.len() == 1 {\n+                if let MetaItem(ref cfg_mi) = nmis[0].node {\n+                    if cfg_mi.check_name(\"cfg\") {\n+                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n+                            if cfg_nmis.len() == 1 {\n+                                if let MetaItem(ref content_mi) = cfg_nmis[0].node {\n+                                    return Some(content_mi);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub fn from_ast(diagnostic: &::errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n         let mut doc_strings = vec![];\n         let mut sp = None;\n+        let mut cfg = Cfg::True;\n+\n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n-                if let Some(value) = attr.value_str() {\n-                    if attr.check_name(\"doc\") {\n-                        doc_strings.push(value.to_string());\n-                        if sp.is_none() {\n-                            sp = Some(attr.span);\n+                if attr.check_name(\"doc\") {\n+                    if let Some(mi) = attr.meta() {\n+                        if let Some(value) = mi.value_str() {\n+                            // Extracted #[doc = \"...\"]\n+                            doc_strings.push(value.to_string());\n+                            if sp.is_none() {\n+                                sp = Some(attr.span);\n+                            }\n+                            return None;\n+                        } else if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                            // Extracted #[doc(cfg(...))]\n+                            match Cfg::parse(cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => diagnostic.span_err(e.span, e.msg),\n+                            }\n+                            return None;\n                         }\n-                        return None;\n                     }\n                 }\n-\n                 Some(attr.clone())\n             })\n         }).collect();\n         Attributes {\n-            doc_strings: doc_strings,\n-            other_attrs: other_attrs,\n+            doc_strings,\n+            other_attrs,\n+            cfg: if cfg == Cfg::True { None } else { Some(Rc::new(cfg)) },\n             span: sp,\n         }\n     }\n@@ -579,8 +618,8 @@ impl AttributesExt for Attributes {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, _cx: &DocContext) -> Attributes {\n-        Attributes::from_ast(self)\n+    fn clean(&self, cx: &DocContext) -> Attributes {\n+        Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n "}, {"sha": "9bb7e4e3a09d51e859b5fd7a2a0bc170be71503b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -10,6 +10,7 @@\n \n use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n+use rustc_driver::pretty::ReplaceBodyWithLoop;\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n@@ -26,6 +27,7 @@ use rustc_metadata::cstore::CStore;\n \n use syntax::{ast, codemap};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::fold::Folder;\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -158,6 +160,7 @@ pub fn run_core(search_paths: SearchPaths,\n     let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n                                                       &sess,\n                                                       &input));\n+    let krate = ReplaceBodyWithLoop::new().fold_crate(krate);\n \n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n "}, {"sha": "4e3181759f999aafb26458776c5bebcf25bc0b2f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -1962,6 +1962,14 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n \n+    if let Some(ref cfg) = item.attrs.cfg {\n+        stability.push(format!(\"<div class='stab portability'>{}</div>\", if show_reason {\n+            cfg.render_long_html()\n+        } else {\n+            cfg.render_short_html()\n+        }));\n+    }\n+\n     stability\n }\n "}, {"sha": "08bf5a10fe9d981280810ff6bbd4ff9dac1e1301", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -152,6 +152,7 @@ a.test-arrow {\n \n .stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n+.stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n \n #help > div {\n \tbackground: #e9e9e9;"}, {"sha": "9264015ed9edfae068ccc6d783af38e71726498f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -26,6 +26,7 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(vec_remove_item)]\n+#![feature(ascii_ctype)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "146629486fabdf58788170ff1213c53703bba808", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -33,6 +33,9 @@ pub use self::strip_priv_imports::strip_priv_imports;\n mod unindent_comments;\n pub use self::unindent_comments::unindent_comments;\n \n+mod propagate_doc_cfg;\n+pub use self::propagate_doc_cfg::propagate_doc_cfg;\n+\n type Pass = (&'static str,                                      // name\n              fn(clean::Crate) -> plugins::PluginResult,         // fn\n              &'static str);                                     // description\n@@ -49,13 +52,16 @@ pub const PASSES: &'static [Pass] = &[\n       implies strip-priv-imports\"),\n     (\"strip-priv-imports\", strip_priv_imports,\n      \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n+    (\"propagate-doc-cfg\", propagate_doc_cfg,\n+     \"propagates `#[doc(cfg(...))]` to child items\"),\n ];\n \n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n+    \"propagate-doc-cfg\",\n ];\n \n "}, {"sha": "9e65fff5e2ac6f3f65c04f9a3af106a9e708c65a", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+use clean::{Crate, Item};\n+use clean::cfg::Cfg;\n+use fold::DocFolder;\n+use plugins::PluginResult;\n+\n+pub fn propagate_doc_cfg(cr: Crate) -> PluginResult {\n+    CfgPropagator { parent_cfg: None }.fold_crate(cr)\n+}\n+\n+struct CfgPropagator {\n+    parent_cfg: Option<Rc<Cfg>>,\n+}\n+\n+impl DocFolder for CfgPropagator {\n+    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+        let old_parent_cfg = self.parent_cfg.clone();\n+\n+        let new_cfg = match (self.parent_cfg.take(), item.attrs.cfg.take()) {\n+            (None, None) => None,\n+            (Some(rc), None) | (None, Some(rc)) => Some(rc),\n+            (Some(mut a), Some(b)) => {\n+                let b = Rc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n+                *Rc::make_mut(&mut a) &= b;\n+                Some(a)\n+            }\n+        };\n+        self.parent_cfg = new_cfg.clone();\n+        item.attrs.cfg = new_cfg;\n+\n+        let result = self.fold_item_recur(item);\n+        self.parent_cfg = old_parent_cfg;\n+\n+        result\n+    }\n+}"}, {"sha": "fff047c99c034a7d17b8732f7e788742478caa9e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -32,13 +32,15 @@ use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n+use rustc_driver::pretty::ReplaceBodyWithLoop;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::fold::Folder;\n use syntax_pos::{BytePos, DUMMY_SP, Pos, Span};\n use errors;\n use errors::emitter::ColorConfig;\n@@ -72,6 +74,7 @@ pub fn run(input: &str,\n         crate_types: vec![config::CrateTypeDylib],\n         externs: externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n+        lint_cap: Some(::rustc::lint::Level::Allow),\n         actually_rustdoc: true,\n         ..config::basic_options().clone()\n     };\n@@ -94,6 +97,7 @@ pub fn run(input: &str,\n     let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n                                                       &sess,\n                                                       &input));\n+    let krate = ReplaceBodyWithLoop::new().fold_crate(krate);\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n@@ -121,6 +125,7 @@ pub fn run(input: &str,\n         let map = hir::map::map_crate(&mut hir_forest, defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n+            sess: &sess,\n             collector: &mut collector,\n             map: &map\n         };\n@@ -574,6 +579,7 @@ impl Collector {\n }\n \n struct HirCollector<'a, 'hir: 'a> {\n+    sess: &'a session::Session,\n     collector: &'a mut Collector,\n     map: &'a hir::map::Map<'hir>\n }\n@@ -583,12 +589,18 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                                             name: String,\n                                             attrs: &[ast::Attribute],\n                                             nested: F) {\n+        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n+        if let Some(ref cfg) = attrs.cfg {\n+            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features.borrow())) {\n+                return;\n+            }\n+        }\n+\n         let has_name = !name.is_empty();\n         if has_name {\n             self.collector.names.push(name);\n         }\n \n-        let mut attrs = Attributes::from_ast(attrs);\n         attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {"}, {"sha": "880caa2ade5d82a39a7418b6e80a4a09d86b76d2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -315,6 +315,7 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n+#![feature(doc_cfg)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n #![default_lib_allocator]"}, {"sha": "72eed549f62a0b4e4f019051d440018007814428", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -13,26 +13,36 @@\n #![stable(feature = \"os\", since = \"1.0.0\")]\n #![allow(missing_docs, bad_style, missing_debug_implementations)]\n \n-#[cfg(any(target_os = \"redox\", unix))]\n+#[cfg(all(not(dox), any(target_os = \"redox\", unix)))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::ext as unix;\n-#[cfg(windows)]\n+#[cfg(all(not(dox), windows))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::ext as windows;\n \n-#[cfg(target_os = \"android\")]   pub mod android;\n-#[cfg(target_os = \"bitrig\")]    pub mod bitrig;\n-#[cfg(target_os = \"dragonfly\")] pub mod dragonfly;\n-#[cfg(target_os = \"freebsd\")]   pub mod freebsd;\n-#[cfg(target_os = \"haiku\")]     pub mod haiku;\n-#[cfg(target_os = \"ios\")]       pub mod ios;\n-#[cfg(target_os = \"linux\")]     pub mod linux;\n-#[cfg(target_os = \"macos\")]     pub mod macos;\n-#[cfg(target_os = \"nacl\")]      pub mod nacl;\n-#[cfg(target_os = \"netbsd\")]   pub mod netbsd;\n-#[cfg(target_os = \"openbsd\")]   pub mod openbsd;\n-#[cfg(target_os = \"solaris\")]   pub mod solaris;\n-#[cfg(target_os = \"emscripten\")] pub mod emscripten;\n-#[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n+#[cfg(dox)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use sys::unix_ext as unix;\n+#[cfg(dox)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use sys::windows_ext as windows;\n+\n+#[cfg(any(dox, target_os = \"linux\"))]\n+#[doc(cfg(target_os = \"linux\"))]\n+pub mod linux;\n+\n+#[cfg(all(not(dox), target_os = \"android\"))]    pub mod android;\n+#[cfg(all(not(dox), target_os = \"bitrig\"))]     pub mod bitrig;\n+#[cfg(all(not(dox), target_os = \"dragonfly\"))]  pub mod dragonfly;\n+#[cfg(all(not(dox), target_os = \"freebsd\"))]    pub mod freebsd;\n+#[cfg(all(not(dox), target_os = \"haiku\"))]      pub mod haiku;\n+#[cfg(all(not(dox), target_os = \"ios\"))]        pub mod ios;\n+#[cfg(all(not(dox), target_os = \"macos\"))]      pub mod macos;\n+#[cfg(all(not(dox), target_os = \"nacl\"))]       pub mod nacl;\n+#[cfg(all(not(dox), target_os = \"netbsd\"))]     pub mod netbsd;\n+#[cfg(all(not(dox), target_os = \"openbsd\"))]    pub mod openbsd;\n+#[cfg(all(not(dox), target_os = \"solaris\"))]    pub mod solaris;\n+#[cfg(all(not(dox), target_os = \"emscripten\"))] pub mod emscripten;\n+#[cfg(all(not(dox), target_os = \"fuchsia\"))]    pub mod fuchsia;\n \n pub mod raw;"}, {"sha": "d91c2073a23a83e5b31941a5c00b650f3d7690ba", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -45,3 +45,33 @@ mod imp;\n #[cfg(target_os = \"redox\")]\n #[path = \"redox/mod.rs\"]\n mod imp;\n+\n+\n+// Import essential modules from both platforms when documenting.\n+\n+#[cfg(all(dox, not(unix)))]\n+use os::linux as platform;\n+\n+#[cfg(all(dox, not(any(unix, target_os = \"redox\"))))]\n+#[path = \"unix/ext/mod.rs\"]\n+pub mod unix_ext;\n+\n+#[cfg(all(dox, any(unix, target_os = \"redox\")))]\n+pub use self::ext as unix_ext;\n+\n+\n+#[cfg(all(dox, not(windows)))]\n+#[macro_use]\n+#[path = \"windows/compat.rs\"]\n+mod compat;\n+\n+#[cfg(all(dox, not(windows)))]\n+#[path = \"windows/c.rs\"]\n+mod c;\n+\n+#[cfg(all(dox, not(windows)))]\n+#[path = \"windows/ext/mod.rs\"]\n+pub mod windows_ext;\n+\n+#[cfg(all(dox, windows))]\n+pub use self::ext as windows_ext;"}, {"sha": "259cda5bcb3ebe485d07f2cd5f8090e2ebf1b18a", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -28,6 +28,7 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(cfg(target_os = \"redox\"))]\n \n pub mod ffi;\n pub mod fs;"}, {"sha": "67fe46cc9c7a20326b6c8b4dec7726f8356128b6", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -28,6 +28,7 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(cfg(unix))]\n \n pub mod io;\n pub mod ffi;"}, {"sha": "698944ea0ba4b03e2ca0133b2fd00ab93d772b50", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -12,8 +12,19 @@\n \n //! Unix-specific networking functionality\n \n+#[cfg(unix)]\n use libc;\n \n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(not(unix))]\n+mod libc {\n+    pub use libc::c_int;\n+    pub type socklen_t = u32;\n+    pub struct sockaddr;\n+    #[derive(Clone)]\n+    pub struct sockaddr_un;\n+}\n+\n use ascii;\n use ffi::OsStr;\n use fmt;"}, {"sha": "4393aedf162a3bf9b0d787a3e8e69d0f207d8e9e", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -13,20 +13,21 @@\n use io::{self, ErrorKind};\n use libc;\n \n-#[cfg(target_os = \"android\")]   pub use os::android as platform;\n-#[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n-#[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n-#[cfg(target_os = \"freebsd\")]   pub use os::freebsd as platform;\n-#[cfg(target_os = \"haiku\")]     pub use os::haiku as platform;\n-#[cfg(target_os = \"ios\")]       pub use os::ios as platform;\n-#[cfg(target_os = \"linux\")]     pub use os::linux as platform;\n-#[cfg(target_os = \"macos\")]     pub use os::macos as platform;\n-#[cfg(target_os = \"nacl\")]      pub use os::nacl as platform;\n-#[cfg(target_os = \"netbsd\")]    pub use os::netbsd as platform;\n-#[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n-#[cfg(target_os = \"solaris\")]   pub use os::solaris as platform;\n-#[cfg(target_os = \"emscripten\")] pub use os::emscripten as platform;\n-#[cfg(target_os = \"fuchsia\")]   pub use os::fuchsia as platform;\n+#[cfg(any(dox, target_os = \"linux\"))] pub use os::linux as platform;\n+\n+#[cfg(all(not(dox), target_os = \"android\"))]   pub use os::android as platform;\n+#[cfg(all(not(dox), target_os = \"bitrig\"))]    pub use os::bitrig as platform;\n+#[cfg(all(not(dox), target_os = \"dragonfly\"))] pub use os::dragonfly as platform;\n+#[cfg(all(not(dox), target_os = \"freebsd\"))]   pub use os::freebsd as platform;\n+#[cfg(all(not(dox), target_os = \"haiku\"))]     pub use os::haiku as platform;\n+#[cfg(all(not(dox), target_os = \"ios\"))]       pub use os::ios as platform;\n+#[cfg(all(not(dox), target_os = \"macos\"))]     pub use os::macos as platform;\n+#[cfg(all(not(dox), target_os = \"nacl\"))]      pub use os::nacl as platform;\n+#[cfg(all(not(dox), target_os = \"netbsd\"))]    pub use os::netbsd as platform;\n+#[cfg(all(not(dox), target_os = \"openbsd\"))]   pub use os::openbsd as platform;\n+#[cfg(all(not(dox), target_os = \"solaris\"))]   pub use os::solaris as platform;\n+#[cfg(all(not(dox), target_os = \"emscripten\"))] pub use os::emscripten as platform;\n+#[cfg(all(not(dox), target_os = \"fuchsia\"))]   pub use os::fuchsia as platform;\n \n #[macro_use]\n pub mod weak;"}, {"sha": "ba54ca6ea18281a893d698d8d49104e02d012976", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -301,7 +301,7 @@ pub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n pub const FD_SETSIZE: usize = 64;\n \n #[repr(C)]\n-#[cfg(target_arch = \"x86\")]\n+#[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n     pub wVersion: WORD,\n     pub wHighVersion: WORD,\n@@ -312,7 +312,7 @@ pub struct WSADATA {\n     pub lpVendorInfo: *mut u8,\n }\n #[repr(C)]\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(target_pointer_width = \"64\")]\n pub struct WSADATA {\n     pub wVersion: WORD,\n     pub wHighVersion: WORD,\n@@ -768,6 +768,14 @@ pub struct FLOATING_SAVE_AREA {\n     _Dummy: [u8; 512] // FIXME: Fill this out\n }\n \n+// FIXME(#43348): This structure is used for backtrace only, and a fake\n+// definition is provided here only to allow rustdoc to pass type-check. This\n+// will not appear in the final documentation. This should be also defined for\n+// other architectures supported by Windows such as ARM, and for historical\n+// interest, maybe MIPS and PowerPC as well.\n+#[cfg(all(dox, not(any(target_arch = \"x86_64\", target_arch = \"x86\"))))]\n+pub enum CONTEXT {}\n+\n #[repr(C)]\n pub struct SOCKADDR_STORAGE_LH {\n     pub ss_family: ADDRESS_FAMILY,"}, {"sha": "4b458d293bce278a7f8d4708d50e49958d0e40fb", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -17,6 +17,7 @@\n //! platform-agnostic idioms would not normally support.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(cfg(windows))]\n \n pub mod ffi;\n pub mod fs;"}, {"sha": "2b8a733b85243b92e6dc609c1e1da402efdaebd3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -372,6 +372,9 @@ declare_features! (\n     // global allocators and their internals\n     (active, global_allocator, \"1.20.0\", None),\n     (active, allocator_internals, \"1.20.0\", None),\n+\n+    // #[doc(cfg(...))]\n+    (active, doc_cfg, \"1.21.0\", Some(43781)),\n );\n \n declare_features! (\n@@ -1172,6 +1175,16 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n+        if attr.check_name(\"doc\") {\n+            if let Some(content) = attr.meta_item_list() {\n+                if content.len() == 1 && content[0].check_name(\"cfg\") {\n+                    gate_feature_post!(&self, doc_cfg, attr.span,\n+                        \"#[doc(cfg(...))] is experimental\"\n+                    );\n+                }\n+            }\n+        }\n+\n         if self.context.features.proc_macro && attr::is_known(attr) {\n             return\n         }"}, {"sha": "1a77d918014572c3c4974867dec71738a8665d4a", "filename": "src/test/compile-fail/feature-gate-doc_cfg.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[doc(cfg(unix))] //~ ERROR: #[doc(cfg(...))] is experimental\n+fn main() {}"}, {"sha": "cfb37912fe757587e37f06e72b2cb4e7915d3680", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/0ed03e5490b481804db27627e16e147680ed207d/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ed03e5490b481804db27627e16e147680ed207d/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=0ed03e5490b481804db27627e16e147680ed207d", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(doc_cfg)]\n+\n+// @has doc_cfg/struct.Portable.html\n+// @!has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' ''\n+// @has - '//*[@id=\"method.unix_and_arm_only_function\"]' 'fn unix_and_arm_only_function()'\n+// @has - '//*[@class=\"stab portability\"]' 'This is supported on Unix and ARM only.'\n+pub struct Portable;\n+\n+// @has doc_cfg/unix_only/index.html \\\n+//  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+//  'This is supported on Unix only.'\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix\\Z'\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix and ARM\\Z'\n+// @count - '//*[@class=\"stab portability\"]' 3\n+#[doc(cfg(unix))]\n+pub mod unix_only {\n+    // @has doc_cfg/unix_only/fn.unix_only_function.html \\\n+    //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+    //  'This is supported on Unix only.'\n+    // @count - '//*[@class=\"stab portability\"]' 1\n+    pub fn unix_only_function() {\n+        content::should::be::irrelevant();\n+    }\n+\n+    // @has doc_cfg/unix_only/trait.ArmOnly.html \\\n+    //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+    //  'This is supported on Unix and ARM only.'\n+    // @count - '//*[@class=\"stab portability\"]' 2\n+    #[doc(cfg(target_arch = \"arm\"))]\n+    pub trait ArmOnly {\n+        fn unix_and_arm_only_function();\n+    }\n+\n+    impl ArmOnly for super::Portable {\n+        fn unix_and_arm_only_function() {}\n+    }\n+}\n\\ No newline at end of file"}]}