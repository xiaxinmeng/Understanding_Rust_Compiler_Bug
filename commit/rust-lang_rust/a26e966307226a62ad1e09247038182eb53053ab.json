{"sha": "a26e966307226a62ad1e09247038182eb53053ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNmU5NjYzMDcyMjZhNjJhZDFlMDkyNDcwMzgxODJlYjUzMDUzYWI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-28T23:29:16Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-02T18:01:36Z"}, "message": "convert the `inline` pass to use the new multi result\n\nThis involves changing various details about that system,\nthough the basic shape remains the same.", "tree": {"sha": "7c71b50e11c61a6bfb5212fc0c302dd1483c55e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7c71b50e11c61a6bfb5212fc0c302dd1483c55e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a26e966307226a62ad1e09247038182eb53053ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a26e966307226a62ad1e09247038182eb53053ab", "html_url": "https://github.com/rust-lang/rust/commit/a26e966307226a62ad1e09247038182eb53053ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a26e966307226a62ad1e09247038182eb53053ab/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d675ce0a3e323b390bdbd7c8b5bdf80909ca6a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d675ce0a3e323b390bdbd7c8b5bdf80909ca6a1", "html_url": "https://github.com/rust-lang/rust/commit/1d675ce0a3e323b390bdbd7c8b5bdf80909ca6a1"}], "stats": {"total": 428, "additions": 311, "deletions": 117}, "files": [{"sha": "9718098aac8afe8ae39507c92debf4837b79c450", "filename": "src/librustc/mir/transform.rs", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc%2Fmir%2Ftransform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc%2Fmir%2Ftransform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftransform.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -13,6 +13,8 @@ use hir::def_id::DefId;\n use hir::map::DefPathData;\n use mir::{Mir, Promoted};\n use ty::TyCtxt;\n+use ty::maps::Multi;\n+use ty::steal::Steal;\n use std::cell::Ref;\n use std::rc::Rc;\n use syntax::ast::NodeId;\n@@ -70,15 +72,6 @@ impl<'a, 'tcx> MirSource {\n     }\n }\n \n-/// Various information about pass.\n-pub trait Pass {\n-    fn name<'a>(&'a self) -> Cow<'a, str> {\n-        default_name::<Self>()\n-    }\n-\n-    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>);\n-}\n-\n /// Generates a default name for the pass based on the name of the\n /// type `T`.\n pub fn default_name<T: ?Sized>() -> Cow<'static, str> {\n@@ -97,8 +90,20 @@ pub trait MirCtxt<'a, 'tcx: 'a> {\n     fn suite(&self) -> MirSuite;\n     fn pass_num(&self) -> MirPassIndex;\n     fn source(&self) -> MirSource;\n+\n+    // Get a read-only view on the MIR of this def-id from the\n+    // previous pass.\n     fn read_previous_mir(&self) -> Ref<'tcx, Mir<'tcx>>;\n+\n+    // Steal the MIR of this def-id from the previous pass; any future\n+    // attempt to access the MIR from the previous pass is a bug.\n     fn steal_previous_mir(&self) -> Mir<'tcx>;\n+\n+    // Same as `read_previous_mir()`, but for any def-id you want.\n+    fn read_previous_mir_of(&self, def_id: DefId) -> Ref<'tcx, Mir<'tcx>>;\n+\n+    // Same as `steal_previous_mir()`, but for any def-id you want.\n+    fn steal_previous_mir_of(&self, def_id: DefId) -> Mir<'tcx>;\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n@@ -116,17 +121,35 @@ pub struct MirPassIndex(pub usize);\n /// `mir_cx.read_previous_mir()`); after the pass executes, it will be\n /// `Some()` with the result of the pass (in which case the output\n /// from the previous pass is most likely stolen, so you would not\n-/// want to try and access it).\n+/// want to try and access it). If the pass is interprocedural, then\n+/// the hook will be invoked once per output.\n pub trait PassHook {\n     fn on_mir_pass<'a, 'tcx: 'a>(&self,\n                                  mir_cx: &MirCtxt<'a, 'tcx>,\n-                                 mir: Option<&Mir<'tcx>>);\n+                                 mir: Option<(DefId, &Mir<'tcx>)>);\n }\n \n-/// A streamlined trait that you can implement to create a pass; the\n-/// pass will be invoked to process the MIR with the given `def_id`.\n-/// This lets you do things before we fetch the MIR itself.  You may\n-/// prefer `MirPass`.\n+/// The full suite of types that identifies a particular\n+/// application of a pass to a def-id.\n+pub type PassId = (MirSuite, MirPassIndex, DefId);\n+\n+/// The most generic sort of MIR pass. You only want to implement this\n+/// rather general trait if you are doing an interprocedural pass that\n+/// may inspect and affect the MIR of many def-ids. Otherwise, prefer\n+/// the more steamlined `DefIdPass` or `MirPass`.\n+pub trait Pass {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        default_name::<Self>()\n+    }\n+\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>)\n+                              -> Multi<PassId, &'tcx Steal<Mir<'tcx>>>;\n+}\n+\n+/// A streamlined trait that you can implement to create an\n+/// intraprocedural pass; the pass will be invoked to process the MIR\n+/// with the given `def_id`.  This lets you do things before we fetch\n+/// the MIR itself. You may prefer `MirPass`, which is even more streamlined.\n pub trait DefIdPass {\n     fn name<'a>(&'a self) -> Cow<'a, str> {\n         default_name::<Self>()\n@@ -135,10 +158,21 @@ pub trait DefIdPass {\n     fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>) -> Mir<'tcx>;\n }\n \n+impl<T: DefIdPass> Pass for T {\n+    fn name<'a>(&'a self) -> Cow<'a, str> {\n+        DefIdPass::name(self)\n+    }\n+\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>)\n+                              -> Multi<PassId, &'tcx Steal<Mir<'tcx>>> {\n+        Multi::from(mir_cx.tcx().alloc_steal_mir(DefIdPass::run_pass(self, mir_cx)))\n+    }\n+}\n+\n /// A streamlined trait that you can implement to create a pass; the\n /// pass will be named after the type, and it will consist of a main\n /// loop that goes over each available MIR and applies `run_pass`.\n-pub trait MirPass: DepGraphSafe {\n+pub trait MirPass {\n     fn name<'a>(&'a self) -> Cow<'a, str> {\n         default_name::<Self>()\n     }\n@@ -174,7 +208,7 @@ impl<T: MirPass> DefIdPass for T {\n #[derive(Clone)]\n pub struct Passes {\n     pass_hooks: Vec<Rc<PassHook>>,\n-    suites: Vec<Vec<Rc<DefIdPass>>>,\n+    suites: Vec<Vec<Rc<Pass>>>,\n }\n \n /// The number of \"pass suites\" that we have:\n@@ -202,7 +236,7 @@ impl<'a, 'tcx> Passes {\n     }\n \n     /// Pushes a built-in pass.\n-    pub fn push_pass<T: DefIdPass + 'static>(&mut self, suite: MirSuite, pass: T) {\n+    pub fn push_pass<T: Pass + 'static>(&mut self, suite: MirSuite, pass: T) {\n         self.suites[suite.0].push(Rc::new(pass));\n     }\n \n@@ -215,7 +249,7 @@ impl<'a, 'tcx> Passes {\n         self.suites[suite.0].len()\n     }\n \n-    pub fn pass(&self, suite: MirSuite, pass: MirPassIndex) -> &DefIdPass {\n+    pub fn pass(&self, suite: MirSuite, pass: MirPassIndex) -> &Pass {\n         &*self.suites[suite.0][pass.0]\n     }\n "}, {"sha": "3541a19fe6b645b10b1dc815e5e007942fcc8874", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 65, "deletions": 31, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -24,20 +24,21 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, NodeSet};\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::cell::{RefCell, RefMut};\n+use std::option;\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::iter::{self, Once};\n use std::mem;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n+use std::vec;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::symbol::Symbol;\n \n-trait Key: Clone + Hash + Eq + Debug {\n+pub trait Key: Clone + Hash + Eq + Debug {\n     fn map_crate(&self) -> CrateNum;\n     fn default_span(&self, tcx: TyCtxt) -> Span;\n }\n@@ -163,27 +164,61 @@ impl<'tcx> Value<'tcx> for ty::SymbolName {\n trait IntoKeyValues<K: Key, V> {\n     type KeyValues: IntoIterator<Item=(K, V)>;\n \n-    fn into_key_values(tcx: TyCtxt, key: &K, value: Self) -> Self::KeyValues;\n+    fn into_key_values(key: &K, value: Self) -> Self::KeyValues;\n }\n \n impl<K: Key, V> IntoKeyValues<K, V> for V {\n     type KeyValues = Once<(K, V)>;\n \n-    fn into_key_values(_: TyCtxt, key: &K, value: Self) -> Self::KeyValues {\n+    fn into_key_values(key: &K, value: Self) -> Self::KeyValues {\n         iter::once((key.clone(), value))\n     }\n }\n \n-impl<K: Key, V> IntoKeyValues<K, V> for FxHashMap<K, V> {\n-    type KeyValues = Self;\n+/// Return type for a multi-query, which is a query which may (if it\n+/// chooses) return more than one (key, value) pair. Construct a\n+/// `Multi` using `Multi::from(...)`.\n+pub struct Multi<K: Key, V> {\n+    single: Option<V>,\n+    map: Vec<(K, V)>,\n+}\n \n-    fn into_key_values(tcx: TyCtxt, key: &K, value: Self) -> Self {\n-        if !value.contains_key(key) {\n-            span_bug!(key.default_span(tcx),\n-                      \"multi-generation function for `{:?}` did not generate a value for `{:?}`\",\n-                      key, key)\n+impl<K: Key, V> Multi<K, V> {\n+    pub fn iter<'a>(&'a self, key: &'a K) -> impl Iterator<Item = (&'a K, &'a V)> + 'a {\n+        self.single.iter()\n+                   .map(move |v| (key, v))\n+                   .chain(self.map.iter().map(move |&(ref k, ref v)| (k, v)))\n+    }\n+}\n+\n+/// Construct a `Multi` from a single value.\n+impl<K: Key, V> From<V> for Multi<K, V> {\n+    fn from(value: V) -> Self {\n+        Multi {\n+            single: Some(value),\n+            map: vec![],\n         }\n-        value\n+    }\n+}\n+\n+/// Construct a `Multi` from a hashmap of (K, V) pairs.\n+impl<K: Key, V> From<Vec<(K, V)>> for Multi<K, V> {\n+    fn from(value: Vec<(K, V)>) -> Self {\n+        Multi {\n+            single: None,\n+            map: value\n+        }\n+    }\n+}\n+\n+impl<K: Key, V> IntoKeyValues<K, V> for Multi<K, V> {\n+    type KeyValues = iter::Chain<option::IntoIter<(K, V)>, vec::IntoIter<(K, V)>>;\n+\n+    fn into_key_values(key: &K, value: Self) -> Self::KeyValues {\n+        value.single\n+             .map(|v| (key.clone(), v))\n+             .into_iter()\n+             .chain(value.map)\n     }\n }\n \n@@ -469,7 +504,7 @@ macro_rules! define_maps {\n \n                 {\n                     let map = &mut *tcx.maps.$name.borrow_mut();\n-                    for (k, v) in IntoKeyValues::<$K, $V>::into_key_values(tcx, &key, result) {\n+                    for (k, v) in IntoKeyValues::<$K, $V>::into_key_values(&key, result) {\n                         map.insert(k, v);\n                     }\n                 }\n@@ -545,16 +580,6 @@ macro_rules! define_maps {\n         impl<$tcx> Clone for Providers<$tcx> {\n             fn clone(&self) -> Self { *self }\n         }\n-\n-        impl<$tcx> Default for Providers<$tcx> {\n-            fn default() -> Self {\n-                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $V {\n-                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n-                         stringify!($name), key);\n-                })*\n-                Providers { $($name),* }\n-            }\n-        }\n     }\n }\n \n@@ -642,34 +667,43 @@ macro_rules! define_provider_struct {\n     // Final state:\n     (tcx: $tcx:tt,\n      input: (),\n-     output: ($($output:tt)*)) => {\n+     output: ($(([$name:ident] [$K:ty] [$R:ty]))*)) => {\n         pub struct Providers<$tcx> {\n-            $($output)*\n+            $(pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)*\n+        }\n+\n+        impl<$tcx> Default for Providers<$tcx> {\n+            fn default() -> Self {\n+                $(fn $name<'a, $tcx>(_: TyCtxt<'a, $tcx, $tcx>, key: $K) -> $R {\n+                    bug!(\"tcx.maps.{}({:?}) unsupported by its crate\",\n+                         stringify!($name), key);\n+                })*\n+                Providers { $($name),* }\n+            }\n         }\n     };\n \n     // Something ready to shift:\n     (tcx: $tcx:tt,\n-     ready: ([$name:ident] [$K:ty] [$R:ty]),\n+     ready: ($name:tt $K:tt $V:tt),\n      input: $input:tt,\n      output: ($($output:tt)*)) => {\n         define_provider_struct! {\n             tcx: $tcx,\n             input: $input,\n-            output: ($($output)*\n-                     pub $name: for<'a> fn(TyCtxt<'a, $tcx, $tcx>, $K) -> $R,)\n+            output: ($($output)* ($name $K $V))\n         }\n     };\n \n     // The `multi` modifier indicates a **multiquery**, in which case\n-    // the function returns a `FxHashMap<K,V>` instead of just a value\n+    // the function returns a `Multi<K,V>` instead of just a value\n     // `V`.\n     (tcx: $tcx:tt,\n      input: (([multi $($other_modifiers:tt)*] $name:tt [$K:ty] [$V:ty]) $($input:tt)*),\n      output: $output:tt) => {\n         define_provider_struct! {\n             tcx: $tcx,\n-            ready: ($name [$K] [FxHashMap<$K,$V>]),\n+            ready: ($name [$K] [Multi<$K,$V>]),\n             input: ($($input)*),\n             output: $output\n         }\n@@ -778,7 +812,7 @@ define_maps! { <'tcx>\n     /// Fetch the MIR for a given def-id after a given pass has been executed. This is\n     /// **only** intended to be used by the `mir_suite` provider -- if you are using it\n     /// manually, you're doing it wrong.\n-    [] mir_pass: mir_pass((MirSuite, MirPassIndex, DefId)) -> &'tcx Steal<mir::Mir<'tcx>>,\n+    [multi] mir_pass: mir_pass((MirSuite, MirPassIndex, DefId)) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n     /// MIR after our optimization passes have run. This is MIR that is ready\n     /// for trans. This is also the only query that can fetch non-local MIR, at present."}, {"sha": "cd6b5f62edd2c6dbaf13f4ba19d3ccf3a8a4e334", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -929,7 +929,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n \n     // No lifetime analysis based on borrowing can be done from here on out.\n-    // passes.push_pass(MIR_OPTIMIZED, mir::transform::inline::Inline); // TODO re-enable\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::inline::Inline);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::instcombine::InstCombine);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::copy_prop::CopyPropagation);"}, {"sha": "ef271d8b836eba478115418a67493ccd5eb6a59c", "filename": "src/librustc_mir/callgraph.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Fcallgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Fcallgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fcallgraph.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -22,30 +22,31 @@ use rustc::ty;\n \n use rustc::util::nodemap::DefIdMap;\n \n+use transform::interprocedural::InterproceduralCx;\n+\n pub struct CallGraph {\n     node_map: DefIdMap<graph::NodeIndex>,\n     graph: graph::Graph<DefId, ()>\n }\n \n impl CallGraph {\n-    // FIXME: allow for construction of a callgraph that inspects\n-    // cross-crate MIRs if available.\n-    pub fn build<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>) -> CallGraph {\n+    pub fn build<'a, 'mir, 'tcx>(cx: &mut InterproceduralCx<'a, 'mir, 'tcx>) -> CallGraph {\n         let mut callgraph = CallGraph {\n             node_map: DefIdMap(),\n             graph: graph::Graph::new()\n         };\n \n-        for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n+        for &def_id in cx.tcx.mir_keys(LOCAL_CRATE).iter() {\n             let idx = callgraph.add_node(def_id);\n \n             let mut call_visitor = CallVisitor {\n                 caller: idx,\n                 graph: &mut callgraph\n             };\n \n-            let mir = tcx.item_mir(def_id);\n-            call_visitor.visit_mir(&mir);\n+            if let Some(mir) = cx.ensure_mir_and_read(def_id) {\n+                call_visitor.visit_mir(mir);\n+            }\n         }\n \n         callgraph"}, {"sha": "b895a21558594a0ea13d563b15eb10e99544ef54", "filename": "src/librustc_mir/transform/dump_mir.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdump_mir.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -15,10 +15,11 @@ use std::fmt;\n use std::fs::File;\n use std::io;\n \n+use rustc::hir::def_id::DefId;\n+use rustc::mir::Mir;\n+use rustc::mir::transform::{DefIdPass, MirCtxt, MirSource, PassHook};\n use rustc::session::config::{OutputFilenames, OutputType};\n use rustc::ty::TyCtxt;\n-use rustc::mir::Mir;\n-use rustc::mir::transform::{DefIdPass, PassHook, MirCtxt};\n use util as mir_util;\n \n pub struct Marker(pub &'static str);\n@@ -48,19 +49,26 @@ pub struct DumpMir;\n \n impl PassHook for DumpMir {\n     fn on_mir_pass<'a, 'tcx: 'a>(&self,\n-                             mir_cx: &MirCtxt<'a, 'tcx>,\n-                             mir: Option<&Mir<'tcx>>)\n+                                 mir_cx: &MirCtxt<'a, 'tcx>,\n+                                 mir: Option<(DefId, &Mir<'tcx>)>)\n     {\n         let tcx = mir_cx.tcx();\n         let suite = mir_cx.suite();\n         let pass_num = mir_cx.pass_num();\n         let pass = tcx.mir_passes.pass(suite, pass_num);\n         let name = &pass.name();\n-        let source = mir_cx.source();\n+        let source = match mir {\n+            None => mir_cx.source(),\n+            Some((def_id, _)) => {\n+                let id = tcx.hir.as_local_node_id(def_id)\n+                                .expect(\"mir source requires local def-id\");\n+                MirSource::from_node(tcx, id)\n+            }\n+        };\n         if mir_util::dump_enabled(tcx, name, source) {\n             let previous_mir;\n             let mir_to_dump = match mir {\n-                Some(m) => m,\n+                Some((_, m)) => m,\n                 None => {\n                     previous_mir = mir_cx.read_previous_mir();\n                     &*previous_mir"}, {"sha": "e10a91c6ec2e7afb4030cbf4612b62fece9a85e6", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -18,20 +18,22 @@ use rustc_data_structures::graph;\n \n use rustc::dep_graph::DepNode;\n use rustc::mir::*;\n-use rustc::mir::transform::{MirSource, Pass};\n+use rustc::mir::transform::{MirCtxt, MirSource, Pass, PassId};\n use rustc::mir::visit::*;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::maps::Multi;\n+use rustc::ty::steal::Steal;\n use rustc::ty::subst::{Subst,Substs};\n use rustc::util::nodemap::{DefIdSet};\n \n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n \n-use std::cell::{Ref, RefCell};\n use syntax::{attr};\n use syntax::abi::Abi;\n \n use callgraph;\n+use transform::interprocedural::InterproceduralCx;\n \n const DEFAULT_THRESHOLD: usize = 50;\n const HINT_THRESHOLD: usize = 100;\n@@ -44,25 +46,29 @@ const UNKNOWN_SIZE_COST: usize = 10;\n pub struct Inline;\n \n impl Pass for Inline {\n-    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 { return; }\n+    fn run_pass<'a, 'tcx: 'a>(&self, mir_cx: &MirCtxt<'a, 'tcx>)\n+                              -> Multi<PassId, &'tcx Steal<Mir<'tcx>>> {\n+        let tcx = mir_cx.tcx();\n+        if tcx.sess.opts.debugging_opts.mir_opt_level < 2 {\n+            return Multi::from(tcx.alloc_steal_mir(mir_cx.steal_previous_mir()));\n+        }\n \n-        let _ignore = tcx.dep_graph.in_ignore();\n+        let mut cx = InterproceduralCx::new(mir_cx);\n \n-        let callgraph = callgraph::CallGraph::build(tcx);\n+        let callgraph = callgraph::CallGraph::build(&mut cx);\n \n-        let mut inliner = Inliner {\n-            tcx: tcx,\n-        };\n+        let mut inliner = Inliner { tcx };\n \n         for scc in callgraph.scc_iter() {\n-            inliner.inline_scc(&callgraph, &scc);\n+            inliner.inline_scc(&mut cx, &callgraph, &scc);\n         }\n+\n+        Multi::from(cx.into_local_mirs())\n     }\n }\n \n-struct Inliner<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+struct Inliner<'mir, 'tcx: 'mir> {\n+    tcx: TyCtxt<'mir, 'tcx, 'tcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -74,16 +80,12 @@ struct CallSite<'tcx> {\n     location: SourceInfo,\n }\n \n-impl<'a, 'tcx> Inliner<'a, 'tcx> {\n-    fn maybe_item_mir(&mut self, _def_id: DefId) -> Option<Ref<'tcx, Mir<'tcx>>> {\n-        panic!() // TODO -- hook up inline into the system\n-    }\n-\n-    fn mir(&mut self, _def_id: DefId) -> &'tcx RefCell<Mir<'tcx>> {\n-        panic!() // TODO -- hook up inline into the system\n-    }\n-\n-    fn inline_scc(&mut self, callgraph: &callgraph::CallGraph, scc: &[graph::NodeIndex]) -> bool {\n+impl<'mir, 'tcx> Inliner<'mir, 'tcx> {\n+    fn inline_scc<'a>(&mut self,\n+                      cx: &mut InterproceduralCx<'a, 'mir, 'tcx>,\n+                      callgraph: &callgraph::CallGraph,\n+                      scc: &[graph::NodeIndex]) -> bool {\n+        let tcx = self.tcx;\n         let mut callsites = Vec::new();\n         let mut in_scc = DefIdSet();\n \n@@ -93,14 +95,14 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             let def_id = callgraph.def_id(node);\n \n             // Don't inspect functions from other crates\n-            let id = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+            let id = if let Some(id) = tcx.hir.as_local_node_id(def_id) {\n                 id\n             } else {\n                 continue;\n             };\n-            let src = MirSource::from_node(self.tcx, id);\n+            let src = MirSource::from_node(tcx, id);\n             if let MirSource::Fn(_) = src {\n-                if let Some(mir) = self.tcx.maybe_item_mir(def_id) {\n+                if let Some(mir) = cx.ensure_mir_and_read(def_id) {\n                     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n                         // Don't inline calls that are in cleanup blocks.\n                         if bb_data.is_cleanup { continue; }\n@@ -151,27 +153,27 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                 let callsite = callsites[csi];\n                 csi += 1;\n \n-                let _task = self.tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n-                self.tcx.dep_graph.write(DepNode::Mir(callsite.caller));\n+                let _task = tcx.dep_graph.in_task(DepNode::Mir(callsite.caller));\n+                tcx.dep_graph.write(DepNode::Mir(callsite.caller));\n \n                 let callee_mir = {\n-                    if let Some(callee_mir) = self.maybe_item_mir(callsite.callee) {\n+                    if let Some(callee_mir) = cx.ensure_mir_and_read(callsite.callee) {\n                         if !self.should_inline(callsite, &callee_mir) {\n                             continue;\n                         }\n \n-                        callee_mir.subst(self.tcx, callsite.substs)\n+                        callee_mir.subst(tcx, callsite.substs)\n                     } else {\n                         continue;\n                     }\n \n                 };\n \n-                let mut caller_mir = self.mir(callsite.caller).borrow_mut();\n+                let caller_mir = cx.mir_mut(callsite.caller);\n \n                 let start = caller_mir.basic_blocks().len();\n \n-                if !self.inline_call(callsite, &mut caller_mir, callee_mir) {\n+                if !self.inline_call(callsite, caller_mir, callee_mir) {\n                     continue;\n                 }\n \n@@ -216,21 +218,23 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         // Simplify functions we inlined into.\n         for def_id in inlined_into {\n-            let _task = self.tcx.dep_graph.in_task(DepNode::Mir(def_id));\n-            self.tcx.dep_graph.write(DepNode::Mir(def_id));\n+            let _task = tcx.dep_graph.in_task(DepNode::Mir(def_id));\n+            tcx.dep_graph.write(DepNode::Mir(def_id));\n \n-            let mut caller_mir = self.mir(def_id).borrow_mut();\n+            let caller_mir = cx.mir_mut(def_id);\n \n             debug!(\"Running simplify cfg on {:?}\", def_id);\n-            CfgSimplifier::new(&mut caller_mir).simplify();\n-            remove_dead_blocks(&mut caller_mir);\n+            CfgSimplifier::new(caller_mir).simplify();\n+            remove_dead_blocks(caller_mir);\n         }\n         changed\n     }\n \n-    fn should_inline(&self, callsite: CallSite<'tcx>,\n-                     callee_mir: &'a Mir<'tcx>) -> bool {\n-\n+    fn should_inline(&self,\n+                     callsite: CallSite<'tcx>,\n+                     callee_mir: &Mir<'tcx>)\n+                     -> bool\n+    {\n         let tcx = self.tcx;\n \n         // Don't inline closures that have captures\n@@ -382,10 +386,10 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         }\n     }\n \n-\n-    fn inline_call(&self, callsite: CallSite<'tcx>,\n-                             caller_mir: &mut Mir<'tcx>, mut callee_mir: Mir<'tcx>) -> bool {\n-\n+    fn inline_call(&self,\n+                   callsite: CallSite<'tcx>,\n+                   caller_mir: &mut Mir<'tcx>,\n+                   mut callee_mir: Mir<'tcx>) -> bool {\n         // Don't inline a function into itself\n         if callsite.caller == callsite.callee { return false; }\n "}, {"sha": "02d2b357e043e94bfbfe9e35e77543a5350553aa", "filename": "src/librustc_mir/transform/interprocedural.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finterprocedural.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -0,0 +1,100 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::Mir;\n+use rustc::mir::transform::{MirCtxt, PassId};\n+use rustc::ty::steal::Steal;\n+use rustc::ty::TyCtxt;\n+use rustc_data_structures::fx::FxHashMap;\n+\n+/// When writing inter-procedural analyses etc, we need to read (and\n+/// steal) the MIR for a number of def-ids at once, not all of which\n+/// are local. This little cache code attempts to remember what you've\n+/// stolen and so forth. It is more of a placeholder meant to get\n+/// inlining up and going again, and is probably going to need heavy\n+/// revision as we scale up to more interesting optimizations.\n+pub struct InterproceduralCx<'a, 'mir: 'a, 'tcx: 'mir> {\n+    pub tcx: TyCtxt<'mir, 'tcx, 'tcx>,\n+    pub mir_cx: &'a MirCtxt<'mir, 'tcx>,\n+    local_cache: FxHashMap<DefId, Mir<'tcx>>,\n+}\n+\n+impl<'a, 'mir, 'tcx> InterproceduralCx<'a, 'mir, 'tcx> {\n+    pub fn new(mir_cx: &'a MirCtxt<'mir, 'tcx>) -> Self {\n+        InterproceduralCx {\n+            mir_cx,\n+            tcx: mir_cx.tcx(),\n+            local_cache: FxHashMap::default(),\n+        }\n+    }\n+\n+    pub fn into_local_mirs(self) -> Vec<(PassId, &'tcx Steal<Mir<'tcx>>)> {\n+        let tcx = self.tcx;\n+        let suite = self.mir_cx.suite();\n+        let pass_num = self.mir_cx.pass_num();\n+        self.local_cache.into_iter()\n+                        .map(|(def_id, mir)| {\n+                            let mir = tcx.alloc_steal_mir(mir);\n+                            ((suite, pass_num, def_id), mir)\n+                        })\n+                        .collect()\n+    }\n+\n+    /// Ensures that the mir for `def_id` is available, if it can be\n+    /// made available.\n+    pub fn ensure_mir(&mut self, def_id: DefId) {\n+        if def_id.is_local() {\n+            self.ensure_mir_and_read(def_id);\n+        }\n+    }\n+\n+    /// Ensures that the mir for `def_id` is available and returns it if possible;\n+    /// returns `None` if this is a cross-crate MIR that is not\n+    /// available from metadata.\n+    pub fn ensure_mir_and_read(&mut self, def_id: DefId) -> Option<&Mir<'tcx>> {\n+        if def_id.is_local() {\n+            Some(self.mir_mut(def_id))\n+        } else {\n+            self.tcx.maybe_item_mir(def_id)\n+        }\n+    }\n+\n+    /// True if the local cache contains MIR for `def-id`.\n+    pub fn contains_mir(&self, def_id: DefId) -> bool {\n+        if def_id.is_local() {\n+            self.local_cache.contains_key(&def_id)\n+        } else {\n+            self.tcx.is_item_mir_available(def_id)\n+        }\n+    }\n+\n+    /// Reads the MIR for `def-id`. If the MIR is local, this will\n+    /// panic if you have not previously invoked `ensure_mir`.\n+    pub fn mir(&self, def_id: DefId) -> Option<&Mir<'tcx>> {\n+        if def_id.is_local() {\n+            match self.local_cache.get(&def_id) {\n+                Some(p) => Some(p),\n+                None => {\n+                    panic!(\"MIR for local def-id `{:?}` not previously ensured\", def_id)\n+                }\n+            }\n+        } else {\n+            self.tcx.maybe_item_mir(def_id)\n+        }\n+    }\n+\n+    pub fn mir_mut(&mut self, def_id: DefId) -> &mut Mir<'tcx> {\n+        assert!(def_id.is_local(), \"cannot get mutable mir of remote entry\");\n+        let mir_cx = self.mir_cx;\n+        self.local_cache.entry(def_id)\n+                        .or_insert_with(|| mir_cx.steal_previous_mir_of(def_id))\n+    }\n+}"}, {"sha": "81af7c239608545635045fd7f066290a00051940", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a26e966307226a62ad1e09247038182eb53053ab/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=a26e966307226a62ad1e09247038182eb53053ab", "patch": "@@ -10,10 +10,10 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::mir::Mir;\n-use rustc::mir::transform::{MirCtxt, MirPassIndex, MirSuite, MirSource, MIR_OPTIMIZED};\n+use rustc::mir::transform::{MirCtxt, MirPassIndex, MirSuite, MirSource, MIR_OPTIMIZED, PassId};\n use rustc::ty::steal::Steal;\n use rustc::ty::TyCtxt;\n-use rustc::ty::maps::Providers;\n+use rustc::ty::maps::{Multi, Providers};\n use std::cell::Ref;\n \n pub mod simplify_branches;\n@@ -29,6 +29,7 @@ pub mod deaggregator;\n pub mod instcombine;\n pub mod copy_prop;\n pub mod inline;\n+pub mod interprocedural;\n \n pub fn provide(providers: &mut Providers) {\n     self::qualify_consts::provide(providers);\n@@ -57,7 +58,7 @@ fn mir_suite<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n fn mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                       (suite, pass_num, def_id): (MirSuite, MirPassIndex, DefId))\n-                      -> &'tcx Steal<Mir<'tcx>>\n+                      -> Multi<PassId, &'tcx Steal<Mir<'tcx>>>\n {\n     let passes = &tcx.mir_passes;\n     let pass = passes.pass(suite, pass_num);\n@@ -69,11 +70,15 @@ fn mir_pass<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mir = pass.run_pass(&mir_ctxt);\n \n+    let key = &(suite, pass_num, def_id);\n     for hook in passes.hooks() {\n-        hook.on_mir_pass(&mir_ctxt, Some(&mir));\n+        for (&(_, _, k), v) in mir.iter(key) {\n+            let v = &v.borrow();\n+            hook.on_mir_pass(&mir_ctxt, Some((k, v)));\n+        }\n     }\n \n-    tcx.alloc_steal_mir(mir)\n+    mir\n }\n \n struct MirCtxtImpl<'a, 'tcx: 'a> {\n@@ -107,24 +112,32 @@ impl<'a, 'tcx> MirCtxt<'a, 'tcx> for MirCtxtImpl<'a, 'tcx> {\n     }\n \n     fn read_previous_mir(&self) -> Ref<'tcx, Mir<'tcx>> {\n-        self.previous_mir().borrow()\n+        self.previous_mir(self.def_id).borrow()\n     }\n \n     fn steal_previous_mir(&self) -> Mir<'tcx> {\n-        self.previous_mir().steal()\n+        self.previous_mir(self.def_id).steal()\n+    }\n+\n+    fn read_previous_mir_of(&self, def_id: DefId) -> Ref<'tcx, Mir<'tcx>> {\n+        self.previous_mir(def_id).borrow()\n+    }\n+\n+    fn steal_previous_mir_of(&self, def_id: DefId) -> Mir<'tcx> {\n+        self.previous_mir(def_id).steal()\n     }\n }\n \n impl<'a, 'tcx> MirCtxtImpl<'a, 'tcx> {\n-    fn previous_mir(&self) -> &'tcx Steal<Mir<'tcx>> {\n+    fn previous_mir(&self, def_id: DefId) -> &'tcx Steal<Mir<'tcx>> {\n         let MirSuite(suite) = self.suite;\n         let MirPassIndex(pass_num) = self.pass_num;\n         if pass_num > 0 {\n-            self.tcx.mir_pass((MirSuite(suite), MirPassIndex(pass_num - 1), self.def_id))\n+            self.tcx.mir_pass((MirSuite(suite), MirPassIndex(pass_num - 1), def_id))\n         } else if suite > 0 {\n-            self.tcx.mir_suite((MirSuite(suite - 1), self.def_id))\n+            self.tcx.mir_suite((MirSuite(suite - 1), def_id))\n         } else {\n-            self.tcx.mir_build(self.def_id)\n+            self.tcx.mir_build(def_id)\n         }\n     }\n }"}]}