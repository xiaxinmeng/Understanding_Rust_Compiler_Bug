{"sha": "75e0078a1703448a19e25eac85daaa5a4e6e68ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZTAwNzhhMTcwMzQ0OGExOWUyNWVhYzg1ZGFhYTVhNGU2ZTY4YWM=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-08T02:32:59Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-10-08T05:57:29Z"}, "message": "Optimize `TokenStreamBuilder::push`.\n\nCurrently, when two tokens must be glued together, this function duplicates\nlarge chunks of the existing streams. This can cause quadratic behaviour.\n\nThis commit changes the function so that it overwrites the last token with a\nglued token, which avoids the quadratic behaviour. This removes the need for\n`TokenStreamBuilder::push_all_but_{first,last}_tree`.\n\nThe commit also restructures `push` somewhat, by removing\n`TokenStream::{first_tree_and_joint,last_tree_if_joint}` in favour of more\npattern matching and some comments. This makes the code shorter, and in my\nopinion, more readable.", "tree": {"sha": "4ef94fc1c955d9e508684b8c2fe4854fa624c598", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ef94fc1c955d9e508684b8c2fe4854fa624c598"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75e0078a1703448a19e25eac85daaa5a4e6e68ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75e0078a1703448a19e25eac85daaa5a4e6e68ac", "html_url": "https://github.com/rust-lang/rust/commit/75e0078a1703448a19e25eac85daaa5a4e6e68ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75e0078a1703448a19e25eac85daaa5a4e6e68ac/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3832a634d3aa6a7c60448906e6656a22f7e35628", "url": "https://api.github.com/repos/rust-lang/rust/commits/3832a634d3aa6a7c60448906e6656a22f7e35628", "html_url": "https://github.com/rust-lang/rust/commit/3832a634d3aa6a7c60448906e6656a22f7e35628"}], "stats": {"total": 94, "additions": 43, "deletions": 51}, "files": [{"sha": "bef12ed4fadafc22d88d48a3670b3020651b1107", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 43, "deletions": 51, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/75e0078a1703448a19e25eac85daaa5a4e6e68ac/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75e0078a1703448a19e25eac85daaa5a4e6e68ac/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=75e0078a1703448a19e25eac85daaa5a4e6e68ac", "patch": "@@ -390,25 +390,6 @@ impl TokenStream {\n                     .collect())\n         }))\n     }\n-\n-    fn first_tree_and_joint(&self) -> Option<TreeAndJoint> {\n-        self.0.as_ref().map(|stream| {\n-            stream.first().unwrap().clone()\n-        })\n-    }\n-\n-    fn last_tree_if_joint(&self) -> Option<TokenTree> {\n-        match self.0 {\n-            None => None,\n-            Some(ref stream) => {\n-                if let (tree, Joint) = stream.last().unwrap() {\n-                    Some(tree.clone())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n-    }\n }\n \n // 99.5%+ of the time we have 1 or 2 elements in this vector.\n@@ -421,18 +402,49 @@ impl TokenStreamBuilder {\n     }\n \n     pub fn push<T: Into<TokenStream>>(&mut self, stream: T) {\n-        let stream = stream.into();\n-        let last_tree_if_joint = self.0.last().and_then(TokenStream::last_tree_if_joint);\n-        if let Some(TokenTree::Token(last_token)) = last_tree_if_joint {\n-            if let Some((TokenTree::Token(token), is_joint)) = stream.first_tree_and_joint() {\n-                if let Some(glued_tok) = last_token.glue(&token) {\n-                    let last_stream = self.0.pop().unwrap();\n-                    self.push_all_but_last_tree(&last_stream);\n-                    let glued_tt = TokenTree::Token(glued_tok);\n-                    let glued_tokenstream = TokenStream::new(vec![(glued_tt, is_joint)]);\n-                    self.0.push(glued_tokenstream);\n-                    self.push_all_but_first_tree(&stream);\n-                    return\n+        let mut stream = stream.into();\n+\n+        // If `self` is not empty and the last tree within the last stream is a\n+        // token tree marked with `Joint`...\n+        if let Some(TokenStream(Some(ref mut last_stream_lrc))) = self.0.last_mut() {\n+            if let Some((TokenTree::Token(last_token), Joint)) = last_stream_lrc.last() {\n+\n+                // ...and `stream` is not empty and the first tree within it is\n+                // a token tree...\n+                if let TokenStream(Some(ref mut stream_lrc)) = stream {\n+                    if let Some((TokenTree::Token(token), is_joint)) = stream_lrc.first() {\n+\n+                        // ...and the two tokens can be glued together...\n+                        if let Some(glued_tok) = last_token.glue(&token) {\n+\n+                            // ...then do so, by overwriting the last token\n+                            // tree in `self` and removing the first token tree\n+                            // from `stream`. This requires using `make_mut()`\n+                            // on the last stream in `self` and on `stream`,\n+                            // and in practice this doesn't cause cloning 99.9%\n+                            // of the time.\n+\n+                            // Overwrite the last token tree with the merged\n+                            // token.\n+                            let last_vec_mut = Lrc::make_mut(last_stream_lrc);\n+                            *last_vec_mut.last_mut().unwrap() =\n+                                (TokenTree::Token(glued_tok), *is_joint);\n+\n+                            // Remove the first token tree from `stream`. (This\n+                            // is almost always the only tree in `stream`.)\n+                            let stream_vec_mut = Lrc::make_mut(stream_lrc);\n+                            stream_vec_mut.remove(0);\n+\n+                            // Don't push `stream` if it's empty -- that could\n+                            // block subsequent token gluing, by getting\n+                            // between two token trees that should be glued\n+                            // together.\n+                            if !stream.is_empty() {\n+                                self.0.push(stream);\n+                            }\n+                            return;\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -442,26 +454,6 @@ impl TokenStreamBuilder {\n     pub fn build(self) -> TokenStream {\n         TokenStream::from_streams(self.0)\n     }\n-\n-    fn push_all_but_last_tree(&mut self, stream: &TokenStream) {\n-        if let Some(ref streams) = stream.0 {\n-            let len = streams.len();\n-            match len {\n-                1 => {}\n-                _ => self.0.push(TokenStream(Some(Lrc::new(streams[0 .. len - 1].to_vec())))),\n-            }\n-        }\n-    }\n-\n-    fn push_all_but_first_tree(&mut self, stream: &TokenStream) {\n-        if let Some(ref streams) = stream.0 {\n-            let len = streams.len();\n-            match len {\n-                1 => {}\n-                _ => self.0.push(TokenStream(Some(Lrc::new(streams[1 .. len].to_vec())))),\n-            }\n-        }\n-    }\n }\n \n #[derive(Clone)]"}]}