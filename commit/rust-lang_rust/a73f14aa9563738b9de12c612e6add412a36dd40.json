{"sha": "a73f14aa9563738b9de12c612e6add412a36dd40", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3M2YxNGFhOTU2MzczOGI5ZGUxMmM2MTJlNmFkZDQxMmEzNmRkNDA=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-04-20T01:24:45Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-04-20T01:24:45Z"}, "message": "Trivial refactoring in bin", "tree": {"sha": "9235993a26b8a1757377c4cd4f08c7c52e070511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9235993a26b8a1757377c4cd4f08c7c52e070511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a73f14aa9563738b9de12c612e6add412a36dd40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a73f14aa9563738b9de12c612e6add412a36dd40", "html_url": "https://github.com/rust-lang/rust/commit/a73f14aa9563738b9de12c612e6add412a36dd40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a73f14aa9563738b9de12c612e6add412a36dd40/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9532ba8d7ffec4bbd2698c048c383910fe714c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9532ba8d7ffec4bbd2698c048c383910fe714c4", "html_url": "https://github.com/rust-lang/rust/commit/f9532ba8d7ffec4bbd2698c048c383910fe714c4"}], "stats": {"total": 192, "additions": 100, "deletions": 92}, "files": [{"sha": "9411ccde41fccc8c9a54aefcb96623688997b78c", "filename": "src/bin/main.rs", "status": "modified", "additions": 100, "deletions": 92, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/a73f14aa9563738b9de12c612e6add412a36dd40/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a73f14aa9563738b9de12c612e6add412a36dd40/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=a73f14aa9563738b9de12c612e6add412a36dd40", "patch": "@@ -32,6 +32,39 @@ type FmtResult<T> = std::result::Result<T, FmtError>;\n \n const WRITE_MODE_LIST: &str = \"[replace|overwrite|display|plain|diff|coverage|checkstyle|check]\";\n \n+fn main() {\n+    env_logger::init();\n+    let opts = make_opts();\n+    // Only handles arguments passed in through the CLI.\n+    let write_mode = determine_write_mode(&opts);\n+\n+    let exit_code = match execute(&opts) {\n+        Ok(summary) => {\n+            if summary.has_operational_errors()\n+                || summary.has_diff && write_mode == WriteMode::Check\n+                || summary.has_parsing_errors() || summary.has_formatting_errors()\n+            {\n+                1\n+            } else {\n+                assert!(summary.has_no_errors());\n+                0\n+            }\n+        }\n+        Err(e) => {\n+            eprintln!(\"{}\", e.to_string());\n+            1\n+        }\n+    };\n+    // Make sure standard output is flushed before we exit.\n+    std::io::stdout().flush().unwrap();\n+\n+    // Exit with given exit code.\n+    //\n+    // NOTE: This immediately terminates the process without doing any cleanup,\n+    // so make sure to finish all necessary cleanup before this is called.\n+    std::process::exit(exit_code);\n+}\n+\n /// Rustfmt operations.\n enum Operation {\n     /// Format files and their child modules.\n@@ -277,78 +310,86 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             minimal_config_path,\n         } => {\n             let options = CliOptions::from_matches(&matches)?;\n+            format(files, config_path, minimal_config_path, options)\n+        }\n+    }\n+}\n \n-            for f in options.file_lines.files() {\n-                match *f {\n-                    FileName::Real(ref f) if files.contains(f) => {}\n-                    FileName::Real(_) => {\n-                        eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n-                    }\n-                    _ => eprintln!(\"Warning: Not a file '{}'\", f),\n-                }\n-            }\n-\n-            let mut config = Config::default();\n-            // Load the config path file if provided\n-            if let Some(config_file) = config_path.as_ref() {\n-                config = Config::from_toml_path(config_file.as_ref())?;\n-            };\n-\n-            if options.verbose {\n-                if let Some(path) = config_path.as_ref() {\n-                    println!(\"Using rustfmt config file {}\", path.display());\n-                }\n+fn format(\n+    files: Vec<PathBuf>,\n+    config_path: Option<PathBuf>,\n+    minimal_config_path: Option<String>,\n+    options: CliOptions,\n+) -> FmtResult<Summary> {\n+    for f in options.file_lines.files() {\n+        match *f {\n+            FileName::Real(ref f) if files.contains(f) => {}\n+            FileName::Real(_) => {\n+                eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n             }\n+            _ => eprintln!(\"Warning: Not a file '{}'\", f),\n+        }\n+    }\n \n-            let mut out = &mut stdout();\n-            checkstyle::output_header(&mut out, config.write_mode())?;\n-            let mut error_summary = Summary::default();\n+    let mut config = Config::default();\n+    // Load the config path file if provided\n+    if let Some(config_file) = config_path.as_ref() {\n+        config = Config::from_toml_path(config_file.as_ref())?;\n+    };\n \n-            for file in files {\n-                if !file.exists() {\n-                    eprintln!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n-                    error_summary.add_operational_error();\n-                } else if file.is_dir() {\n-                    eprintln!(\"Error: `{}` is a directory\", file.to_str().unwrap());\n-                    error_summary.add_operational_error();\n-                } else {\n-                    // Check the file directory if the config-path could not be read or not provided\n-                    if config_path.is_none() {\n-                        let (config_tmp, path_tmp) =\n-                            Config::from_resolved_toml_path(file.parent().unwrap())?;\n-                        if options.verbose {\n-                            if let Some(path) = path_tmp.as_ref() {\n-                                println!(\n-                                    \"Using rustfmt config file {} for {}\",\n-                                    path.display(),\n-                                    file.display()\n-                                );\n-                            }\n-                        }\n-                        config = config_tmp;\n-                    }\n+    if options.verbose {\n+        if let Some(path) = config_path.as_ref() {\n+            println!(\"Using rustfmt config file {}\", path.display());\n+        }\n+    }\n \n-                    if !config.version_meets_requirement(&mut error_summary) {\n-                        break;\n+    let mut out = &mut stdout();\n+    checkstyle::output_header(&mut out, config.write_mode())?;\n+    let mut error_summary = Summary::default();\n+\n+    for file in files {\n+        if !file.exists() {\n+            eprintln!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n+            error_summary.add_operational_error();\n+        } else if file.is_dir() {\n+            eprintln!(\"Error: `{}` is a directory\", file.to_str().unwrap());\n+            error_summary.add_operational_error();\n+        } else {\n+            // Check the file directory if the config-path could not be read or not provided\n+            if config_path.is_none() {\n+                let (config_tmp, path_tmp) =\n+                    Config::from_resolved_toml_path(file.parent().unwrap())?;\n+                if options.verbose {\n+                    if let Some(path) = path_tmp.as_ref() {\n+                        println!(\n+                            \"Using rustfmt config file {} for {}\",\n+                            path.display(),\n+                            file.display()\n+                        );\n                     }\n-\n-                    options.clone().apply_to(&mut config);\n-                    error_summary.add(run(Input::File(file), &config));\n                 }\n+                config = config_tmp;\n             }\n-            checkstyle::output_footer(&mut out, config.write_mode())?;\n \n-            // If we were given a path via dump-minimal-config, output any options\n-            // that were used during formatting as TOML.\n-            if let Some(path) = minimal_config_path {\n-                let mut file = File::create(path)?;\n-                let toml = config.used_options().to_toml()?;\n-                file.write_all(toml.as_bytes())?;\n+            if !config.version_meets_requirement(&mut error_summary) {\n+                break;\n             }\n \n-            Ok(error_summary)\n+            options.clone().apply_to(&mut config);\n+            error_summary.add(run(Input::File(file), &config));\n         }\n     }\n+    checkstyle::output_footer(&mut out, config.write_mode())?;\n+\n+    // If we were given a path via dump-minimal-config, output any options\n+    // that were used during formatting as TOML.\n+    if let Some(path) = minimal_config_path {\n+        let mut file = File::create(path)?;\n+        let toml = config.used_options().to_toml()?;\n+        file.write_all(toml.as_bytes())?;\n+    }\n+\n+    Ok(error_summary)\n }\n \n fn determine_write_mode(opts: &Options) -> WriteMode {\n@@ -360,39 +401,6 @@ fn determine_write_mode(opts: &Options) -> WriteMode {\n     }\n }\n \n-fn main() {\n-    env_logger::init();\n-    let opts = make_opts();\n-    // Only handles arguments passed in through the CLI.\n-    let write_mode = determine_write_mode(&opts);\n-\n-    let exit_code = match execute(&opts) {\n-        Ok(summary) => {\n-            if summary.has_operational_errors()\n-                || summary.has_diff && write_mode == WriteMode::Check\n-                || summary.has_parsing_errors() || summary.has_formatting_errors()\n-            {\n-                1\n-            } else {\n-                assert!(summary.has_no_errors());\n-                0\n-            }\n-        }\n-        Err(e) => {\n-            eprintln!(\"{}\", e.to_string());\n-            1\n-        }\n-    };\n-    // Make sure standard output is flushed before we exit.\n-    std::io::stdout().flush().unwrap();\n-\n-    // Exit with given exit code.\n-    //\n-    // NOTE: This immediately terminates the process without doing any cleanup,\n-    // so make sure to finish all necessary cleanup before this is called.\n-    std::process::exit(exit_code);\n-}\n-\n fn print_usage_to_stdout(opts: &Options, reason: &str) {\n     let sep = if reason.is_empty() {\n         String::new()"}]}