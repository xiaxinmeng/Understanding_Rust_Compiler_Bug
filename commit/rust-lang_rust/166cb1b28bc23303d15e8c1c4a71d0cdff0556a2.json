{"sha": "166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2NmNiMWIyOGJjMjMzMDNkMTVlOGMxYzRhNzFkMGNkZmYwNTU2YTI=", "commit": {"author": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-06T21:14:17Z"}, "committer": {"name": "Elliott Slaughter", "email": "eslaughter@mozilla.com", "date": "2012-08-08T19:21:25Z"}, "message": "rustc: Strict enforcement of glue function types.\n\nMake all glue functions take values by alias to remove the need for\nbitcasts at the top of every glue function. Use static type\ninformation to produce the correct type for glue functions so that\nLLVM can enforce the type system at call sites.", "tree": {"sha": "4ae431b8acacee03eb3e568cc1210104fefc6cf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ae431b8acacee03eb3e568cc1210104fefc6cf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "html_url": "https://github.com/rust-lang/rust/commit/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/comments", "author": null, "committer": null, "parents": [{"sha": "76d04af71a64e9c79ea21c8d4b956ef0591e3c61", "url": "https://api.github.com/repos/rust-lang/rust/commits/76d04af71a64e9c79ea21c8d4b956ef0591e3c61", "html_url": "https://github.com/rust-lang/rust/commit/76d04af71a64e9c79ea21c8d4b956ef0591e3c61"}], "stats": {"total": 178, "additions": 118, "deletions": 60}, "files": [{"sha": "ce6669f97999268ce759251cbd03a49b312532fb", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 101, "deletions": 54, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "patch": "@@ -546,18 +546,18 @@ fn make_generic_glue_inner(ccx: @crate_ctxt, t: ty::t,\n     let fcx = new_fn_ctxt(ccx, ~[], llfn, none);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     ccx.stats.n_glues_created += 1u;\n-    // Any nontrivial glue is with values passed *by alias*; this is a\n+    // All glue functions take values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n     // the caller has no idea if it's dealing with something that can be\n     // passed by value.\n-\n-    let llty = T_ptr(type_of(ccx, t));\n+    //\n+    // llfn is expected be declared to take a parameter of the appropriate\n+    // type, so we don't need to explicitly cast the function parameter.\n \n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n     let llrawptr0 = llvm::LLVMGetParam(llfn, 3u as c_uint);\n-    let llval0 = BitCast(bcx, llrawptr0, llty);\n-    helper(bcx, llval0, t);\n+    helper(bcx, llrawptr0, t);\n     finish_fn(fcx, lltop);\n     return llfn;\n }\n@@ -581,28 +581,44 @@ fn make_generic_glue(ccx: @crate_ctxt, t: ty::t, llfn: ValueRef,\n fn emit_tydescs(ccx: @crate_ctxt) {\n     let _icx = ccx.insn_ctxt(~\"emit_tydescs\");\n     for ccx.tydescs.each |key, val| {\n-        let glue_fn_ty = T_ptr(T_glue_fn(ccx));\n+        let glue_fn_ty = T_ptr(T_generic_glue_fn(ccx));\n         let ti = val;\n \n+        // Each of the glue functions needs to be cast to a generic type\n+        // before being put into the tydesc because we only have a singleton\n+        // tydesc type. Then we'll recast each function to its real type when\n+        // calling it.\n         let take_glue =\n             match copy ti.take_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => { ccx.stats.n_real_glues += 1u; v }\n+              some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n             };\n         let drop_glue =\n             match copy ti.drop_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => { ccx.stats.n_real_glues += 1u; v }\n+              some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n             };\n         let free_glue =\n             match copy ti.free_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => { ccx.stats.n_real_glues += 1u; v }\n+              some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n             };\n         let visit_glue =\n             match copy ti.visit_glue {\n               none => { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n-              some(v) => { ccx.stats.n_real_glues += 1u; v }\n+              some(v) => {\n+                ccx.stats.n_real_glues += 1u;\n+                llvm::LLVMConstPointerCast(v, glue_fn_ty)\n+              }\n             };\n \n         let shape = shape_of(ccx, key);\n@@ -692,20 +708,20 @@ fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n \n \n fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n-    // v is a pointer to the actual box component of the type here. The\n-    // ValueRef will have the wrong type here (make_generic_glue is casting\n-    // everything to a pointer to the type that the glue acts on).\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = bcx.insn_ctxt(~\"make_free_glue\");\n     let ccx = bcx.ccx();\n     let bcx = match ty::get(t).struct {\n       ty::ty_box(body_mt) => {\n-        let v = PointerCast(bcx, v, type_of(ccx, t));\n+        let v = Load(bcx, v);\n         let body = GEPi(bcx, v, ~[0u, abi::box_field_body]);\n+        // Cast away the addrspace of the box pointer.\n+        let body = PointerCast(bcx, body, T_ptr(type_of(ccx, body_mt.ty)));\n         let bcx = drop_ty(bcx, body, body_mt.ty);\n         trans_free(bcx, v)\n       }\n       ty::ty_opaque_box => {\n-        let v = PointerCast(bcx, v, type_of(ccx, t));\n+        let v = Load(bcx, v);\n         let td = Load(bcx, GEPi(bcx, v, ~[0u, abi::box_field_tydesc]));\n         let valptr = GEPi(bcx, v, ~[0u, abi::box_field_body]);\n         // Generate code that, dynamically, indexes into the\n@@ -715,7 +731,6 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n         trans_free(bcx, v)\n       }\n       ty::ty_uniq(content_mt) => {\n-        let v = PointerCast(bcx, v, type_of(ccx, t));\n         uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n@@ -785,7 +800,7 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       }\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) => {\n-        free_ty(bcx, Load(bcx, v0), t)\n+        free_ty(bcx, v0, t)\n       }\n       ty::ty_unboxed_vec(_) => {\n         tvec::make_drop_glue_unboxed(bcx, v0, t)\n@@ -861,14 +876,12 @@ fn decr_refcnt_maybe_free(bcx: block, box_ptr: ValueRef, t: ty::t) -> block {\n     let ccx = bcx.ccx();\n     maybe_validate_box(bcx, box_ptr);\n \n-    let llbox_ty = T_opaque_box_ptr(ccx);\n-    let box_ptr = PointerCast(bcx, box_ptr, llbox_ty);\n     do with_cond(bcx, IsNotNull(bcx, box_ptr)) |bcx| {\n         let rc_ptr = GEPi(bcx, box_ptr, ~[0u, abi::box_field_refcnt]);\n         let rc = Sub(bcx, Load(bcx, rc_ptr), C_int(ccx, 1));\n         Store(bcx, rc, rc_ptr);\n         let zero_test = ICmp(bcx, lib::llvm::IntEQ, C_int(ccx, 0), rc);\n-        with_cond(bcx, zero_test, |bcx| free_ty(bcx, box_ptr, t))\n+        with_cond(bcx, zero_test, |bcx| free_ty_immediate(bcx, box_ptr, t))\n     }\n }\n \n@@ -1097,17 +1110,16 @@ fn lazily_emit_all_tydesc_glue(ccx: @crate_ctxt,\n fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n                            ti: @tydesc_info) {\n     let _icx = ccx.insn_ctxt(~\"lazily_emit_tydesc_glue\");\n+    let llfnty = type_of_glue_fn(ccx, ti.ty);\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue {\n           some(_) => (),\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n-            let glue_fn = declare_generic_glue\n-                (ccx, ti.ty, T_glue_fn(ccx), ~\"take\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"take\");\n             ti.take_glue = some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn,\n-                              make_take_glue, ~\"take\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_take_glue, ~\"take\");\n             debug!{\"--- lazily_emit_tydesc_glue TAKE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n@@ -1118,11 +1130,9 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue DROP %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n-            let glue_fn =\n-                declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), ~\"drop\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"drop\");\n             ti.drop_glue = some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn,\n-                              make_drop_glue, ~\"drop\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_drop_glue, ~\"drop\");\n             debug!{\"--- lazily_emit_tydesc_glue DROP %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n@@ -1133,11 +1143,9 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue FREE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n-            let glue_fn =\n-                declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), ~\"free\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"free\");\n             ti.free_glue = some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn,\n-                              make_free_glue, ~\"free\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_free_glue, ~\"free\");\n             debug!{\"--- lazily_emit_tydesc_glue FREE %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n@@ -1148,11 +1156,9 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n           none => {\n             debug!{\"+++ lazily_emit_tydesc_glue VISIT %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n-            let glue_fn =\n-                declare_generic_glue(ccx, ti.ty, T_glue_fn(ccx), ~\"visit\");\n+            let glue_fn = declare_generic_glue(ccx, ti.ty, llfnty, ~\"visit\");\n             ti.visit_glue = some(glue_fn);\n-            make_generic_glue(ccx, ti.ty, glue_fn,\n-                              make_visit_glue, ~\"visit\");\n+            make_generic_glue(ccx, ti.ty, glue_fn, make_visit_glue, ~\"visit\");\n             debug!{\"--- lazily_emit_tydesc_glue VISIT %s\",\n                    ppaux::ty_to_str(ccx.tcx, ti.ty)};\n           }\n@@ -1161,43 +1167,63 @@ fn lazily_emit_tydesc_glue(ccx: @crate_ctxt, field: uint,\n }\n \n // See [Note-arg-mode]\n-fn call_tydesc_glue_full(++cx: block, v: ValueRef, tydesc: ValueRef,\n+fn call_tydesc_glue_full(++bcx: block, v: ValueRef, tydesc: ValueRef,\n                          field: uint, static_ti: option<@tydesc_info>) {\n-    let _icx = cx.insn_ctxt(~\"call_tydesc_glue_full\");\n-        if cx.unreachable { return; }\n+    let _icx = bcx.insn_ctxt(~\"call_tydesc_glue_full\");\n+        if bcx.unreachable { return; }\n+    let ccx = bcx.ccx();\n \n-    let mut static_glue_fn = none;\n-    match static_ti {\n-      none => {/* no-op */ }\n+    let static_glue_fn = match static_ti {\n+      none => none,\n       some(sti) => {\n-        lazily_emit_tydesc_glue(cx.ccx(), field, sti);\n+        lazily_emit_tydesc_glue(ccx, field, sti);\n         if field == abi::tydesc_field_take_glue {\n-            static_glue_fn = sti.take_glue;\n+            sti.take_glue\n         } else if field == abi::tydesc_field_drop_glue {\n-            static_glue_fn = sti.drop_glue;\n+            sti.drop_glue\n         } else if field == abi::tydesc_field_free_glue {\n-            static_glue_fn = sti.free_glue;\n+            sti.free_glue\n         } else if field == abi::tydesc_field_visit_glue {\n-            static_glue_fn = sti.visit_glue;\n+            sti.visit_glue\n+        } else {\n+            none\n         }\n       }\n-    }\n+    };\n+\n+    // When available, use static type info to give glue the right type.\n+    let static_glue_fn = match static_ti {\n+      none => none,\n+      some(sti) => {\n+        match static_glue_fn {\n+          none => none,\n+          some(sgf) => some(\n+              PointerCast(bcx, sgf, T_ptr(type_of_glue_fn(ccx, sti.ty))))\n+        }\n+      }\n+    };\n \n-    let llrawptr = PointerCast(cx, v, T_ptr(T_i8()));\n+    // When static type info is available, avoid casting parameter because the\n+    // function already has the right type. Otherwise cast to generic pointer.\n+    let llrawptr = if is_none(static_ti) || is_none(static_glue_fn) {\n+        PointerCast(bcx, v, T_ptr(T_i8()))\n+    } else {\n+        v\n+    };\n \n     let llfn = {\n         match static_glue_fn {\n           none => {\n             // Select out the glue function to call from the tydesc\n-            let llfnptr = GEPi(cx, tydesc, ~[0u, field]);\n-            Load(cx, llfnptr)\n+            let llfnptr = GEPi(bcx, tydesc, ~[0u, field]);\n+            Load(bcx, llfnptr)\n           }\n           some(sgf) => sgf\n         }\n     };\n \n-    Call(cx, llfn, ~[C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n-                    C_null(T_ptr(T_ptr(cx.ccx().tydesc_type))), llrawptr]);\n+    Call(bcx, llfn, ~[C_null(T_ptr(T_nil())), C_null(T_ptr(T_nil())),\n+                      C_null(T_ptr(T_ptr(bcx.ccx().tydesc_type))), llrawptr]);\n }\n \n // See [Note-arg-mode]\n@@ -1231,6 +1257,7 @@ fn call_cmp_glue(bcx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n }\n \n fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = cx.insn_ctxt(~\"take_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n@@ -1239,6 +1266,7 @@ fn take_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n }\n \n fn drop_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = cx.insn_ctxt(~\"drop_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_drop_glue);\n@@ -1252,7 +1280,7 @@ fn drop_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n       ty::ty_uniq(_) |\n       ty::ty_evec(_, ty::vstore_uniq) |\n       ty::ty_estr(ty::vstore_uniq) => {\n-        free_ty(bcx, v, t)\n+        free_ty_immediate(bcx, v, t)\n       }\n       ty::ty_box(_) | ty::ty_opaque_box |\n       ty::ty_evec(_, ty::vstore_box) |\n@@ -1284,13 +1312,32 @@ fn take_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> result {\n }\n \n fn free_ty(cx: block, v: ValueRef, t: ty::t) -> block {\n+    // NB: v is an *alias* of type t here, not a direct value.\n     let _icx = cx.insn_ctxt(~\"free_ty\");\n     if ty::type_needs_drop(cx.tcx(), t) {\n         return call_tydesc_glue(cx, v, t, abi::tydesc_field_free_glue);\n     }\n     return cx;\n }\n \n+fn free_ty_immediate(bcx: block, v: ValueRef, t: ty::t) -> block {\n+    let _icx = bcx.insn_ctxt(~\"free_ty_immediate\");\n+    match ty::get(t).struct {\n+      ty::ty_uniq(_) |\n+      ty::ty_evec(_, ty::vstore_uniq) |\n+      ty::ty_estr(ty::vstore_uniq) |\n+      ty::ty_box(_) | ty::ty_opaque_box |\n+      ty::ty_evec(_, ty::vstore_box) |\n+      ty::ty_estr(ty::vstore_box) |\n+      ty::ty_opaque_closure_ptr(_) => {\n+        let vp = alloca_zeroed(bcx, type_of(bcx.ccx(), t));\n+        Store(bcx, v, vp);\n+        free_ty(bcx, vp, t)\n+      }\n+      _ => bcx.tcx().sess.bug(~\"free_ty_immediate: non-box ty\")\n+    }\n+}\n+\n fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n                 n_bytes: ValueRef) {\n     // FIXME (Related to #1645, I think?): Provide LLVM with better"}, {"sha": "d5af4e181a756ce1d7e200a7ea26690689f1e90c", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "patch": "@@ -492,7 +492,7 @@ fn make_opaque_cbox_drop_glue(\n                                ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n       }\n       ty::ck_uniq => {\n-        free_ty(bcx, Load(bcx, cboxptr),\n+        free_ty(bcx, cboxptr,\n                 ty::mk_opaque_closure_ptr(bcx.tcx(), ck))\n       }\n     }\n@@ -501,7 +501,7 @@ fn make_opaque_cbox_drop_glue(\n fn make_opaque_cbox_free_glue(\n     bcx: block,\n     ck: ty::closure_kind,\n-    cbox: ValueRef)     // ptr to the opaque closure\n+    cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(~\"closure::make_opaque_cbox_free_glue\");\n     match ck {\n@@ -513,7 +513,7 @@ fn make_opaque_cbox_free_glue(\n     do with_cond(bcx, IsNotNull(bcx, cbox)) |bcx| {\n         // Load the type descr found in the cbox\n         let lltydescty = T_ptr(ccx.tydesc_type);\n-        let cbox = PointerCast(bcx, cbox, T_opaque_cbox_ptr(ccx));\n+        let cbox = Load(bcx, cbox);\n         let tydescptr = GEPi(bcx, cbox, ~[0u, abi::box_field_tydesc]);\n         let tydesc = Load(bcx, tydescptr);\n         let tydesc = PointerCast(bcx, tydesc, lltydescty);"}, {"sha": "20573eff4cce09b777376e1ca9cbac3d19e73116", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "patch": "@@ -655,7 +655,7 @@ fn T_tydesc_field(cx: @crate_ctxt, field: uint) -> TypeRef unsafe {\n     return t;\n }\n \n-fn T_glue_fn(cx: @crate_ctxt) -> TypeRef {\n+fn T_generic_glue_fn(cx: @crate_ctxt) -> TypeRef {\n     let s = ~\"glue_fn\";\n     match name_has_type(cx.tn, s) {\n       some(t) => return t,"}, {"sha": "94c48ace7497ed79de5ffbd5143e85f75d89ca06", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "patch": "@@ -175,10 +175,13 @@ fn trans_evec(bcx: block, elements: evec_elements,\n             let ty = ty::mk_evec(bcx.tcx(),\n                                  {ty: unit_ty, mutbl: ast::m_mutbl},\n                                  ty::vstore_fixed(count));\n+            let llty = T_ptr(type_of::type_of(bcx.ccx(), ty));\n \n             let n = C_uint(ccx, count);\n             let vp = base::arrayalloca(bcx, llunitty, n);\n-            add_clean(bcx, vp, ty);\n+            // Cast to the fake type we told cleanup to expect.\n+            let vp0 = BitCast(bcx, vp, llty);\n+            add_clean(bcx, vp0, ty);\n \n             let len = Mul(bcx, n, unit_sz);\n "}, {"sha": "06f3b179536af7aa2c6fd59bf2229040a3f5743b", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "patch": "@@ -10,6 +10,7 @@ export type_of_dtor;\n export type_of_explicit_args;\n export type_of_fn_from_ty;\n export type_of_fn;\n+export type_of_glue_fn;\n export type_of_non_gc_box;\n \n fn type_of_explicit_args(cx: @crate_ctxt,\n@@ -244,3 +245,9 @@ fn type_of_dtor(ccx: @crate_ctxt, self_ty: ty::t) -> TypeRef {\n          llvm::LLVMVoidType())\n }\n \n+fn type_of_glue_fn(ccx: @crate_ctxt, t: ty::t) -> TypeRef {\n+    let tydescpp = T_ptr(T_ptr(ccx.tydesc_type));\n+    let llty = T_ptr(type_of(ccx, t));\n+    return T_fn(~[T_ptr(T_nil()), T_ptr(T_nil()), tydescpp, llty],\n+                T_void());\n+}"}, {"sha": "e9374dbb05e82ba04537cc59354de41b2d10e6b3", "filename": "src/rustc/middle/trans/uniq.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/166cb1b28bc23303d15e8c1c4a71d0cdff0556a2/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Funiq.rs?ref=166cb1b28bc23303d15e8c1c4a71d0cdff0556a2", "patch": "@@ -7,9 +7,10 @@ import shape::llsize_of;\n \n export make_free_glue, autoderef, duplicate;\n \n-fn make_free_glue(bcx: block, vptr: ValueRef, t: ty::t)\n+fn make_free_glue(bcx: block, vptrptr: ValueRef, t: ty::t)\n     -> block {\n     let _icx = bcx.insn_ctxt(~\"uniq::make_free_glue\");\n+    let vptr = Load(bcx, vptrptr);\n     do with_cond(bcx, IsNotNull(bcx, vptr)) |bcx| {\n         let content_ty = content_ty(t);\n         let body_ptr = opaque_box_body(bcx, content_ty, vptr);"}]}