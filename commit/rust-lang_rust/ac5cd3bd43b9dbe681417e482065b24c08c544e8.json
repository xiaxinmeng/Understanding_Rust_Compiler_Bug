{"sha": "ac5cd3bd43b9dbe681417e482065b24c08c544e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNWNkM2JkNDNiOWRiZTY4MTQxN2U0ODIwNjViMjRjMDhjNTQ0ZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-01T11:58:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-01T11:58:02Z"}, "message": "Auto merge of #38745 - CannedYerins:llvm-code-style, r=rkruppe\n\nImprove naming style in rustllvm.\n\nAs per the LLVM style guide, use CamelCase for all locals and classes,\nand camelCase for all non-FFI functions.\nAlso, make names of variables of commonly used types more consistent.\n\nFixes #38688.\n\nr? @rkruppe", "tree": {"sha": "ba4a2b8364b56e26830284a78762d90b1a8b5b5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba4a2b8364b56e26830284a78762d90b1a8b5b5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac5cd3bd43b9dbe681417e482065b24c08c544e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac5cd3bd43b9dbe681417e482065b24c08c544e8", "html_url": "https://github.com/rust-lang/rust/commit/ac5cd3bd43b9dbe681417e482065b24c08c544e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac5cd3bd43b9dbe681417e482065b24c08c544e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1279a0b30a6a36822ecf7c7cc683953e1239745", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1279a0b30a6a36822ecf7c7cc683953e1239745", "html_url": "https://github.com/rust-lang/rust/commit/e1279a0b30a6a36822ecf7c7cc683953e1239745"}, {"sha": "e6f97114ca67ffcd55c81d990f1f239957eb6c00", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6f97114ca67ffcd55c81d990f1f239957eb6c00", "html_url": "https://github.com/rust-lang/rust/commit/e6f97114ca67ffcd55c81d990f1f239957eb6c00"}], "stats": {"total": 889, "additions": 446, "deletions": 443}, "files": [{"sha": "938f346e0bf82ff7756c4ac254889fbbb777a906", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ac5cd3bd43b9dbe681417e482065b24c08c544e8", "patch": "@@ -126,11 +126,11 @@ pub enum RustString_opaque {}\n pub type RustStringRef = *mut RustString_opaque;\n type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n-/// Appending to a Rust string -- used by raw_rust_string_ostream.\n+/// Appending to a Rust string -- used by RawRustStringOstream.\n #[no_mangle]\n-pub unsafe extern \"C\" fn rust_llvm_string_write_impl(sr: RustStringRef,\n-                                                     ptr: *const c_char,\n-                                                     size: size_t) {\n+pub unsafe extern \"C\" fn LLVMRustStringWriteImpl(sr: RustStringRef,\n+                                                 ptr: *const c_char,\n+                                                 size: size_t) {\n     let slice = slice::from_raw_parts(ptr as *const u8, size as usize);\n \n     let sr = sr as RustStringRepr;"}, {"sha": "f04251136f451831818aeeb3ff0c2d073ae57573", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 104, "deletions": 102, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=ac5cd3bd43b9dbe681417e482065b24c08c544e8", "patch": "@@ -17,32 +17,32 @@ using namespace llvm;\n using namespace llvm::object;\n \n struct RustArchiveMember {\n-  const char *filename;\n-  const char *name;\n-  Archive::Child child;\n+  const char *Filename;\n+  const char *Name;\n+  Archive::Child Child;\n \n   RustArchiveMember()\n-      : filename(nullptr), name(nullptr),\n+      : Filename(nullptr), Name(nullptr),\n #if LLVM_VERSION_GE(3, 8)\n-        child(nullptr, nullptr, nullptr)\n+        Child(nullptr, nullptr, nullptr)\n #else\n-        child(nullptr, nullptr)\n+        Child(nullptr, nullptr)\n #endif\n   {\n   }\n   ~RustArchiveMember() {}\n };\n \n struct RustArchiveIterator {\n-  bool first;\n-  Archive::child_iterator cur;\n-  Archive::child_iterator end;\n+  bool First;\n+  Archive::child_iterator Cur;\n+  Archive::child_iterator End;\n #if LLVM_VERSION_GE(3, 9)\n-  Error err;\n+  Error Err;\n \n-  RustArchiveIterator() : first(true), err(Error::success()) {}\n+  RustArchiveIterator() : First(true), Err(Error::success()) {}\n #else\n-  RustArchiveIterator() : first(true) {}\n+  RustArchiveIterator() : First(true) {}\n #endif\n };\n \n@@ -54,8 +54,8 @@ enum class LLVMRustArchiveKind {\n   COFF,\n };\n \n-static Archive::Kind from_rust(LLVMRustArchiveKind kind) {\n-  switch (kind) {\n+static Archive::Kind fromRust(LLVMRustArchiveKind Kind) {\n+  switch (Kind) {\n   case LLVMRustArchiveKind::GNU:\n     return Archive::K_GNU;\n   case LLVMRustArchiveKind::MIPS64:\n@@ -75,59 +75,61 @@ typedef Archive::Child *LLVMRustArchiveChildRef;\n typedef Archive::Child const *LLVMRustArchiveChildConstRef;\n typedef RustArchiveIterator *LLVMRustArchiveIteratorRef;\n \n-extern \"C\" LLVMRustArchiveRef LLVMRustOpenArchive(char *path) {\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or =\n-      MemoryBuffer::getFile(path, -1, false);\n-  if (!buf_or) {\n-    LLVMRustSetLastError(buf_or.getError().message().c_str());\n+extern \"C\" LLVMRustArchiveRef LLVMRustOpenArchive(char *Path) {\n+  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOr =\n+      MemoryBuffer::getFile(Path, -1, false);\n+  if (!BufOr) {\n+    LLVMRustSetLastError(BufOr.getError().message().c_str());\n     return nullptr;\n   }\n \n #if LLVM_VERSION_LE(3, 8)\n-  ErrorOr<std::unique_ptr<Archive>> archive_or =\n+  ErrorOr<std::unique_ptr<Archive>> ArchiveOr =\n #else\n-  Expected<std::unique_ptr<Archive>> archive_or =\n+  Expected<std::unique_ptr<Archive>> ArchiveOr =\n #endif\n-      Archive::create(buf_or.get()->getMemBufferRef());\n+      Archive::create(BufOr.get()->getMemBufferRef());\n \n-  if (!archive_or) {\n+  if (!ArchiveOr) {\n #if LLVM_VERSION_LE(3, 8)\n-    LLVMRustSetLastError(archive_or.getError().message().c_str());\n+    LLVMRustSetLastError(ArchiveOr.getError().message().c_str());\n #else\n-    LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n+    LLVMRustSetLastError(toString(ArchiveOr.takeError()).c_str());\n #endif\n     return nullptr;\n   }\n \n-  OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n-      std::move(archive_or.get()), std::move(buf_or.get()));\n+  OwningBinary<Archive> *Ret = new OwningBinary<Archive>(\n+      std::move(ArchiveOr.get()), std::move(BufOr.get()));\n \n-  return ret;\n+  return Ret;\n }\n \n-extern \"C\" void LLVMRustDestroyArchive(LLVMRustArchiveRef ar) { delete ar; }\n+extern \"C\" void LLVMRustDestroyArchive(LLVMRustArchiveRef RustArchive) {\n+  delete RustArchive;\n+}\n \n extern \"C\" LLVMRustArchiveIteratorRef\n-LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n-  Archive *ar = ra->getBinary();\n-  RustArchiveIterator *rai = new RustArchiveIterator();\n+LLVMRustArchiveIteratorNew(LLVMRustArchiveRef RustArchive) {\n+  Archive *Archive = RustArchive->getBinary();\n+  RustArchiveIterator *RAI = new RustArchiveIterator();\n #if LLVM_VERSION_LE(3, 8)\n-  rai->cur = ar->child_begin();\n+  RAI->Cur = Archive->child_begin();\n #else\n-  rai->cur = ar->child_begin(rai->err);\n-  if (rai->err) {\n-    LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-    delete rai;\n+  RAI->Cur = Archive->child_begin(RAI->Err);\n+  if (RAI->Err) {\n+    LLVMRustSetLastError(toString(std::move(RAI->Err)).c_str());\n+    delete RAI;\n     return nullptr;\n   }\n #endif\n-  rai->end = ar->child_end();\n-  return rai;\n+  RAI->End = Archive->child_end();\n+  return RAI;\n }\n \n extern \"C\" LLVMRustArchiveChildConstRef\n-LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n-  if (rai->cur == rai->end)\n+LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef RAI) {\n+  if (RAI->Cur == RAI->End)\n     return nullptr;\n \n   // Advancing the iterator validates the next child, and this can\n@@ -136,94 +138,94 @@ LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n   // the next child.\n   // This means we must not advance the iterator in the *first* call,\n   // but instead advance it *before* fetching the child in all later calls.\n-  if (!rai->first) {\n-    ++rai->cur;\n+  if (!RAI->First) {\n+    ++RAI->Cur;\n #if LLVM_VERSION_GE(3, 9)\n-    if (rai->err) {\n-      LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+    if (RAI->Err) {\n+      LLVMRustSetLastError(toString(std::move(RAI->Err)).c_str());\n       return nullptr;\n     }\n #endif\n   } else {\n-    rai->first = false;\n+    RAI->First = false;\n   }\n \n-  if (rai->cur == rai->end)\n+  if (RAI->Cur == RAI->End)\n     return nullptr;\n \n #if LLVM_VERSION_EQ(3, 8)\n-  const ErrorOr<Archive::Child> *cur = rai->cur.operator->();\n-  if (!*cur) {\n-    LLVMRustSetLastError(cur->getError().message().c_str());\n+  const ErrorOr<Archive::Child> *Cur = RAI->Cur.operator->();\n+  if (!*Cur) {\n+    LLVMRustSetLastError(Cur->getError().message().c_str());\n     return nullptr;\n   }\n-  const Archive::Child &child = cur->get();\n+  const Archive::Child &Child = Cur->get();\n #else\n-  const Archive::Child &child = *rai->cur.operator->();\n+  const Archive::Child &Child = *RAI->Cur.operator->();\n #endif\n-  Archive::Child *ret = new Archive::Child(child);\n+  Archive::Child *Ret = new Archive::Child(Child);\n \n-  return ret;\n+  return Ret;\n }\n \n-extern \"C\" void LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n-  delete child;\n+extern \"C\" void LLVMRustArchiveChildFree(LLVMRustArchiveChildRef Child) {\n+  delete Child;\n }\n \n-extern \"C\" void LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n-  delete rai;\n+extern \"C\" void LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef RAI) {\n+  delete RAI;\n }\n \n extern \"C\" const char *\n-LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {\n+LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef Child, size_t *Size) {\n #if LLVM_VERSION_GE(4, 0)\n-  Expected<StringRef> name_or_err = child->getName();\n-  if (!name_or_err) {\n-    // rustc_llvm currently doesn't use this error string, but it might be useful\n-    // in the future, and in the mean time this tells LLVM that the error was\n-    // not ignored and that it shouldn't abort the process.\n-    LLVMRustSetLastError(toString(name_or_err.takeError()).c_str());\n+  Expected<StringRef> NameOrErr = Child->getName();\n+  if (!NameOrErr) {\n+    // rustc_llvm currently doesn't use this error string, but it might be\n+    // useful in the future, and in the mean time this tells LLVM that the\n+    // error was not ignored and that it shouldn't abort the process.\n+    LLVMRustSetLastError(toString(NameOrErr.takeError()).c_str());\n     return nullptr;\n   }\n #else\n-  ErrorOr<StringRef> name_or_err = child->getName();\n-  if (name_or_err.getError())\n+  ErrorOr<StringRef> NameOrErr = Child->getName();\n+  if (NameOrErr.getError())\n     return nullptr;\n #endif\n-  StringRef name = name_or_err.get();\n-  *size = name.size();\n-  return name.data();\n+  StringRef Name = NameOrErr.get();\n+  *Size = Name.size();\n+  return Name.data();\n }\n \n-extern \"C\" const char *LLVMRustArchiveChildData(LLVMRustArchiveChildRef child,\n-                                                size_t *size) {\n-  StringRef buf;\n+extern \"C\" const char *LLVMRustArchiveChildData(LLVMRustArchiveChildRef Child,\n+                                                size_t *Size) {\n+  StringRef Buf;\n #if LLVM_VERSION_GE(4, 0)\n-  Expected<StringRef> buf_or_err = child->getBuffer();\n-  if (!buf_or_err) {\n-    LLVMRustSetLastError(toString(buf_or_err.takeError()).c_str());\n+  Expected<StringRef> BufOrErr = Child->getBuffer();\n+  if (!BufOrErr) {\n+    LLVMRustSetLastError(toString(BufOrErr.takeError()).c_str());\n     return nullptr;\n   }\n #else\n-  ErrorOr<StringRef> buf_or_err = child->getBuffer();\n-  if (buf_or_err.getError()) {\n-    LLVMRustSetLastError(buf_or_err.getError().message().c_str());\n+  ErrorOr<StringRef> BufOrErr = Child->getBuffer();\n+  if (BufOrErr.getError()) {\n+    LLVMRustSetLastError(BufOrErr.getError().message().c_str());\n     return nullptr;\n   }\n #endif\n-  buf = buf_or_err.get();\n-  *size = buf.size();\n-  return buf.data();\n+  Buf = BufOrErr.get();\n+  *Size = Buf.size();\n+  return Buf.data();\n }\n \n extern \"C\" LLVMRustArchiveMemberRef\n LLVMRustArchiveMemberNew(char *Filename, char *Name,\n-                         LLVMRustArchiveChildRef child) {\n+                         LLVMRustArchiveChildRef Child) {\n   RustArchiveMember *Member = new RustArchiveMember;\n-  Member->filename = Filename;\n-  Member->name = Name;\n-  if (child)\n-    Member->child = *child;\n+  Member->Filename = Filename;\n+  Member->Name = Name;\n+  if (Child)\n+    Member->Child = *Child;\n   return Member;\n }\n \n@@ -234,38 +236,38 @@ extern \"C\" void LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n extern \"C\" LLVMRustResult\n LLVMRustWriteArchive(char *Dst, size_t NumMembers,\n                      const LLVMRustArchiveMemberRef *NewMembers,\n-                     bool WriteSymbtab, LLVMRustArchiveKind rust_kind) {\n+                     bool WriteSymbtab, LLVMRustArchiveKind RustKind) {\n \n #if LLVM_VERSION_LE(3, 8)\n   std::vector<NewArchiveIterator> Members;\n #else\n   std::vector<NewArchiveMember> Members;\n #endif\n-  auto Kind = from_rust(rust_kind);\n+  auto Kind = fromRust(RustKind);\n \n-  for (size_t i = 0; i < NumMembers; i++) {\n-    auto Member = NewMembers[i];\n-    assert(Member->name);\n-    if (Member->filename) {\n+  for (size_t I = 0; I < NumMembers; I++) {\n+    auto Member = NewMembers[I];\n+    assert(Member->Name);\n+    if (Member->Filename) {\n #if LLVM_VERSION_GE(3, 9)\n       Expected<NewArchiveMember> MOrErr =\n-          NewArchiveMember::getFile(Member->filename, true);\n+          NewArchiveMember::getFile(Member->Filename, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;\n       }\n       Members.push_back(std::move(*MOrErr));\n #elif LLVM_VERSION_EQ(3, 8)\n-      Members.push_back(NewArchiveIterator(Member->filename));\n+      Members.push_back(NewArchiveIterator(Member->Filename));\n #else\n-      Members.push_back(NewArchiveIterator(Member->filename, Member->name));\n+      Members.push_back(NewArchiveIterator(Member->Filename, Member->Name));\n #endif\n     } else {\n #if LLVM_VERSION_LE(3, 8)\n-      Members.push_back(NewArchiveIterator(Member->child, Member->name));\n+      Members.push_back(NewArchiveIterator(Member->Child, Member->Name));\n #else\n       Expected<NewArchiveMember> MOrErr =\n-          NewArchiveMember::getOldMember(Member->child, true);\n+          NewArchiveMember::getOldMember(Member->Child, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;\n@@ -275,12 +277,12 @@ LLVMRustWriteArchive(char *Dst, size_t NumMembers,\n     }\n   }\n #if LLVM_VERSION_GE(3, 8)\n-  auto pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true, false);\n+  auto Pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true, false);\n #else\n-  auto pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true);\n+  auto Pair = writeArchive(Dst, Members, WriteSymbtab, Kind, true);\n #endif\n-  if (!pair.second)\n+  if (!Pair.second)\n     return LLVMRustResult::Success;\n-  LLVMRustSetLastError(pair.second.message().c_str());\n+  LLVMRustSetLastError(Pair.second.message().c_str());\n   return LLVMRustResult::Failure;\n }"}, {"sha": "c410a6b1349d68598d94bef86724d0cc325573d9", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=ac5cd3bd43b9dbe681417e482065b24c08c544e8", "patch": "@@ -64,8 +64,8 @@ enum class LLVMRustPassKind {\n   Module,\n };\n \n-static LLVMRustPassKind to_rust(PassKind kind) {\n-  switch (kind) {\n+static LLVMRustPassKind toRust(PassKind Kind) {\n+  switch (Kind) {\n   case PT_Function:\n     return LLVMRustPassKind::Function;\n   case PT_Module:\n@@ -86,17 +86,17 @@ extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n   return nullptr;\n }\n \n-extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef rust_pass) {\n-  assert(rust_pass);\n-  Pass *pass = unwrap(rust_pass);\n-  return to_rust(pass->getPassKind());\n+extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef RustPass) {\n+  assert(RustPass);\n+  Pass *Pass = unwrap(RustPass);\n+  return toRust(Pass->getPassKind());\n }\n \n-extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n-  assert(rust_pass);\n-  Pass *pass = unwrap(rust_pass);\n-  PassManagerBase *pm = unwrap(PM);\n-  pm->add(pass);\n+extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PMR, LLVMPassRef RustPass) {\n+  assert(RustPass);\n+  Pass *Pass = unwrap(RustPass);\n+  PassManagerBase *PMB = unwrap(PMR);\n+  PMB->add(Pass);\n }\n \n #ifdef LLVM_COMPONENT_X86\n@@ -167,7 +167,7 @@ GEN_SUBTARGETS\n #undef SUBTARGET\n \n extern \"C\" bool LLVMRustHasFeature(LLVMTargetMachineRef TM,\n-                                   const char *feature) {\n+                                   const char *Feature) {\n   TargetMachine *Target = unwrap(TM);\n   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n   const FeatureBitset &Bits = MCInfo->getFeatureBits();\n@@ -181,7 +181,7 @@ extern \"C\" bool LLVMRustHasFeature(LLVMTargetMachineRef TM,\n   GEN_SUBTARGETS { return false; }\n #undef SUBTARGET\n \n-  while (strcmp(feature, FeatureEntry->Key) != 0)\n+  while (strcmp(Feature, FeatureEntry->Key) != 0)\n     FeatureEntry++;\n \n   return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n@@ -197,8 +197,8 @@ enum class LLVMRustCodeModel {\n   Large,\n };\n \n-static CodeModel::Model from_rust(LLVMRustCodeModel model) {\n-  switch (model) {\n+static CodeModel::Model fromRust(LLVMRustCodeModel Model) {\n+  switch (Model) {\n   case LLVMRustCodeModel::Default:\n     return CodeModel::Default;\n   case LLVMRustCodeModel::JITDefault:\n@@ -224,8 +224,8 @@ enum class LLVMRustCodeGenOptLevel {\n   Aggressive,\n };\n \n-static CodeGenOpt::Level from_rust(LLVMRustCodeGenOptLevel level) {\n-  switch (level) {\n+static CodeGenOpt::Level fromRust(LLVMRustCodeGenOptLevel Level) {\n+  switch (Level) {\n   case LLVMRustCodeGenOptLevel::None:\n     return CodeGenOpt::None;\n   case LLVMRustCodeGenOptLevel::Less:\n@@ -289,9 +289,9 @@ extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef) {\n #endif\n \n extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n-    const char *triple, const char *cpu, const char *feature,\n-    LLVMRustCodeModel rust_CM, LLVMRelocMode Reloc,\n-    LLVMRustCodeGenOptLevel rust_OptLevel, bool UseSoftFloat,\n+    const char *TripleStr, const char *CPU, const char *Feature,\n+    LLVMRustCodeModel RustCM, LLVMRelocMode Reloc,\n+    LLVMRustCodeGenOptLevel RustOptLevel, bool UseSoftFloat,\n     bool PositionIndependentExecutable, bool FunctionSections,\n     bool DataSections) {\n \n@@ -300,8 +300,8 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n #else\n   Optional<Reloc::Model> RM;\n #endif\n-  auto CM = from_rust(rust_CM);\n-  auto OptLevel = from_rust(rust_OptLevel);\n+  auto CM = fromRust(RustCM);\n+  auto OptLevel = fromRust(RustOptLevel);\n \n   switch (Reloc) {\n   case LLVMRelocStatic:\n@@ -321,17 +321,17 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   }\n \n   std::string Error;\n-  Triple Trip(Triple::normalize(triple));\n+  Triple Trip(Triple::normalize(TripleStr));\n   const llvm::Target *TheTarget =\n       TargetRegistry::lookupTarget(Trip.getTriple(), Error);\n   if (TheTarget == nullptr) {\n     LLVMRustSetLastError(Error.c_str());\n     return nullptr;\n   }\n \n-  StringRef real_cpu = cpu;\n-  if (real_cpu == \"native\") {\n-    real_cpu = sys::getHostCPUName();\n+  StringRef RealCPU = CPU;\n+  if (RealCPU == \"native\") {\n+    RealCPU = sys::getHostCPUName();\n   }\n \n   TargetOptions Options;\n@@ -347,7 +347,7 @@ extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n   Options.FunctionSections = FunctionSections;\n \n   TargetMachine *TM = TheTarget->createTargetMachine(\n-      Trip.getTriple(), real_cpu, feature, Options, RM, CM, OptLevel);\n+      Trip.getTriple(), RealCPU, Feature, Options, RM, CM, OptLevel);\n   return wrap(TM);\n }\n \n@@ -367,45 +367,45 @@ extern \"C\" void LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n }\n \n extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n-    LLVMPassManagerBuilderRef PMB, LLVMRustCodeGenOptLevel OptLevel,\n+    LLVMPassManagerBuilderRef PMBR, LLVMRustCodeGenOptLevel OptLevel,\n     bool MergeFunctions, bool SLPVectorize, bool LoopVectorize) {\n   // Ignore mergefunc for now as enabling it causes crashes.\n-  // unwrap(PMB)->MergeFunctions = MergeFunctions;\n-  unwrap(PMB)->SLPVectorize = SLPVectorize;\n-  unwrap(PMB)->OptLevel = from_rust(OptLevel);\n-  unwrap(PMB)->LoopVectorize = LoopVectorize;\n+  // unwrap(PMBR)->MergeFunctions = MergeFunctions;\n+  unwrap(PMBR)->SLPVectorize = SLPVectorize;\n+  unwrap(PMBR)->OptLevel = fromRust(OptLevel);\n+  unwrap(PMBR)->LoopVectorize = LoopVectorize;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n // field of a PassManagerBuilder, we expose our own method of doing so.\n-extern \"C\" void LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n+extern \"C\" void LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMBR,\n                                               LLVMModuleRef M,\n                                               bool DisableSimplifyLibCalls) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n   TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n   if (DisableSimplifyLibCalls)\n     TLI->disableAllFunctions();\n-  unwrap(PMB)->LibraryInfo = TLI;\n+  unwrap(PMBR)->LibraryInfo = TLI;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to create the\n // TargetLibraryInfo pass, so we use this method to do so.\n-extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB, LLVMModuleRef M,\n+extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n                                        bool DisableSimplifyLibCalls) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n   TargetLibraryInfoImpl TLII(TargetTriple);\n   if (DisableSimplifyLibCalls)\n     TLII.disableAllFunctions();\n-  unwrap(PMB)->add(new TargetLibraryInfoWrapperPass(TLII));\n+  unwrap(PMR)->add(new TargetLibraryInfoWrapperPass(TLII));\n }\n \n // Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n // all the functions in a module, so we do that manually here. You'll find\n // similar code in clang's BackendUtil.cpp file.\n-extern \"C\" void LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM,\n+extern \"C\" void LLVMRustRunFunctionPassManager(LLVMPassManagerRef PMR,\n                                                LLVMModuleRef M) {\n   llvm::legacy::FunctionPassManager *P =\n-      unwrap<llvm::legacy::FunctionPassManager>(PM);\n+      unwrap<llvm::legacy::FunctionPassManager>(PMR);\n   P->doInitialization();\n \n   // Upgrade all calls to old intrinsics first.\n@@ -425,10 +425,10 @@ extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n   // check if they've already been initialized.  (This could happen if we're\n   // being called from rustpkg, for example). If the arguments change, then\n   // that's just kinda unfortunate.\n-  static bool initialized = false;\n-  if (initialized)\n+  static bool Initialized = false;\n+  if (Initialized)\n     return;\n-  initialized = true;\n+  Initialized = true;\n   cl::ParseCommandLineOptions(Argc, Argv);\n }\n \n@@ -438,8 +438,8 @@ enum class LLVMRustFileType {\n   ObjectFile,\n };\n \n-static TargetMachine::CodeGenFileType from_rust(LLVMRustFileType type) {\n-  switch (type) {\n+static TargetMachine::CodeGenFileType fromRust(LLVMRustFileType Type) {\n+  switch (Type) {\n   case LLVMRustFileType::AssemblyFile:\n     return TargetMachine::CGFT_AssemblyFile;\n   case LLVMRustFileType::ObjectFile:\n@@ -451,14 +451,14 @@ static TargetMachine::CodeGenFileType from_rust(LLVMRustFileType type) {\n \n extern \"C\" LLVMRustResult\n LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n-                        LLVMModuleRef M, const char *path,\n-                        LLVMRustFileType rust_FileType) {\n+                        LLVMModuleRef M, const char *Path,\n+                        LLVMRustFileType RustFileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n-  auto FileType = from_rust(rust_FileType);\n+  auto FileType = fromRust(RustFileType);\n \n   std::string ErrorInfo;\n   std::error_code EC;\n-  raw_fd_ostream OS(path, EC, sys::fs::F_None);\n+  raw_fd_ostream OS(Path, EC, sys::fs::F_None);\n   if (EC)\n     ErrorInfo = EC.message();\n   if (ErrorInfo != \"\") {\n@@ -477,12 +477,12 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n }\n \n extern \"C\" void LLVMRustPrintModule(LLVMPassManagerRef PMR, LLVMModuleRef M,\n-                                    const char *path) {\n+                                    const char *Path) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   std::string ErrorInfo;\n \n   std::error_code EC;\n-  raw_fd_ostream OS(path, EC, sys::fs::F_None);\n+  raw_fd_ostream OS(Path, EC, sys::fs::F_None);\n   if (EC)\n     ErrorInfo = EC.message();\n \n@@ -496,10 +496,10 @@ extern \"C\" void LLVMRustPrintModule(LLVMPassManagerRef PMR, LLVMModuleRef M,\n extern \"C\" void LLVMRustPrintPasses() {\n   LLVMInitializePasses();\n   struct MyListener : PassRegistrationListener {\n-    void passEnumerate(const PassInfo *info) {\n+    void passEnumerate(const PassInfo *Info) {\n #if LLVM_VERSION_GE(4, 0)\n-      StringRef PassArg = info->getPassArgument();\n-      StringRef PassName = info->getPassName();\n+      StringRef PassArg = Info->getPassArgument();\n+      StringRef PassName = Info->getPassName();\n       if (!PassArg.empty()) {\n         // These unsigned->signed casts could theoretically overflow, but\n         // realistically never will (and even if, the result is implementation\n@@ -508,37 +508,37 @@ extern \"C\" void LLVMRustPrintPasses() {\n                (int)PassName.size(), PassName.data());\n       }\n #else\n-      if (info->getPassArgument() && *info->getPassArgument()) {\n-        printf(\"%15s - %s\\n\", info->getPassArgument(), info->getPassName());\n+      if (Info->getPassArgument() && *Info->getPassArgument()) {\n+        printf(\"%15s - %s\\n\", Info->getPassArgument(), Info->getPassName());\n       }\n #endif\n     }\n-  } listener;\n+  } Listener;\n \n   PassRegistry *PR = PassRegistry::getPassRegistry();\n-  PR->enumerateWith(&listener);\n+  PR->enumerateWith(&Listener);\n }\n \n-extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB,\n+extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMBR,\n                                             bool AddLifetimes) {\n #if LLVM_VERSION_GE(4, 0)\n-  unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n+  unwrap(PMBR)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n #else\n-  unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n+  unwrap(PMBR)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n #endif\n }\n \n-extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols,\n-                                           size_t len) {\n+extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,\n+                                           size_t Len) {\n   llvm::legacy::PassManager passes;\n \n #if LLVM_VERSION_LE(3, 8)\n-  ArrayRef<const char *> ref(symbols, len);\n-  passes.add(llvm::createInternalizePass(ref));\n+  ArrayRef<const char *> Ref(Symbols, Len);\n+  passes.add(llvm::createInternalizePass(Ref));\n #else\n   auto PreserveFunctions = [=](const GlobalValue &GV) {\n-    for (size_t i = 0; i < len; i++) {\n-      if (GV.getName() == symbols[i]) {\n+    for (size_t I = 0; I < Len; I++) {\n+      if (GV.getName() == Symbols[I]) {\n         return true;\n       }\n     }"}, {"sha": "ea31e8dab678feddd63bb77a99ff0755822a5358", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 262, "deletions": 261, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=ac5cd3bd43b9dbe681417e482065b24c08c544e8", "patch": "@@ -30,7 +30,7 @@ using namespace llvm::object;\n \n // LLVMAtomicOrdering is already an enum - don't create another\n // one.\n-static AtomicOrdering from_rust(LLVMAtomicOrdering Ordering) {\n+static AtomicOrdering fromRust(LLVMAtomicOrdering Ordering) {\n   switch (Ordering) {\n   case LLVMAtomicOrderingNotAtomic:\n     return AtomicOrdering::NotAtomic;\n@@ -55,29 +55,29 @@ static char *LastError;\n \n extern \"C\" LLVMMemoryBufferRef\n LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or =\n+  ErrorOr<std::unique_ptr<MemoryBuffer>> BufOr =\n       MemoryBuffer::getFile(Path, -1, false);\n-  if (!buf_or) {\n-    LLVMRustSetLastError(buf_or.getError().message().c_str());\n+  if (!BufOr) {\n+    LLVMRustSetLastError(BufOr.getError().message().c_str());\n     return nullptr;\n   }\n-  return wrap(buf_or.get().release());\n+  return wrap(BufOr.get().release());\n }\n \n extern \"C\" char *LLVMRustGetLastError(void) {\n-  char *ret = LastError;\n+  char *Ret = LastError;\n   LastError = nullptr;\n-  return ret;\n+  return Ret;\n }\n \n-void LLVMRustSetLastError(const char *err) {\n+void LLVMRustSetLastError(const char *Err) {\n   free((void *)LastError);\n-  LastError = strdup(err);\n+  LastError = strdup(Err);\n }\n \n extern \"C\" void LLVMRustSetNormalizedTarget(LLVMModuleRef M,\n-                                            const char *triple) {\n-  unwrap(M)->setTargetTriple(Triple::normalize(triple));\n+                                            const char *Triple) {\n+  unwrap(M)->setTargetTriple(Triple::normalize(Triple));\n }\n \n extern \"C\" void LLVMRustPrintPassTimings() {\n@@ -106,8 +106,8 @@ extern \"C\" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n-static Attribute::AttrKind from_rust(LLVMRustAttribute kind) {\n-  switch (kind) {\n+static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n+  switch (Kind) {\n   case AlwaysInline:\n     return Attribute::AlwaysInline;\n   case ByVal:\n@@ -153,63 +153,63 @@ static Attribute::AttrKind from_rust(LLVMRustAttribute kind) {\n   }\n }\n \n-extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index,\n-                                             LLVMRustAttribute attr) {\n+extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned Index,\n+                                             LLVMRustAttribute RustAttr) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n-  Attribute Attr = Attribute::get(Call->getContext(), from_rust(attr));\n+  Attribute Attr = Attribute::get(Call->getContext(), fromRust(RustAttr));\n   AttrBuilder B(Attr);\n   Call.setAttributes(Call.getAttributes().addAttributes(\n-      Call->getContext(), index,\n-      AttributeSet::get(Call->getContext(), index, B)));\n+      Call->getContext(), Index,\n+      AttributeSet::get(Call->getContext(), Index, B)));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n-                                                       unsigned index,\n-                                                       uint64_t bytes) {\n+                                                       unsigned Index,\n+                                                       uint64_t Bytes) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n-  B.addDereferenceableAttr(bytes);\n+  B.addDereferenceableAttr(Bytes);\n   Call.setAttributes(Call.getAttributes().addAttributes(\n-      Call->getContext(), index,\n-      AttributeSet::get(Call->getContext(), index, B)));\n+      Call->getContext(), Index,\n+      AttributeSet::get(Call->getContext(), Index, B)));\n }\n \n-extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned index,\n-                                             LLVMRustAttribute attr) {\n+extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned Index,\n+                                             LLVMRustAttribute RustAttr) {\n   Function *A = unwrap<Function>(Fn);\n-  Attribute Attr = Attribute::get(A->getContext(), from_rust(attr));\n+  Attribute Attr = Attribute::get(A->getContext(), fromRust(RustAttr));\n   AttrBuilder B(Attr);\n-  A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n+  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned index,\n-                                               uint64_t bytes) {\n+extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned Index,\n+                                               uint64_t Bytes) {\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n-  B.addDereferenceableAttr(bytes);\n-  A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n+  B.addDereferenceableAttr(Bytes);\n+  A->addAttributes(Index, AttributeSet::get(A->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n-                                                   unsigned index,\n+                                                   unsigned Index,\n                                                    const char *Name,\n                                                    const char *Value) {\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAttribute(Name, Value);\n-  F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n+  F->addAttributes(Index, AttributeSet::get(F->getContext(), Index, B));\n }\n \n extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n-                                                 unsigned index,\n-                                                 LLVMRustAttribute attr) {\n+                                                 unsigned Index,\n+                                                 LLVMRustAttribute RustAttr) {\n   Function *F = unwrap<Function>(Fn);\n   const AttributeSet PAL = F->getAttributes();\n-  Attribute Attr = Attribute::get(F->getContext(), from_rust(attr));\n+  Attribute Attr = Attribute::get(F->getContext(), fromRust(RustAttr));\n   AttrBuilder B(Attr);\n-  const AttributeSet PALnew = PAL.removeAttributes(\n-      F->getContext(), index, AttributeSet::get(F->getContext(), index, B));\n-  F->setAttributes(PALnew);\n+  const AttributeSet PALNew = PAL.removeAttributes(\n+      F->getContext(), Index, AttributeSet::get(F->getContext(), Index, B));\n+  F->setAttributes(PALNew);\n }\n \n // enable fpmath flag UnsafeAlgebra\n@@ -220,35 +220,35 @@ extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef source, const char *Name,\n-                        LLVMAtomicOrdering order, unsigned alignment) {\n-  LoadInst *li = new LoadInst(unwrap(source), 0);\n-  li->setAtomic(from_rust(order));\n-  li->setAlignment(alignment);\n-  return wrap(unwrap(B)->Insert(li, Name));\n+LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef Source, const char *Name,\n+                        LLVMAtomicOrdering Order, unsigned Alignment) {\n+  LoadInst *LI = new LoadInst(unwrap(Source), 0);\n+  LI->setAtomic(fromRust(Order));\n+  LI->setAlignment(Alignment);\n+  return wrap(unwrap(B)->Insert(LI, Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n-                                                 LLVMValueRef val,\n-                                                 LLVMValueRef target,\n-                                                 LLVMAtomicOrdering order,\n-                                                 unsigned alignment) {\n-  StoreInst *si = new StoreInst(unwrap(val), unwrap(target));\n-  si->setAtomic(from_rust(order));\n-  si->setAlignment(alignment);\n-  return wrap(unwrap(B)->Insert(si));\n+                                                 LLVMValueRef V,\n+                                                 LLVMValueRef Target,\n+                                                 LLVMAtomicOrdering Order,\n+                                                 unsigned Alignment) {\n+  StoreInst *SI = new StoreInst(unwrap(V), unwrap(Target));\n+  SI->setAtomic(fromRust(Order));\n+  SI->setAlignment(Alignment);\n+  return wrap(unwrap(B)->Insert(SI));\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef target,\n-                           LLVMValueRef old, LLVMValueRef source,\n-                           LLVMAtomicOrdering order,\n-                           LLVMAtomicOrdering failure_order, LLVMBool weak) {\n-  AtomicCmpXchgInst *acxi = unwrap(B)->CreateAtomicCmpXchg(\n-      unwrap(target), unwrap(old), unwrap(source), from_rust(order),\n-      from_rust(failure_order));\n-  acxi->setWeak(weak);\n-  return wrap(acxi);\n+LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef Target,\n+                           LLVMValueRef Old, LLVMValueRef Source,\n+                           LLVMAtomicOrdering Order,\n+                           LLVMAtomicOrdering FailureOrder, LLVMBool Weak) {\n+  AtomicCmpXchgInst *ACXI = unwrap(B)->CreateAtomicCmpXchg(\n+      unwrap(Target), unwrap(Old), unwrap(Source), fromRust(Order),\n+      fromRust(FailureOrder));\n+  ACXI->setWeak(Weak);\n+  return wrap(ACXI);\n }\n \n enum class LLVMRustSynchronizationScope {\n@@ -257,8 +257,8 @@ enum class LLVMRustSynchronizationScope {\n   CrossThread,\n };\n \n-static SynchronizationScope from_rust(LLVMRustSynchronizationScope scope) {\n-  switch (scope) {\n+static SynchronizationScope fromRust(LLVMRustSynchronizationScope Scope) {\n+  switch (Scope) {\n   case LLVMRustSynchronizationScope::SingleThread:\n     return SingleThread;\n   case LLVMRustSynchronizationScope::CrossThread:\n@@ -269,9 +269,9 @@ static SynchronizationScope from_rust(LLVMRustSynchronizationScope scope) {\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering order,\n-                         LLVMRustSynchronizationScope scope) {\n-  return wrap(unwrap(B)->CreateFence(from_rust(order), from_rust(scope)));\n+LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering Order,\n+                         LLVMRustSynchronizationScope Scope) {\n+  return wrap(unwrap(B)->CreateFence(fromRust(Order), fromRust(Scope)));\n }\n \n extern \"C\" void LLVMRustSetDebug(int Enabled) {\n@@ -286,8 +286,8 @@ enum class LLVMRustAsmDialect {\n   Intel,\n };\n \n-static InlineAsm::AsmDialect from_rust(LLVMRustAsmDialect dialect) {\n-  switch (dialect) {\n+static InlineAsm::AsmDialect fromRust(LLVMRustAsmDialect Dialect) {\n+  switch (Dialect) {\n   case LLVMRustAsmDialect::Att:\n     return InlineAsm::AD_ATT;\n   case LLVMRustAsmDialect::Intel:\n@@ -303,7 +303,7 @@ extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString,\n                                           LLVMBool IsAlignStack,\n                                           LLVMRustAsmDialect Dialect) {\n   return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString, Constraints,\n-                             HasSideEffects, IsAlignStack, from_rust(Dialect)));\n+                             HasSideEffects, IsAlignStack, fromRust(Dialect)));\n }\n \n typedef DIBuilder *LLVMRustDIBuilderRef;\n@@ -318,13 +318,13 @@ inline Metadata **unwrap(LLVMRustMetadataRef *Vals) {\n }\n }\n \n-template <typename DIT> DIT *unwrapDIptr(LLVMRustMetadataRef ref) {\n-  return (DIT *)(ref ? unwrap<MDNode>(ref) : nullptr);\n+template <typename DIT> DIT *unwrapDIPtr(LLVMRustMetadataRef Ref) {\n+  return (DIT *)(Ref ? unwrap<MDNode>(Ref) : nullptr);\n }\n \n #define DIDescriptor DIScope\n #define DIArray DINodeArray\n-#define unwrapDI unwrapDIptr\n+#define unwrapDI unwrapDIPtr\n \n // These values **must** match debuginfo::DIFlags! They also *happen*\n // to match LLVM, but that isn't required as we do giant sets of\n@@ -351,90 +351,90 @@ enum class LLVMRustDIFlags : uint32_t {\n   // version we support!\n };\n \n-inline LLVMRustDIFlags operator&(LLVMRustDIFlags a, LLVMRustDIFlags b) {\n-  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) &\n-                                      static_cast<uint32_t>(b));\n+inline LLVMRustDIFlags operator&(LLVMRustDIFlags A, LLVMRustDIFlags B) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(A) &\n+                                      static_cast<uint32_t>(B));\n }\n \n-inline LLVMRustDIFlags operator|(LLVMRustDIFlags a, LLVMRustDIFlags b) {\n-  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) |\n-                                      static_cast<uint32_t>(b));\n+inline LLVMRustDIFlags operator|(LLVMRustDIFlags A, LLVMRustDIFlags B) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(A) |\n+                                      static_cast<uint32_t>(B));\n }\n \n-inline LLVMRustDIFlags &operator|=(LLVMRustDIFlags &a, LLVMRustDIFlags b) {\n-  return a = a | b;\n+inline LLVMRustDIFlags &operator|=(LLVMRustDIFlags &A, LLVMRustDIFlags B) {\n+  return A = A | B;\n }\n \n-inline bool is_set(LLVMRustDIFlags f) { return f != LLVMRustDIFlags::FlagZero; }\n+inline bool isSet(LLVMRustDIFlags F) { return F != LLVMRustDIFlags::FlagZero; }\n \n-inline LLVMRustDIFlags visibility(LLVMRustDIFlags f) {\n-  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(f) & 0x3);\n+inline LLVMRustDIFlags visibility(LLVMRustDIFlags F) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(F) & 0x3);\n }\n \n #if LLVM_VERSION_GE(4, 0)\n-static DINode::DIFlags from_rust(LLVMRustDIFlags flags) {\n-  DINode::DIFlags result = DINode::DIFlags::FlagZero;\n+static DINode::DIFlags fromRust(LLVMRustDIFlags Flags) {\n+  DINode::DIFlags Result = DINode::DIFlags::FlagZero;\n #else\n-static unsigned from_rust(LLVMRustDIFlags flags) {\n-  unsigned result = 0;\n+static unsigned fromRust(LLVMRustDIFlags Flags) {\n+  unsigned Result = 0;\n #endif\n \n-  switch (visibility(flags)) {\n+  switch (visibility(Flags)) {\n   case LLVMRustDIFlags::FlagPrivate:\n-    result |= DINode::DIFlags::FlagPrivate;\n+    Result |= DINode::DIFlags::FlagPrivate;\n     break;\n   case LLVMRustDIFlags::FlagProtected:\n-    result |= DINode::DIFlags::FlagProtected;\n+    Result |= DINode::DIFlags::FlagProtected;\n     break;\n   case LLVMRustDIFlags::FlagPublic:\n-    result |= DINode::DIFlags::FlagPublic;\n+    Result |= DINode::DIFlags::FlagPublic;\n     break;\n   default:\n     // The rest are handled below\n     break;\n   }\n \n-  if (is_set(flags & LLVMRustDIFlags::FlagFwdDecl)) {\n-    result |= DINode::DIFlags::FlagFwdDecl;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagFwdDecl)) {\n+    Result |= DINode::DIFlags::FlagFwdDecl;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagAppleBlock)) {\n-    result |= DINode::DIFlags::FlagAppleBlock;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagAppleBlock)) {\n+    Result |= DINode::DIFlags::FlagAppleBlock;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagBlockByrefStruct)) {\n-    result |= DINode::DIFlags::FlagBlockByrefStruct;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagBlockByrefStruct)) {\n+    Result |= DINode::DIFlags::FlagBlockByrefStruct;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagVirtual)) {\n-    result |= DINode::DIFlags::FlagVirtual;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagVirtual)) {\n+    Result |= DINode::DIFlags::FlagVirtual;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagArtificial)) {\n-    result |= DINode::DIFlags::FlagArtificial;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagArtificial)) {\n+    Result |= DINode::DIFlags::FlagArtificial;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagExplicit)) {\n-    result |= DINode::DIFlags::FlagExplicit;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagExplicit)) {\n+    Result |= DINode::DIFlags::FlagExplicit;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagPrototyped)) {\n-    result |= DINode::DIFlags::FlagPrototyped;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagPrototyped)) {\n+    Result |= DINode::DIFlags::FlagPrototyped;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagObjcClassComplete)) {\n-    result |= DINode::DIFlags::FlagObjcClassComplete;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagObjcClassComplete)) {\n+    Result |= DINode::DIFlags::FlagObjcClassComplete;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagObjectPointer)) {\n-    result |= DINode::DIFlags::FlagObjectPointer;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagObjectPointer)) {\n+    Result |= DINode::DIFlags::FlagObjectPointer;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagVector)) {\n-    result |= DINode::DIFlags::FlagVector;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagVector)) {\n+    Result |= DINode::DIFlags::FlagVector;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagStaticMember)) {\n-    result |= DINode::DIFlags::FlagStaticMember;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagStaticMember)) {\n+    Result |= DINode::DIFlags::FlagStaticMember;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagLValueReference)) {\n-    result |= DINode::DIFlags::FlagLValueReference;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagLValueReference)) {\n+    Result |= DINode::DIFlags::FlagLValueReference;\n   }\n-  if (is_set(flags & LLVMRustDIFlags::FlagRValueReference)) {\n-    result |= DINode::DIFlags::FlagRValueReference;\n+  if (isSet(Flags & LLVMRustDIFlags::FlagRValueReference)) {\n+    Result |= DINode::DIFlags::FlagRValueReference;\n   }\n \n-  return result;\n+  return Result;\n }\n \n extern \"C\" uint32_t LLVMRustDebugMetadataVersion() {\n@@ -445,9 +445,9 @@ extern \"C\" uint32_t LLVMRustVersionMinor() { return LLVM_VERSION_MINOR; }\n \n extern \"C\" uint32_t LLVMRustVersionMajor() { return LLVM_VERSION_MAJOR; }\n \n-extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M, const char *name,\n-                                      uint32_t value) {\n-  unwrap(M)->addModuleFlag(Module::Warning, name, value);\n+extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M, const char *Name,\n+                                      uint32_t Value) {\n+  unwrap(M)->addModuleFlag(Module::Warning, Name, Value);\n }\n \n extern \"C\" LLVMRustDIBuilderRef LLVMRustDIBuilderCreate(LLVMModuleRef M) {\n@@ -490,25 +490,25 @@ LLVMRustDIBuilderCreateSubroutineType(LLVMRustDIBuilderRef Builder,\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n     const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n-    LLVMRustMetadataRef Ty, bool isLocalToUnit, bool isDefinition,\n-    unsigned ScopeLine, LLVMRustDIFlags Flags, bool isOptimized,\n+    LLVMRustMetadataRef Ty, bool IsLocalToUnit, bool IsDefinition,\n+    unsigned ScopeLine, LLVMRustDIFlags Flags, bool IsOptimized,\n     LLVMValueRef Fn, LLVMRustMetadataRef TParam, LLVMRustMetadataRef Decl) {\n #if LLVM_VERSION_GE(3, 8)\n   DITemplateParameterArray TParams =\n       DITemplateParameterArray(unwrap<MDTuple>(TParam));\n   DISubprogram *Sub = Builder->createFunction(\n       unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n-      LineNo, unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition,\n-      ScopeLine, from_rust(Flags), isOptimized, TParams,\n-      unwrapDIptr<DISubprogram>(Decl));\n+      LineNo, unwrapDI<DISubroutineType>(Ty), IsLocalToUnit, IsDefinition,\n+      ScopeLine, fromRust(Flags), IsOptimized, TParams,\n+      unwrapDIPtr<DISubprogram>(Decl));\n   unwrap<Function>(Fn)->setSubprogram(Sub);\n   return wrap(Sub);\n #else\n   return wrap(Builder->createFunction(\n       unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n-      LineNo, unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition,\n-      ScopeLine, from_rust(Flags), isOptimized, unwrap<Function>(Fn),\n-      unwrapDIptr<MDNode>(TParam), unwrapDIptr<MDNode>(Decl)));\n+      LineNo, unwrapDI<DISubroutineType>(Ty), IsLocalToUnit, IsDefinition,\n+      ScopeLine, fromRust(Flags), IsOptimized, unwrap<Function>(Fn),\n+      unwrapDIPtr<MDNode>(TParam), unwrapDIPtr<MDNode>(Decl)));\n #endif\n }\n \n@@ -539,7 +539,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(\n     const char *UniqueId) {\n   return wrap(Builder->createStructType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n-      SizeInBits, AlignInBits, from_rust(Flags), unwrapDI<DIType>(DerivedFrom),\n+      SizeInBits, AlignInBits, fromRust(Flags), unwrapDI<DIType>(DerivedFrom),\n       DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n       unwrapDI<DIType>(VTableHolder), UniqueId));\n }\n@@ -549,10 +549,10 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateMemberType(\n     LLVMRustMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n     uint64_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n     LLVMRustMetadataRef Ty) {\n-  return wrap(Builder->createMemberType(\n-      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n-      SizeInBits, AlignInBits, OffsetInBits, from_rust(Flags),\n-      unwrapDI<DIType>(Ty)));\n+  return wrap(Builder->createMemberType(unwrapDI<DIDescriptor>(Scope), Name,\n+                                        unwrapDI<DIFile>(File), LineNo,\n+                                        SizeInBits, AlignInBits, OffsetInBits,\n+                                        fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n@@ -573,9 +573,9 @@ LLVMRustDIBuilderCreateLexicalBlockFile(LLVMRustDIBuilderRef Builder,\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Context, const char *Name,\n     const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n-    LLVMRustMetadataRef Ty, bool isLocalToUnit, LLVMValueRef Val,\n+    LLVMRustMetadataRef Ty, bool IsLocalToUnit, LLVMValueRef V,\n     LLVMRustMetadataRef Decl = nullptr, uint64_t AlignInBits = 0) {\n-  Constant *InitVal = cast<Constant>(unwrap(Val));\n+  Constant *InitVal = cast<Constant>(unwrap(V));\n \n #if LLVM_VERSION_GE(4, 0)\n   llvm::DIExpression *InitExpr = nullptr;\n@@ -591,15 +591,15 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n \n   return wrap(Builder->createGlobalVariable(\n       unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n-      unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), isLocalToUnit,\n+      unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), IsLocalToUnit,\n #if LLVM_VERSION_GE(4, 0)\n       InitExpr,\n #else\n       InitVal,\n #endif\n-      unwrapDIptr<MDNode>(Decl)\n+      unwrapDIPtr<MDNode>(Decl)\n #if LLVM_VERSION_GE(4, 0)\n-          ,\n+      ,\n       AlignInBits\n #endif\n       ));\n@@ -614,21 +614,21 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n   if (Tag == 0x100) { // DW_TAG_auto_variable\n     return wrap(Builder->createAutoVariable(\n         unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n-        unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)\n+        unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags)\n #if LLVM_VERSION_GE(4, 0)\n-                                                  ,\n-        AlignInBits\n+        ,\n+\tAlignInBits\n #endif\n         ));\n   } else {\n     return wrap(Builder->createParameterVariable(\n         unwrapDI<DIDescriptor>(Scope), Name, ArgNo, unwrapDI<DIFile>(File),\n-        LineNo, unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));\n+        LineNo, unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags)));\n   }\n #else\n   return wrap(Builder->createLocalVariable(\n       Tag, unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n-      unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags), ArgNo));\n+      unwrapDI<DIType>(Ty), AlwaysPreserve, fromRust(Flags), ArgNo));\n #endif\n }\n \n@@ -665,11 +665,11 @@ LLVMRustDIBuilderGetOrCreateArray(LLVMRustDIBuilderRef Builder,\n }\n \n extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n-    LLVMRustDIBuilderRef Builder, LLVMValueRef Val, LLVMRustMetadataRef VarInfo,\n+    LLVMRustDIBuilderRef Builder, LLVMValueRef V, LLVMRustMetadataRef VarInfo,\n     int64_t *AddrOps, unsigned AddrOpsCount, LLVMValueRef DL,\n     LLVMBasicBlockRef InsertAtEnd) {\n   return wrap(Builder->insertDeclare(\n-      unwrap(Val), unwrap<DILocalVariable>(VarInfo),\n+      unwrap(V), unwrap<DILocalVariable>(VarInfo),\n       Builder->createExpression(llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n       DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n       unwrap(InsertAtEnd)));\n@@ -685,11 +685,11 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n     LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n     LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n     uint64_t AlignInBits, LLVMRustMetadataRef Elements,\n-    LLVMRustMetadataRef ClassType) {\n+    LLVMRustMetadataRef ClassTy) {\n   return wrap(Builder->createEnumerationType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n       SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n-      unwrapDI<DIType>(ClassType)));\n+      unwrapDI<DIType>(ClassTy)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(\n@@ -699,7 +699,7 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(\n     unsigned RunTimeLang, const char *UniqueId) {\n   return wrap(Builder->createUnionType(\n       unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n-      SizeInBits, AlignInBits, from_rust(Flags),\n+      SizeInBits, AlignInBits, fromRust(Flags),\n       DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang, UniqueId));\n }\n \n@@ -726,22 +726,22 @@ LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n \n extern \"C\" void\n LLVMRustDICompositeTypeSetTypeArray(LLVMRustDIBuilderRef Builder,\n-                                    LLVMRustMetadataRef CompositeType,\n-                                    LLVMRustMetadataRef TypeArray) {\n-  DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n-  Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n+                                    LLVMRustMetadataRef CompositeTy,\n+                                    LLVMRustMetadataRef TyArray) {\n+  DICompositeType *Tmp = unwrapDI<DICompositeType>(CompositeTy);\n+  Builder->replaceArrays(Tmp, DINodeArray(unwrap<MDTuple>(TyArray)));\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef Context, unsigned Line,\n+LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef ContextRef, unsigned Line,\n                                      unsigned Column, LLVMRustMetadataRef Scope,\n                                      LLVMRustMetadataRef InlinedAt) {\n-  LLVMContext &context = *unwrap(Context);\n+  LLVMContext &Context = *unwrap(ContextRef);\n \n-  DebugLoc debug_loc = DebugLoc::get(Line, Column, unwrapDIptr<MDNode>(Scope),\n-                                     unwrapDIptr<MDNode>(InlinedAt));\n+  DebugLoc debug_loc = DebugLoc::get(Line, Column, unwrapDIPtr<MDNode>(Scope),\n+                                     unwrapDIPtr<MDNode>(InlinedAt));\n \n-  return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode()));\n+  return wrap(MetadataAsValue::get(Context, debug_loc.getAsMDNode()));\n }\n \n extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref() {\n@@ -750,31 +750,31 @@ extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref() {\n \n extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlus() { return dwarf::DW_OP_plus; }\n \n-extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Type, RustStringRef str) {\n-  raw_rust_string_ostream os(str);\n-  unwrap<llvm::Type>(Type)->print(os);\n+extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Ty, RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  unwrap<llvm::Type>(Ty)->print(OS);\n }\n \n-extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef Value,\n-                                           RustStringRef str) {\n-  raw_rust_string_ostream os(str);\n-  os << \"(\";\n-  unwrap<llvm::Value>(Value)->getType()->print(os);\n-  os << \":\";\n-  unwrap<llvm::Value>(Value)->print(os);\n-  os << \")\";\n+extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef V,\n+                                           RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  OS << \"(\";\n+  unwrap<llvm::Value>(V)->getType()->print(OS);\n+  OS << \":\";\n+  unwrap<llvm::Value>(V)->print(OS);\n+  OS << \")\";\n }\n \n-extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc,\n-                                              size_t len) {\n-  Module *Dst = unwrap(dst);\n+extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef DstRef, char *BC,\n+                                              size_t Len) {\n+  Module *Dst = unwrap(DstRef);\n \n-  std::unique_ptr<MemoryBuffer> buf =\n-      MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+  std::unique_ptr<MemoryBuffer> Buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(BC, Len));\n \n #if LLVM_VERSION_GE(4, 0)\n   Expected<std::unique_ptr<Module>> SrcOrError =\n-      llvm::getLazyBitcodeModule(buf->getMemBufferRef(), Dst->getContext());\n+      llvm::getLazyBitcodeModule(Buf->getMemBufferRef(), Dst->getContext());\n   if (!SrcOrError) {\n     LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n     return false;\n@@ -783,7 +783,7 @@ extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc,\n   auto Src = std::move(*SrcOrError);\n #else\n   ErrorOr<std::unique_ptr<Module>> Src =\n-      llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n+      llvm::getLazyBitcodeModule(std::move(Buf), Dst->getContext());\n   if (!Src) {\n     LLVMRustSetLastError(Src.getError().message().c_str());\n     return false;\n@@ -824,61 +824,62 @@ inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n }\n \n extern \"C\" size_t LLVMRustGetSectionName(LLVMSectionIteratorRef SI,\n-                                         const char **ptr) {\n-  StringRef ret;\n-  if (std::error_code ec = (*unwrap(SI))->getName(ret))\n-    report_fatal_error(ec.message());\n-  *ptr = ret.data();\n-  return ret.size();\n+                                         const char **Ptr) {\n+  StringRef Ret;\n+  if (std::error_code EC = (*unwrap(SI))->getName(Ret))\n+    report_fatal_error(EC.message());\n+  *Ptr = Ret.data();\n+  return Ret.size();\n }\n \n // LLVMArrayType function does not support 64-bit ElementCount\n-extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementType,\n+extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementTy,\n                                          uint64_t ElementCount) {\n-  return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n+  return wrap(ArrayType::get(unwrap(ElementTy), ElementCount));\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(Twine, LLVMTwineRef)\n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(DebugLoc, LLVMDebugLocRef)\n \n-extern \"C\" void LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n-  raw_rust_string_ostream os(str);\n-  unwrap(T)->print(os);\n+extern \"C\" void LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  unwrap(T)->print(OS);\n }\n \n extern \"C\" void LLVMRustUnpackOptimizationDiagnostic(\n-    LLVMDiagnosticInfoRef di, RustStringRef pass_name_out,\n-    LLVMValueRef *function_out, LLVMDebugLocRef *debugloc_out,\n-    RustStringRef message_out) {\n+    LLVMDiagnosticInfoRef DI, RustStringRef PassNameOut,\n+    LLVMValueRef *FunctionOut, LLVMDebugLocRef *DebugLocOut,\n+    RustStringRef MessageOut) {\n   // Undefined to call this not on an optimization diagnostic!\n-  llvm::DiagnosticInfoOptimizationBase *opt =\n-      static_cast<llvm::DiagnosticInfoOptimizationBase *>(unwrap(di));\n+  llvm::DiagnosticInfoOptimizationBase *Opt =\n+      static_cast<llvm::DiagnosticInfoOptimizationBase *>(unwrap(DI));\n \n-  raw_rust_string_ostream pass_name_os(pass_name_out);\n-  pass_name_os << opt->getPassName();\n-  *function_out = wrap(&opt->getFunction());\n-  *debugloc_out = wrap(&opt->getDebugLoc());\n-  raw_rust_string_ostream message_os(message_out);\n-  message_os << opt->getMsg();\n+  RawRustStringOstream PassNameOS(PassNameOut);\n+  PassNameOS << Opt->getPassName();\n+  *FunctionOut = wrap(&Opt->getFunction());\n+  *DebugLocOut = wrap(&Opt->getDebugLoc());\n+  RawRustStringOstream MessageOS(MessageOut);\n+  MessageOS << Opt->getMsg();\n }\n \n-extern \"C\" void LLVMRustUnpackInlineAsmDiagnostic(\n-    LLVMDiagnosticInfoRef di, unsigned *cookie_out, LLVMTwineRef *message_out,\n-    LLVMValueRef *instruction_out) {\n+extern \"C\" void\n+LLVMRustUnpackInlineAsmDiagnostic(LLVMDiagnosticInfoRef DI, unsigned *CookieOut,\n+                                  LLVMTwineRef *MessageOut,\n+                                  LLVMValueRef *InstructionOut) {\n   // Undefined to call this not on an inline assembly diagnostic!\n-  llvm::DiagnosticInfoInlineAsm *ia =\n-      static_cast<llvm::DiagnosticInfoInlineAsm *>(unwrap(di));\n+  llvm::DiagnosticInfoInlineAsm *IA =\n+      static_cast<llvm::DiagnosticInfoInlineAsm *>(unwrap(DI));\n \n-  *cookie_out = ia->getLocCookie();\n-  *message_out = wrap(&ia->getMsgStr());\n-  *instruction_out = wrap(ia->getInstruction());\n+  *CookieOut = IA->getLocCookie();\n+  *MessageOut = wrap(&IA->getMsgStr());\n+  *InstructionOut = wrap(IA->getInstruction());\n }\n \n-extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di,\n-                                                    RustStringRef str) {\n-  raw_rust_string_ostream os(str);\n-  DiagnosticPrinterRawOStream dp(os);\n-  unwrap(di)->print(dp);\n+extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef DI,\n+                                                    RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  DiagnosticPrinterRawOStream DP(OS);\n+  unwrap(DI)->print(DP);\n }\n \n enum class LLVMRustDiagnosticKind {\n@@ -896,8 +897,8 @@ enum class LLVMRustDiagnosticKind {\n   OptimizationFailure,\n };\n \n-static LLVMRustDiagnosticKind to_rust(DiagnosticKind kind) {\n-  switch (kind) {\n+static LLVMRustDiagnosticKind toRust(DiagnosticKind Kind) {\n+  switch (Kind) {\n   case DK_InlineAsm:\n     return LLVMRustDiagnosticKind::InlineAsm;\n   case DK_StackSize:\n@@ -920,7 +921,7 @@ static LLVMRustDiagnosticKind to_rust(DiagnosticKind kind) {\n #endif\n   default:\n #if LLVM_VERSION_GE(3, 9)\n-    return (kind >= DK_FirstRemark && kind <= DK_LastRemark)\n+    return (Kind >= DK_FirstRemark && Kind <= DK_LastRemark)\n                ? LLVMRustDiagnosticKind::OptimizationRemarkOther\n                : LLVMRustDiagnosticKind::Other;\n #else\n@@ -930,8 +931,8 @@ static LLVMRustDiagnosticKind to_rust(DiagnosticKind kind) {\n }\n \n extern \"C\" LLVMRustDiagnosticKind\n-LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n-  return to_rust((DiagnosticKind)unwrap(di)->getKind());\n+LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef DI) {\n+  return toRust((DiagnosticKind)unwrap(DI)->getKind());\n }\n // This is kept distinct from LLVMGetTypeKind, because when\n // a new type kind is added, the Rust-side enum must be\n@@ -979,10 +980,10 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n }\n \n extern \"C\" void LLVMRustWriteDebugLocToString(LLVMContextRef C,\n-                                              LLVMDebugLocRef dl,\n-                                              RustStringRef str) {\n-  raw_rust_string_ostream os(str);\n-  unwrap(dl)->print(os);\n+                                              LLVMDebugLocRef DL,\n+                                              RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  unwrap(DL)->print(OS);\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)\n@@ -992,82 +993,82 @@ extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n   unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n }\n \n-extern \"C\" void LLVMRustWriteSMDiagnosticToString(LLVMSMDiagnosticRef d,\n-                                                  RustStringRef str) {\n-  raw_rust_string_ostream os(str);\n-  unwrap(d)->print(\"\", os);\n+extern \"C\" void LLVMRustWriteSMDiagnosticToString(LLVMSMDiagnosticRef D,\n+                                                  RustStringRef Str) {\n+  RawRustStringOstream OS(Str);\n+  unwrap(D)->print(\"\", OS);\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildLandingPad(LLVMBuilderRef Builder, LLVMTypeRef Ty,\n+LLVMRustBuildLandingPad(LLVMBuilderRef B, LLVMTypeRef Ty,\n                         LLVMValueRef PersFn, unsigned NumClauses,\n                         const char *Name, LLVMValueRef F) {\n-  return LLVMBuildLandingPad(Builder, Ty, PersFn, NumClauses, Name);\n+  return LLVMBuildLandingPad(B, Ty, PersFn, NumClauses, Name);\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n+extern \"C\" LLVMValueRef LLVMRustBuildCleanupPad(LLVMBuilderRef B,\n                                                 LLVMValueRef ParentPad,\n-                                                unsigned ArgCnt,\n+                                                unsigned ArgCount,\n                                                 LLVMValueRef *LLArgs,\n                                                 const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n   Value **Args = unwrap(LLArgs);\n   if (ParentPad == nullptr) {\n-    Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+    Type *Ty = Type::getTokenTy(unwrap(B)->getContext());\n     ParentPad = wrap(Constant::getNullValue(Ty));\n   }\n-  return wrap(unwrap(Builder)->CreateCleanupPad(\n-      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCnt), Name));\n+  return wrap(unwrap(B)->CreateCleanupPad(\n+      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCount), Name));\n #else\n   return nullptr;\n #endif\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n+extern \"C\" LLVMValueRef LLVMRustBuildCleanupRet(LLVMBuilderRef B,\n                                                 LLVMValueRef CleanupPad,\n                                                 LLVMBasicBlockRef UnwindBB) {\n #if LLVM_VERSION_GE(3, 8)\n   CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n-  return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n+  return wrap(unwrap(B)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n #else\n   return nullptr;\n #endif\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchPad(LLVMBuilderRef Builder, LLVMValueRef ParentPad,\n-                      unsigned ArgCnt, LLVMValueRef *LLArgs, const char *Name) {\n+LLVMRustBuildCatchPad(LLVMBuilderRef B, LLVMValueRef ParentPad,\n+                      unsigned ArgCount, LLVMValueRef *LLArgs, const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n   Value **Args = unwrap(LLArgs);\n-  return wrap(unwrap(Builder)->CreateCatchPad(\n-      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCnt), Name));\n+  return wrap(unwrap(B)->CreateCatchPad(\n+      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCount), Name));\n #else\n   return nullptr;\n #endif\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n+extern \"C\" LLVMValueRef LLVMRustBuildCatchRet(LLVMBuilderRef B,\n                                               LLVMValueRef Pad,\n                                               LLVMBasicBlockRef BB) {\n #if LLVM_VERSION_GE(3, 8)\n-  return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n+  return wrap(unwrap(B)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n                                               unwrap(BB)));\n #else\n   return nullptr;\n #endif\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n+extern \"C\" LLVMValueRef LLVMRustBuildCatchSwitch(LLVMBuilderRef B,\n                                                  LLVMValueRef ParentPad,\n                                                  LLVMBasicBlockRef BB,\n                                                  unsigned NumHandlers,\n                                                  const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n   if (ParentPad == nullptr) {\n-    Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+    Type *Ty = Type::getTokenTy(unwrap(B)->getContext());\n     ParentPad = wrap(Constant::getNullValue(Ty));\n   }\n-  return wrap(unwrap(Builder)->CreateCatchSwitch(unwrap(ParentPad), unwrap(BB),\n+  return wrap(unwrap(B)->CreateCatchSwitch(unwrap(ParentPad), unwrap(BB),\n                                                  NumHandlers, Name));\n #else\n   return nullptr;\n@@ -1105,8 +1106,8 @@ extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n                                           LLVMValueRef *Args, unsigned NumArgs,\n                                           OperandBundleDef *Bundle,\n                                           const char *Name) {\n-  unsigned len = Bundle ? 1 : 0;\n-  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+  unsigned Len = Bundle ? 1 : 0;\n+  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateCall(\n       unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles, Name));\n }\n@@ -1116,8 +1117,8 @@ LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,\n                     LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n                     const char *Name) {\n-  unsigned len = Bundle ? 1 : 0;\n-  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+  unsigned Len = Bundle ? 1 : 0;\n+  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, Len);\n   return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n                                       makeArrayRef(unwrap(Args), NumArgs),\n                                       Bundles, Name));\n@@ -1147,8 +1148,8 @@ LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n \n extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B,\n                                                LLVMBasicBlockRef BB) {\n-  auto point = unwrap(BB)->getFirstInsertionPt();\n-  unwrap(B)->SetInsertPoint(unwrap(BB), point);\n+  auto Point = unwrap(BB)->getFirstInsertionPt();\n+  unwrap(B)->SetInsertPoint(unwrap(BB), Point);\n }\n \n extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n@@ -1179,8 +1180,8 @@ enum class LLVMRustLinkage {\n   CommonLinkage = 10,\n };\n \n-static LLVMRustLinkage to_rust(LLVMLinkage linkage) {\n-  switch (linkage) {\n+static LLVMRustLinkage toRust(LLVMLinkage Linkage) {\n+  switch (Linkage) {\n   case LLVMExternalLinkage:\n     return LLVMRustLinkage::ExternalLinkage;\n   case LLVMAvailableExternallyLinkage:\n@@ -1208,8 +1209,8 @@ static LLVMRustLinkage to_rust(LLVMLinkage linkage) {\n   }\n }\n \n-static LLVMLinkage from_rust(LLVMRustLinkage linkage) {\n-  switch (linkage) {\n+static LLVMLinkage fromRust(LLVMRustLinkage Linkage) {\n+  switch (Linkage) {\n   case LLVMRustLinkage::ExternalLinkage:\n     return LLVMExternalLinkage;\n   case LLVMRustLinkage::AvailableExternallyLinkage:\n@@ -1238,12 +1239,12 @@ static LLVMLinkage from_rust(LLVMRustLinkage linkage) {\n }\n \n extern \"C\" LLVMRustLinkage LLVMRustGetLinkage(LLVMValueRef V) {\n-  return to_rust(LLVMGetLinkage(V));\n+  return toRust(LLVMGetLinkage(V));\n }\n \n extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V,\n                                    LLVMRustLinkage RustLinkage) {\n-  LLVMSetLinkage(V, from_rust(RustLinkage));\n+  LLVMSetLinkage(V, fromRust(RustLinkage));\n }\n \n // Returns true if both high and low were successfully set. Fails in case constant wasn\u2019t any of\n@@ -1273,8 +1274,8 @@ enum class LLVMRustVisibility {\n   Protected = 2,\n };\n \n-static LLVMRustVisibility to_rust(LLVMVisibility vis) {\n-  switch (vis) {\n+static LLVMRustVisibility toRust(LLVMVisibility Vis) {\n+  switch (Vis) {\n   case LLVMDefaultVisibility:\n     return LLVMRustVisibility::Default;\n   case LLVMHiddenVisibility:\n@@ -1287,8 +1288,8 @@ static LLVMRustVisibility to_rust(LLVMVisibility vis) {\n   }\n }\n \n-static LLVMVisibility from_rust(LLVMRustVisibility vis) {\n-  switch (vis) {\n+static LLVMVisibility fromRust(LLVMRustVisibility Vis) {\n+  switch (Vis) {\n   case LLVMRustVisibility::Default:\n     return LLVMDefaultVisibility;\n   case LLVMRustVisibility::Hidden:\n@@ -1302,10 +1303,10 @@ static LLVMVisibility from_rust(LLVMRustVisibility vis) {\n }\n \n extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n-  return to_rust(LLVMGetVisibility(V));\n+  return toRust(LLVMGetVisibility(V));\n }\n \n extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n                                       LLVMRustVisibility RustVisibility) {\n-  LLVMSetVisibility(V, from_rust(RustVisibility));\n+  LLVMSetVisibility(V, fromRust(RustVisibility));\n }"}, {"sha": "a30fa3133e2825b1403d0afa0dda7343846f9acc", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/ac5cd3bd43b9dbe681417e482065b24c08c544e8/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=ac5cd3bd43b9dbe681417e482065b24c08c544e8", "patch": "@@ -106,24 +106,24 @@ typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;\n typedef struct LLVMOpaqueSMDiagnostic *LLVMSMDiagnosticRef;\n typedef struct LLVMOpaqueRustJITMemoryManager *LLVMRustJITMemoryManagerRef;\n \n-extern \"C\" void rust_llvm_string_write_impl(RustStringRef str, const char *ptr,\n-                                            size_t size);\n+extern \"C\" void LLVMRustStringWriteImpl(RustStringRef Str, const char *Ptr,\n+                                        size_t Size);\n \n-class raw_rust_string_ostream : public llvm::raw_ostream {\n-  RustStringRef str;\n-  uint64_t pos;\n+class RawRustStringOstream : public llvm::raw_ostream {\n+  RustStringRef Str;\n+  uint64_t Pos;\n \n-  void write_impl(const char *ptr, size_t size) override {\n-    rust_llvm_string_write_impl(str, ptr, size);\n-    pos += size;\n+  void write_impl(const char *Ptr, size_t Size) override {\n+    LLVMRustStringWriteImpl(Str, Ptr, Size);\n+    Pos += Size;\n   }\n \n-  uint64_t current_pos() const override { return pos; }\n+  uint64_t current_pos() const override { return Pos; }\n \n public:\n-  explicit raw_rust_string_ostream(RustStringRef str) : str(str), pos(0) {}\n+  explicit RawRustStringOstream(RustStringRef Str) : Str(Str), Pos(0) {}\n \n-  ~raw_rust_string_ostream() {\n+  ~RawRustStringOstream() {\n     // LLVM requires this.\n     flush();\n   }"}]}