{"sha": "8f2913cc2475682da493b06ce81cf1e4fc621f0e", "node_id": "C_kwDOAAsO6NoAKDhmMjkxM2NjMjQ3NTY4MmRhNDkzYjA2Y2U4MWNmMWU0ZmM2MjFmMGU", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-19T07:21:11Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-19T07:21:54Z"}, "message": "Use futex locks on wasm+atomics.", "tree": {"sha": "83e47121e1bebaefd19596fb14c7532cc875b09b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83e47121e1bebaefd19596fb14c7532cc875b09b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f2913cc2475682da493b06ce81cf1e4fc621f0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f2913cc2475682da493b06ce81cf1e4fc621f0e", "html_url": "https://github.com/rust-lang/rust/commit/8f2913cc2475682da493b06ce81cf1e4fc621f0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f2913cc2475682da493b06ce81cf1e4fc621f0e/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65987ae8f57e6f529c0de33ac0787a20bad266fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/65987ae8f57e6f529c0de33ac0787a20bad266fb", "html_url": "https://github.com/rust-lang/rust/commit/65987ae8f57e6f529c0de33ac0787a20bad266fb"}], "stats": {"total": 360, "additions": 6, "deletions": 354}, "files": [{"sha": "f06c07c54093fc06a63de784d5d6d3d410ca3d8a", "filename": "library/std/src/sys/wasm/atomics/condvar.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/65987ae8f57e6f529c0de33ac0787a20bad266fb/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65987ae8f57e6f529c0de33ac0787a20bad266fb/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fcondvar.rs?ref=65987ae8f57e6f529c0de33ac0787a20bad266fb", "patch": "@@ -1,102 +0,0 @@\n-use crate::arch::wasm32;\n-use crate::cmp;\n-use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-use crate::sys::locks::Mutex;\n-use crate::time::Duration;\n-\n-pub struct Condvar {\n-    cnt: AtomicUsize,\n-}\n-\n-pub type MovableCondvar = Condvar;\n-\n-// Condition variables are implemented with a simple counter internally that is\n-// likely to cause spurious wakeups. Blocking on a condition variable will first\n-// read the value of the internal counter, unlock the given mutex, and then\n-// block if and only if the counter's value is still the same. Notifying a\n-// condition variable will modify the counter (add one for now) and then wake up\n-// a thread waiting on the address of the counter.\n-//\n-// A thread waiting on the condition variable will as a result avoid going to\n-// sleep if it's notified after the lock is unlocked but before it fully goes to\n-// sleep. A sleeping thread is guaranteed to be woken up at some point as it can\n-// only be woken up with a call to `wake`.\n-//\n-// Note that it's possible for 2 or more threads to be woken up by a call to\n-// `notify_one` with this implementation. That can happen where the modification\n-// of `cnt` causes any threads in the middle of `wait` to avoid going to sleep,\n-// and the subsequent `wake` may wake up a thread that's actually blocking. We\n-// consider this a spurious wakeup, though, which all users of condition\n-// variables must already be prepared to handle. As a result, this source of\n-// spurious wakeups is currently though to be ok, although it may be problematic\n-// later on if it causes too many spurious wakeups.\n-\n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        Condvar { cnt: AtomicUsize::new(0) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        // nothing to do\n-    }\n-\n-    pub unsafe fn notify_one(&self) {\n-        self.cnt.fetch_add(1, SeqCst);\n-        // SAFETY: ptr() is always valid\n-        unsafe {\n-            wasm32::memory_atomic_notify(self.ptr(), 1);\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        self.cnt.fetch_add(1, SeqCst);\n-        // SAFETY: ptr() is always valid\n-        unsafe {\n-            wasm32::memory_atomic_notify(self.ptr(), u32::MAX); // -1 == \"wake everyone\"\n-        }\n-    }\n-\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        // \"atomically block and unlock\" implemented by loading our current\n-        // counter's value, unlocking the mutex, and blocking if the counter\n-        // still has the same value.\n-        //\n-        // Notifications happen by incrementing the counter and then waking a\n-        // thread. Incrementing the counter after we unlock the mutex will\n-        // prevent us from sleeping and otherwise the call to `wake` will\n-        // wake us up once we're asleep.\n-        let ticket = self.cnt.load(SeqCst) as i32;\n-        mutex.unlock();\n-        let val = wasm32::memory_atomic_wait32(self.ptr(), ticket, -1);\n-        // 0 == woken, 1 == not equal to `ticket`, 2 == timeout (shouldn't happen)\n-        debug_assert!(val == 0 || val == 1);\n-        mutex.lock();\n-    }\n-\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let ticket = self.cnt.load(SeqCst) as i32;\n-        mutex.unlock();\n-        let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::MAX as u128, nanos);\n-\n-        // If the return value is 2 then a timeout happened, so we return\n-        // `false` as we weren't actually notified.\n-        let ret = wasm32::memory_atomic_wait32(self.ptr(), ticket, nanos as i64) != 2;\n-        mutex.lock();\n-        return ret;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        // nothing to do\n-    }\n-\n-    #[inline]\n-    fn ptr(&self) -> *mut i32 {\n-        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n-        self.cnt.as_mut_ptr() as *mut i32\n-    }\n-}"}, {"sha": "1acc8392444c181e7768dd95a5ca22066ce62632", "filename": "library/std/src/sys/wasm/atomics/mutex.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/65987ae8f57e6f529c0de33ac0787a20bad266fb/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65987ae8f57e6f529c0de33ac0787a20bad266fb/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fmutex.rs?ref=65987ae8f57e6f529c0de33ac0787a20bad266fb", "patch": "@@ -1,64 +0,0 @@\n-use crate::arch::wasm32;\n-use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-\n-pub struct Mutex {\n-    locked: AtomicUsize,\n-}\n-\n-pub type MovableMutex = Mutex;\n-\n-// Mutexes have a pretty simple implementation where they contain an `i32`\n-// internally that is 0 when unlocked and 1 when the mutex is locked.\n-// Acquisition has a fast path where it attempts to cmpxchg the 0 to a 1, and\n-// if it fails it then waits for a notification. Releasing a lock is then done\n-// by swapping in 0 and then notifying any waiters, if present.\n-\n-impl Mutex {\n-    pub const fn new() -> Mutex {\n-        Mutex { locked: AtomicUsize::new(0) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        // nothing to do\n-    }\n-\n-    pub unsafe fn lock(&self) {\n-        while !self.try_lock() {\n-            // SAFETY: the caller must uphold the safety contract for `memory_atomic_wait32`.\n-            let val = unsafe {\n-                wasm32::memory_atomic_wait32(\n-                    self.ptr(),\n-                    1,  // we expect our mutex is locked\n-                    -1, // wait infinitely\n-                )\n-            };\n-            // we should have either woke up (0) or got a not-equal due to a\n-            // race (1). We should never time out (2)\n-            debug_assert!(val == 0 || val == 1);\n-        }\n-    }\n-\n-    pub unsafe fn unlock(&self) {\n-        let prev = self.locked.swap(0, SeqCst);\n-        debug_assert_eq!(prev, 1);\n-        wasm32::memory_atomic_notify(self.ptr(), 1); // wake up one waiter, if any\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_lock(&self) -> bool {\n-        self.locked.compare_exchange(0, 1, SeqCst, SeqCst).is_ok()\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        // nothing to do\n-    }\n-\n-    #[inline]\n-    fn ptr(&self) -> *mut i32 {\n-        assert_eq!(mem::size_of::<usize>(), mem::size_of::<i32>());\n-        self.locked.as_mut_ptr() as *mut i32\n-    }\n-}"}, {"sha": "690bb155e1a27fea59e59253d524975d007817e1", "filename": "library/std/src/sys/wasm/atomics/rwlock.rs", "status": "removed", "additions": 0, "deletions": 145, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/65987ae8f57e6f529c0de33ac0787a20bad266fb/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65987ae8f57e6f529c0de33ac0787a20bad266fb/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Frwlock.rs?ref=65987ae8f57e6f529c0de33ac0787a20bad266fb", "patch": "@@ -1,145 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sys::locks::{Condvar, Mutex};\n-\n-pub struct RwLock {\n-    lock: Mutex,\n-    cond: Condvar,\n-    state: UnsafeCell<State>,\n-}\n-\n-pub type MovableRwLock = RwLock;\n-\n-enum State {\n-    Unlocked,\n-    Reading(usize),\n-    Writing,\n-}\n-\n-unsafe impl Send for RwLock {}\n-unsafe impl Sync for RwLock {}\n-\n-// This rwlock implementation is a relatively simple implementation which has a\n-// condition variable for readers/writers as well as a mutex protecting the\n-// internal state of the lock. A current downside of the implementation is that\n-// unlocking the lock will notify *all* waiters rather than just readers or just\n-// writers. This can cause lots of \"thundering stampede\" problems. While\n-// hopefully correct this implementation is very likely to want to be changed in\n-// the future.\n-\n-impl RwLock {\n-    pub const fn new() -> RwLock {\n-        RwLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_readers() {\n-            self.cond.wait(&self.lock);\n-        }\n-        self.lock.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_read(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_readers();\n-        self.lock.unlock();\n-        return ok;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write(&self) {\n-        self.lock.lock();\n-        while !(*self.state.get()).inc_writers() {\n-            self.cond.wait(&self.lock);\n-        }\n-        self.lock.unlock();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn try_write(&self) -> bool {\n-        self.lock.lock();\n-        let ok = (*self.state.get()).inc_writers();\n-        self.lock.unlock();\n-        return ok;\n-    }\n-\n-    #[inline]\n-    pub unsafe fn read_unlock(&self) {\n-        self.lock.lock();\n-        let notify = (*self.state.get()).dec_readers();\n-        self.lock.unlock();\n-        if notify {\n-            // FIXME: should only wake up one of these some of the time\n-            self.cond.notify_all();\n-        }\n-    }\n-\n-    #[inline]\n-    pub unsafe fn write_unlock(&self) {\n-        self.lock.lock();\n-        (*self.state.get()).dec_writers();\n-        self.lock.unlock();\n-        // FIXME: should only wake up one of these some of the time\n-        self.cond.notify_all();\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.lock.destroy();\n-        self.cond.destroy();\n-    }\n-}\n-\n-impl State {\n-    fn inc_readers(&mut self) -> bool {\n-        match *self {\n-            State::Unlocked => {\n-                *self = State::Reading(1);\n-                true\n-            }\n-            State::Reading(ref mut cnt) => {\n-                *cnt += 1;\n-                true\n-            }\n-            State::Writing => false,\n-        }\n-    }\n-\n-    fn inc_writers(&mut self) -> bool {\n-        match *self {\n-            State::Unlocked => {\n-                *self = State::Writing;\n-                true\n-            }\n-            State::Reading(_) | State::Writing => false,\n-        }\n-    }\n-\n-    fn dec_readers(&mut self) -> bool {\n-        let zero = match *self {\n-            State::Reading(ref mut cnt) => {\n-                *cnt -= 1;\n-                *cnt == 0\n-            }\n-            State::Unlocked | State::Writing => invalid(),\n-        };\n-        if zero {\n-            *self = State::Unlocked;\n-        }\n-        zero\n-    }\n-\n-    fn dec_writers(&mut self) {\n-        match *self {\n-            State::Writing => {}\n-            State::Unlocked | State::Reading(_) => invalid(),\n-        }\n-        *self = State::Unlocked;\n-    }\n-}\n-\n-fn invalid() -> ! {\n-    panic!(\"inconsistent rwlock\");\n-}"}, {"sha": "714b7049227940bdcd8578cc0f3f609a4478f2d0", "filename": "library/std/src/sys/wasm/atomics/thread.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8f2913cc2475682da493b06ce81cf1e4fc621f0e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2913cc2475682da493b06ce81cf1e4fc621f0e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fatomics%2Fthread.rs?ref=8f2913cc2475682da493b06ce81cf1e4fc621f0e", "patch": "@@ -53,37 +53,3 @@ pub mod guard {\n         None\n     }\n }\n-\n-// We currently just use our own thread-local to store our\n-// current thread's ID, and then we lazily initialize it to something allocated\n-// from a global counter.\n-pub fn my_id() -> u32 {\n-    use crate::sync::atomic::{AtomicU32, Ordering::SeqCst};\n-\n-    static NEXT_ID: AtomicU32 = AtomicU32::new(0);\n-\n-    #[thread_local]\n-    static mut MY_ID: u32 = 0;\n-\n-    unsafe {\n-        // If our thread ID isn't set yet then we need to allocate one. Do so\n-        // with with a simple \"atomically add to a global counter\" strategy.\n-        // This strategy doesn't handled what happens when the counter\n-        // overflows, however, so just abort everything once the counter\n-        // overflows and eventually we could have some sort of recycling scheme\n-        // (or maybe this is all totally irrelevant by that point!). In any case\n-        // though we're using a CAS loop instead of a `fetch_add` to ensure that\n-        // the global counter never overflows.\n-        if MY_ID == 0 {\n-            let mut cur = NEXT_ID.load(SeqCst);\n-            MY_ID = loop {\n-                let next = cur.checked_add(1).unwrap_or_else(|| crate::process::abort());\n-                match NEXT_ID.compare_exchange(cur, next, SeqCst, SeqCst) {\n-                    Ok(_) => break next,\n-                    Err(i) => cur = i,\n-                }\n-            };\n-        }\n-        MY_ID\n-    }\n-}"}, {"sha": "9992e44b0e7566b2fb9f8857550dcb2e29999477", "filename": "library/std/src/sys/wasm/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8f2913cc2475682da493b06ce81cf1e4fc621f0e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f2913cc2475682da493b06ce81cf1e4fc621f0e/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmod.rs?ref=8f2913cc2475682da493b06ce81cf1e4fc621f0e", "patch": "@@ -49,16 +49,13 @@ pub mod time;\n \n cfg_if::cfg_if! {\n     if #[cfg(target_feature = \"atomics\")] {\n-        #[path = \"atomics/condvar.rs\"]\n-        mod condvar;\n-        #[path = \"atomics/mutex.rs\"]\n-        mod mutex;\n-        #[path = \"atomics/rwlock.rs\"]\n-        mod rwlock;\n+        #[path = \"../unix/locks\"]\n         pub mod locks {\n-            pub use super::condvar::*;\n-            pub use super::mutex::*;\n-            pub use super::rwlock::*;\n+            #![allow(unsafe_op_in_unsafe_fn)]\n+            mod futex;\n+            mod futex_rwlock;\n+            pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n+            pub use futex_rwlock::{RwLock, MovableRwLock};\n         }\n         #[path = \"atomics/futex.rs\"]\n         pub mod futex;"}]}