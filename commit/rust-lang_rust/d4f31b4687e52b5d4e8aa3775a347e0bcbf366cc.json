{"sha": "d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZjMxYjQ2ODdlNTJiNWQ0ZThhYTM3NzVhMzQ3ZTBiY2JmMzY2Y2M=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-04-19T15:53:51Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-05-06T12:14:21Z"}, "message": "Fixup tests to test both const-eval and runtime", "tree": {"sha": "659e1eeb932cf15c8a7a52888a1a44645cdd2685", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/659e1eeb932cf15c8a7a52888a1a44645cdd2685"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc", "html_url": "https://github.com/rust-lang/rust/commit/d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dbce10bcd611b97db390282f1239bd67d69f6bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dbce10bcd611b97db390282f1239bd67d69f6bd", "html_url": "https://github.com/rust-lang/rust/commit/0dbce10bcd611b97db390282f1239bd67d69f6bd"}], "stats": {"total": 121, "additions": 22, "deletions": 99}, "files": [{"sha": "e6d0c94a02fac5f7ff6cb3fc7a869adefe40ad47", "filename": "src/test/ui/numbers-arithmetic/saturating-float-casts.rs", "status": "modified", "additions": 22, "deletions": 99, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnumbers-arithmetic%2Fsaturating-float-casts.rs?ref=d4f31b4687e52b5d4e8aa3775a347e0bcbf366cc", "patch": "@@ -1,9 +1,12 @@\n // run-pass\n+// compile-flags:-Zmir-opt-level=0\n // Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n //\n // Some of these tests come from a similar file in miri,\n-// tests/run-pass/float.rs. They're just duplicated currently but we may want\n-// to merge this in the future.\n+// tests/run-pass/float.rs. Individual test cases are potentially duplicated\n+// with the previously existing tests, but since this runs so quickly anyway,\n+// we're not spending the time to figure out exactly which ones should be\n+// merged.\n \n #![feature(test, stmt_expr_attributes)]\n #![feature(track_caller)]\n@@ -21,31 +24,18 @@ macro_rules! test {\n         // black_box disables constant evaluation to test run-time conversions:\n         assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n                     \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n-    );\n-\n-    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n-        test!($fval, f32 -> $ity, $ival);\n-        test!($fval, f64 -> $ity, $ival);\n-    )\n-}\n \n-// This macro tests const eval in addition to run-time evaluation.\n-// If and when saturating casts are adopted, this macro should be merged with test!() to ensure\n-// that run-time and const eval agree on inputs that currently trigger a const eval error.\n-macro_rules! test_c {\n-    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => ({\n-        test!($val, $src_ty -> $dest_ty, $expected);\n         {\n             const X: $src_ty = $val;\n             const Y: $dest_ty = X as $dest_ty;\n             assert_eq!(Y, $expected,\n                         \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n         }\n-    });\n+    );\n \n     ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n-        test_c!($fval, f32 -> $ity, $ival);\n-        test_c!($fval, f64 -> $ity, $ival);\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n     )\n }\n \n@@ -59,11 +49,11 @@ macro_rules! common_fptoi_tests {\n         // as well, the test is just slightly misplaced.\n         test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n         test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n-        test_c!(0., $fty -> $ity, 0);\n-        test_c!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(0., $fty -> $ity, 0);\n+        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n         test!(-0.9, $fty -> $ity, 0);\n-        test_c!(1., $fty -> $ity, 1);\n-        test_c!(42., $fty -> $ity, 42);\n+        test!(1., $fty -> $ity, 1);\n+        test!(42., $fty -> $ity, 42);\n     )+ });\n \n     (f* -> $($ity:ident)+) => ({\n@@ -217,39 +207,6 @@ where\n     assert_eq!(unsafe { x.cast_unchecked() }, y);\n }\n \n-fn basic() {\n-    // basic arithmetic\n-    assert_eq(6.0_f32 * 6.0_f32, 36.0_f32);\n-    assert_eq(6.0_f64 * 6.0_f64, 36.0_f64);\n-    assert_eq(-{ 5.0_f32 }, -5.0_f32);\n-    assert_eq(-{ 5.0_f64 }, -5.0_f64);\n-    // infinities, NaN\n-    assert!((5.0_f32 / 0.0).is_infinite());\n-    assert_ne!({ 5.0_f32 / 0.0 }, { -5.0_f32 / 0.0 });\n-    assert!((5.0_f64 / 0.0).is_infinite());\n-    assert_ne!({ 5.0_f64 / 0.0 }, { 5.0_f64 / -0.0 });\n-    assert!((-5.0_f32).sqrt().is_nan());\n-    assert!((-5.0_f64).sqrt().is_nan());\n-    assert_ne!(f32::NAN, f32::NAN);\n-    assert_ne!(f64::NAN, f64::NAN);\n-    // negative zero\n-    let posz = 0.0f32;\n-    let negz = -0.0f32;\n-    assert_eq(posz, negz);\n-    assert_ne!(posz.to_bits(), negz.to_bits());\n-    let posz = 0.0f64;\n-    let negz = -0.0f64;\n-    assert_eq(posz, negz);\n-    assert_ne!(posz.to_bits(), negz.to_bits());\n-    // byte-level transmute\n-    let x: u64 = unsafe { std::mem::transmute(42.0_f64) };\n-    let y: f64 = unsafe { std::mem::transmute(x) };\n-    assert_eq(y, 42.0_f64);\n-    let x: u32 = unsafe { std::mem::transmute(42.0_f32) };\n-    let y: f32 = unsafe { std::mem::transmute(x) };\n-    assert_eq(y, 42.0_f32);\n-}\n-\n fn casts() {\n     // f32 -> i8\n     test_both_cast::<f32, i8>(127.99, 127);\n@@ -500,42 +457,8 @@ fn casts() {\n     assert_eq::<f32>(f64::NEG_INFINITY as f32, f32::NEG_INFINITY);\n }\n \n-fn ops() {\n-    // f32 min/max\n-    assert_eq((1.0 as f32).max(-1.0), 1.0);\n-    assert_eq((1.0 as f32).min(-1.0), -1.0);\n-    assert_eq(f32::NAN.min(9.0), 9.0);\n-    assert_eq(f32::NAN.max(-9.0), -9.0);\n-    assert_eq((9.0 as f32).min(f32::NAN), 9.0);\n-    assert_eq((-9.0 as f32).max(f32::NAN), -9.0);\n-\n-    // f64 min/max\n-    assert_eq((1.0 as f64).max(-1.0), 1.0);\n-    assert_eq((1.0 as f64).min(-1.0), -1.0);\n-    assert_eq(f64::NAN.min(9.0), 9.0);\n-    assert_eq(f64::NAN.max(-9.0), -9.0);\n-    assert_eq((9.0 as f64).min(f64::NAN), 9.0);\n-    assert_eq((-9.0 as f64).max(f64::NAN), -9.0);\n-\n-    // f32 copysign\n-    assert_eq(3.5_f32.copysign(0.42), 3.5_f32);\n-    assert_eq(3.5_f32.copysign(-0.42), -3.5_f32);\n-    assert_eq((-3.5_f32).copysign(0.42), 3.5_f32);\n-    assert_eq((-3.5_f32).copysign(-0.42), -3.5_f32);\n-    assert!(f32::NAN.copysign(1.0).is_nan());\n-\n-    // f64 copysign\n-    assert_eq(3.5_f64.copysign(0.42), 3.5_f64);\n-    assert_eq(3.5_f64.copysign(-0.42), -3.5_f64);\n-    assert_eq((-3.5_f64).copysign(0.42), 3.5_f64);\n-    assert_eq((-3.5_f64).copysign(-0.42), -3.5_f64);\n-    assert!(f64::NAN.copysign(1.0).is_nan());\n-}\n-\n pub fn main() {\n-    basic();\n-    casts();\n-    ops();\n+    casts(); // from miri's tests\n \n     common_fptoi_tests!(f* -> i8 i16 i32 i64 u8 u16 u32 u64);\n     fptoui_tests!(f* -> u8 u16 u32 u64);\n@@ -549,39 +472,39 @@ pub fn main() {\n     // The following tests cover edge cases for some integer types.\n \n     // # u8\n-    test_c!(254., f* -> u8, 254);\n+    test!(254., f* -> u8, 254);\n     test!(256., f* -> u8, 255);\n \n     // # i8\n-    test_c!(-127., f* -> i8, -127);\n+    test!(-127., f* -> i8, -127);\n     test!(-129., f* -> i8, -128);\n-    test_c!(126., f* -> i8, 126);\n+    test!(126., f* -> i8, 126);\n     test!(128., f* -> i8, 127);\n \n     // # i32\n     // -2147483648. is i32::MIN (exactly)\n-    test_c!(-2147483648., f* -> i32, i32::MIN);\n+    test!(-2147483648., f* -> i32, i32::MIN);\n     // 2147483648. is i32::MAX rounded up\n     test!(2147483648., f32 -> i32, 2147483647);\n     // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n     // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n-    test_c!(2147483520., f32 -> i32, 2147483520);\n+    test!(2147483520., f32 -> i32, 2147483520);\n     // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n     test!(-2147483904., f* -> i32, i32::MIN);\n-    test_c!(-2147483520., f* -> i32, -2147483520);\n+    test!(-2147483520., f* -> i32, -2147483520);\n \n     // # u32\n     // round(MAX) and nextUp(round(MAX))\n-    test_c!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967040., f* -> u32, 4294967040);\n     test!(4294967296., f* -> u32, 4294967295);\n \n     // # u128\n     #[cfg(not(target_os = \"emscripten\"))]\n     {\n         // float->int:\n-        test_c!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+        test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n         // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n         const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n-        test_c!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+        test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n     }\n }"}]}