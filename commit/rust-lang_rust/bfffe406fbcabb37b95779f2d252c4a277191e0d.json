{"sha": "bfffe406fbcabb37b95779f2d252c4a277191e0d", "node_id": "C_kwDOAAsO6NoAKGJmZmZlNDA2ZmJjYWJiMzdiOTU3NzlmMmQyNTJjNGEyNzcxOTFlMGQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-13T02:13:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-13T02:13:00Z"}, "message": "Auto merge of #101138 - Rejyr:diagnostic-migration-rustc-lint-pt2, r=davidtwco\n\nMigrate `rustc_lint` lint diagnostics\n\nPart 2 of [Migrate `rustc_lint` errors to `SessionDiagnostic`](https://github.com/rust-lang/rust/pull/100776)\n\nr? `@davidtwco`\n\n# TODO\n- [x] Refactor some lints manually implementing `DecorateLint` to use `Option<Subdiagnostic>`.\n- [x] Add `#[rustc_lint_diagnostics]` to lint functions in `context.rs`.\n- [x] Migrate `hidden_unicode_codepoints.rs`.\n- [x] Migrate `UnsafeCode` in `builtin.rs`.\n- [x] Migrate the rest of `builtin.rs`.", "tree": {"sha": "0bc3fd4dae36be369f19ca75aca3c1e45e2b748d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bc3fd4dae36be369f19ca75aca3c1e45e2b748d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfffe406fbcabb37b95779f2d252c4a277191e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfffe406fbcabb37b95779f2d252c4a277191e0d", "html_url": "https://github.com/rust-lang/rust/commit/bfffe406fbcabb37b95779f2d252c4a277191e0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfffe406fbcabb37b95779f2d252c4a277191e0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86ad69d4c63961b316fdbadd18bc35535f7b128b", "url": "https://api.github.com/repos/rust-lang/rust/commits/86ad69d4c63961b316fdbadd18bc35535f7b128b", "html_url": "https://github.com/rust-lang/rust/commit/86ad69d4c63961b316fdbadd18bc35535f7b128b"}, {"sha": "88e5dd2530a48b046d35402807c4b3bb44775688", "url": "https://api.github.com/repos/rust-lang/rust/commits/88e5dd2530a48b046d35402807c4b3bb44775688", "html_url": "https://github.com/rust-lang/rust/commit/88e5dd2530a48b046d35402807c4b3bb44775688"}], "stats": {"total": 3669, "additions": 2295, "deletions": 1374}, "files": [{"sha": "d63ff77d8e2558bd5decf85363d07b90258c6bef", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 59, "deletions": 2, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -15,6 +15,43 @@ lint_enum_intrinsics_mem_variant =\n \n lint_expectation = this lint expectation is unfulfilled\n     .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n+    .rationale = {$rationale}\n+\n+lint_for_loops_over_fallibles =\n+    for loop over {$article} `{$ty}`. This is more readably written as an `if let` statement\n+    .suggestion = consider using `if let` to clear intent\n+    .remove_next = to iterate over `{$recv_snip}` remove the call to `next`\n+    .use_while_let = to check pattern in a loop use `while let`\n+    .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n+\n+lint_non_binding_let_on_sync_lock =\n+    non-binding let on a synchronization lock\n+\n+lint_non_binding_let_on_drop_type =\n+    non-binding let on a type that implements `Drop`\n+\n+lint_non_binding_let_suggestion =\n+    consider binding to an unused variable to avoid immediately dropping the value\n+\n+lint_non_binding_let_multi_suggestion =\n+    consider immediately dropping the value\n+\n+lint_deprecated_lint_name =\n+    lint name `{$name}` is deprecated and may not have an effect in the future.\n+    .suggestion = change it to\n+\n+lint_renamed_or_removed_lint = {$msg}\n+    .suggestion = use the new name\n+\n+lint_unknown_lint =\n+    unknown lint: `{$name}`\n+    .suggestion = did you mean\n+\n+lint_ignored_unless_crate_specified = {$level}({$name}) is ignored unless specified at crate level\n+\n+lint_unknown_gated_lint =\n+    unknown lint: `{$name}`\n+    .note = the `{$name}` lint is unstable\n \n lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n     .label = this {$label} contains {$count ->\n@@ -55,6 +92,8 @@ lint_diag_out_of_impl =\n \n lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n+lint_bad_opt_access = {$msg}\n+\n lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n     .as_ptr_label = this pointer will be invalid\n     .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n@@ -331,6 +370,8 @@ lint_builtin_anonymous_params = anonymous parameters are deprecated and will be\n     .suggestion = try naming the parameter or explicitly ignoring it\n \n lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+    .msg_suggestion = {$msg}\n+    .default_suggestion = remove this attribute\n lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n \n@@ -391,10 +432,16 @@ lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may n\n     .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n     .help = consider using `min_{$name}` instead, which is more stable and complete\n \n-lint_builtin_clashing_extern_same_name = `{$this_fi}` redeclared with a different signature\n+lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n+lint_builtin_unpermitted_type_init_unint = the type `{$ty}` does not permit being left uninitialized\n+\n+lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n+lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+\n+lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n     .previous_decl_label = `{$orig}` previously declared here\n     .mismatch_label = this signature doesn't match the previous declaration\n-lint_builtin_clashing_extern_diff_name = `{$this_fi}` redeclares `{$orig}` with a different signature\n+lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n     .previous_decl_label = `{$orig}` previously declared here\n     .mismatch_label = this signature doesn't match the previous declaration\n \n@@ -403,6 +450,16 @@ lint_builtin_deref_nullptr = dereferencing a null pointer\n \n lint_builtin_asm_labels = avoid using named labels in inline assembly\n \n+lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n+    .note = lib.rs is the root of this crate's library target\n+    .help = to refer to it from other targets, use the library's name as the path\n+\n+lint_builtin_special_module_name_used_main = found module declaration for main.rs\n+    .note = a binary crate cannot be used as library\n+\n+lint_supertrait_as_deref_target = `{$t}` implements `Deref` with supertrait `{$target_principal}` as target\n+    .label = target type is set here\n+\n lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n     .label = overruled by previous forbid\n "}, {"sha": "3593f141df61ba783befdccf739ad5a95948a413", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 16, "deletions": 34, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,5 +1,5 @@\n+use crate::lints::{ArrayIntoIterDiag, ArrayIntoIterDiagSub};\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment};\n@@ -118,41 +118,23 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 // to an array or to a slice.\n                 _ => bug!(\"array type coerced to something other than array or slice\"),\n             };\n-            cx.struct_span_lint(\n+            let sub = if self.for_expr_span == expr.span {\n+                Some(ArrayIntoIterDiagSub::RemoveIntoIter {\n+                    span: receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                })\n+            } else if receiver_ty.is_array() {\n+                Some(ArrayIntoIterDiagSub::UseExplicitIntoIter {\n+                    start_span: expr.span.shrink_to_lo(),\n+                    end_span: receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n+                })\n+            } else {\n+                None\n+            };\n+            cx.emit_spanned_lint(\n                 ARRAY_INTO_ITER,\n                 call.ident.span,\n-                fluent::lint_array_into_iter,\n-                |diag| {\n-                    diag.set_arg(\"target\", target);\n-                    diag.span_suggestion(\n-                        call.ident.span,\n-                        fluent::use_iter_suggestion,\n-                        \"iter\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                    if self.for_expr_span == expr.span {\n-                        diag.span_suggestion(\n-                            receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                            fluent::remove_into_iter_suggestion,\n-                            \"\",\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else if receiver_ty.is_array() {\n-                        diag.multipart_suggestion(\n-                            fluent::use_explicit_into_iter_suggestion,\n-                            vec![\n-                                (expr.span.shrink_to_lo(), \"IntoIterator::into_iter(\".into()),\n-                                (\n-                                    receiver_arg.span.shrink_to_hi().to(expr.span.shrink_to_hi()),\n-                                    \")\".into(),\n-                                ),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                    diag\n-                },\n-            )\n+                ArrayIntoIterDiag { target, suggestion: call.ident.span, sub },\n+            );\n         }\n     }\n }"}, {"sha": "6f445426df70e7218c5b1a744a7ca34fdd73e66f", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 251, "deletions": 476, "changes": 727, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -22,6 +22,23 @@\n \n use crate::{\n     errors::BuiltinEllpisisInclusiveRangePatterns,\n+    lints::{\n+        BuiltinAnonymousParams, BuiltinBoxPointers, BuiltinClashingExtern,\n+        BuiltinClashingExternSub, BuiltinConstNoMangle, BuiltinDeprecatedAttrLink,\n+        BuiltinDeprecatedAttrLinkSuggestion, BuiltinDeprecatedAttrUsed, BuiltinDerefNullptr,\n+        BuiltinEllipsisInclusiveRangePatternsLint, BuiltinExplicitOutlives,\n+        BuiltinExplicitOutlivesSuggestion, BuiltinIncompleteFeatures,\n+        BuiltinIncompleteFeaturesHelp, BuiltinIncompleteFeaturesNote, BuiltinKeywordIdents,\n+        BuiltinMissingCopyImpl, BuiltinMissingDebugImpl, BuiltinMissingDoc,\n+        BuiltinMutablesTransmutes, BuiltinNoMangleGeneric, BuiltinNonShorthandFieldPatterns,\n+        BuiltinSpecialModuleNameUsed, BuiltinTrivialBounds, BuiltinTypeAliasGenericBounds,\n+        BuiltinTypeAliasGenericBoundsSuggestion, BuiltinTypeAliasWhereClause,\n+        BuiltinUnexpectedCliConfigName, BuiltinUnexpectedCliConfigValue,\n+        BuiltinUngatedAsyncFnTrackCaller, BuiltinUnnameableTestItems, BuiltinUnpermittedTypeInit,\n+        BuiltinUnpermittedTypeInitSub, BuiltinUnreachablePub, BuiltinUnsafe,\n+        BuiltinUnstableFeatures, BuiltinUnusedDocComment, BuiltinUnusedDocCommentSub,\n+        BuiltinWhileTrue, SuggestChangingAssocTypes,\n+    },\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n@@ -33,10 +50,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{\n-    fluent, Applicability, DelayDm, Diagnostic, DiagnosticBuilder, DiagnosticMessage,\n-    DiagnosticStyledString, MultiSpan,\n-};\n+use rustc_errors::{fluent, Applicability, DecorateLint, MultiSpan};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -110,25 +124,17 @@ impl EarlyLintPass for WhileTrue {\n             && !cond.span.from_expansion()\n         {\n             let condition_span = e.span.with_hi(cond.span.hi());\n-            cx.struct_span_lint(\n-                            WHILE_TRUE,\n-                            condition_span,\n-                fluent::lint_builtin_while_true,\n-                            |lint| {\n-                    lint.span_suggestion_short(\n-                        condition_span,\n-                        fluent::suggestion,\n-                        format!(\n+            let replace = format!(\n                             \"{}loop\",\n                             label.map_or_else(String::new, |label| format!(\n                                 \"{}: \",\n                                 label.ident,\n                             ))\n-                        ),\n-                        Applicability::MachineApplicable,\n-                    )\n-                },\n-            )\n+                        );\n+            cx.emit_spanned_lint(WHILE_TRUE, condition_span, BuiltinWhileTrue {\n+                suggestion: condition_span,\n+                replace,\n+            });\n         }\n     }\n }\n@@ -164,12 +170,7 @@ impl BoxPointers {\n         for leaf in ty.walk() {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n-                    cx.struct_span_lint(\n-                        BOX_POINTERS,\n-                        span,\n-                        fluent::lint_builtin_box_pointers,\n-                        |lint| lint.set_arg(\"ty\", ty),\n-                    );\n+                    cx.emit_spanned_lint(BOX_POINTERS, span, BuiltinBoxPointers { ty });\n                 }\n             }\n         }\n@@ -267,19 +268,13 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.typeck_results().field_index(fieldpat.hir_id))\n                     {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,\n                             fieldpat.span,\n-                            fluent::lint_builtin_non_shorthand_field_patterns,\n-                            |lint| {\n-                                let suggested_ident =\n-                                    format!(\"{}{}\", binding_annot.prefix_str(), ident);\n-                                lint.set_arg(\"ident\", ident).span_suggestion(\n-                                    fieldpat.span,\n-                                    fluent::suggestion,\n-                                    suggested_ident,\n-                                    Applicability::MachineApplicable,\n-                                )\n+                            BuiltinNonShorthandFieldPatterns {\n+                                ident,\n+                                suggestion: fieldpat.span,\n+                                prefix: binding_annot.prefix_str(),\n                             },\n                         );\n                     }\n@@ -321,48 +316,21 @@ impl UnsafeCode {\n         &self,\n         cx: &EarlyContext<'_>,\n         span: Span,\n-        msg: impl Into<DiagnosticMessage>,\n-        decorate: impl for<'a, 'b> FnOnce(\n-            &'b mut DiagnosticBuilder<'a, ()>,\n-        ) -> &'b mut DiagnosticBuilder<'a, ()>,\n+        decorate: impl for<'a> DecorateLint<'a, ()>,\n     ) {\n         // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n         }\n \n-        cx.struct_span_lint(UNSAFE_CODE, span, msg, decorate);\n-    }\n-\n-    fn report_overridden_symbol_name(\n-        &self,\n-        cx: &EarlyContext<'_>,\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    ) {\n-        self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint_builtin_overridden_symbol_name)\n-        })\n-    }\n-\n-    fn report_overridden_symbol_section(\n-        &self,\n-        cx: &EarlyContext<'_>,\n-        span: Span,\n-        msg: DiagnosticMessage,\n-    ) {\n-        self.report_unsafe(cx, span, msg, |lint| {\n-            lint.note(fluent::lint_builtin_overridden_symbol_section)\n-        })\n+        cx.emit_spanned_lint(UNSAFE_CODE, span, decorate);\n     }\n }\n \n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.has_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(cx, attr.span, fluent::lint_builtin_allow_internal_unsafe, |lint| {\n-                lint\n-            });\n+            self.report_unsafe(cx, attr.span, BuiltinUnsafe::AllowInternalUnsafe);\n         }\n     }\n \n@@ -371,70 +339,46 @@ impl EarlyLintPass for UnsafeCode {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, fluent::lint_builtin_unsafe_block, |lint| lint);\n+                self.report_unsafe(cx, blk.span, BuiltinUnsafe::UnsafeBlock);\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(box ast::Trait { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_trait, |lint| lint)\n+                self.report_unsafe(cx, it.span, BuiltinUnsafe::UnsafeTrait);\n             }\n \n             ast::ItemKind::Impl(box ast::Impl { unsafety: ast::Unsafe::Yes(_), .. }) => {\n-                self.report_unsafe(cx, it.span, fluent::lint_builtin_unsafe_impl, |lint| lint)\n+                self.report_unsafe(cx, it.span, BuiltinUnsafe::UnsafeImpl);\n             }\n \n             ast::ItemKind::Fn(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_no_mangle_fn,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleFn);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_export_name_fn,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameFn);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n-                    self.report_overridden_symbol_section(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_link_section_fn,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionFn);\n                 }\n             }\n \n             ast::ItemKind::Static(..) => {\n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_no_mangle_static,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleStatic);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n-                    self.report_overridden_symbol_name(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_export_name_static,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameStatic);\n                 }\n \n                 if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::link_section) {\n-                    self.report_overridden_symbol_section(\n-                        cx,\n-                        attr.span,\n-                        fluent::lint_builtin_link_section_static,\n-                    );\n+                    self.report_unsafe(cx, attr.span, BuiltinUnsafe::LinkSectionStatic);\n                 }\n             }\n \n@@ -445,18 +389,10 @@ impl EarlyLintPass for UnsafeCode {\n     fn check_impl_item(&mut self, cx: &EarlyContext<'_>, it: &ast::AssocItem) {\n         if let ast::AssocItemKind::Fn(..) = it.kind {\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n-                self.report_overridden_symbol_name(\n-                    cx,\n-                    attr.span,\n-                    fluent::lint_builtin_no_mangle_method,\n-                );\n+                self.report_unsafe(cx, attr.span, BuiltinUnsafe::NoMangleMethod);\n             }\n             if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n-                self.report_overridden_symbol_name(\n-                    cx,\n-                    attr.span,\n-                    fluent::lint_builtin_export_name_method,\n-                );\n+                self.report_unsafe(cx, attr.span, BuiltinUnsafe::ExportNameMethod);\n             }\n         }\n     }\n@@ -471,13 +407,13 @@ impl EarlyLintPass for UnsafeCode {\n             body,\n         ) = fk\n         {\n-            let msg = match ctxt {\n+            let decorator = match ctxt {\n                 FnCtxt::Foreign => return,\n-                FnCtxt::Free => fluent::lint_builtin_decl_unsafe_fn,\n-                FnCtxt::Assoc(_) if body.is_none() => fluent::lint_builtin_decl_unsafe_method,\n-                FnCtxt::Assoc(_) => fluent::lint_builtin_impl_unsafe_method,\n+                FnCtxt::Free => BuiltinUnsafe::DeclUnsafeFn,\n+                FnCtxt::Assoc(_) if body.is_none() => BuiltinUnsafe::DeclUnsafeMethod,\n+                FnCtxt::Assoc(_) => BuiltinUnsafe::ImplUnsafeMethod,\n             };\n-            self.report_unsafe(cx, span, msg, |lint| lint);\n+            self.report_unsafe(cx, span, decorator);\n         }\n     }\n }\n@@ -578,11 +514,10 @@ impl MissingDoc {\n         let attrs = cx.tcx.hir().attrs(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n         let has_doc = attrs.iter().any(has_doc);\n         if !has_doc {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 MISSING_DOCS,\n                 cx.tcx.def_span(def_id),\n-                fluent::lint_builtin_missing_doc,\n-                |lint| lint.set_arg(\"article\", article).set_arg(\"desc\", desc),\n+                BuiltinMissingDoc { article, desc },\n             );\n         }\n     }\n@@ -799,12 +734,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n         )\n         .is_ok()\n         {\n-            cx.struct_span_lint(\n-                MISSING_COPY_IMPLEMENTATIONS,\n-                item.span,\n-                fluent::lint_builtin_missing_copy_impl,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, BuiltinMissingCopyImpl);\n         }\n     }\n }\n@@ -878,11 +808,10 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.owner_id.def_id) {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n-                fluent::lint_builtin_missing_debug_impl,\n-                |lint| lint.set_arg(\"debug\", cx.tcx.def_path_str(debug)),\n+                BuiltinMissingDebugImpl { tcx: cx.tcx, def_id: debug },\n             );\n         }\n     }\n@@ -958,19 +887,11 @@ impl EarlyLintPass for AnonymousParameters {\n                         } else {\n                             (\"<type>\", Applicability::HasPlaceholders)\n                         };\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             ANONYMOUS_PARAMETERS,\n                             arg.pat.span,\n-                            fluent::lint_builtin_anonymous_params,\n-                            |lint| {\n-                                lint.span_suggestion(\n-                                    arg.pat.span,\n-                                    fluent::suggestion,\n-                                    format!(\"_: {}\", ty_snip),\n-                                    appl,\n-                                )\n-                            },\n-                        )\n+                            BuiltinAnonymousParams { suggestion: (arg.pat.span, appl), ty_snip },\n+                        );\n                     }\n                 }\n             }\n@@ -1005,42 +926,30 @@ impl EarlyLintPass for DeprecatedAttr {\n                     _,\n                 ) = gate\n                 {\n-                    // FIXME(davidtwco) translatable deprecated attr\n-                    cx.struct_span_lint(\n+                    let suggestion = match suggestion {\n+                        Some(msg) => {\n+                            BuiltinDeprecatedAttrLinkSuggestion::Msg { suggestion: attr.span, msg }\n+                        }\n+                        None => {\n+                            BuiltinDeprecatedAttrLinkSuggestion::Default { suggestion: attr.span }\n+                        }\n+                    };\n+                    cx.emit_spanned_lint(\n                         DEPRECATED,\n                         attr.span,\n-                        fluent::lint_builtin_deprecated_attr_link,\n-                        |lint| {\n-                            lint.set_arg(\"name\", name)\n-                                .set_arg(\"reason\", reason)\n-                                .set_arg(\"link\", link)\n-                                .span_suggestion_short(\n-                                    attr.span,\n-                                    suggestion.map(|s| s.into()).unwrap_or(\n-                                        fluent::lint_builtin_deprecated_attr_default_suggestion,\n-                                    ),\n-                                    \"\",\n-                                    Applicability::MachineApplicable,\n-                                )\n-                        },\n+                        BuiltinDeprecatedAttrLink { name, reason, link, suggestion },\n                     );\n                 }\n                 return;\n             }\n         }\n         if attr.has_name(sym::no_start) || attr.has_name(sym::crate_id) {\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 DEPRECATED,\n                 attr.span,\n-                fluent::lint_builtin_deprecated_attr_used,\n-                |lint| {\n-                    lint.set_arg(\"name\", pprust::path_to_string(&attr.get_normal_item().path))\n-                        .span_suggestion_short(\n-                            attr.span,\n-                            fluent::lint_builtin_deprecated_attr_default_suggestion,\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        )\n+                BuiltinDeprecatedAttrUsed {\n+                    name: pprust::path_to_string(&attr.get_normal_item().path),\n+                    suggestion: attr.span,\n                 },\n             );\n         }\n@@ -1069,20 +978,18 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n         let span = sugared_span.take().unwrap_or(attr.span);\n \n         if is_doc_comment || attr.has_name(sym::doc) {\n-            cx.struct_span_lint(\n+            let sub = match attr.kind {\n+                AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n+                    BuiltinUnusedDocCommentSub::PlainHelp\n+                }\n+                AttrKind::DocComment(CommentKind::Block, _) => {\n+                    BuiltinUnusedDocCommentSub::BlockHelp\n+                }\n+            };\n+            cx.emit_spanned_lint(\n                 UNUSED_DOC_COMMENTS,\n                 span,\n-                fluent::lint_builtin_unused_doc_comment,\n-                |lint| {\n-                    lint.set_arg(\"kind\", node_kind).span_label(node_span, fluent::label).help(\n-                        match attr.kind {\n-                            AttrKind::DocComment(CommentKind::Line, _) | AttrKind::Normal(..) => {\n-                                fluent::plain_help\n-                            }\n-                            AttrKind::DocComment(CommentKind::Block, _) => fluent::block_help,\n-                        },\n-                    )\n-                },\n+                BuiltinUnusedDocComment { kind: node_kind, label: node_span, sub },\n             );\n         }\n     }\n@@ -1197,20 +1104,10 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             NO_MANGLE_GENERIC_ITEMS,\n                             span,\n-                            fluent::lint_builtin_no_mangle_generic,\n-                            |lint| {\n-                                lint.span_suggestion_short(\n-                                    no_mangle_attr.span,\n-                                    fluent::suggestion,\n-                                    \"\",\n-                                    // Use of `#[no_mangle]` suggests FFI intent; correct\n-                                    // fix may be to monomorphize source by hand\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                            },\n+                            BuiltinNoMangleGeneric { suggestion: no_mangle_attr.span },\n                         );\n                         break;\n                     }\n@@ -1225,30 +1122,23 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n             }\n             hir::ItemKind::Const(..) => {\n                 if cx.sess().contains_name(attrs, sym::no_mangle) {\n+                    // account for \"pub const\" (#45562)\n+                    let start = cx\n+                        .tcx\n+                        .sess\n+                        .source_map()\n+                        .span_to_snippet(it.span)\n+                        .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n+                        .unwrap_or(0) as u32;\n+                    // `const` is 5 chars\n+                    let suggestion = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n+\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         NO_MANGLE_CONST_ITEMS,\n                         it.span,\n-                        fluent::lint_builtin_const_no_mangle,\n-                        |lint| {\n-                            // account for \"pub const\" (#45562)\n-                            let start = cx\n-                                .tcx\n-                                .sess\n-                                .source_map()\n-                                .span_to_snippet(it.span)\n-                                .map(|snippet| snippet.find(\"const\").unwrap_or(0))\n-                                .unwrap_or(0) as u32;\n-                            // `const` is 5 chars\n-                            let const_span = it.span.with_hi(BytePos(it.span.lo().0 + start + 5));\n-                            lint.span_suggestion(\n-                                const_span,\n-                                fluent::suggestion,\n-                                \"pub static\",\n-                                Applicability::MachineApplicable,\n-                            )\n-                        },\n+                        BuiltinConstNoMangle { suggestion },\n                     );\n                 }\n             }\n@@ -1309,12 +1199,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableTransmutes {\n             get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (ty1.kind(), ty2.kind()))\n         {\n             if from_mutbl < to_mutbl {\n-                cx.struct_span_lint(\n-                    MUTABLE_TRANSMUTES,\n-                    expr.span,\n-                    fluent::lint_builtin_mutable_transmutes,\n-                    |lint| lint,\n-                );\n+                cx.emit_spanned_lint(MUTABLE_TRANSMUTES, expr.span, BuiltinMutablesTransmutes);\n             }\n         }\n \n@@ -1362,12 +1247,7 @@ impl<'tcx> LateLintPass<'tcx> for UnstableFeatures {\n         if attr.has_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    cx.struct_span_lint(\n-                        UNSTABLE_FEATURES,\n-                        item.span(),\n-                        fluent::lint_builtin_unstable_features,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(UNSTABLE_FEATURES, item.span(), BuiltinUnstableFeatures);\n                 }\n             }\n         }\n@@ -1422,20 +1302,10 @@ impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n             // Now, check if the function has the `#[track_caller]` attribute\n             && let Some(attr) = attrs.iter().find(|attr| attr.has_name(sym::track_caller))\n             {\n-                cx.struct_span_lint(\n-                    UNGATED_ASYNC_FN_TRACK_CALLER,\n-                    attr.span,\n-                    fluent::lint_ungated_async_fn_track_caller,\n-                    |lint| {\n-                        lint.span_label(span, fluent::label);\n-                        rustc_session::parse::add_feature_diagnostics(\n-                            lint,\n-                            &cx.tcx.sess.parse_sess,\n-                            sym::closure_track_caller,\n-                        );\n-                        lint\n-                    },\n-                );\n+                cx.emit_spanned_lint(UNGATED_ASYNC_FN_TRACK_CALLER, attr.span, BuiltinUngatedAsyncFnTrackCaller {\n+                    label: span,\n+                    parse_sess: &cx.tcx.sess.parse_sess,\n+                });\n             }\n     }\n }\n@@ -1493,18 +1363,13 @@ impl UnreachablePub {\n                 applicability = Applicability::MaybeIncorrect;\n             }\n             let def_span = cx.tcx.def_span(def_id);\n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 UNREACHABLE_PUB,\n                 def_span,\n-                fluent::lint_builtin_unreachable_pub,\n-                |lint| {\n-                    lint.set_arg(\"what\", what);\n-\n-                    lint.span_suggestion(vis_span, fluent::suggestion, \"pub(crate)\", applicability);\n-                    if exportable {\n-                        lint.help(fluent::help);\n-                    }\n-                    lint\n+                BuiltinUnreachablePub {\n+                    what,\n+                    suggestion: (vis_span, applicability),\n+                    help: exportable.then_some(()),\n                 },\n             );\n         }\n@@ -1569,7 +1434,7 @@ declare_lint_pass!(\n );\n \n impl TypeAliasBounds {\n-    fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n+    pub(crate) fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n@@ -1583,29 +1448,6 @@ impl TypeAliasBounds {\n             hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => false,\n         }\n     }\n-\n-    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut Diagnostic) {\n-        // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n-        // bound.  Let's see if this type does that.\n-\n-        // We use a HIR visitor to walk the type.\n-        use rustc_hir::intravisit::{self, Visitor};\n-        struct WalkAssocTypes<'a> {\n-            err: &'a mut Diagnostic,\n-        }\n-        impl Visitor<'_> for WalkAssocTypes<'_> {\n-            fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n-                if TypeAliasBounds::is_type_variable_assoc(qpath) {\n-                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n-                }\n-                intravisit::walk_qpath(self, qpath, id)\n-            }\n-        }\n-\n-        // Let's go for a walk!\n-        let mut visitor = WalkAssocTypes { err };\n-        visitor.visit_ty(ty);\n-    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n@@ -1639,35 +1481,31 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_where_clause, |lint| {\n-                lint.set_span(where_spans);\n-                lint.span_suggestion(\n-                    type_alias_generics.where_clause_span,\n-                    fluent::suggestion,\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n-                    suggested_changing_assoc_types = true;\n-                }\n-                lint\n+            let sub = (!suggested_changing_assoc_types).then(|| {\n+                suggested_changing_assoc_types = true;\n+                SuggestChangingAssocTypes { ty }\n             });\n+            cx.emit_spanned_lint(\n+                TYPE_ALIAS_BOUNDS,\n+                where_spans,\n+                BuiltinTypeAliasWhereClause {\n+                    suggestion: type_alias_generics.where_clause_span,\n+                    sub,\n+                },\n+            );\n         }\n \n         if !inline_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_generic_bounds, |lint| {\n-                lint.set_span(inline_spans);\n-                lint.multipart_suggestion(\n-                    fluent::suggestion,\n-                    inline_sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n-                }\n-                lint\n+            let suggestion = BuiltinTypeAliasGenericBoundsSuggestion { suggestions: inline_sugg };\n+            let sub = (!suggested_changing_assoc_types).then(|| {\n+                suggested_changing_assoc_types = true;\n+                SuggestChangingAssocTypes { ty }\n             });\n+            cx.emit_spanned_lint(\n+                TYPE_ALIAS_BOUNDS,\n+                inline_spans,\n+                BuiltinTypeAliasGenericBounds { suggestion, sub },\n+            );\n         }\n     }\n }\n@@ -1767,14 +1605,10 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         TRIVIAL_BOUNDS,\n                         span,\n-                        fluent::lint_builtin_trivial_bounds,\n-                        |lint| {\n-                            lint.set_arg(\"predicate_kind_name\", predicate_kind_name)\n-                                .set_arg(\"predicate\", predicate)\n-                        },\n+                        BuiltinTrivialBounds { predicate_kind_name, predicate },\n                     );\n                 }\n             }\n@@ -1875,8 +1709,6 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n         };\n \n         if let Some((start, end, join)) = endpoints {\n-            let msg = fluent::lint_builtin_ellipsis_inclusive_range_patterns;\n-            let suggestion = fluent::suggestion;\n             if parenthesise {\n                 self.node_id = Some(pat.id);\n                 let end = expr_to_string(&end);\n@@ -1891,14 +1723,14 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace,\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, pat.span, msg, |lint| {\n-                        lint.span_suggestion(\n-                            pat.span,\n-                            suggestion,\n+                    cx.emit_spanned_lint(\n+                        ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                        pat.span,\n+                        BuiltinEllipsisInclusiveRangePatternsLint::Parenthesise {\n+                            suggestion: pat.span,\n                             replace,\n-                            Applicability::MachineApplicable,\n-                        )\n-                    });\n+                        },\n+                    );\n                 }\n             } else {\n                 let replace = \"..=\";\n@@ -1909,14 +1741,13 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                         replace: replace.to_string(),\n                     });\n                 } else {\n-                    cx.struct_span_lint(ELLIPSIS_INCLUSIVE_RANGE_PATTERNS, join, msg, |lint| {\n-                        lint.span_suggestion_short(\n-                            join,\n-                            suggestion,\n-                            replace,\n-                            Applicability::MachineApplicable,\n-                        )\n-                    });\n+                    cx.emit_spanned_lint(\n+                        ELLIPSIS_INCLUSIVE_RANGE_PATTERNS,\n+                        join,\n+                        BuiltinEllipsisInclusiveRangePatternsLint::NonParenthesise {\n+                            suggestion: join,\n+                        },\n+                    );\n                 }\n             };\n         }\n@@ -1996,12 +1827,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if let Some(attr) = cx.sess().find_by_name(attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(\n-                UNNAMEABLE_TEST_ITEMS,\n-                attr.span,\n-                fluent::lint_builtin_unnameable_test_items,\n-                |lint| lint,\n-            );\n+            cx.emit_spanned_lint(UNNAMEABLE_TEST_ITEMS, attr.span, BuiltinUnnameableTestItems);\n         }\n     }\n \n@@ -2117,18 +1943,10 @@ impl KeywordIdents {\n             return;\n         }\n \n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             KEYWORD_IDENTS,\n             ident.span,\n-            fluent::lint_builtin_keyword_idents,\n-            |lint| {\n-                lint.set_arg(\"kw\", ident).set_arg(\"next\", next_edition).span_suggestion(\n-                    ident.span,\n-                    fluent::suggestion,\n-                    format!(\"r#{}\", ident),\n-                    Applicability::MachineApplicable,\n-                )\n-            },\n+            BuiltinKeywordIdents { kw: ident, next: next_edition, suggestion: ident.span },\n         );\n     }\n }\n@@ -2405,16 +2223,15 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     Applicability::MaybeIncorrect\n                 };\n \n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     EXPLICIT_OUTLIVES_REQUIREMENTS,\n                     lint_spans.clone(),\n-                    fluent::lint_builtin_explicit_outlives,\n-                    |lint| {\n-                        lint.set_arg(\"count\", bound_count).multipart_suggestion(\n-                            fluent::suggestion,\n-                            lint_spans.into_iter().map(|span| (span, String::new())).collect(),\n+                    BuiltinExplicitOutlives {\n+                        count: bound_count,\n+                        suggestion: BuiltinExplicitOutlivesSuggestion {\n+                            spans: lint_spans,\n                             applicability,\n-                        )\n+                        },\n                     },\n                 );\n             }\n@@ -2463,24 +2280,18 @@ impl EarlyLintPass for IncompleteFeatures {\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(&name, _)| features.incomplete(name))\n             .for_each(|(&name, &span)| {\n-                cx.struct_span_lint(\n+                let note = rustc_feature::find_feature_issue(name, GateIssue::Language)\n+                    .map(|n| BuiltinIncompleteFeaturesNote { n });\n+                let help = if HAS_MIN_FEATURES.contains(&name) {\n+                    Some(BuiltinIncompleteFeaturesHelp)\n+                } else {\n+                    None\n+                };\n+                cx.emit_spanned_lint(\n                     INCOMPLETE_FEATURES,\n                     span,\n-                    fluent::lint_builtin_incomplete_features,\n-                    |lint| {\n-                        lint.set_arg(\"name\", name);\n-                        if let Some(n) =\n-                            rustc_feature::find_feature_issue(name, GateIssue::Language)\n-                        {\n-                            lint.set_arg(\"n\", n);\n-                            lint.note(fluent::note);\n-                        }\n-                        if HAS_MIN_FEATURES.contains(&name) {\n-                            lint.help(fluent::help);\n-                        }\n-                        lint\n-                    },\n-                )\n+                    BuiltinIncompleteFeatures { name, note, help },\n+                );\n             });\n     }\n }\n@@ -2525,6 +2336,36 @@ declare_lint! {\n \n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n \n+/// Information about why a type cannot be initialized this way.\n+pub struct InitError {\n+    pub(crate) message: String,\n+    /// Spans from struct fields and similar that can be obtained from just the type.\n+    pub(crate) span: Option<Span>,\n+    /// Used to report a trace through adts.\n+    pub(crate) nested: Option<Box<InitError>>,\n+}\n+impl InitError {\n+    fn spanned(self, span: Span) -> InitError {\n+        Self { span: Some(span), ..self }\n+    }\n+\n+    fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n+        assert!(self.nested.is_none());\n+        Self { nested: nested.into().map(Box::new), ..self }\n+    }\n+}\n+\n+impl<'a> From<&'a str> for InitError {\n+    fn from(s: &'a str) -> Self {\n+        s.to_owned().into()\n+    }\n+}\n+impl From<String> for InitError {\n+    fn from(message: String) -> Self {\n+        Self { message, span: None, nested: None }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n@@ -2533,36 +2374,6 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             Uninit,\n         }\n \n-        /// Information about why a type cannot be initialized this way.\n-        struct InitError {\n-            message: String,\n-            /// Spans from struct fields and similar that can be obtained from just the type.\n-            span: Option<Span>,\n-            /// Used to report a trace through adts.\n-            nested: Option<Box<InitError>>,\n-        }\n-        impl InitError {\n-            fn spanned(self, span: Span) -> InitError {\n-                Self { span: Some(span), ..self }\n-            }\n-\n-            fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n-                assert!(self.nested.is_none());\n-                Self { nested: nested.into().map(Box::new), ..self }\n-            }\n-        }\n-\n-        impl<'a> From<&'a str> for InitError {\n-            fn from(s: &'a str) -> Self {\n-                s.to_owned().into()\n-            }\n-        }\n-        impl From<String> for InitError {\n-            fn from(message: String) -> Self {\n-                Self { message, span: None, nested: None }\n-            }\n-        }\n-\n         /// Test if this constant is all-0.\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n             use hir::ExprKind::*;\n@@ -2786,46 +2597,16 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n-            if let Some(mut err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n-            {\n-                // FIXME(davidtwco): make translatable\n-                cx.struct_span_lint(\n+            if let Some(err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init)) {\n+                let msg = match init {\n+                    InitKind::Zeroed => fluent::lint_builtin_unpermitted_type_init_zeroed,\n+                    InitKind::Uninit => fluent::lint_builtin_unpermitted_type_init_unint,\n+                };\n+                let sub = BuiltinUnpermittedTypeInitSub { err };\n+                cx.emit_spanned_lint(\n                     INVALID_VALUE,\n                     expr.span,\n-                    DelayDm(|| {\n-                        format!(\n-                            \"the type `{}` does not permit {}\",\n-                            conjured_ty,\n-                            match init {\n-                                InitKind::Zeroed => \"zero-initialization\",\n-                                InitKind::Uninit => \"being left uninitialized\",\n-                            },\n-                        )\n-                    }),\n-                    |lint| {\n-                        lint.span_label(\n-                            expr.span,\n-                            \"this code causes undefined behavior when executed\",\n-                        );\n-                        lint.span_label(\n-                            expr.span,\n-                            \"help: use `MaybeUninit<T>` instead, \\\n-                            and only call `assume_init` after initialization is done\",\n-                        );\n-                        loop {\n-                            if let Some(span) = err.span {\n-                                lint.span_note(span, &err.message);\n-                            } else {\n-                                lint.note(&err.message);\n-                            }\n-                            if let Some(e) = err.nested {\n-                                err = *e;\n-                            } else {\n-                                break;\n-                            }\n-                        }\n-                        lint\n-                    },\n+                    BuiltinUnpermittedTypeInit { msg, ty: conjured_ty, label: expr.span, sub },\n                 );\n             }\n         }\n@@ -3171,31 +2952,39 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                             SymbolName::Normal(_) => fi.span,\n                             SymbolName::Link(_, annot_span) => fi.span.to(annot_span),\n                         };\n-                    // Finally, emit the diagnostic.\n \n-                    let msg = if orig.get_name() == this_fi.ident.name {\n-                        fluent::lint_builtin_clashing_extern_same_name\n+                    // Finally, emit the diagnostic.\n+                    let this = this_fi.ident.name;\n+                    let orig = orig.get_name();\n+                    let previous_decl_label = get_relevant_span(orig_fi);\n+                    let mismatch_label = get_relevant_span(this_fi);\n+                    let sub = BuiltinClashingExternSub {\n+                        tcx,\n+                        expected: existing_decl_ty,\n+                        found: this_decl_ty,\n+                    };\n+                    let decorator = if orig == this {\n+                        BuiltinClashingExtern::SameName {\n+                            this,\n+                            orig,\n+                            previous_decl_label,\n+                            mismatch_label,\n+                            sub,\n+                        }\n                     } else {\n-                        fluent::lint_builtin_clashing_extern_diff_name\n+                        BuiltinClashingExtern::DiffName {\n+                            this,\n+                            orig,\n+                            previous_decl_label,\n+                            mismatch_label,\n+                            sub,\n+                        }\n                     };\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         CLASHING_EXTERN_DECLARATIONS,\n                         this_fi.hir_id(),\n                         get_relevant_span(this_fi),\n-                        msg,\n-                        |lint| {\n-                            let mut expected_str = DiagnosticStyledString::new();\n-                            expected_str.push(existing_decl_ty.fn_sig(tcx).to_string(), false);\n-                            let mut found_str = DiagnosticStyledString::new();\n-                            found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n-\n-                            lint.set_arg(\"this_fi\", this_fi.ident.name)\n-                                .set_arg(\"orig\", orig.get_name())\n-                                .span_label(get_relevant_span(orig_fi), fluent::previous_decl_label)\n-                                .span_label(get_relevant_span(this_fi), fluent::mismatch_label)\n-                                // FIXME(davidtwco): translatable expected/found\n-                                .note_expected_found(&\"\", expected_str, &\"\", found_str)\n-                        },\n+                        decorator,\n                     );\n                 }\n             }\n@@ -3275,11 +3064,10 @@ impl<'tcx> LateLintPass<'tcx> for DerefNullPtr {\n \n         if let rustc_hir::ExprKind::Unary(rustc_hir::UnOp::Deref, expr_deref) = expr.kind {\n             if is_null_ptr(cx, expr_deref) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     DEREF_NULLPTR,\n                     expr.span,\n-                    fluent::lint_builtin_deref_nullptr,\n-                    |lint| lint.span_label(expr.span, fluent::label),\n+                    BuiltinDerefNullptr { label: expr.span },\n                 );\n             }\n         }\n@@ -3324,6 +3112,7 @@ declare_lint! {\n declare_lint_pass!(NamedAsmLabels => [NAMED_ASM_LABELS]);\n \n impl<'tcx> LateLintPass<'tcx> for NamedAsmLabels {\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n         if let hir::Expr {\n             kind: hir::ExprKind::InlineAsm(hir::InlineAsm { template_strs, .. }),\n@@ -3464,16 +3253,17 @@ impl EarlyLintPass for SpecialModuleName {\n                 }\n \n                 match item.ident.name.as_str() {\n-                    \"lib\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for lib.rs\", |lint| {\n-                        lint\n-                            .note(\"lib.rs is the root of this crate's library target\")\n-                            .help(\"to refer to it from other targets, use the library's name as the path\")\n-                    }),\n-                    \"main\" => cx.struct_span_lint(SPECIAL_MODULE_NAME, item.span, \"found module declaration for main.rs\", |lint| {\n-                        lint\n-                            .note(\"a binary crate cannot be used as library\")\n-                    }),\n-                    _ => continue\n+                    \"lib\" => cx.emit_spanned_lint(\n+                        SPECIAL_MODULE_NAME,\n+                        item.span,\n+                        BuiltinSpecialModuleNameUsed::Lib,\n+                    ),\n+                    \"main\" => cx.emit_spanned_lint(\n+                        SPECIAL_MODULE_NAME,\n+                        item.span,\n+                        BuiltinSpecialModuleNameUsed::Main,\n+                    ),\n+                    _ => continue,\n                 }\n             }\n         }\n@@ -3489,31 +3279,16 @@ impl EarlyLintPass for UnexpectedCfgs {\n         let cfg = &cx.sess().parse_sess.config;\n         let check_cfg = &cx.sess().parse_sess.check_config;\n         for &(name, value) in cfg {\n-            if let Some(names_valid) = &check_cfg.names_valid {\n-                if !names_valid.contains(&name) {\n-                    cx.lookup(\n-                        UNEXPECTED_CFGS,\n-                        None::<MultiSpan>,\n-                        fluent::lint_builtin_unexpected_cli_config_name,\n-                        |diag| diag.help(fluent::help).set_arg(\"name\", name),\n-                    );\n-                }\n+            if let Some(names_valid) = &check_cfg.names_valid && !names_valid.contains(&name){\n+                cx.emit_lint(UNEXPECTED_CFGS, BuiltinUnexpectedCliConfigName {\n+                    name,\n+                });\n             }\n-            if let Some(value) = value {\n-                if let Some(values) = &check_cfg.values_valid.get(&name) {\n-                    if !values.contains(&value) {\n-                        cx.lookup(\n-                            UNEXPECTED_CFGS,\n-                            None::<MultiSpan>,\n-                            fluent::lint_builtin_unexpected_cli_config_value,\n-                            |diag| {\n-                                diag.help(fluent::help)\n-                                    .set_arg(\"name\", name)\n-                                    .set_arg(\"value\", value)\n-                            },\n-                        );\n-                    }\n-                }\n+            if let Some(value) = value && let Some(values) = check_cfg.values_valid.get(&name) && !values.contains(&value) {\n+                cx.emit_lint(\n+                    UNEXPECTED_CFGS,\n+                    BuiltinUnexpectedCliConfigValue { name, value },\n+                );\n             }\n         }\n     }"}, {"sha": "c9b9a62257148c51a8614717ade5d77b03cf30d1", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -965,6 +965,7 @@ pub trait LintContext: Sized {\n     /// Note that this function should only be called for [`LintExpectationId`]s\n     /// retrieved from the current lint pass. Buffered or manually created ids can\n     /// cause ICEs.\n+    #[rustc_lint_diagnostics]\n     fn fulfill_expectation(&self, expectation: LintExpectationId) {\n         // We need to make sure that submitted expectation ids are correctly fulfilled suppressed\n         // and stored between compilation sessions. To not manually do these steps, we simply create\n@@ -1011,6 +1012,7 @@ impl<'tcx> LintContext for LateContext<'tcx> {\n         &*self.lint_store\n     }\n \n+    #[rustc_lint_diagnostics]\n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,\n@@ -1045,6 +1047,7 @@ impl LintContext for EarlyContext<'_> {\n         self.builder.lint_store()\n     }\n \n+    #[rustc_lint_diagnostics]\n     fn lookup<S: Into<MultiSpan>>(\n         &self,\n         lint: &'static Lint,"}, {"sha": "dff5a645c175ecf11c0d30de5917caa78148f659", "filename": "compiler/rustc_lint/src/deref_into_dyn_supertrait.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fderef_into_dyn_supertrait.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,6 +1,8 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n+use crate::{\n+    lints::{SupertraitAsDerefTarget, SupertraitAsDerefTargetLabel},\n+    LateContext, LateLintPass, LintContext,\n+};\n \n-use rustc_errors::DelayDm;\n use rustc_hir as hir;\n use rustc_middle::{traits::util::supertraits, ty};\n use rustc_span::sym;\n@@ -71,22 +73,14 @@ impl<'tcx> LateLintPass<'tcx> for DerefIntoDynSupertrait {\n             && supertraits(cx.tcx, t_principal.with_self_ty(cx.tcx, cx.tcx.types.trait_object_dummy_self))\n                 .any(|sup| sup.map_bound(|x| ty::ExistentialTraitRef::erase_self_ty(cx.tcx, x)) == target_principal)\n         {\n-            cx.struct_span_lint(\n-                DEREF_INTO_DYN_SUPERTRAIT,\n-                cx.tcx.def_span(item.owner_id.def_id),\n-                DelayDm(|| {\n-                    format!(\n-                        \"`{t}` implements `Deref` with supertrait `{target_principal}` as target\"\n-                    )\n-                }),\n-                |lint| {\n-                    if let Some(target_span) = impl_.items.iter().find_map(|i| (i.ident.name == sym::Target).then_some(i.span)) {\n-                        lint.span_label(target_span, \"target type is set here\");\n-                    }\n-\n-                    lint\n-                },\n-            )\n+            let label = impl_.items.iter().find_map(|i| (i.ident.name == sym::Target).then_some(i.span)).map(|label| SupertraitAsDerefTargetLabel {\n+                label,\n+            });\n+            cx.emit_spanned_lint(DEREF_INTO_DYN_SUPERTRAIT, cx.tcx.def_span(item.owner_id.def_id), SupertraitAsDerefTarget {\n+                t,\n+                target_principal: target_principal.to_string(),\n+                label,\n+            });\n         }\n     }\n }"}, {"sha": "f9b2df49592244fa701928bfbe71eeac0357df41", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -40,6 +40,7 @@ pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     fn inlined_check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n             let BufferedEarlyLint { span, msg, node_id: _, lint_id, diagnostic } = early_lint;"}, {"sha": "73bd4173270baf86c56f6aa3548368ab1d15e7a3", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,5 +1,8 @@\n-use crate::{context::LintContext, LateContext, LateLintPass};\n-use rustc_errors::fluent;\n+use crate::{\n+    context::LintContext,\n+    lints::{EnumIntrinsicsMemDiscriminate, EnumIntrinsicsMemVariant},\n+    LateContext, LateLintPass,\n+};\n use rustc_hir as hir;\n use rustc_middle::ty::{visit::TypeVisitable, Ty};\n use rustc_span::{symbol::sym, Span};\n@@ -50,23 +53,21 @@ fn enforce_mem_discriminant(\n ) {\n     let ty_param = cx.typeck_results().node_substs(func_expr.hir_id).type_at(0);\n     if is_non_enum(ty_param) {\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             expr_span,\n-            fluent::lint_enum_intrinsics_mem_discriminant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).span_note(args_span, fluent::note),\n+            EnumIntrinsicsMemDiscriminate { ty_param, note: args_span },\n         );\n     }\n }\n \n fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, span: Span) {\n     let ty_param = cx.typeck_results().node_substs(func_expr.hir_id).type_at(0);\n     if is_non_enum(ty_param) {\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             ENUM_INTRINSICS_NON_ENUMS,\n             span,\n-            fluent::lint_enum_intrinsics_mem_variant,\n-            |lint| lint.set_arg(\"ty_param\", ty_param).note(fluent::note),\n+            EnumIntrinsicsMemVariant { ty_param },\n         );\n     }\n }"}, {"sha": "f3ae26091863d964f7c9f827153d9f202f153cc7", "filename": "compiler/rustc_lint/src/errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ferrors.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -8,12 +8,12 @@ use rustc_span::{Span, Symbol};\n \n #[derive(Diagnostic)]\n #[diag(lint_overruled_attribute, code = \"E0453\")]\n-pub struct OverruledAttribute {\n+pub struct OverruledAttribute<'a> {\n     #[primary_span]\n     pub span: Span,\n     #[label]\n     pub overruled: Span,\n-    pub lint_level: String,\n+    pub lint_level: &'a str,\n     pub lint_source: Symbol,\n     #[subdiagnostic]\n     pub sub: OverruledAttributeSub,\n@@ -38,6 +38,7 @@ impl AddToDiagnostic for OverruledAttributeSub {\n             OverruledAttributeSub::NodeSource { span, reason } => {\n                 diag.span_label(span, fluent::lint_node_source);\n                 if let Some(rationale) = reason {\n+                    #[allow(rustc::untranslatable_diagnostic)]\n                     diag.note(rationale.as_str());\n                 }\n             }"}, {"sha": "70c999811a52b297c9363298f75f389e8cff68b8", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,8 +1,7 @@\n-use crate::builtin;\n-use rustc_errors::fluent;\n-use rustc_hir::HirId;\n+use crate::lints::{Expectation, ExpectationNote};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::{lint::LintExpectation, ty::TyCtxt};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::lint::builtin::UNFULFILLED_LINT_EXPECTATIONS;\n use rustc_session::lint::LintExpectationId;\n use rustc_span::symbol::sym;\n use rustc_span::Symbol;\n@@ -28,34 +27,17 @@ fn check_expectations(tcx: TyCtxt<'_>, tool_filter: Option<Symbol>) {\n             if !fulfilled_expectations.contains(&id)\n                 && tool_filter.map_or(true, |filter| expectation.lint_tool == Some(filter))\n             {\n-                emit_unfulfilled_expectation_lint(tcx, *hir_id, expectation);\n+                let rationale = expectation.reason.map(|rationale| ExpectationNote { rationale });\n+                let note = expectation.is_unfulfilled_lint_expectations.then_some(());\n+                tcx.emit_spanned_lint(\n+                    UNFULFILLED_LINT_EXPECTATIONS,\n+                    *hir_id,\n+                    expectation.emission_span,\n+                    Expectation { rationale, note },\n+                );\n             }\n         } else {\n             unreachable!(\"at this stage all `LintExpectationId`s are stable\");\n         }\n     }\n }\n-\n-fn emit_unfulfilled_expectation_lint(\n-    tcx: TyCtxt<'_>,\n-    hir_id: HirId,\n-    expectation: &LintExpectation,\n-) {\n-    tcx.struct_span_lint_hir(\n-        builtin::UNFULFILLED_LINT_EXPECTATIONS,\n-        hir_id,\n-        expectation.emission_span,\n-        fluent::lint_expectation,\n-        |lint| {\n-            if let Some(rationale) = expectation.reason {\n-                lint.note(rationale.as_str());\n-            }\n-\n-            if expectation.is_unfulfilled_lint_expectations {\n-                lint.note(fluent::note);\n-            }\n-\n-            lint\n-        },\n-    );\n-}"}, {"sha": "5219992ee94f0a76e4590bb0bebbe5508c029140", "filename": "compiler/rustc_lint/src/for_loops_over_fallibles.rs", "status": "modified", "additions": 27, "deletions": 46, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ffor_loops_over_fallibles.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,12 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n+use crate::{\n+    lints::{\n+        ForLoopsOverFalliblesDiag, ForLoopsOverFalliblesLoopSub, ForLoopsOverFalliblesQuestionMark,\n+        ForLoopsOverFalliblesSuggestion,\n+    },\n+    LateContext, LateLintPass, LintContext,\n+};\n \n use hir::{Expr, Pat};\n-use rustc_errors::{Applicability, DelayDm};\n use rustc_hir as hir;\n use rustc_infer::{infer::TyCtxtInferExt, traits::ObligationCause};\n use rustc_middle::ty::{self, List};\n@@ -53,53 +58,29 @@ impl<'tcx> LateLintPass<'tcx> for ForLoopsOverFallibles {\n             _ => return,\n         };\n \n-        let msg = DelayDm(|| {\n-            format!(\n-                \"for loop over {article} `{ty}`. This is more readably written as an `if let` statement\",\n-            )\n-        });\n-\n-        cx.struct_span_lint(FOR_LOOPS_OVER_FALLIBLES, arg.span, msg, |lint| {\n-            if let Some(recv) = extract_iterator_next_call(cx, arg)\n+        let sub =  if let Some(recv) = extract_iterator_next_call(cx, arg)\n             && let Ok(recv_snip) = cx.sess().source_map().span_to_snippet(recv.span)\n             {\n-                lint.span_suggestion(\n-                    recv.span.between(arg.span.shrink_to_hi()),\n-                    format!(\"to iterate over `{recv_snip}` remove the call to `next`\"),\n-                    \".by_ref()\",\n-                    Applicability::MaybeIncorrect\n-                );\n+                ForLoopsOverFalliblesLoopSub::RemoveNext { suggestion: recv.span.between(arg.span.shrink_to_hi()), recv_snip }\n             } else {\n-                lint.multipart_suggestion_verbose(\n-                    \"to check pattern in a loop use `while let`\",\n-                    vec![\n-                        // NB can't use `until` here because `expr.span` and `pat.span` have different syntax contexts\n-                        (expr.span.with_hi(pat.span.lo()), format!(\"while let {var}(\")),\n-                        (pat.span.between(arg.span), \") = \".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect\n-                );\n-            }\n-\n-            if suggest_question_mark(cx, adt, substs, expr.span) {\n-                lint.span_suggestion(\n-                    arg.span.shrink_to_hi(),\n-                    \"consider unwrapping the `Result` with `?` to iterate over its contents\",\n-                    \"?\",\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            lint.multipart_suggestion_verbose(\n-                \"consider using `if let` to clear intent\",\n-                vec![\n-                    // NB can't use `until` here because `expr.span` and `pat.span` have different syntax contexts\n-                    (expr.span.with_hi(pat.span.lo()), format!(\"if let {var}(\")),\n-                    (pat.span.between(arg.span), \") = \".to_string()),\n-                ],\n-                Applicability::MaybeIncorrect,\n-            )\n-        })\n+                ForLoopsOverFalliblesLoopSub::UseWhileLet { start_span: expr.span.with_hi(pat.span.lo()), end_span: pat.span.between(arg.span), var }\n+            } ;\n+        let question_mark = if suggest_question_mark(cx, adt, substs, expr.span) {\n+            Some(ForLoopsOverFalliblesQuestionMark { suggestion: arg.span.shrink_to_hi() })\n+        } else {\n+            None\n+        };\n+        let suggestion = ForLoopsOverFalliblesSuggestion {\n+            var,\n+            start_span: expr.span.with_hi(pat.span.lo()),\n+            end_span: pat.span.between(arg.span),\n+        };\n+\n+        cx.emit_spanned_lint(\n+            FOR_LOOPS_OVER_FALLIBLES,\n+            arg.span,\n+            ForLoopsOverFalliblesDiag { article, ty, sub, question_mark, suggestion },\n+        );\n     }\n }\n "}, {"sha": "7c1af6bee1dd6e3835ece76b689baaeb082136a0", "filename": "compiler/rustc_lint/src/hidden_unicode_codepoints.rs", "status": "modified", "additions": 18, "deletions": 49, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fhidden_unicode_codepoints.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,12 @@\n-use crate::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{\n+    lints::{\n+        HiddenUnicodeCodepointsDiag, HiddenUnicodeCodepointsDiagLabels,\n+        HiddenUnicodeCodepointsDiagSub,\n+    },\n+    EarlyContext, EarlyLintPass, LintContext,\n+};\n use ast::util::unicode::{contains_text_flow_control_chars, TEXT_FLOW_CONTROL_CHARS};\n use rustc_ast as ast;\n-use rustc_errors::{fluent, Applicability, SuggestionStyle};\n use rustc_span::{BytePos, Span, Symbol};\n \n declare_lint! {\n@@ -60,55 +65,19 @@ impl HiddenUnicodeCodepoints {\n             })\n             .collect();\n \n-        cx.struct_span_lint(\n+        let count = spans.len();\n+        let labels = point_at_inner_spans\n+            .then_some(HiddenUnicodeCodepointsDiagLabels { spans: spans.clone() });\n+        let sub = if point_at_inner_spans && !spans.is_empty() {\n+            HiddenUnicodeCodepointsDiagSub::Escape { spans }\n+        } else {\n+            HiddenUnicodeCodepointsDiagSub::NoEscape { spans }\n+        };\n+\n+        cx.emit_spanned_lint(\n             TEXT_DIRECTION_CODEPOINT_IN_LITERAL,\n             span,\n-            fluent::lint_hidden_unicode_codepoints,\n-            |lint| {\n-                lint.set_arg(\"label\", label);\n-                lint.set_arg(\"count\", spans.len());\n-                lint.span_label(span, fluent::label);\n-                lint.note(fluent::note);\n-                if point_at_inner_spans {\n-                    for (c, span) in &spans {\n-                        lint.span_label(*span, format!(\"{:?}\", c));\n-                    }\n-                }\n-                if point_at_inner_spans && !spans.is_empty() {\n-                    lint.multipart_suggestion_with_style(\n-                        fluent::suggestion_remove,\n-                        spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n-                        Applicability::MachineApplicable,\n-                        SuggestionStyle::HideCodeAlways,\n-                    );\n-                    lint.multipart_suggestion(\n-                        fluent::suggestion_escape,\n-                        spans\n-                            .into_iter()\n-                            .map(|(c, span)| {\n-                                let c = format!(\"{:?}\", c);\n-                                (span, c[1..c.len() - 1].to_string())\n-                            })\n-                            .collect(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n-                    // should do the same here to provide the same good suggestions as we do for\n-                    // literals above.\n-                    lint.set_arg(\n-                        \"escaped\",\n-                        spans\n-                            .into_iter()\n-                            .map(|(c, _)| format!(\"{:?}\", c))\n-                            .collect::<Vec<String>>()\n-                            .join(\", \"),\n-                    );\n-                    lint.note(fluent::suggestion_remove);\n-                    lint.note(fluent::no_suggestion_note_escape);\n-                }\n-                lint\n-            },\n+            HiddenUnicodeCodepointsDiag { label, count, span_label: span, labels, sub },\n         );\n     }\n }"}, {"sha": "5eb54cc0034279392c1eac3a4cdf8ad6b7d78b80", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 33, "deletions": 76, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,9 +1,12 @@\n //! Some lints that are only useful in the compiler or crates that use compiler internals, such as\n //! Clippy.\n \n+use crate::lints::{\n+    BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistantDocKeyword,\n+    QueryInstability, TyQualified, TykindDiag, TykindKind, UntranslatableDiag,\n+};\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir::def::Res;\n use rustc_hir::{def_id::DefId, Expr, ExprKind, GenericArg, PatKind, Path, PathSegment, QPath};\n use rustc_hir::{HirId, Impl, Item, ItemKind, Node, Pat, Ty, TyKind};\n@@ -29,20 +32,15 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             // don't lint imports, only actual usages\n             return;\n         }\n-        let replace = match cx.tcx.get_diagnostic_name(def_id) {\n+        let preferred = match cx.tcx.get_diagnostic_name(def_id) {\n             Some(sym::HashMap) => \"FxHashMap\",\n             Some(sym::HashSet) => \"FxHashSet\",\n             _ => return,\n         };\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             DEFAULT_HASH_TYPES,\n             path.span,\n-            fluent::lint_default_hash_types,\n-            |lint| {\n-                lint.set_arg(\"preferred\", replace)\n-                    .set_arg(\"used\", cx.tcx.item_name(def_id))\n-                    .note(fluent::note)\n-            },\n+            DefaultHashTypesDiag { preferred, used: cx.tcx.item_name(def_id) },\n         );\n     }\n }\n@@ -83,12 +81,11 @@ impl LateLintPass<'_> for QueryStability {\n         if let Ok(Some(instance)) = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs) {\n             let def_id = instance.def_id();\n             if cx.tcx.has_attr(def_id, sym::rustc_lint_query_instability) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     POTENTIAL_QUERY_INSTABILITY,\n                     span,\n-                    fluent::lint_query_instability,\n-                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::note),\n-                )\n+                    QueryInstability { query: cx.tcx.item_name(def_id) },\n+                );\n             }\n         }\n     }\n@@ -126,14 +123,8 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             let span = path.span.with_hi(\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n-            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint_tykind_kind, |lint| {\n-                lint\n-                    .span_suggestion(\n-                        span,\n-                        fluent::suggestion,\n-                        \"ty\",\n-                        Applicability::MaybeIncorrect, // ty maybe needs an import\n-                    )\n+            cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindKind {\n+                suggestion: span,\n             });\n         }\n     }\n@@ -190,39 +181,17 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n \n                     match span {\n                         Some(span) => {\n-                            cx.struct_span_lint(\n-                                USAGE_OF_TY_TYKIND,\n-                                path.span,\n-                                fluent::lint_tykind_kind,\n-                                |lint| lint.span_suggestion(\n-                                    span,\n-                                    fluent::suggestion,\n-                                    \"ty\",\n-                                    Applicability::MaybeIncorrect, // ty maybe needs an import\n-                                )\n-                            )\n+                            cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindKind {\n+                                suggestion: span,\n+                            });\n                         },\n-                        None => cx.struct_span_lint(\n-                            USAGE_OF_TY_TYKIND,\n-                            path.span,\n-                            fluent::lint_tykind,\n-                            |lint| lint.help(fluent::help)\n-                        )\n-                    }\n-                } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n-                    if path.segments.len() > 1 {\n-                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint_ty_qualified, |lint| {\n-                            lint\n-                                .set_arg(\"ty\", t.clone())\n-                                .span_suggestion(\n-                                    path.span,\n-                                    fluent::suggestion,\n-                                    t,\n-                                    // The import probably needs to be changed\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                        })\n+                        None => cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindDiag),\n                     }\n+                } else if !ty.span.from_expansion() && path.segments.len() > 1 && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n+                    cx.emit_spanned_lint(USAGE_OF_QUALIFIED_TY, path.span, TyQualified {\n+                        ty: t.clone(),\n+                        suggestion: path.span,\n+                    });\n                 }\n             }\n             _ => {}\n@@ -303,12 +272,11 @@ impl EarlyLintPass for LintPassImpl {\n                         && call_site.ctxt().outer_expn_data().kind\n                             != ExpnKind::Macro(MacroKind::Bang, sym::declare_lint_pass)\n                     {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            fluent::lint_lintpass_by_hand,\n-                            |lint| lint.help(fluent::help),\n-                        )\n+                            LintPassByHand,\n+                        );\n                     }\n                 }\n             }\n@@ -338,17 +306,16 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n             if let Some(list) = attr.meta_item_list() {\n                 for nested in list {\n                     if nested.has_name(sym::keyword) {\n-                        let v = nested\n+                        let keyword = nested\n                             .value_str()\n                             .expect(\"#[doc(keyword = \\\"...\\\")] expected a value!\");\n-                        if is_doc_keyword(v) {\n+                        if is_doc_keyword(keyword) {\n                             return;\n                         }\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             EXISTING_DOC_KEYWORD,\n                             attr.span,\n-                            fluent::lint_non_existant_doc_keyword,\n-                            |lint| lint.set_arg(\"keyword\", v).help(fluent::help),\n+                            NonExistantDocKeyword { keyword },\n                         );\n                     }\n                 }\n@@ -407,12 +374,7 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_impl);\n         if !found_parent_with_attr && !found_impl {\n-            cx.struct_span_lint(\n-                DIAGNOSTIC_OUTSIDE_OF_IMPL,\n-                span,\n-                fluent::lint_diag_out_of_impl,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(DIAGNOSTIC_OUTSIDE_OF_IMPL, span, DiagOutOfImpl);\n         }\n \n         let mut found_diagnostic_message = false;\n@@ -428,12 +390,7 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_diagnostic_message);\n         if !found_parent_with_attr && !found_diagnostic_message {\n-            cx.struct_span_lint(\n-                UNTRANSLATABLE_DIAGNOSTIC,\n-                span,\n-                fluent::lint_untranslatable_diag,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(UNTRANSLATABLE_DIAGNOSTIC, span, UntranslatableDiag);\n         }\n     }\n }\n@@ -465,9 +422,9 @@ impl LateLintPass<'_> for BadOptAccess {\n                 let Some(lit) = item.lit()  &&\n                 let ast::LitKind::Str(val, _) = lit.kind\n             {\n-                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, val.as_str(), |lint|\n-                    lint\n-                );\n+                cx.emit_spanned_lint(BAD_OPT_ACCESS, expr.span, BadOptAccessDiag {\n+                    msg: val.as_str(),\n+                });\n             }\n         }\n     }"}, {"sha": "b83a9665fc0c60ef48e3fd1d0639bad6b9f41eaa", "filename": "compiler/rustc_lint/src/let_underscore.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flet_underscore.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,5 +1,8 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{Applicability, DiagnosticBuilder, MultiSpan};\n+use crate::{\n+    lints::{NonBindingLet, NonBindingLetSub},\n+    LateContext, LateLintPass, LintContext,\n+};\n+use rustc_errors::MultiSpan;\n use rustc_hir as hir;\n use rustc_middle::ty;\n use rustc_span::Symbol;\n@@ -119,6 +122,11 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                 _ => false,\n             };\n \n+            let sub = NonBindingLetSub {\n+                suggestion: local.pat.span,\n+                multi_suggestion_start: local.span.until(init.span),\n+                multi_suggestion_end: init.span.shrink_to_hi(),\n+            };\n             if is_sync_lock {\n                 let mut span = MultiSpan::from_spans(vec![local.pat.span, init.span]);\n                 span.push_span_label(\n@@ -129,41 +137,14 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n                     init.span,\n                     \"this binding will immediately drop the value assigned to it\".to_string(),\n                 );\n-                cx.struct_span_lint(\n-                    LET_UNDERSCORE_LOCK,\n-                    span,\n-                    \"non-binding let on a synchronization lock\",\n-                    |lint| build_lint(lint, local, init.span),\n-                )\n+                cx.emit_spanned_lint(LET_UNDERSCORE_LOCK, span, NonBindingLet::SyncLock { sub });\n             } else {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     LET_UNDERSCORE_DROP,\n                     local.span,\n-                    \"non-binding let on a type that implements `Drop`\",\n-                    |lint| build_lint(lint, local, init.span),\n-                )\n+                    NonBindingLet::DropType { sub },\n+                );\n             }\n         }\n     }\n }\n-\n-fn build_lint<'a, 'b>(\n-    lint: &'a mut DiagnosticBuilder<'b, ()>,\n-    local: &hir::Local<'_>,\n-    init_span: rustc_span::Span,\n-) -> &'a mut DiagnosticBuilder<'b, ()> {\n-    lint.span_suggestion_verbose(\n-        local.pat.span,\n-        \"consider binding to an unused variable to avoid immediately dropping the value\",\n-        \"_unused\",\n-        Applicability::MachineApplicable,\n-    )\n-    .multipart_suggestion(\n-        \"consider immediately dropping the value\",\n-        vec![\n-            (local.span.until(init_span), \"drop(\".to_string()),\n-            (init_span.shrink_to_hi(), \")\".to_string()),\n-        ],\n-        Applicability::MachineApplicable,\n-    )\n-}"}, {"sha": "09dfb1022d857205b5699e6f9b46a2843d5efb29", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 69, "deletions": 118, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,9 +1,13 @@\n use crate::context::{CheckLintNameResult, LintStore};\n use crate::late::unerased_lint_store;\n+use crate::lints::{\n+    DeprecatedLintName, IgnoredUnlessCrateSpecified, OverruledAtributeLint, RenamedOrRemovedLint,\n+    RenamedOrRemovedLintSuggestion, UnknownLint, UnknownLintSuggestion,\n+};\n use rustc_ast as ast;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n+use rustc_errors::{fluent, DecorateLint, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirId;\n@@ -15,6 +19,7 @@ use rustc_middle::lint::{\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n+use rustc_session::lint::builtin::{RENAMED_AND_REMOVED_LINTS, UNKNOWN_LINTS, UNUSED_ATTRIBUTES};\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS, SINGLE_USE_LIFETIMES, UNFULFILLED_LINT_EXPECTATIONS},\n     Level, Lint, LintExpectationId, LintId,\n@@ -583,57 +588,32 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     old_src,\n                     id_name\n                 );\n-\n-                let decorate_diag = |diag: &mut Diagnostic| {\n-                    diag.span_label(src.span(), \"overruled by previous forbid\");\n-                    match old_src {\n-                        LintLevelSource::Default => {\n-                            diag.note(&format!(\n-                                \"`forbid` lint level is the default for {}\",\n-                                id.to_string()\n-                            ));\n-                        }\n-                        LintLevelSource::Node { span, reason, .. } => {\n-                            diag.span_label(span, \"`forbid` level set here\");\n-                            if let Some(rationale) = reason {\n-                                diag.note(rationale.as_str());\n-                            }\n-                        }\n-                        LintLevelSource::CommandLine(_, _) => {\n-                            diag.note(\"`forbid` lint level was set on command line\");\n-                        }\n+                let sub = match old_src {\n+                    LintLevelSource::Default => {\n+                        OverruledAttributeSub::DefaultSource { id: id.to_string() }\n                     }\n+                    LintLevelSource::Node { span, reason, .. } => {\n+                        OverruledAttributeSub::NodeSource { span, reason }\n+                    }\n+                    LintLevelSource::CommandLine(_, _) => OverruledAttributeSub::CommandLineSource,\n                 };\n                 if !fcw_warning {\n                     self.sess.emit_err(OverruledAttribute {\n                         span: src.span(),\n                         overruled: src.span(),\n-                        lint_level: level.as_str().to_string(),\n+                        lint_level: level.as_str(),\n                         lint_source: src.name(),\n-                        sub: match old_src {\n-                            LintLevelSource::Default => {\n-                                OverruledAttributeSub::DefaultSource { id: id.to_string() }\n-                            }\n-                            LintLevelSource::Node { span, reason, .. } => {\n-                                OverruledAttributeSub::NodeSource { span, reason }\n-                            }\n-                            LintLevelSource::CommandLine(_, _) => {\n-                                OverruledAttributeSub::CommandLineSource\n-                            }\n-                        },\n+                        sub,\n                     });\n                 } else {\n-                    self.struct_lint(\n+                    self.emit_spanned_lint(\n                         FORBIDDEN_LINT_GROUPS,\n-                        Some(src.span().into()),\n-                        format!(\n-                            \"{}({}) incompatible with previous forbid\",\n-                            level.as_str(),\n-                            src.name(),\n-                        ),\n-                        |lint| {\n-                            decorate_diag(lint);\n-                            lint\n+                        src.span().into(),\n+                        OverruledAtributeLint {\n+                            overruled: src.span(),\n+                            lint_level: level.as_str(),\n+                            lint_source: src.name(),\n+                            sub,\n                         },\n                     );\n                 }\n@@ -858,25 +838,13 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                             }\n                             Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) = self.provider.get_lint_level(lint, &sess);\n-                                struct_lint_level(\n-                                    self.sess,\n+                                self.emit_spanned_lint(\n                                     lint,\n-                                    lvl,\n-                                    src,\n-                                    Some(sp.into()),\n-                                    format!(\n-                                        \"lint name `{}` is deprecated \\\n-                                         and may not have an effect in the future.\",\n-                                        name\n-                                    ),\n-                                    |lint| {\n-                                        lint.span_suggestion(\n-                                            sp,\n-                                            \"change it to\",\n-                                            new_lint_name,\n-                                            Applicability::MachineApplicable,\n-                                        )\n+                                    sp.into(),\n+                                    DeprecatedLintName {\n+                                        name,\n+                                        suggestion: sp,\n+                                        replace: &new_lint_name,\n                                     },\n                                 );\n \n@@ -917,54 +885,29 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     _ if !self.warn_about_weird_lints => {}\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n-                        let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (renamed_lint_level, src) = self.provider.get_lint_level(lint, &sess);\n-                        struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            renamed_lint_level,\n-                            src,\n-                            Some(sp.into()),\n-                            msg,\n-                            |lint| {\n-                                if let Some(new_name) = &renamed {\n-                                    lint.span_suggestion(\n-                                        sp,\n-                                        \"use the new name\",\n-                                        new_name,\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                lint\n-                            },\n+                        let suggestion =\n+                            renamed.as_ref().map(|replace| RenamedOrRemovedLintSuggestion {\n+                                suggestion: sp,\n+                                replace: replace.as_str(),\n+                            });\n+                        self.emit_spanned_lint(\n+                            RENAMED_AND_REMOVED_LINTS,\n+                            sp.into(),\n+                            RenamedOrRemovedLint { msg, suggestion },\n                         );\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n-                        let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) = self.provider.get_lint_level(lint, self.sess);\n                         let name = if let Some(tool_ident) = tool_ident {\n                             format!(\"{}::{}\", tool_ident.name, name)\n                         } else {\n                             name.to_string()\n                         };\n-                        struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(sp.into()),\n-                            format!(\"unknown lint: `{}`\", name),\n-                            |lint| {\n-                                if let Some(suggestion) = suggestion {\n-                                    lint.span_suggestion(\n-                                        sp,\n-                                        \"did you mean\",\n-                                        suggestion,\n-                                        Applicability::MaybeIncorrect,\n-                                    );\n-                                }\n-                                lint\n-                            },\n+                        let suggestion = suggestion\n+                            .map(|replace| UnknownLintSuggestion { suggestion: sp, replace });\n+                        self.emit_spanned_lint(\n+                            UNKNOWN_LINTS,\n+                            sp.into(),\n+                            UnknownLint { name, suggestion },\n                         );\n                     }\n                 }\n@@ -1010,20 +953,10 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     continue\n                 };\n \n-                let lint = builtin::UNUSED_ATTRIBUTES;\n-                let (lint_level, lint_src) = self.provider.get_lint_level(lint, &self.sess);\n-                struct_lint_level(\n-                    self.sess,\n-                    lint,\n-                    lint_level,\n-                    lint_src,\n-                    Some(lint_attr_span.into()),\n-                    format!(\n-                        \"{}({}) is ignored unless specified at crate level\",\n-                        level.as_str(),\n-                        lint_attr_name\n-                    ),\n-                    |lint| lint,\n+                self.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    lint_attr_span.into(),\n+                    IgnoredUnlessCrateSpecified { level: level.as_str(), name: lint_attr_name },\n                 );\n                 // don't set a separate error for every lint in the group\n                 break;\n@@ -1047,11 +980,10 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     level,\n                     src,\n                     Some(span.into()),\n-                    format!(\"unknown lint: `{}`\", lint_id.lint.name_lower()),\n+                    fluent::lint_unknown_gated_lint,\n                     |lint| {\n-                        lint.note(\n-                            &format!(\"the `{}` lint is unstable\", lint_id.lint.name_lower(),),\n-                        );\n+                        lint.set_arg(\"name\", lint_id.lint.name_lower());\n+                        lint.note(fluent::note);\n                         add_feature_diagnostics(lint, &self.sess.parse_sess, feature);\n                         lint\n                     },\n@@ -1086,6 +1018,25 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n         let (level, src) = self.lint_level(lint);\n         struct_lint_level(self.sess, lint, level, src, span, msg, decorate)\n     }\n+\n+    pub fn emit_spanned_lint(\n+        &self,\n+        lint: &'static Lint,\n+        span: MultiSpan,\n+        decorate: impl for<'a> DecorateLint<'a, ()>,\n+    ) {\n+        let (level, src) = self.lint_level(lint);\n+        struct_lint_level(self.sess, lint, level, src, Some(span), decorate.msg(), |lint| {\n+            decorate.decorate_lint(lint)\n+        });\n+    }\n+\n+    pub fn emit_lint(&self, lint: &'static Lint, decorate: impl for<'a> DecorateLint<'a, ()>) {\n+        let (level, src) = self.lint_level(lint);\n+        struct_lint_level(self.sess, lint, level, src, None, decorate.msg(), |lint| {\n+            decorate.decorate_lint(lint)\n+        });\n+    }\n }\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "3d818154cb94ff48c1a7c33fd2a19d473b089588", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -38,6 +38,8 @@\n #![feature(never_type)]\n #![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;\n@@ -60,6 +62,7 @@ mod internal;\n mod late;\n mod let_underscore;\n mod levels;\n+mod lints;\n mod methods;\n mod non_ascii_idents;\n mod non_fmt_panic;"}, {"sha": "c3782a496891db3797bab13879bc32e54f024d02", "filename": "compiler/rustc_lint/src/lints.rs", "status": "added", "additions": 1479, "deletions": 0, "changes": 1479, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -0,0 +1,1479 @@\n+#![allow(rustc::untranslatable_diagnostic)]\n+#![allow(rustc::diagnostic_outside_of_impl)]\n+use std::num::NonZeroU32;\n+\n+use rustc_errors::{\n+    fluent, AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage,\n+    DiagnosticStyledString, SuggestionStyle,\n+};\n+use rustc_hir::def_id::DefId;\n+use rustc_macros::{LintDiagnostic, Subdiagnostic};\n+use rustc_middle::ty::{Predicate, Ty, TyCtxt};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::{edition::Edition, sym, symbol::Ident, Span, Symbol};\n+\n+use crate::{\n+    builtin::InitError, builtin::TypeAliasBounds, errors::OverruledAttributeSub, LateContext,\n+};\n+\n+// array_into_iter.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_array_into_iter)]\n+pub struct ArrayIntoIterDiag<'a> {\n+    pub target: &'a str,\n+    #[suggestion(use_iter_suggestion, code = \"iter\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<ArrayIntoIterDiagSub>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ArrayIntoIterDiagSub {\n+    #[suggestion(remove_into_iter_suggestion, code = \"\", applicability = \"maybe-incorrect\")]\n+    RemoveIntoIter {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[multipart_suggestion(use_explicit_into_iter_suggestion, applicability = \"maybe-incorrect\")]\n+    UseExplicitIntoIter {\n+        #[suggestion_part(code = \"IntoIterator::into_iter(\")]\n+        start_span: Span,\n+        #[suggestion_part(code = \")\")]\n+        end_span: Span,\n+    },\n+}\n+\n+// builtin.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_while_true)]\n+pub struct BuiltinWhileTrue {\n+    #[suggestion(style = \"short\", code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub replace: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_box_pointers)]\n+pub struct BuiltinBoxPointers<'a> {\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_non_shorthand_field_patterns)]\n+pub struct BuiltinNonShorthandFieldPatterns {\n+    pub ident: Ident,\n+    #[suggestion(code = \"{prefix}{ident}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub prefix: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinUnsafe {\n+    #[diag(lint_builtin_allow_internal_unsafe)]\n+    AllowInternalUnsafe,\n+    #[diag(lint_builtin_unsafe_block)]\n+    UnsafeBlock,\n+    #[diag(lint_builtin_unsafe_trait)]\n+    UnsafeTrait,\n+    #[diag(lint_builtin_unsafe_impl)]\n+    UnsafeImpl,\n+    #[diag(lint_builtin_no_mangle_fn)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    NoMangleFn,\n+    #[diag(lint_builtin_export_name_fn)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    ExportNameFn,\n+    #[diag(lint_builtin_link_section_fn)]\n+    #[note(lint_builtin_overridden_symbol_section)]\n+    LinkSectionFn,\n+    #[diag(lint_builtin_no_mangle_static)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    NoMangleStatic,\n+    #[diag(lint_builtin_export_name_static)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    ExportNameStatic,\n+    #[diag(lint_builtin_link_section_static)]\n+    #[note(lint_builtin_overridden_symbol_section)]\n+    LinkSectionStatic,\n+    #[diag(lint_builtin_no_mangle_method)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    NoMangleMethod,\n+    #[diag(lint_builtin_export_name_method)]\n+    #[note(lint_builtin_overridden_symbol_name)]\n+    ExportNameMethod,\n+    #[diag(lint_builtin_decl_unsafe_fn)]\n+    DeclUnsafeFn,\n+    #[diag(lint_builtin_decl_unsafe_method)]\n+    DeclUnsafeMethod,\n+    #[diag(lint_builtin_impl_unsafe_method)]\n+    ImplUnsafeMethod,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_missing_doc)]\n+pub struct BuiltinMissingDoc<'a> {\n+    pub article: &'a str,\n+    pub desc: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_missing_copy_impl)]\n+pub struct BuiltinMissingCopyImpl;\n+\n+pub struct BuiltinMissingDebugImpl<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+// Needed for def_path_str\n+impl<'a> DecorateLint<'a, ()> for BuiltinMissingDebugImpl<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"debug\", self.tcx.def_path_str(self.def_id));\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_builtin_missing_debug_impl\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_anonymous_params)]\n+pub struct BuiltinAnonymousParams<'a> {\n+    #[suggestion(code = \"_: {ty_snip}\")]\n+    pub suggestion: (Span, Applicability),\n+    pub ty_snip: &'a str,\n+}\n+\n+// FIXME(davidtwco) translatable deprecated attr\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deprecated_attr_link)]\n+pub struct BuiltinDeprecatedAttrLink<'a> {\n+    pub name: Symbol,\n+    pub reason: &'a str,\n+    pub link: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinDeprecatedAttrLinkSuggestion<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum BuiltinDeprecatedAttrLinkSuggestion<'a> {\n+    #[suggestion(msg_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    Msg {\n+        #[primary_span]\n+        suggestion: Span,\n+        msg: &'a str,\n+    },\n+    #[suggestion(default_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    Default {\n+        #[primary_span]\n+        suggestion: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deprecated_attr_used)]\n+pub struct BuiltinDeprecatedAttrUsed {\n+    pub name: String,\n+    #[suggestion(\n+        lint_builtin_deprecated_attr_default_suggestion,\n+        style = \"short\",\n+        code = \"\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unused_doc_comment)]\n+pub struct BuiltinUnusedDocComment<'a> {\n+    pub kind: &'a str,\n+    #[label]\n+    pub label: Span,\n+    #[subdiagnostic]\n+    pub sub: BuiltinUnusedDocCommentSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum BuiltinUnusedDocCommentSub {\n+    #[help(plain_help)]\n+    PlainHelp,\n+    #[help(block_help)]\n+    BlockHelp,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_no_mangle_generic)]\n+pub struct BuiltinNoMangleGeneric {\n+    // Use of `#[no_mangle]` suggests FFI intent; correct\n+    // fix may be to monomorphize source by hand\n+    #[suggestion(style = \"short\", code = \"\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_const_no_mangle)]\n+pub struct BuiltinConstNoMangle {\n+    #[suggestion(code = \"pub static\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_mutable_transmutes)]\n+pub struct BuiltinMutablesTransmutes;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unstable_features)]\n+pub struct BuiltinUnstableFeatures;\n+\n+// lint_ungated_async_fn_track_caller\n+pub struct BuiltinUngatedAsyncFnTrackCaller<'a> {\n+    pub label: Span,\n+    pub parse_sess: &'a ParseSess,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinUngatedAsyncFnTrackCaller<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.span_label(self.label, fluent::label);\n+        rustc_session::parse::add_feature_diagnostics(\n+            diag,\n+            &self.parse_sess,\n+            sym::closure_track_caller,\n+        );\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_ungated_async_fn_track_caller\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unreachable_pub)]\n+pub struct BuiltinUnreachablePub<'a> {\n+    pub what: &'a str,\n+    #[suggestion(code = \"pub(crate)\")]\n+    pub suggestion: (Span, Applicability),\n+    #[help]\n+    pub help: Option<()>,\n+}\n+\n+pub struct SuggestChangingAssocTypes<'a, 'b> {\n+    pub ty: &'a rustc_hir::Ty<'b>,\n+}\n+\n+impl AddToDiagnostic for SuggestChangingAssocTypes<'_, '_> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n+        // bound.  Let's see if this type does that.\n+\n+        // We use a HIR visitor to walk the type.\n+        use rustc_hir::intravisit::{self, Visitor};\n+        struct WalkAssocTypes<'a> {\n+            err: &'a mut rustc_errors::Diagnostic,\n+        }\n+        impl Visitor<'_> for WalkAssocTypes<'_> {\n+            fn visit_qpath(\n+                &mut self,\n+                qpath: &rustc_hir::QPath<'_>,\n+                id: rustc_hir::HirId,\n+                span: Span,\n+            ) {\n+                if TypeAliasBounds::is_type_variable_assoc(qpath) {\n+                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n+                }\n+                intravisit::walk_qpath(self, qpath, id)\n+            }\n+        }\n+\n+        // Let's go for a walk!\n+        let mut visitor = WalkAssocTypes { err: diag };\n+        visitor.visit_ty(self.ty);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_type_alias_where_clause)]\n+pub struct BuiltinTypeAliasWhereClause<'a, 'b> {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<SuggestChangingAssocTypes<'a, 'b>>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_type_alias_generic_bounds)]\n+pub struct BuiltinTypeAliasGenericBounds<'a, 'b> {\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinTypeAliasGenericBoundsSuggestion,\n+    #[subdiagnostic]\n+    pub sub: Option<SuggestChangingAssocTypes<'a, 'b>>,\n+}\n+\n+pub struct BuiltinTypeAliasGenericBoundsSuggestion {\n+    pub suggestions: Vec<(Span, String)>,\n+}\n+\n+impl AddToDiagnostic for BuiltinTypeAliasGenericBoundsSuggestion {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.multipart_suggestion(\n+            fluent::suggestion,\n+            self.suggestions,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_trivial_bounds)]\n+pub struct BuiltinTrivialBounds<'a> {\n+    pub predicate_kind_name: &'a str,\n+    pub predicate: Predicate<'a>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinEllipsisInclusiveRangePatternsLint {\n+    #[diag(lint_builtin_ellipsis_inclusive_range_patterns)]\n+    Parenthesise {\n+        #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+        suggestion: Span,\n+        replace: String,\n+    },\n+    #[diag(lint_builtin_ellipsis_inclusive_range_patterns)]\n+    NonParenthesise {\n+        #[suggestion(style = \"short\", code = \"..=\", applicability = \"machine-applicable\")]\n+        suggestion: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unnameable_test_items)]\n+pub struct BuiltinUnnameableTestItems;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_keyword_idents)]\n+pub struct BuiltinKeywordIdents {\n+    pub kw: Ident,\n+    pub next: Edition,\n+    #[suggestion(code = \"r#{kw}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_explicit_outlives)]\n+pub struct BuiltinExplicitOutlives {\n+    pub count: usize,\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinExplicitOutlivesSuggestion,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion)]\n+pub struct BuiltinExplicitOutlivesSuggestion {\n+    #[suggestion_part(code = \"\")]\n+    pub spans: Vec<Span>,\n+    #[applicability]\n+    pub applicability: Applicability,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_incomplete_features)]\n+pub struct BuiltinIncompleteFeatures {\n+    pub name: Symbol,\n+    #[subdiagnostic]\n+    pub note: Option<BuiltinIncompleteFeaturesNote>,\n+    #[subdiagnostic]\n+    pub help: Option<BuiltinIncompleteFeaturesHelp>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(help)]\n+pub struct BuiltinIncompleteFeaturesHelp;\n+\n+#[derive(Subdiagnostic)]\n+#[note(note)]\n+pub struct BuiltinIncompleteFeaturesNote {\n+    pub n: NonZeroU32,\n+}\n+\n+pub struct BuiltinUnpermittedTypeInit<'a> {\n+    pub msg: DiagnosticMessage,\n+    pub ty: Ty<'a>,\n+    pub label: Span,\n+    pub sub: BuiltinUnpermittedTypeInitSub,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinUnpermittedTypeInit<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label);\n+        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label_suggestion);\n+        self.sub.add_to_diagnostic(diag);\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        self.msg.clone()\n+    }\n+}\n+\n+// FIXME(davidtwco): make translatable\n+pub struct BuiltinUnpermittedTypeInitSub {\n+    pub err: InitError,\n+}\n+\n+impl AddToDiagnostic for BuiltinUnpermittedTypeInitSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        let mut err = self.err;\n+        loop {\n+            if let Some(span) = err.span {\n+                diag.span_note(span, err.message);\n+            } else {\n+                diag.note(err.message);\n+            }\n+            if let Some(e) = err.nested {\n+                err = *e;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinClashingExtern<'a> {\n+    #[diag(lint_builtin_clashing_extern_same_name)]\n+    SameName {\n+        this: Symbol,\n+        orig: Symbol,\n+        #[label(previous_decl_label)]\n+        previous_decl_label: Span,\n+        #[label(mismatch_label)]\n+        mismatch_label: Span,\n+        #[subdiagnostic]\n+        sub: BuiltinClashingExternSub<'a>,\n+    },\n+    #[diag(lint_builtin_clashing_extern_diff_name)]\n+    DiffName {\n+        this: Symbol,\n+        orig: Symbol,\n+        #[label(previous_decl_label)]\n+        previous_decl_label: Span,\n+        #[label(mismatch_label)]\n+        mismatch_label: Span,\n+        #[subdiagnostic]\n+        sub: BuiltinClashingExternSub<'a>,\n+    },\n+}\n+\n+// FIXME(davidtwco): translatable expected/found\n+pub struct BuiltinClashingExternSub<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub expected: Ty<'a>,\n+    pub found: Ty<'a>,\n+}\n+\n+impl AddToDiagnostic for BuiltinClashingExternSub<'_> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        let mut expected_str = DiagnosticStyledString::new();\n+        expected_str.push(self.expected.fn_sig(self.tcx).to_string(), false);\n+        let mut found_str = DiagnosticStyledString::new();\n+        found_str.push(self.found.fn_sig(self.tcx).to_string(), true);\n+        diag.note_expected_found(&\"\", expected_str, &\"\", found_str);\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deref_nullptr)]\n+pub struct BuiltinDerefNullptr {\n+    #[label]\n+    pub label: Span,\n+}\n+\n+// FIXME: migrate fluent::lint::builtin_asm_labels\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinSpecialModuleNameUsed {\n+    #[diag(lint_builtin_special_module_name_used_lib)]\n+    #[note]\n+    #[help]\n+    Lib,\n+    #[diag(lint_builtin_special_module_name_used_main)]\n+    #[note]\n+    Main,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unexpected_cli_config_name)]\n+#[help]\n+pub struct BuiltinUnexpectedCliConfigName {\n+    pub name: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_unexpected_cli_config_value)]\n+#[help]\n+pub struct BuiltinUnexpectedCliConfigValue {\n+    pub name: Symbol,\n+    pub value: Symbol,\n+}\n+\n+// deref_into_dyn_supertrait.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_supertrait_as_deref_target)]\n+pub struct SupertraitAsDerefTarget<'a> {\n+    pub t: Ty<'a>,\n+    pub target_principal: String,\n+    // pub target_principal: Binder<'a, ExistentialTraitRef<'b>>,\n+    #[subdiagnostic]\n+    pub label: Option<SupertraitAsDerefTargetLabel>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[label(label)]\n+pub struct SupertraitAsDerefTargetLabel {\n+    #[primary_span]\n+    pub label: Span,\n+}\n+\n+// enum_intrinsics_non_enums.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_enum_intrinsics_mem_discriminant)]\n+pub struct EnumIntrinsicsMemDiscriminate<'a> {\n+    pub ty_param: Ty<'a>,\n+    #[note]\n+    pub note: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_enum_intrinsics_mem_variant)]\n+#[note]\n+pub struct EnumIntrinsicsMemVariant<'a> {\n+    pub ty_param: Ty<'a>,\n+}\n+\n+// expect.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_expectation)]\n+pub struct Expectation {\n+    #[subdiagnostic]\n+    pub rationale: Option<ExpectationNote>,\n+    #[note]\n+    pub note: Option<()>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(rationale)]\n+pub struct ExpectationNote {\n+    pub rationale: Symbol,\n+}\n+\n+// for_loops_over_fallibles.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_for_loops_over_fallibles)]\n+pub struct ForLoopsOverFalliblesDiag<'a> {\n+    pub article: &'static str,\n+    pub ty: &'static str,\n+    #[subdiagnostic]\n+    pub sub: ForLoopsOverFalliblesLoopSub<'a>,\n+    #[subdiagnostic]\n+    pub question_mark: Option<ForLoopsOverFalliblesQuestionMark>,\n+    #[subdiagnostic]\n+    pub suggestion: ForLoopsOverFalliblesSuggestion<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum ForLoopsOverFalliblesLoopSub<'a> {\n+    #[suggestion(remove_next, code = \".by_ref()\", applicability = \"maybe-incorrect\")]\n+    RemoveNext {\n+        #[primary_span]\n+        suggestion: Span,\n+        recv_snip: String,\n+    },\n+    #[multipart_suggestion(use_while_let, applicability = \"maybe-incorrect\")]\n+    UseWhileLet {\n+        #[suggestion_part(code = \"while let {var}(\")]\n+        start_span: Span,\n+        #[suggestion_part(code = \") = \")]\n+        end_span: Span,\n+        var: &'a str,\n+    },\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(use_question_mark, code = \"?\", applicability = \"maybe-incorrect\")]\n+pub struct ForLoopsOverFalliblesQuestionMark {\n+    #[primary_span]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"maybe-incorrect\")]\n+pub struct ForLoopsOverFalliblesSuggestion<'a> {\n+    pub var: &'a str,\n+    #[suggestion_part(code = \"if let {var}(\")]\n+    pub start_span: Span,\n+    #[suggestion_part(code = \") = \")]\n+    pub end_span: Span,\n+}\n+\n+// hidden_unicode_codepoints.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_hidden_unicode_codepoints)]\n+#[note]\n+pub struct HiddenUnicodeCodepointsDiag<'a> {\n+    pub label: &'a str,\n+    pub count: usize,\n+    #[label]\n+    pub span_label: Span,\n+    #[subdiagnostic]\n+    pub labels: Option<HiddenUnicodeCodepointsDiagLabels>,\n+    #[subdiagnostic]\n+    pub sub: HiddenUnicodeCodepointsDiagSub,\n+}\n+\n+pub struct HiddenUnicodeCodepointsDiagLabels {\n+    pub spans: Vec<(char, Span)>,\n+}\n+\n+impl AddToDiagnostic for HiddenUnicodeCodepointsDiagLabels {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        for (c, span) in self.spans {\n+            diag.span_label(span, format!(\"{:?}\", c));\n+        }\n+    }\n+}\n+\n+pub enum HiddenUnicodeCodepointsDiagSub {\n+    Escape { spans: Vec<(char, Span)> },\n+    NoEscape { spans: Vec<(char, Span)> },\n+}\n+\n+// Used because of multiple multipart_suggestion and note\n+impl AddToDiagnostic for HiddenUnicodeCodepointsDiagSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        match self {\n+            HiddenUnicodeCodepointsDiagSub::Escape { spans } => {\n+                diag.multipart_suggestion_with_style(\n+                    fluent::suggestion_remove,\n+                    spans.iter().map(|(_, span)| (*span, \"\".to_string())).collect(),\n+                    Applicability::MachineApplicable,\n+                    SuggestionStyle::HideCodeAlways,\n+                );\n+                diag.multipart_suggestion(\n+                    fluent::suggestion_escape,\n+                    spans\n+                        .into_iter()\n+                        .map(|(c, span)| {\n+                            let c = format!(\"{:?}\", c);\n+                            (span, c[1..c.len() - 1].to_string())\n+                        })\n+                        .collect(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            HiddenUnicodeCodepointsDiagSub::NoEscape { spans } => {\n+                // FIXME: in other suggestions we've reversed the inner spans of doc comments. We\n+                // should do the same here to provide the same good suggestions as we do for\n+                // literals above.\n+                diag.set_arg(\n+                    \"escaped\",\n+                    spans\n+                        .into_iter()\n+                        .map(|(c, _)| format!(\"{:?}\", c))\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                );\n+                diag.note(fluent::suggestion_remove);\n+                diag.note(fluent::no_suggestion_note_escape);\n+            }\n+        }\n+    }\n+}\n+\n+// internal.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_default_hash_types)]\n+#[note]\n+pub struct DefaultHashTypesDiag<'a> {\n+    pub preferred: &'a str,\n+    pub used: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_query_instability)]\n+#[note]\n+pub struct QueryInstability {\n+    pub query: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_tykind_kind)]\n+pub struct TykindKind {\n+    #[suggestion(code = \"ty\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_tykind)]\n+#[help]\n+pub struct TykindDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_ty_qualified)]\n+pub struct TyQualified {\n+    pub ty: String,\n+    #[suggestion(code = \"{ty}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_lintpass_by_hand)]\n+#[help]\n+pub struct LintPassByHand;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_existant_doc_keyword)]\n+#[help]\n+pub struct NonExistantDocKeyword {\n+    pub keyword: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_diag_out_of_impl)]\n+pub struct DiagOutOfImpl;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_untranslatable_diag)]\n+pub struct UntranslatableDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_bad_opt_access)]\n+pub struct BadOptAccessDiag<'a> {\n+    pub msg: &'a str,\n+}\n+\n+// let_underscore.rs\n+#[derive(LintDiagnostic)]\n+pub enum NonBindingLet {\n+    #[diag(lint_non_binding_let_on_sync_lock)]\n+    SyncLock {\n+        #[subdiagnostic]\n+        sub: NonBindingLetSub,\n+    },\n+    #[diag(lint_non_binding_let_on_drop_type)]\n+    DropType {\n+        #[subdiagnostic]\n+        sub: NonBindingLetSub,\n+    },\n+}\n+\n+pub struct NonBindingLetSub {\n+    pub suggestion: Span,\n+    pub multi_suggestion_start: Span,\n+    pub multi_suggestion_end: Span,\n+}\n+\n+impl AddToDiagnostic for NonBindingLetSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.span_suggestion_verbose(\n+            self.suggestion,\n+            fluent::lint_non_binding_let_suggestion,\n+            \"_unused\",\n+            Applicability::MachineApplicable,\n+        );\n+        diag.multipart_suggestion(\n+            fluent::lint_non_binding_let_multi_suggestion,\n+            vec![\n+                (self.multi_suggestion_start, \"drop(\".to_string()),\n+                (self.multi_suggestion_end, \")\".to_string()),\n+            ],\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+// levels.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overruled_attribute)]\n+pub struct OverruledAtributeLint<'a> {\n+    #[label]\n+    pub overruled: Span,\n+    pub lint_level: &'a str,\n+    pub lint_source: Symbol,\n+    #[subdiagnostic]\n+    pub sub: OverruledAttributeSub,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_deprecated_lint_name)]\n+pub struct DeprecatedLintName<'a> {\n+    pub name: String,\n+    #[suggestion(code = \"{replace}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub replace: &'a str,\n+}\n+\n+// FIXME: Non-translatable msg\n+#[derive(LintDiagnostic)]\n+#[diag(lint_renamed_or_removed_lint)]\n+pub struct RenamedOrRemovedLint<'a> {\n+    pub msg: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: Option<RenamedOrRemovedLintSuggestion<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(suggestion, code = \"{replace}\", applicability = \"machine-applicable\")]\n+pub struct RenamedOrRemovedLintSuggestion<'a> {\n+    #[primary_span]\n+    pub suggestion: Span,\n+    pub replace: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unknown_lint)]\n+pub struct UnknownLint {\n+    pub name: String,\n+    #[subdiagnostic]\n+    pub suggestion: Option<UnknownLintSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+pub struct UnknownLintSuggestion {\n+    #[primary_span]\n+    pub suggestion: Span,\n+    pub replace: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_ignored_unless_crate_specified)]\n+pub struct IgnoredUnlessCrateSpecified<'a> {\n+    pub level: &'a str,\n+    pub name: Symbol,\n+}\n+\n+// methods.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_cstring_ptr)]\n+#[note]\n+#[help]\n+pub struct CStringPtr {\n+    #[label(as_ptr_label)]\n+    pub as_ptr: Span,\n+    #[label(unwrap_label)]\n+    pub unwrap: Span,\n+}\n+\n+// non_ascii_idents.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_identifier_non_ascii_char)]\n+pub struct IdentifierNonAsciiChar;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_identifier_uncommon_codepoints)]\n+pub struct IdentifierUncommonCodepoints;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_confusable_identifier_pair)]\n+pub struct ConfusableIdentifierPair {\n+    pub existing_sym: Symbol,\n+    pub sym: Symbol,\n+    #[label]\n+    pub label: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_mixed_script_confusables)]\n+#[note(includes_note)]\n+#[note]\n+pub struct MixedScriptConfusables {\n+    pub set: String,\n+    pub includes: String,\n+}\n+\n+// non_fmt_panic.rs\n+pub struct NonFmtPanicUnused {\n+    pub count: usize,\n+    pub suggestion: Option<Span>,\n+}\n+\n+// Used because of two suggestions based on one Option<Span>\n+impl<'a> DecorateLint<'a, ()> for NonFmtPanicUnused {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"count\", self.count);\n+        diag.note(fluent::note);\n+        if let Some(span) = self.suggestion {\n+            diag.span_suggestion(\n+                span.shrink_to_hi(),\n+                fluent::add_args_suggestion,\n+                \", ...\",\n+                Applicability::HasPlaceholders,\n+            );\n+            diag.span_suggestion(\n+                span.shrink_to_lo(),\n+                fluent::add_fmt_suggestion,\n+                \"\\\"{}\\\", \",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_non_fmt_panic_unused\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_fmt_panic_braces)]\n+#[note]\n+pub struct NonFmtPanicBraces {\n+    pub count: usize,\n+    #[suggestion(code = \"\\\"{{}}\\\", \", applicability = \"machine-applicable\")]\n+    pub suggestion: Option<Span>,\n+}\n+\n+// nonstandard_style.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_camel_case_type)]\n+pub struct NonCamelCaseType<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    #[subdiagnostic]\n+    pub sub: NonCamelCaseTypeSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NonCamelCaseTypeSub {\n+    #[label(label)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        replace: String,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_snake_case)]\n+pub struct NonSnakeCaseDiag<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    pub sc: String,\n+    #[subdiagnostic]\n+    pub sub: NonSnakeCaseDiagSub,\n+}\n+\n+pub enum NonSnakeCaseDiagSub {\n+    Label { span: Span },\n+    Help,\n+    RenameOrConvertSuggestion { span: Span, suggestion: Ident },\n+    ConvertSuggestion { span: Span, suggestion: String },\n+    SuggestionAndNote { span: Span },\n+}\n+\n+impl AddToDiagnostic for NonSnakeCaseDiagSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        match self {\n+            NonSnakeCaseDiagSub::Label { span } => {\n+                diag.span_label(span, fluent::label);\n+            }\n+            NonSnakeCaseDiagSub::Help => {\n+                diag.help(fluent::help);\n+            }\n+            NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion } => {\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::convert_suggestion,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            NonSnakeCaseDiagSub::RenameOrConvertSuggestion { span, suggestion } => {\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::rename_or_convert_suggestion,\n+                    suggestion,\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            NonSnakeCaseDiagSub::SuggestionAndNote { span } => {\n+                diag.note(fluent::cannot_convert_note);\n+                diag.span_suggestion(\n+                    span,\n+                    fluent::rename_suggestion,\n+                    \"\",\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_upper_case_global)]\n+pub struct NonUpperCaseGlobal<'a> {\n+    pub sort: &'a str,\n+    pub name: &'a str,\n+    #[subdiagnostic]\n+    pub sub: NonUpperCaseGlobalSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum NonUpperCaseGlobalSub {\n+    #[label(label)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(suggestion, code = \"{replace}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        replace: String,\n+    },\n+}\n+\n+// noop_method_call.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_noop_method_call)]\n+#[note]\n+pub struct NoopMethodCallDiag<'a> {\n+    pub method: Symbol,\n+    pub receiver_ty: Ty<'a>,\n+    #[label]\n+    pub label: Span,\n+}\n+\n+// pass_by_value.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_pass_by_value)]\n+pub struct PassByValueDiag {\n+    pub ty: String,\n+    #[suggestion(code = \"{ty}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+// redundant_semicolon.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_redundant_semicolons)]\n+pub struct RedundantSemicolonsDiag {\n+    pub multiple: bool,\n+    #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+// traits.rs\n+pub struct DropTraitConstraintsDiag<'a> {\n+    pub predicate: Predicate<'a>,\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+// Needed for def_path_str\n+impl<'a> DecorateLint<'a, ()> for DropTraitConstraintsDiag<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"predicate\", self.predicate);\n+        diag.set_arg(\"needs_drop\", self.tcx.def_path_str(self.def_id))\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_drop_trait_constraints\n+    }\n+}\n+\n+pub struct DropGlue<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub def_id: DefId,\n+}\n+\n+// Needed for def_path_str\n+impl<'a> DecorateLint<'a, ()> for DropGlue<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"needs_drop\", self.tcx.def_path_str(self.def_id))\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_drop_glue\n+    }\n+}\n+\n+// types.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_range_endpoint_out_of_range)]\n+pub struct RangeEndpointOutOfRange<'a> {\n+    pub ty: &'a str,\n+    #[suggestion(code = \"{start}..={literal}{suffix}\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    pub start: String,\n+    pub literal: u128,\n+    pub suffix: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_bin_hex)]\n+pub struct OverflowingBinHex<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub dec: u128,\n+    pub actually: String,\n+    #[subdiagnostic]\n+    pub sign: OverflowingBinHexSign,\n+    #[subdiagnostic]\n+    pub sub: Option<OverflowingBinHexSub<'a>>,\n+}\n+\n+pub enum OverflowingBinHexSign {\n+    Positive,\n+    Negative,\n+}\n+\n+impl AddToDiagnostic for OverflowingBinHexSign {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        match self {\n+            OverflowingBinHexSign::Positive => {\n+                diag.note(fluent::positive_note);\n+            }\n+            OverflowingBinHexSign::Negative => {\n+                diag.note(fluent::negative_note);\n+                diag.note(fluent::negative_becomes_note);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum OverflowingBinHexSub<'a> {\n+    #[suggestion(\n+        suggestion,\n+        code = \"{sans_suffix}{suggestion_ty}\",\n+        applicability = \"machine-applicable\"\n+    )]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        suggestion_ty: &'a str,\n+        sans_suffix: &'a str,\n+    },\n+    #[help(help)]\n+    Help { suggestion_ty: &'a str },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_int)]\n+#[note]\n+pub struct OverflowingInt<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub min: i128,\n+    pub max: u128,\n+    #[subdiagnostic]\n+    pub help: Option<OverflowingIntHelp<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[help(help)]\n+pub struct OverflowingIntHelp<'a> {\n+    pub suggestion_ty: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_only_cast_u8_to_char)]\n+pub struct OnlyCastu8ToChar {\n+    #[suggestion(code = \"'\\\\u{{{literal:X}}}'\", applicability = \"machine-applicable\")]\n+    pub span: Span,\n+    pub literal: u128,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_uint)]\n+#[note]\n+pub struct OverflowingUInt<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+    pub min: u128,\n+    pub max: u128,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_overflowing_literal)]\n+#[note]\n+pub struct OverflowingLiteral<'a> {\n+    pub ty: &'a str,\n+    pub lit: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_comparisons)]\n+pub struct UnusedComparisons;\n+\n+pub struct ImproperCTypes<'a> {\n+    pub ty: Ty<'a>,\n+    pub desc: &'a str,\n+    pub label: Span,\n+    pub help: Option<DiagnosticMessage>,\n+    pub note: DiagnosticMessage,\n+    pub span_note: Option<Span>,\n+}\n+\n+// Used because of the complexity of Option<DiagnosticMessage>, DiagnosticMessage, and Option<Span>\n+impl<'a> DecorateLint<'a, ()> for ImproperCTypes<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.set_arg(\"desc\", self.desc);\n+        diag.span_label(self.label, fluent::label);\n+        if let Some(help) = self.help {\n+            diag.help(help);\n+        }\n+        diag.note(self.note);\n+        if let Some(note) = self.span_note {\n+            diag.span_note(note, fluent::note);\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_improper_ctypes\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_variant_size_differences)]\n+pub struct VariantSizeDifferencesDiag {\n+    pub largest: u64,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_load)]\n+#[help]\n+pub struct AtomicOrderingLoad;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_store)]\n+#[help]\n+pub struct AtomicOrderingStore;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_fence)]\n+#[help]\n+pub struct AtomicOrderingFence;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_atomic_ordering_invalid)]\n+#[help]\n+pub struct InvalidAtomicOrderingDiag {\n+    pub method: Symbol,\n+    #[label]\n+    pub fail_order_arg_span: Span,\n+}\n+\n+// unused.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_op)]\n+pub struct UnusedOp<'a> {\n+    pub op: &'a str,\n+    #[label]\n+    pub label: Span,\n+    #[suggestion(style = \"verbose\", code = \"let _ = \", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_result)]\n+pub struct UnusedResult<'a> {\n+    pub ty: Ty<'a>,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// pre/post strings\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_closure)]\n+#[note]\n+pub struct UnusedClosure<'a> {\n+    pub count: usize,\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the\n+// pre/post strings\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_generator)]\n+#[note]\n+pub struct UnusedGenerator<'a> {\n+    pub count: usize,\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+}\n+\n+// FIXME(davidtwco): this isn't properly translatable becauses of the pre/post\n+// strings\n+pub struct UnusedDef<'a, 'b> {\n+    pub pre: &'a str,\n+    pub post: &'a str,\n+    pub cx: &'a LateContext<'b>,\n+    pub def_id: DefId,\n+    pub note: Option<Symbol>,\n+}\n+\n+// Needed because of def_path_str\n+impl<'a> DecorateLint<'a, ()> for UnusedDef<'_, '_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"pre\", self.pre);\n+        diag.set_arg(\"post\", self.post);\n+        diag.set_arg(\"def\", self.cx.tcx.def_path_str(self.def_id));\n+        // check for #[must_use = \"...\"]\n+        if let Some(note) = self.note {\n+            diag.note(note.as_str());\n+        }\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        fluent::lint_unused_def\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_path_statement_drop)]\n+pub struct PathStatementDrop {\n+    #[subdiagnostic]\n+    pub sub: PathStatementDropSub,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum PathStatementDropSub {\n+    #[suggestion(suggestion, code = \"drop({snippet});\", applicability = \"machine-applicable\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        snippet: String,\n+    },\n+    #[help(help)]\n+    Help {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_path_statement_no_effect)]\n+pub struct PathStatementNoEffect;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_delim)]\n+pub struct UnusedDelim<'a> {\n+    pub delim: &'static str,\n+    pub item: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: Option<UnusedDelimSuggestion>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedDelimSuggestion {\n+    #[suggestion_part(code = \"{start_replace}\")]\n+    pub start_span: Span,\n+    pub start_replace: &'static str,\n+    #[suggestion_part(code = \"{end_replace}\")]\n+    pub end_span: Span,\n+    pub end_replace: &'static str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_import_braces)]\n+pub struct UnusedImportBracesDiag {\n+    pub node: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_allocation)]\n+pub struct UnusedAllocationDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_unused_allocation_mut)]\n+pub struct UnusedAllocationMutDiag;"}, {"sha": "3045fc1a4761e47d2a1f2f339242338f9f5fb707", "filename": "compiler/rustc_lint/src/methods.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,7 @@\n+use crate::lints::CStringPtr;\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n-use rustc_errors::fluent;\n use rustc_hir::{Expr, ExprKind, PathSegment};\n use rustc_middle::ty;\n use rustc_span::{symbol::sym, ExpnKind, Span};\n@@ -90,16 +90,10 @@ fn lint_cstring_as_ptr(\n         if cx.tcx.is_diagnostic_item(sym::Result, def.did()) {\n             if let ty::Adt(adt, _) = substs.type_at(0).kind() {\n                 if cx.tcx.is_diagnostic_item(sym::cstring_type, adt.did()) {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         TEMPORARY_CSTRING_AS_PTR,\n                         as_ptr_span,\n-                        fluent::lint_cstring_ptr,\n-                        |diag| {\n-                            diag.span_label(as_ptr_span, fluent::as_ptr_label)\n-                                .span_label(unwrap.span, fluent::unwrap_label)\n-                                .note(fluent::note)\n-                                .help(fluent::help)\n-                        },\n+                        CStringPtr { as_ptr: as_ptr_span, unwrap: unwrap.span },\n                     );\n                 }\n             }"}, {"sha": "f130a98185d611aeb243c676e8b428d1c1068a01", "filename": "compiler/rustc_lint/src/non_ascii_idents.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_ascii_idents.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,10 @@\n+use crate::lints::{\n+    ConfusableIdentifierPair, IdentifierNonAsciiChar, IdentifierUncommonCodepoints,\n+    MixedScriptConfusables,\n+};\n use crate::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::fluent;\n use rustc_span::symbol::Symbol;\n \n declare_lint! {\n@@ -180,21 +183,11 @@ impl EarlyLintPass for NonAsciiIdents {\n                 continue;\n             }\n             has_non_ascii_idents = true;\n-            cx.struct_span_lint(\n-                NON_ASCII_IDENTS,\n-                sp,\n-                fluent::lint_identifier_non_ascii_char,\n-                |lint| lint,\n-            );\n+            cx.emit_spanned_lint(NON_ASCII_IDENTS, sp, IdentifierNonAsciiChar);\n             if check_uncommon_codepoints\n                 && !symbol_str.chars().all(GeneralSecurityProfile::identifier_allowed)\n             {\n-                cx.struct_span_lint(\n-                    UNCOMMON_CODEPOINTS,\n-                    sp,\n-                    fluent::lint_identifier_uncommon_codepoints,\n-                    |lint| lint,\n-                )\n+                cx.emit_spanned_lint(UNCOMMON_CODEPOINTS, sp, IdentifierUncommonCodepoints);\n             }\n         }\n \n@@ -222,14 +215,13 @@ impl EarlyLintPass for NonAsciiIdents {\n                     .entry(skeleton_sym)\n                     .and_modify(|(existing_symbol, existing_span, existing_is_ascii)| {\n                         if !*existing_is_ascii || !is_ascii {\n-                            cx.struct_span_lint(\n+                            cx.emit_spanned_lint(\n                                 CONFUSABLE_IDENTS,\n                                 sp,\n-                                fluent::lint_confusable_identifier_pair,\n-                                |lint| {\n-                                    lint.set_arg(\"existing_sym\", *existing_symbol)\n-                                        .set_arg(\"sym\", symbol)\n-                                        .span_label(*existing_span, fluent::label)\n+                                ConfusableIdentifierPair {\n+                                    existing_sym: *existing_symbol,\n+                                    sym: symbol,\n+                                    label: *existing_span,\n                                 },\n                             );\n                         }\n@@ -331,24 +323,18 @@ impl EarlyLintPass for NonAsciiIdents {\n                 }\n \n                 for ((sp, ch_list), script_set) in lint_reports {\n-                    cx.struct_span_lint(\n+                    let mut includes = String::new();\n+                    for (idx, ch) in ch_list.into_iter().enumerate() {\n+                        if idx != 0 {\n+                            includes += \", \";\n+                        }\n+                        let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n+                        includes += &char_info;\n+                    }\n+                    cx.emit_spanned_lint(\n                         MIXED_SCRIPT_CONFUSABLES,\n                         sp,\n-                        fluent::lint_mixed_script_confusables,\n-                        |lint| {\n-                            let mut includes = String::new();\n-                            for (idx, ch) in ch_list.into_iter().enumerate() {\n-                                if idx != 0 {\n-                                    includes += \", \";\n-                                }\n-                                let char_info = format!(\"'{}' (U+{:04X})\", ch, ch as u32);\n-                                includes += &char_info;\n-                            }\n-                            lint.set_arg(\"set\", script_set.to_string())\n-                                .set_arg(\"includes\", includes)\n-                                .note(fluent::includes_note)\n-                                .note(fluent::note)\n-                        },\n+                        MixedScriptConfusables { set: script_set.to_string(), includes },\n                     );\n                 }\n             }"}, {"sha": "4a02c6cce47ed92de0385735b7e5e896ebac460a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,3 +1,4 @@\n+use crate::lints::{NonFmtPanicBraces, NonFmtPanicUnused};\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_errors::{fluent, Applicability};\n@@ -118,6 +119,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n         arg_span = expn.call_site;\n     }\n \n+    #[allow(rustc::diagnostic_outside_of_impl)]\n     cx.struct_span_lint(NON_FMT_PANICS, arg_span, fluent::lint_non_fmt_panic, |lint| {\n         lint.set_arg(\"name\", symbol);\n         lint.note(fluent::note);\n@@ -253,25 +255,14 @@ fn check_panic_str<'tcx>(\n                 .map(|span| fmt_span.from_inner(InnerSpan::new(span.start, span.end)))\n                 .collect(),\n         };\n-        cx.struct_span_lint(NON_FMT_PANICS, arg_spans, fluent::lint_non_fmt_panic_unused, |lint| {\n-            lint.set_arg(\"count\", n_arguments);\n-            lint.note(fluent::note);\n-            if is_arg_inside_call(arg.span, span) {\n-                lint.span_suggestion(\n-                    arg.span.shrink_to_hi(),\n-                    fluent::add_args_suggestion,\n-                    \", ...\",\n-                    Applicability::HasPlaceholders,\n-                );\n-                lint.span_suggestion(\n-                    arg.span.shrink_to_lo(),\n-                    fluent::add_fmt_suggestion,\n-                    \"\\\"{}\\\", \",\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-            lint\n-        });\n+        cx.emit_spanned_lint(\n+            NON_FMT_PANICS,\n+            arg_spans,\n+            NonFmtPanicUnused {\n+                count: n_arguments,\n+                suggestion: is_arg_inside_call(arg.span, span).then_some(arg.span),\n+            },\n+        );\n     } else {\n         let brace_spans: Option<Vec<_>> =\n             snippet.filter(|s| s.starts_with('\"') || s.starts_with(\"r#\")).map(|s| {\n@@ -281,22 +272,12 @@ fn check_panic_str<'tcx>(\n                     .collect()\n             });\n         let count = brace_spans.as_ref().map(|v| v.len()).unwrap_or(/* any number >1 */ 2);\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             NON_FMT_PANICS,\n             brace_spans.unwrap_or_else(|| vec![span]),\n-            fluent::lint_non_fmt_panic_braces,\n-            |lint| {\n-                lint.set_arg(\"count\", count);\n-                lint.note(fluent::note);\n-                if is_arg_inside_call(arg.span, span) {\n-                    lint.span_suggestion(\n-                        arg.span.shrink_to_lo(),\n-                        fluent::suggestion,\n-                        \"\\\"{}\\\", \",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                lint\n+            NonFmtPanicBraces {\n+                count,\n+                suggestion: is_arg_inside_call(arg.span, span).then_some(arg.span.shrink_to_lo()),\n             },\n         );\n     }"}, {"sha": "74d234fabea0872467d98c5828b39e472ddc9e0f", "filename": "compiler/rustc_lint/src/nonstandard_style.rs", "status": "modified", "additions": 49, "deletions": 80, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnonstandard_style.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,10 @@\n+use crate::lints::{\n+    NonCamelCaseType, NonCamelCaseTypeSub, NonSnakeCaseDiag, NonSnakeCaseDiagSub,\n+    NonUpperCaseGlobal, NonUpperCaseGlobalSub,\n+};\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::FnKind;\n@@ -136,30 +139,17 @@ impl NonCamelCaseTypes {\n         let name = ident.name.as_str();\n \n         if !is_camel_case(name) {\n-            cx.struct_span_lint(\n+            let cc = to_camel_case(name);\n+            let sub = if *name != cc {\n+                NonCamelCaseTypeSub::Suggestion { span: ident.span, replace: cc }\n+            } else {\n+                NonCamelCaseTypeSub::Label { span: ident.span }\n+            };\n+            cx.emit_spanned_lint(\n                 NON_CAMEL_CASE_TYPES,\n                 ident.span,\n-                fluent::lint_non_camel_case_type,\n-                |lint| {\n-                    let cc = to_camel_case(name);\n-                    // We cannot provide meaningful suggestions\n-                    // if the characters are in the category of \"Lowercase Letter\".\n-                    if *name != cc {\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            fluent::suggestion,\n-                            to_camel_case(name),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        lint.span_label(ident.span, fluent::label);\n-                    }\n-\n-                    lint.set_arg(\"sort\", sort);\n-                    lint.set_arg(\"name\", name);\n-                    lint\n-                },\n-            )\n+                NonCamelCaseType { sort, name, sub },\n+            );\n         }\n     }\n }\n@@ -294,47 +284,37 @@ impl NonSnakeCase {\n         let name = ident.name.as_str();\n \n         if !is_snake_case(name) {\n-            cx.struct_span_lint(NON_SNAKE_CASE, ident.span, fluent::lint_non_snake_case, |lint| {\n-                let sc = NonSnakeCase::to_snake_case(name);\n-                // We cannot provide meaningful suggestions\n-                // if the characters are in the category of \"Uppercase Letter\".\n-                if name != sc {\n-                    // We have a valid span in almost all cases, but we don't have one when linting a crate\n-                    // name provided via the command line.\n-                    if !ident.span.is_dummy() {\n-                        let sc_ident = Ident::from_str_and_span(&sc, ident.span);\n-                        let (message, suggestion) = if sc_ident.is_reserved() {\n-                            // We shouldn't suggest a reserved identifier to fix non-snake-case identifiers.\n-                            // Instead, recommend renaming the identifier entirely or, if permitted,\n-                            // escaping it to create a raw identifier.\n-                            if sc_ident.name.can_be_raw() {\n-                                (fluent::rename_or_convert_suggestion, sc_ident.to_string())\n-                            } else {\n-                                lint.note(fluent::cannot_convert_note);\n-                                (fluent::rename_suggestion, String::new())\n+            let span = ident.span;\n+            let sc = NonSnakeCase::to_snake_case(name);\n+            // We cannot provide meaningful suggestions\n+            // if the characters are in the category of \"Uppercase Letter\".\n+            let sub = if name != sc {\n+                // We have a valid span in almost all cases, but we don't have one when linting a crate\n+                // name provided via the command line.\n+                if !span.is_dummy() {\n+                    let sc_ident = Ident::from_str_and_span(&sc, span);\n+                    if sc_ident.is_reserved() {\n+                        // We shouldn't suggest a reserved identifier to fix non-snake-case identifiers.\n+                        // Instead, recommend renaming the identifier entirely or, if permitted,\n+                        // escaping it to create a raw identifier.\n+                        if sc_ident.name.can_be_raw() {\n+                            NonSnakeCaseDiagSub::RenameOrConvertSuggestion {\n+                                span,\n+                                suggestion: sc_ident,\n                             }\n                         } else {\n-                            (fluent::convert_suggestion, sc.clone())\n-                        };\n-\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            message,\n-                            suggestion,\n-                            Applicability::MaybeIncorrect,\n-                        );\n+                            NonSnakeCaseDiagSub::SuggestionAndNote { span }\n+                        }\n                     } else {\n-                        lint.help(fluent::help);\n+                        NonSnakeCaseDiagSub::ConvertSuggestion { span, suggestion: sc.clone() }\n                     }\n                 } else {\n-                    lint.span_label(ident.span, fluent::label);\n+                    NonSnakeCaseDiagSub::Help\n                 }\n-\n-                lint.set_arg(\"sort\", sort);\n-                lint.set_arg(\"name\", name);\n-                lint.set_arg(\"sc\", sc);\n-                lint\n-            });\n+            } else {\n+                NonSnakeCaseDiagSub::Label { span }\n+            };\n+            cx.emit_spanned_lint(NON_SNAKE_CASE, span, NonSnakeCaseDiag { sort, name, sc, sub });\n         }\n     }\n }\n@@ -490,30 +470,19 @@ impl NonUpperCaseGlobals {\n     fn check_upper_case(cx: &LateContext<'_>, sort: &str, ident: &Ident) {\n         let name = ident.name.as_str();\n         if name.chars().any(|c| c.is_lowercase()) {\n-            cx.struct_span_lint(\n+            let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n+            // We cannot provide meaningful suggestions\n+            // if the characters are in the category of \"Lowercase Letter\".\n+            let sub = if *name != uc {\n+                NonUpperCaseGlobalSub::Suggestion { span: ident.span, replace: uc }\n+            } else {\n+                NonUpperCaseGlobalSub::Label { span: ident.span }\n+            };\n+            cx.emit_spanned_lint(\n                 NON_UPPER_CASE_GLOBALS,\n                 ident.span,\n-                fluent::lint_non_upper_case_global,\n-                |lint| {\n-                    let uc = NonSnakeCase::to_snake_case(&name).to_uppercase();\n-                    // We cannot provide meaningful suggestions\n-                    // if the characters are in the category of \"Lowercase Letter\".\n-                    if *name != uc {\n-                        lint.span_suggestion(\n-                            ident.span,\n-                            fluent::suggestion,\n-                            uc,\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        lint.span_label(ident.span, fluent::label);\n-                    }\n-\n-                    lint.set_arg(\"sort\", sort);\n-                    lint.set_arg(\"name\", name);\n-                    lint\n-                },\n-            )\n+                NonUpperCaseGlobal { sort, name, sub },\n+            );\n         }\n     }\n }"}, {"sha": "d67a00619dd09eb1a5cb7fb0d3d8e0af542fd018", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,7 @@\n use crate::context::LintContext;\n+use crate::lints::NoopMethodCallDiag;\n use crate::LateContext;\n use crate::LateLintPass;\n-use rustc_errors::fluent;\n use rustc_hir::def::DefKind;\n use rustc_hir::{Expr, ExprKind};\n use rustc_middle::ty;\n@@ -85,11 +85,10 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n         }\n         let expr_span = expr.span;\n         let span = expr_span.with_lo(receiver.span.hi());\n-        cx.struct_span_lint(NOOP_METHOD_CALL, span, fluent::lint_noop_method_call, |lint| {\n-            lint.set_arg(\"method\", call.ident.name)\n-                .set_arg(\"receiver_ty\", receiver_ty)\n-                .span_label(span, fluent::label)\n-                .note(fluent::note)\n-        });\n+        cx.emit_spanned_lint(\n+            NOOP_METHOD_CALL,\n+            span,\n+            NoopMethodCallDiag { method: call.ident.name, receiver_ty, label: span },\n+        );\n     }\n }"}, {"sha": "57482a9edba880761fd97b38a0b4dc567aba419d", "filename": "compiler/rustc_lint/src/pass_by_value.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpass_by_value.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,5 +1,5 @@\n+use crate::lints::PassByValueDiag;\n use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::{GenericArg, PathSegment, QPath, TyKind};\n@@ -29,20 +29,11 @@ impl<'tcx> LateLintPass<'tcx> for PassByValue {\n                     }\n                 }\n                 if let Some(t) = path_for_pass_by_value(cx, &inner_ty) {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         PASS_BY_VALUE,\n                         ty.span,\n-                        fluent::lint_pass_by_value,\n-                        |lint| {\n-                            lint.set_arg(\"ty\", t.clone()).span_suggestion(\n-                                ty.span,\n-                                fluent::suggestion,\n-                                t,\n-                                // Changing type of function argument\n-                                Applicability::MaybeIncorrect,\n-                            )\n-                        },\n-                    )\n+                        PassByValueDiag { ty: t.clone(), suggestion: ty.span },\n+                    );\n                 }\n             }\n             _ => {}"}, {"sha": "9a8b14b4907eaeeac69f112a5584b8b5b57d1530", "filename": "compiler/rustc_lint/src/redundant_semicolon.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fredundant_semicolon.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,6 +1,5 @@\n-use crate::{EarlyContext, EarlyLintPass, LintContext};\n+use crate::{lints::RedundantSemicolonsDiag, EarlyContext, EarlyLintPass, LintContext};\n use rustc_ast::{Block, StmtKind};\n-use rustc_errors::{fluent, Applicability};\n use rustc_span::Span;\n \n declare_lint! {\n@@ -48,18 +47,10 @@ fn maybe_lint_redundant_semis(cx: &EarlyContext<'_>, seq: &mut Option<(Span, boo\n             return;\n         }\n \n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             REDUNDANT_SEMICOLONS,\n             span,\n-            fluent::lint_redundant_semicolons,\n-            |lint| {\n-                lint.set_arg(\"multiple\", multiple).span_suggestion(\n-                    span,\n-                    fluent::suggestion,\n-                    \"\",\n-                    Applicability::MaybeIncorrect,\n-                )\n-            },\n+            RedundantSemicolonsDiag { multiple, suggestion: span },\n         );\n     }\n }"}, {"sha": "7ea1a138b7e60252e771b4ddffa896577a0c48b1", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,7 +1,7 @@\n+use crate::lints::{DropGlue, DropTraitConstraintsDiag};\n use crate::LateContext;\n use crate::LateLintPass;\n use crate::LintContext;\n-use rustc_errors::fluent;\n use rustc_hir as hir;\n use rustc_span::symbol::sym;\n \n@@ -101,17 +101,13 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n                 if trait_predicate.trait_ref.self_ty().is_impl_trait() {\n                     continue;\n                 }\n-                let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n-                    continue;\n+                let Some(def_id) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                    return\n                 };\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     DROP_BOUNDS,\n                     span,\n-                    fluent::lint_drop_trait_constraints,\n-                    |lint| {\n-                        lint.set_arg(\"predicate\", predicate)\n-                            .set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n-                    },\n+                    DropTraitConstraintsDiag { predicate, tcx: cx.tcx, def_id },\n                 );\n             }\n         }\n@@ -123,12 +119,11 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n         };\n         for bound in &bounds[..] {\n             let def_id = bound.trait_ref.trait_def_id();\n-            if cx.tcx.lang_items().drop_trait() == def_id\n-                && let Some(needs_drop) = cx.tcx.get_diagnostic_item(sym::needs_drop)\n-            {\n-                cx.struct_span_lint(DYN_DROP, bound.span, fluent::lint_drop_glue, |lint| {\n-                    lint.set_arg(\"needs_drop\", cx.tcx.def_path_str(needs_drop))\n-                });\n+            if cx.tcx.lang_items().drop_trait() == def_id {\n+                let Some(def_id) = cx.tcx.get_diagnostic_item(sym::needs_drop) else {\n+                    return\n+                };\n+                cx.emit_spanned_lint(DYN_DROP, bound.span, DropGlue { tcx: cx.tcx, def_id });\n             }\n         }\n     }"}, {"sha": "f2ab44ac97c838410338ee687e3a434f81c2eb43", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 110, "deletions": 177, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,11 +1,16 @@\n+use crate::lints::{\n+    AtomicOrderingFence, AtomicOrderingLoad, AtomicOrderingStore, ImproperCTypes,\n+    InvalidAtomicOrderingDiag, OnlyCastu8ToChar, OverflowingBinHex, OverflowingBinHexSign,\n+    OverflowingBinHexSub, OverflowingInt, OverflowingIntHelp, OverflowingLiteral, OverflowingUInt,\n+    RangeEndpointOutOfRange, UnusedComparisons, VariantSizeDifferencesDiag,\n+};\n use crate::{LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{fluent, Applicability, DiagnosticMessage};\n+use rustc_errors::{fluent, DiagnosticMessage};\n use rustc_hir as hir;\n use rustc_hir::{is_range_literal, Expr, ExprKind, Node};\n-use rustc_macros::LintDiagnostic;\n use rustc_middle::ty::layout::{IntegerExt, LayoutOf, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n@@ -146,32 +151,22 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     };\n     let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) else { return false };\n \n-    cx.struct_span_lint(\n+    use rustc_ast::{LitIntType, LitKind};\n+    let suffix = match lit.node {\n+        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+        LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+        _ => bug!(),\n+    };\n+    cx.emit_spanned_lint(\n         OVERFLOWING_LITERALS,\n         struct_expr.span,\n-        fluent::lint_range_endpoint_out_of_range,\n-        |lint| {\n-            use ast::{LitIntType, LitKind};\n-\n-            lint.set_arg(\"ty\", ty);\n-\n-            // We need to preserve the literal's suffix,\n-            // as it may determine typing information.\n-            let suffix = match lit.node {\n-                LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                _ => bug!(),\n-            };\n-            let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-            lint.span_suggestion(\n-                struct_expr.span,\n-                fluent::suggestion,\n-                suggestion,\n-                Applicability::MachineApplicable,\n-            );\n-\n-            lint\n+        RangeEndpointOutOfRange {\n+            ty,\n+            suggestion: struct_expr.span,\n+            start,\n+            literal: lit_val - 1,\n+            suffix,\n         },\n     );\n \n@@ -228,58 +223,37 @@ fn report_bin_hex_error(\n     val: u128,\n     negative: bool,\n ) {\n-    cx.struct_span_lint(\n-        OVERFLOWING_LITERALS,\n-        expr.span,\n-        fluent::lint_overflowing_bin_hex,\n-        |lint| {\n-            let (t, actually) = match ty {\n-                attr::IntType::SignedInt(t) => {\n-                    let actually = if negative {\n-                        -(size.sign_extend(val) as i128)\n-                    } else {\n-                        size.sign_extend(val) as i128\n-                    };\n-                    (t.name_str(), actually.to_string())\n-                }\n-                attr::IntType::UnsignedInt(t) => {\n-                    let actually = size.truncate(val);\n-                    (t.name_str(), actually.to_string())\n-                }\n+    let (t, actually) = match ty {\n+        attr::IntType::SignedInt(t) => {\n+            let actually = if negative {\n+                -(size.sign_extend(val) as i128)\n+            } else {\n+                size.sign_extend(val) as i128\n             };\n-\n-            if negative {\n-                // If the value is negative,\n-                // emits a note about the value itself, apart from the literal.\n-                lint.note(fluent::negative_note);\n-                lint.note(fluent::negative_becomes_note);\n+            (t.name_str(), actually.to_string())\n+        }\n+        attr::IntType::UnsignedInt(t) => {\n+            let actually = size.truncate(val);\n+            (t.name_str(), actually.to_string())\n+        }\n+    };\n+    let sign =\n+        if negative { OverflowingBinHexSign::Negative } else { OverflowingBinHexSign::Positive };\n+    let sub = get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative).map(\n+        |suggestion_ty| {\n+            if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                let (sans_suffix, _) = repr_str.split_at(pos);\n+                OverflowingBinHexSub::Suggestion { span: expr.span, suggestion_ty, sans_suffix }\n             } else {\n-                lint.note(fluent::positive_note);\n-            }\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(cx.typeck_results().node_type(expr.hir_id), val, negative)\n-            {\n-                lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    lint.span_suggestion(\n-                        expr.span,\n-                        fluent::suggestion,\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    lint.help(fluent::help);\n-                }\n+                OverflowingBinHexSub::Help { suggestion_ty }\n             }\n-            lint.set_arg(\"ty\", t)\n-                .set_arg(\"lit\", repr_str)\n-                .set_arg(\"dec\", val)\n-                .set_arg(\"actually\", actually);\n-\n-            lint\n         },\n     );\n+    cx.emit_spanned_lint(\n+        OVERFLOWING_LITERALS,\n+        expr.span,\n+        OverflowingBinHex { ty: t, lit: repr_str.clone(), dec: val, actually, sign, sub },\n+    )\n }\n \n // This function finds the next fitting type and generates a suggestion string.\n@@ -363,28 +337,19 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_int, |lint| {\n-            lint.set_arg(\"ty\", t.name_str())\n-                .set_arg(\n-                    \"lit\",\n-                    cx.sess()\n-                        .source_map()\n-                        .span_to_snippet(lit.span)\n-                        .expect(\"must get snippet from literal\"),\n-                )\n-                .set_arg(\"min\", min)\n-                .set_arg(\"max\", max)\n-                .note(fluent::note);\n-\n-            if let Some(sugg_ty) =\n-                get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n-            {\n-                lint.set_arg(\"suggestion_ty\", sugg_ty);\n-                lint.help(fluent::help);\n-            }\n-\n-            lint\n-        });\n+        let lit = cx\n+            .sess()\n+            .source_map()\n+            .span_to_snippet(lit.span)\n+            .expect(\"must get snippet from literal\");\n+        let help = get_type_suggestion(cx.typeck_results().node_type(e.hir_id), v, negative)\n+            .map(|suggestion_ty| OverflowingIntHelp { suggestion_ty });\n+\n+        cx.emit_spanned_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            OverflowingInt { ty: t.name_str(), lit, min, max, help },\n+        );\n     }\n }\n \n@@ -408,18 +373,10 @@ fn lint_uint_literal<'tcx>(\n             match par_e.kind {\n                 hir::ExprKind::Cast(..) => {\n                     if let ty::Char = cx.typeck_results().expr_ty(par_e).kind() {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             OVERFLOWING_LITERALS,\n                             par_e.span,\n-                            fluent::lint_only_cast_u8_to_char,\n-                            |lint| {\n-                                lint.span_suggestion(\n-                                    par_e.span,\n-                                    fluent::suggestion,\n-                                    format!(\"'\\\\u{{{:X}}}'\", lit_val),\n-                                    Applicability::MachineApplicable,\n-                                )\n-                            },\n+                            OnlyCastu8ToChar { span: par_e.span, literal: lit_val },\n                         );\n                         return;\n                     }\n@@ -443,19 +400,20 @@ fn lint_uint_literal<'tcx>(\n             );\n             return;\n         }\n-        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, fluent::lint_overflowing_uint, |lint| {\n-            lint.set_arg(\"ty\", t.name_str())\n-                .set_arg(\n-                    \"lit\",\n-                    cx.sess()\n-                        .source_map()\n-                        .span_to_snippet(lit.span)\n-                        .expect(\"must get snippet from literal\"),\n-                )\n-                .set_arg(\"min\", min)\n-                .set_arg(\"max\", max)\n-                .note(fluent::note)\n-        });\n+        cx.emit_spanned_lint(\n+            OVERFLOWING_LITERALS,\n+            e.span,\n+            OverflowingUInt {\n+                ty: t.name_str(),\n+                lit: cx\n+                    .sess()\n+                    .source_map()\n+                    .span_to_snippet(lit.span)\n+                    .expect(\"must get snippet from literal\"),\n+                min,\n+                max,\n+            },\n+        );\n     }\n }\n \n@@ -484,20 +442,16 @@ fn lint_literal<'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     OVERFLOWING_LITERALS,\n                     e.span,\n-                    fluent::lint_overflowing_literal,\n-                    |lint| {\n-                        lint.set_arg(\"ty\", t.name_str())\n-                            .set_arg(\n-                                \"lit\",\n-                                cx.sess()\n-                                    .source_map()\n-                                    .span_to_snippet(lit.span)\n-                                    .expect(\"must get snippet from literal\"),\n-                            )\n-                            .note(fluent::note)\n+                    OverflowingLiteral {\n+                        ty: t.name_str(),\n+                        lit: cx\n+                            .sess()\n+                            .source_map()\n+                            .span_to_snippet(lit.span)\n+                            .expect(\"must get snippet from literal\"),\n                     },\n                 );\n             }\n@@ -517,12 +471,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.struct_span_lint(\n-                        UNUSED_COMPARISONS,\n-                        e.span,\n-                        fluent::lint_unused_comparisons,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(UNUSED_COMPARISONS, e.span, UnusedComparisons);\n                 }\n             }\n             hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n@@ -1174,26 +1123,21 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             CItemKind::Declaration => IMPROPER_CTYPES,\n             CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n-\n-        self.cx.struct_span_lint(lint, sp, fluent::lint_improper_ctypes, |lint| {\n-            let item_description = match self.mode {\n-                CItemKind::Declaration => \"block\",\n-                CItemKind::Definition => \"fn\",\n+        let desc = match self.mode {\n+            CItemKind::Declaration => \"block\",\n+            CItemKind::Definition => \"fn\",\n+        };\n+        let span_note = if let ty::Adt(def, _) = ty.kind()\n+            && let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n+                Some(sp)\n+            } else {\n+                None\n             };\n-            lint.set_arg(\"ty\", ty);\n-            lint.set_arg(\"desc\", item_description);\n-            lint.span_label(sp, fluent::label);\n-            if let Some(help) = help {\n-                lint.help(help);\n-            }\n-            lint.note(note);\n-            if let ty::Adt(def, _) = ty.kind() {\n-                if let Some(sp) = self.cx.tcx.hir().span_if_local(def.did()) {\n-                    lint.span_note(sp, fluent::note);\n-                }\n-            }\n-            lint\n-        });\n+        self.cx.emit_spanned_lint(\n+            lint,\n+            sp,\n+            ImproperCTypes { ty, desc, label: sp, help, note, span_note },\n+        );\n     }\n \n     fn check_for_opaque_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n@@ -1397,11 +1341,10 @@ impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n             // We only warn if the largest variant is at least thrice as large as\n             // the second-largest.\n             if largest > slargest * 3 && slargest > 0 {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    fluent::lint_variant_size_differences,\n-                    |lint| lint.set_arg(\"largest\", largest),\n+                    VariantSizeDifferencesDiag { largest },\n                 );\n             }\n         }\n@@ -1509,17 +1452,19 @@ impl InvalidAtomicOrdering {\n \n     fn check_atomic_load_store(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if let Some((method, args)) = Self::inherent_atomic_method_call(cx, expr, &[sym::load, sym::store])\n-            && let Some((ordering_arg, invalid_ordering, msg)) = match method {\n-                sym::load => Some((&args[0], sym::Release, fluent::lint_atomic_ordering_load)),\n-                sym::store => Some((&args[1], sym::Acquire, fluent::lint_atomic_ordering_store)),\n+            && let Some((ordering_arg, invalid_ordering)) = match method {\n+                sym::load => Some((&args[0], sym::Release)),\n+                sym::store => Some((&args[1], sym::Acquire)),\n                 _ => None,\n             }\n             && let Some(ordering) = Self::match_ordering(cx, ordering_arg)\n             && (ordering == invalid_ordering || ordering == sym::AcqRel)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, msg, |lint| {\n-                lint.help(fluent::help)\n-            });\n+            if method == sym::load {\n+                cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, AtomicOrderingLoad);\n+            } else {\n+                cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, ordering_arg.span, AtomicOrderingStore);\n+            };\n         }\n     }\n \n@@ -1530,10 +1475,7 @@ impl InvalidAtomicOrdering {\n             && matches!(cx.tcx.get_diagnostic_name(def_id), Some(sym::fence | sym::compiler_fence))\n             && Self::match_ordering(cx, &args[0]) == Some(sym::Relaxed)\n         {\n-            cx.struct_span_lint(INVALID_ATOMIC_ORDERING, args[0].span, fluent::lint_atomic_ordering_fence, |lint| {\n-                lint\n-                    .help(fluent::help)\n-            });\n+            cx.emit_spanned_lint(INVALID_ATOMIC_ORDERING, args[0].span, AtomicOrderingFence);\n         }\n     }\n \n@@ -1550,15 +1492,6 @@ impl InvalidAtomicOrdering {\n         let Some(fail_ordering) = Self::match_ordering(cx, fail_order_arg) else { return };\n \n         if matches!(fail_ordering, sym::Release | sym::AcqRel) {\n-            #[derive(LintDiagnostic)]\n-            #[diag(lint_atomic_ordering_invalid)]\n-            #[help]\n-            struct InvalidAtomicOrderingDiag {\n-                method: Symbol,\n-                #[label]\n-                fail_order_arg_span: Span,\n-            }\n-\n             cx.emit_spanned_lint(\n                 INVALID_ATOMIC_ORDERING,\n                 fail_order_arg.span,"}, {"sha": "ac2b32b44e6a1d42e16ab70e7f41872df229b829", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 67, "deletions": 102, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfffe406fbcabb37b95779f2d252c4a277191e0d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=bfffe406fbcabb37b95779f2d252c4a277191e0d", "patch": "@@ -1,9 +1,14 @@\n+use crate::lints::{\n+    PathStatementDrop, PathStatementDropSub, PathStatementNoEffect, UnusedAllocationDiag,\n+    UnusedAllocationMutDiag, UnusedClosure, UnusedDef, UnusedDelim, UnusedDelimSuggestion,\n+    UnusedGenerator, UnusedImportBracesDiag, UnusedOp, UnusedResult,\n+};\n use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n use rustc_ast::util::{classify, parser};\n use rustc_ast::{ExprKind, StmtKind};\n-use rustc_errors::{fluent, pluralize, Applicability, MultiSpan};\n+use rustc_errors::{pluralize, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n@@ -163,23 +168,20 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n         let mut op_warned = false;\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, fluent::lint_unused_op, |lint| {\n-                lint.set_arg(\"op\", must_use_op)\n-                    .span_label(expr.span, fluent::label)\n-                    .span_suggestion_verbose(\n-                        expr.span.shrink_to_lo(),\n-                        fluent::suggestion,\n-                        \"let _ = \",\n-                        Applicability::MachineApplicable,\n-                    )\n-            });\n+            cx.emit_spanned_lint(\n+                UNUSED_MUST_USE,\n+                expr.span,\n+                UnusedOp {\n+                    op: must_use_op,\n+                    label: expr.span,\n+                    suggestion: expr.span.shrink_to_lo(),\n+                },\n+            );\n             op_warned = true;\n         }\n \n         if !(type_lint_emitted_or_suppressed || fn_warned || op_warned) {\n-            cx.struct_span_lint(UNUSED_RESULTS, s.span, fluent::lint_unused_result, |lint| {\n-                lint.set_arg(\"ty\", ty)\n-            });\n+            cx.emit_spanned_lint(UNUSED_RESULTS, s.span, UnusedResult { ty });\n         }\n \n         fn check_fn_must_use(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> bool {\n@@ -402,47 +404,31 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     );\n                 }\n                 MustUsePath::Closure(span) => {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n-                        fluent::lint_unused_closure,\n-                        |lint| {\n-                            // FIXME(davidtwco): this isn't properly translatable because of the\n-                            // pre/post strings\n-                            lint.set_arg(\"count\", plural_len)\n-                                .set_arg(\"pre\", descr_pre)\n-                                .set_arg(\"post\", descr_post)\n-                                .note(fluent::note)\n-                        },\n+                        UnusedClosure { count: plural_len, pre: descr_pre, post: descr_post },\n                     );\n                 }\n                 MustUsePath::Generator(span) => {\n-                    cx.struct_span_lint(\n+                    cx.emit_spanned_lint(\n                         UNUSED_MUST_USE,\n                         *span,\n-                        fluent::lint_unused_generator,\n-                        |lint| {\n-                            // FIXME(davidtwco): this isn't properly translatable because of the\n-                            // pre/post strings\n-                            lint.set_arg(\"count\", plural_len)\n-                                .set_arg(\"pre\", descr_pre)\n-                                .set_arg(\"post\", descr_post)\n-                                .note(fluent::note)\n-                        },\n+                        UnusedGenerator { count: plural_len, pre: descr_pre, post: descr_post },\n                     );\n                 }\n                 MustUsePath::Def(span, def_id, reason) => {\n-                    cx.struct_span_lint(UNUSED_MUST_USE, *span, fluent::lint_unused_def, |lint| {\n-                        // FIXME(davidtwco): this isn't properly translatable because of the pre/post\n-                        // strings\n-                        lint.set_arg(\"pre\", descr_pre);\n-                        lint.set_arg(\"post\", descr_post);\n-                        lint.set_arg(\"def\", cx.tcx.def_path_str(*def_id));\n-                        if let Some(note) = reason {\n-                            lint.note(note.as_str());\n-                        }\n-                        lint\n-                    });\n+                    cx.emit_spanned_lint(\n+                        UNUSED_MUST_USE,\n+                        *span,\n+                        UnusedDef {\n+                            pre: descr_pre,\n+                            post: descr_post,\n+                            cx,\n+                            def_id: *def_id,\n+                            note: *reason,\n+                        },\n+                    );\n                 }\n             }\n         }\n@@ -478,31 +464,15 @@ impl<'tcx> LateLintPass<'tcx> for PathStatements {\n             if let hir::ExprKind::Path(_) = expr.kind {\n                 let ty = cx.typeck_results().expr_ty(expr);\n                 if ty.needs_drop(cx.tcx, cx.param_env) {\n-                    cx.struct_span_lint(\n-                        PATH_STATEMENTS,\n-                        s.span,\n-                        fluent::lint_path_statement_drop,\n-                        |lint| {\n-                            if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span) {\n-                                lint.span_suggestion(\n-                                    s.span,\n-                                    fluent::suggestion,\n-                                    format!(\"drop({});\", snippet),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            } else {\n-                                lint.span_help(s.span, fluent::suggestion);\n-                            }\n-                            lint\n-                        },\n-                    );\n+                    let sub = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(expr.span)\n+                    {\n+                        PathStatementDropSub::Suggestion { span: s.span, snippet }\n+                    } else {\n+                        PathStatementDropSub::Help { span: s.span }\n+                    };\n+                    cx.emit_spanned_lint(PATH_STATEMENTS, s.span, PathStatementDrop { sub })\n                 } else {\n-                    cx.struct_span_lint(\n-                        PATH_STATEMENTS,\n-                        s.span,\n-                        fluent::lint_path_statement_no_effect,\n-                        |lint| lint,\n-                    );\n+                    cx.emit_spanned_lint(PATH_STATEMENTS, s.span, PathStatementNoEffect);\n                 }\n             }\n         }\n@@ -695,36 +665,35 @@ trait UnusedDelimLint {\n         } else {\n             MultiSpan::from(value_span)\n         };\n-        cx.struct_span_lint(self.lint(), primary_span, fluent::lint_unused_delim, |lint| {\n-            lint.set_arg(\"delim\", Self::DELIM_STR);\n-            lint.set_arg(\"item\", msg);\n-            if let Some((lo, hi)) = spans {\n-                let sm = cx.sess().source_map();\n-                let lo_replace =\n+        let suggestion = spans.map(|(lo, hi)| {\n+            let sm = cx.sess().source_map();\n+            let lo_replace =\n                     if keep_space.0 &&\n                         let Ok(snip) = sm.span_to_prev_source(lo) && !snip.ends_with(' ') {\n-                        \" \".to_string()\n+                        \" \"\n                         } else {\n-                            \"\".to_string()\n+                            \"\"\n                         };\n \n-                let hi_replace =\n+            let hi_replace =\n                     if keep_space.1 &&\n                         let Ok(snip) = sm.span_to_next_source(hi) && !snip.starts_with(' ') {\n-                        \" \".to_string()\n+                        \" \"\n                         } else {\n-                            \"\".to_string()\n+                            \"\"\n                         };\n-\n-                let replacement = vec![(lo, lo_replace), (hi, hi_replace)];\n-                lint.multipart_suggestion(\n-                    fluent::suggestion,\n-                    replacement,\n-                    Applicability::MachineApplicable,\n-                );\n+            UnusedDelimSuggestion {\n+                start_span: lo,\n+                start_replace: lo_replace,\n+                end_span: hi,\n+                end_replace: hi_replace,\n             }\n-            lint\n         });\n+        cx.emit_spanned_lint(\n+            self.lint(),\n+            primary_span,\n+            UnusedDelim { delim: Self::DELIM_STR, item: msg, suggestion },\n+        );\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n@@ -1297,11 +1266,10 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            cx.struct_span_lint(\n+            cx.emit_spanned_lint(\n                 UNUSED_IMPORT_BRACES,\n                 item.span,\n-                fluent::lint_unused_import_braces,\n-                |lint| lint.set_arg(\"node\", node_name),\n+                UnusedImportBracesDiag { node: node_name },\n             );\n         }\n     }\n@@ -1351,17 +1319,14 @@ impl<'tcx> LateLintPass<'tcx> for UnusedAllocation {\n \n         for adj in cx.typeck_results().expr_adjustments(e) {\n             if let adjustment::Adjust::Borrow(adjustment::AutoBorrow::Ref(_, m)) = adj.kind {\n-                cx.struct_span_lint(\n-                    UNUSED_ALLOCATION,\n-                    e.span,\n-                    match m {\n-                        adjustment::AutoBorrowMutability::Not => fluent::lint_unused_allocation,\n-                        adjustment::AutoBorrowMutability::Mut { .. } => {\n-                            fluent::lint_unused_allocation_mut\n-                        }\n-                    },\n-                    |lint| lint,\n-                );\n+                match m {\n+                    adjustment::AutoBorrowMutability::Not => {\n+                        cx.emit_spanned_lint(UNUSED_ALLOCATION, e.span, UnusedAllocationDiag);\n+                    }\n+                    adjustment::AutoBorrowMutability::Mut { .. } => {\n+                        cx.emit_spanned_lint(UNUSED_ALLOCATION, e.span, UnusedAllocationMutDiag);\n+                    }\n+                };\n             }\n         }\n     }"}]}