{"sha": "f4c093c4af22358c85a3f1b72a878714f8ca588c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0YzA5M2M0YWYyMjM1OGM4NWEzZjFiNzJhODc4NzE0ZjhjYTU4OGM=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-26T17:14:01Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2012-07-26T17:14:01Z"}, "message": "Change `#macro` to `macro_rules!` in some cases.", "tree": {"sha": "2642ae6af12864f1903f176227c677f6462af2b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2642ae6af12864f1903f176227c677f6462af2b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4c093c4af22358c85a3f1b72a878714f8ca588c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4c093c4af22358c85a3f1b72a878714f8ca588c", "html_url": "https://github.com/rust-lang/rust/commit/f4c093c4af22358c85a3f1b72a878714f8ca588c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4c093c4af22358c85a3f1b72a878714f8ca588c/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5fbd4f9d2f9f60240d80a103d00595328042cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5fbd4f9d2f9f60240d80a103d00595328042cd", "html_url": "https://github.com/rust-lang/rust/commit/7f5fbd4f9d2f9f60240d80a103d00595328042cd"}], "stats": {"total": 79, "additions": 34, "deletions": 45}, "files": [{"sha": "86837285c2b753b6980165dd720abfcb7136c394", "filename": "src/libcore/future.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4c093c4af22358c85a3f1b72a878714f8ca588c/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c093c4af22358c85a3f1b72a878714f8ca588c/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=f4c093c4af22358c85a3f1b72a878714f8ca588c", "patch": "@@ -60,11 +60,8 @@ fn from_value<A>(+val: A) -> future<A> {\n     })\n }\n \n-fn macros() {\n-    #macro[\n-        [#move[x],\n-         unsafe { let y <- *ptr::addr_of(x); y }]\n-    ];\n+macro_rules! move{\n+    {$x:expr} => { unsafe { let y <- *ptr::addr_of($x); y } }\n }\n \n fn from_port<A:send>(-port: future_pipe::client::waiting<A>) -> future<A> {\n@@ -81,7 +78,7 @@ fn from_port<A:send>(-port: future_pipe::client::waiting<A>) -> future<A> {\n         port_ <-> *port;\n         let port = option::unwrap(port_);\n         alt recv(port) {\n-          future_pipe::completed(data) { #move(data) }\n+          future_pipe::completed(data) { move!{data} }\n         }\n     }\n }"}, {"sha": "d14905e1290c49cd8f6ac1946ce7fad143b72358", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/f4c093c4af22358c85a3f1b72a878714f8ca588c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c093c4af22358c85a3f1b72a878714f8ca588c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f4c093c4af22358c85a3f1b72a878714f8ca588c", "patch": "@@ -101,52 +101,43 @@ enum class_contents { ctor_decl(fn_decl, ~[attribute], blk, codemap::span),\n type arg_or_capture_item = either<arg, capture_item>;\n type item_info = (ident, item_, option<~[attribute]>);\n \n-fn dummy() {\n \n+/* The expr situation is not as complex as I thought it would be.\n+The important thing is to make sure that lookahead doesn't balk\n+at ACTUALLY tokens */\n+macro_rules! maybe_whole_expr{\n+    {$p:expr} => { alt copy $p.token {\n+      ACTUALLY(token::w_expr(e)) {\n+        $p.bump();\n+        ret pexpr(e);\n+      }\n+      ACTUALLY(token::w_path(pt)) {\n+        $p.bump();\n+        ret $p.mk_pexpr($p.span.lo, $p.span.lo,\n+                       expr_path(pt));\n+      }\n+      _ {}\n+    }}\n+}\n \n+macro_rules! maybe_whole {\n+    {$p:expr, $constructor:path} => { alt copy $p.token {\n+      ACTUALLY($constructor(x)) { $p.bump(); ret x; }\n+      _ {}\n+    }}\n+}\n \n-    #macro[[#maybe_whole_item[p],\n-            alt copy p.token {\n-                ACTUALLY(token::w_item(i)) { p.bump(); ret i; }\n-                _ {} }]];\n-    #macro[[#maybe_whole_block[p],\n-            alt copy p.token {\n-                ACTUALLY(token::w_block(b)) { p.bump(); ret b; }\n-                _ {} }]];\n-    #macro[[#maybe_whole_stmt[p],\n-            alt copy p.token {\n-                ACTUALLY(token::w_stmt(s)) { p.bump(); ret s; }\n-                _ {} }]];\n-    #macro[[#maybe_whole_pat[p],\n-            alt copy p.token {\n-                ACTUALLY(token::w_pat(pt)) { p.bump(); ret pt; }\n-                _ {} }]];\n-    /* The expr situation is not as complex as I thought it would be.\n-    The important thing is to make sure that lookahead doesn't balk\n-    at ACTUALLY tokens */\n-    #macro[[#maybe_whole_expr_pexpr[p], /* ack! */\n-            alt copy p.token {\n-                ACTUALLY(token::w_expr(e)) {\n-                    p.bump();\n-                    ret pexpr(e);\n-                }\n-                ACTUALLY(token::w_path(pt)) {\n-                    p.bump();\n-                    ret p.mk_pexpr(p.span.lo, p.span.lo,\n-                                   expr_path(pt));\n-                }\n-                _ {} }]];\n-    #macro[[#maybe_whole_ty[p],\n-            alt copy p.token {\n-                ACTUALLY(token::w_ty(t)) { p.bump(); ret t; }\n-                _ {} }]];\n-    /* ident is handled by common.rs */\n+/* ident is handled by common.rs */\n+\n+fn dummy() {\n+    /* we will need this to bootstrap maybe_whole! */\n     #macro[[#maybe_whole_path[p],\n             alt p.token {\n                 ACTUALLY(token::w_path(pt)) { p.bump(); ret pt; }\n                 _ {} }]];\n }\n \n+\n class parser {\n     let sess: parse_sess;\n     let cfg: crate_cfg;\n@@ -734,7 +725,7 @@ class parser {\n     }\n \n     fn parse_bottom_expr() -> pexpr {\n-        #maybe_whole_expr_pexpr[self];\n+        maybe_whole_expr!{self};\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n "}, {"sha": "568739b0663def3603c2e38a8ae3d086055f85ad", "filename": "src/test/run-pass/macro-by-example-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4c093c4af22358c85a3f1b72a878714f8ca588c/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4c093c4af22358c85a3f1b72a878714f8ca588c/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs?ref=f4c093c4af22358c85a3f1b72a878714f8ca588c", "patch": "@@ -9,6 +9,7 @@ fn main() {\n \n     fn add(a: int, b: int) -> int { ret a + b; }\n \n-    assert (#apply[add, [1, 15]] == 16);\n+    assert(#apply[add, [1, 15]] == 16);\n+    assert(apply!{add, [1, 15]} == 16);\n     assert(apply_tt!{add, (1, 15)} == 16);\n }"}]}