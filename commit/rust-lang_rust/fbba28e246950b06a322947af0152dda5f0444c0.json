{"sha": "fbba28e246950b06a322947af0152dda5f0444c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYmEyOGUyNDY5NTBiMDZhMzIyOTQ3YWYwMTUyZGRhNWYwNDQ0YzA=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-01T23:12:58Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-04-05T16:52:58Z"}, "message": "Added smoke tests for new methods.\nFixed bug in existing StrSearcher impl", "tree": {"sha": "531e5147966dd6065e176dc68e9bae8872c9394c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/531e5147966dd6065e176dc68e9bae8872c9394c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbba28e246950b06a322947af0152dda5f0444c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbba28e246950b06a322947af0152dda5f0444c0", "html_url": "https://github.com/rust-lang/rust/commit/fbba28e246950b06a322947af0152dda5f0444c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbba28e246950b06a322947af0152dda5f0444c0/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c29559d28acb34884769c884703c2c5de3397d2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c29559d28acb34884769c884703c2c5de3397d2b", "html_url": "https://github.com/rust-lang/rust/commit/c29559d28acb34884769c884703c2c5de3397d2b"}], "stats": {"total": 182, "additions": 160, "deletions": 22}, "files": [{"sha": "bc07c9b65a5886f49ef714432ebfa9770981f80d", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 137, "deletions": 12, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/fbba28e246950b06a322947af0152dda5f0444c0/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbba28e246950b06a322947af0152dda5f0444c0/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=fbba28e246950b06a322947af0152dda5f0444c0", "patch": "@@ -1720,6 +1720,31 @@ mod pattern {\n         if rev {\n             v.reverse();\n         }\n+\n+        let mut first_index = 0;\n+        let mut err = None;\n+\n+        for (i, e) in right.iter().enumerate() {\n+            match *e {\n+                Match(a, b) | Reject(a, b)\n+                if a <= b && a == first_index => {\n+                    first_index = b;\n+                }\n+                _ => {\n+                    err = Some(i);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if let Some(err) = err {\n+            panic!(\"Input skipped range at {}\", err);\n+        }\n+\n+        if first_index != haystack.len() {\n+            panic!(\"Did not cover whole input\");\n+        }\n+\n         assert_eq!(v, right);\n     }\n \n@@ -1731,25 +1756,35 @@ mod pattern {\n         Reject(6, 7),\n     ]);\n     make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n-        Match(0, 0),\n-        Match(1, 1),\n-        Match(2, 2),\n-        Match(3, 3),\n-        Match(4, 4),\n-        Match(5, 5),\n-        Match(6, 6),\n-        Match(7, 7),\n+        Match (0, 0),\n+        Reject(0, 1),\n+        Match (1, 1),\n+        Reject(1, 2),\n+        Match (2, 2),\n+        Reject(2, 3),\n+        Match (3, 3),\n+        Reject(3, 4),\n+        Match (4, 4),\n+        Reject(4, 5),\n+        Match (5, 5),\n+        Reject(5, 6),\n+        Match (6, 6),\n+        Reject(6, 7),\n+        Match (7, 7),\n     ]);\n     make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n         Reject(0, 3),\n         Reject(3, 6),\n         Reject(6, 9),\n     ]);\n     make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n-        Match(0, 0),\n-        Match(3, 3),\n-        Match(6, 6),\n-        Match(9, 9),\n+        Match (0, 0),\n+        Reject(0, 3),\n+        Match (3, 3),\n+        Reject(3, 6),\n+        Match (6, 6),\n+        Reject(6, 9),\n+        Match (9, 9),\n     ]);\n     make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n         Match(0, 0),\n@@ -1778,6 +1813,96 @@ mod pattern {\n \n }\n \n+macro_rules! generate_iterator_test {\n+    {\n+        $name:ident {\n+            $(\n+                ($($arg:expr),*) -> [$($t:tt)*];\n+            )*\n+        }\n+        with $fwd:expr, $bwd:expr;\n+    } => {\n+        #[test]\n+        fn $name() {\n+            $(\n+                {\n+                    let res = vec![$($t)*];\n+\n+                    let fwd_vec: Vec<_> = ($fwd)($($arg),*).collect();\n+                    assert_eq!(fwd_vec, res);\n+\n+                    let mut bwd_vec: Vec<_> = ($bwd)($($arg),*).collect();\n+                    bwd_vec.reverse();\n+                    assert_eq!(bwd_vec, res);\n+                }\n+            )*\n+        }\n+    };\n+    {\n+        $name:ident {\n+            $(\n+                ($($arg:expr),*) -> [$($t:tt)*];\n+            )*\n+        }\n+        with $fwd:expr;\n+    } => {\n+        #[test]\n+        fn $name() {\n+            $(\n+                {\n+                    let res = vec![$($t)*];\n+\n+                    let fwd_vec: Vec<_> = ($fwd)($($arg),*).collect();\n+                    assert_eq!(fwd_vec, res);\n+                }\n+            )*\n+        }\n+    }\n+}\n+\n+generate_iterator_test! {\n+    double_ended_split {\n+        (\"foo.bar.baz\", '.') -> [\"foo\", \"bar\", \"baz\"];\n+        (\"foo::bar::baz\", \"::\") -> [\"foo\", \"bar\", \"baz\"];\n+    }\n+    with str::split, str::rsplit;\n+}\n+\n+generate_iterator_test! {\n+    double_ended_split_terminator {\n+        (\"foo;bar;baz;\", ';') -> [\"foo\", \"bar\", \"baz\"];\n+    }\n+    with str::split_terminator, str::rsplit_terminator;\n+}\n+\n+generate_iterator_test! {\n+    double_ended_matches {\n+        (\"a1b2c3\", char::is_numeric) -> [\"1\", \"2\", \"3\"];\n+    }\n+    with str::matches, str::rmatches;\n+}\n+\n+generate_iterator_test! {\n+    double_ended_match_indices {\n+        (\"a1b2c3\", char::is_numeric) -> [(1, 2), (3, 4), (5, 6)];\n+    }\n+    with str::match_indices, str::rmatch_indices;\n+}\n+\n+generate_iterator_test! {\n+    not_double_ended_splitn {\n+        (\"foo::bar::baz\", 2, \"::\") -> [\"foo\", \"bar::baz\"];\n+    }\n+    with str::splitn;\n+}\n+\n+generate_iterator_test! {\n+    not_double_ended_rsplitn {\n+        (\"foo::bar::baz\", 2, \"::\") -> [\"baz\", \"foo::bar\"];\n+    }\n+    with str::rsplitn;\n+}\n+\n mod bench {\n     use test::{Bencher, black_box};\n "}, {"sha": "9f701e1b031816692c216397f2afd8d54743548e", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fbba28e246950b06a322947af0152dda5f0444c0/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbba28e246950b06a322947af0152dda5f0444c0/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=fbba28e246950b06a322947af0152dda5f0444c0", "patch": "@@ -351,7 +351,14 @@ pub struct StrSearcher<'a, 'b> {\n     needle: &'b str,\n     start: usize,\n     end: usize,\n-    done: bool,\n+    state: State,\n+}\n+\n+#[derive(Clone, PartialEq)]\n+enum State { Done, NotDone, Reject(usize, usize) }\n+impl State {\n+    #[inline] fn done(&self) -> bool { *self == State::Done }\n+    #[inline] fn take(&mut self) -> State { ::mem::replace(self, State::NotDone) }\n }\n \n /// Non-allocating substring search.\n@@ -368,7 +375,7 @@ impl<'a, 'b> Pattern<'a> for &'b str {\n             needle: self,\n             start: 0,\n             end: haystack.len(),\n-            done: false,\n+            state: State::NotDone,\n         }\n     }\n }\n@@ -385,8 +392,9 @@ unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n         |m: &mut StrSearcher| {\n             // Forward step for empty needle\n             let current_start = m.start;\n-            if !m.done {\n+            if !m.state.done() {\n                 m.start = m.haystack.char_range_at(current_start).next;\n+                m.state = State::Reject(current_start, m.start);\n             }\n             SearchStep::Match(current_start, current_start)\n         },\n@@ -415,8 +423,9 @@ unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n         |m: &mut StrSearcher| {\n             // Backward step for empty needle\n             let current_end = m.end;\n-            if !m.done {\n+            if !m.state.done() {\n                 m.end = m.haystack.char_range_at_reverse(current_end).next;\n+                m.state = State::Reject(m.end, current_end);\n             }\n             SearchStep::Match(current_end, current_end)\n         },\n@@ -446,23 +455,27 @@ fn str_search_step<F, G>(mut m: &mut StrSearcher,\n     where F: FnOnce(&mut StrSearcher) -> SearchStep,\n           G: FnOnce(&mut StrSearcher) -> SearchStep\n {\n-    if m.done {\n+    if m.state.done() {\n         SearchStep::Done\n     } else if m.needle.len() == 0 && m.start <= m.end {\n         // Case for needle == \"\"\n-        if m.start == m.end {\n-            m.done = true;\n+        if let State::Reject(a, b) = m.state.take() {\n+            SearchStep::Reject(a, b)\n+        } else {\n+            if m.start == m.end {\n+                m.state = State::Done;\n+            }\n+            empty_needle_step(&mut m)\n         }\n-        empty_needle_step(&mut m)\n     } else if m.start + m.needle.len() <= m.end {\n         // Case for needle != \"\"\n         nonempty_needle_step(&mut m)\n     } else if m.start < m.end {\n         // Remaining slice shorter than needle, reject it\n-        m.done = true;\n+        m.state = State::Done;\n         SearchStep::Reject(m.start, m.end)\n     } else {\n-        m.done = true;\n+        m.state = State::Done;\n         SearchStep::Done\n     }\n }"}]}