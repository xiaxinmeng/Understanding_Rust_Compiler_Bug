{"sha": "92294e7aedf26c1b276b4a721e18b7a43217848d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMjk0ZTdhZWRmMjZjMWIyNzZiNGE3MjFlMThiN2E0MzIxNzg0OGQ=", "commit": {"author": {"name": "Ches Martin", "email": "ches@whiskeyandgrits.net", "date": "2015-03-02T04:54:37Z"}, "committer": {"name": "Ches Martin", "email": "ches@whiskeyandgrits.net", "date": "2015-03-20T22:32:26Z"}, "message": "guide: Improvements to language covering enums", "tree": {"sha": "42fdf59c17d038ba77dd31bb1b4fa0eafe938d80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42fdf59c17d038ba77dd31bb1b4fa0eafe938d80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92294e7aedf26c1b276b4a721e18b7a43217848d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92294e7aedf26c1b276b4a721e18b7a43217848d", "html_url": "https://github.com/rust-lang/rust/commit/92294e7aedf26c1b276b4a721e18b7a43217848d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92294e7aedf26c1b276b4a721e18b7a43217848d/comments", "author": {"login": "ches", "id": 13277, "node_id": "MDQ6VXNlcjEzMjc3", "avatar_url": "https://avatars.githubusercontent.com/u/13277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ches", "html_url": "https://github.com/ches", "followers_url": "https://api.github.com/users/ches/followers", "following_url": "https://api.github.com/users/ches/following{/other_user}", "gists_url": "https://api.github.com/users/ches/gists{/gist_id}", "starred_url": "https://api.github.com/users/ches/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ches/subscriptions", "organizations_url": "https://api.github.com/users/ches/orgs", "repos_url": "https://api.github.com/users/ches/repos", "events_url": "https://api.github.com/users/ches/events{/privacy}", "received_events_url": "https://api.github.com/users/ches/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ches", "id": 13277, "node_id": "MDQ6VXNlcjEzMjc3", "avatar_url": "https://avatars.githubusercontent.com/u/13277?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ches", "html_url": "https://github.com/ches", "followers_url": "https://api.github.com/users/ches/followers", "following_url": "https://api.github.com/users/ches/following{/other_user}", "gists_url": "https://api.github.com/users/ches/gists{/gist_id}", "starred_url": "https://api.github.com/users/ches/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ches/subscriptions", "organizations_url": "https://api.github.com/users/ches/orgs", "repos_url": "https://api.github.com/users/ches/repos", "events_url": "https://api.github.com/users/ches/events{/privacy}", "received_events_url": "https://api.github.com/users/ches/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c040b07f00f8cb1e59c4811c59e2adf81e6e167", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c040b07f00f8cb1e59c4811c59e2adf81e6e167", "html_url": "https://github.com/rust-lang/rust/commit/0c040b07f00f8cb1e59c4811c59e2adf81e6e167"}], "stats": {"total": 68, "additions": 35, "deletions": 33}, "files": [{"sha": "d531a22d0e0dd55d2b2a0d5d913b88f9d3912c73", "filename": "src/doc/trpl/compound-data-types.md", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/92294e7aedf26c1b276b4a721e18b7a43217848d/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/92294e7aedf26c1b276b4a721e18b7a43217848d/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcompound-data-types.md?ref=92294e7aedf26c1b276b4a721e18b7a43217848d", "patch": "@@ -196,8 +196,9 @@ Now, we have actual names, rather than positions. Good names are important,\n and with a struct, we have actual names.\n \n There _is_ one case when a tuple struct is very useful, though, and that's a\n-tuple struct with only one element. We call this a *newtype*, because it lets\n-you create a new type that's similar to another one:\n+tuple struct with only one element. We call this the *newtype* pattern, because\n+it allows you to create a new type, distinct from that of its contained value\n+and expressing its own semantic meaning:\n \n ```{rust}\n struct Inches(i32);\n@@ -216,7 +217,7 @@ destructuring `let`, as we discussed previously in 'tuples.' In this case, the\n \n Finally, Rust has a \"sum type\", an *enum*. Enums are an incredibly useful\n feature of Rust, and are used throughout the standard library. An `enum` is\n-a type which ties a set of alternates to a specific name. For example, below\n+a type which relates a set of alternates to a specific name. For example, below\n we define `Character` to be either a `Digit` or something else. These\n can be used via their fully scoped names: `Character::Other` (more about `::`\n below).\n@@ -228,8 +229,8 @@ enum Character {\n }\n ```\n \n-An `enum` variant can be defined as most normal types. Below are some example\n-types which also would be allowed in an `enum`.\n+Most normal types are allowed as the variant components of an `enum`. Here are\n+some examples:\n \n ```rust\n struct Empty;\n@@ -239,15 +240,15 @@ struct Status { Health: i32, Mana: i32, Attack: i32, Defense: i32 }\n struct HeightDatabase(Vec<i32>);\n ```\n \n-So you see that depending on the sub-datastructure, the `enum` variant, same as\n-a struct, may or may not hold data. That is, in `Character`, `Digit` is a name\n-tied to an `i32` where `Other` is just a name. However, the fact that they are\n-distinct makes this very useful.\n+You see that, depending on its type, an `enum` variant may or may not hold data.\n+In `Character`, for instance, `Digit` gives a meaningful name for an `i32`\n+value, where `Other` is only a name. However, the fact that they represent\n+distinct categories of `Character` is a very useful property.\n \n-As with structures, enums don't by default have access to operators such as\n-compare ( `==` and `!=`), binary operations (`*` and `+`), and order\n-(`<` and `>=`). As such, using the previous `Character` type, the\n-following code is invalid:\n+As with structures, the variants of an enum by default are not comparable with\n+equality operators (`==`, `!=`), have no ordering (`<`, `>=`, etc.), and do not\n+support other binary operations such as `*` and `+`. As such, the following code\n+is invalid for the example `Character` type:\n \n ```{rust,ignore}\n // These assignments both succeed\n@@ -265,9 +266,10 @@ let four_equals_ten = four == ten;\n ```\n \n This may seem rather limiting, but it's a limitation which we can overcome.\n-There are two ways: by implementing equality ourselves, or by using the\n-[`match`][match] keyword. We don't know enough about Rust to implement equality\n-yet, but we can use the `Ordering` enum from the standard library, which does:\n+There are two ways: by implementing equality ourselves, or by pattern matching\n+variants with [`match`][match] expressions, which you'll learn in the next\n+chapter. We don't know enough about Rust to implement equality yet, but we can\n+use the `Ordering` enum from the standard library, which does:\n \n ```\n enum Ordering {\n@@ -277,9 +279,8 @@ enum Ordering {\n }\n ```\n \n-Because we did not define `Ordering`, we must import it (from the std\n-library) with the `use` keyword. Here's an example of how `Ordering` is\n-used:\n+Because `Ordering` has already been defined for us, we will import it with the\n+`use` keyword. Here's an example of how it is used:\n \n ```{rust}\n use std::cmp::Ordering;\n@@ -313,17 +314,17 @@ the standard library if you need them.\n \n Okay, let's talk about the actual code in the example. `cmp` is a function that\n compares two things, and returns an `Ordering`. We return either\n-`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on if\n-the two values are less, greater, or equal. Note that each variant of the\n-`enum` is namespaced under the `enum` itself: it's `Ordering::Greater` not\n-`Greater`.\n+`Ordering::Less`, `Ordering::Greater`, or `Ordering::Equal`, depending on\n+whether the first value is less than, greater than, or equal to the second. Note\n+that each variant of the `enum` is namespaced under the `enum` itself: it's\n+`Ordering::Greater`, not `Greater`.\n \n The `ordering` variable has the type `Ordering`, and so contains one of the\n three values. We then do a bunch of `if`/`else` comparisons to check which\n one it is.\n \n-This `Ordering::Greater` notation is too long. Let's use `use` to import the\n-`enum` variants instead. This will avoid full scoping:\n+This `Ordering::Greater` notation is too long. Let's use another form of `use`\n+to import the `enum` variants instead. This will avoid full scoping:\n \n ```{rust}\n use std::cmp::Ordering::{self, Equal, Less, Greater};\n@@ -347,14 +348,15 @@ fn main() {\n ```\n \n Importing variants is convenient and compact, but can also cause name conflicts,\n-so do this with caution. It's considered good style to rarely import variants\n-for this reason.\n-\n-As you can see, `enum`s are quite a powerful tool for data representation, and are\n-even more useful when they're [generic][generics] across types. Before we\n-get to generics, though, let's talk about how to use them with pattern matching, a\n-tool that will let us deconstruct this sum type (the type theory term for enums)\n-in a very elegant way and avoid all these messy `if`/`else`s.\n+so do this with caution. For this reason, it's normally considered better style\n+to `use` an enum rather than its variants directly.\n+\n+As you can see, `enum`s are quite a powerful tool for data representation, and\n+are even more useful when they're [generic][generics] across types. Before we\n+get to generics, though, let's talk about how to use enums with pattern\n+matching, a tool that will let us deconstruct sum types (the type theory term\n+for enums) like `Ordering` in a very elegant way that avoids all these messy\n+and brittle `if`/`else`s.\n \n \n [arity]: ./glossary.html#arity"}]}