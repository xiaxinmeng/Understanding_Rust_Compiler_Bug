{"sha": "1d1dc48407e9feb5443173aefb3fd0db252e82c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkMWRjNDg0MDdlOWZlYjU0NDMxNzNhZWZiM2ZkMGRiMjUyZTgyYzc=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-06T09:37:28Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-11-10T18:22:37Z"}, "message": "codegen_llvm_back: whitespace & formatting fixes", "tree": {"sha": "ef96548349f1650735bbf670a3e49a505c335453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef96548349f1650735bbf670a3e49a505c335453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d1dc48407e9feb5443173aefb3fd0db252e82c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d1dc48407e9feb5443173aefb3fd0db252e82c7", "html_url": "https://github.com/rust-lang/rust/commit/1d1dc48407e9feb5443173aefb3fd0db252e82c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d1dc48407e9feb5443173aefb3fd0db252e82c7/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06118eac4c602a22d2004c98756a95f2c5ec95d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/06118eac4c602a22d2004c98756a95f2c5ec95d5", "html_url": "https://github.com/rust-lang/rust/commit/06118eac4c602a22d2004c98756a95f2c5ec95d5"}], "stats": {"total": 115, "additions": 53, "deletions": 62}, "files": [{"sha": "077c8c31f4a2e867b173910eda841faf36b5fa03", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -83,6 +83,7 @@ impl<'a> ArchiveBuilder<'a> {\n         if self.src_archive().is_none() {\n             return Vec::new()\n         }\n+\n         let archive = self.src_archive.as_ref().unwrap().as_ref().unwrap();\n         let ret = archive.iter()\n                          .filter_map(|child| child.ok())"}, {"sha": "b137102659aa350f9e9674983bf643c82e4956c5", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -47,8 +47,8 @@ use std::str;\n use syntax::attr;\n \n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n-                                  invalid_output_for_target, out_filename, check_file_is_writeable,\n-                                  filename_for_metadata};\n+                                    invalid_output_for_target, filename_for_metadata,\n+                                    out_filename, check_file_is_writeable};\n \n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n@@ -147,9 +147,7 @@ pub(crate) fn link_binary(sess: &Session,\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n     if !sess.opts.cg.save_temps {\n-        if sess.opts.output_types.should_codegen() &&\n-            !preserve_objects_for_their_debuginfo(sess)\n-        {\n+        if sess.opts.output_types.should_codegen() && !preserve_objects_for_their_debuginfo(sess) {\n             for obj in codegen_results.modules.iter().filter_map(|m| m.object.as_ref()) {\n                 remove(sess, obj);\n             }\n@@ -814,8 +812,8 @@ fn link_natively(sess: &Session,\n                     .unwrap_or_else(|_| {\n                         let mut x = \"Non-UTF-8 output: \".to_string();\n                         x.extend(s.iter()\n-                                 .flat_map(|&b| ascii::escape_default(b))\n-                                 .map(|b| char::from_u32(b as u32).unwrap()));\n+                                  .flat_map(|&b| ascii::escape_default(b))\n+                                  .map(|b| char::from_u32(b as u32).unwrap()));\n                         x\n                     })\n             }\n@@ -1012,8 +1010,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n                 // ensure the line is interpreted as one whole argument.\n                 for c in self.arg.chars() {\n                     match c {\n-                        '\\\\' |\n-                        ' ' => write!(f, \"\\\\{}\", c)?,\n+                        '\\\\' | ' ' => write!(f, \"\\\\{}\", c)?,\n                         c => write!(f, \"{}\", c)?,\n                     }\n                 }"}, {"sha": "cb944e08c83244c6d7dad7bd21cfa3ec30691c56", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -205,11 +205,11 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         Lto::Fat => {\n             assert!(cached_modules.is_empty());\n             let opt_jobs = fat_lto(cgcx,\n-                                  &diag_handler,\n-                                  modules,\n-                                  upstream_modules,\n-                                  &symbol_white_list,\n-                                  timeline);\n+                                   &diag_handler,\n+                                   modules,\n+                                   upstream_modules,\n+                                   &symbol_white_list,\n+                                   timeline);\n             opt_jobs.map(|opt_jobs| (opt_jobs, vec![]))\n         }\n         Lto::Thin |\n@@ -310,8 +310,8 @@ fn fat_lto(cgcx: &CodegenContext,\n         unsafe {\n             let ptr = symbol_white_list.as_ptr();\n             llvm::LLVMRustRunRestrictionPass(llmod,\n-                                            ptr as *const *const libc::c_char,\n-                                            symbol_white_list.len() as libc::size_t);\n+                                             ptr as *const *const libc::c_char,\n+                                             symbol_white_list.len() as libc::size_t);\n             cgcx.save_temp_bitcode(&module, \"lto.after-restriction\");\n         }\n \n@@ -617,8 +617,7 @@ fn run_pass_manager(cgcx: &CodegenContext,\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        time_ext(cgcx.time_passes, None, \"LTO passes\", ||\n-             llvm::LLVMRunPassManager(pm, llmod));\n+        time_ext(cgcx.time_passes, None, \"LTO passes\", || llvm::LLVMRunPassManager(pm, llmod));\n \n         llvm::LLVMDisposePassManager(pm);\n     }"}, {"sha": "a7772bf55180a4b72c4f5cb2031b36ca247abdc9", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -117,8 +117,7 @@ fn get_rpath_relative_to_output(config: &mut RPathConfig, lib: &Path) -> String\n     let relative = path_relative_from(&lib, &output).unwrap_or_else(||\n         panic!(\"couldn't create relative path from {:?} to {:?}\", output, lib));\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    format!(\"{}/{}\", prefix,\n-            relative.to_str().expect(\"non-utf8 component in path\"))\n+    format!(\"{}/{}\", prefix, relative.to_str().expect(\"non-utf8 component in path\"))\n }\n \n // This routine is adapted from the *old* Path's `path_relative_from`"}, {"sha": "b55121ca69048b706fb921a221706b77e64949ca", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -106,8 +106,7 @@ pub fn write_output_file(\n         file_type: llvm::FileType) -> Result<(), FatalError> {\n     unsafe {\n         let output_c = path2cstr(output);\n-        let result = llvm::LLVMRustWriteOutputFile(\n-                target, pm, m, output_c.as_ptr(), file_type);\n+        let result = llvm::LLVMRustWriteOutputFile(target, pm, m, output_c.as_ptr(), file_type);\n         if result.into_result().is_err() {\n             let msg = format!(\"could not write output to {}\", output.display());\n             Err(llvm_err(handler, msg))\n@@ -590,8 +589,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n \n             for pass in &config.passes {\n                 if !addpass(pass) {\n-                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n-                                            pass));\n+                    diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\", pass));\n                 }\n                 if pass == \"name-anon-globals\" {\n                     have_name_anon_globals_pass = true;\n@@ -601,8 +599,8 @@ unsafe fn optimize(cgcx: &CodegenContext,\n             for pass in &cgcx.plugin_passes {\n                 if !addpass(pass) {\n                     diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n-                                            `{}` but LLVM does not \\\n-                                            recognize it\", pass));\n+                                               `{}` but LLVM does not \\\n+                                               recognize it\", pass));\n                 }\n                 if pass == \"name-anon-globals\" {\n                     have_name_anon_globals_pass = true;\n@@ -613,12 +611,12 @@ unsafe fn optimize(cgcx: &CodegenContext,\n                 // As described above, this will probably cause an error in LLVM\n                 if config.no_prepopulate_passes {\n                     diag_handler.err(\"The current compilation is going to use thin LTO buffers \\\n-                                     without running LLVM's NameAnonGlobals pass. \\\n-                                     This will likely cause errors in LLVM. Consider adding \\\n-                                     -C passes=name-anon-globals to the compiler command line.\");\n+                                      without running LLVM's NameAnonGlobals pass. \\\n+                                      This will likely cause errors in LLVM. Consider adding \\\n+                                      -C passes=name-anon-globals to the compiler command line.\");\n                 } else {\n                     bug!(\"We are using thin LTO buffers without running the NameAnonGlobals pass. \\\n-                         This will likely cause errors in LLVM and should never happen.\");\n+                          This will likely cause errors in LLVM and should never happen.\");\n                 }\n             }\n         }\n@@ -704,9 +702,9 @@ unsafe fn codegen(cgcx: &CodegenContext,\n         // escape the closure itself, and the manager should only be\n         // used once.\n         unsafe fn with_codegen<'ll, F, R>(tm: &'ll llvm::TargetMachine,\n-                                    llmod: &'ll llvm::Module,\n-                                    no_builtins: bool,\n-                                    f: F) -> R\n+                                          llmod: &'ll llvm::Module,\n+                                          no_builtins: bool,\n+                                          f: F) -> R\n             where F: FnOnce(&'ll mut PassManager<'ll>) -> R,\n         {\n             let cpm = llvm::LLVMCreatePassManager();\n@@ -818,15 +816,15 @@ unsafe fn codegen(cgcx: &CodegenContext,\n                 };\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &path,\n-                                    llvm::FileType::AssemblyFile)\n+                                      llvm::FileType::AssemblyFile)\n                 })?;\n                 timeline.record(\"asm\");\n             }\n \n             if write_obj {\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n-                                    llvm::FileType::ObjectFile)\n+                                      llvm::FileType::ObjectFile)\n                 })?;\n                 timeline.record(\"obj\");\n             } else if asm_to_obj {\n@@ -947,11 +945,11 @@ fn need_pre_thin_lto_bitcode_for_incr_comp(sess: &Session) -> bool {\n }\n \n pub fn start_async_codegen(tcx: TyCtxt,\n-                               time_graph: Option<TimeGraph>,\n-                               metadata: EncodedMetadata,\n-                               coordinator_receive: Receiver<Box<dyn Any + Send>>,\n-                               total_cgus: usize)\n-                               -> OngoingCodegen {\n+                           time_graph: Option<TimeGraph>,\n+                           metadata: EncodedMetadata,\n+                           coordinator_receive: Receiver<Box<dyn Any + Send>>,\n+                           total_cgus: usize)\n+                           -> OngoingCodegen {\n     let sess = tcx.sess;\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n@@ -1116,7 +1114,8 @@ fn copy_all_cgu_workproducts_to_incr_comp_cache_dir(\n         }\n \n         if let Some((id, product)) =\n-                copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files) {\n+            copy_cgu_workproducts_to_incr_comp_cache_dir(sess, &module.name, &files)\n+        {\n             work_products.insert(id, product);\n         }\n     }\n@@ -1584,10 +1583,8 @@ fn start_executing_work(tcx: TyCtxt,\n \n         let (name, mut cmd) = get_linker(sess, &linker, flavor);\n         cmd.args(&sess.target.target.options.asm_args);\n-        Some(Arc::new(AssemblerCommand {\n-            name,\n-            cmd,\n-        }))\n+\n+        Some(Arc::new(AssemblerCommand { name, cmd }))\n     } else {\n         None\n     };\n@@ -2186,9 +2183,9 @@ pub fn run_assembler(cgcx: &CodegenContext, handler: &Handler, assembly: &Path,\n                 handler.struct_err(&format!(\"linking with `{}` failed: {}\",\n                                             pname.display(),\n                                             prog.status))\n-                    .note(&format!(\"{:?}\", &cmd))\n-                    .note(str::from_utf8(&note[..]).unwrap())\n-                    .emit();\n+                       .note(&format!(\"{:?}\", &cmd))\n+                       .note(str::from_utf8(&note[..]).unwrap())\n+                       .emit();\n                 handler.abort_if_errors();\n             }\n         },\n@@ -2450,8 +2447,8 @@ impl OngoingCodegen {\n     }\n \n     pub(crate) fn submit_pre_codegened_module_to_llvm(&self,\n-                                                       tcx: TyCtxt,\n-                                                       module: ModuleCodegen) {\n+                                                      tcx: TyCtxt,\n+                                                      module: ModuleCodegen) {\n         self.wait_for_signal_to_codegen_item();\n         self.check_for_errors(tcx.sess);\n "}, {"sha": "501166af90686dfeb04cfa3cfb24946be26f6526", "filename": "src/librustc_codegen_utils/linker.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_utils%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_utils%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flinker.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -224,9 +224,9 @@ impl<'a> GccLinker<'a> {\n }\n \n impl<'a> Linker for GccLinker<'a> {\n-    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\",lib)); }\n+    fn link_dylib(&mut self, lib: &str) { self.hint_dynamic(); self.cmd.arg(format!(\"-l{}\", lib)); }\n     fn link_staticlib(&mut self, lib: &str) {\n-        self.hint_static(); self.cmd.arg(format!(\"-l{}\",lib));\n+        self.hint_static(); self.cmd.arg(format!(\"-l{}\", lib));\n     }\n     fn link_rlib(&mut self, lib: &Path) { self.hint_static(); self.cmd.arg(lib); }\n     fn include_path(&mut self, path: &Path) { self.cmd.arg(\"-L\").arg(path); }\n@@ -243,7 +243,7 @@ impl<'a> Linker for GccLinker<'a> {\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n         self.hint_dynamic();\n-        self.cmd.arg(format!(\"-l{}\",lib));\n+        self.cmd.arg(format!(\"-l{}\", lib));\n     }\n \n     fn link_framework(&mut self, framework: &str) {\n@@ -261,7 +261,7 @@ impl<'a> Linker for GccLinker<'a> {\n         self.hint_static();\n         let target = &self.sess.target.target;\n         if !target.options.is_like_osx {\n-            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\",lib));\n+            self.linker_arg(\"--whole-archive\").cmd.arg(format!(\"-l{}\", lib));\n             self.linker_arg(\"--no-whole-archive\");\n         } else {\n             // -force_load is the macOS equivalent of --whole-archive, but it\n@@ -373,8 +373,7 @@ impl<'a> Linker for GccLinker<'a> {\n             // purely to support rustbuild right now, we should get a more\n             // principled solution at some point to force the compiler to pass\n             // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath ||\n-               self.sess.opts.debugging_opts.osx_rpath_install_name {\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n                 self.linker_arg(\"-install_name\");\n                 let mut v = OsString::from(\"@rpath/\");\n                 v.push(out_filename.file_name().unwrap());"}, {"sha": "dff7e518630e4d23628aea3f6db9000caf04a35a", "filename": "src/librustc_codegen_utils/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d1dc48407e9feb5443173aefb3fd0db252e82c7/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_export.rs?ref=1d1dc48407e9feb5443173aefb3fd0db252e82c7", "patch": "@@ -47,11 +47,10 @@ fn crate_export_threshold(crate_type: config::CrateType) -> SymbolExportLevel {\n     }\n }\n \n-pub fn crates_export_threshold(crate_types: &[config::CrateType])\n-                                      -> SymbolExportLevel {\n-    if crate_types.iter().any(|&crate_type| {\n-        crate_export_threshold(crate_type) == SymbolExportLevel::Rust\n-    }) {\n+pub fn crates_export_threshold(crate_types: &[config::CrateType]) -> SymbolExportLevel {\n+    if crate_types.iter().any(|&crate_type|\n+        crate_export_threshold(crate_type) == SymbolExportLevel::Rust)\n+    {\n         SymbolExportLevel::Rust\n     } else {\n         SymbolExportLevel::C\n@@ -359,7 +358,7 @@ fn is_unreachable_local_definition_provider(tcx: TyCtxt, def_id: DefId) -> bool\n         !tcx.reachable_set(LOCAL_CRATE).0.contains(&node_id)\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\",\n-              def_id)\n+             def_id)\n     }\n }\n "}]}