{"sha": "c687d0490e5648c107b8de5fefb96b521ae889d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2ODdkMDQ5MGU1NjQ4YzEwN2I4ZGU1ZmVmYjk2YjUyMWFlODg5ZDk=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-04-21T21:49:06Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2020-04-23T12:30:30Z"}, "message": "Create new rustdoc lint to check for code blocks tags", "tree": {"sha": "e9297ffc0ac1053722ab6697f8d0922b25c37c1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9297ffc0ac1053722ab6697f8d0922b25c37c1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c687d0490e5648c107b8de5fefb96b521ae889d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c687d0490e5648c107b8de5fefb96b521ae889d9", "html_url": "https://github.com/rust-lang/rust/commit/c687d0490e5648c107b8de5fefb96b521ae889d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c687d0490e5648c107b8de5fefb96b521ae889d9/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d", "html_url": "https://github.com/rust-lang/rust/commit/2dc5b602eee35d70e8e6e506a7ea07b6c7e0197d"}], "stats": {"total": 243, "additions": 217, "deletions": 26}, "files": [{"sha": "bcd59702289591e6288682e431a72d973eb7ebc0", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -61,7 +61,8 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n     BARE_TRAIT_OBJECTS, ELIDED_LIFETIMES_IN_PATHS, EXPLICIT_OUTLIVES_REQUIREMENTS,\n-    INTRA_DOC_LINK_RESOLUTION_FAILURE, MISSING_DOC_CODE_EXAMPLES, PRIVATE_DOC_TESTS,\n+    INTRA_DOC_LINK_RESOLUTION_FAILURE, INVALID_CODEBLOCK_ATTRIBUTE, MISSING_DOC_CODE_EXAMPLES,\n+    PRIVATE_DOC_TESTS,\n };\n use rustc_span::Span;\n \n@@ -299,6 +300,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n     add_lint_group!(\n         \"rustdoc\",\n         INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        INVALID_CODEBLOCK_ATTRIBUTE,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS\n     );"}, {"sha": "3ace9ecbd60e5af8adfde2d5d8b11778b881972c", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -386,6 +386,12 @@ declare_lint! {\n     \"failures in resolving intra-doc link targets\"\n }\n \n+declare_lint! {\n+    pub INVALID_CODEBLOCK_ATTRIBUTE,\n+    Warn,\n+    \"codeblock attribute looks a lot like a known one\"\n+}\n+\n declare_lint! {\n     pub MISSING_CRATE_LEVEL_DOCS,\n     Allow,\n@@ -553,6 +559,7 @@ declare_lint_pass! {\n         UNSTABLE_NAME_COLLISIONS,\n         IRREFUTABLE_LET_PATTERNS,\n         INTRA_DOC_LINK_RESOLUTION_FAILURE,\n+        INVALID_CODEBLOCK_ATTRIBUTE,\n         MISSING_CRATE_LEVEL_DOCS,\n         MISSING_DOC_CODE_EXAMPLES,\n         PRIVATE_DOC_TESTS,"}, {"sha": "f83bb9b1162de9e4711826adbbddcfc8486df68e", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -253,6 +253,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n     let missing_doc_example = rustc_lint::builtin::MISSING_DOC_CODE_EXAMPLES.name;\n     let private_doc_tests = rustc_lint::builtin::PRIVATE_DOC_TESTS.name;\n     let no_crate_level_docs = rustc_lint::builtin::MISSING_CRATE_LEVEL_DOCS.name;\n+    let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n \n     // In addition to those specific lints, we also need to whitelist those given through\n     // command line, otherwise they'll get ignored and we don't want that.\n@@ -263,6 +264,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         missing_doc_example.to_owned(),\n         private_doc_tests.to_owned(),\n         no_crate_level_docs.to_owned(),\n+        invalid_codeblock_attribute_name.to_owned(),\n     ];\n \n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n@@ -275,7 +277,10 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n     let lint_opts = lints()\n         .filter_map(|lint| {\n-            if lint.name == warnings_lint_name || lint.name == intra_link_resolution_failure_name {\n+            if lint.name == warnings_lint_name\n+                || lint.name == intra_link_resolution_failure_name\n+                || lint.name == invalid_codeblock_attribute_name\n+            {\n                 None\n             } else {\n                 Some((lint.name_lower(), lint::Allow))"}, {"sha": "862c20dd16a556790061ce2b345df22b20eed870", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -20,7 +20,12 @@\n #![allow(non_camel_case_types)]\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::HirId;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::lint;\n use rustc_span::edition::Edition;\n+use rustc_span::Span;\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::VecDeque;\n@@ -192,7 +197,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n         if let Some(Event::Start(Tag::CodeBlock(kind))) = event {\n             let parse_result = match kind {\n                 CodeBlockKind::Fenced(ref lang) => {\n-                    LangString::parse(&lang, self.check_error_codes, false)\n+                    LangString::parse_without_check(&lang, self.check_error_codes, false)\n                 }\n                 CodeBlockKind::Indented => LangString::all_false(),\n             };\n@@ -560,6 +565,7 @@ pub fn find_testable_code<T: test::Tester>(\n     tests: &mut T,\n     error_codes: ErrorCodes,\n     enable_per_target_ignores: bool,\n+    extra_info: Option<&ExtraInfo<'_, '_>>,\n ) {\n     let mut parser = Parser::new(doc).into_offset_iter();\n     let mut prev_offset = 0;\n@@ -573,7 +579,12 @@ pub fn find_testable_code<T: test::Tester>(\n                         if lang.is_empty() {\n                             LangString::all_false()\n                         } else {\n-                            LangString::parse(lang, error_codes, enable_per_target_ignores)\n+                            LangString::parse(\n+                                lang,\n+                                error_codes,\n+                                enable_per_target_ignores,\n+                                extra_info,\n+                            )\n                         }\n                     }\n                     CodeBlockKind::Indented => LangString::all_false(),\n@@ -615,6 +626,49 @@ pub fn find_testable_code<T: test::Tester>(\n     }\n }\n \n+pub struct ExtraInfo<'a, 'b> {\n+    hir_id: Option<HirId>,\n+    item_did: Option<DefId>,\n+    sp: Span,\n+    tcx: &'a TyCtxt<'b>,\n+}\n+\n+impl<'a, 'b> ExtraInfo<'a, 'b> {\n+    pub fn new(tcx: &'a TyCtxt<'b>, hir_id: HirId, sp: Span) -> ExtraInfo<'a, 'b> {\n+        ExtraInfo { hir_id: Some(hir_id), item_did: None, sp, tcx }\n+    }\n+\n+    pub fn new_did(tcx: &'a TyCtxt<'b>, did: DefId, sp: Span) -> ExtraInfo<'a, 'b> {\n+        ExtraInfo { hir_id: None, item_did: Some(did), sp, tcx }\n+    }\n+\n+    fn error_invalid_codeblock_attr(&self, msg: &str, help: &str) {\n+        let hir_id = match (self.hir_id, self.item_did) {\n+            (Some(h), _) => h,\n+            (None, Some(item_did)) => {\n+                match self.tcx.hir().as_local_hir_id(item_did) {\n+                    Some(hir_id) => hir_id,\n+                    None => {\n+                        // If non-local, no need to check anything.\n+                        return;\n+                    }\n+                }\n+            }\n+            (None, None) => return,\n+        };\n+        self.tcx.struct_span_lint_hir(\n+            lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE,\n+            hir_id,\n+            self.sp,\n+            |lint| {\n+                let mut diag = lint.build(msg);\n+                diag.help(help);\n+                diag.emit();\n+            },\n+        );\n+    }\n+}\n+\n #[derive(Eq, PartialEq, Clone, Debug)]\n pub struct LangString {\n     original: String,\n@@ -652,10 +706,19 @@ impl LangString {\n         }\n     }\n \n+    fn parse_without_check(\n+        string: &str,\n+        allow_error_code_check: ErrorCodes,\n+        enable_per_target_ignores: bool,\n+    ) -> LangString {\n+        Self::parse(string, allow_error_code_check, enable_per_target_ignores, None)\n+    }\n+\n     fn parse(\n         string: &str,\n         allow_error_code_check: ErrorCodes,\n         enable_per_target_ignores: bool,\n+        extra: Option<&ExtraInfo<'_, '_>>,\n     ) -> LangString {\n         let allow_error_code_check = allow_error_code_check.as_bool();\n         let mut seen_rust_tags = false;\n@@ -715,6 +778,53 @@ impl LangString {\n                         seen_other_tags = true;\n                     }\n                 }\n+                x if extra.is_some() => {\n+                    let s = x.to_lowercase();\n+                    match if s == \"compile-fail\" || s == \"compile_fail\" || s == \"compilefail\" {\n+                        Some((\n+                            \"compile_fail\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or won't fail if it compiles successfully\",\n+                        ))\n+                    } else if s == \"should-panic\" || s == \"should_panic\" || s == \"shouldpanic\" {\n+                        Some((\n+                            \"should_panic\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or won't fail if it doesn't panic when running\",\n+                        ))\n+                    } else if s == \"no-run\" || s == \"no_run\" || s == \"norun\" {\n+                        Some((\n+                            \"no_run\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or will be run (which you might not want)\",\n+                        ))\n+                    } else if s == \"allow-fail\" || s == \"allow_fail\" || s == \"allowfail\" {\n+                        Some((\n+                            \"allow_fail\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or will be run (which you might not want)\",\n+                        ))\n+                    } else if s == \"test-harness\" || s == \"test_harness\" || s == \"testharness\" {\n+                        Some((\n+                            \"test_harness\",\n+                            \"the code block will either not be tested if not marked as a rust one \\\n+                             or the code will be wrapped inside a main function\",\n+                        ))\n+                    } else {\n+                        None\n+                    } {\n+                        Some((flag, help)) => {\n+                            if let Some(ref extra) = extra {\n+                                extra.error_invalid_codeblock_attr(\n+                                    &format!(\"unknown attribute `{}`. Did you mean `{}`?\", x, flag),\n+                                    help,\n+                                );\n+                            }\n+                        }\n+                        None => {}\n+                    }\n+                    seen_other_tags = true;\n+                }\n                 _ => seen_other_tags = true,\n             }\n         }\n@@ -934,7 +1044,7 @@ crate struct RustCodeBlock {\n \n /// Returns a range of bytes for each code block in the markdown that is tagged as `rust` or\n /// untagged (and assumed to be rust).\n-crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n+crate fn rust_code_blocks(md: &str, extra_info: &ExtraInfo<'_, '_>) -> Vec<RustCodeBlock> {\n     let mut code_blocks = vec![];\n \n     if md.is_empty() {\n@@ -951,7 +1061,7 @@ crate fn rust_code_blocks(md: &str) -> Vec<RustCodeBlock> {\n                     let lang_string = if syntax.is_empty() {\n                         LangString::all_false()\n                     } else {\n-                        LangString::parse(&*syntax, ErrorCodes::Yes, false)\n+                        LangString::parse(&*syntax, ErrorCodes::Yes, false, Some(extra_info))\n                     };\n                     if !lang_string.rust {\n                         continue;"}, {"sha": "b4c0f0ac4c5d94febbc8798e3a7e6b353c357ee0", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -153,7 +153,7 @@ pub fn test(mut options: Options, diag: &rustc_errors::Handler) -> i32 {\n     collector.set_position(DUMMY_SP);\n     let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n \n-    find_testable_code(&input_str, &mut collector, codes, options.enable_per_target_ignores);\n+    find_testable_code(&input_str, &mut collector, codes, options.enable_per_target_ignores, None);\n \n     options.test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main("}, {"sha": "d1f2c12ccd630c6435cd32b733e8a81787cb728e", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -10,7 +10,7 @@ use crate::clean;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n use crate::html::markdown::{self, RustCodeBlock};\n-use crate::passes::Pass;\n+use crate::passes::{span_of_attrs, Pass};\n \n pub const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n@@ -114,7 +114,9 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n impl<'a, 'tcx> DocFolder for SyntaxChecker<'a, 'tcx> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if let Some(dox) = &item.attrs.collapsed_doc_value() {\n-            for code_block in markdown::rust_code_blocks(&dox) {\n+            let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());\n+            let extra = crate::html::markdown::ExtraInfo::new_did(&self.cx.tcx, item.def_id, sp);\n+            for code_block in markdown::rust_code_blocks(&dox, &extra) {\n                 self.check_rust_syntax(&item, &dox, code_block);\n             }\n         }"}, {"sha": "70366c90139c2825b5d3f1da04b61c47e68a73f8", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -338,7 +338,7 @@ pub fn look_for_tests<'tcx>(\n \n     let mut tests = Tests { found_tests: 0 };\n \n-    find_testable_code(&dox, &mut tests, ErrorCodes::No, false);\n+    find_testable_code(&dox, &mut tests, ErrorCodes::No, false, None);\n \n     if check_missing_code && tests.found_tests == 0 {\n         let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());"}, {"sha": "e2940efd49c0d567260696f3e571cb646def9ebb", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 81, "deletions": 16, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c687d0490e5648c107b8de5fefb96b521ae889d9/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=c687d0490e5648c107b8de5fefb96b521ae889d9", "patch": "@@ -5,9 +5,11 @@ use rustc_errors::ErrorReported;\n use rustc_feature::UnstableFeatures;\n use rustc_hir as hir;\n use rustc_hir::intravisit;\n+use rustc_hir::{HirId, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n-use rustc_session::{self, config, DiagnosticOutput, Session};\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::{self, config, lint, DiagnosticOutput, Session};\n use rustc_span::edition::Edition;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::sym;\n@@ -25,6 +27,7 @@ use tempfile::Builder as TempFileBuilder;\n use crate::clean::Attributes;\n use crate::config::Options;\n use crate::html::markdown::{self, ErrorCodes, Ignore, LangString};\n+use crate::passes::span_of_attrs;\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -40,6 +43,45 @@ pub struct TestOptions {\n pub fn run(options: Options) -> i32 {\n     let input = config::Input::File(options.input.clone());\n \n+    let warnings_lint_name = lint::builtin::WARNINGS.name;\n+    let invalid_codeblock_attribute_name = rustc_lint::builtin::INVALID_CODEBLOCK_ATTRIBUTE.name;\n+\n+    // In addition to those specific lints, we also need to whitelist those given through\n+    // command line, otherwise they'll get ignored and we don't want that.\n+    let mut whitelisted_lints =\n+        vec![warnings_lint_name.to_owned(), invalid_codeblock_attribute_name.to_owned()];\n+\n+    whitelisted_lints.extend(options.lint_opts.iter().map(|(lint, _)| lint).cloned());\n+\n+    let lints = || {\n+        lint::builtin::HardwiredLints::get_lints()\n+            .into_iter()\n+            .chain(rustc_lint::SoftLints::get_lints().into_iter())\n+    };\n+\n+    let lint_opts = lints()\n+        .filter_map(|lint| {\n+            if lint.name == warnings_lint_name || lint.name == invalid_codeblock_attribute_name {\n+                None\n+            } else {\n+                Some((lint.name_lower(), lint::Allow))\n+            }\n+        })\n+        .chain(options.lint_opts.clone().into_iter())\n+        .collect::<Vec<_>>();\n+\n+    let lint_caps = lints()\n+        .filter_map(|lint| {\n+            // We don't want to whitelist *all* lints so let's\n+            // ignore those ones.\n+            if whitelisted_lints.iter().any(|l| lint.name == l) {\n+                None\n+            } else {\n+                Some((lint::LintId::of(lint), lint::Allow))\n+            }\n+        })\n+        .collect();\n+\n     let crate_types = if options.proc_macro_crate {\n         vec![config::CrateType::ProcMacro]\n     } else {\n@@ -50,10 +92,11 @@ pub fn run(options: Options) -> i32 {\n         maybe_sysroot: options.maybe_sysroot.clone(),\n         search_paths: options.libs.clone(),\n         crate_types,\n+        lint_opts: if !options.display_warnings { lint_opts } else { vec![] },\n+        lint_cap: Some(options.lint_cap.clone().unwrap_or_else(|| lint::Forbid)),\n         cg: options.codegen_options.clone(),\n         externs: options.externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n-        lint_cap: Some(rustc_session::lint::Level::Allow),\n         actually_rustdoc: true,\n         debugging_opts: config::DebuggingOptions { ..config::basic_debugging_options() },\n         edition: options.edition,\n@@ -75,7 +118,7 @@ pub fn run(options: Options) -> i32 {\n         diagnostic_output: DiagnosticOutput::Default,\n         stderr: None,\n         crate_name: options.crate_name.clone(),\n-        lint_caps: Default::default(),\n+        lint_caps,\n         register_lints: None,\n         override_queries: None,\n         registry: rustc_driver::diagnostics_registry(),\n@@ -105,17 +148,25 @@ pub fn run(options: Options) -> i32 {\n \n             global_ctxt.enter(|tcx| {\n                 let krate = tcx.hir().krate();\n+\n                 let mut hir_collector = HirCollector {\n                     sess: compiler.session(),\n                     collector: &mut collector,\n                     map: tcx.hir(),\n                     codes: ErrorCodes::from(\n                         compiler.session().opts.unstable_features.is_nightly_build(),\n                     ),\n+                    tcx,\n                 };\n-                hir_collector.visit_testable(\"\".to_string(), &krate.item.attrs, |this| {\n-                    intravisit::walk_crate(this, krate);\n-                });\n+                hir_collector.visit_testable(\n+                    \"\".to_string(),\n+                    &krate.item.attrs,\n+                    CRATE_HIR_ID,\n+                    krate.item.span,\n+                    |this| {\n+                        intravisit::walk_crate(this, krate);\n+                    },\n+                );\n             });\n             compiler.session().abort_if_errors();\n \n@@ -881,18 +932,21 @@ impl Tester for Collector {\n     }\n }\n \n-struct HirCollector<'a, 'hir> {\n+struct HirCollector<'a, 'hir, 'tcx> {\n     sess: &'a Session,\n     collector: &'a mut Collector,\n     map: Map<'hir>,\n     codes: ErrorCodes,\n+    tcx: TyCtxt<'tcx>,\n }\n \n-impl<'a, 'hir> HirCollector<'a, 'hir> {\n+impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n     fn visit_testable<F: FnOnce(&mut Self)>(\n         &mut self,\n         name: String,\n         attrs: &[ast::Attribute],\n+        hir_id: HirId,\n+        sp: Span,\n         nested: F,\n     ) {\n         let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n@@ -918,6 +972,11 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                 self.collector,\n                 self.codes,\n                 self.collector.enable_per_target_ignores,\n+                Some(&crate::html::markdown::ExtraInfo::new(\n+                    &self.tcx,\n+                    hir_id,\n+                    span_of_attrs(&attrs).unwrap_or(sp),\n+                )),\n             );\n         }\n \n@@ -929,7 +988,7 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n     }\n }\n \n-impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n+impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx> {\n     type Map = Map<'hir>;\n \n     fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n@@ -943,25 +1002,25 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n             item.ident.to_string()\n         };\n \n-        self.visit_testable(name, &item.attrs, |this| {\n+        self.visit_testable(name, &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_trait_item(this, item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_impl_item(this, item);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem) {\n-        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, item.hir_id, item.span, |this| {\n             intravisit::walk_foreign_item(this, item);\n         });\n     }\n@@ -972,19 +1031,25 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n         g: &'hir hir::Generics,\n         item_id: hir::HirId,\n     ) {\n-        self.visit_testable(v.ident.to_string(), &v.attrs, |this| {\n+        self.visit_testable(v.ident.to_string(), &v.attrs, v.id, v.span, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }\n \n     fn visit_struct_field(&mut self, f: &'hir hir::StructField) {\n-        self.visit_testable(f.ident.to_string(), &f.attrs, |this| {\n+        self.visit_testable(f.ident.to_string(), &f.attrs, f.hir_id, f.span, |this| {\n             intravisit::walk_struct_field(this, f);\n         });\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir hir::MacroDef) {\n-        self.visit_testable(macro_def.ident.to_string(), &macro_def.attrs, |_| ());\n+        self.visit_testable(\n+            macro_def.ident.to_string(),\n+            &macro_def.attrs,\n+            macro_def.hir_id,\n+            macro_def.span,\n+            |_| (),\n+        );\n     }\n }\n "}]}