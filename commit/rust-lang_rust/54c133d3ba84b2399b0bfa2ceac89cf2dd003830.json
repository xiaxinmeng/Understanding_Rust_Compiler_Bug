{"sha": "54c133d3ba84b2399b0bfa2ceac89cf2dd003830", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YzEzM2QzYmE4NGIyMzk5YjBiZmEyY2VhYzg5Y2YyZGQwMDM4MzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-10-17T03:00:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-17T03:00:14Z"}, "message": "Auto merge of #37082 - frewsxcv:session, r=jseyfried\n\n'src/librustc/session/filesearch.rs' refactoring and cleanup.", "tree": {"sha": "ee912586fcfeefceb4661a744b831c0f01df0331", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee912586fcfeefceb4661a744b831c0f01df0331"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c133d3ba84b2399b0bfa2ceac89cf2dd003830", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c133d3ba84b2399b0bfa2ceac89cf2dd003830", "html_url": "https://github.com/rust-lang/rust/commit/54c133d3ba84b2399b0bfa2ceac89cf2dd003830", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c133d3ba84b2399b0bfa2ceac89cf2dd003830/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6572a463116a31efba8bfddb2e64ed659311b8a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6572a463116a31efba8bfddb2e64ed659311b8a1", "html_url": "https://github.com/rust-lang/rust/commit/6572a463116a31efba8bfddb2e64ed659311b8a1"}, {"sha": "0038430192bf1f78f65288b823abec8c6bdc5cc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0038430192bf1f78f65288b823abec8c6bdc5cc8", "html_url": "https://github.com/rust-lang/rust/commit/0038430192bf1f78f65288b823abec8c6bdc5cc8"}], "stats": {"total": 82, "additions": 37, "deletions": 45}, "files": [{"sha": "82c2425aead734f4244f8f62a97febb54366a475", "filename": "src/librustc/session/filesearch.rs", "status": "modified", "additions": 37, "deletions": 45, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/54c133d3ba84b2399b0bfa2ceac89cf2dd003830/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c133d3ba84b2399b0bfa2ceac89cf2dd003830/src%2Flibrustc%2Fsession%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Ffilesearch.rs?ref=54c133d3ba84b2399b0bfa2ceac89cf2dd003830", "patch": "@@ -12,6 +12,7 @@\n \n pub use self::FileMatch::*;\n \n+use std::borrow::Cow;\n use std::collections::HashSet;\n use std::env;\n use std::fs;\n@@ -67,33 +68,32 @@ impl<'a> FileSearch<'a> {\n     {\n         self.for_each_lib_search_path(|lib_search_path, kind| {\n             debug!(\"searching {}\", lib_search_path.display());\n-            match fs::read_dir(lib_search_path) {\n-                Ok(files) => {\n-                    let files = files.filter_map(|p| p.ok().map(|s| s.path()))\n-                                     .collect::<Vec<_>>();\n-                    fn is_rlib(p: &Path) -> bool {\n-                        p.extension().and_then(|s| s.to_str()) == Some(\"rlib\")\n+            let files = match fs::read_dir(lib_search_path) {\n+                Ok(files) => files,\n+                Err(..) => return,\n+            };\n+            let files = files.filter_map(|p| p.ok().map(|s| s.path()))\n+                             .collect::<Vec<_>>();\n+            fn is_rlib(p: &Path) -> bool {\n+                p.extension() == Some(\"rlib\".as_ref())\n+            }\n+            // Reading metadata out of rlibs is faster, and if we find both\n+            // an rlib and a dylib we only read one of the files of\n+            // metadata, so in the name of speed, bring all rlib files to\n+            // the front of the search list.\n+            let files1 = files.iter().filter(|p| is_rlib(p));\n+            let files2 = files.iter().filter(|p| !is_rlib(p));\n+            for path in files1.chain(files2) {\n+                debug!(\"testing {}\", path.display());\n+                let maybe_picked = pick(path, kind);\n+                match maybe_picked {\n+                    FileMatches => {\n+                        debug!(\"picked {}\", path.display());\n                     }\n-                    // Reading metadata out of rlibs is faster, and if we find both\n-                    // an rlib and a dylib we only read one of the files of\n-                    // metadata, so in the name of speed, bring all rlib files to\n-                    // the front of the search list.\n-                    let files1 = files.iter().filter(|p| is_rlib(p));\n-                    let files2 = files.iter().filter(|p| !is_rlib(p));\n-                    for path in files1.chain(files2) {\n-                        debug!(\"testing {}\", path.display());\n-                        let maybe_picked = pick(path, kind);\n-                        match maybe_picked {\n-                            FileMatches => {\n-                                debug!(\"picked {}\", path.display());\n-                            }\n-                            FileDoesntMatch => {\n-                                debug!(\"rejected {}\", path.display());\n-                            }\n-                        }\n+                    FileDoesntMatch => {\n+                        debug!(\"rejected {}\", path.display());\n                     }\n                 }\n-                Err(..) => (),\n             }\n         });\n     }\n@@ -123,18 +123,18 @@ impl<'a> FileSearch<'a> {\n     // Returns a list of directories where target-specific tool binaries are located.\n     pub fn get_tools_search_paths(&self) -> Vec<PathBuf> {\n         let mut p = PathBuf::from(self.sysroot);\n-        p.push(&find_libdir(self.sysroot));\n-        p.push(&rustlibdir());\n+        p.push(find_libdir(self.sysroot).as_ref());\n+        p.push(RUST_LIB_DIR);\n         p.push(&self.triple);\n         p.push(\"bin\");\n         vec![p]\n     }\n }\n \n pub fn relative_target_lib_path(sysroot: &Path, target_triple: &str) -> PathBuf {\n-    let mut p = PathBuf::from(&find_libdir(sysroot));\n+    let mut p = PathBuf::from(find_libdir(sysroot).as_ref());\n     assert!(p.is_relative());\n-    p.push(&rustlibdir());\n+    p.push(RUST_LIB_DIR);\n     p.push(target_triple);\n     p.push(\"lib\");\n     p\n@@ -166,7 +166,7 @@ pub fn get_or_default_sysroot() -> PathBuf {\n }\n \n // The name of the directory rustc expects libraries to be located.\n-fn find_libdir(sysroot: &Path) -> String {\n+fn find_libdir(sysroot: &Path) -> Cow<'static, str> {\n     // FIXME: This is a quick hack to make the rustc binary able to locate\n     // Rust libraries in Linux environments where libraries might be installed\n     // to lib64/lib32. This would be more foolproof by basing the sysroot off\n@@ -176,31 +176,23 @@ fn find_libdir(sysroot: &Path) -> String {\n     // \"lib\" (i.e. non-default), this value is used (see issue #16552).\n \n     match option_env!(\"CFG_LIBDIR_RELATIVE\") {\n-        Some(libdir) if libdir != \"lib\" => return libdir.to_string(),\n-        _ => if sysroot.join(&primary_libdir_name()).join(&rustlibdir()).exists() {\n-            return primary_libdir_name();\n+        Some(libdir) if libdir != \"lib\" => return libdir.into(),\n+        _ => if sysroot.join(PRIMARY_LIB_DIR).join(RUST_LIB_DIR).exists() {\n+            return PRIMARY_LIB_DIR.into();\n         } else {\n-            return secondary_libdir_name();\n+            return SECONDARY_LIB_DIR.into();\n         }\n     }\n \n     #[cfg(target_pointer_width = \"64\")]\n-    fn primary_libdir_name() -> String {\n-        \"lib64\".to_string()\n-    }\n+    const PRIMARY_LIB_DIR: &'static str = \"lib64\";\n \n     #[cfg(target_pointer_width = \"32\")]\n-    fn primary_libdir_name() -> String {\n-        \"lib32\".to_string()\n-    }\n+    const PRIMARY_LIB_DIR: &'static str = \"lib32\";\n \n-    fn secondary_libdir_name() -> String {\n-        \"lib\".to_string()\n-    }\n+    const SECONDARY_LIB_DIR: &'static str = \"lib\";\n }\n \n // The name of rustc's own place to organize libraries.\n // Used to be \"rustc\", now the default is \"rustlib\"\n-pub fn rustlibdir() -> String {\n-    \"rustlib\".to_string()\n-}\n+const RUST_LIB_DIR: &'static str = \"rustlib\";"}]}