{"sha": "748a4cacd24d9ecdca995e66117a10a1562e7d5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0OGE0Y2FjZDI0ZDllY2RjYTk5NWU2NjExN2ExMGExNTYyZTdkNWQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-28T11:47:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-28T11:47:12Z"}, "message": "Reorganize tests", "tree": {"sha": "4640f14c4c4417743815f9792058df30feac70dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4640f14c4c4417743815f9792058df30feac70dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/748a4cacd24d9ecdca995e66117a10a1562e7d5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/748a4cacd24d9ecdca995e66117a10a1562e7d5d", "html_url": "https://github.com/rust-lang/rust/commit/748a4cacd24d9ecdca995e66117a10a1562e7d5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/748a4cacd24d9ecdca995e66117a10a1562e7d5d/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6c41a205a908eb94f139f968f803e728fc3418c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c41a205a908eb94f139f968f803e728fc3418c6", "html_url": "https://github.com/rust-lang/rust/commit/6c41a205a908eb94f139f968f803e728fc3418c6"}], "stats": {"total": 786, "additions": 417, "deletions": 369}, "files": [{"sha": "ca159c658810a32adb861aa100cfada162476882", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -128,3 +128,52 @@ impl PushDisplay for String {\n         write!(self, \"{}\", item).unwrap()\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::check_action;\n+\n+    #[test]\n+    fn test_swap_comma() {\n+        check_action(\n+            \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n+            \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n+            |file, off| flip_comma(file, off).map(|f| f()),\n+        )\n+    }\n+\n+    #[test]\n+    fn test_add_derive() {\n+        check_action(\n+            \"struct Foo { a: i32, <|>}\",\n+            \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"struct Foo { <|> a: i32, }\",\n+            \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n+            \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n+            |file, off| add_derive(file, off).map(|f| f()),\n+        );\n+    }\n+\n+    #[test]\n+    fn test_add_impl() {\n+        check_action(\n+            \"struct Foo {<|>}\\n\",\n+            \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\",\n+            |file, off| add_impl(file, off).map(|f| f()),\n+        );\n+        check_action(\n+            \"struct Foo<T: Clone> {<|>}\",\n+            \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n+            |file, off| add_impl(file, off).map(|f| f()),\n+        );\n+    }\n+\n+}"}, {"sha": "c6ce62661530110a6352f74361df55e4fe219bcc", "filename": "crates/libeditor/src/completion.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcompletion.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -37,3 +37,55 @@ fn complete(name_ref: ast::NameRef, scopes: &FnScopes) -> Vec<CompletionItem> {\n         })\n         .collect()\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::{assert_eq_dbg, extract_offset};\n+\n+    fn do_check(code: &str, expected_completions: &str) {\n+        let (off, code) = extract_offset(&code);\n+        let file = File::parse(&code);\n+        let completions = scope_completion(&file, off).unwrap();\n+        assert_eq_dbg(expected_completions, &completions);\n+    }\n+\n+    #[test]\n+    fn test_completion_let_scope() {\n+        do_check(r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \", r#\"[CompletionItem { name: \"y\" },\n+                   CompletionItem { name: \"x\" }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_if_let_scope() {\n+        do_check(r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \", r#\"[CompletionItem { name: \"b\" },\n+                   CompletionItem { name: \"a\" }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_for_scope() {\n+        do_check(r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \", r#\"[CompletionItem { name: \"x\" }]\"#);\n+    }\n+}"}, {"sha": "30cff655870b162732fbcd9ee4c55c79b218d8a3", "filename": "crates/libeditor/src/extend_selection.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fextend_selection.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -64,3 +64,58 @@ fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n     }\n     res\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::extract_offset;\n+\n+    fn do_check(before: &str, afters: &[&str]) {\n+        let (cursor, before) = extract_offset(before);\n+        let file = File::parse(&before);\n+        let mut range = TextRange::offset_len(cursor, 0.into());\n+        for &after in afters {\n+            range = extend_selection(&file, range)\n+                .unwrap();\n+            let actual = &before[range];\n+            assert_eq!(after, actual);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_arith() {\n+        do_check(\n+            r#\"fn foo() { <|>1 + 1 }\"#,\n+            &[\"1\", \"1 + 1\", \"{ 1 + 1 }\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_start_of_the_lind() {\n+        do_check(\n+            r#\"\n+impl S {\n+<|>    fn foo() {\n+\n+    }\n+}\"#,\n+            &[\"fn foo() {\\n\\n    }\"]\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extend_selection_comments() {\n+        do_check(\n+            r#\"\n+fn bar(){}\n+\n+// fn foo() {\n+// 1 + <|>1\n+// }\n+\n+// fn foo(){}\n+    \"#,\n+            &[\"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"]\n+        );\n+    }\n+}"}, {"sha": "b2e2c4782c67785e58a19e2c5e9d92cb98adc899", "filename": "crates/libeditor/src/lib.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Flib.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -1,6 +1,9 @@\n extern crate libsyntax2;\n extern crate superslice;\n extern crate itertools;\n+#[cfg(test)]\n+#[macro_use]\n+extern crate test_utils as _test_utils;\n \n mod extend_selection;\n mod symbols;\n@@ -10,6 +13,8 @@ mod code_actions;\n mod typing;\n mod completion;\n mod scope;\n+#[cfg(test)]\n+mod test_utils;\n \n use libsyntax2::{\n     File, TextUnit, TextRange, SyntaxNodeRef,\n@@ -154,3 +159,68 @@ pub fn find_node_at_offset<'a, N: AstNode<'a>>(\n         .filter_map(N::cast)\n         .next()\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::{assert_eq_dbg, extract_offset, add_cursor};\n+\n+    #[test]\n+    fn test_highlighting() {\n+        let file = File::parse(r#\"\n+// comment\n+fn main() {}\n+    println!(\"Hello, {}!\", 92);\n+\"#);\n+        let hls = highlight(&file);\n+        assert_eq_dbg(\n+            r#\"[HighlightedRange { range: [1; 11), tag: \"comment\" },\n+                HighlightedRange { range: [12; 14), tag: \"keyword\" },\n+                HighlightedRange { range: [15; 19), tag: \"function\" },\n+                HighlightedRange { range: [29; 36), tag: \"text\" },\n+                HighlightedRange { range: [38; 50), tag: \"string\" },\n+                HighlightedRange { range: [52; 54), tag: \"literal\" }]\"#,\n+            &hls,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_runnables() {\n+      let file = File::parse(r#\"\n+fn main() {}\n+\n+#[test]\n+fn test_foo() {}\n+\n+#[test]\n+#[ignore]\n+fn test_foo() {}\n+\"#);\n+        let runnables = runnables(&file);\n+        assert_eq_dbg(\n+            r#\"[Runnable { range: [1; 13), kind: Bin },\n+                Runnable { range: [15; 39), kind: Test { name: \"test_foo\" } },\n+                Runnable { range: [41; 75), kind: Test { name: \"test_foo\" } }]\"#,\n+            &runnables,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_matching_brace() {\n+        fn do_check(before: &str, after: &str) {\n+            let (pos, before) = extract_offset(before);\n+            let file = File::parse(&before);\n+            let new_pos = match matching_brace(&file, pos) {\n+                None => pos,\n+                Some(pos) => pos,\n+            };\n+            let actual = add_cursor(&before, new_pos);\n+            assert_eq_text!(after, &actual);\n+        }\n+\n+        do_check(\n+            \"struct Foo { a: i32, }<|>\",\n+            \"struct Foo <|>{ a: i32, }\",\n+        );\n+    }\n+}"}, {"sha": "28b86c004522b48579a3e452f3803a37f499d755", "filename": "crates/libeditor/src/symbols.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fsymbols.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -123,3 +123,45 @@ fn structure_node(node: SyntaxNodeRef) -> Option<StructureNode> {\n         })\n         .accept(node)?\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::assert_eq_dbg;\n+\n+    #[test]\n+    fn test_file_structure() {\n+        let file = File::parse(r#\"\n+struct Foo {\n+    x: i32\n+}\n+\n+mod m {\n+    fn bar() {}\n+}\n+\n+enum E { X, Y(i32) }\n+type T = ();\n+static S: i32 = 92;\n+const C: i32 = 92;\n+\n+impl E {}\n+\n+impl fmt::Debug for E {}\n+\"#);\n+        let symbols = file_structure(&file);\n+        assert_eq_dbg(\n+            r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },\n+                StructureNode { parent: Some(0), label: \"x\", navigation_range: [18; 19), node_range: [18; 24), kind: NAMED_FIELD_DEF },\n+                StructureNode { parent: None, label: \"m\", navigation_range: [32; 33), node_range: [28; 53), kind: MODULE },\n+                StructureNode { parent: Some(2), label: \"bar\", navigation_range: [43; 46), node_range: [40; 51), kind: FN_DEF },\n+                StructureNode { parent: None, label: \"E\", navigation_range: [60; 61), node_range: [55; 75), kind: ENUM_DEF },\n+                StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n+                StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n+                StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n+                StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n+                StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n+            &symbols,\n+        )\n+    }\n+}"}, {"sha": "475f560fa9a29369fcb2602ee2ef065ea12e63eb", "filename": "crates/libeditor/src/test_utils.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftest_utils.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -0,0 +1,20 @@\n+use libsyntax2::{File, TextUnit};\n+pub use _test_utils::*;\n+use ActionResult;\n+\n+pub fn check_action<F: Fn(&File, TextUnit) -> Option<ActionResult>> (\n+    before: &str,\n+    after: &str,\n+    f: F,\n+) {\n+    let (before_cursor_pos, before) = extract_offset(before);\n+    let file = File::parse(&before);\n+    let result = f(&file, before_cursor_pos).expect(\"code action is not applicable\");\n+    let actual = result.edit.apply(&before);\n+    let actual_cursor_pos = match result.cursor_position {\n+        None => result.edit.apply_to_offset(before_cursor_pos).unwrap(),\n+        Some(off) => off,\n+    };\n+    let actual = add_cursor(&actual, actual_cursor_pos);\n+    assert_eq_text!(after, &actual);\n+}"}, {"sha": "952caf7f612de93b024f79f04d334bfc00c036c0", "filename": "crates/libeditor/src/typing.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/748a4cacd24d9ecdca995e66117a10a1562e7d5d/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftyping.rs?ref=748a4cacd24d9ecdca995e66117a10a1562e7d5d", "patch": "@@ -163,3 +163,132 @@ fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n     }\n     \" \"\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use test_utils::{check_action, extract_range, extract_offset};\n+\n+    fn check_join_lines(before: &str, after: &str) {\n+        check_action(before, after, |file, offset| {\n+            let range = TextRange::offset_len(offset, 0.into());\n+            let res = join_lines(file, range);\n+            Some(res)\n+        })\n+    }\n+\n+    #[test]\n+    fn test_join_lines_comma() {\n+        check_join_lines(r\"\n+fn foo() {\n+    <|>foo(1,\n+    )\n+}\n+\", r\"\n+fn foo() {\n+    <|>foo(1)\n+}\n+\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_lambda_block() {\n+        check_join_lines(r\"\n+pub fn reparse(&self, edit: &AtomEdit) -> File {\n+    <|>self.incremental_reparse(edit).unwrap_or_else(|| {\n+        self.full_reparse(edit)\n+    })\n+}\n+\", r\"\n+pub fn reparse(&self, edit: &AtomEdit) -> File {\n+    <|>self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+}\n+\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_block() {\n+        check_join_lines(r\"\n+fn foo() {\n+    foo(<|>{\n+        92\n+    })\n+}\", r\"\n+fn foo() {\n+    foo(<|>92)\n+}\");\n+    }\n+\n+    #[test]\n+    fn test_join_lines_selection() {\n+        fn do_check(before: &str, after: &str) {\n+            let (sel, before) = extract_range(before);\n+            let file = File::parse(&before);\n+            let result = join_lines(&file, sel);\n+            let actual = result.edit.apply(&before);\n+            assert_eq_text!(after, &actual);\n+        }\n+\n+        do_check(r\"\n+fn foo() {\n+    <|>foo(1,\n+        2,\n+        3,\n+    <|>)\n+}\n+    \", r\"\n+fn foo() {\n+    foo(1, 2, 3)\n+}\n+    \");\n+\n+        do_check(r\"\n+struct Foo <|>{\n+    f: u32,\n+}<|>\n+    \", r\"\n+struct Foo { f: u32 }\n+    \");\n+    }\n+\n+    #[test]\n+    fn test_on_eq_typed() {\n+        fn do_check(before: &str, after: &str) {\n+            let (offset, before) = extract_offset(before);\n+            let file = File::parse(&before);\n+            let result = on_eq_typed(&file, offset).unwrap();\n+            let actual = result.edit.apply(&before);\n+            assert_eq_text!(after, &actual);\n+        }\n+\n+        //     do_check(r\"\n+        // fn foo() {\n+        //     let foo =<|>\n+        // }\n+        // \", r\"\n+        // fn foo() {\n+        //     let foo =;\n+        // }\n+        // \");\n+        do_check(r\"\n+fn foo() {\n+    let foo =<|> 1 + 1\n+}\n+\", r\"\n+fn foo() {\n+    let foo = 1 + 1;\n+}\n+\");\n+        //     do_check(r\"\n+        // fn foo() {\n+        //     let foo =<|>\n+        //     let bar = 1;\n+        // }\n+        // \", r\"\n+        // fn foo() {\n+        //     let foo =;\n+        //     let bar = 1;\n+        // }\n+        // \");\n+    }\n+}"}, {"sha": "440afe92d8c7cb7c9e43cf5377468b194acaa138", "filename": "crates/libeditor/tests/test.rs", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/6c41a205a908eb94f139f968f803e728fc3418c6/crates%2Flibeditor%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c41a205a908eb94f139f968f803e728fc3418c6/crates%2Flibeditor%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Ftests%2Ftest.rs?ref=6c41a205a908eb94f139f968f803e728fc3418c6", "patch": "@@ -1,369 +0,0 @@\n-extern crate libeditor;\n-extern crate libsyntax2;\n-#[macro_use]\n-extern crate test_utils;\n-\n-use test_utils::{assert_eq_dbg, add_cursor, extract_offset, extract_range};\n-use libsyntax2::{File, TextUnit, TextRange};\n-use libeditor::{\n-    ActionResult,\n-    highlight, runnables, extend_selection, file_structure,\n-    flip_comma, add_derive, add_impl, matching_brace,\n-    join_lines, on_eq_typed, scope_completion,\n-};\n-\n-#[test]\n-fn test_extend_selection() {\n-    fn do_check(before: &str, afters: &[&str]) {\n-        let (cursor, before) = extract_offset(before);\n-        let file = file(&before);\n-        let mut range = TextRange::offset_len(cursor, 0.into());\n-        for &after in afters {\n-            range = extend_selection(&file, range)\n-                .unwrap();\n-            let actual = &before[range];\n-            assert_eq!(after, actual);\n-        }\n-    }\n-\n-    do_check(\n-        r#\"fn foo() { <|>1 + 1 }\"#,\n-        &[\"1\", \"1 + 1\", \"{ 1 + 1 }\"],\n-    );\n-\n-    do_check(\n-        r#\"\n-impl S {\n-<|>    fn foo() {\n-\n-    }\n-}\"#,\n-        &[\"fn foo() {\\n\\n    }\"]\n-    );\n-    do_check(\n-        r#\"\n-fn bar(){}\n-\n-// fn foo() {\n-// 1 + <|>1\n-// }\n-\n-// fn foo(){}\n-\"#,\n-        &[\"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"]\n-    );\n-}\n-\n-#[test]\n-fn test_highlighting() {\n-    let file = file(r#\"\n-// comment\n-fn main() {}\n-    println!(\"Hello, {}!\", 92);\n-\"#);\n-    let hls = highlight(&file);\n-    assert_eq_dbg(\n-        r#\"[HighlightedRange { range: [1; 11), tag: \"comment\" },\n-            HighlightedRange { range: [12; 14), tag: \"keyword\" },\n-            HighlightedRange { range: [15; 19), tag: \"function\" },\n-            HighlightedRange { range: [29; 36), tag: \"text\" },\n-            HighlightedRange { range: [38; 50), tag: \"string\" },\n-            HighlightedRange { range: [52; 54), tag: \"literal\" }]\"#,\n-        &hls,\n-    );\n-}\n-\n-#[test]\n-fn test_runnables() {\n-    let file = file(r#\"\n-fn main() {}\n-\n-#[test]\n-fn test_foo() {}\n-\n-#[test]\n-#[ignore]\n-fn test_foo() {}\n-\"#);\n-    let runnables = runnables(&file);\n-    assert_eq_dbg(\n-        r#\"[Runnable { range: [1; 13), kind: Bin },\n-            Runnable { range: [15; 39), kind: Test { name: \"test_foo\" } },\n-            Runnable { range: [41; 75), kind: Test { name: \"test_foo\" } }]\"#,\n-        &runnables,\n-    )\n-}\n-\n-#[test]\n-fn test_file_structure() {\n-    let file = file(r#\"\n-struct Foo {\n-    x: i32\n-}\n-\n-mod m {\n-    fn bar() {}\n-}\n-\n-enum E { X, Y(i32) }\n-type T = ();\n-static S: i32 = 92;\n-const C: i32 = 92;\n-\n-impl E {}\n-\n-impl fmt::Debug for E {}\n-\"#);\n-    let symbols = file_structure(&file);\n-    assert_eq_dbg(\n-        r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },\n-            StructureNode { parent: Some(0), label: \"x\", navigation_range: [18; 19), node_range: [18; 24), kind: NAMED_FIELD_DEF },\n-            StructureNode { parent: None, label: \"m\", navigation_range: [32; 33), node_range: [28; 53), kind: MODULE },\n-            StructureNode { parent: Some(2), label: \"bar\", navigation_range: [43; 46), node_range: [40; 51), kind: FN_DEF },\n-            StructureNode { parent: None, label: \"E\", navigation_range: [60; 61), node_range: [55; 75), kind: ENUM_DEF },\n-            StructureNode { parent: None, label: \"T\", navigation_range: [81; 82), node_range: [76; 88), kind: TYPE_DEF },\n-            StructureNode { parent: None, label: \"S\", navigation_range: [96; 97), node_range: [89; 108), kind: STATIC_DEF },\n-            StructureNode { parent: None, label: \"C\", navigation_range: [115; 116), node_range: [109; 127), kind: CONST_DEF },\n-            StructureNode { parent: None, label: \"impl E\", navigation_range: [134; 135), node_range: [129; 138), kind: IMPL_ITEM },\n-            StructureNode { parent: None, label: \"impl fmt::Debug for E\", navigation_range: [160; 161), node_range: [140; 164), kind: IMPL_ITEM }]\"#,\n-        &symbols,\n-    )\n-}\n-\n-#[test]\n-fn test_swap_comma() {\n-    check_action(\n-        \"fn foo(x: i32,<|> y: Result<(), ()>) {}\",\n-        \"fn foo(y: Result<(), ()>,<|> x: i32) {}\",\n-        |file, off| flip_comma(file, off).map(|f| f()),\n-    )\n-}\n-\n-#[test]\n-fn test_add_derive() {\n-    check_action(\n-        \"struct Foo { a: i32, <|>}\",\n-        \"#[derive(<|>)]\\nstruct Foo { a: i32, }\",\n-        |file, off| add_derive(file, off).map(|f| f()),\n-    );\n-    check_action(\n-        \"struct Foo { <|> a: i32, }\",\n-        \"#[derive(<|>)]\\nstruct Foo {  a: i32, }\",\n-        |file, off| add_derive(file, off).map(|f| f()),\n-    );\n-    check_action(\n-        \"#[derive(Clone)]\\nstruct Foo { a: i32<|>, }\",\n-        \"#[derive(Clone<|>)]\\nstruct Foo { a: i32, }\",\n-        |file, off| add_derive(file, off).map(|f| f()),\n-    );\n-}\n-\n-#[test]\n-fn test_add_impl() {\n-    check_action(\n-        \"struct Foo {<|>}\\n\",\n-        \"struct Foo {}\\n\\nimpl Foo {\\n<|>\\n}\\n\",\n-        |file, off| add_impl(file, off).map(|f| f()),\n-    );\n-    check_action(\n-        \"struct Foo<T: Clone> {<|>}\",\n-        \"struct Foo<T: Clone> {}\\n\\nimpl<T: Clone> Foo<T> {\\n<|>\\n}\",\n-        |file, off| add_impl(file, off).map(|f| f()),\n-    );\n-}\n-\n-#[test]\n-fn test_matching_brace() {\n-    fn do_check(before: &str, after: &str) {\n-        let (pos, before) = extract_offset(before);\n-        let file = file(&before);\n-        let new_pos = match matching_brace(&file, pos) {\n-            None => pos,\n-            Some(pos) => pos,\n-        };\n-        let actual = add_cursor(&before, new_pos);\n-        assert_eq_text!(after, &actual);\n-    }\n-\n-    do_check(\n-        \"struct Foo { a: i32, }<|>\",\n-        \"struct Foo <|>{ a: i32, }\",\n-    );\n-}\n-\n-#[test]\n-fn test_join_lines_cursor() {\n-    fn do_check(before: &str, after: &str) {\n-        check_action(before, after, |file, offset| {\n-            let range = TextRange::offset_len(offset, 0.into());\n-            let res = join_lines(file, range);\n-            Some(res)\n-        })\n-    }\n-\n-    do_check(r\"\n-fn foo() {\n-    <|>foo(1,\n-    )\n-}\n-\", r\"\n-fn foo() {\n-    <|>foo(1)\n-}\n-\");\n-    do_check(r\"\n-pub fn reparse(&self, edit: &AtomEdit) -> File {\n-    <|>self.incremental_reparse(edit).unwrap_or_else(|| {\n-        self.full_reparse(edit)\n-    })\n-}\n-\", r\"\n-pub fn reparse(&self, edit: &AtomEdit) -> File {\n-    <|>self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n-}\n-\");\n-    do_check(r\"\n-fn foo() {\n-    foo(<|>{\n-        92\n-    })\n-}\", r\"\n-fn foo() {\n-    foo(<|>92)\n-}\");\n-}\n-\n-#[test]\n-fn test_join_lines_selection() {\n-    fn do_check(before: &str, after: &str) {\n-        let (sel, before) = extract_range(before);\n-        let file = file(&before);\n-        let result = join_lines(&file, sel);\n-        let actual = result.edit.apply(&before);\n-        assert_eq_text!(after, &actual);\n-    }\n-\n-    do_check(r\"\n-fn foo() {\n-    <|>foo(1,\n-        2,\n-        3,\n-    <|>)\n-}\n-\", r\"\n-fn foo() {\n-    foo(1, 2, 3)\n-}\n-\");\n-\n-    do_check(r\"\n-struct Foo <|>{\n-    f: u32,\n-}<|>\n-\", r\"\n-struct Foo { f: u32 }\n-\");\n-}\n-\n-#[test]\n-fn test_on_eq_typed() {\n-    fn do_check(before: &str, after: &str) {\n-        let (offset, before) = extract_offset(before);\n-        let file = file(&before);\n-        let result = on_eq_typed(&file, offset).unwrap();\n-        let actual = result.edit.apply(&before);\n-        assert_eq_text!(after, &actual);\n-    }\n-\n-//     do_check(r\"\n-// fn foo() {\n-//     let foo =<|>\n-// }\n-// \", r\"\n-// fn foo() {\n-//     let foo =;\n-// }\n-// \");\n-    do_check(r\"\n-fn foo() {\n-    let foo =<|> 1 + 1\n-}\n-\", r\"\n-fn foo() {\n-    let foo = 1 + 1;\n-}\n-\");\n-//     do_check(r\"\n-// fn foo() {\n-//     let foo =<|>\n-//     let bar = 1;\n-// }\n-// \", r\"\n-// fn foo() {\n-//     let foo =;\n-//     let bar = 1;\n-// }\n-// \");\n-\n-}\n-\n-#[test]\n-fn test_completion() {\n-    fn do_check(code: &str, expected_completions: &str) {\n-        let (off, code) = extract_offset(&code);\n-        let file = file(&code);\n-        let completions = scope_completion(&file, off).unwrap();\n-        assert_eq_dbg(expected_completions, &completions);\n-    }\n-\n-    do_check(r\"\n-fn quux(x: i32) {\n-    let y = 92;\n-    1 + <|>;\n-    let z = ();\n-}\n-\", r#\"[CompletionItem { name: \"y\" },\n-       CompletionItem { name: \"x\" }]\"#);\n-\n-    do_check(r\"\n-fn quux() {\n-    if let Some(x) = foo() {\n-        let y = 92;\n-    };\n-    if let Some(a) = bar() {\n-        let b = 62;\n-        1 + <|>\n-    }\n-}\n-\", r#\"[CompletionItem { name: \"b\" },\n-       CompletionItem { name: \"a\" }]\"#);\n-\n-    do_check(r\"\n-fn quux() {\n-    for x in &[1, 2, 3] {\n-        <|>\n-    }\n-}\n-\", r#\"[CompletionItem { name: \"x\" }]\"#);\n-}\n-\n-fn file(text: &str) -> File {\n-    File::parse(text)\n-}\n-\n-fn check_action<F: Fn(&File, TextUnit) -> Option<ActionResult>>(\n-    before: &str,\n-    after: &str,\n-    f: F,\n-) {\n-    let (before_cursor_pos, before) = extract_offset(before);\n-    let file = file(&before);\n-    let result = f(&file, before_cursor_pos).expect(\"code action is not applicable\");\n-    let actual = result.edit.apply(&before);\n-    let actual_cursor_pos = match result.cursor_position {\n-        None => result.edit.apply_to_offset(before_cursor_pos).unwrap(),\n-        Some(off) => off,\n-    };\n-    let actual = add_cursor(&actual, actual_cursor_pos);\n-    assert_eq_text!(after, &actual);\n-}"}]}