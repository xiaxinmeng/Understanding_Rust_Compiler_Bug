{"sha": "34ec9a59423a299a6cd1bedfd4e0a660748f6540", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0ZWM5YTU5NDIzYTI5OWE2Y2QxYmVkZmQ0ZTBhNjYwNzQ4ZjY1NDA=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-01-20T04:44:02Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-02-08T03:28:32Z"}, "message": "Add a query type which is always marked as red if it runs", "tree": {"sha": "b784597e684f1b11818fda7a962ce8b9b118b86f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b784597e684f1b11818fda7a962ce8b9b118b86f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/34ec9a59423a299a6cd1bedfd4e0a660748f6540", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/34ec9a59423a299a6cd1bedfd4e0a660748f6540", "html_url": "https://github.com/rust-lang/rust/commit/34ec9a59423a299a6cd1bedfd4e0a660748f6540", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/34ec9a59423a299a6cd1bedfd4e0a660748f6540/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1731801163df1d3a8d4ddfa68adac2ec833ef7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1731801163df1d3a8d4ddfa68adac2ec833ef7f", "html_url": "https://github.com/rust-lang/rust/commit/d1731801163df1d3a8d4ddfa68adac2ec833ef7f"}], "stats": {"total": 167, "additions": 106, "deletions": 61}, "files": [{"sha": "e8c1cd36064e106874a5f0aca5344d1a7ee45368", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -79,6 +79,16 @@ struct DepGraphData {\n     loaded_from_cache: Lock<FxHashMap<DepNodeIndex, bool>>,\n }\n \n+pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+where\n+    R: for<'a> HashStable<StableHashingContext<'a>>,\n+{\n+    let mut stable_hasher = StableHasher::new();\n+    result.hash_stable(hcx, &mut stable_hasher);\n+\n+    Some(stable_hasher.finish())\n+}\n+\n impl DepGraph {\n \n     pub fn new(prev_graph: PreviousDepGraph,\n@@ -178,14 +188,16 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc guide]: https://rust-lang.github.io/rustc-guide/incremental-compilation.html\n-    pub fn with_task<'gcx, C, A, R>(&self,\n-                                   key: DepNode,\n-                                   cx: C,\n-                                   arg: A,\n-                                   task: fn(C, A) -> R)\n-                                   -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+    pub fn with_task<'a, C, A, R>(\n+        &self,\n+        key: DepNode,\n+        cx: C,\n+        arg: A,\n+        task: fn(C, A) -> R,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_key| Some(TaskDeps {\n@@ -196,17 +208,18 @@ impl DepGraph {\n             }),\n             |data, key, fingerprint, task| {\n                 data.borrow_mut().complete_task(key, task.unwrap(), fingerprint)\n-            })\n+            },\n+            hash_result)\n     }\n \n     /// Creates a new dep-graph input with value `input`\n-    pub fn input_task<'gcx, C, R>(&self,\n+    pub fn input_task<'a, C, R>(&self,\n                                    key: DepNode,\n                                    cx: C,\n                                    input: R)\n                                    -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+        where C: DepGraphSafe + StableHashingContextProvider<'a>,\n+              R: for<'b> HashStable<StableHashingContext<'b>>,\n     {\n         fn identity_fn<C, A>(_: C, arg: A) -> A {\n             arg\n@@ -216,10 +229,11 @@ impl DepGraph {\n             |_| None,\n             |data, key, fingerprint, _| {\n                 data.borrow_mut().alloc_node(key, SmallVec::new(), fingerprint)\n-            })\n+            },\n+            hash_result::<R>)\n     }\n \n-    fn with_task_impl<'gcx, C, A, R>(\n+    fn with_task_impl<'a, C, A, R>(\n         &self,\n         key: DepNode,\n         cx: C,\n@@ -230,11 +244,11 @@ impl DepGraph {\n         finish_task_and_alloc_depnode: fn(&Lock<CurrentDepGraph>,\n                                           DepNode,\n                                           Fingerprint,\n-                                          Option<TaskDeps>) -> DepNodeIndex\n+                                          Option<TaskDeps>) -> DepNodeIndex,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-        R: HashStable<StableHashingContext<'gcx>>,\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(|deps| Lock::new(deps));\n@@ -269,31 +283,33 @@ impl DepGraph {\n                 profq_msg(hcx.sess(), ProfileQueriesMsg::TaskEnd)\n             };\n \n-            let mut stable_hasher = StableHasher::new();\n-            result.hash_stable(&mut hcx, &mut stable_hasher);\n-\n-            let current_fingerprint = stable_hasher.finish();\n+            let current_fingerprint = hash_result(&mut hcx, &result);\n \n             let dep_node_index = finish_task_and_alloc_depnode(\n                 &data.current,\n                 key,\n-                current_fingerprint,\n+                current_fingerprint.unwrap_or(Fingerprint::ZERO),\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n                 let prev_fingerprint = data.previous.fingerprint_by_index(prev_index);\n \n-                let color = if current_fingerprint == prev_fingerprint {\n-                    DepNodeColor::Green(dep_node_index)\n+                let color = if let Some(current_fingerprint) = current_fingerprint {\n+                    if current_fingerprint == prev_fingerprint {\n+                        DepNodeColor::Green(dep_node_index)\n+                    } else {\n+                        DepNodeColor::Red\n+                    }\n                 } else {\n+                    // Mark the node as Red if we can't hash the result\n                     DepNodeColor::Red\n                 };\n \n                 debug_assert!(data.colors.get(prev_index).is_none(),\n-                              \"DepGraph::with_task() - Duplicate DepNodeColor \\\n-                               insertion for {:?}\", key);\n+                            \"DepGraph::with_task() - Duplicate DepNodeColor \\\n+                            insertion for {:?}\", key);\n \n                 data.colors.insert(prev_index, color);\n             }\n@@ -342,14 +358,16 @@ impl DepGraph {\n \n     /// Execute something within an \"eval-always\" task which is a task\n     // that runs whenever anything changes.\n-    pub fn with_eval_always_task<'gcx, C, A, R>(&self,\n-                                   key: DepNode,\n-                                   cx: C,\n-                                   arg: A,\n-                                   task: fn(C, A) -> R)\n-                                   -> (R, DepNodeIndex)\n-        where C: DepGraphSafe + StableHashingContextProvider<'gcx>,\n-              R: HashStable<StableHashingContext<'gcx>>,\n+    pub fn with_eval_always_task<'a, C, A, R>(\n+        &self,\n+        key: DepNode,\n+        cx: C,\n+        arg: A,\n+        task: fn(C, A) -> R,\n+        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+    ) -> (R, DepNodeIndex)\n+    where\n+        C: DepGraphSafe + StableHashingContextProvider<'a>,\n     {\n         self.with_task_impl(key, cx, arg, false, task,\n             |_| None,\n@@ -359,7 +377,8 @@ impl DepGraph {\n                     &DepNode::new_no_params(DepKind::Krate)\n                 ];\n                 current.alloc_node(key, smallvec![krate_idx], fingerprint)\n-            })\n+            },\n+            hash_result)\n     }\n \n     #[inline]"}, {"sha": "b84d2ad145889bf1fab96fc39d908e98c508a874", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -10,7 +10,7 @@ pub mod cgu_reuse_tracker;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::{DepNode, DepKind, DepConstructor, WorkProductId, label_strs};\n-pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps};\n+pub use self::graph::{DepGraph, WorkProduct, DepNodeIndex, DepNodeColor, TaskDeps, hash_result};\n pub use self::graph::WorkProductFileKind;\n pub use self::prev::PreviousDepGraph;\n pub use self::query::DepGraphQuery;"}, {"sha": "37552f18f4a08112582e146ac9ede7d4d78a50a6", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -48,14 +48,14 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     hir_body_nodes: Vec<(DefPathHash, Fingerprint)>,\n }\n \n-fn input_dep_node_and_hash<'a, I>(\n+fn input_dep_node_and_hash<I>(\n     dep_graph: &DepGraph,\n-    hcx: &mut StableHashingContext<'a>,\n+    hcx: &mut StableHashingContext<'_>,\n     dep_node: DepNode,\n     input: I,\n ) -> (DepNodeIndex, Fingerprint)\n where\n-    I: HashStable<StableHashingContext<'a>>,\n+    I: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let dep_node_index = dep_graph.input_task(dep_node, &mut *hcx, &input).1;\n \n@@ -70,15 +70,15 @@ where\n     (dep_node_index, hash)\n }\n \n-fn alloc_hir_dep_nodes<'a, I>(\n+fn alloc_hir_dep_nodes<I>(\n     dep_graph: &DepGraph,\n-    hcx: &mut StableHashingContext<'a>,\n+    hcx: &mut StableHashingContext<'_>,\n     def_path_hash: DefPathHash,\n     item_like: I,\n     hir_body_nodes: &mut Vec<(DefPathHash, Fingerprint)>,\n ) -> (DepNodeIndex, DepNodeIndex)\n where\n-    I: HashStable<StableHashingContext<'a>>,\n+    I: for<'a> HashStable<StableHashingContext<'a>>,\n {\n     let sig = dep_graph.input_task(\n         def_path_hash.to_dep_node(DepKind::Hir),\n@@ -286,7 +286,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<T: HashStable<StableHashingContext<'a>>,\n+    fn with_dep_node_owner<T: for<'b> HashStable<StableHashingContext<'b>>,\n                            F: FnOnce(&mut Self)>(&mut self,\n                                                  dep_node_owner: DefIndex,\n                                                  item_like: &T,"}, {"sha": "795853a37c7583d1d44b2f6a6f4bab2b8752816e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -1,7 +1,7 @@\n //! type context book-keeping\n \n use crate::dep_graph::DepGraph;\n-use crate::dep_graph::{DepNode, DepConstructor};\n+use crate::dep_graph::{self, DepNode, DepConstructor};\n use crate::errors::DiagnosticBuilder;\n use crate::session::Session;\n use crate::session::config::{BorrowckMode, OutputFilenames};\n@@ -1435,7 +1435,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.dep_graph.with_task(dep_node,\n                                      self,\n                                      crate_hash,\n-                                     |_, x| x // No transformation needed\n+                                     |_, x| x, // No transformation needed\n+                                     dep_graph::hash_result,\n             );\n         }\n     }"}, {"sha": "a3ee92f8e126361debf5c7e40cd2f5a6b77a544d", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -20,7 +20,7 @@ use std::hash::Hash;\n use std::fmt::Debug;\n use syntax_pos::symbol::InternedString;\n use rustc_data_structures::sync::Lock;\n-use rustc_data_structures::stable_hasher::HashStable;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use crate::ich::StableHashingContext;\n \n // Query configuration and description traits.\n@@ -30,7 +30,7 @@ pub trait QueryConfig<'tcx> {\n     const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n-    type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;\n+    type Value: Clone;\n }\n \n pub(super) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n@@ -44,6 +44,11 @@ pub(super) trait QueryAccessors<'tcx>: QueryConfig<'tcx> {\n     // Don't use this method to compute query results, instead use the methods on TyCtxt\n     fn compute(tcx: TyCtxt<'_, 'tcx, '_>, key: Self::Key) -> Self::Value;\n \n+    fn hash_result(\n+        hcx: &mut StableHashingContext<'_>,\n+        result: &Self::Value\n+    ) -> Option<Fingerprint>;\n+\n     fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value;\n }\n "}, {"sha": "8211dc50fc6e096602a19f6a853cc7e32a71b066", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -1,4 +1,4 @@\n-use crate::dep_graph::{DepConstructor, DepNode};\n+use crate::dep_graph::{self, DepConstructor, DepNode};\n use crate::errors::DiagnosticBuilder;\n use crate::hir::def_id::{CrateNum, DefId, DefIndex};\n use crate::hir::def::{Def, Export};\n@@ -49,6 +49,7 @@ use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_target::spec::PanicStrategy;\n \n use std::borrow::Cow;\n@@ -227,19 +228,19 @@ define_queries! { <'tcx>\n \n         /// Fetch the MIR for a given def-id right after it's built - this includes\n         /// unreachable code.\n-        [] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+        [no_hash] fn mir_built: MirBuilt(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n         /// Fetch the MIR for a given def-id up till the point where it is\n         /// ready for const evaluation.\n         ///\n         /// See the README for the `mir` module for details.\n-        [] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+        [no_hash] fn mir_const: MirConst(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n-        [] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n+        [no_hash] fn mir_validated: MirValidated(DefId) -> &'tcx Steal<mir::Mir<'tcx>>,\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n         /// for codegen. This is also the only query that can fetch non-local MIR, at present.\n-        [] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n+        [no_hash] fn optimized_mir: MirOptimized(DefId) -> &'tcx mir::Mir<'tcx>,\n     },\n \n     TypeChecking {\n@@ -282,7 +283,7 @@ define_queries! { <'tcx>\n     TypeChecking {\n         [] fn typeck_item_bodies: typeck_item_bodies_dep_node(CrateNum) -> CompileResult,\n \n-        [] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n+        [no_hash] fn typeck_tables_of: TypeckTables(DefId) -> &'tcx ty::TypeckTables<'tcx>,\n     },\n \n     Other {"}, {"sha": "3dcb939d63606c64b0733c6148394fb9eb4b0e27", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -499,7 +499,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         dep_node: &DepNode,\n         dep_node_index: DepNodeIndex,\n     ) {\n-        use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n         use crate::ich::Fingerprint;\n \n         assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n@@ -509,11 +508,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"BEGIN verify_ich({:?})\", dep_node);\n         let mut hcx = self.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n \n-        result.hash_stable(&mut hcx, &mut hasher);\n-\n-        let new_hash: Fingerprint = hasher.finish();\n+        let new_hash = Q::hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n         debug!(\"END verify_ich({:?})\", dep_node);\n \n         let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n@@ -549,12 +545,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     tcx.dep_graph.with_eval_always_task(dep_node,\n                                                         tcx,\n                                                         key,\n-                                                        Q::compute)\n+                                                        Q::compute,\n+                                                        Q::hash_result)\n                 } else {\n                     tcx.dep_graph.with_task(dep_node,\n                                             tcx,\n                                             key,\n-                                            Q::compute)\n+                                            Q::compute,\n+                                            Q::hash_result)\n                 }\n             })\n         });\n@@ -679,6 +677,18 @@ macro_rules! handle_cycle_error {\n     };\n }\n \n+macro_rules! hash_result {\n+    ([][$hcx:expr, $result:expr]) => {{\n+        dep_graph::hash_result($hcx, &$result)\n+    }};\n+    ([no_hash$(, $modifiers:ident)*][$hcx:expr, $result:expr]) => {{\n+        None\n+    }};\n+    ([$other:ident$(, $modifiers:ident)*][$($args:tt)*]) => {\n+        hash_result!([$($modifiers),*][$($args)*])\n+    };\n+}\n+\n macro_rules! define_queries {\n     (<$tcx:tt> $($category:tt {\n         $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n@@ -966,6 +976,13 @@ macro_rules! define_queries_inner {\n                 })\n             }\n \n+            fn hash_result(\n+                _hcx: &mut StableHashingContext<'_>,\n+                _result: &Self::Value\n+            ) -> Option<Fingerprint> {\n+                hash_result!([$($modifiers)*][_hcx, _result])\n+            }\n+\n             fn handle_cycle_error(tcx: TyCtxt<'_, 'tcx, '_>) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx])\n             }"}, {"sha": "d9f44ca6e45a3b973f966b80f09b6a51b9e6934b", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/34ec9a59423a299a6cd1bedfd4e0a660748f6540/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=34ec9a59423a299a6cd1bedfd4e0a660748f6540", "patch": "@@ -20,6 +20,7 @@ use super::LlvmCodegenBackend;\n \n use llvm;\n use metadata;\n+use rustc::dep_graph;\n use rustc::mir::mono::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata};\n use rustc::ty::TyCtxt;\n@@ -145,7 +146,8 @@ pub fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let ((stats, module), _) = tcx.dep_graph.with_task(dep_node,\n                                                        tcx,\n                                                        cgu_name,\n-                                                       module_codegen);\n+                                                       module_codegen,\n+                                                       dep_graph::hash_result);\n     let time_to_codegen = start_time.elapsed();\n \n     // We assume that the cost to run LLVM on a CGU is proportional to"}]}