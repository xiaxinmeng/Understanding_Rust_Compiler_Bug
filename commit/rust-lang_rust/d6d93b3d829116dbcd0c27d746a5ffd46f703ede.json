{"sha": "d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZDkzYjNkODI5MTE2ZGJjZDBjMjdkNzQ2YTVmZmQ0NmY3MDNlZGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T18:32:29Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-11T18:32:29Z"}, "message": "parser: move into stmt.rs", "tree": {"sha": "02891445ee5b581367de1f67dfcefc1452e6a06d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02891445ee5b581367de1f67dfcefc1452e6a06d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "html_url": "https://github.com/rust-lang/rust/commit/d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "28db7c5968ea15ad2c26d9267ab722994ae371c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/28db7c5968ea15ad2c26d9267ab722994ae371c0", "html_url": "https://github.com/rust-lang/rust/commit/28db7c5968ea15ad2c26d9267ab722994ae371c0"}], "stats": {"total": 941, "additions": 477, "deletions": 464}, "files": [{"sha": "182941406ab8b8995e041cbe3c5e39482f196b6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 9, "deletions": 458, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "patch": "@@ -1,5 +1,4 @@\n mod expr;\n-use expr::LhsExpr;\n mod pat;\n mod item;\n pub use item::AliasKind;\n@@ -8,23 +7,15 @@ pub use module::{ModulePath, ModulePathSuccess};\n mod ty;\n mod path;\n pub use path::PathStyle;\n+mod stmt;\n \n-use crate::ast::{self, AttrStyle};\n-use crate::ast::{Arg, Attribute, BindingMode};\n-use crate::ast::{Block, BlockCheckMode, Expr, ExprKind, Stmt, StmtKind};\n-use crate::ast::{FnDecl};\n-use crate::ast::{Ident, IsAsync, Local, Lifetime};\n-use crate::ast::{MacStmtStyle, Mac_, MacDelimiter};\n-use crate::ast::{Mutability};\n-use crate::ast::StrStyle;\n-use crate::ast::SelfKind;\n-use crate::ast::{GenericParam, GenericParamKind, WhereClause};\n-use crate::ast::{TyKind,  GenericBounds};\n+use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n+use crate::ast::{FnDecl, Ident, IsAsync, Lifetime, MacDelimiter, Mutability};\n+use crate::ast::{GenericParam, GenericParamKind, WhereClause, TyKind,  GenericBounds};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n-use crate::ext::base::DummyResult;\n use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, respan};\n-use crate::parse::{SeqSep, classify, literal, token};\n+use crate::parse::{SeqSep, literal, token};\n use crate::parse::lexer::UnmatchedBrace;\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::{Token, TokenKind, DelimToken};\n@@ -1214,450 +1205,6 @@ impl<'a> Parser<'a> {\n \n     }\n \n-    /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n-    fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n-        if self.eat(&token::Eq) {\n-            Ok(Some(self.parse_expr()?))\n-        } else if skip_eq {\n-            Ok(Some(self.parse_expr()?))\n-        } else {\n-            Ok(None)\n-        }\n-    }\n-\n-    /// Parses a local variable declaration.\n-    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n-        let lo = self.prev_span;\n-        let pat = self.parse_top_level_pat()?;\n-\n-        let (err, ty) = if self.eat(&token::Colon) {\n-            // Save the state of the parser before parsing type normally, in case there is a `:`\n-            // instead of an `=` typo.\n-            let parser_snapshot_before_type = self.clone();\n-            let colon_sp = self.prev_span;\n-            match self.parse_ty() {\n-                Ok(ty) => (None, Some(ty)),\n-                Err(mut err) => {\n-                    // Rewind to before attempting to parse the type and continue parsing\n-                    let parser_snapshot_after_type = self.clone();\n-                    mem::replace(self, parser_snapshot_before_type);\n-\n-                    let snippet = self.span_to_snippet(pat.span).unwrap();\n-                    err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n-                    (Some((parser_snapshot_after_type, colon_sp, err)), None)\n-                }\n-            }\n-        } else {\n-            (None, None)\n-        };\n-        let init = match (self.parse_initializer(err.is_some()), err) {\n-            (Ok(init), None) => {  // init parsed, ty parsed\n-                init\n-            }\n-            (Ok(init), Some((_, colon_sp, mut err))) => {  // init parsed, ty error\n-                // Could parse the type as if it were the initializer, it is likely there was a\n-                // typo in the code: `:` instead of `=`. Add suggestion and emit the error.\n-                err.span_suggestion_short(\n-                    colon_sp,\n-                    \"use `=` if you meant to assign\",\n-                    \"=\".to_string(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n-                // As this was parsed successfully, continue as if the code has been fixed for the\n-                // rest of the file. It will still fail due to the emitted error, but we avoid\n-                // extra noise.\n-                init\n-            }\n-            (Err(mut init_err), Some((snapshot, _, ty_err))) => {  // init error, ty error\n-                init_err.cancel();\n-                // Couldn't parse the type nor the initializer, only raise the type error and\n-                // return to the parser state before parsing the type as the initializer.\n-                // let x: <parse_error>;\n-                mem::replace(self, snapshot);\n-                return Err(ty_err);\n-            }\n-            (Err(err), None) => {  // init error, ty parsed\n-                // Couldn't parse the initializer and we're not attempting to recover a failed\n-                // parse of the type, return the error.\n-                return Err(err);\n-            }\n-        };\n-        let hi = if self.token == token::Semi {\n-            self.token.span\n-        } else {\n-            self.prev_span\n-        };\n-        Ok(P(ast::Local {\n-            ty,\n-            pat,\n-            init,\n-            id: ast::DUMMY_NODE_ID,\n-            span: lo.to(hi),\n-            attrs,\n-        }))\n-    }\n-\n-    /// Parse a statement. This stops just before trailing semicolons on everything but items.\n-    /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(self.parse_stmt_(true))\n-    }\n-\n-    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n-            e.emit();\n-            self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n-            None\n-        })\n-    }\n-\n-    fn is_async_fn(&self) -> bool {\n-        self.token.is_keyword(kw::Async) &&\n-            self.is_keyword_ahead(1, &[kw::Fn])\n-    }\n-\n-    fn is_crate_vis(&self) -> bool {\n-        self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n-    }\n-\n-    fn is_auto_trait_item(&self) -> bool {\n-        // auto trait\n-        (self.token.is_keyword(kw::Auto) &&\n-            self.is_keyword_ahead(1, &[kw::Trait]))\n-        || // unsafe auto trait\n-        (self.token.is_keyword(kw::Unsafe) &&\n-         self.is_keyword_ahead(1, &[kw::Auto]) &&\n-         self.is_keyword_ahead(2, &[kw::Trait]))\n-    }\n-\n-    fn parse_stmt_without_recovery(\n-        &mut self,\n-        macro_legacy_warnings: bool,\n-    ) -> PResult<'a, Option<Stmt>> {\n-        maybe_whole!(self, NtStmt, |x| Some(x));\n-\n-        let attrs = self.parse_outer_attributes()?;\n-        let lo = self.token.span;\n-\n-        Ok(Some(if self.eat_keyword(kw::Let) {\n-            Stmt {\n-                id: ast::DUMMY_NODE_ID,\n-                node: StmtKind::Local(self.parse_local(attrs.into())?),\n-                span: lo.to(self.prev_span),\n-            }\n-        } else if let Some(macro_def) = self.eat_macro_def(\n-            &attrs,\n-            &source_map::respan(lo, VisibilityKind::Inherited),\n-            lo,\n-        )? {\n-            Stmt {\n-                id: ast::DUMMY_NODE_ID,\n-                node: StmtKind::Item(macro_def),\n-                span: lo.to(self.prev_span),\n-            }\n-        // Starts like a simple path, being careful to avoid contextual keywords\n-        // such as a union items, item with `crate` visibility or auto trait items.\n-        // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n-        // like a path (1 token), but it fact not a path.\n-        // `union::b::c` - path, `union U { ... }` - not a path.\n-        // `crate::b::c` - path, `crate struct S;` - not a path.\n-        } else if self.token.is_path_start() &&\n-                  !self.token.is_qpath_start() &&\n-                  !self.is_union_item() &&\n-                  !self.is_crate_vis() &&\n-                  !self.is_auto_trait_item() &&\n-                  !self.is_async_fn() {\n-            let path = self.parse_path(PathStyle::Expr)?;\n-\n-            if !self.eat(&token::Not) {\n-                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n-                    self.parse_struct_expr(lo, path, ThinVec::new())?\n-                } else {\n-                    let hi = self.prev_span;\n-                    self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n-                };\n-\n-                let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n-                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n-                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n-                })?;\n-\n-                return Ok(Some(Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Expr(expr),\n-                    span: lo.to(self.prev_span),\n-                }));\n-            }\n-\n-            let (delim, tts) = self.expect_delimited_token_tree()?;\n-            let hi = self.prev_span;\n-\n-            let style = if delim == MacDelimiter::Brace {\n-                MacStmtStyle::Braces\n-            } else {\n-                MacStmtStyle::NoBraces\n-            };\n-\n-            let mac = respan(lo.to(hi), Mac_ {\n-                path,\n-                tts,\n-                delim,\n-                prior_type_ascription: self.last_type_ascription,\n-            });\n-            let node = if delim == MacDelimiter::Brace ||\n-                          self.token == token::Semi || self.token == token::Eof {\n-                StmtKind::Mac(P((mac, style, attrs.into())))\n-            }\n-            // We used to incorrectly stop parsing macro-expanded statements here.\n-            // If the next token will be an error anyway but could have parsed with the\n-            // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-            else if macro_legacy_warnings &&\n-                    self.token.can_begin_expr() &&\n-                    match self.token.kind {\n-                // These can continue an expression, so we can't stop parsing and warn.\n-                token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n-                token::BinOp(token::Minus) | token::BinOp(token::Star) |\n-                token::BinOp(token::And) | token::BinOp(token::Or) |\n-                token::AndAnd | token::OrOr |\n-                token::DotDot | token::DotDotDot | token::DotDotEq => false,\n-                _ => true,\n-            } {\n-                self.warn_missing_semicolon();\n-                StmtKind::Mac(P((mac, style, attrs.into())))\n-            } else {\n-                let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n-                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n-                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                StmtKind::Expr(e)\n-            };\n-            Stmt {\n-                id: ast::DUMMY_NODE_ID,\n-                span: lo.to(hi),\n-                node,\n-            }\n-        } else {\n-            // FIXME: Bad copy of attrs\n-            let old_directory_ownership =\n-                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n-            let item = self.parse_item_(attrs.clone(), false, true)?;\n-            self.directory.ownership = old_directory_ownership;\n-\n-            match item {\n-                Some(i) => Stmt {\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: lo.to(i.span),\n-                    node: StmtKind::Item(i),\n-                },\n-                None => {\n-                    let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n-                        if !attrs.is_empty() {\n-                            if s.prev_token_kind == PrevTokenKind::DocComment {\n-                                s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n-                            } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n-                                s.span_err(\n-                                    s.token.span, \"expected statement after outer attribute\"\n-                                );\n-                            }\n-                        }\n-                    };\n-\n-                    // Do not attempt to parse an expression if we're done here.\n-                    if self.token == token::Semi {\n-                        unused_attrs(&attrs, self);\n-                        self.bump();\n-                        return Ok(None);\n-                    }\n-\n-                    if self.token == token::CloseDelim(token::Brace) {\n-                        unused_attrs(&attrs, self);\n-                        return Ok(None);\n-                    }\n-\n-                    // Remainder are line-expr stmts.\n-                    let e = self.parse_expr_res(\n-                        Restrictions::STMT_EXPR, Some(attrs.into()))?;\n-                    Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        span: lo.to(e.span),\n-                        node: StmtKind::Expr(e),\n-                    }\n-                }\n-            }\n-        }))\n-    }\n-\n-    /// Parses a block. No inner attributes are allowed.\n-    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n-        maybe_whole!(self, NtBlock, |x| x);\n-\n-        let lo = self.token.span;\n-\n-        if !self.eat(&token::OpenDelim(token::Brace)) {\n-            let sp = self.token.span;\n-            let tok = self.this_token_descr();\n-            let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n-            let do_not_suggest_help =\n-                self.token.is_keyword(kw::In) || self.token == token::Colon;\n-\n-            if self.token.is_ident_named(sym::and) {\n-                e.span_suggestion_short(\n-                    self.token.span,\n-                    \"use `&&` instead of `and` for the boolean operator\",\n-                    \"&&\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            if self.token.is_ident_named(sym::or) {\n-                e.span_suggestion_short(\n-                    self.token.span,\n-                    \"use `||` instead of `or` for the boolean operator\",\n-                    \"||\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-\n-            // Check to see if the user has written something like\n-            //\n-            //    if (cond)\n-            //      bar;\n-            //\n-            // Which is valid in other languages, but not Rust.\n-            match self.parse_stmt_without_recovery(false) {\n-                Ok(Some(stmt)) => {\n-                    if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n-                        || do_not_suggest_help {\n-                        // if the next token is an open brace (e.g., `if a b {`), the place-\n-                        // inside-a-block suggestion would be more likely wrong than right\n-                        e.span_label(sp, \"expected `{`\");\n-                        return Err(e);\n-                    }\n-                    let mut stmt_span = stmt.span;\n-                    // expand the span to include the semicolon, if it exists\n-                    if self.eat(&token::Semi) {\n-                        stmt_span = stmt_span.with_hi(self.prev_span.hi());\n-                    }\n-                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n-                        e.span_suggestion(\n-                            stmt_span,\n-                            \"try placing this code inside a block\",\n-                            format!(\"{{ {} }}\", snippet),\n-                            // speculative, has been misleading in the past (#46836)\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-                Err(mut e) => {\n-                    self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n-                    self.cancel(&mut e);\n-                }\n-                _ => ()\n-            }\n-            e.span_label(sp, \"expected `{`\");\n-            return Err(e);\n-        }\n-\n-        self.parse_block_tail(lo, BlockCheckMode::Default)\n-    }\n-\n-    /// Parses a block. Inner attributes are allowed.\n-    crate fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n-        maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n-\n-        let lo = self.token.span;\n-        self.expect(&token::OpenDelim(token::Brace))?;\n-        Ok((self.parse_inner_attributes()?,\n-            self.parse_block_tail(lo, BlockCheckMode::Default)?))\n-    }\n-\n-    /// Parses the rest of a block expression or function body.\n-    /// Precondition: already parsed the '{'.\n-    fn parse_block_tail(&mut self, lo: Span, s: BlockCheckMode) -> PResult<'a, P<Block>> {\n-        let mut stmts = vec![];\n-        while !self.eat(&token::CloseDelim(token::Brace)) {\n-            if self.token == token::Eof {\n-                break;\n-            }\n-            let stmt = match self.parse_full_stmt(false) {\n-                Err(mut err) => {\n-                    err.emit();\n-                    self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n-                    Some(Stmt {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: StmtKind::Expr(DummyResult::raw_expr(self.token.span, true)),\n-                        span: self.token.span,\n-                    })\n-                }\n-                Ok(stmt) => stmt,\n-            };\n-            if let Some(stmt) = stmt {\n-                stmts.push(stmt);\n-            } else {\n-                // Found only `;` or `}`.\n-                continue;\n-            };\n-        }\n-        Ok(P(ast::Block {\n-            stmts,\n-            id: ast::DUMMY_NODE_ID,\n-            rules: s,\n-            span: lo.to(self.prev_span),\n-        }))\n-    }\n-\n-    /// Parses a statement, including the trailing semicolon.\n-    crate fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n-        // skip looking for a trailing semicolon when we have an interpolated statement\n-        maybe_whole!(self, NtStmt, |x| Some(x));\n-\n-        let mut stmt = match self.parse_stmt_without_recovery(macro_legacy_warnings)? {\n-            Some(stmt) => stmt,\n-            None => return Ok(None),\n-        };\n-\n-        match stmt.node {\n-            StmtKind::Expr(ref expr) if self.token != token::Eof => {\n-                // expression without semicolon\n-                if classify::expr_requires_semi_to_be_stmt(expr) {\n-                    // Just check for errors and recover; do not eat semicolon yet.\n-                    if let Err(mut e) =\n-                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n-                    {\n-                        e.emit();\n-                        self.recover_stmt();\n-                        // Don't complain about type errors in body tail after parse error (#57383).\n-                        let sp = expr.span.to(self.prev_span);\n-                        stmt.node = StmtKind::Expr(DummyResult::raw_expr(sp, true));\n-                    }\n-                }\n-            }\n-            StmtKind::Local(..) => {\n-                // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n-                if macro_legacy_warnings && self.token != token::Semi {\n-                    self.warn_missing_semicolon();\n-                } else {\n-                    self.expect_one_of(&[], &[token::Semi])?;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        if self.eat(&token::Semi) {\n-            stmt = stmt.add_trailing_semicolon();\n-        }\n-        stmt.span = stmt.span.to(self.prev_span);\n-        Ok(Some(stmt))\n-    }\n-\n-    fn warn_missing_semicolon(&self) {\n-        self.diagnostic().struct_span_warn(self.token.span, {\n-            &format!(\"expected `;`, found {}\", self.this_token_descr())\n-        }).note({\n-            \"This was erroneously allowed and will become a hard error in a future release\"\n-        }).emit();\n-    }\n-\n     /// Parses bounds of a lifetime parameter `BOUND + BOUND + BOUND`, possibly with trailing `+`.\n     ///\n     /// ```\n@@ -2149,6 +1696,10 @@ impl<'a> Parser<'a> {\n             self.is_keyword_ahead(1, &[kw::Const]))\n     }\n \n+    fn is_crate_vis(&self) -> bool {\n+        self.token.is_keyword(kw::Crate) && self.look_ahead(1, |t| t != &token::ModSep)\n+    }\n+\n     /// Parses `pub`, `pub(crate)` and `pub(in path)` plus shortcuts `crate` for `pub(crate)`,\n     /// `pub(self)` for `pub(in self)` and `pub(super)` for `pub(in super)`.\n     /// If the following element can't be a tuple (i.e., it's a function definition), then"}, {"sha": "4432c1329cbfeb9aa4bdc8d1309a2b53f22bed54", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "patch": "@@ -1,11 +1,10 @@\n use super::{Parser, PResult, Restrictions, PrevTokenKind, TokenType, PathStyle};\n-use super::{BlockCheckMode, BlockMode, SemiColonMode};\n+use super::{BlockMode, SemiColonMode};\n use super::{SeqSep, TokenExpectType};\n \n use crate::maybe_recover_from_interpolated_ty_qpath;\n use crate::ptr::P;\n-use crate::ast::{self, Attribute, AttrStyle};\n-use crate::ast::{Ident, CaptureBy};\n+use crate::ast::{self, Attribute, AttrStyle, Ident, CaptureBy, BlockCheckMode};\n use crate::ast::{Expr, ExprKind, RangeLimits, Label, Movability, IsAsync, Arm};\n use crate::ast::{Ty, TyKind, FunctionRetTy, Arg, FnDecl};\n use crate::ast::{BinOpKind, BinOp, UnOp};"}, {"sha": "e85ef9cc974194f0a1576f4f01f3038442a9dd24", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "patch": "@@ -569,6 +569,11 @@ impl<'a> Parser<'a> {\n         Err(err)\n     }\n \n+    pub(super) fn is_async_fn(&self) -> bool {\n+        self.token.is_keyword(kw::Async) &&\n+            self.is_keyword_ahead(1, &[kw::Fn])\n+    }\n+\n     /// Parses a macro invocation inside a `trait`, `impl` or `extern` block.\n     fn parse_assoc_macro_invoc(&mut self, item_kind: &str, vis: Option<&Visibility>,\n                                at_end: &mut bool) -> PResult<'a, Option<Mac>>"}, {"sha": "3eb4d45045a9e00b32338d7f8050410d909b1236", "filename": "src/libsyntax/parse/parser/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpath.rs?ref=d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "patch": "@@ -1,11 +1,11 @@\n-use super::{Parser, PResult, TokenType, BlockCheckMode};\n+use super::{Parser, PResult, TokenType};\n \n use crate::{maybe_whole, ThinVec};\n use crate::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n-use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind};\n+use crate::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n use crate::parse::token::{self, Token};\n use crate::source_map::{Span, BytePos};\n-use crate::symbol::{kw};\n+use crate::symbol::kw;\n \n use std::mem;\n use log::debug;"}, {"sha": "f182edcbff4372e40cad2383f943db1bd7bf75b1", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d93b3d829116dbcd0c27d746a5ffd46f703ede/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=d6d93b3d829116dbcd0c27d746a5ffd46f703ede", "patch": "@@ -0,0 +1,458 @@\n+use super::{Parser, PResult, Restrictions, PrevTokenKind, SemiColonMode, BlockMode};\n+use super::expr::LhsExpr;\n+use super::path::PathStyle;\n+\n+use crate::ptr::P;\n+use crate::{maybe_whole, ThinVec};\n+use crate::ast::{self, Stmt, StmtKind, Local, Block, BlockCheckMode, Expr, ExprKind};\n+use crate::ast::{Attribute, AttrStyle, VisibilityKind, MacStmtStyle, Mac_, MacDelimiter};\n+use crate::ext::base::DummyResult;\n+use crate::parse::{classify, DirectoryOwnership};\n+use crate::parse::diagnostics::Error;\n+use crate::parse::token::{self};\n+use crate::source_map::{respan, Span};\n+use crate::symbol::{kw, sym};\n+\n+use std::mem;\n+use errors::Applicability;\n+\n+impl<'a> Parser<'a> {\n+    /// Parse a statement. This stops just before trailing semicolons on everything but items.\n+    /// e.g., a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n+    pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n+        Ok(self.parse_stmt_(true))\n+    }\n+\n+    fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n+            None\n+        })\n+    }\n+\n+    fn parse_stmt_without_recovery(\n+        &mut self,\n+        macro_legacy_warnings: bool,\n+    ) -> PResult<'a, Option<Stmt>> {\n+        maybe_whole!(self, NtStmt, |x| Some(x));\n+\n+        let attrs = self.parse_outer_attributes()?;\n+        let lo = self.token.span;\n+\n+        Ok(Some(if self.eat_keyword(kw::Let) {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Local(self.parse_local(attrs.into())?),\n+                span: lo.to(self.prev_span),\n+            }\n+        } else if let Some(macro_def) = self.eat_macro_def(\n+            &attrs,\n+            &respan(lo, VisibilityKind::Inherited),\n+            lo,\n+        )? {\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                node: StmtKind::Item(macro_def),\n+                span: lo.to(self.prev_span),\n+            }\n+        // Starts like a simple path, being careful to avoid contextual keywords\n+        // such as a union items, item with `crate` visibility or auto trait items.\n+        // Our goal here is to parse an arbitrary path `a::b::c` but not something that starts\n+        // like a path (1 token), but it fact not a path.\n+        // `union::b::c` - path, `union U { ... }` - not a path.\n+        // `crate::b::c` - path, `crate struct S;` - not a path.\n+        } else if self.token.is_path_start() &&\n+                  !self.token.is_qpath_start() &&\n+                  !self.is_union_item() &&\n+                  !self.is_crate_vis() &&\n+                  !self.is_auto_trait_item() &&\n+                  !self.is_async_fn() {\n+            let path = self.parse_path(PathStyle::Expr)?;\n+\n+            if !self.eat(&token::Not) {\n+                let expr = if self.check(&token::OpenDelim(token::Brace)) {\n+                    self.parse_struct_expr(lo, path, ThinVec::new())?\n+                } else {\n+                    let hi = self.prev_span;\n+                    self.mk_expr(lo.to(hi), ExprKind::Path(None, path), ThinVec::new())\n+                };\n+\n+                let expr = self.with_res(Restrictions::STMT_EXPR, |this| {\n+                    let expr = this.parse_dot_or_call_expr_with(expr, lo, attrs.into())?;\n+                    this.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(expr))\n+                })?;\n+\n+                return Ok(Some(Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: StmtKind::Expr(expr),\n+                    span: lo.to(self.prev_span),\n+                }));\n+            }\n+\n+            let (delim, tts) = self.expect_delimited_token_tree()?;\n+            let hi = self.prev_span;\n+\n+            let style = if delim == MacDelimiter::Brace {\n+                MacStmtStyle::Braces\n+            } else {\n+                MacStmtStyle::NoBraces\n+            };\n+\n+            let mac = respan(lo.to(hi), Mac_ {\n+                path,\n+                tts,\n+                delim,\n+                prior_type_ascription: self.last_type_ascription,\n+            });\n+            let node = if delim == MacDelimiter::Brace ||\n+                          self.token == token::Semi || self.token == token::Eof {\n+                StmtKind::Mac(P((mac, style, attrs.into())))\n+            }\n+            // We used to incorrectly stop parsing macro-expanded statements here.\n+            // If the next token will be an error anyway but could have parsed with the\n+            // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+            else if macro_legacy_warnings &&\n+                    self.token.can_begin_expr() &&\n+                    match self.token.kind {\n+                // These can continue an expression, so we can't stop parsing and warn.\n+                token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                token::BinOp(token::And) | token::BinOp(token::Or) |\n+                token::AndAnd | token::OrOr |\n+                token::DotDot | token::DotDotDot | token::DotDotEq => false,\n+                _ => true,\n+            } {\n+                self.warn_missing_semicolon();\n+                StmtKind::Mac(P((mac, style, attrs.into())))\n+            } else {\n+                let e = self.mk_expr(mac.span, ExprKind::Mac(mac), ThinVec::new());\n+                let e = self.maybe_recover_from_bad_qpath(e, true)?;\n+                let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                StmtKind::Expr(e)\n+            };\n+            Stmt {\n+                id: ast::DUMMY_NODE_ID,\n+                span: lo.to(hi),\n+                node,\n+            }\n+        } else {\n+            // FIXME: Bad copy of attrs\n+            let old_directory_ownership =\n+                mem::replace(&mut self.directory.ownership, DirectoryOwnership::UnownedViaBlock);\n+            let item = self.parse_item_(attrs.clone(), false, true)?;\n+            self.directory.ownership = old_directory_ownership;\n+\n+            match item {\n+                Some(i) => Stmt {\n+                    id: ast::DUMMY_NODE_ID,\n+                    span: lo.to(i.span),\n+                    node: StmtKind::Item(i),\n+                },\n+                None => {\n+                    let unused_attrs = |attrs: &[Attribute], s: &mut Self| {\n+                        if !attrs.is_empty() {\n+                            if s.prev_token_kind == PrevTokenKind::DocComment {\n+                                s.span_fatal_err(s.prev_span, Error::UselessDocComment).emit();\n+                            } else if attrs.iter().any(|a| a.style == AttrStyle::Outer) {\n+                                s.span_err(\n+                                    s.token.span, \"expected statement after outer attribute\"\n+                                );\n+                            }\n+                        }\n+                    };\n+\n+                    // Do not attempt to parse an expression if we're done here.\n+                    if self.token == token::Semi {\n+                        unused_attrs(&attrs, self);\n+                        self.bump();\n+                        return Ok(None);\n+                    }\n+\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        unused_attrs(&attrs, self);\n+                        return Ok(None);\n+                    }\n+\n+                    // Remainder are line-expr stmts.\n+                    let e = self.parse_expr_res(\n+                        Restrictions::STMT_EXPR, Some(attrs.into()))?;\n+                    Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: lo.to(e.span),\n+                        node: StmtKind::Expr(e),\n+                    }\n+                }\n+            }\n+        }))\n+    }\n+\n+    /// Parses a local variable declaration.\n+    fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n+        let lo = self.prev_span;\n+        let pat = self.parse_top_level_pat()?;\n+\n+        let (err, ty) = if self.eat(&token::Colon) {\n+            // Save the state of the parser before parsing type normally, in case there is a `:`\n+            // instead of an `=` typo.\n+            let parser_snapshot_before_type = self.clone();\n+            let colon_sp = self.prev_span;\n+            match self.parse_ty() {\n+                Ok(ty) => (None, Some(ty)),\n+                Err(mut err) => {\n+                    // Rewind to before attempting to parse the type and continue parsing\n+                    let parser_snapshot_after_type = self.clone();\n+                    mem::replace(self, parser_snapshot_before_type);\n+\n+                    let snippet = self.span_to_snippet(pat.span).unwrap();\n+                    err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n+                    (Some((parser_snapshot_after_type, colon_sp, err)), None)\n+                }\n+            }\n+        } else {\n+            (None, None)\n+        };\n+        let init = match (self.parse_initializer(err.is_some()), err) {\n+            (Ok(init), None) => {  // init parsed, ty parsed\n+                init\n+            }\n+            (Ok(init), Some((_, colon_sp, mut err))) => {  // init parsed, ty error\n+                // Could parse the type as if it were the initializer, it is likely there was a\n+                // typo in the code: `:` instead of `=`. Add suggestion and emit the error.\n+                err.span_suggestion_short(\n+                    colon_sp,\n+                    \"use `=` if you meant to assign\",\n+                    \"=\".to_string(),\n+                    Applicability::MachineApplicable\n+                );\n+                err.emit();\n+                // As this was parsed successfully, continue as if the code has been fixed for the\n+                // rest of the file. It will still fail due to the emitted error, but we avoid\n+                // extra noise.\n+                init\n+            }\n+            (Err(mut init_err), Some((snapshot, _, ty_err))) => {  // init error, ty error\n+                init_err.cancel();\n+                // Couldn't parse the type nor the initializer, only raise the type error and\n+                // return to the parser state before parsing the type as the initializer.\n+                // let x: <parse_error>;\n+                mem::replace(self, snapshot);\n+                return Err(ty_err);\n+            }\n+            (Err(err), None) => {  // init error, ty parsed\n+                // Couldn't parse the initializer and we're not attempting to recover a failed\n+                // parse of the type, return the error.\n+                return Err(err);\n+            }\n+        };\n+        let hi = if self.token == token::Semi {\n+            self.token.span\n+        } else {\n+            self.prev_span\n+        };\n+        Ok(P(ast::Local {\n+            ty,\n+            pat,\n+            init,\n+            id: ast::DUMMY_NODE_ID,\n+            span: lo.to(hi),\n+            attrs,\n+        }))\n+    }\n+\n+    /// Parses the RHS of a local variable declaration (e.g., '= 14;').\n+    fn parse_initializer(&mut self, skip_eq: bool) -> PResult<'a, Option<P<Expr>>> {\n+        if self.eat(&token::Eq) {\n+            Ok(Some(self.parse_expr()?))\n+        } else if skip_eq {\n+            Ok(Some(self.parse_expr()?))\n+        } else {\n+            Ok(None)\n+        }\n+    }\n+\n+    fn is_auto_trait_item(&self) -> bool {\n+        // auto trait\n+        (self.token.is_keyword(kw::Auto) &&\n+            self.is_keyword_ahead(1, &[kw::Trait]))\n+        || // unsafe auto trait\n+        (self.token.is_keyword(kw::Unsafe) &&\n+         self.is_keyword_ahead(1, &[kw::Auto]) &&\n+         self.is_keyword_ahead(2, &[kw::Trait]))\n+    }\n+\n+    /// Parses a block. No inner attributes are allowed.\n+    pub fn parse_block(&mut self) -> PResult<'a, P<Block>> {\n+        maybe_whole!(self, NtBlock, |x| x);\n+\n+        let lo = self.token.span;\n+\n+        if !self.eat(&token::OpenDelim(token::Brace)) {\n+            let sp = self.token.span;\n+            let tok = self.this_token_descr();\n+            let mut e = self.span_fatal(sp, &format!(\"expected `{{`, found {}\", tok));\n+            let do_not_suggest_help =\n+                self.token.is_keyword(kw::In) || self.token == token::Colon;\n+\n+            if self.token.is_ident_named(sym::and) {\n+                e.span_suggestion_short(\n+                    self.token.span,\n+                    \"use `&&` instead of `and` for the boolean operator\",\n+                    \"&&\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            if self.token.is_ident_named(sym::or) {\n+                e.span_suggestion_short(\n+                    self.token.span,\n+                    \"use `||` instead of `or` for the boolean operator\",\n+                    \"||\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            // Check to see if the user has written something like\n+            //\n+            //    if (cond)\n+            //      bar;\n+            //\n+            // Which is valid in other languages, but not Rust.\n+            match self.parse_stmt_without_recovery(false) {\n+                Ok(Some(stmt)) => {\n+                    if self.look_ahead(1, |t| t == &token::OpenDelim(token::Brace))\n+                        || do_not_suggest_help {\n+                        // if the next token is an open brace (e.g., `if a b {`), the place-\n+                        // inside-a-block suggestion would be more likely wrong than right\n+                        e.span_label(sp, \"expected `{`\");\n+                        return Err(e);\n+                    }\n+                    let mut stmt_span = stmt.span;\n+                    // expand the span to include the semicolon, if it exists\n+                    if self.eat(&token::Semi) {\n+                        stmt_span = stmt_span.with_hi(self.prev_span.hi());\n+                    }\n+                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n+                        e.span_suggestion(\n+                            stmt_span,\n+                            \"try placing this code inside a block\",\n+                            format!(\"{{ {} }}\", snippet),\n+                            // speculative, has been misleading in the past (#46836)\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                }\n+                Err(mut e) => {\n+                    self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n+                    self.cancel(&mut e);\n+                }\n+                _ => ()\n+            }\n+            e.span_label(sp, \"expected `{`\");\n+            return Err(e);\n+        }\n+\n+        self.parse_block_tail(lo, BlockCheckMode::Default)\n+    }\n+\n+    /// Parses a block. Inner attributes are allowed.\n+    crate fn parse_inner_attrs_and_block(&mut self) -> PResult<'a, (Vec<Attribute>, P<Block>)> {\n+        maybe_whole!(self, NtBlock, |x| (Vec::new(), x));\n+\n+        let lo = self.token.span;\n+        self.expect(&token::OpenDelim(token::Brace))?;\n+        Ok((self.parse_inner_attributes()?,\n+            self.parse_block_tail(lo, BlockCheckMode::Default)?))\n+    }\n+\n+    /// Parses the rest of a block expression or function body.\n+    /// Precondition: already parsed the '{'.\n+    pub(super) fn parse_block_tail(\n+        &mut self,\n+        lo: Span,\n+        s: BlockCheckMode\n+    ) -> PResult<'a, P<Block>> {\n+        let mut stmts = vec![];\n+        while !self.eat(&token::CloseDelim(token::Brace)) {\n+            if self.token == token::Eof {\n+                break;\n+            }\n+            let stmt = match self.parse_full_stmt(false) {\n+                Err(mut err) => {\n+                    err.emit();\n+                    self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore);\n+                    Some(Stmt {\n+                        id: ast::DUMMY_NODE_ID,\n+                        node: StmtKind::Expr(DummyResult::raw_expr(self.token.span, true)),\n+                        span: self.token.span,\n+                    })\n+                }\n+                Ok(stmt) => stmt,\n+            };\n+            if let Some(stmt) = stmt {\n+                stmts.push(stmt);\n+            } else {\n+                // Found only `;` or `}`.\n+                continue;\n+            };\n+        }\n+        Ok(P(ast::Block {\n+            stmts,\n+            id: ast::DUMMY_NODE_ID,\n+            rules: s,\n+            span: lo.to(self.prev_span),\n+        }))\n+    }\n+\n+    /// Parses a statement, including the trailing semicolon.\n+    crate fn parse_full_stmt(&mut self, macro_legacy_warnings: bool) -> PResult<'a, Option<Stmt>> {\n+        // skip looking for a trailing semicolon when we have an interpolated statement\n+        maybe_whole!(self, NtStmt, |x| Some(x));\n+\n+        let mut stmt = match self.parse_stmt_without_recovery(macro_legacy_warnings)? {\n+            Some(stmt) => stmt,\n+            None => return Ok(None),\n+        };\n+\n+        match stmt.node {\n+            StmtKind::Expr(ref expr) if self.token != token::Eof => {\n+                // expression without semicolon\n+                if classify::expr_requires_semi_to_be_stmt(expr) {\n+                    // Just check for errors and recover; do not eat semicolon yet.\n+                    if let Err(mut e) =\n+                        self.expect_one_of(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+                    {\n+                        e.emit();\n+                        self.recover_stmt();\n+                        // Don't complain about type errors in body tail after parse error (#57383).\n+                        let sp = expr.span.to(self.prev_span);\n+                        stmt.node = StmtKind::Expr(DummyResult::raw_expr(sp, true));\n+                    }\n+                }\n+            }\n+            StmtKind::Local(..) => {\n+                // We used to incorrectly allow a macro-expanded let statement to lack a semicolon.\n+                if macro_legacy_warnings && self.token != token::Semi {\n+                    self.warn_missing_semicolon();\n+                } else {\n+                    self.expect_one_of(&[], &[token::Semi])?;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        if self.eat(&token::Semi) {\n+            stmt = stmt.add_trailing_semicolon();\n+        }\n+        stmt.span = stmt.span.to(self.prev_span);\n+        Ok(Some(stmt))\n+    }\n+\n+    fn warn_missing_semicolon(&self) {\n+        self.diagnostic().struct_span_warn(self.token.span, {\n+            &format!(\"expected `;`, found {}\", self.this_token_descr())\n+        }).note({\n+            \"This was erroneously allowed and will become a hard error in a future release\"\n+        }).emit();\n+    }\n+}"}]}