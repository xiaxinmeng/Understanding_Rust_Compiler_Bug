{"sha": "3eeb5a665e313c5b281820099e04d4c6c8188b46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZWI1YTY2NWUzMTNjNWIyODE4MjAwOTllMDRkNGM2YzgxODhiNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-01T13:19:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-01T13:19:18Z"}, "message": "Auto merge of #46785 - leodasvacas:type-check-defaults-at-declaration, r=nikomatsakis\n\n[Underspecified semantics] Type check defaults at declaration.\n\nFixes  #46669. See the test for code that compiles on stable but will no longer compile. This falls under a \"Underspecified language semantics\" fix. **Needs crater**.\n\nOn type and trait declarations, we currently allow anything that name checks as a type parameter default. That allows the user to write a default that can never be applied, or even a default that may conditionally be applied depending on the type of another parameter. Mostly this just defers the error to use sites, but also allows clever hacks such as `Foo<T, U = <T as Iterator>::Item>` where `U` will be able to apply it's default only when `T: Iterator`. Maybe that means this bug is a feature, but it's a fiddly behaviour that seems undesirable.\n\nThis PR validates defaults at declaration sites by ensuring all predicates on the parameter are valid for the default. With the exception of `Self: Sized` which we don't want to check to allow things like `trait Add<RHS = Self>`.", "tree": {"sha": "e16ca17237185c562aa8a02f382c3102e6f44061", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e16ca17237185c562aa8a02f382c3102e6f44061"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eeb5a665e313c5b281820099e04d4c6c8188b46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eeb5a665e313c5b281820099e04d4c6c8188b46", "html_url": "https://github.com/rust-lang/rust/commit/3eeb5a665e313c5b281820099e04d4c6c8188b46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eeb5a665e313c5b281820099e04d4c6c8188b46/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a85417f5938023d1491b44d94da705f539bb8b17", "url": "https://api.github.com/repos/rust-lang/rust/commits/a85417f5938023d1491b44d94da705f539bb8b17", "html_url": "https://github.com/rust-lang/rust/commit/a85417f5938023d1491b44d94da705f539bb8b17"}, {"sha": "3e84aeda0fa308424338529611a8ee157776b221", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e84aeda0fa308424338529611a8ee157776b221", "html_url": "https://github.com/rust-lang/rust/commit/3e84aeda0fa308424338529611a8ee157776b221"}], "stats": {"total": 254, "additions": 231, "deletions": 23}, "files": [{"sha": "39e757c52ff2974ed709d62b6e0d3dbb56d8b781", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 88, "deletions": 23, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -185,10 +185,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                     reject_shadowing_type_parameters(fcx.tcx, item.def_id);\n                     let sig = fcx.tcx.fn_sig(item.def_id);\n                     let sig = fcx.normalize_associated_types_in(span, &sig);\n-                    let predicates = fcx.tcx.predicates_of(item.def_id)\n-                        .instantiate_identity(fcx.tcx);\n-                    let predicates = fcx.normalize_associated_types_in(span, &predicates);\n-                    this.check_fn_or_method(fcx, span, sig, &predicates,\n+                    this.check_fn_or_method(fcx, span, sig,\n                                             item.def_id, &mut implied_bounds);\n                     let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n                     this.check_method_receiver(fcx, sig_if_method, &item, self_ty);\n@@ -272,20 +269,16 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-            this.check_where_clauses(fcx, item.span, &predicates);\n+            self.check_where_clauses(fcx, item.span, def_id);\n \n             vec![] // no implied bounds in a struct def'n\n         });\n     }\n \n     fn check_trait(&mut self, item: &hir::Item) {\n         let trait_def_id = self.tcx.hir.local_def_id(item.id);\n-        self.for_item(item).with_fcx(|fcx, this| {\n-            let predicates = fcx.tcx.predicates_of(trait_def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-            this.check_where_clauses(fcx, item.span, &predicates);\n+        self.for_item(item).with_fcx(|fcx, _| {\n+            self.check_where_clauses(fcx, item.span, trait_def_id);\n             vec![]\n         });\n     }\n@@ -295,12 +288,8 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n             let def_id = fcx.tcx.hir.local_def_id(item.id);\n             let sig = fcx.tcx.fn_sig(def_id);\n             let sig = fcx.normalize_associated_types_in(item.span, &sig);\n-\n-            let predicates = fcx.tcx.predicates_of(def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-\n             let mut implied_bounds = vec![];\n-            this.check_fn_or_method(fcx, item.span, sig, &predicates,\n+            this.check_fn_or_method(fcx, item.span, sig,\n                                     def_id, &mut implied_bounds);\n             implied_bounds\n         })\n@@ -354,19 +343,96 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                 }\n             }\n \n-            let predicates = fcx.tcx.predicates_of(item_def_id).instantiate_identity(fcx.tcx);\n-            let predicates = fcx.normalize_associated_types_in(item.span, &predicates);\n-            this.check_where_clauses(fcx, item.span, &predicates);\n+            this.check_where_clauses(fcx, item.span, item_def_id);\n \n             fcx.impl_implied_bounds(item_def_id, item.span)\n         });\n     }\n \n+    /// Checks where clauses and inline bounds that are declared on def_id.\n     fn check_where_clauses<'fcx, 'tcx>(&mut self,\n                                        fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                        span: Span,\n-                                       predicates: &ty::InstantiatedPredicates<'tcx>)\n-    {\n+                                       def_id: DefId) {\n+        use ty::subst::Subst;\n+        use rustc::ty::TypeFoldable;\n+\n+        let mut predicates = fcx.tcx.predicates_of(def_id);\n+        let mut substituted_predicates = Vec::new();\n+\n+        let generics = self.tcx.generics_of(def_id);\n+        let is_our_default = |def: &ty::TypeParameterDef|\n+                                def.has_default && def.index >= generics.parent_count() as u32;\n+\n+        // Check that concrete defaults are well-formed. See test `type-check-defaults.rs`.\n+        // For example this forbids the declaration:\n+        // struct Foo<T = Vec<[u32]>> { .. }\n+        // Here the default `Vec<[u32]>` is not WF because `[u32]: Sized` does not hold.\n+        for d in generics.types.iter().cloned().filter(is_our_default).map(|p| p.def_id) {\n+            let ty = fcx.tcx.type_of(d);\n+            // ignore dependent defaults -- that is, where the default of one type\n+            // parameter includes another (e.g., <T, U = T>). In those cases, we can't\n+            // be sure if it will error or not as user might always specify the other.\n+            if !ty.needs_subst() {\n+                fcx.register_wf_obligation(ty, fcx.tcx.def_span(d), self.code.clone());\n+            }\n+        }\n+\n+        // Check that trait predicates are WF when params are substituted by their defaults.\n+        // We don't want to overly constrain the predicates that may be written but we want to\n+        // catch cases where a default my never be applied such as `struct Foo<T: Copy = String>`.\n+        // Therefore we check if a predicate which contains a single type param\n+        // with a concrete default is WF with that default substituted.\n+        // For more examples see tests `defaults-well-formedness.rs` and `type-check-defaults.rs`.\n+        //\n+        // First we build the defaulted substitution.\n+        let substs = ty::subst::Substs::for_item(fcx.tcx, def_id, |def, _| {\n+                // All regions are identity.\n+                fcx.tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+            }, |def, _| {\n+                // If the param has a default,\n+                if is_our_default(def) {\n+                    let default_ty = fcx.tcx.type_of(def.def_id);\n+                    // and it's not a dependent default\n+                    if !default_ty.needs_subst() {\n+                        // then substitute with the default.\n+                        return default_ty;\n+                    }\n+                }\n+                // Mark unwanted params as err.\n+                fcx.tcx.types.err\n+            });\n+        // Now we build the substituted predicates.\n+        for &pred in predicates.predicates.iter() {\n+            struct CountParams { params: FxHashSet<u32> }\n+            impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n+                fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+                    match t.sty {\n+                        ty::TyParam(p) => {\n+                            self.params.insert(p.idx);\n+                            t.super_visit_with(self)\n+                        }\n+                        _ => t.super_visit_with(self)\n+                    }\n+                }\n+            }\n+            let mut param_count = CountParams { params: FxHashSet() };\n+            pred.visit_with(&mut param_count);\n+            let substituted_pred = pred.subst(fcx.tcx, substs);\n+            // Don't check non-defaulted params, dependent defaults or preds with multiple params.\n+            if substituted_pred.references_error() || param_count.params.len() > 1 {\n+                continue;\n+            }\n+            // Avoid duplication of predicates that contain no parameters, for example.\n+            if !predicates.predicates.contains(&substituted_pred) {\n+                substituted_predicates.push(substituted_pred);\n+            }\n+        }\n+\n+        predicates.predicates.extend(substituted_predicates);\n+        let predicates = predicates.instantiate_identity(fcx.tcx);\n+        let predicates = fcx.normalize_associated_types_in(span, &predicates);\n+\n         let obligations =\n             predicates.predicates\n                       .iter()\n@@ -385,7 +451,6 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n                                       span: Span,\n                                       sig: ty::PolyFnSig<'tcx>,\n-                                      predicates: &ty::InstantiatedPredicates<'tcx>,\n                                       def_id: DefId,\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n@@ -402,7 +467,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         // FIXME(#25759) return types should not be implied bounds\n         implied_bounds.push(sig.output());\n \n-        self.check_where_clauses(fcx, span, predicates);\n+        self.check_where_clauses(fcx, span, def_id);\n     }\n \n     fn check_method_receiver<'fcx, 'tcx>(&mut self,"}, {"sha": "f35946790955360be57bf8f2e09c009ef82c6670", "filename": "src/test/run-pass/defaults-well-formedness.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Frun-pass%2Fdefaults-well-formedness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Frun-pass%2Fdefaults-well-formedness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefaults-well-formedness.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Trait<T> {}\n+struct Foo<U, V=i32>(U, V) where U: Trait<V>;\n+\n+trait Marker {}\n+struct TwoParams<T, U>(T, U);\n+impl Marker for TwoParams<i32, i32> {}\n+\n+// Clauses with more than 1 param are not checked.\n+struct IndividuallyBogus<T = i32, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Marker;\n+struct BogusTogether<T = u32, U = i32>(T, U) where TwoParams<T, U>: Marker;\n+// Clauses with non-defaulted params are not checked.\n+struct NonDefaultedInClause<T, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Marker;\n+struct DefaultedLhs<U, V=i32>(U, V) where V: Trait<U>;\n+// Dependent defaults are not checked.\n+struct Dependent<T, U = T>(T, U) where U: Copy;\n+trait SelfBound<T: Copy=Self> {}\n+// Not even for well-formedness.\n+struct WellFormedProjection<A, T=<A as Iterator>::Item>(A, T);\n+\n+fn main() {}"}, {"sha": "67b1d2c06e314cb650befe8cfe85160843f96623", "filename": "src/test/run-pass/type-macros-simple.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-macros-simple.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -34,3 +34,4 @@ fn issue_36540() {\n }\n \n trait Trait<T> {}\n+impl Trait<i32> for i32 {}"}, {"sha": "f916df5d32d0462826035a9e87aca7351c6ee88e", "filename": "src/test/ui/type-check-defaults.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Fui%2Ftype-check-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Fui%2Ftype-check-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.rs?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::FromIterator;\n+use std::vec::IntoIter;\n+use std::ops::Add;\n+\n+struct Foo<T, U: FromIterator<T>>(T, U);\n+struct WellFormed<Z = Foo<i32, i32>>(Z);\n+//~^ error: the trait bound `i32: std::iter::FromIterator<i32>` is not satisfied [E0277]\n+struct WellFormedNoBounds<Z:?Sized = Foo<i32, i32>>(Z);\n+//~^ error: the trait bound `i32: std::iter::FromIterator<i32>` is not satisfied [E0277]\n+\n+struct Bounds<T:Copy=String>(T);\n+//~^ error: the trait bound `std::string::String: std::marker::Copy` is not satisfied [E0277]\n+\n+struct WhereClause<T=String>(T) where T: Copy;\n+//~^ error: the trait bound `std::string::String: std::marker::Copy` is not satisfied [E0277]\n+\n+trait TraitBound<T:Copy=String> {}\n+//~^ error: the trait bound `std::string::String: std::marker::Copy` is not satisfied [E0277]\n+\n+trait Super<T: Copy> { }\n+trait Base<T = String>: Super<T> { }\n+//~^ error: the trait bound `T: std::marker::Copy` is not satisfied [E0277]\n+\n+trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+//~^ error:  cannot add `u8` to `i32` [E0277]\n+\n+fn main() { }"}, {"sha": "f39b7dcb31f0ca22cbe667f7625a3fc7f6916868", "filename": "src/test/ui/type-check-defaults.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3eeb5a665e313c5b281820099e04d4c6c8188b46/src%2Ftest%2Fui%2Ftype-check-defaults.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check-defaults.stderr?ref=3eeb5a665e313c5b281820099e04d4c6c8188b46", "patch": "@@ -0,0 +1,75 @@\n+error[E0277]: the trait bound `i32: std::iter::FromIterator<i32>` is not satisfied\n+  --> $DIR/type-check-defaults.rs:16:19\n+   |\n+LL | struct WellFormed<Z = Foo<i32, i32>>(Z);\n+   |                   ^ a collection of type `i32` cannot be built from an iterator over elements of type `i32`\n+   |\n+   = help: the trait `std::iter::FromIterator<i32>` is not implemented for `i32`\n+note: required by `Foo`\n+  --> $DIR/type-check-defaults.rs:15:1\n+   |\n+LL | struct Foo<T, U: FromIterator<T>>(T, U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `i32: std::iter::FromIterator<i32>` is not satisfied\n+  --> $DIR/type-check-defaults.rs:18:27\n+   |\n+LL | struct WellFormedNoBounds<Z:?Sized = Foo<i32, i32>>(Z);\n+   |                           ^ a collection of type `i32` cannot be built from an iterator over elements of type `i32`\n+   |\n+   = help: the trait `std::iter::FromIterator<i32>` is not implemented for `i32`\n+note: required by `Foo`\n+  --> $DIR/type-check-defaults.rs:15:1\n+   |\n+LL | struct Foo<T, U: FromIterator<T>>(T, U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:21:1\n+   |\n+LL | struct Bounds<T:Copy=String>(T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:24:1\n+   |\n+LL | struct WhereClause<T=String>(T) where T: Copy;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `std::string::String: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:27:1\n+   |\n+LL | trait TraitBound<T:Copy=String> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `std::string::String`\n+   |\n+   = note: required by `std::marker::Copy`\n+\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/type-check-defaults.rs:31:1\n+   |\n+LL | trait Base<T = String>: Super<T> { }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+   = help: consider adding a `where T: std::marker::Copy` bound\n+note: required by `Super`\n+  --> $DIR/type-check-defaults.rs:30:1\n+   |\n+LL | trait Super<T: Copy> { }\n+   | ^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0277]: cannot add `u8` to `i32`\n+  --> $DIR/type-check-defaults.rs:34:1\n+   |\n+LL | trait ProjectionPred<T:Iterator = IntoIter<i32>> where T::Item : Add<u8> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no implementation for `i32 + u8`\n+   |\n+   = help: the trait `std::ops::Add<u8>` is not implemented for `i32`\n+   = note: required by `std::ops::Add`\n+\n+error: aborting due to 7 previous errors\n+\n+If you want more information on this error, try using \"rustc --explain E0277\""}]}