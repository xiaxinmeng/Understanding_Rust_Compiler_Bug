{"sha": "f04e866e5752f47e0896550faf40e19fea22d8ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNGU4NjZlNTc1MmY0N2UwODk2NTUwZmFmNDBlMTlmZWEyMmQ4ZWE=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-07-08T01:04:10Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2020-07-14T22:42:59Z"}, "message": "Add and use more static symbols.\n\nNote that the output of `unpretty-debug.stdout` has changed. In that\ntest the hash values are normalized from a symbol numbers to small\nnumbers like \"0#0\" and \"0#1\". The increase in the number of static\nsymbols must have caused the original numbers to contain more digits,\nresulting in different pretty-printing prior to normalization.", "tree": {"sha": "dc192030f27fb19c6c842775f931f6a7494a0020", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc192030f27fb19c6c842775f931f6a7494a0020"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f04e866e5752f47e0896550faf40e19fea22d8ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f04e866e5752f47e0896550faf40e19fea22d8ea", "html_url": "https://github.com/rust-lang/rust/commit/f04e866e5752f47e0896550faf40e19fea22d8ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f04e866e5752f47e0896550faf40e19fea22d8ea/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e284f5d050029906d32667635af9c839fafd3eca", "url": "https://api.github.com/repos/rust-lang/rust/commits/e284f5d050029906d32667635af9c839fafd3eca", "html_url": "https://github.com/rust-lang/rust/commit/e284f5d050029906d32667635af9c839fafd3eca"}], "stats": {"total": 1373, "additions": 794, "deletions": 579}, "files": [{"sha": "7c67f029f382db1b4107fc73092759e9885ae413", "filename": "src/librustc_ast/expand/allocator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fexpand%2Fallocator.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -9,7 +9,7 @@ pub enum AllocatorKind {\n }\n \n impl AllocatorKind {\n-    pub fn fn_name(&self, base: &str) -> String {\n+    pub fn fn_name(&self, base: Symbol) -> String {\n         match *self {\n             AllocatorKind::Global => format!(\"__rg_{}\", base),\n             AllocatorKind::Default => format!(\"__rdl_{}\", base),\n@@ -26,29 +26,29 @@ pub enum AllocatorTy {\n }\n \n pub struct AllocatorMethod {\n-    pub name: &'static str,\n+    pub name: Symbol,\n     pub inputs: &'static [AllocatorTy],\n     pub output: AllocatorTy,\n }\n \n pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n     AllocatorMethod {\n-        name: \"alloc\",\n+        name: sym::alloc,\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n     },\n     AllocatorMethod {\n-        name: \"dealloc\",\n+        name: sym::dealloc,\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n         output: AllocatorTy::Unit,\n     },\n     AllocatorMethod {\n-        name: \"realloc\",\n+        name: sym::realloc,\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Usize],\n         output: AllocatorTy::ResultPtr,\n     },\n     AllocatorMethod {\n-        name: \"alloc_zeroed\",\n+        name: sym::alloc_zeroed,\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n     },\n@@ -70,7 +70,7 @@ pub fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n         }\n     }\n \n-    let name = Symbol::intern(&AllocatorKind::Global.fn_name(\"alloc\"));\n+    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n     let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans"}, {"sha": "0606fac2fe748f17aa13ee7e078ab363f146ecb6", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -1041,10 +1041,10 @@ pub fn find_transparency(\n                 break;\n             } else if let Some(value) = attr.value_str() {\n                 transparency = Some((\n-                    match &*value.as_str() {\n-                        \"transparent\" => Transparency::Transparent,\n-                        \"semitransparent\" => Transparency::SemiTransparent,\n-                        \"opaque\" => Transparency::Opaque,\n+                    match value {\n+                        sym::transparent => Transparency::Transparent,\n+                        sym::semitransparent => Transparency::SemiTransparent,\n+                        sym::opaque => Transparency::Opaque,\n                         _ => {\n                             error = Some(TransparencyError::UnknownTransparency(value, attr.span));\n                             continue;"}, {"sha": "5a8648f2aaa4cf61e6ebafaa1f1ddf34e3c24bb4", "filename": "src/librustc_builtin_macros/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fclone.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -84,7 +84,7 @@ pub fn expand_deriving_clone(\n         is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n-            name: \"clone\",\n+            name: sym::clone,\n             generics: LifetimeBounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: Vec::new(),"}, {"sha": "e1677ae70ccabf6203df756ed875bfeb2086920e", "filename": "src/librustc_builtin_macros/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Feq.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -28,7 +28,7 @@ pub fn expand_deriving_eq(\n         is_unsafe: false,\n         supports_unions: true,\n         methods: vec![MethodDef {\n-            name: \"assert_receiver_is_total_eq\",\n+            name: sym::assert_receiver_is_total_eq,\n             generics: LifetimeBounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: vec![],"}, {"sha": "a9bc03db8b70605e54542c7e86fdb5b15f104636", "filename": "src/librustc_builtin_macros/deriving/cmp/ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Ford.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -26,7 +26,7 @@ pub fn expand_deriving_ord(\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n-            name: \"cmp\",\n+            name: sym::cmp,\n             generics: LifetimeBounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: vec![(borrowed_self(), \"other\")],"}, {"sha": "e7d8f78118098063f750aa44f9d8a8575c6d4cb2", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -92,9 +92,9 @@ pub fn expand_deriving_partial_eq(\n     // avoid defining `ne` if we can\n     // c-like enums, enums without any fields and structs without fields\n     // can safely define only `eq`.\n-    let mut methods = vec![md!(\"eq\", cs_eq)];\n+    let mut methods = vec![md!(sym::eq, cs_eq)];\n     if !is_type_without_fields(item) {\n-        methods.push(md!(\"ne\", cs_ne));\n+        methods.push(md!(sym::ne, cs_ne));\n     }\n \n     let trait_def = TraitDef {"}, {"sha": "a3eb96fb782e531f2b548d8065952c8c5f5043b4", "filename": "src/librustc_builtin_macros/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -49,7 +49,7 @@ pub fn expand_deriving_partial_ord(\n     let attrs = vec![cx.attribute(inline)];\n \n     let partial_cmp_def = MethodDef {\n-        name: \"partial_cmp\",\n+        name: sym::partial_cmp,\n         generics: LifetimeBounds::empty(),\n         explicit_self: borrowed_explicit_self(),\n         args: vec![(borrowed_self(), \"other\")],\n@@ -70,10 +70,10 @@ pub fn expand_deriving_partial_ord(\n     } else {\n         vec![\n             partial_cmp_def,\n-            md!(\"lt\", true, false),\n-            md!(\"le\", true, true),\n-            md!(\"gt\", false, false),\n-            md!(\"ge\", false, true),\n+            md!(sym::lt, true, false),\n+            md!(sym::le, true, true),\n+            md!(sym::gt, false, false),\n+            md!(sym::ge, false, true),\n         ]\n     };\n \n@@ -108,14 +108,14 @@ pub fn some_ordering_collapsed(\n ) -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n-    let op_str = match op {\n-        PartialCmpOp => \"partial_cmp\",\n-        LtOp => \"lt\",\n-        LeOp => \"le\",\n-        GtOp => \"gt\",\n-        GeOp => \"ge\",\n+    let op_sym = match op {\n+        PartialCmpOp => sym::partial_cmp,\n+        LtOp => sym::lt,\n+        LeOp => sym::le,\n+        GtOp => sym::gt,\n+        GeOp => sym::ge,\n     };\n-    cx.expr_method_call(span, lft, cx.ident_of(op_str, span), vec![rgt])\n+    cx.expr_method_call(span, lft, Ident::new(op_sym, span), vec![rgt])\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {"}, {"sha": "6befeb746bd6d1dfc37069a7a846f3ca9d40e3f2", "filename": "src/librustc_builtin_macros/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdebug.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_debug(\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n-            name: \"fmt\",\n+            name: sym::fmt,\n             generics: LifetimeBounds::empty(),\n             explicit_self: borrowed_explicit_self(),\n             args: vec![(fmtr, \"f\")],"}, {"sha": "0792be73263317ddfc1bf4b4c2ffe8be2147a483", "filename": "src/librustc_builtin_macros/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdecodable.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::ast;\n use rustc_ast::ast::{Expr, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_decodable(\n@@ -30,7 +30,7 @@ pub fn expand_deriving_rustc_decodable(\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n-            name: \"decode\",\n+            name: sym::decode,\n             generics: LifetimeBounds {\n                 lifetimes: Vec::new(),\n                 bounds: vec![("}, {"sha": "5dfb0e8f37c63a81807642c342e179a70af61ecf", "filename": "src/librustc_builtin_macros/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fdefault.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -27,7 +27,7 @@ pub fn expand_deriving_default(\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n-            name: \"default\",\n+            name: kw::Default,\n             generics: LifetimeBounds::empty(),\n             explicit_self: None,\n             args: Vec::new(),"}, {"sha": "4a90b7a193886793e7b5093798ef4cd6e9db47bc", "filename": "src/librustc_builtin_macros/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fencodable.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -92,7 +92,7 @@ use crate::deriving::pathvec_std;\n use rustc_ast::ast::{Expr, ExprKind, MetaItem, Mutability};\n use rustc_ast::ptr::P;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n pub fn expand_deriving_rustc_encodable(\n@@ -114,7 +114,7 @@ pub fn expand_deriving_rustc_encodable(\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n-            name: \"encode\",\n+            name: sym::encode,\n             generics: LifetimeBounds {\n                 lifetimes: Vec::new(),\n                 bounds: vec![("}, {"sha": "050774aa24c969e9c62f159fcc26263026f42909", "filename": "src/librustc_builtin_macros/deriving/generic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fgeneric%2Fmod.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -226,7 +226,7 @@ pub struct TraitDef<'a> {\n \n pub struct MethodDef<'a> {\n     /// name of the method\n-    pub name: &'a str,\n+    pub name: Symbol,\n     /// List of generics, e.g., `R: rand::Rng`\n     pub generics: LifetimeBounds<'a>,\n \n@@ -681,7 +681,7 @@ impl<'a> TraitDef<'a> {\n         let opt_trait_ref = Some(trait_ref);\n         let unused_qual = {\n             let word = rustc_ast::attr::mk_nested_word_item(Ident::new(\n-                Symbol::intern(\"unused_qualifications\"),\n+                sym::unused_qualifications,\n                 self.span,\n             ));\n             let list = rustc_ast::attr::mk_list_item(Ident::new(sym::allow, self.span), vec![word]);\n@@ -818,7 +818,7 @@ impl<'a> MethodDef<'a> {\n     ) -> P<Expr> {\n         let substructure = Substructure {\n             type_ident,\n-            method_ident: cx.ident_of(self.name, trait_.span),\n+            method_ident: Ident::new(self.name, trait_.span),\n             self_args,\n             nonself_args,\n             fields,\n@@ -913,7 +913,7 @@ impl<'a> MethodDef<'a> {\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n \n-        let method_ident = cx.ident_of(self.name, trait_.span);\n+        let method_ident = Ident::new(self.name, trait_.span);\n         let fn_decl = cx.fn_decl(args, ast::FnRetTy::Ty(ret_type));\n         let body_block = cx.block_expr(body);\n \n@@ -1315,7 +1315,7 @@ impl<'a> MethodDef<'a> {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n-                Some(deriving::call_intrinsic(cx, sp, \"unreachable\", vec![]))\n+                Some(deriving::call_intrinsic(cx, sp, sym::unreachable, vec![]))\n             }\n             _ => None,\n         };\n@@ -1363,7 +1363,7 @@ impl<'a> MethodDef<'a> {\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n                 let variant_value =\n-                    deriving::call_intrinsic(cx, sp, \"discriminant_value\", vec![self_addr]);\n+                    deriving::call_intrinsic(cx, sp, sym::discriminant_value, vec![self_addr]);\n                 let let_stmt = cx.stmt_let(sp, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n \n@@ -1464,7 +1464,7 @@ impl<'a> MethodDef<'a> {\n             // derive Debug on such a type could here generate code\n             // that needs the feature gate enabled.)\n \n-            deriving::call_intrinsic(cx, sp, \"unreachable\", vec![])\n+            deriving::call_intrinsic(cx, sp, sym::unreachable, vec![])\n         } else {\n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired places, but we cannot actually deref"}, {"sha": "f975b75f0be13daa842c521d4029c21a67637371", "filename": "src/librustc_builtin_macros/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fhash.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -29,7 +29,7 @@ pub fn expand_deriving_hash(\n         is_unsafe: false,\n         supports_unions: false,\n         methods: vec![MethodDef {\n-            name: \"hash\",\n+            name: sym::hash,\n             generics: LifetimeBounds {\n                 lifetimes: Vec::new(),\n                 bounds: vec![(typaram, vec![path_std!(cx, hash::Hasher)])],\n@@ -73,7 +73,7 @@ fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructu\n             let variant_value = deriving::call_intrinsic(\n                 cx,\n                 trait_span,\n-                \"discriminant_value\",\n+                sym::discriminant_value,\n                 vec![cx.expr_self(trait_span)],\n             );\n "}, {"sha": "6cee21fc6e69d4c35e995daee9e9b41ebbda0a35", "filename": "src/librustc_builtin_macros/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fderiving%2Fmod.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -62,11 +62,11 @@ impl MultiItemModifier for BuiltinDerive {\n fn call_intrinsic(\n     cx: &ExtCtxt<'_>,\n     span: Span,\n-    intrinsic: &str,\n+    intrinsic: Symbol,\n     args: Vec<P<ast::Expr>>,\n ) -> P<ast::Expr> {\n     let span = cx.with_def_site_ctxt(span);\n-    let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n+    let path = cx.std_path(&[sym::intrinsics, intrinsic]);\n     let call = cx.expr_call_global(span, path, args);\n \n     cx.expr_block(P(ast::Block {"}, {"sha": "f8a9a97b2a50e15b8a1f492b398bac9c2be8c90b", "filename": "src/librustc_builtin_macros/global_allocator.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Fglobal_allocator.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -79,12 +79,8 @@ impl AllocFnFactory<'_, '_> {\n         self.cx.stmt_item(self.span, item)\n     }\n \n-    fn call_allocator(&self, method: &str, mut args: Vec<P<Expr>>) -> P<Expr> {\n-        let method = self.cx.std_path(&[\n-            Symbol::intern(\"alloc\"),\n-            Symbol::intern(\"GlobalAlloc\"),\n-            Symbol::intern(method),\n-        ]);\n+    fn call_allocator(&self, method: Symbol, mut args: Vec<P<Expr>>) -> P<Expr> {\n+        let method = self.cx.std_path(&[sym::alloc, sym::GlobalAlloc, method]);\n         let method = self.cx.expr_path(self.cx.path(self.span, method));\n         let allocator = self.cx.path_ident(self.span, self.global);\n         let allocator = self.cx.expr_path(allocator);\n@@ -115,11 +111,8 @@ impl AllocFnFactory<'_, '_> {\n                 args.push(self.cx.param(self.span, size, ty_usize.clone()));\n                 args.push(self.cx.param(self.span, align, ty_usize));\n \n-                let layout_new = self.cx.std_path(&[\n-                    Symbol::intern(\"alloc\"),\n-                    Symbol::intern(\"Layout\"),\n-                    Symbol::intern(\"from_size_align_unchecked\"),\n-                ]);\n+                let layout_new =\n+                    self.cx.std_path(&[sym::alloc, sym::Layout, sym::from_size_align_unchecked]);\n                 let layout_new = self.cx.expr_path(self.cx.path(self.span, layout_new));\n                 let size = self.cx.expr_ident(self.span, size);\n                 let align = self.cx.expr_ident(self.span, align);"}, {"sha": "98e42ebf46f2a0bd83b483711730e4af583dbba7", "filename": "src/librustc_builtin_macros/test_harness.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_builtin_macros%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_builtin_macros%2Ftest_harness.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -164,10 +164,8 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainNamed | EntryPointType::MainAttr | EntryPointType::Start => item\n                 .map(|ast::Item { id, ident, attrs, kind, vis, span, tokens }| {\n                     let allow_ident = Ident::new(sym::allow, self.def_site);\n-                    let dc_nested = attr::mk_nested_word_item(Ident::from_str_and_span(\n-                        \"dead_code\",\n-                        self.def_site,\n-                    ));\n+                    let dc_nested =\n+                        attr::mk_nested_word_item(Ident::new(sym::dead_code, self.def_site));\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n                     let attrs = attrs"}, {"sha": "153f0232f3a6cbab0908b44631822bf37dcead65", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 233, "deletions": 197, "changes": 430, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -25,59 +25,59 @@ use rustc_middle::mir::Operand;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n-use rustc_span::Span;\n+use rustc_span::{sym, symbol::kw, Span, Symbol};\n use rustc_target::abi::{self, HasDataLayout, LayoutOf, Primitive};\n use rustc_target::spec::PanicStrategy;\n \n use std::cmp::Ordering;\n use std::iter;\n \n-fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Value> {\n+fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: Symbol) -> Option<&'ll Value> {\n     let llvm_name = match name {\n-        \"sqrtf32\" => \"llvm.sqrt.f32\",\n-        \"sqrtf64\" => \"llvm.sqrt.f64\",\n-        \"powif32\" => \"llvm.powi.f32\",\n-        \"powif64\" => \"llvm.powi.f64\",\n-        \"sinf32\" => \"llvm.sin.f32\",\n-        \"sinf64\" => \"llvm.sin.f64\",\n-        \"cosf32\" => \"llvm.cos.f32\",\n-        \"cosf64\" => \"llvm.cos.f64\",\n-        \"powf32\" => \"llvm.pow.f32\",\n-        \"powf64\" => \"llvm.pow.f64\",\n-        \"expf32\" => \"llvm.exp.f32\",\n-        \"expf64\" => \"llvm.exp.f64\",\n-        \"exp2f32\" => \"llvm.exp2.f32\",\n-        \"exp2f64\" => \"llvm.exp2.f64\",\n-        \"logf32\" => \"llvm.log.f32\",\n-        \"logf64\" => \"llvm.log.f64\",\n-        \"log10f32\" => \"llvm.log10.f32\",\n-        \"log10f64\" => \"llvm.log10.f64\",\n-        \"log2f32\" => \"llvm.log2.f32\",\n-        \"log2f64\" => \"llvm.log2.f64\",\n-        \"fmaf32\" => \"llvm.fma.f32\",\n-        \"fmaf64\" => \"llvm.fma.f64\",\n-        \"fabsf32\" => \"llvm.fabs.f32\",\n-        \"fabsf64\" => \"llvm.fabs.f64\",\n-        \"minnumf32\" => \"llvm.minnum.f32\",\n-        \"minnumf64\" => \"llvm.minnum.f64\",\n-        \"maxnumf32\" => \"llvm.maxnum.f32\",\n-        \"maxnumf64\" => \"llvm.maxnum.f64\",\n-        \"copysignf32\" => \"llvm.copysign.f32\",\n-        \"copysignf64\" => \"llvm.copysign.f64\",\n-        \"floorf32\" => \"llvm.floor.f32\",\n-        \"floorf64\" => \"llvm.floor.f64\",\n-        \"ceilf32\" => \"llvm.ceil.f32\",\n-        \"ceilf64\" => \"llvm.ceil.f64\",\n-        \"truncf32\" => \"llvm.trunc.f32\",\n-        \"truncf64\" => \"llvm.trunc.f64\",\n-        \"rintf32\" => \"llvm.rint.f32\",\n-        \"rintf64\" => \"llvm.rint.f64\",\n-        \"nearbyintf32\" => \"llvm.nearbyint.f32\",\n-        \"nearbyintf64\" => \"llvm.nearbyint.f64\",\n-        \"roundf32\" => \"llvm.round.f32\",\n-        \"roundf64\" => \"llvm.round.f64\",\n-        \"assume\" => \"llvm.assume\",\n-        \"abort\" => \"llvm.trap\",\n+        sym::sqrtf32 => \"llvm.sqrt.f32\",\n+        sym::sqrtf64 => \"llvm.sqrt.f64\",\n+        sym::powif32 => \"llvm.powi.f32\",\n+        sym::powif64 => \"llvm.powi.f64\",\n+        sym::sinf32 => \"llvm.sin.f32\",\n+        sym::sinf64 => \"llvm.sin.f64\",\n+        sym::cosf32 => \"llvm.cos.f32\",\n+        sym::cosf64 => \"llvm.cos.f64\",\n+        sym::powf32 => \"llvm.pow.f32\",\n+        sym::powf64 => \"llvm.pow.f64\",\n+        sym::expf32 => \"llvm.exp.f32\",\n+        sym::expf64 => \"llvm.exp.f64\",\n+        sym::exp2f32 => \"llvm.exp2.f32\",\n+        sym::exp2f64 => \"llvm.exp2.f64\",\n+        sym::logf32 => \"llvm.log.f32\",\n+        sym::logf64 => \"llvm.log.f64\",\n+        sym::log10f32 => \"llvm.log10.f32\",\n+        sym::log10f64 => \"llvm.log10.f64\",\n+        sym::log2f32 => \"llvm.log2.f32\",\n+        sym::log2f64 => \"llvm.log2.f64\",\n+        sym::fmaf32 => \"llvm.fma.f32\",\n+        sym::fmaf64 => \"llvm.fma.f64\",\n+        sym::fabsf32 => \"llvm.fabs.f32\",\n+        sym::fabsf64 => \"llvm.fabs.f64\",\n+        sym::minnumf32 => \"llvm.minnum.f32\",\n+        sym::minnumf64 => \"llvm.minnum.f64\",\n+        sym::maxnumf32 => \"llvm.maxnum.f32\",\n+        sym::maxnumf64 => \"llvm.maxnum.f64\",\n+        sym::copysignf32 => \"llvm.copysign.f32\",\n+        sym::copysignf64 => \"llvm.copysign.f64\",\n+        sym::floorf32 => \"llvm.floor.f32\",\n+        sym::floorf64 => \"llvm.floor.f64\",\n+        sym::ceilf32 => \"llvm.ceil.f32\",\n+        sym::ceilf64 => \"llvm.ceil.f64\",\n+        sym::truncf32 => \"llvm.trunc.f32\",\n+        sym::truncf64 => \"llvm.trunc.f64\",\n+        sym::rintf32 => \"llvm.rint.f32\",\n+        sym::rintf64 => \"llvm.rint.f64\",\n+        sym::nearbyintf32 => \"llvm.nearbyint.f32\",\n+        sym::nearbyintf64 => \"llvm.nearbyint.f64\",\n+        sym::roundf32 => \"llvm.round.f32\",\n+        sym::roundf64 => \"llvm.round.f64\",\n+        sym::assume => \"llvm.assume\",\n+        sym::abort => \"llvm.trap\",\n         _ => return None,\n     };\n     Some(cx.get_intrinsic(&llvm_name))\n@@ -86,12 +86,12 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n     fn is_codegen_intrinsic(\n         &mut self,\n-        intrinsic: &str,\n+        intrinsic: Symbol,\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool {\n         match intrinsic {\n-            \"count_code_region\" => {\n+            sym::count_code_region => {\n                 use coverage::count_code_region_args::*;\n                 self.add_counter_region(\n                     caller_instance,\n@@ -101,13 +101,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 true // Also inject the counter increment in the backend\n             }\n-            \"coverage_counter_add\" | \"coverage_counter_subtract\" => {\n+            sym::coverage_counter_add | sym::coverage_counter_subtract => {\n                 use coverage::coverage_counter_expression_args::*;\n                 self.add_counter_expression_region(\n                     caller_instance,\n                     op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n                     op_to_u32(&args[LEFT_INDEX]),\n-                    if intrinsic == \"coverage_counter_add\" {\n+                    if intrinsic == sym::coverage_counter_add {\n                         CounterOp::Add\n                     } else {\n                         CounterOp::Subtract\n@@ -118,7 +118,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 false // Does not inject backend code\n             }\n-            \"coverage_unreachable\" => {\n+            sym::coverage_unreachable => {\n                 use coverage::coverage_unreachable_args::*;\n                 self.add_unreachable_region(\n                     caller_instance,\n@@ -152,7 +152,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         let sig = tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &sig);\n         let arg_tys = sig.inputs();\n         let ret_ty = sig.output();\n-        let name = &*tcx.item_name(def_id).as_str();\n+        let name = tcx.item_name(def_id);\n+        let name_str = &*name.as_str();\n \n         let llret_ty = self.layout_of(ret_ty).llvm_type(self);\n         let result = PlaceRef::new_sized(llresult, fn_abi.ret.layout);\n@@ -164,18 +165,18 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                 None,\n             ),\n-            \"unreachable\" => {\n+            sym::unreachable => {\n                 return;\n             }\n-            \"likely\" => {\n+            sym::likely => {\n                 let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n                 self.call(expect, &[args[0].immediate(), self.const_bool(true)], None)\n             }\n-            \"unlikely\" => {\n+            sym::unlikely => {\n                 let expect = self.get_intrinsic(&(\"llvm.expect.i1\"));\n                 self.call(expect, &[args[0].immediate(), self.const_bool(false)], None)\n             }\n-            \"try\" => {\n+            kw::Try => {\n                 try_intrinsic(\n                     self,\n                     args[0].immediate(),\n@@ -185,11 +186,11 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            \"breakpoint\" => {\n+            sym::breakpoint => {\n                 let llfn = self.get_intrinsic(&(\"llvm.debugtrap\"));\n                 self.call(llfn, &[], None)\n             }\n-            \"count_code_region\" => {\n+            sym::count_code_region => {\n                 // FIXME(richkadel): The current implementation assumes the MIR for the given\n                 // caller_instance represents a single function. Validate and/or correct if inlining\n                 // and/or monomorphization invalidates these assumptions.\n@@ -206,13 +207,13 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }\n-            \"va_start\" => self.va_start(args[0].immediate()),\n-            \"va_end\" => self.va_end(args[0].immediate()),\n-            \"va_copy\" => {\n+            sym::va_start => self.va_start(args[0].immediate()),\n+            sym::va_end => self.va_end(args[0].immediate()),\n+            sym::va_copy => {\n                 let intrinsic = self.cx().get_intrinsic(&(\"llvm.va_copy\"));\n                 self.call(intrinsic, &[args[0].immediate(), args[1].immediate()], None)\n             }\n-            \"va_arg\" => {\n+            sym::va_arg => {\n                 match fn_abi.ret.layout.abi {\n                     abi::Abi::Scalar(ref scalar) => {\n                         match scalar.value {\n@@ -238,7 +239,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     _ => bug!(\"the va_arg intrinsic does not work with non-scalar types\"),\n                 }\n             }\n-            \"size_of_val\" => {\n+            sym::size_of_val => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n                     let (llsize, _) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n@@ -247,7 +248,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.const_usize(self.size_of(tp_ty).bytes())\n                 }\n             }\n-            \"min_align_of_val\" => {\n+            sym::min_align_of_val => {\n                 let tp_ty = substs.type_at(0);\n                 if let OperandValue::Pair(_, meta) = args[0].val {\n                     let (_, llalign) = glue::size_and_align_of_dst(self, tp_ty, Some(meta));\n@@ -256,30 +257,35 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     self.const_usize(self.align_of(tp_ty).bytes())\n                 }\n             }\n-            \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"needs_drop\" | \"type_id\"\n-            | \"type_name\" | \"variant_count\" => {\n+            sym::size_of\n+            | sym::pref_align_of\n+            | sym::min_align_of\n+            | sym::needs_drop\n+            | sym::type_id\n+            | sym::type_name\n+            | sym::variant_count => {\n                 let value = self\n                     .tcx\n                     .const_eval_instance(ty::ParamEnv::reveal_all(), instance, None)\n                     .unwrap();\n                 OperandRef::from_const(self, value, ret_ty).immediate_or_packed_pair(self)\n             }\n             // Effectively no-op\n-            \"forget\" => {\n+            sym::forget => {\n                 return;\n             }\n-            \"offset\" => {\n+            sym::offset => {\n                 let ptr = args[0].immediate();\n                 let offset = args[1].immediate();\n                 self.inbounds_gep(ptr, &[offset])\n             }\n-            \"arith_offset\" => {\n+            sym::arith_offset => {\n                 let ptr = args[0].immediate();\n                 let offset = args[1].immediate();\n                 self.gep(ptr, &[offset])\n             }\n \n-            \"copy_nonoverlapping\" => {\n+            sym::copy_nonoverlapping => {\n                 copy_intrinsic(\n                     self,\n                     false,\n@@ -291,7 +297,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            \"copy\" => {\n+            sym::copy => {\n                 copy_intrinsic(\n                     self,\n                     true,\n@@ -303,7 +309,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            \"write_bytes\" => {\n+            sym::write_bytes => {\n                 memset_intrinsic(\n                     self,\n                     false,\n@@ -315,7 +321,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 return;\n             }\n \n-            \"volatile_copy_nonoverlapping_memory\" => {\n+            sym::volatile_copy_nonoverlapping_memory => {\n                 copy_intrinsic(\n                     self,\n                     false,\n@@ -327,7 +333,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            \"volatile_copy_memory\" => {\n+            sym::volatile_copy_memory => {\n                 copy_intrinsic(\n                     self,\n                     true,\n@@ -339,7 +345,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            \"volatile_set_memory\" => {\n+            sym::volatile_set_memory => {\n                 memset_intrinsic(\n                     self,\n                     true,\n@@ -350,14 +356,14 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 );\n                 return;\n             }\n-            \"volatile_load\" | \"unaligned_volatile_load\" => {\n+            sym::volatile_load | sym::unaligned_volatile_load => {\n                 let tp_ty = substs.type_at(0);\n                 let mut ptr = args[0].immediate();\n                 if let PassMode::Cast(ty) = fn_abi.ret.mode {\n                     ptr = self.pointercast(ptr, self.type_ptr_to(ty.llvm_type(self)));\n                 }\n                 let load = self.volatile_load(ptr);\n-                let align = if name == \"unaligned_volatile_load\" {\n+                let align = if name == sym::unaligned_volatile_load {\n                     1\n                 } else {\n                     self.align_of(tp_ty).bytes() as u32\n@@ -367,26 +373,26 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n                 to_immediate(self, load, self.layout_of(tp_ty))\n             }\n-            \"volatile_store\" => {\n+            sym::volatile_store => {\n                 let dst = args[0].deref(self.cx());\n                 args[1].val.volatile_store(self, dst);\n                 return;\n             }\n-            \"unaligned_volatile_store\" => {\n+            sym::unaligned_volatile_store => {\n                 let dst = args[0].deref(self.cx());\n                 args[1].val.unaligned_volatile_store(self, dst);\n                 return;\n             }\n-            \"prefetch_read_data\"\n-            | \"prefetch_write_data\"\n-            | \"prefetch_read_instruction\"\n-            | \"prefetch_write_instruction\" => {\n+            sym::prefetch_read_data\n+            | sym::prefetch_write_data\n+            | sym::prefetch_read_instruction\n+            | sym::prefetch_write_instruction => {\n                 let expect = self.get_intrinsic(&(\"llvm.prefetch\"));\n                 let (rw, cache_type) = match name {\n-                    \"prefetch_read_data\" => (0, 1),\n-                    \"prefetch_write_data\" => (1, 1),\n-                    \"prefetch_read_instruction\" => (0, 0),\n-                    \"prefetch_write_instruction\" => (1, 0),\n+                    sym::prefetch_read_data => (0, 1),\n+                    sym::prefetch_write_data => (1, 1),\n+                    sym::prefetch_read_instruction => (0, 0),\n+                    sym::prefetch_write_instruction => (1, 0),\n                     _ => bug!(),\n                 };\n                 self.call(\n@@ -400,32 +406,51 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     None,\n                 )\n             }\n-            \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\"\n-            | \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\"\n-            | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" | \"unchecked_div\"\n-            | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"unchecked_add\"\n-            | \"unchecked_sub\" | \"unchecked_mul\" | \"exact_div\" | \"rotate_left\" | \"rotate_right\"\n-            | \"saturating_add\" | \"saturating_sub\" => {\n+            sym::ctlz\n+            | sym::ctlz_nonzero\n+            | sym::cttz\n+            | sym::cttz_nonzero\n+            | sym::ctpop\n+            | sym::bswap\n+            | sym::bitreverse\n+            | sym::add_with_overflow\n+            | sym::sub_with_overflow\n+            | sym::mul_with_overflow\n+            | sym::wrapping_add\n+            | sym::wrapping_sub\n+            | sym::wrapping_mul\n+            | sym::unchecked_div\n+            | sym::unchecked_rem\n+            | sym::unchecked_shl\n+            | sym::unchecked_shr\n+            | sym::unchecked_add\n+            | sym::unchecked_sub\n+            | sym::unchecked_mul\n+            | sym::exact_div\n+            | sym::rotate_left\n+            | sym::rotate_right\n+            | sym::saturating_add\n+            | sym::saturating_sub => {\n                 let ty = arg_tys[0];\n                 match int_type_width_signed(ty, self) {\n                     Some((width, signed)) => match name {\n-                        \"ctlz\" | \"cttz\" => {\n+                        sym::ctlz | sym::cttz => {\n                             let y = self.const_bool(false);\n                             let llfn = self.get_intrinsic(&format!(\"llvm.{}.i{}\", name, width));\n                             self.call(llfn, &[args[0].immediate(), y], None)\n                         }\n-                        \"ctlz_nonzero\" | \"cttz_nonzero\" => {\n+                        sym::ctlz_nonzero | sym::cttz_nonzero => {\n                             let y = self.const_bool(true);\n-                            let llvm_name = &format!(\"llvm.{}.i{}\", &name[..4], width);\n+                            let llvm_name = &format!(\"llvm.{}.i{}\", &name_str[..4], width);\n                             let llfn = self.get_intrinsic(llvm_name);\n                             self.call(llfn, &[args[0].immediate(), y], None)\n                         }\n-                        \"ctpop\" => self.call(\n+                        sym::ctpop => self.call(\n                             self.get_intrinsic(&format!(\"llvm.ctpop.i{}\", width)),\n                             &[args[0].immediate()],\n                             None,\n                         ),\n-                        \"bswap\" => {\n+                        sym::bswap => {\n                             if width == 8 {\n                                 args[0].immediate() // byte swap a u8/i8 is just a no-op\n                             } else {\n@@ -436,16 +461,18 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                                 )\n                             }\n                         }\n-                        \"bitreverse\" => self.call(\n+                        sym::bitreverse => self.call(\n                             self.get_intrinsic(&format!(\"llvm.bitreverse.i{}\", width)),\n                             &[args[0].immediate()],\n                             None,\n                         ),\n-                        \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n+                        sym::add_with_overflow\n+                        | sym::sub_with_overflow\n+                        | sym::mul_with_overflow => {\n                             let intrinsic = format!(\n                                 \"llvm.{}{}.with.overflow.i{}\",\n                                 if signed { 's' } else { 'u' },\n-                                &name[..3],\n+                                &name_str[..3],\n                                 width\n                             );\n                             let llfn = self.get_intrinsic(&intrinsic);\n@@ -464,61 +491,61 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n \n                             return;\n                         }\n-                        \"wrapping_add\" => self.add(args[0].immediate(), args[1].immediate()),\n-                        \"wrapping_sub\" => self.sub(args[0].immediate(), args[1].immediate()),\n-                        \"wrapping_mul\" => self.mul(args[0].immediate(), args[1].immediate()),\n-                        \"exact_div\" => {\n+                        sym::wrapping_add => self.add(args[0].immediate(), args[1].immediate()),\n+                        sym::wrapping_sub => self.sub(args[0].immediate(), args[1].immediate()),\n+                        sym::wrapping_mul => self.mul(args[0].immediate(), args[1].immediate()),\n+                        sym::exact_div => {\n                             if signed {\n                                 self.exactsdiv(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.exactudiv(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"unchecked_div\" => {\n+                        sym::unchecked_div => {\n                             if signed {\n                                 self.sdiv(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.udiv(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"unchecked_rem\" => {\n+                        sym::unchecked_rem => {\n                             if signed {\n                                 self.srem(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.urem(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"unchecked_shl\" => self.shl(args[0].immediate(), args[1].immediate()),\n-                        \"unchecked_shr\" => {\n+                        sym::unchecked_shl => self.shl(args[0].immediate(), args[1].immediate()),\n+                        sym::unchecked_shr => {\n                             if signed {\n                                 self.ashr(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.lshr(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"unchecked_add\" => {\n+                        sym::unchecked_add => {\n                             if signed {\n                                 self.unchecked_sadd(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.unchecked_uadd(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"unchecked_sub\" => {\n+                        sym::unchecked_sub => {\n                             if signed {\n                                 self.unchecked_ssub(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.unchecked_usub(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"unchecked_mul\" => {\n+                        sym::unchecked_mul => {\n                             if signed {\n                                 self.unchecked_smul(args[0].immediate(), args[1].immediate())\n                             } else {\n                                 self.unchecked_umul(args[0].immediate(), args[1].immediate())\n                             }\n                         }\n-                        \"rotate_left\" | \"rotate_right\" => {\n-                            let is_left = name == \"rotate_left\";\n+                        sym::rotate_left | sym::rotate_right => {\n+                            let is_left = name == sym::rotate_left;\n                             let val = args[0].immediate();\n                             let raw_shift = args[1].immediate();\n                             // rotate = funnel shift with first two args the same\n@@ -527,8 +554,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                             let llfn = self.get_intrinsic(llvm_name);\n                             self.call(llfn, &[val, val, raw_shift], None)\n                         }\n-                        \"saturating_add\" | \"saturating_sub\" => {\n-                            let is_add = name == \"saturating_add\";\n+                        sym::saturating_add | sym::saturating_sub => {\n+                            let is_add = name == sym::saturating_add;\n                             let lhs = args[0].immediate();\n                             let rhs = args[1].immediate();\n                             let llvm_name = &format!(\n@@ -556,14 +583,14 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     }\n                 }\n             }\n-            \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n+            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n                 match float_type_width(arg_tys[0]) {\n                     Some(_width) => match name {\n-                        \"fadd_fast\" => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fsub_fast\" => self.fsub_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fmul_fast\" => self.fmul_fast(args[0].immediate(), args[1].immediate()),\n-                        \"fdiv_fast\" => self.fdiv_fast(args[0].immediate(), args[1].immediate()),\n-                        \"frem_fast\" => self.frem_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fadd_fast => self.fadd_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fsub_fast => self.fsub_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fmul_fast => self.fmul_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::fdiv_fast => self.fdiv_fast(args[0].immediate(), args[1].immediate()),\n+                        sym::frem_fast => self.frem_fast(args[0].immediate(), args[1].immediate()),\n                         _ => bug!(),\n                     },\n                     None => {\n@@ -581,7 +608,7 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n-            \"float_to_int_unchecked\" => {\n+            sym::float_to_int_unchecked => {\n                 if float_type_width(arg_tys[0]).is_none() {\n                     span_invalid_monomorphization_error(\n                         tcx.sess,\n@@ -619,27 +646,27 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n-            \"discriminant_value\" => {\n+            sym::discriminant_value => {\n                 if ret_ty.is_integral() {\n                     args[0].deref(self.cx()).codegen_get_discr(self, ret_ty)\n                 } else {\n                     span_bug!(span, \"Invalid discriminant type for `{:?}`\", arg_tys[0])\n                 }\n             }\n \n-            name if name.starts_with(\"simd_\") => {\n+            _ if name_str.starts_with(\"simd_\") => {\n                 match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                     Ok(llval) => llval,\n                     Err(()) => return,\n                 }\n             }\n             // This requires that atomic intrinsics follow a specific naming pattern:\n             // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n-            name if name.starts_with(\"atomic_\") => {\n+            name if name_str.starts_with(\"atomic_\") => {\n                 use rustc_codegen_ssa::common::AtomicOrdering::*;\n                 use rustc_codegen_ssa::common::{AtomicRmwBinOp, SynchronizationScope};\n \n-                let split: Vec<&str> = name.split('_').collect();\n+                let split: Vec<&str> = name_str.split('_').collect();\n \n                 let is_cxchg = split[1] == \"cxchg\" || split[1] == \"cxchgweak\";\n                 let (order, failorder) = match split.len() {\n@@ -769,23 +796,23 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 }\n             }\n \n-            \"nontemporal_store\" => {\n+            sym::nontemporal_store => {\n                 let dst = args[0].deref(self.cx());\n                 args[1].val.nontemporal_store(self, dst);\n                 return;\n             }\n \n-            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n                 let a = args[0].immediate();\n                 let b = args[1].immediate();\n-                if name == \"ptr_guaranteed_eq\" {\n+                if name == sym::ptr_guaranteed_eq {\n                     self.icmp(IntPredicate::IntEQ, a, b)\n                 } else {\n                     self.icmp(IntPredicate::IntNE, a, b)\n                 }\n             }\n \n-            \"ptr_offset_from\" => {\n+            sym::ptr_offset_from => {\n                 let ty = substs.type_at(0);\n                 let pointee_size = self.size_of(ty);\n \n@@ -1172,7 +1199,7 @@ fn get_rust_try_fn<'ll, 'tcx>(\n \n fn generic_simd_intrinsic(\n     bx: &mut Builder<'a, 'll, 'tcx>,\n-    name: &str,\n+    name: Symbol,\n     callee_ty: Ty<'tcx>,\n     args: &[OperandRef<'tcx, &'ll Value>],\n     ret_ty: Ty<'tcx>,\n@@ -1219,8 +1246,9 @@ fn generic_simd_intrinsic(\n     let sig = tcx\n         .normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &callee_ty.fn_sig(tcx));\n     let arg_tys = sig.inputs();\n+    let name_str = &*name.as_str();\n \n-    if name == \"simd_select_bitmask\" {\n+    if name == sym::simd_select_bitmask {\n         let in_ty = arg_tys[0];\n         let m_len = match in_ty.kind {\n             // Note that this `.unwrap()` crashes for isize/usize, that's sort\n@@ -1250,12 +1278,12 @@ fn generic_simd_intrinsic(\n     let in_len = arg_tys[0].simd_size(tcx);\n \n     let comparison = match name {\n-        \"simd_eq\" => Some(hir::BinOpKind::Eq),\n-        \"simd_ne\" => Some(hir::BinOpKind::Ne),\n-        \"simd_lt\" => Some(hir::BinOpKind::Lt),\n-        \"simd_le\" => Some(hir::BinOpKind::Le),\n-        \"simd_gt\" => Some(hir::BinOpKind::Gt),\n-        \"simd_ge\" => Some(hir::BinOpKind::Ge),\n+        sym::simd_eq => Some(hir::BinOpKind::Eq),\n+        sym::simd_ne => Some(hir::BinOpKind::Ne),\n+        sym::simd_lt => Some(hir::BinOpKind::Lt),\n+        sym::simd_le => Some(hir::BinOpKind::Le),\n+        sym::simd_gt => Some(hir::BinOpKind::Gt),\n+        sym::simd_ge => Some(hir::BinOpKind::Ge),\n         _ => None,\n     };\n \n@@ -1289,8 +1317,8 @@ fn generic_simd_intrinsic(\n         ));\n     }\n \n-    if name.starts_with(\"simd_shuffle\") {\n-        let n: u64 = name[\"simd_shuffle\".len()..].parse().unwrap_or_else(|_| {\n+    if name_str.starts_with(\"simd_shuffle\") {\n+        let n: u64 = name_str[\"simd_shuffle\".len()..].parse().unwrap_or_else(|_| {\n             span_bug!(span, \"bad `simd_shuffle` instruction only caught in codegen?\")\n         });\n \n@@ -1351,7 +1379,7 @@ fn generic_simd_intrinsic(\n         ));\n     }\n \n-    if name == \"simd_insert\" {\n+    if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n             \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n@@ -1365,7 +1393,7 @@ fn generic_simd_intrinsic(\n             args[1].immediate(),\n         ));\n     }\n-    if name == \"simd_extract\" {\n+    if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n             \"expected return type `{}` (element of input `{}`), found `{}`\",\n@@ -1376,7 +1404,7 @@ fn generic_simd_intrinsic(\n         return Ok(bx.extract_element(args[0].immediate(), args[1].immediate()));\n     }\n \n-    if name == \"simd_select\" {\n+    if name == sym::simd_select {\n         let m_elem_ty = in_elem;\n         let m_len = in_len;\n         require_simd!(arg_tys[1], \"argument\");\n@@ -1398,7 +1426,7 @@ fn generic_simd_intrinsic(\n         return Ok(bx.select(m_i1s, args[1].immediate(), args[2].immediate()));\n     }\n \n-    if name == \"simd_bitmask\" {\n+    if name == sym::simd_bitmask {\n         // The `fn simd_bitmask(vector) -> unsigned integer` intrinsic takes a\n         // vector mask and returns an unsigned integer containing the most\n         // significant bit (MSB) of each lane.\n@@ -1513,46 +1541,46 @@ fn generic_simd_intrinsic(\n     }\n \n     match name {\n-        \"simd_fsqrt\" => {\n+        sym::simd_fsqrt => {\n             return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fsin\" => {\n+        sym::simd_fsin => {\n             return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fcos\" => {\n+        sym::simd_fcos => {\n             return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fabs\" => {\n+        sym::simd_fabs => {\n             return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_floor\" => {\n+        sym::simd_floor => {\n             return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_ceil\" => {\n+        sym::simd_ceil => {\n             return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fexp\" => {\n+        sym::simd_fexp => {\n             return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fexp2\" => {\n+        sym::simd_fexp2 => {\n             return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_flog10\" => {\n+        sym::simd_flog10 => {\n             return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_flog2\" => {\n+        sym::simd_flog2 => {\n             return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_flog\" => {\n+        sym::simd_flog => {\n             return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fpowi\" => {\n+        sym::simd_fpowi => {\n             return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fpow\" => {\n+        sym::simd_fpow => {\n             return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n         }\n-        \"simd_fma\" => {\n+        sym::simd_fma => {\n             return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n         }\n         _ => { /* fallthrough */ }\n@@ -1591,7 +1619,7 @@ fn generic_simd_intrinsic(\n         cx.type_vector(elem_ty, vec_len)\n     }\n \n-    if name == \"simd_gather\" {\n+    if name == sym::simd_gather {\n         // simd_gather(values: <N x T>, pointers: <N x *_ T>,\n         //             mask: <N x i{M}>) -> <N x T>\n         // * N: number of elements in the input vectors\n@@ -1718,7 +1746,7 @@ fn generic_simd_intrinsic(\n         return Ok(v);\n     }\n \n-    if name == \"simd_scatter\" {\n+    if name == sym::simd_scatter {\n         // simd_scatter(values: <N x T>, pointers: <N x *mut T>,\n         //             mask: <N x i{M}>) -> ()\n         // * N: number of elements in the input vectors\n@@ -1841,8 +1869,9 @@ fn generic_simd_intrinsic(\n     }\n \n     macro_rules! arith_red {\n-        ($name:tt : $integer_reduce:ident, $float_reduce:ident, $ordered:expr) => {\n-            if name == $name {\n+        ($name:ident : $integer_reduce:ident, $float_reduce:ident, $ordered:expr, $op:ident,\n+         $identity:expr) => {\n+            if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n                     \"expected return type `{}` (element of input `{}`), found `{}`\",\n@@ -1856,11 +1885,7 @@ fn generic_simd_intrinsic(\n                         if $ordered {\n                             // if overflow occurs, the result is the\n                             // mathematical result modulo 2^n:\n-                            if name.contains(\"mul\") {\n-                                Ok(bx.mul(args[1].immediate(), r))\n-                            } else {\n-                                Ok(bx.add(args[1].immediate(), r))\n-                            }\n+                            Ok(bx.$op(args[1].immediate(), r))\n                         } else {\n                             Ok(bx.$integer_reduce(args[0].immediate()))\n                         }\n@@ -1871,14 +1896,13 @@ fn generic_simd_intrinsic(\n                             args[1].immediate()\n                         } else {\n                             // unordered arithmetic reductions use the identity accumulator\n-                            let identity_acc = if $name.contains(\"mul\") { 1.0 } else { 0.0 };\n                             match f.bit_width() {\n-                                32 => bx.const_real(bx.type_f32(), identity_acc),\n-                                64 => bx.const_real(bx.type_f64(), identity_acc),\n+                                32 => bx.const_real(bx.type_f32(), $identity),\n+                                64 => bx.const_real(bx.type_f64(), $identity),\n                                 v => return_error!(\n                                     r#\"\n unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n-                                    $name,\n+                                    sym::$name,\n                                     in_ty,\n                                     in_elem,\n                                     v,\n@@ -1890,7 +1914,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     }\n                     _ => return_error!(\n                         \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        $name,\n+                        sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n@@ -1900,14 +1924,26 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         };\n     }\n \n-    arith_red!(\"simd_reduce_add_ordered\": vector_reduce_add, vector_reduce_fadd, true);\n-    arith_red!(\"simd_reduce_mul_ordered\": vector_reduce_mul, vector_reduce_fmul, true);\n-    arith_red!(\"simd_reduce_add_unordered\": vector_reduce_add, vector_reduce_fadd_fast, false);\n-    arith_red!(\"simd_reduce_mul_unordered\": vector_reduce_mul, vector_reduce_fmul_fast, false);\n+    arith_red!(simd_reduce_add_ordered: vector_reduce_add, vector_reduce_fadd, true, add, 0.0);\n+    arith_red!(simd_reduce_mul_ordered: vector_reduce_mul, vector_reduce_fmul, true, mul, 1.0);\n+    arith_red!(\n+        simd_reduce_add_unordered: vector_reduce_add,\n+        vector_reduce_fadd_fast,\n+        false,\n+        add,\n+        0.0\n+    );\n+    arith_red!(\n+        simd_reduce_mul_unordered: vector_reduce_mul,\n+        vector_reduce_fmul_fast,\n+        false,\n+        mul,\n+        1.0\n+    );\n \n     macro_rules! minmax_red {\n-        ($name:tt: $int_red:ident, $float_red:ident) => {\n-            if name == $name {\n+        ($name:ident: $int_red:ident, $float_red:ident) => {\n+            if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n                     \"expected return type `{}` (element of input `{}`), found `{}`\",\n@@ -1921,7 +1957,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     ty::Float(_f) => Ok(bx.$float_red(args[0].immediate())),\n                     _ => return_error!(\n                         \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        $name,\n+                        sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n@@ -1931,15 +1967,15 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         };\n     }\n \n-    minmax_red!(\"simd_reduce_min\": vector_reduce_min, vector_reduce_fmin);\n-    minmax_red!(\"simd_reduce_max\": vector_reduce_max, vector_reduce_fmax);\n+    minmax_red!(simd_reduce_min: vector_reduce_min, vector_reduce_fmin);\n+    minmax_red!(simd_reduce_max: vector_reduce_max, vector_reduce_fmax);\n \n-    minmax_red!(\"simd_reduce_min_nanless\": vector_reduce_min, vector_reduce_fmin_fast);\n-    minmax_red!(\"simd_reduce_max_nanless\": vector_reduce_max, vector_reduce_fmax_fast);\n+    minmax_red!(simd_reduce_min_nanless: vector_reduce_min, vector_reduce_fmin_fast);\n+    minmax_red!(simd_reduce_max_nanless: vector_reduce_max, vector_reduce_fmax_fast);\n \n     macro_rules! bitwise_red {\n-        ($name:tt : $red:ident, $boolean:expr) => {\n-            if name == $name {\n+        ($name:ident : $red:ident, $boolean:expr) => {\n+            if name == sym::$name {\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n@@ -1954,7 +1990,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                         ty::Int(_) | ty::Uint(_) => {}\n                         _ => return_error!(\n                             \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            $name,\n+                            sym::$name,\n                             in_ty,\n                             in_elem,\n                             ret_ty\n@@ -1973,7 +2009,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                     }\n                     _ => return_error!(\n                         \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        $name,\n+                        sym::$name,\n                         in_ty,\n                         in_elem,\n                         ret_ty\n@@ -1983,13 +2019,13 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         };\n     }\n \n-    bitwise_red!(\"simd_reduce_and\": vector_reduce_and, false);\n-    bitwise_red!(\"simd_reduce_or\": vector_reduce_or, false);\n-    bitwise_red!(\"simd_reduce_xor\": vector_reduce_xor, false);\n-    bitwise_red!(\"simd_reduce_all\": vector_reduce_and, true);\n-    bitwise_red!(\"simd_reduce_any\": vector_reduce_or, true);\n+    bitwise_red!(simd_reduce_and: vector_reduce_and, false);\n+    bitwise_red!(simd_reduce_or: vector_reduce_or, false);\n+    bitwise_red!(simd_reduce_xor: vector_reduce_xor, false);\n+    bitwise_red!(simd_reduce_all: vector_reduce_and, true);\n+    bitwise_red!(simd_reduce_any: vector_reduce_or, true);\n \n-    if name == \"simd_cast\" {\n+    if name == sym::simd_cast {\n         require_simd!(ret_ty, \"return\");\n         let out_len = ret_ty.simd_size(tcx);\n         require!(\n@@ -2077,7 +2113,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n     }\n     macro_rules! arith {\n         ($($name: ident: $($($p: ident),* => $call: ident),*;)*) => {\n-            $(if name == stringify!($name) {\n+            $(if name == sym::$name {\n                 match in_elem.kind {\n                     $($(ty::$p(_))|* => {\n                         return Ok(bx.$call(args[0].immediate(), args[1].immediate()))\n@@ -2107,10 +2143,10 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n \n     }\n \n-    if name == \"simd_saturating_add\" || name == \"simd_saturating_sub\" {\n+    if name == sym::simd_saturating_add || name == sym::simd_saturating_sub {\n         let lhs = args[0].immediate();\n         let rhs = args[1].immediate();\n-        let is_add = name == \"simd_saturating_add\";\n+        let is_add = name == sym::simd_saturating_add;\n         let ptr_bits = bx.tcx().data_layout.pointer_size.bits() as _;\n         let (signed, elem_width, elem_ty) = match in_elem.kind {\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),"}, {"sha": "faf6809f35b1c3d6a1f612770d0e6b1190f586ba", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -16,6 +16,7 @@ use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n use rustc_middle::ty::Instance;\n use rustc_middle::ty::{SymbolName, TyCtxt};\n use rustc_session::config::{CrateType, SanitizerSet};\n+use rustc_span::symbol::sym;\n \n pub fn threshold(tcx: TyCtxt<'_>) -> SymbolExportLevel {\n     crates_export_threshold(&tcx.sess.crate_types())\n@@ -107,21 +108,20 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n         })\n         .map(|def_id| {\n             let export_level = if special_runtime_crate {\n-                let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name.as_str();\n+                let name = tcx.symbol_name(Instance::mono(tcx, def_id.to_def_id())).name;\n                 // We can probably do better here by just ensuring that\n                 // it has hidden visibility rather than public\n                 // visibility, as this is primarily here to ensure it's\n                 // not stripped during LTO.\n                 //\n                 // In general though we won't link right if these\n                 // symbols are stripped, and LTO currently strips them.\n-                if name == \"rust_eh_personality\"\n-                    || name == \"rust_eh_register_frames\"\n-                    || name == \"rust_eh_unregister_frames\"\n-                {\n-                    SymbolExportLevel::C\n-                } else {\n-                    SymbolExportLevel::Rust\n+                match name {\n+                    sym::rust_eh_personality\n+                    | sym::rust_eh_register_frames\n+                    | sym::rust_eh_unregister_frames =>\n+                        SymbolExportLevel::C,\n+                    _ => SymbolExportLevel::Rust,\n                 }\n             } else {\n                 symbol_export_level(tcx, def_id.to_def_id())"}, {"sha": "7116bb8c92517d3fbf1fba318f5db2e30700ac9e", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -17,7 +17,8 @@ use rustc_middle::mir::interpret::{AllocId, ConstValue, Pointer, Scalar};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n-use rustc_span::{source_map::Span, symbol::Symbol};\n+use rustc_span::source_map::Span;\n+use rustc_span::{sym, Symbol};\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n use rustc_target::abi::{self, LayoutOf};\n use rustc_target::spec::abi::Abi;\n@@ -445,7 +446,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         &mut self,\n         helper: &TerminatorCodegenHelper<'tcx>,\n         bx: &mut Bx,\n-        intrinsic: Option<&str>,\n+        intrinsic: Option<Symbol>,\n         instance: Option<Instance<'tcx>>,\n         span: Span,\n         destination: &Option<(mir::Place<'tcx>, mir::BasicBlock)>,\n@@ -461,10 +462,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             UninitValid,\n         };\n         let panic_intrinsic = intrinsic.and_then(|i| match i {\n-            // FIXME: Move to symbols instead of strings.\n-            \"assert_inhabited\" => Some(AssertIntrinsic::Inhabited),\n-            \"assert_zero_valid\" => Some(AssertIntrinsic::ZeroValid),\n-            \"assert_uninit_valid\" => Some(AssertIntrinsic::UninitValid),\n+            sym::assert_inhabited => Some(AssertIntrinsic::Inhabited),\n+            sym::assert_zero_valid => Some(AssertIntrinsic::ZeroValid),\n+            sym::assert_uninit_valid => Some(AssertIntrinsic::UninitValid),\n             _ => None,\n         });\n         if let Some(intrinsic) = panic_intrinsic {\n@@ -568,10 +568,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // Handle intrinsics old codegen wants Expr's for, ourselves.\n         let intrinsic = match def {\n-            Some(ty::InstanceDef::Intrinsic(def_id)) => Some(bx.tcx().item_name(def_id).as_str()),\n+            Some(ty::InstanceDef::Intrinsic(def_id)) => Some(bx.tcx().item_name(def_id)),\n             _ => None,\n         };\n-        let intrinsic = intrinsic.as_ref().map(|s| &s[..]);\n \n         let extra_args = &args[sig.inputs().skip_binder().len()..];\n         let extra_args = extra_args\n@@ -587,7 +586,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             None => FnAbi::of_fn_ptr(&bx, sig, &extra_args),\n         };\n \n-        if intrinsic == Some(\"transmute\") {\n+        if intrinsic == Some(sym::transmute) {\n             if let Some(destination_ref) = destination.as_ref() {\n                 let &(dest, target) = destination_ref;\n                 self.codegen_transmute(&mut bx, &args[0], dest);\n@@ -607,7 +606,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         // For normal codegen, this Miri-specific intrinsic should never occur.\n-        if intrinsic == Some(\"miri_start_panic\") {\n+        if intrinsic == Some(sym::miri_start_panic) {\n             bug!(\"`miri_start_panic` should never end up in compiled code\");\n         }\n \n@@ -635,7 +634,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             ReturnDest::Nothing\n         };\n \n-        if intrinsic == Some(\"caller_location\") {\n+        if intrinsic == Some(sym::caller_location) {\n             if let Some((_, target)) = destination.as_ref() {\n                 let location = self.get_caller_location(&mut bx, fn_span);\n \n@@ -650,7 +649,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n \n-        if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n+        if intrinsic.is_some() && intrinsic != Some(sym::drop_in_place) {\n             let intrinsic = intrinsic.unwrap();\n \n             // `is_codegen_intrinsic()` allows the backend implementation to perform compile-time\n@@ -682,7 +681,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // third argument must be constant. This is\n                     // checked by const-qualification, which also\n                     // promotes any complex rvalues to constants.\n-                    if i == 2 && intrinsic.starts_with(\"simd_shuffle\") {\n+                    if i == 2 && intrinsic.as_str().starts_with(\"simd_shuffle\") {\n                         if let mir::Operand::Constant(constant) = arg {\n                             let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices("}, {"sha": "425bea4cb1986d60d6eb1f9a330d690d6c46262a", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -2,7 +2,7 @@ use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n use rustc_middle::mir::Operand;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_target::abi::call::FnAbi;\n \n pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n@@ -24,7 +24,7 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     /// the intrinsic does not need code generation.\n     fn is_codegen_intrinsic(\n         &mut self,\n-        intrinsic: &str,\n+        intrinsic: Symbol,\n         args: &Vec<Operand<'tcx>>,\n         caller_instance: ty::Instance<'tcx>,\n     ) -> bool;"}, {"sha": "be11e29cb25756e4f9f83180b8b1a38a3ae64677", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -698,7 +698,7 @@ impl RustcDefaultCalls {\n                         .parse_sess\n                         .config\n                         .iter()\n-                        .filter_map(|&(name, ref value)| {\n+                        .filter_map(|&(name, value)| {\n                             // Note that crt-static is a specially recognized cfg\n                             // directive that's printed out here as part of\n                             // rust-lang/rust#37406, but in general the\n@@ -707,9 +707,7 @@ impl RustcDefaultCalls {\n                             // specifically allowing the crt-static cfg and that's\n                             // it, this is intended to get into Cargo and then go\n                             // through to build scripts.\n-                            let value = value.as_ref().map(|s| s.as_str());\n-                            let value = value.as_ref().map(|s| s.as_ref());\n-                            if (name != sym::target_feature || value != Some(\"crt-static\"))\n+                            if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n                                 && !allow_unstable_cfg\n                                 && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n                             {"}, {"sha": "1c8a56e5d80e7a7a4701a93966af9f1432805eff", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 119, "deletions": 120, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -16,7 +16,7 @@ use rustc_ast::ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_macros::HashStable_Generic;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n \n use lazy_static::lazy_static;\n@@ -52,10 +52,10 @@ macro_rules! language_item_table {\n         }\n \n         impl LangItem {\n-            /// Returns the `name` in `#[lang = \"$name\"]`.\n+            /// Returns the `name` symbol in `#[lang = \"$name\"]`.\n             /// For example, `LangItem::EqTraitLangItem`,\n-            /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n-            pub fn name(self) -> &'static str {\n+            /// that is `#[lang = \"eq\"]` would result in `sym::eq`.\n+            pub fn name(self) -> Symbol {\n                 match self {\n                     $( $variant => $name, )*\n                 }\n@@ -110,9 +110,8 @@ macro_rules! language_item_table {\n             }\n \n             $(\n-                /// Returns the corresponding `DefId` for the lang item\n-                #[doc = $name]\n-                /// if it exists.\n+                /// Returns the corresponding `DefId` for the lang item if it\n+                /// exists.\n                 #[allow(dead_code)]\n                 pub fn $method(&self) -> Option<DefId> {\n                     self.items[$variant as usize]\n@@ -122,7 +121,7 @@ macro_rules! language_item_table {\n \n         lazy_static! {\n             /// A mapping from the name of the lang item to its order and the form it must be of.\n-            pub static ref ITEM_REFS: FxHashMap<&'static str, (usize, Target)> = {\n+            pub static ref ITEM_REFS: FxHashMap<Symbol, (usize, Target)> = {\n                 let mut item_refs = FxHashMap::default();\n                 $( item_refs.insert($name, ($variant as usize, $target)); )*\n                 item_refs\n@@ -154,100 +153,100 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n }\n \n language_item_table! {\n-//  Variant name,                Name,                 Method name,             Target;\n-    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n-    CharImplItem,                \"char\",               char_impl,               Target::Impl;\n-    StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n-    SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n-    SliceU8ImplItem,             \"slice_u8\",           slice_u8_impl,           Target::Impl;\n-    StrAllocImplItem,            \"str_alloc\",          str_alloc_impl,          Target::Impl;\n-    SliceAllocImplItem,          \"slice_alloc\",        slice_alloc_impl,        Target::Impl;\n-    SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n-    ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n-    MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n-    ConstSlicePtrImplItem,       \"const_slice_ptr\",    const_slice_ptr_impl,    Target::Impl;\n-    MutSlicePtrImplItem,         \"mut_slice_ptr\",      mut_slice_ptr_impl,      Target::Impl;\n-    I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n-    I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n-    I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;\n-    I64ImplItem,                 \"i64\",                i64_impl,                Target::Impl;\n-    I128ImplItem,                \"i128\",               i128_impl,               Target::Impl;\n-    IsizeImplItem,               \"isize\",              isize_impl,              Target::Impl;\n-    U8ImplItem,                  \"u8\",                 u8_impl,                 Target::Impl;\n-    U16ImplItem,                 \"u16\",                u16_impl,                Target::Impl;\n-    U32ImplItem,                 \"u32\",                u32_impl,                Target::Impl;\n-    U64ImplItem,                 \"u64\",                u64_impl,                Target::Impl;\n-    U128ImplItem,                \"u128\",               u128_impl,               Target::Impl;\n-    UsizeImplItem,               \"usize\",              usize_impl,              Target::Impl;\n-    F32ImplItem,                 \"f32\",                f32_impl,                Target::Impl;\n-    F64ImplItem,                 \"f64\",                f64_impl,                Target::Impl;\n-    F32RuntimeImplItem,          \"f32_runtime\",        f32_runtime_impl,        Target::Impl;\n-    F64RuntimeImplItem,          \"f64_runtime\",        f64_runtime_impl,        Target::Impl;\n-\n-    SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n-    UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n+//  Variant name,                  Name,                    Method name,             Target;\n+    BoolImplItem,                  sym::bool,               bool_impl,               Target::Impl;\n+    CharImplItem,                  sym::char,               char_impl,               Target::Impl;\n+    StrImplItem,                   sym::str,                str_impl,                Target::Impl;\n+    SliceImplItem,                 sym::slice,              slice_impl,              Target::Impl;\n+    SliceU8ImplItem,               sym::slice_u8,           slice_u8_impl,           Target::Impl;\n+    StrAllocImplItem,              sym::str_alloc,          str_alloc_impl,          Target::Impl;\n+    SliceAllocImplItem,            sym::slice_alloc,        slice_alloc_impl,        Target::Impl;\n+    SliceU8AllocImplItem,          sym::slice_u8_alloc,     slice_u8_alloc_impl,     Target::Impl;\n+    ConstPtrImplItem,              sym::const_ptr,          const_ptr_impl,          Target::Impl;\n+    MutPtrImplItem,                sym::mut_ptr,            mut_ptr_impl,            Target::Impl;\n+    ConstSlicePtrImplItem,         sym::const_slice_ptr,    const_slice_ptr_impl,    Target::Impl;\n+    MutSlicePtrImplItem,           sym::mut_slice_ptr,      mut_slice_ptr_impl,      Target::Impl;\n+    I8ImplItem,                    sym::i8,                 i8_impl,                 Target::Impl;\n+    I16ImplItem,                   sym::i16,                i16_impl,                Target::Impl;\n+    I32ImplItem,                   sym::i32,                i32_impl,                Target::Impl;\n+    I64ImplItem,                   sym::i64,                i64_impl,                Target::Impl;\n+    I128ImplItem,                  sym::i128,               i128_impl,               Target::Impl;\n+    IsizeImplItem,                 sym::isize,              isize_impl,              Target::Impl;\n+    U8ImplItem,                    sym::u8,                 u8_impl,                 Target::Impl;\n+    U16ImplItem,                   sym::u16,                u16_impl,                Target::Impl;\n+    U32ImplItem,                   sym::u32,                u32_impl,                Target::Impl;\n+    U64ImplItem,                   sym::u64,                u64_impl,                Target::Impl;\n+    U128ImplItem,                  sym::u128,               u128_impl,               Target::Impl;\n+    UsizeImplItem,                 sym::usize,              usize_impl,              Target::Impl;\n+    F32ImplItem,                   sym::f32,                f32_impl,                Target::Impl;\n+    F64ImplItem,                   sym::f64,                f64_impl,                Target::Impl;\n+    F32RuntimeImplItem,            sym::f32_runtime,        f32_runtime_impl,        Target::Impl;\n+    F64RuntimeImplItem,            sym::f64_runtime,        f64_runtime_impl,        Target::Impl;\n+\n+    SizedTraitLangItem,            sym::sized,              sized_trait,             Target::Trait;\n+    UnsizeTraitLangItem,           sym::unsize,             unsize_trait,            Target::Trait;\n     // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n-    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n+    StructuralPeqTraitLangItem,    sym::structural_peq,     structural_peq_trait,    Target::Trait;\n     // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n-    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n-    CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n-    CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n-    SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;\n-    DiscriminantKindTraitLangItem,\"discriminant_kind\", discriminant_kind_trait, Target::Trait;\n-    FreezeTraitLangItem,         \"freeze\",             freeze_trait,            Target::Trait;\n-\n-    DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n-\n-    CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n-    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n-\n-    AddTraitLangItem(Op),        \"add\",                add_trait,               Target::Trait;\n-    SubTraitLangItem(Op),        \"sub\",                sub_trait,               Target::Trait;\n-    MulTraitLangItem(Op),        \"mul\",                mul_trait,               Target::Trait;\n-    DivTraitLangItem(Op),        \"div\",                div_trait,               Target::Trait;\n-    RemTraitLangItem(Op),        \"rem\",                rem_trait,               Target::Trait;\n-    NegTraitLangItem(Op),        \"neg\",                neg_trait,               Target::Trait;\n-    NotTraitLangItem(Op),        \"not\",                not_trait,               Target::Trait;\n-    BitXorTraitLangItem(Op),     \"bitxor\",             bitxor_trait,            Target::Trait;\n-    BitAndTraitLangItem(Op),     \"bitand\",             bitand_trait,            Target::Trait;\n-    BitOrTraitLangItem(Op),      \"bitor\",              bitor_trait,             Target::Trait;\n-    ShlTraitLangItem(Op),        \"shl\",                shl_trait,               Target::Trait;\n-    ShrTraitLangItem(Op),        \"shr\",                shr_trait,               Target::Trait;\n-    AddAssignTraitLangItem(Op),  \"add_assign\",         add_assign_trait,        Target::Trait;\n-    SubAssignTraitLangItem(Op),  \"sub_assign\",         sub_assign_trait,        Target::Trait;\n-    MulAssignTraitLangItem(Op),  \"mul_assign\",         mul_assign_trait,        Target::Trait;\n-    DivAssignTraitLangItem(Op),  \"div_assign\",         div_assign_trait,        Target::Trait;\n-    RemAssignTraitLangItem(Op),  \"rem_assign\",         rem_assign_trait,        Target::Trait;\n-    BitXorAssignTraitLangItem(Op),\"bitxor_assign\",     bitxor_assign_trait,     Target::Trait;\n-    BitAndAssignTraitLangItem(Op),\"bitand_assign\",     bitand_assign_trait,     Target::Trait;\n-    BitOrAssignTraitLangItem(Op),\"bitor_assign\",       bitor_assign_trait,      Target::Trait;\n-    ShlAssignTraitLangItem(Op),  \"shl_assign\",         shl_assign_trait,        Target::Trait;\n-    ShrAssignTraitLangItem(Op),  \"shr_assign\",         shr_assign_trait,        Target::Trait;\n-    IndexTraitLangItem(Op),      \"index\",              index_trait,             Target::Trait;\n-    IndexMutTraitLangItem(Op),   \"index_mut\",          index_mut_trait,         Target::Trait;\n-\n-    UnsafeCellTypeLangItem,      \"unsafe_cell\",        unsafe_cell_type,        Target::Struct;\n-    VaListTypeLangItem,          \"va_list\",            va_list,                 Target::Struct;\n-\n-    DerefTraitLangItem,          \"deref\",              deref_trait,             Target::Trait;\n-    DerefMutTraitLangItem,       \"deref_mut\",          deref_mut_trait,         Target::Trait;\n-    ReceiverTraitLangItem,       \"receiver\",           receiver_trait,          Target::Trait;\n-\n-    FnTraitLangItem,             \"fn\",                 fn_trait,                Target::Trait;\n-    FnMutTraitLangItem,          \"fn_mut\",             fn_mut_trait,            Target::Trait;\n-    FnOnceTraitLangItem,         \"fn_once\",            fn_once_trait,           Target::Trait;\n-\n-    FnOnceOutputLangItem,        \"fn_once_output\",     fn_once_output,          Target::AssocTy;\n-\n-    FutureTraitLangItem,         \"future_trait\",       future_trait,            Target::Trait;\n-    GeneratorStateLangItem,      \"generator_state\",    gen_state,               Target::Enum;\n-    GeneratorTraitLangItem,      \"generator\",          gen_trait,               Target::Trait;\n-    UnpinTraitLangItem,          \"unpin\",              unpin_trait,             Target::Trait;\n-    PinTypeLangItem,             \"pin\",                pin_type,                Target::Struct;\n+    StructuralTeqTraitLangItem,    sym::structural_teq,     structural_teq_trait,    Target::Trait;\n+    CopyTraitLangItem,             sym::copy,               copy_trait,              Target::Trait;\n+    CloneTraitLangItem,            sym::clone,              clone_trait,             Target::Trait;\n+    SyncTraitLangItem,             sym::sync,               sync_trait,              Target::Trait;\n+    DiscriminantKindTraitLangItem, sym::discriminant_kind,  discriminant_kind_trait, Target::Trait;\n+    FreezeTraitLangItem,           sym::freeze,             freeze_trait,            Target::Trait;\n+\n+    DropTraitLangItem,             sym::drop,               drop_trait,              Target::Trait;\n+\n+    CoerceUnsizedTraitLangItem,    sym::coerce_unsized,     coerce_unsized_trait,    Target::Trait;\n+    DispatchFromDynTraitLangItem,  sym::dispatch_from_dyn,  dispatch_from_dyn_trait, Target::Trait;\n+\n+    AddTraitLangItem(Op),          sym::add,                add_trait,               Target::Trait;\n+    SubTraitLangItem(Op),          sym::sub,                sub_trait,               Target::Trait;\n+    MulTraitLangItem(Op),          sym::mul,                mul_trait,               Target::Trait;\n+    DivTraitLangItem(Op),          sym::div,                div_trait,               Target::Trait;\n+    RemTraitLangItem(Op),          sym::rem,                rem_trait,               Target::Trait;\n+    NegTraitLangItem(Op),          sym::neg,                neg_trait,               Target::Trait;\n+    NotTraitLangItem(Op),          sym::not,                not_trait,               Target::Trait;\n+    BitXorTraitLangItem(Op),       sym::bitxor,             bitxor_trait,            Target::Trait;\n+    BitAndTraitLangItem(Op),       sym::bitand,             bitand_trait,            Target::Trait;\n+    BitOrTraitLangItem(Op),        sym::bitor,              bitor_trait,             Target::Trait;\n+    ShlTraitLangItem(Op),          sym::shl,                shl_trait,               Target::Trait;\n+    ShrTraitLangItem(Op),          sym::shr,                shr_trait,               Target::Trait;\n+    AddAssignTraitLangItem(Op),    sym::add_assign,         add_assign_trait,        Target::Trait;\n+    SubAssignTraitLangItem(Op),    sym::sub_assign,         sub_assign_trait,        Target::Trait;\n+    MulAssignTraitLangItem(Op),    sym::mul_assign,         mul_assign_trait,        Target::Trait;\n+    DivAssignTraitLangItem(Op),    sym::div_assign,         div_assign_trait,        Target::Trait;\n+    RemAssignTraitLangItem(Op),    sym::rem_assign,         rem_assign_trait,        Target::Trait;\n+    BitXorAssignTraitLangItem(Op), sym::bitxor_assign,      bitxor_assign_trait,     Target::Trait;\n+    BitAndAssignTraitLangItem(Op), sym::bitand_assign,      bitand_assign_trait,     Target::Trait;\n+    BitOrAssignTraitLangItem(Op),  sym::bitor_assign,       bitor_assign_trait,      Target::Trait;\n+    ShlAssignTraitLangItem(Op),    sym::shl_assign,         shl_assign_trait,        Target::Trait;\n+    ShrAssignTraitLangItem(Op),    sym::shr_assign,         shr_assign_trait,        Target::Trait;\n+    IndexTraitLangItem(Op),        sym::index,              index_trait,             Target::Trait;\n+    IndexMutTraitLangItem(Op),     sym::index_mut,          index_mut_trait,         Target::Trait;\n+\n+    UnsafeCellTypeLangItem,        sym::unsafe_cell,        unsafe_cell_type,        Target::Struct;\n+    VaListTypeLangItem,            sym::va_list,            va_list,                 Target::Struct;\n+\n+    DerefTraitLangItem,            sym::deref,              deref_trait,             Target::Trait;\n+    DerefMutTraitLangItem,         sym::deref_mut,          deref_mut_trait,         Target::Trait;\n+    ReceiverTraitLangItem,         sym::receiver,           receiver_trait,          Target::Trait;\n+\n+    FnTraitLangItem,               kw::Fn,                  fn_trait,                Target::Trait;\n+    FnMutTraitLangItem,            sym::fn_mut,             fn_mut_trait,            Target::Trait;\n+    FnOnceTraitLangItem,           sym::fn_once,            fn_once_trait,           Target::Trait;\n+\n+    FnOnceOutputLangItem,          sym::fn_once_output,     fn_once_output,          Target::AssocTy;\n+\n+    FutureTraitLangItem,           sym::future_trait,       future_trait,            Target::Trait;\n+    GeneratorStateLangItem,        sym::generator_state,    gen_state,               Target::Enum;\n+    GeneratorTraitLangItem,        sym::generator,          gen_trait,               Target::Trait;\n+    UnpinTraitLangItem,            sym::unpin,              unpin_trait,             Target::Trait;\n+    PinTypeLangItem,               sym::pin,                pin_type,                Target::Struct;\n \n     // Don't be fooled by the naming here: this lang item denotes `PartialEq`, not `Eq`.\n-    EqTraitLangItem,             \"eq\",                 eq_trait,                Target::Trait;\n-    PartialOrdTraitLangItem,     \"partial_ord\",        partial_ord_trait,       Target::Trait;\n+    EqTraitLangItem,               sym::eq,                 eq_trait,                Target::Trait;\n+    PartialOrdTraitLangItem,       sym::partial_ord,        partial_ord_trait,       Target::Trait;\n \n     // A number of panic-related lang items. The `panic` item corresponds to\n     // divide-by-zero and various panic cases with `match`. The\n@@ -258,39 +257,39 @@ language_item_table! {\n     // defined to use it, but a final product is required to define it\n     // somewhere. Additionally, there are restrictions on crates that use a weak\n     // lang item, but do not have it defined.\n-    PanicFnLangItem,             \"panic\",              panic_fn,                Target::Fn;\n-    PanicBoundsCheckFnLangItem,  \"panic_bounds_check\", panic_bounds_check_fn,   Target::Fn;\n-    PanicInfoLangItem,           \"panic_info\",         panic_info,              Target::Struct;\n-    PanicLocationLangItem,       \"panic_location\",     panic_location,          Target::Struct;\n-    PanicImplLangItem,           \"panic_impl\",         panic_impl,              Target::Fn;\n+    PanicFnLangItem,               sym::panic,              panic_fn,                Target::Fn;\n+    PanicBoundsCheckFnLangItem,    sym::panic_bounds_check, panic_bounds_check_fn,   Target::Fn;\n+    PanicInfoLangItem,             sym::panic_info,         panic_info,              Target::Struct;\n+    PanicLocationLangItem,         sym::panic_location,     panic_location,          Target::Struct;\n+    PanicImplLangItem,             sym::panic_impl,         panic_impl,              Target::Fn;\n     // Libstd panic entry point. Necessary for const eval to be able to catch it\n-    BeginPanicFnLangItem,        \"begin_panic\",        begin_panic_fn,          Target::Fn;\n+    BeginPanicFnLangItem,          sym::begin_panic,        begin_panic_fn,          Target::Fn;\n \n-    ExchangeMallocFnLangItem,    \"exchange_malloc\",    exchange_malloc_fn,      Target::Fn;\n-    BoxFreeFnLangItem,           \"box_free\",           box_free_fn,             Target::Fn;\n-    DropInPlaceFnLangItem,       \"drop_in_place\",      drop_in_place_fn,        Target::Fn;\n-    OomLangItem,                 \"oom\",                oom,                     Target::Fn;\n-    AllocLayoutLangItem,         \"alloc_layout\",       alloc_layout,            Target::Struct;\n+    ExchangeMallocFnLangItem,      sym::exchange_malloc,    exchange_malloc_fn,      Target::Fn;\n+    BoxFreeFnLangItem,             sym::box_free,           box_free_fn,             Target::Fn;\n+    DropInPlaceFnLangItem,         sym::drop_in_place,      drop_in_place_fn,        Target::Fn;\n+    OomLangItem,                   sym::oom,                oom,                     Target::Fn;\n+    AllocLayoutLangItem,           sym::alloc_layout,       alloc_layout,            Target::Struct;\n \n-    StartFnLangItem,             \"start\",              start_fn,                Target::Fn;\n+    StartFnLangItem,               sym::start,              start_fn,                Target::Fn;\n \n-    CountCodeRegionFnLangItem,   \"count_code_region\",  count_code_region_fn,    Target::Fn;\n+    CountCodeRegionFnLangItem,     sym::count_code_region,  count_code_region_fn,    Target::Fn;\n \n-    EhPersonalityLangItem,       \"eh_personality\",     eh_personality,          Target::Fn;\n-    EhCatchTypeinfoLangItem,     \"eh_catch_typeinfo\",  eh_catch_typeinfo,       Target::Static;\n+    EhPersonalityLangItem,         sym::eh_personality,     eh_personality,          Target::Fn;\n+    EhCatchTypeinfoLangItem,       sym::eh_catch_typeinfo,  eh_catch_typeinfo,       Target::Static;\n \n-    OwnedBoxLangItem,            \"owned_box\",          owned_box,               Target::Struct;\n+    OwnedBoxLangItem,              sym::owned_box,          owned_box,               Target::Struct;\n \n-    PhantomDataItem,             \"phantom_data\",       phantom_data,            Target::Struct;\n+    PhantomDataItem,               sym::phantom_data,       phantom_data,            Target::Struct;\n \n-    ManuallyDropItem,            \"manually_drop\",      manually_drop,           Target::Struct;\n+    ManuallyDropItem,              sym::manually_drop,      manually_drop,           Target::Struct;\n \n-    MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n+    MaybeUninitLangItem,           sym::maybe_uninit,       maybe_uninit,            Target::Union;\n \n     // Align offset for stride != 1; must not panic.\n-    AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n+    AlignOffsetLangItem,           sym::align_offset,       align_offset_fn,         Target::Fn;\n \n-    TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n+    TerminationTraitLangItem,      sym::termination,        termination,             Target::Trait;\n \n-    TryTraitLangItem,            \"try\",                try_trait,               Target::Trait;\n+    TryTraitLangItem,              kw::Try,                 try_trait,               Target::Trait;\n }"}, {"sha": "1a1dbc1b5a86f42cf55fabcd6ddc4b549ccbf9d4", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -62,11 +62,11 @@ impl AssertModuleSource<'tcx> {\n         } else if attr.check_name(sym::rustc_partition_codegened) {\n             (CguReuse::No, ComparisonKind::Exact)\n         } else if attr.check_name(sym::rustc_expected_cgu_reuse) {\n-            match &*self.field(attr, sym::kind).as_str() {\n-                \"no\" => (CguReuse::No, ComparisonKind::Exact),\n-                \"pre-lto\" => (CguReuse::PreLto, ComparisonKind::Exact),\n-                \"post-lto\" => (CguReuse::PostLto, ComparisonKind::Exact),\n-                \"any\" => (CguReuse::PreLto, ComparisonKind::AtLeast),\n+            match self.field(attr, sym::kind) {\n+                sym::no => (CguReuse::No, ComparisonKind::Exact),\n+                sym::pre_dash_lto => (CguReuse::PreLto, ComparisonKind::Exact),\n+                sym::post_dash_lto => (CguReuse::PostLto, ComparisonKind::Exact),\n+                sym::any => (CguReuse::PreLto, ComparisonKind::AtLeast),\n                 other => {\n                     self.tcx.sess.span_fatal(\n                         attr.span,"}, {"sha": "8fb7d5fcae176b451387af34ed22d885dcffae64", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -53,7 +53,7 @@ pub fn add_configuration(\n     cfg.extend(target_features.into_iter().map(|feat| (tf, Some(feat))));\n \n     if sess.crt_static(None) {\n-        cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n+        cfg.insert((tf, Some(sym::crt_dash_static)));\n     }\n }\n "}, {"sha": "0563894e6348d718f631127b776a40d04b521951", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -679,8 +679,8 @@ impl<'a> CrateLoader<'a> {\n         // in terms of everyone has a compatible panic runtime format, that's\n         // performed later as part of the `dependency_format` module.\n         let name = match desired_strategy {\n-            PanicStrategy::Unwind => Symbol::intern(\"panic_unwind\"),\n-            PanicStrategy::Abort => Symbol::intern(\"panic_abort\"),\n+            PanicStrategy::Unwind => sym::panic_unwind,\n+            PanicStrategy::Abort => sym::panic_abort,\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n@@ -713,7 +713,7 @@ impl<'a> CrateLoader<'a> {\n         {\n             info!(\"loading profiler\");\n \n-            let name = Symbol::intern(\"profiler_builtins\");\n+            let name = sym::profiler_builtins;\n             let cnum = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n             let data = self.cstore.get_crate_data(cnum);\n "}, {"sha": "bd3e20458b078bb72f8237a908656f02d9f5bf11", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -2,7 +2,7 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_middle::mir::*;\n use rustc_middle::ty;\n use rustc_span::source_map::DesugaringKind;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::{sym, Span};\n \n use crate::borrow_check::diagnostics::UseSpans;\n use crate::borrow_check::prefixes::PrefixSet;\n@@ -394,10 +394,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 | ty::Opaque(def_id, _) => def_id,\n                 _ => return err,\n             };\n-            let is_option =\n-                self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"option_type\"), def_id);\n-            let is_result =\n-                self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"result_type\"), def_id);\n+            let is_option = self.infcx.tcx.is_diagnostic_item(sym::option_type, def_id);\n+            let is_result = self.infcx.tcx.is_diagnostic_item(sym::result_type, def_id);\n             if (is_option || is_result) && use_spans.map_or(true, |v| !v.for_closure()) {\n                 err.span_suggestion(\n                     span,\n@@ -409,7 +407,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Applicability::MaybeIncorrect,\n                 );\n             } else if matches!(span.desugaring_kind(), Some(DesugaringKind::ForLoop(_)))\n-                && self.infcx.tcx.is_diagnostic_item(Symbol::intern(\"vec_type\"), def_id)\n+                && self.infcx.tcx.is_diagnostic_item(sym::vec_type, def_id)\n             {\n                 // FIXME: suggest for anything that implements `IntoIterator`.\n                 err.span_suggestion("}, {"sha": "e07c71b41d82714ad13b1dafcfcb787cac87bef9", "filename": "src/librustc_passes/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -57,7 +57,7 @@ impl LanguageItemCollector<'tcx> {\n \n     fn check_for_lang(&mut self, actual_target: Target, hir_id: HirId, attrs: &[Attribute]) {\n         if let Some((value, span)) = extract(&attrs) {\n-            match ITEM_REFS.get(&*value.as_str()).cloned() {\n+            match ITEM_REFS.get(&value).cloned() {\n                 // Known lang item with attribute on correct target.\n                 Some((item_index, expected_target)) if actual_target == expected_target => {\n                     let def_id = self.tcx.hir().local_def_id(hir_id);"}, {"sha": "76bc6b6c85f020c5f24aa624488191f3983ef923", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -620,7 +620,7 @@ pub fn check_unused_or_stable_features(tcx: TyCtxt<'_>) {\n     // available as we'd like it to be.\n     // FIXME: only remove `libc` when `stdbuild` is active.\n     // FIXME: remove special casing for `test`.\n-    remaining_lib_features.remove(&Symbol::intern(\"libc\"));\n+    remaining_lib_features.remove(&sym::libc);\n     remaining_lib_features.remove(&sym::test);\n \n     let check_features = |remaining_lib_features: &mut FxHashMap<_, _>, defined_features: &[_]| {"}, {"sha": "d85d8401db676bf44dad3db6708fc06fe550c998", "filename": "src/librustc_passes/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_passes%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_passes%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fweak_lang_items.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -81,7 +81,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n             // `core::intrinsics::code_count_region()` is (currently) the only `extern` lang item\n             // that is never actually linked. It is not a `weak_lang_item` that can be registered\n             // when used, and should be registered here instead.\n-            if let Some((item_index, _)) = ITEM_REFS.get(&*name.as_str()).cloned() {\n+            if let Some((item_index, _)) = ITEM_REFS.get(&name).cloned() {\n                 if self.items.items[item_index].is_none() {\n                     let item_def_id = self.tcx.hir().local_def_id(hir_id).to_def_id();\n                     self.items.items[item_index] = Some(item_def_id);"}, {"sha": "b98e4f0b3a27bacd61dd617021cda049957221e0", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -16,7 +16,7 @@ use rustc_middle::ty::{self, DefIdTree};\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::SourceMap;\n-use rustc_span::symbol::{kw, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, MultiSpan, Span};\n \n use crate::imports::{Import, ImportKind, ImportResolver};\n@@ -882,8 +882,7 @@ impl<'a> Resolver<'a> {\n         );\n         self.add_typo_suggestion(err, suggestion, ident.span);\n \n-        if macro_kind == MacroKind::Derive && (ident.as_str() == \"Send\" || ident.as_str() == \"Sync\")\n-        {\n+        if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n             err.span_note(ident.span, &msg);\n         }"}, {"sha": "f909f66b70746397eb6ae837567717b2ea72c680", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -1034,8 +1034,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         let initial_res = source_bindings[ns].get().map(|initial_binding| {\n                             all_ns_err = false;\n                             if let Some(target_binding) = target_bindings[ns].get() {\n-                                // Note that as_str() de-gensyms the Symbol\n-                                if target.name.as_str() == \"_\"\n+                                if target.name == kw::Underscore\n                                     && initial_binding.is_extern_crate()\n                                     && !initial_binding.is_import()\n                                 {"}, {"sha": "567db8edec9afe25b550f83e8be1e2df685c28b1", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -2364,7 +2364,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         if let Some(params) = error {\n             // If there's no lifetime available, suggest `'static`.\n             if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(Ident::from_str(\"'static\"));\n+                lifetime_names.insert(Ident::with_dummy_span(kw::StaticLifetime));\n             }\n         }\n         self.add_missing_lifetime_specifiers_label("}, {"sha": "348fe105a4315abf15bfc1420df7304734c74359", "filename": "src/librustc_session/config.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_session%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_session%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Fconfig.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -717,18 +717,20 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n     let mut ret = FxHashSet::default();\n     ret.reserve(6); // the minimum number of insertions\n     // Target bindings.\n-    ret.insert((Symbol::intern(\"target_os\"), Some(Symbol::intern(os))));\n+    ret.insert((sym::target_os, Some(Symbol::intern(os))));\n     if let Some(ref fam) = sess.target.target.options.target_family {\n-        ret.insert((Symbol::intern(\"target_family\"), Some(Symbol::intern(fam))));\n-        if fam == \"windows\" || fam == \"unix\" {\n-            ret.insert((Symbol::intern(fam), None));\n+        ret.insert((sym::target_family, Some(Symbol::intern(fam))));\n+        if fam == \"windows\" {\n+            ret.insert((sym::windows, None));\n+        } else if fam == \"unix\" {\n+            ret.insert((sym::unix, None));\n         }\n     }\n-    ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n-    ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n-    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n-    ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n-    ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n+    ret.insert((sym::target_arch, Some(Symbol::intern(arch))));\n+    ret.insert((sym::target_endian, Some(Symbol::intern(end))));\n+    ret.insert((sym::target_pointer_width, Some(Symbol::intern(wordsz))));\n+    ret.insert((sym::target_env, Some(Symbol::intern(env))));\n+    ret.insert((sym::target_vendor, Some(Symbol::intern(vendor))));\n     if sess.target.target.options.has_elf_tls {\n         ret.insert((sym::target_thread_local, None));\n     }\n@@ -754,7 +756,7 @@ pub fn default_configuration(sess: &Session) -> CrateConfig {\n     }\n \n     if sess.opts.debug_assertions {\n-        ret.insert((Symbol::intern(\"debug_assertions\"), None));\n+        ret.insert((sym::debug_assertions, None));\n     }\n     if sess.opts.crate_types.contains(&CrateType::ProcMacro) {\n         ret.insert((sym::proc_macro, None));"}, {"sha": "95f36d3346ad7b1692ac5cc6d3a9ae096660b82d", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -129,17 +129,23 @@ symbols! {\n         abi_x86_interrupt,\n         abort,\n         aborts,\n+        add,\n+        add_assign,\n         address,\n         add_with_overflow,\n         advanced_slice_patterns,\n         adx_target_feature,\n         alias,\n         align,\n+        align_offset,\n         alignstack,\n         all,\n+        alloc,\n         allocator,\n         allocator_internals,\n         alloc_error_handler,\n+        alloc_layout,\n+        alloc_zeroed,\n         allow,\n         allowed,\n         allow_fail,\n@@ -156,15 +162,18 @@ symbols! {\n         ArgumentV1,\n         arith_offset,\n         arm_target_feature,\n+        array,\n         asm,\n         assert,\n         assert_inhabited,\n+        assert_receiver_is_total_eq,\n         assert_uninit_valid,\n         assert_zero_valid,\n         associated_consts,\n         associated_type_bounds,\n         associated_type_defaults,\n         associated_types,\n+        as_str,\n         assume,\n         assume_init,\n         async_await,\n@@ -183,19 +192,29 @@ symbols! {\n         bin,\n         bind_by_move_pattern_guards,\n         bindings_after_at,\n+        bitand,\n+        bitand_assign,\n+        bitor,\n+        bitor_assign,\n         bitreverse,\n+        bitxor,\n+        bitxor_assign,\n         block,\n         bool,\n         borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n         borrowck_graphviz_preflow,\n+        box_free,\n         box_patterns,\n         box_syntax,\n         braced_empty_structs,\n         breakpoint,\n         bswap,\n         C,\n+        call,\n         caller_location,\n+        call_mut,\n+        call_once,\n         cdylib,\n         ceilf32,\n         ceilf64,\n@@ -219,6 +238,7 @@ symbols! {\n         closure_to_fn_coercion,\n         cmp,\n         cmpxchg16b_target_feature,\n+        coerce_unsized,\n         cold,\n         column,\n         compile_error,\n@@ -243,8 +263,10 @@ symbols! {\n         const_mut_refs,\n         const_panic,\n         const_precise_live_drops,\n+        const_ptr,\n         const_raw_ptr_deref,\n         const_raw_ptr_to_usize_cast,\n+        const_slice_ptr,\n         const_trait_bound_opt_out,\n         const_trait_impl,\n         const_transmute,\n@@ -271,6 +293,7 @@ symbols! {\n         crate_name,\n         crate_type,\n         crate_visibility_modifier,\n+        crt_dash_static: \"crt-static\",\n         ctlz,\n         ctlz_nonzero,\n         ctpop,\n@@ -281,12 +304,16 @@ symbols! {\n         custom_inner_attributes,\n         custom_test_frameworks,\n         c_variadic,\n+        dead_code,\n+        dealloc,\n         debug,\n         Debug,\n+        debug_assertions,\n         debug_trait,\n         declare_lint_pass,\n         decl_macro,\n         Decodable,\n+        decode,\n         Default,\n         default_lib_allocator,\n         default_type_parameter_fallback,\n@@ -299,7 +326,11 @@ symbols! {\n         derive,\n         diagnostic,\n         direct,\n+        discriminant_kind,\n         discriminant_value,\n+        dispatch_from_dyn,\n+        div,\n+        div_assign,\n         doc,\n         doc_alias,\n         doc_cfg,\n@@ -316,16 +347,19 @@ symbols! {\n         double_braced_impl: \"{{impl}}\",\n         double_braced_misc: \"{{misc}}\",\n         double_braced_opaque: \"{{opaque}}\",\n+        drop,\n         dropck_eyepatch,\n         dropck_parametricity,\n         drop_in_place,\n         drop_types_in_const,\n         dylib,\n         dyn_trait,\n+        eh_catch_typeinfo,\n         eh_personality,\n         enable,\n         enclosing_scope,\n         Encodable,\n+        encode,\n         env,\n         eq,\n         Eq,\n@@ -334,6 +368,7 @@ symbols! {\n         Err,\n         exact_div,\n         except,\n+        exchange_malloc,\n         exclusive_range_pattern,\n         exhaustive_integer_patterns,\n         exhaustive_patterns,\n@@ -354,7 +389,9 @@ symbols! {\n         extern_types,\n         f16c_target_feature,\n         f32,\n+        f32_runtime,\n         f64,\n+        f64_runtime,\n         fabsf32,\n         fabsf64,\n         fadd_fast,\n@@ -375,11 +412,15 @@ symbols! {\n         fmt_internals,\n         fmul_fast,\n         fn_must_use,\n+        fn_mut,\n+        fn_once,\n+        fn_once_output,\n         forbid,\n         forget,\n         format_args,\n         format_args_capture,\n         format_args_nl,\n+        freeze,\n         frem_fast,\n         from,\n         From,\n@@ -388,23 +429,30 @@ symbols! {\n         from_generator,\n         from_method,\n         from_ok,\n+        from_size_align_unchecked,\n         from_trait,\n         from_usize,\n         fsub_fast,\n         fundamental,\n         future,\n         Future,\n+        future_trait,\n         FxHashMap,\n         FxHashSet,\n+        ge,\n+        generator,\n         generators,\n+        generator_state,\n         generic_associated_types,\n         generic_param_attrs,\n         gen_future,\n         gen_kill,\n         get_context,\n+        GlobalAlloc,\n         global_allocator,\n         global_asm,\n         globs,\n+        gt,\n         half_open_range_patterns,\n         hash,\n         Hash,\n@@ -467,10 +515,13 @@ symbols! {\n         lang,\n         lang_items,\n         lateout,\n+        Layout,\n         lazy_normalization_consts,\n+        le,\n         let_chains,\n         lhs,\n         lib,\n+        libc,\n         lifetime,\n         likely,\n         line,\n@@ -495,6 +546,7 @@ symbols! {\n         logf64,\n         log_syntax,\n         loop_break_value,\n+        lt,\n         macro_at_most_once_rep,\n         macro_escape,\n         macro_export,\n@@ -506,13 +558,15 @@ symbols! {\n         macro_vis_matcher,\n         main,\n         managed_boxes,\n+        manually_drop,\n         marker,\n         marker_trait_attr,\n         masked,\n         match_beginning_vert,\n         match_default_bindings,\n         maxnumf32,\n         maxnumf64,\n+        maybe_uninit,\n         maybe_uninit_uninit,\n         maybe_uninit_zeroed,\n         may_dangle,\n@@ -538,16 +592,22 @@ symbols! {\n         movbe_target_feature,\n         move_ref_pattern,\n         move_val_init,\n+        mul,\n+        mul_assign,\n         mul_with_overflow,\n         must_use,\n+        mut_ptr,\n+        mut_slice_ptr,\n         naked,\n         naked_functions,\n         name,\n+        ne,\n         nearbyintf32,\n         nearbyintf64,\n         needs_allocator,\n         needs_drop,\n         needs_panic_runtime,\n+        neg,\n         negate_unsigned,\n         negative_impls,\n         never,\n@@ -557,6 +617,7 @@ symbols! {\n         __next,\n         next,\n         nll,\n+        no,\n         no_builtins,\n         no_core,\n         no_crate_inject,\n@@ -590,6 +651,7 @@ symbols! {\n         on,\n         on_unimplemented,\n         oom,\n+        opaque,\n         ops,\n         optimize,\n         optimize_attribute,\n@@ -598,6 +660,7 @@ symbols! {\n         Option,\n         option_env,\n         options,\n+        option_type,\n         opt_out_copy,\n         or,\n         Ord,\n@@ -606,37 +669,48 @@ symbols! {\n         out,\n         Output,\n         overlapping_marker_traits,\n+        owned_box,\n         packed,\n         panic,\n+        panic_abort,\n+        panic_bounds_check,\n         panic_handler,\n         panic_impl,\n         panic_implementation,\n+        panic_info,\n+        panic_location,\n         panic_runtime,\n+        panic_unwind,\n         param_attrs,\n         parent_trait,\n         partial_cmp,\n         PartialEq,\n+        partial_ord,\n         PartialOrd,\n         passes,\n         pat,\n         path,\n         pattern_parentheses,\n         Pending,\n+        phantom_data,\n         pin,\n         Pin,\n         pinned,\n         platform_intrinsics,\n         plugin,\n         plugin_registrar,\n         plugins,\n+        pointer,\n         poll,\n         Poll,\n+        post_dash_lto: \"post-lto\",\n         powerpc_target_feature,\n         powf32,\n         powf64,\n         powif32,\n         powif64,\n         precise_pointer_size_matching,\n+        pre_dash_lto: \"pre-lto\",\n         pref_align_of,\n         prefetch_read_data,\n         prefetch_read_instruction,\n@@ -683,13 +757,18 @@ symbols! {\n         Rc,\n         readonly,\n         Ready,\n+        realloc,\n         reason,\n+        receiver,\n         recursion_limit,\n         reexport_test_harness_main,\n+        reference,\n         reflect,\n         register_attr,\n         register_tool,\n         relaxed_adts,\n+        rem,\n+        rem_assign,\n         repr,\n         repr128,\n         repr_align,\n@@ -701,6 +780,7 @@ symbols! {\n         re_rebalance_coherence,\n         result,\n         Result,\n+        result_type,\n         Return,\n         rhs,\n         rintf32,\n@@ -776,6 +856,8 @@ symbols! {\n         rustc_unsafe_specialization_marker,\n         rustc_variance,\n         rust_eh_personality,\n+        rust_eh_register_frames,\n+        rust_eh_unregister_frames,\n         rustfmt,\n         rust_oom,\n         rvalue_static_promotion,\n@@ -786,19 +868,83 @@ symbols! {\n         _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n+        semitransparent,\n+        Send,\n         send_trait,\n+        shl,\n+        shl_assign,\n         should_panic,\n+        shr,\n+        shr_assign,\n         simd,\n+        simd_add,\n+        simd_and,\n+        simd_bitmask,\n+        simd_cast,\n+        simd_ceil,\n+        simd_div,\n+        simd_eq,\n         simd_extract,\n+        simd_fabs,\n+        simd_fcos,\n+        simd_fexp,\n+        simd_fexp2,\n         simd_ffi,\n+        simd_flog,\n+        simd_flog10,\n+        simd_flog2,\n+        simd_floor,\n+        simd_fma,\n+        simd_fmax,\n+        simd_fmin,\n+        simd_fpow,\n+        simd_fpowi,\n+        simd_fsin,\n+        simd_fsqrt,\n+        simd_gather,\n+        simd_ge,\n+        simd_gt,\n         simd_insert,\n+        simd_le,\n+        simd_lt,\n+        simd_mul,\n+        simd_ne,\n+        simd_or,\n+        simd_reduce_add_ordered,\n+        simd_reduce_add_unordered,\n+        simd_reduce_all,\n+        simd_reduce_and,\n+        simd_reduce_any,\n+        simd_reduce_max,\n+        simd_reduce_max_nanless,\n+        simd_reduce_min,\n+        simd_reduce_min_nanless,\n+        simd_reduce_mul_ordered,\n+        simd_reduce_mul_unordered,\n+        simd_reduce_or,\n+        simd_reduce_xor,\n+        simd_rem,\n+        simd_saturating_add,\n+        simd_saturating_sub,\n+        simd_scatter,\n+        simd_select,\n+        simd_select_bitmask,\n+        simd_shl,\n+        simd_shr,\n+        simd_sub,\n+        simd_xor,\n         since,\n         sinf32,\n         sinf64,\n         size,\n+        sized,\n         size_of,\n         size_of_val,\n+        slice,\n+        slice_alloc,\n         slice_patterns,\n+        slice_u8,\n+        slice_u8_alloc,\n         slicing_syntax,\n         soft,\n         Some,\n@@ -820,24 +966,41 @@ symbols! {\n         stmt_expr_attributes,\n         stop_after_dataflow,\n         str,\n+        str_alloc,\n         stringify,\n         struct_field_attributes,\n         struct_inherit,\n         structural_match,\n+        structural_peq,\n+        structural_teq,\n         struct_variant,\n         sty,\n+        sub,\n+        sub_assign,\n         sub_with_overflow,\n         suggestion,\n         sym,\n+        sync,\n+        Sync,\n         sync_trait,\n+        Target,\n+        target_arch,\n+        target_endian,\n+        target_env,\n+        target_family,\n         target_feature,\n         target_feature_11,\n         target_has_atomic,\n         target_has_atomic_load_store,\n+        target_os,\n+        target_pointer_width,\n+        target_target_vendor,\n         target_thread_local,\n+        target_vendor,\n         task,\n         _task_context,\n         tbm_target_feature,\n+        termination,\n         termination_trait,\n         termination_trait_test,\n         test,\n@@ -865,6 +1028,7 @@ symbols! {\n         try_blocks,\n         try_trait,\n         tt,\n+        tuple,\n         tuple_indexing,\n         two_phase,\n         ty,\n@@ -897,18 +1061,24 @@ symbols! {\n         underscore_imports,\n         underscore_lifetimes,\n         uniform_paths,\n+        unit,\n         universal_impl_trait,\n+        unix,\n         unlikely,\n         unmarked_api,\n+        unpin,\n         unreachable,\n         unreachable_code,\n         unrestricted_attribute_tokens,\n         unsafe_block_in_unsafe_fn,\n+        unsafe_cell,\n         unsafe_no_drop_flag,\n+        unsize,\n         unsized_locals,\n         unsized_tuple_coercion,\n         unstable,\n         untagged_unions,\n+        unused_qualifications,\n         unwind,\n         unwind_attributes,\n         unwrap_or,\n@@ -921,11 +1091,13 @@ symbols! {\n         va_copy,\n         va_end,\n         val,\n+        va_list,\n         var,\n         variant_count,\n         va_start,\n         vec,\n         Vec,\n+        vec_type,\n         version,\n         vis,\n         visible_private_types,"}, {"sha": "cc971440feac52a20fb3b4eea7cf4b96f07f5624", "filename": "src/librustc_trait_selection/autoderef.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_trait_selection%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_trait_selection%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fautoderef.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -6,7 +6,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc_middle::ty::{ToPredicate, TypeFoldable};\n use rustc_session::DiagnosticMessageId;\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n \n #[derive(Copy, Clone, Debug)]\n@@ -143,7 +143,11 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n         let normalized_ty = fulfillcx.normalize_projection_type(\n             &self.infcx,\n             self.param_env,\n-            ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, Ident::from_str(\"Target\")),\n+            ty::ProjectionTy::from_ref_and_name(\n+                tcx,\n+                trait_ref,\n+                Ident::with_dummy_span(sym::Target),\n+            ),\n             cause,\n         );\n         if let Err(e) = fulfillcx.select_where_possible(&self.infcx) {"}, {"sha": "128e88bb10ac517606822dd17b0d5f3d0f6bc2b5", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -1247,7 +1247,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .generic_args()\n                             .bindings\n                             .iter()\n-                            .find_map(|b| match (b.ident.as_str() == \"Output\", &b.kind) {\n+                            .find_map(|b| match (b.ident.name == sym::Output, &b.kind) {\n                                 (true, hir::TypeBindingKind::Equality { ty }) => {\n                                     sess.source_map().span_to_snippet(ty.span).ok()\n                                 }"}, {"sha": "9930a600327348b80eb28d0b25909e3002b2cc82", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::adjustment::{\n };\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n use rustc_trait_selection::autoderef::Autoderef;\n@@ -192,9 +192,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ) -> Option<(Option<Adjustment<'tcx>>, MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in &[\n-            (self.tcx.lang_items().fn_trait(), Ident::from_str(\"call\"), true),\n-            (self.tcx.lang_items().fn_mut_trait(), Ident::from_str(\"call_mut\"), true),\n-            (self.tcx.lang_items().fn_once_trait(), Ident::from_str(\"call_once\"), false),\n+            (self.tcx.lang_items().fn_trait(), Ident::with_dummy_span(sym::call), true),\n+            (self.tcx.lang_items().fn_mut_trait(), Ident::with_dummy_span(sym::call_mut), true),\n+            (self.tcx.lang_items().fn_once_trait(), Ident::with_dummy_span(sym::call_once), false),\n         ] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,"}, {"sha": "944e02acd610a7fc361cfa8e067abb98a8a4aa33", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -423,70 +423,81 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n     };\n \n     let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n-    let name = it.ident.as_str();\n+    let name = it.ident.name;\n \n-    let (n_tps, inputs, output) = match &*name {\n-        \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n+    let (n_tps, inputs, output) = match name {\n+        sym::simd_eq | sym::simd_ne | sym::simd_lt | sym::simd_le | sym::simd_gt | sym::simd_ge => {\n             (2, vec![param(0), param(0)], param(1))\n         }\n-        \"simd_add\"\n-        | \"simd_sub\"\n-        | \"simd_mul\"\n-        | \"simd_rem\"\n-        | \"simd_div\"\n-        | \"simd_shl\"\n-        | \"simd_shr\"\n-        | \"simd_and\"\n-        | \"simd_or\"\n-        | \"simd_xor\"\n-        | \"simd_fmin\"\n-        | \"simd_fmax\"\n-        | \"simd_fpow\"\n-        | \"simd_saturating_add\"\n-        | \"simd_saturating_sub\" => (1, vec![param(0), param(0)], param(0)),\n-        \"simd_fsqrt\" | \"simd_fsin\" | \"simd_fcos\" | \"simd_fexp\" | \"simd_fexp2\" | \"simd_flog2\"\n-        | \"simd_flog10\" | \"simd_flog\" | \"simd_fabs\" | \"simd_floor\" | \"simd_ceil\" => {\n-            (1, vec![param(0)], param(0))\n+        sym::simd_add\n+        | sym::simd_sub\n+        | sym::simd_mul\n+        | sym::simd_rem\n+        | sym::simd_div\n+        | sym::simd_shl\n+        | sym::simd_shr\n+        | sym::simd_and\n+        | sym::simd_or\n+        | sym::simd_xor\n+        | sym::simd_fmin\n+        | sym::simd_fmax\n+        | sym::simd_fpow\n+        | sym::simd_saturating_add\n+        | sym::simd_saturating_sub => (1, vec![param(0), param(0)], param(0)),\n+        sym::simd_fsqrt\n+        | sym::simd_fsin\n+        | sym::simd_fcos\n+        | sym::simd_fexp\n+        | sym::simd_fexp2\n+        | sym::simd_flog2\n+        | sym::simd_flog10\n+        | sym::simd_flog\n+        | sym::simd_fabs\n+        | sym::simd_floor\n+        | sym::simd_ceil => (1, vec![param(0)], param(0)),\n+        sym::simd_fpowi => (1, vec![param(0), tcx.types.i32], param(0)),\n+        sym::simd_fma => (1, vec![param(0), param(0), param(0)], param(0)),\n+        sym::simd_gather => (3, vec![param(0), param(1), param(2)], param(0)),\n+        sym::simd_scatter => (3, vec![param(0), param(1), param(2)], tcx.mk_unit()),\n+        sym::simd_insert => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n+        sym::simd_extract => (2, vec![param(0), tcx.types.u32], param(1)),\n+        sym::simd_cast => (2, vec![param(0)], param(1)),\n+        sym::simd_bitmask => (2, vec![param(0)], param(1)),\n+        sym::simd_select | sym::simd_select_bitmask => {\n+            (2, vec![param(0), param(1), param(1)], param(1))\n         }\n-        \"simd_fpowi\" => (1, vec![param(0), tcx.types.i32], param(0)),\n-        \"simd_fma\" => (1, vec![param(0), param(0), param(0)], param(0)),\n-        \"simd_gather\" => (3, vec![param(0), param(1), param(2)], param(0)),\n-        \"simd_scatter\" => (3, vec![param(0), param(1), param(2)], tcx.mk_unit()),\n-        \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n-        \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n-        \"simd_cast\" => (2, vec![param(0)], param(1)),\n-        \"simd_bitmask\" => (2, vec![param(0)], param(1)),\n-        \"simd_select\" | \"simd_select_bitmask\" => (2, vec![param(0), param(1), param(1)], param(1)),\n-        \"simd_reduce_all\" | \"simd_reduce_any\" => (1, vec![param(0)], tcx.types.bool),\n-        \"simd_reduce_add_ordered\" | \"simd_reduce_mul_ordered\" => {\n+        sym::simd_reduce_all | sym::simd_reduce_any => (1, vec![param(0)], tcx.types.bool),\n+        sym::simd_reduce_add_ordered | sym::simd_reduce_mul_ordered => {\n             (2, vec![param(0), param(1)], param(1))\n         }\n-        \"simd_reduce_add_unordered\"\n-        | \"simd_reduce_mul_unordered\"\n-        | \"simd_reduce_and\"\n-        | \"simd_reduce_or\"\n-        | \"simd_reduce_xor\"\n-        | \"simd_reduce_min\"\n-        | \"simd_reduce_max\"\n-        | \"simd_reduce_min_nanless\"\n-        | \"simd_reduce_max_nanless\" => (2, vec![param(0)], param(1)),\n-        name if name.starts_with(\"simd_shuffle\") => match name[\"simd_shuffle\".len()..].parse() {\n-            Ok(n) => {\n-                let params = vec![param(0), param(0), tcx.mk_array(tcx.types.u32, n)];\n-                (2, params, param(1))\n-            }\n-            Err(_) => {\n-                struct_span_err!(\n-                    tcx.sess,\n-                    it.span,\n-                    E0439,\n-                    \"invalid `simd_shuffle`, needs length: `{}`\",\n-                    name\n-                )\n-                .emit();\n-                return;\n+        sym::simd_reduce_add_unordered\n+        | sym::simd_reduce_mul_unordered\n+        | sym::simd_reduce_and\n+        | sym::simd_reduce_or\n+        | sym::simd_reduce_xor\n+        | sym::simd_reduce_min\n+        | sym::simd_reduce_max\n+        | sym::simd_reduce_min_nanless\n+        | sym::simd_reduce_max_nanless => (2, vec![param(0)], param(1)),\n+        name if name.as_str().starts_with(\"simd_shuffle\") => {\n+            match name.as_str()[\"simd_shuffle\".len()..].parse() {\n+                Ok(n) => {\n+                    let params = vec![param(0), param(0), tcx.mk_array(tcx.types.u32, n)];\n+                    (2, params, param(1))\n+                }\n+                Err(_) => {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        it.span,\n+                        E0439,\n+                        \"invalid `simd_shuffle`, needs length: `{}`\",\n+                        name\n+                    )\n+                    .emit();\n+                    return;\n+                }\n             }\n-        },\n+        }\n         _ => {\n             let msg = format!(\"unrecognized platform-specific intrinsic function: `{}`\", name);\n             tcx.sess.struct_span_err(it.span, &msg).emit();"}, {"sha": "611406bd052dc53ddaaa85ea190af179717811af", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -17,7 +17,7 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::{\n     self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{source_map, FileName, Span};\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::Obligation;\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 let mut fallback_span = true;\n                 let msg = \"remove this method call\";\n-                if item_name.as_str() == \"as_str\" && actual.peel_refs().is_str() {\n+                if item_name.name == sym::as_str && actual.peel_refs().is_str() {\n                     if let SelfSource::MethodCall(expr) = source {\n                         let call_expr =\n                             self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));"}, {"sha": "b61aa73bb0184cca73211de38d8849eff8cbccd4", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple,\n use rustc_middle::ty::{\n     self, suggest_constraining_type_param, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n };\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::infer::InferCtxtExt;\n \n@@ -702,16 +702,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n         let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n             match op.node {\n-                hir::BinOpKind::Add => (\"add_assign\", lang.add_assign_trait()),\n-                hir::BinOpKind::Sub => (\"sub_assign\", lang.sub_assign_trait()),\n-                hir::BinOpKind::Mul => (\"mul_assign\", lang.mul_assign_trait()),\n-                hir::BinOpKind::Div => (\"div_assign\", lang.div_assign_trait()),\n-                hir::BinOpKind::Rem => (\"rem_assign\", lang.rem_assign_trait()),\n-                hir::BinOpKind::BitXor => (\"bitxor_assign\", lang.bitxor_assign_trait()),\n-                hir::BinOpKind::BitAnd => (\"bitand_assign\", lang.bitand_assign_trait()),\n-                hir::BinOpKind::BitOr => (\"bitor_assign\", lang.bitor_assign_trait()),\n-                hir::BinOpKind::Shl => (\"shl_assign\", lang.shl_assign_trait()),\n-                hir::BinOpKind::Shr => (\"shr_assign\", lang.shr_assign_trait()),\n+                hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n+                hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n+                hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n+                hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n+                hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n+                hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n+                hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n+                hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n+                hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n+                hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n                 hir::BinOpKind::Lt\n                 | hir::BinOpKind::Le\n                 | hir::BinOpKind::Ge\n@@ -725,30 +725,30 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         } else if let Op::Binary(op, IsAssign::No) = op {\n             match op.node {\n-                hir::BinOpKind::Add => (\"add\", lang.add_trait()),\n-                hir::BinOpKind::Sub => (\"sub\", lang.sub_trait()),\n-                hir::BinOpKind::Mul => (\"mul\", lang.mul_trait()),\n-                hir::BinOpKind::Div => (\"div\", lang.div_trait()),\n-                hir::BinOpKind::Rem => (\"rem\", lang.rem_trait()),\n-                hir::BinOpKind::BitXor => (\"bitxor\", lang.bitxor_trait()),\n-                hir::BinOpKind::BitAnd => (\"bitand\", lang.bitand_trait()),\n-                hir::BinOpKind::BitOr => (\"bitor\", lang.bitor_trait()),\n-                hir::BinOpKind::Shl => (\"shl\", lang.shl_trait()),\n-                hir::BinOpKind::Shr => (\"shr\", lang.shr_trait()),\n-                hir::BinOpKind::Lt => (\"lt\", lang.partial_ord_trait()),\n-                hir::BinOpKind::Le => (\"le\", lang.partial_ord_trait()),\n-                hir::BinOpKind::Ge => (\"ge\", lang.partial_ord_trait()),\n-                hir::BinOpKind::Gt => (\"gt\", lang.partial_ord_trait()),\n-                hir::BinOpKind::Eq => (\"eq\", lang.eq_trait()),\n-                hir::BinOpKind::Ne => (\"ne\", lang.eq_trait()),\n+                hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n+                hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n+                hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n+                hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n+                hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n+                hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n+                hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n+                hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n+                hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n+                hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n+                hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n+                hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n+                hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n+                hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n+                hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n+                hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n                 hir::BinOpKind::And | hir::BinOpKind::Or => {\n                     span_bug!(span, \"&& and || are not overloadable\")\n                 }\n             }\n         } else if let Op::Unary(hir::UnOp::UnNot, _) = op {\n-            (\"not\", lang.not_trait())\n+            (sym::not, lang.not_trait())\n         } else if let Op::Unary(hir::UnOp::UnNeg, _) = op {\n-            (\"neg\", lang.neg_trait())\n+            (sym::neg, lang.neg_trait())\n         } else {\n             bug!(\"lookup_op_method: op not supported: {:?}\", op)\n         };\n@@ -759,7 +759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let method = trait_did.and_then(|trait_did| {\n-            let opname = Ident::from_str(opname);\n+            let opname = Ident::with_dummy_span(opname);\n             self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n         });\n "}, {"sha": "53979d27052d3b34b51d697cdf505dd26c0fc4d8", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -162,8 +162,8 @@ impl Cfg {\n             Cfg::Any(ref sub_cfgs) | Cfg::All(ref sub_cfgs) => {\n                 sub_cfgs.first().map(Cfg::should_capitalize_first_letter).unwrap_or(false)\n             }\n-            Cfg::Cfg(name, _) => match &*name.as_str() {\n-                \"debug_assertions\" | \"target_endian\" => true,\n+            Cfg::Cfg(name, _) => match name {\n+                sym::debug_assertions | sym::target_endian => true,\n                 _ => false,\n             },\n         }\n@@ -347,12 +347,11 @@ impl<'a> fmt::Display for Html<'a> {\n             Cfg::False => fmt.write_str(\"nowhere\"),\n \n             Cfg::Cfg(name, value) => {\n-                let n = &*name.as_str();\n-                let human_readable = match (n, value) {\n-                    (\"unix\", None) => \"Unix\",\n-                    (\"windows\", None) => \"Windows\",\n-                    (\"debug_assertions\", None) => \"debug-assertions enabled\",\n-                    (\"target_os\", Some(os)) => match &*os.as_str() {\n+                let human_readable = match (name, value) {\n+                    (sym::unix, None) => \"Unix\",\n+                    (sym::windows, None) => \"Windows\",\n+                    (sym::debug_assertions, None) => \"debug-assertions enabled\",\n+                    (sym::target_os, Some(os)) => match &*os.as_str() {\n                         \"android\" => \"Android\",\n                         \"dragonfly\" => \"DragonFly BSD\",\n                         \"emscripten\" => \"Emscripten\",\n@@ -372,7 +371,7 @@ impl<'a> fmt::Display for Html<'a> {\n                         \"windows\" => \"Windows\",\n                         _ => \"\",\n                     },\n-                    (\"target_arch\", Some(arch)) => match &*arch.as_str() {\n+                    (sym::target_arch, Some(arch)) => match &*arch.as_str() {\n                         \"aarch64\" => \"AArch64\",\n                         \"arm\" => \"ARM\",\n                         \"asmjs\" => \"JavaScript\",\n@@ -388,15 +387,15 @@ impl<'a> fmt::Display for Html<'a> {\n                         \"x86_64\" => \"x86-64\",\n                         _ => \"\",\n                     },\n-                    (\"target_vendor\", Some(vendor)) => match &*vendor.as_str() {\n+                    (sym::target_vendor, Some(vendor)) => match &*vendor.as_str() {\n                         \"apple\" => \"Apple\",\n                         \"pc\" => \"PC\",\n                         \"rumprun\" => \"Rumprun\",\n                         \"sun\" => \"Sun\",\n                         \"fortanix\" => \"Fortanix\",\n                         _ => \"\",\n                     },\n-                    (\"target_env\", Some(env)) => match &*env.as_str() {\n+                    (sym::target_env, Some(env)) => match &*env.as_str() {\n                         \"gnu\" => \"GNU\",\n                         \"msvc\" => \"MSVC\",\n                         \"musl\" => \"musl\",\n@@ -405,9 +404,9 @@ impl<'a> fmt::Display for Html<'a> {\n                         \"sgx\" => \"SGX\",\n                         _ => \"\",\n                     },\n-                    (\"target_endian\", Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n-                    (\"target_pointer_width\", Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n-                    (\"target_feature\", Some(feat)) => {\n+                    (sym::target_endian, Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n+                    (sym::target_pointer_width, Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n+                    (sym::target_feature, Some(feat)) => {\n                         if self.1 {\n                             return write!(fmt, \"<code>{}</code>\", feat);\n                         } else {\n@@ -419,9 +418,14 @@ impl<'a> fmt::Display for Html<'a> {\n                 if !human_readable.is_empty() {\n                     fmt.write_str(human_readable)\n                 } else if let Some(v) = value {\n-                    write!(fmt, \"<code>{}=\\\"{}\\\"</code>\", Escape(n), Escape(&v.as_str()))\n+                    write!(\n+                        fmt,\n+                        \"<code>{}=\\\"{}\\\"</code>\",\n+                        Escape(&name.as_str()),\n+                        Escape(&v.as_str())\n+                    )\n                 } else {\n-                    write!(fmt, \"<code>{}</code>\", Escape(n))\n+                    write!(fmt, \"<code>{}</code>\", Escape(&name.as_str()))\n                 }\n             }\n         }"}, {"sha": "03d6853494cfc839d4f39180fb1ab34da2d1ac2f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -114,7 +114,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                 for attr in attrs.lists(sym::doc) {\n                     if let Some(v) = attr.value_str() {\n                         if attr.check_name(sym::primitive) {\n-                            prim = PrimitiveType::from_str(&v.as_str());\n+                            prim = PrimitiveType::from_symbol(v);\n                             if prim.is_some() {\n                                 break;\n                             }"}, {"sha": "10a542eb2546677032cf7feea6221a16fed5323b", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -21,7 +21,7 @@ use rustc_index::vec::IndexVec;\n use rustc_middle::middle::stability;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n-use rustc_span::symbol::{sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, FileName};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n@@ -1230,33 +1230,33 @@ impl GetDefId for Type {\n }\n \n impl PrimitiveType {\n-    pub fn from_str(s: &str) -> Option<PrimitiveType> {\n+    pub fn from_symbol(s: Symbol) -> Option<PrimitiveType> {\n         match s {\n-            \"isize\" => Some(PrimitiveType::Isize),\n-            \"i8\" => Some(PrimitiveType::I8),\n-            \"i16\" => Some(PrimitiveType::I16),\n-            \"i32\" => Some(PrimitiveType::I32),\n-            \"i64\" => Some(PrimitiveType::I64),\n-            \"i128\" => Some(PrimitiveType::I128),\n-            \"usize\" => Some(PrimitiveType::Usize),\n-            \"u8\" => Some(PrimitiveType::U8),\n-            \"u16\" => Some(PrimitiveType::U16),\n-            \"u32\" => Some(PrimitiveType::U32),\n-            \"u64\" => Some(PrimitiveType::U64),\n-            \"u128\" => Some(PrimitiveType::U128),\n-            \"bool\" => Some(PrimitiveType::Bool),\n-            \"char\" => Some(PrimitiveType::Char),\n-            \"str\" => Some(PrimitiveType::Str),\n-            \"f32\" => Some(PrimitiveType::F32),\n-            \"f64\" => Some(PrimitiveType::F64),\n-            \"array\" => Some(PrimitiveType::Array),\n-            \"slice\" => Some(PrimitiveType::Slice),\n-            \"tuple\" => Some(PrimitiveType::Tuple),\n-            \"unit\" => Some(PrimitiveType::Unit),\n-            \"pointer\" => Some(PrimitiveType::RawPointer),\n-            \"reference\" => Some(PrimitiveType::Reference),\n-            \"fn\" => Some(PrimitiveType::Fn),\n-            \"never\" => Some(PrimitiveType::Never),\n+            sym::isize => Some(PrimitiveType::Isize),\n+            sym::i8 => Some(PrimitiveType::I8),\n+            sym::i16 => Some(PrimitiveType::I16),\n+            sym::i32 => Some(PrimitiveType::I32),\n+            sym::i64 => Some(PrimitiveType::I64),\n+            sym::i128 => Some(PrimitiveType::I128),\n+            sym::usize => Some(PrimitiveType::Usize),\n+            sym::u8 => Some(PrimitiveType::U8),\n+            sym::u16 => Some(PrimitiveType::U16),\n+            sym::u32 => Some(PrimitiveType::U32),\n+            sym::u64 => Some(PrimitiveType::U64),\n+            sym::u128 => Some(PrimitiveType::U128),\n+            sym::bool => Some(PrimitiveType::Bool),\n+            sym::char => Some(PrimitiveType::Char),\n+            sym::str => Some(PrimitiveType::Str),\n+            sym::f32 => Some(PrimitiveType::F32),\n+            sym::f64 => Some(PrimitiveType::F64),\n+            sym::array => Some(PrimitiveType::Array),\n+            sym::slice => Some(PrimitiveType::Slice),\n+            sym::tuple => Some(PrimitiveType::Tuple),\n+            sym::unit => Some(PrimitiveType::Unit),\n+            sym::pointer => Some(PrimitiveType::RawPointer),\n+            sym::reference => Some(PrimitiveType::Reference),\n+            kw::Fn => Some(PrimitiveType::Fn),\n+            sym::never => Some(PrimitiveType::Never),\n             _ => None,\n         }\n     }"}, {"sha": "96044a89289464a86d01f8d1b44be3a9beb7741f", "filename": "src/test/ui/hygiene/unpretty-debug.stdout", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f04e866e5752f47e0896550faf40e19fea22d8ea/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Funpretty-debug.stdout?ref=f04e866e5752f47e0896550faf40e19fea22d8ea", "patch": "@@ -10,7 +10,10 @@\n \n macro_rules! foo /* 0#0 */ { ($ x : ident) => { y + $ x } }\n \n-fn bar /* 0#0 */() { let x /* 0#0 */ = 1; y /* 0#1 */ + x /* 0#0 */ }\n+fn bar /* 0#0 */() {\n+    let x /* 0#0 */ = 1;\n+    y /* 0#1 */ + x /* 0#0 */\n+}\n \n fn y /* 0#0 */() { }\n "}]}