{"sha": "b361f6c288d15463fee84d3b34c1837ab3dd7252", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzNjFmNmMyODhkMTU0NjNmZWU4NGQzYjM0YzE4MzdhYjNkZDcyNTI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-06-13T00:20:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-06-13T01:10:19Z"}, "message": "Fix json no-implicit-copy warnings", "tree": {"sha": "e724f9d895d61d6693820f1226a5f96dfcd06dad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e724f9d895d61d6693820f1226a5f96dfcd06dad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b361f6c288d15463fee84d3b34c1837ab3dd7252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b361f6c288d15463fee84d3b34c1837ab3dd7252", "html_url": "https://github.com/rust-lang/rust/commit/b361f6c288d15463fee84d3b34c1837ab3dd7252", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b361f6c288d15463fee84d3b34c1837ab3dd7252/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cc0a0e19c153102de94261d8bc9c7f70bd63a85", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cc0a0e19c153102de94261d8bc9c7f70bd63a85", "html_url": "https://github.com/rust-lang/rust/commit/2cc0a0e19c153102de94261d8bc9c7f70bd63a85"}], "stats": {"total": 265, "additions": 139, "deletions": 126}, "files": [{"sha": "2bfde838bce4387f4a330457d9eb30b7864a0181", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b361f6c288d15463fee84d3b34c1837ab3dd7252/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b361f6c288d15463fee84d3b34c1837ab3dd7252/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=b361f6c288d15463fee84d3b34c1837ab3dd7252", "patch": "@@ -400,25 +400,25 @@ fn parse_source(name: str, j: json::json) -> source {\n         json::dict(j) {\n             let mut url = alt j.find(\"url\") {\n                 some(json::string(u)) {\n-                    u\n+                    *u\n                 }\n                 _ { fail \"needed 'url' field in source\"; }\n             };\n             let method = alt j.find(\"method\") {\n                 some(json::string(u)) {\n-                    u\n+                    *u\n                 }\n                 _ { assume_source_method(url) }\n             };\n             let key = alt j.find(\"key\") {\n                 some(json::string(u)) {\n-                    some(u)\n+                    some(*u)\n                 }\n                 _ { none }\n             };\n             let keyfp = alt j.find(\"keyfp\") {\n                 some(json::string(u)) {\n-                    some(u)\n+                    some(*u)\n                 }\n                 _ { none }\n             };\n@@ -455,13 +455,13 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n         some(json::string(n)) {\n-            if !valid_pkg_name(n) {\n-                warn(\"malformed source json: \" + src.name + \", '\" + n + \"'\"+\n+            if !valid_pkg_name(*n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + *n + \"'\"+\n                      \" is an invalid name (alphanumeric, underscores and\" +\n                      \" dashes only)\");\n                 ret;\n             }\n-            n\n+            *n\n         }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing name)\");\n@@ -471,12 +471,12 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n \n     let uuid = alt p.find(\"uuid\") {\n         some(json::string(n)) {\n-            if !is_uuid(n) {\n-                warn(\"malformed source json: \" + src.name + \", '\" + n + \"'\"+\n+            if !is_uuid(*n) {\n+                warn(\"malformed source json: \" + src.name + \", '\" + *n + \"'\"+\n                      \" is an invalid uuid\");\n                 ret;\n             }\n-            n\n+            *n\n         }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing uuid)\");\n@@ -485,32 +485,32 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     };\n \n     let url = alt p.find(\"url\") {\n-        some(json::string(n)) { n }\n+        some(json::string(n)) { *n }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing url)\");\n             ret;\n         }\n     };\n \n     let method = alt p.find(\"method\") {\n-        some(json::string(n)) { n }\n+        some(json::string(n)) { *n }\n         _ {\n             warn(\"malformed source json: \" + src.name + \" (missing method)\");\n             ret;\n         }\n     };\n \n     let ref = alt p.find(\"ref\") {\n-        some(json::string(n)) { some(n) }\n+        some(json::string(n)) { some(*n) }\n         _ { none }\n     };\n \n     let mut tags = [];\n     alt p.find(\"tags\") {\n         some(json::list(js)) {\n-            for js.each {|j|\n+            for (*js).each {|j|\n                 alt j {\n-                    json::string(j) { vec::grow(tags, 1u, j); }\n+                    json::string(j) { vec::grow(tags, 1u, *j); }\n                     _ { }\n                 }\n             }\n@@ -519,7 +519,7 @@ fn load_one_source_package(src: source, p: map::hashmap<str, json::json>) {\n     }\n \n     let description = alt p.find(\"description\") {\n-        some(json::string(n)) { n }\n+        some(json::string(n)) { *n }\n         _ {\n             warn(\"malformed source json: \" + src.name\n                  + \" (missing description)\");\n@@ -580,7 +580,7 @@ fn load_source_packages(c: cargo, src: source) {\n     let pkgstr = io::read_whole_file_str(pkgfile);\n     alt json::from_str(result::get(pkgstr)) {\n         ok(json::list(js)) {\n-            for js.each {|j|\n+            for (*js).each {|j|\n                 alt j {\n                     json::dict(p) {\n                         load_one_source_package(src, p);\n@@ -1576,18 +1576,18 @@ fn dump_sources(c: cargo) {\n                 let chash = map::str_hash();\n                 let child = json::dict(chash);\n \n-                chash.insert(\"url\", json::string(v.url));\n-                chash.insert(\"method\", json::string(v.method));\n+                chash.insert(\"url\", json::string(@v.url));\n+                chash.insert(\"method\", json::string(@v.method));\n \n                 alt copy v.key {\n                     some(key) {\n-                        chash.insert(\"key\", json::string(key));\n+                        chash.insert(\"key\", json::string(@key));\n                     }\n                     _ {}\n                 }\n                 alt copy v.keyfp {\n                     some(keyfp) {\n-                        chash.insert(\"keyfp\", json::string(keyfp));\n+                        chash.insert(\"keyfp\", json::string(@keyfp));\n                     }\n                     _ {}\n                 }"}, {"sha": "1ac6a5476597803be7cf5c85213f6757646456e8", "filename": "src/libstd/json.rs", "status": "modified", "additions": 118, "deletions": 105, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/b361f6c288d15463fee84d3b34c1837ab3dd7252/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b361f6c288d15463fee84d3b34c1837ab3dd7252/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=b361f6c288d15463fee84d3b34c1837ab3dd7252", "patch": "@@ -28,48 +28,33 @@ export null;\n #[doc = \"Represents a json value\"]\n enum json {\n     num(float),\n-    string(str),\n+    string(@str),\n     boolean(bool),\n-    list([json]),\n-    dict(map::hashmap<str,json>),\n+    list(@[json]),\n+    dict(map::hashmap<str, json>),\n     null,\n }\n \n type error = {\n     line: uint,\n     col: uint,\n-    msg: str,\n+    msg: @str,\n };\n \n #[doc = \"Serializes a json value into a io::writer\"]\n fn to_writer(wr: io::writer, j: json) {\n     alt j {\n       num(n) { wr.write_str(float::to_str(n, 6u)); }\n       string(s) {\n-        wr.write_char('\"');\n-        let mut escaped = \"\";\n-        str::chars_iter(s) { |c|\n-            alt c {\n-              '\"' { escaped += \"\\\\\\\"\"; }\n-              '\\\\' { escaped += \"\\\\\\\\\"; }\n-              '\\x08' { escaped += \"\\\\b\"; }\n-              '\\x0c' { escaped += \"\\\\f\"; }\n-              '\\n' { escaped += \"\\\\n\"; }\n-              '\\r' { escaped += \"\\\\r\"; }\n-              '\\t' { escaped += \"\\\\t\"; }\n-              _ { escaped += str::from_char(c); }\n-            }\n-        };\n-        wr.write_str(escaped);\n-        wr.write_char('\"');\n+        wr.write_str(escape_str(*s));\n       }\n       boolean(b) {\n         wr.write_str(if b { \"true\" } else { \"false\" });\n       }\n       list(v) {\n         wr.write_char('[');\n         let mut first = true;\n-        vec::iter(v) { |item|\n+        for (*v).each { |item|\n             if !first {\n                 wr.write_str(\", \");\n             }\n@@ -91,7 +76,7 @@ fn to_writer(wr: io::writer, j: json) {\n                 wr.write_str(\", \");\n             }\n             first = false;\n-            to_writer(wr, string(key));\n+            wr.write_str(escape_str(key));\n             wr.write_str(\": \");\n             to_writer(wr, value);\n         };\n@@ -103,6 +88,26 @@ fn to_writer(wr: io::writer, j: json) {\n     }\n }\n \n+fn escape_str(s: str) -> str {\n+    let mut escaped = \"\\\"\";\n+    str::chars_iter(s) { |c|\n+        alt c {\n+          '\"' { escaped += \"\\\\\\\"\"; }\n+          '\\\\' { escaped += \"\\\\\\\\\"; }\n+          '\\x08' { escaped += \"\\\\b\"; }\n+          '\\x0c' { escaped += \"\\\\f\"; }\n+          '\\n' { escaped += \"\\\\n\"; }\n+          '\\r' { escaped += \"\\\\r\"; }\n+          '\\t' { escaped += \"\\\\t\"; }\n+          _ { escaped += str::from_char(c); }\n+        }\n+    };\n+\n+    escaped += \"\\\"\";\n+\n+    escaped\n+}\n+\n #[doc = \"Serializes a json value into a string\"]\n fn to_str(j: json) -> str {\n     io::with_str_writer { |wr| to_writer(wr, j) }\n@@ -134,8 +139,8 @@ impl parser for parser {\n         self.ch\n     }\n \n-    fn error<T>(msg: str) -> result<T, error> {\n-        err({ line: self.line, col: self.col, msg: msg })\n+    fn error<T>(+msg: str) -> result<T, error> {\n+        err({ line: self.line, col: self.col, msg: @msg })\n     }\n \n     fn parse() -> result<json, error> {\n@@ -318,7 +323,7 @@ impl parser for parser {\n         ok(res)\n     }\n \n-    fn parse_str() -> result<str, error> {\n+    fn parse_str() -> result<@str, error> {\n         let mut escape = false;\n         let mut res = \"\";\n \n@@ -365,7 +370,7 @@ impl parser for parser {\n             } else {\n                 if self.ch == '\"' {\n                     self.bump();\n-                    ret ok(res);\n+                    ret ok(@res);\n                 }\n                 str::push_char(res, self.ch);\n             }\n@@ -382,7 +387,7 @@ impl parser for parser {\n \n         if self.ch == ']' {\n             self.bump();\n-            ret ok(list(values));\n+            ret ok(list(@values));\n         }\n \n         loop {\n@@ -398,7 +403,7 @@ impl parser for parser {\n \n             alt self.ch {\n               ',' { self.bump(); }\n-              ']' { self.bump(); ret ok(list(values)); }\n+              ']' { self.bump(); ret ok(list(@values)); }\n               _ { ret self.error(\"expecting ',' or ']'\"); }\n             }\n         };\n@@ -436,7 +441,7 @@ impl parser for parser {\n             self.bump();\n \n             alt self.parse_value() {\n-              ok(value) { values.insert(key, value); }\n+              ok(value) { values.insert(copy *key, value); }\n               e { ret e; }\n             }\n             self.parse_whitespace();\n@@ -478,7 +483,7 @@ fn eq(value0: json, value1: json) -> bool {\n       (num(f0), num(f1)) { f0 == f1 }\n       (string(s0), string(s1)) { s0 == s1 }\n       (boolean(b0), boolean(b1)) { b0 == b1 }\n-      (list(l0), list(l1)) { vec::all2(l0, l1, eq) }\n+      (list(l0), list(l1)) { vec::all2(*l0, *l1, eq) }\n       (dict(d0), dict(d1)) {\n           if d0.size() == d1.size() {\n               let mut equal = true;\n@@ -558,33 +563,37 @@ impl of to_json for bool {\n }\n \n impl of to_json for str {\n+    fn to_json() -> json { string(@copy self) }\n+}\n+\n+impl of to_json for @str {\n     fn to_json() -> json { string(self) }\n }\n \n impl <A: to_json copy, B: to_json copy> of to_json for (A, B) {\n     fn to_json() -> json {\n         let (a, b) = self;\n-        list([a.to_json(), b.to_json()])\n+        list(@[a.to_json(), b.to_json()])\n     }\n }\n \n impl <A: to_json copy, B: to_json copy, C: to_json copy>\n   of to_json for (A, B, C) {\n     fn to_json() -> json {\n         let (a, b, c) = self;\n-        list([a.to_json(), b.to_json(), c.to_json()])\n+        list(@[a.to_json(), b.to_json(), c.to_json()])\n     }\n }\n \n impl <A: to_json> of to_json for [A] {\n-    fn to_json() -> json { list(self.map { |elt| elt.to_json() }) }\n+    fn to_json() -> json { list(@self.map { |elt| elt.to_json() }) }\n }\n \n impl <A: to_json copy> of to_json for hashmap<str, A> {\n     fn to_json() -> json {\n         let d = map::str_hash();\n         for self.each() { |key, value|\n-            d.insert(key, value.to_json());\n+            d.insert(copy key, value.to_json());\n         }\n         dict(d)\n     }\n@@ -605,7 +614,7 @@ impl of to_str::to_str for json {\n \n impl of to_str::to_str for error {\n     fn to_str() -> str {\n-        #fmt(\"%u:%u: %s\", self.line, self.col, self.msg)\n+        #fmt(\"%u:%u: %s\", self.line, self.col, *self.msg)\n     }\n }\n \n@@ -615,7 +624,7 @@ mod tests {\n         let d = map::str_hash();\n \n         vec::iter(items) { |item|\n-            let (key, value) = item;\n+            let (key, value) = copy item;\n             d.insert(key, value);\n         };\n \n@@ -637,8 +646,8 @@ mod tests {\n \n     #[test]\n     fn test_write_str() {\n-        assert to_str(string(\"\")) == \"\\\"\\\"\";\n-        assert to_str(string(\"foo\")) == \"\\\"foo\\\"\";\n+        assert to_str(string(@\"\")) == \"\\\"\\\"\";\n+        assert to_str(string(@\"foo\")) == \"\\\"foo\\\"\";\n     }\n \n     #[test]\n@@ -649,12 +658,12 @@ mod tests {\n \n     #[test]\n     fn test_write_list() {\n-        assert to_str(list([])) == \"[]\";\n-        assert to_str(list([boolean(true)])) == \"[true]\";\n-        assert to_str(list([\n+        assert to_str(list(@[])) == \"[]\";\n+        assert to_str(list(@[boolean(true)])) == \"[true]\";\n+        assert to_str(list(@[\n             boolean(false),\n             null,\n-            list([string(\"foo\\nbar\"), num(3.5f)])\n+            list(@[string(@\"foo\\nbar\"), num(3.5f)])\n         ])) == \"[false, null, [\\\"foo\\\\nbar\\\", 3.5]]\";\n     }\n \n@@ -664,9 +673,9 @@ mod tests {\n         assert to_str(mk_dict([(\"a\", boolean(true))])) == \"{ \\\"a\\\": true }\";\n         assert to_str(mk_dict([\n             (\"a\", boolean(true)),\n-            (\"b\", list([\n-                mk_dict([(\"c\", string(\"\\x0c\\r\"))]),\n-                mk_dict([(\"d\", string(\"\"))])\n+            (\"b\", list(@[\n+                mk_dict([(\"c\", string(@\"\\x0c\\r\"))]),\n+                mk_dict([(\"d\", string(@\"\"))])\n             ]))\n         ])) ==\n             \"{ \" +\n@@ -681,35 +690,35 @@ mod tests {\n     #[test]\n     fn test_trailing_characters() {\n         assert from_str(\"nulla\") ==\n-            err({line: 1u, col: 5u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 5u, msg: @\"trailing characters\"});\n         assert from_str(\"truea\") ==\n-            err({line: 1u, col: 5u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 5u, msg: @\"trailing characters\"});\n         assert from_str(\"falsea\") ==\n-            err({line: 1u, col: 6u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 6u, msg: @\"trailing characters\"});\n         assert from_str(\"1a\") ==\n-            err({line: 1u, col: 2u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 2u, msg: @\"trailing characters\"});\n         assert from_str(\"[]a\") ==\n-            err({line: 1u, col: 3u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n         assert from_str(\"{}a\") ==\n-            err({line: 1u, col: 3u, msg: \"trailing characters\"});\n+            err({line: 1u, col: 3u, msg: @\"trailing characters\"});\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert from_str(\"n\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n         assert from_str(\"nul\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"t\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n         assert from_str(\"truz\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"f\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid syntax\"});\n         assert from_str(\"faz\") ==\n-            err({line: 1u, col: 3u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 3u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"null\") == ok(null);\n         assert from_str(\"true\") == ok(boolean(true));\n@@ -722,20 +731,20 @@ mod tests {\n     #[test]\n     fn test_read_num() {\n         assert from_str(\"+\") ==\n-            err({line: 1u, col: 1u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 1u, msg: @\"invalid syntax\"});\n         assert from_str(\".\") ==\n-            err({line: 1u, col: 1u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 1u, msg: @\"invalid syntax\"});\n \n         assert from_str(\"-\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid number\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid number\"});\n         assert from_str(\"00\") ==\n-            err({line: 1u, col: 2u, msg: \"invalid number\"});\n+            err({line: 1u, col: 2u, msg: @\"invalid number\"});\n         assert from_str(\"1.\") ==\n-            err({line: 1u, col: 3u, msg: \"invalid number\"});\n+            err({line: 1u, col: 3u, msg: @\"invalid number\"});\n         assert from_str(\"1e\") ==\n-            err({line: 1u, col: 3u, msg: \"invalid number\"});\n+            err({line: 1u, col: 3u, msg: @\"invalid number\"});\n         assert from_str(\"1e+\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid number\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid number\"});\n \n         assert from_str(\"3\") == ok(num(3f));\n         assert from_str(\"3.1\") == ok(num(3.1f));\n@@ -750,82 +759,86 @@ mod tests {\n     #[test]\n     fn test_read_str() {\n         assert from_str(\"\\\"\") ==\n-            err({line: 1u, col: 2u, msg: \"EOF while parsing string\"});\n+            err({line: 1u, col: 2u, msg: @\"EOF while parsing string\"});\n         assert from_str(\"\\\"lol\") ==\n-            err({line: 1u, col: 5u, msg: \"EOF while parsing string\"});\n+            err({line: 1u, col: 5u, msg: @\"EOF while parsing string\"});\n \n-        assert from_str(\"\\\"\\\"\") == ok(string(\"\"));\n-        assert from_str(\"\\\"foo\\\"\") == ok(string(\"foo\"));\n-        assert from_str(\"\\\"\\\\\\\"\\\"\") == ok(string(\"\\\"\"));\n-        assert from_str(\"\\\"\\\\b\\\"\") == ok(string(\"\\x08\"));\n-        assert from_str(\"\\\"\\\\n\\\"\") == ok(string(\"\\n\"));\n-        assert from_str(\"\\\"\\\\r\\\"\") == ok(string(\"\\r\"));\n-        assert from_str(\"\\\"\\\\t\\\"\") == ok(string(\"\\t\"));\n-        assert from_str(\" \\\"foo\\\" \") == ok(string(\"foo\"));\n+        assert from_str(\"\\\"\\\"\") == ok(string(@\"\"));\n+        assert from_str(\"\\\"foo\\\"\") == ok(string(@\"foo\"));\n+        assert from_str(\"\\\"\\\\\\\"\\\"\") == ok(string(@\"\\\"\"));\n+        assert from_str(\"\\\"\\\\b\\\"\") == ok(string(@\"\\x08\"));\n+        assert from_str(\"\\\"\\\\n\\\"\") == ok(string(@\"\\n\"));\n+        assert from_str(\"\\\"\\\\r\\\"\") == ok(string(@\"\\r\"));\n+        assert from_str(\"\\\"\\\\t\\\"\") == ok(string(@\"\\t\"));\n+        assert from_str(\" \\\"foo\\\" \") == ok(string(@\"foo\"));\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert from_str(\"[\") ==\n-            err({line: 1u, col: 2u, msg: \"EOF while parsing value\"});\n+            err({line: 1u, col: 2u, msg: @\"EOF while parsing value\"});\n         assert from_str(\"[1\") ==\n-            err({line: 1u, col: 3u, msg: \"EOF while parsing list\"});\n+            err({line: 1u, col: 3u, msg: @\"EOF while parsing list\"});\n         assert from_str(\"[1,\") ==\n-            err({line: 1u, col: 4u, msg: \"EOF while parsing value\"});\n+            err({line: 1u, col: 4u, msg: @\"EOF while parsing value\"});\n         assert from_str(\"[1,]\") ==\n-            err({line: 1u, col: 4u, msg: \"invalid syntax\"});\n+            err({line: 1u, col: 4u, msg: @\"invalid syntax\"});\n         assert from_str(\"[6 7]\") ==\n-            err({line: 1u, col: 4u, msg: \"expecting ',' or ']'\"});\n-\n-        assert from_str(\"[]\") == ok(list([]));\n-        assert from_str(\"[ ]\") == ok(list([]));\n-        assert from_str(\"[true]\") == ok(list([boolean(true)]));\n-        assert from_str(\"[ false ]\") == ok(list([boolean(false)]));\n-        assert from_str(\"[null]\") == ok(list([null]));\n-        assert from_str(\"[3, 1]\") == ok(list([num(3f), num(1f)]));\n-        assert from_str(\"\\n[3, 2]\\n\") == ok(list([num(3f), num(2f)]));\n+            err({line: 1u, col: 4u, msg: @\"expecting ',' or ']'\"});\n+\n+        assert from_str(\"[]\") == ok(list(@[]));\n+        assert from_str(\"[ ]\") == ok(list(@[]));\n+        assert from_str(\"[true]\") == ok(list(@[boolean(true)]));\n+        assert from_str(\"[ false ]\") == ok(list(@[boolean(false)]));\n+        assert from_str(\"[null]\") == ok(list(@[null]));\n+        assert from_str(\"[3, 1]\") == ok(list(@[num(3f), num(1f)]));\n+        assert from_str(\"\\n[3, 2]\\n\") == ok(list(@[num(3f), num(2f)]));\n         assert from_str(\"[2, [4, 1]]\") ==\n-               ok(list([num(2f), list([num(4f), num(1f)])]));\n+               ok(list(@[num(2f), list(@[num(4f), num(1f)])]));\n     }\n \n     #[test]\n     fn test_read_dict() {\n         assert from_str(\"{\") ==\n-            err({line: 1u, col: 2u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 2u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{ \") ==\n-            err({line: 1u, col: 3u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 3u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{1\") ==\n-            err({line: 1u, col: 2u, msg: \"key must be a string\"});\n+            err({line: 1u, col: 2u, msg: @\"key must be a string\"});\n         assert from_str(\"{ \\\"a\\\"\") ==\n-            err({line: 1u, col: 6u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 6u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{\\\"a\\\"\") ==\n-            err({line: 1u, col: 5u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 5u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{\\\"a\\\" \") ==\n-            err({line: 1u, col: 6u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 6u, msg: @\"EOF while parsing object\"});\n \n         assert from_str(\"{\\\"a\\\" 1\") ==\n-            err({line: 1u, col: 6u, msg: \"expecting ':'\"});\n+            err({line: 1u, col: 6u, msg: @\"expecting ':'\"});\n         assert from_str(\"{\\\"a\\\":\") ==\n-            err({line: 1u, col: 6u, msg: \"EOF while parsing value\"});\n+            err({line: 1u, col: 6u, msg: @\"EOF while parsing value\"});\n         assert from_str(\"{\\\"a\\\":1\") ==\n-            err({line: 1u, col: 7u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 7u, msg: @\"EOF while parsing object\"});\n         assert from_str(\"{\\\"a\\\":1 1\") ==\n-            err({line: 1u, col: 8u, msg: \"expecting ',' or '}'\"});\n+            err({line: 1u, col: 8u, msg: @\"expecting ',' or '}'\"});\n         assert from_str(\"{\\\"a\\\":1,\") ==\n-            err({line: 1u, col: 8u, msg: \"EOF while parsing object\"});\n+            err({line: 1u, col: 8u, msg: @\"EOF while parsing object\"});\n \n         assert eq(result::get(from_str(\"{}\")), mk_dict([]));\n         assert eq(result::get(from_str(\"{\\\"a\\\": 3}\")),\n                   mk_dict([(\"a\", num(3.0f))]));\n \n         assert eq(result::get(from_str(\"{ \\\"a\\\": null, \\\"b\\\" : true }\")),\n-                  mk_dict([(\"a\", null), (\"b\", boolean(true))]));\n+                  mk_dict([\n+                      (\"a\", null),\n+                      (\"b\", boolean(true))]));\n         assert eq(result::get(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\")),\n-                  mk_dict([(\"a\", null), (\"b\", boolean(true))]));\n+                  mk_dict([\n+                      (\"a\", null),\n+                      (\"b\", boolean(true))]));\n         assert eq(result::get(from_str(\"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\")),\n                   mk_dict([\n                       (\"a\", num(1.0)),\n-                      (\"b\", list([boolean(true)]))\n+                      (\"b\", list(@[boolean(true)]))\n                   ]));\n         assert eq(result::get(from_str(\n                       \"{\" +\n@@ -838,9 +851,9 @@ mod tests {\n                       \"}\")),\n                   mk_dict([\n                       (\"a\", num(1.0f)),\n-                      (\"b\", list([\n+                      (\"b\", list(@[\n                           boolean(true),\n-                          string(\"foo\\nbar\"),\n+                          string(@\"foo\\nbar\"),\n                           mk_dict([\n                               (\"c\", mk_dict([(\"d\", null)]))\n                           ])\n@@ -851,6 +864,6 @@ mod tests {\n     #[test]\n     fn test_multiline_errors() {\n         assert from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\") ==\n-            err({line: 3u, col: 8u, msg: \"EOF while parsing object\"});\n+            err({line: 3u, col: 8u, msg: @\"EOF while parsing object\"});\n     }\n }"}]}