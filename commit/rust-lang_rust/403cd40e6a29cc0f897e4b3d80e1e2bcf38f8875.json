{"sha": "403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwM2NkNDBlNmEyOWNjMGY4OTdlNGIzZDgwZTFlMmJjZjM4Zjg4NzU=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-11T17:24:58Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-11T17:42:26Z"}, "message": "Remove `virtual` structs from the language", "tree": {"sha": "df9a8e78271637c38f85af47a25461f91952424c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df9a8e78271637c38f85af47a25461f91952424c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "html_url": "https://github.com/rust-lang/rust/commit/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/comments", "author": null, "committer": null, "parents": [{"sha": "9b9833299245cc1eac68b52169e9152d0f412d6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b9833299245cc1eac68b52169e9152d0f412d6b", "html_url": "https://github.com/rust-lang/rust/commit/9b9833299245cc1eac68b52169e9152d0f412d6b"}], "stats": {"total": 303, "additions": 43, "deletions": 260}, "files": [{"sha": "31dff0b147119c4bcc5de6c80eba9caf29d3f8db", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -56,7 +56,6 @@ register_diagnostics!(\n     E0038,\n     E0039,\n     E0040,\n-    E0041,\n     E0044,\n     E0045,\n     E0046,\n@@ -123,7 +122,6 @@ register_diagnostics!(\n     E0121,\n     E0122,\n     E0124,\n-    E0126,\n     E0127,\n     E0128,\n     E0129,\n@@ -141,9 +139,6 @@ register_diagnostics!(\n     E0141,\n     E0152,\n     E0153,\n-    E0154,\n-    E0155,\n-    E0156,\n     E0157,\n     E0158,\n     E0159,"}, {"sha": "c1c5c1af681f369eb5e3f160fa3db78944ed02a7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -54,7 +54,6 @@ use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::codemap::{Span, DUMMY_SP, Pos};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::ptr::P;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -4179,7 +4178,6 @@ impl<'a> Resolver<'a> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    &struct_def.super_struct,\n                                     struct_def.fields.as_slice());\n             }\n \n@@ -4505,7 +4503,6 @@ impl<'a> Resolver<'a> {\n     fn resolve_struct(&mut self,\n                       id: NodeId,\n                       generics: &Generics,\n-                      super_struct: &Option<P<Ty>>,\n                       fields: &[StructField]) {\n         // If applicable, create a rib for the type parameters.\n         self.with_type_parameter_rib(HasTypeParameters(generics,\n@@ -4517,42 +4514,6 @@ impl<'a> Resolver<'a> {\n             this.resolve_type_parameters(&generics.ty_params);\n             this.resolve_where_clause(&generics.where_clause);\n \n-            // Resolve the super struct.\n-            match *super_struct {\n-                Some(ref t) => match t.node {\n-                    TyPath(ref path, None, path_id) => {\n-                        match this.resolve_path(id, path, TypeNS, true) {\n-                            Some((DefTy(def_id, _), lp)) if this.structs.contains_key(&def_id) => {\n-                                let def = DefStruct(def_id);\n-                                debug!(\"(resolving struct) resolved `{}` to type {:?}\",\n-                                       token::get_ident(path.segments\n-                                                            .last().unwrap()\n-                                                            .identifier),\n-                                       def);\n-                                debug!(\"(resolving struct) writing resolution for `{}` (id {})\",\n-                                       this.path_idents_to_string(path),\n-                                       path_id);\n-                                this.record_def(path_id, (def, lp));\n-                            }\n-                            Some((DefStruct(_), _)) => {\n-                                span_err!(this.session, t.span, E0154,\n-                                    \"super-struct is defined in a different crate\");\n-                            },\n-                            Some(_) => {\n-                                span_err!(this.session, t.span, E0155,\n-                                    \"super-struct is not a struct type\");\n-                            }\n-                            None => {\n-                                span_err!(this.session, t.span, E0156,\n-                                    \"super-struct could not be resolved\");\n-                            }\n-                        }\n-                    },\n-                    _ => this.session.span_bug(t.span, \"path not mapped to a TyPath\")\n-                },\n-                None => {}\n-            }\n-\n             // Resolve fields.\n             for field in fields.iter() {\n                 this.resolve_type(&*field.node.ty);"}, {"sha": "071f6b12684651da85d9dde4ea4b0e58f18d045a", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 57, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -24,13 +24,11 @@ use middle::mem_categorization as mc;\n use middle::resolve;\n use middle::resolve_lifetime;\n use middle::stability;\n-use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::subst;\n+use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::typeck;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFoldable,TypeFolder};\n+use middle::ty_fold::{mod, TypeFoldable,TypeFolder};\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n@@ -40,10 +38,8 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet, FnvHashMap};\n \n use std::cell::{Cell, RefCell};\n use std::cmp;\n-use std::fmt::Show;\n-use std::fmt;\n+use std::fmt::{mod, Show};\n use std::hash::{Hash, sip, Writer};\n-use std::iter::AdditiveIterator;\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -55,15 +51,11 @@ use syntax::ast::{CrateNum, DefId, FnStyle, Ident, ItemTrait, LOCAL_CRATE};\n use syntax::ast::{MutImmutable, MutMutable, Name, NamedField, NodeId};\n use syntax::ast::{Onceness, StmtExpr, StmtSemi, StructField, UnnamedField};\n use syntax::ast::{Visibility};\n-use syntax::ast_util::{PostExpansionMethod, is_local, lit_is_str};\n-use syntax::ast_util;\n-use syntax::attr;\n-use syntax::attr::AttrMetaMethods;\n+use syntax::ast_util::{mod, PostExpansionMethod, is_local, lit_is_str};\n+use syntax::attr::{mod, AttrMetaMethods};\n use syntax::codemap::Span;\n-use syntax::parse::token;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{mod, InternedString};\n use syntax::{ast, ast_map};\n-use syntax::util::small_vector::SmallVector;\n use std::collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n@@ -493,7 +485,6 @@ pub struct ctxt<'tcx> {\n     pub lang_items: middle::lang_items::LanguageItems,\n     /// A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    pub superstructs: RefCell<DefIdMap<Option<ast::DefId>>>,\n     pub struct_fields: RefCell<DefIdMap<Rc<Vec<field_ty>>>>,\n \n     /// Maps from def-id of a type or region parameter to its\n@@ -1512,7 +1503,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         normalized_cache: RefCell::new(HashMap::new()),\n         lang_items: lang_items,\n         provided_method_sources: RefCell::new(DefIdMap::new()),\n-        superstructs: RefCell::new(DefIdMap::new()),\n         struct_fields: RefCell::new(DefIdMap::new()),\n         destructor_for_type: RefCell::new(DefIdMap::new()),\n         destructors: RefCell::new(DefIdSet::new()),\n@@ -4539,53 +4529,19 @@ pub fn lookup_field_type(tcx: &ctxt,\n     t.subst(tcx, substs)\n }\n \n-// Lookup all ancestor structs of a struct indicated by did. That is the reflexive,\n-// transitive closure of doing a single lookup in cx.superstructs.\n-fn each_super_struct(cx: &ctxt, mut did: ast::DefId, f: |ast::DefId|) {\n-    let superstructs = cx.superstructs.borrow();\n-\n-    loop {\n-        f(did);\n-        match superstructs.find(&did) {\n-            Some(&Some(def_id)) => {\n-                did = def_id;\n-            },\n-            Some(&None) => break,\n-            None => {\n-                cx.sess.bug(\n-                    format!(\"ID not mapped to super-struct: {}\",\n-                            cx.map.node_to_string(did.node)).as_slice());\n-            }\n-        }\n-    }\n-}\n-\n // Look up the list of field names and IDs for a given struct.\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n     if did.krate == ast::LOCAL_CRATE {\n-        // We store the fields which are syntactically in each struct in cx. So\n-        // we have to walk the inheritance chain of the struct to get all the\n-        // fields (explicit and inherited) for a struct. If this is expensive\n-        // we could cache the whole list of fields here.\n         let struct_fields = cx.struct_fields.borrow();\n-        let mut results: SmallVector<&[field_ty]> = SmallVector::zero();\n-        each_super_struct(cx, did, |s| {\n-            match struct_fields.find(&s) {\n-                Some(fields) => results.push(fields.as_slice()),\n-                _ => {\n-                    cx.sess.bug(\n-                        format!(\"ID not mapped to struct fields: {}\",\n-                                cx.map.node_to_string(did.node)).as_slice());\n-                }\n+        match struct_fields.find(&did) {\n+            Some(fields) => (**fields).clone(),\n+            _ => {\n+                cx.sess.bug(\n+                    format!(\"ID not mapped to struct fields: {}\",\n+                            cx.map.node_to_string(did.node)).as_slice());\n             }\n-        });\n-\n-        let len = results.as_slice().iter().map(|x| x.len()).sum();\n-        let mut result: Vec<field_ty> = Vec::with_capacity(len);\n-        result.extend(results.as_slice().iter().flat_map(|rs| rs.iter().map(|f| f.clone())));\n-        assert!(result.len() == len);\n-        result\n+        }\n     } else {\n         csearch::get_struct_fields(&cx.sess.cstore, did)\n     }"}, {"sha": "ed663cb85a2c469ab97a2b7091f615c3ed613a14", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -127,7 +127,6 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{ProvidedMethod, RequiredMethod, TypeTraitItem};\n use syntax::ast;\n-use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::ast_util;\n use syntax::attr;\n@@ -602,69 +601,12 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     fcx\n }\n \n-fn span_for_field(tcx: &ty::ctxt, field: &ty::field_ty, struct_id: ast::DefId) -> Span {\n-    assert!(field.id.krate == ast::LOCAL_CRATE);\n-    let item = match tcx.map.find(struct_id.node) {\n-        Some(ast_map::NodeItem(item)) => item,\n-        None => fail!(\"node not in ast map: {}\", struct_id.node),\n-        _ => fail!(\"expected item, found {}\", tcx.map.node_to_string(struct_id.node))\n-    };\n-\n-    match item.node {\n-        ast::ItemStruct(ref struct_def, _) => {\n-            match struct_def.fields.iter().find(|f| match f.node.kind {\n-                ast::NamedField(ident, _) => ident.name == field.name,\n-                _ => false,\n-            }) {\n-                Some(f) => f.span,\n-                None => {\n-                    tcx.sess\n-                       .bug(format!(\"Could not find field {}\",\n-                                    token::get_name(field.name)).as_slice())\n-                }\n-            }\n-        },\n-        _ => tcx.sess.bug(\"Field found outside of a struct?\"),\n-    }\n-}\n-\n-// Check struct fields are uniquely named wrt parents.\n-fn check_for_field_shadowing(tcx: &ty::ctxt,\n-                             id: ast::DefId) {\n-    let struct_fields = tcx.struct_fields.borrow();\n-    let fields = struct_fields.get(&id);\n-\n-    let superstructs = tcx.superstructs.borrow();\n-    let super_struct = superstructs.get(&id);\n-    match *super_struct {\n-        Some(parent_id) => {\n-            let super_fields = ty::lookup_struct_fields(tcx, parent_id);\n-            for f in fields.iter() {\n-                match super_fields.iter().find(|sf| f.name == sf.name) {\n-                    Some(prev_field) => {\n-                        span_err!(tcx.sess, span_for_field(tcx, f, id), E0041,\n-                            \"field `{}` hides field declared in super-struct\",\n-                            token::get_name(f.name));\n-                        span_note!(tcx.sess, span_for_field(tcx, prev_field, parent_id),\n-                            \"previously declared here\");\n-                    },\n-                    None => {}\n-                }\n-            }\n-        },\n-        None => {}\n-    }\n-}\n-\n pub fn check_struct(ccx: &CrateCtxt, id: ast::NodeId, span: Span) {\n     let tcx = ccx.tcx;\n \n     check_representable(tcx, span, id, \"struct\");\n     check_instantiable(tcx, span, id);\n \n-    // Check there are no overlapping fields in super-structs\n-    check_for_field_shadowing(tcx, local_def(id));\n-\n     if ty::lookup_simd(tcx, local_def(id)) {\n         check_simd(tcx, span, id);\n     }"}, {"sha": "100dffb547bcf9f9b7e25d2c933c00cf5f2a4212", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -1235,15 +1235,6 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n \n-            // Write the super-struct type, if it exists.\n-            match struct_def.super_struct {\n-                Some(ref ty) => {\n-                    let supserty = ccx.to_ty(&ExplicitRscope, &**ty);\n-                    write_ty_to_tcx(tcx, it.id, supserty);\n-                },\n-                _ => {},\n-            }\n-\n             convert_struct(ccx, &**struct_def, pty, it.id);\n         },\n         ast::ItemTy(_, ref generics) => {\n@@ -1295,39 +1286,6 @@ pub fn convert_struct(ccx: &CrateCtxt,\n \n     tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n-    let super_struct = match struct_def.super_struct {\n-        Some(ref t) => match t.node {\n-            ast::TyPath(_, _, path_id) => {\n-                let def_map = tcx.def_map.borrow();\n-                match def_map.find(&path_id) {\n-                    Some(&def::DefStruct(def_id)) => {\n-                        // FIXME(#12511) Check for cycles in the inheritance hierarchy.\n-                        // Check super-struct is virtual.\n-                        match tcx.map.find(def_id.node) {\n-                            Some(ast_map::NodeItem(i)) => match i.node {\n-                                ast::ItemStruct(ref struct_def, _) => {\n-                                    if !struct_def.is_virtual {\n-                                        span_err!(tcx.sess, t.span, E0126,\n-                                                  \"struct inheritance is only \\\n-                                                   allowed from virtual structs\");\n-                                    }\n-                                },\n-                                _ => {},\n-                            },\n-                            _ => {},\n-                        }\n-\n-                        Some(def_id)\n-                    },\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        },\n-        None => None,\n-    };\n-    tcx.superstructs.borrow_mut().insert(local_def(id), super_struct);\n-\n     let substs = mk_item_substs(ccx, &pty.generics);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n "}, {"sha": "44b327745edaa078c0de6f10da34687b83197d83", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -1286,10 +1286,6 @@ pub struct StructDef {\n     /// ID of the constructor. This is only used for tuple- or enum-like\n     /// structs.\n     pub ctor_id: Option<NodeId>,\n-    /// Super struct, if specified.\n-    pub super_struct: Option<P<Ty>>,\n-    /// True iff the struct may be inherited from.\n-    pub is_virtual: bool,\n }\n \n /*"}, {"sha": "a53be6097fdb43e9f832738bd2e162954c6ef1b6", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -158,14 +158,12 @@ fn fold_item_underscore(cx: &mut Context, item: ast::Item_) -> ast::Item_ {\n }\n \n fn fold_struct(cx: &mut Context, def: P<ast::StructDef>) -> P<ast::StructDef> {\n-    def.map(|ast::StructDef {fields, ctor_id, super_struct, is_virtual}| {\n+    def.map(|ast::StructDef { fields, ctor_id }| {\n         ast::StructDef {\n             fields: fields.into_iter().filter(|m| {\n                 (cx.in_cfg)(m.node.attrs.as_slice())\n             }).collect(),\n             ctor_id: ctor_id,\n-            super_struct: super_struct,\n-            is_virtual: is_virtual,\n         }\n     })\n }"}, {"sha": "590157d677d827ba58bc4a71c8763c320b511aaa", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -218,22 +218,11 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 }\n             }\n \n-            ast::ItemStruct(ref struct_definition, _) => {\n+            ast::ItemStruct(..) => {\n                 if attr::contains_name(i.attrs.as_slice(), \"simd\") {\n                     self.gate_feature(\"simd\", i.span,\n                                       \"SIMD types are experimental and possibly buggy\");\n                 }\n-                match struct_definition.super_struct {\n-                    Some(ref path) => self.gate_feature(\"struct_inherit\", path.span,\n-                                                        \"struct inheritance is experimental \\\n-                                                         and possibly buggy\"),\n-                    None => {}\n-                }\n-                if struct_definition.is_virtual {\n-                    self.gate_feature(\"struct_inherit\", i.span,\n-                                      \"struct inheritance (`virtual` keyword) is \\\n-                                       experimental and possibly buggy\");\n-                }\n             }\n \n             ast::ItemImpl(_, _, _, ref items) => {"}, {"sha": "3e16bca72ef22f7edbb24167b6471b9e3d67b1ce", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -801,11 +801,9 @@ pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n }\n \n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n-    struct_def.map(|StructDef {fields, ctor_id, super_struct, is_virtual}| StructDef {\n+    struct_def.map(|StructDef { fields, ctor_id }| StructDef {\n         fields: fields.move_map(|f| fld.fold_struct_field(f)),\n         ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n-        super_struct: super_struct.map(|t| fld.fold_ty(t)),\n-        is_virtual: is_virtual\n     })\n }\n "}, {"sha": "daaf6744d9df22ba5438a7cf6d6e3fb580c40f6a", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -4540,24 +4540,14 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse struct Foo { ... }\n-    fn parse_item_struct(&mut self, is_virtual: bool) -> ItemInfo {\n+    fn parse_item_struct(&mut self) -> ItemInfo {\n         let class_name = self.parse_ident();\n         let mut generics = self.parse_generics();\n \n-        let super_struct = if self.eat(&token::COLON) {\n+        if self.eat(&token::COLON) {\n             let ty = self.parse_ty(true);\n-            match ty.node {\n-                TyPath(_, None, _) => {\n-                    Some(ty)\n-                }\n-                _ => {\n-                    self.span_err(ty.span, \"not a struct\");\n-                    None\n-                }\n-            }\n-        } else {\n-            None\n-        };\n+            self.span_err(ty.span, \"`virtual` structs have been removed from the language\");\n+        }\n \n         self.parse_where_clause(&mut generics);\n \n@@ -4618,8 +4608,6 @@ impl<'a> Parser<'a> {\n          ItemStruct(P(ast::StructDef {\n              fields: fields,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None },\n-             super_struct: super_struct,\n-             is_virtual: is_virtual,\n          }), generics),\n          None)\n     }\n@@ -5090,8 +5078,6 @@ impl<'a> Parser<'a> {\n         P(StructDef {\n             fields: fields,\n             ctor_id: None,\n-            super_struct: None,\n-            is_virtual: false,\n         })\n     }\n \n@@ -5288,11 +5274,9 @@ impl<'a> Parser<'a> {\n                                     token_str).as_slice());\n         }\n \n-        let is_virtual = self.eat_keyword(keywords::Virtual);\n-        if is_virtual && !self.is_keyword(keywords::Struct) {\n+        if self.eat_keyword(keywords::Virtual) {\n             let span = self.span;\n-            self.span_err(span,\n-                          \"`virtual` keyword may only be used with `struct`\");\n+            self.span_err(span, \"`virtual` structs have been removed from the language\");\n         }\n \n         // the rest are all guaranteed to be items:\n@@ -5427,7 +5411,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.eat_keyword(keywords::Struct) {\n             // STRUCT ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_struct(is_virtual);\n+            let (ident, item_, extra_attrs) = self.parse_item_struct();\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,"}, {"sha": "c9a6354bf97bd06d12ae8a385865756ea64e545c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -826,9 +826,6 @@ impl<'a> State<'a> {\n                 ));\n             }\n             ast::ItemStruct(ref struct_def, ref generics) => {\n-                if struct_def.is_virtual {\n-                    try!(self.word_space(\"virtual\"));\n-                }\n                 try!(self.head(visibility_qualified(item.vis,\"struct\").as_slice()));\n                 try!(self.print_struct(&**struct_def, generics, item.ident, item.span));\n             }\n@@ -968,13 +965,6 @@ impl<'a> State<'a> {\n                         span: codemap::Span) -> IoResult<()> {\n         try!(self.print_ident(ident));\n         try!(self.print_generics(generics));\n-        match struct_def.super_struct {\n-            Some(ref t) => {\n-                try!(self.word_space(\":\"));\n-                try!(self.print_type(&**t));\n-            },\n-            None => {},\n-        }\n         if ast_util::struct_def_is_tuple_like(struct_def) {\n             if !struct_def.fields.is_empty() {\n                 try!(self.popen());"}, {"sha": "c98c3bffcb621cad4001d469582cc071b7ef7e9f", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -603,10 +603,6 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v Tr\n \n pub fn walk_struct_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                            struct_definition: &'v StructDef) {\n-    match struct_definition.super_struct {\n-        Some(ref t) => visitor.visit_ty(&**t),\n-        None => {},\n-    }\n     for field in struct_definition.fields.iter() {\n         visitor.visit_struct_field(field)\n     }"}, {"sha": "69125bab2ce7c9a8d1a3065bed4bcd68b8e84543", "filename": "src/test/compile-fail/virtual-structs.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Ftest%2Fcompile-fail%2Fvirtual-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875/src%2Ftest%2Fcompile-fail%2Fvirtual-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvirtual-structs.rs?ref=403cd40e6a29cc0f897e4b3d80e1e2bcf38f8875", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test diagnostics for the removed struct inheritance feature.\n+#![feature(struct_inherit)]\n+\n+virtual struct SuperStruct { //~ ERROR `virtual` structs have been removed from the language\n+    f1: int,\n+}\n+\n+struct Struct : SuperStruct; //~ ERROR `virtual` structs have been removed from the language\n+\n+pub fn main() {}"}]}