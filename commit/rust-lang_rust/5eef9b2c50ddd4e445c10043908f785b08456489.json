{"sha": "5eef9b2c50ddd4e445c10043908f785b08456489", "node_id": "C_kwDOAAsO6NoAKDVlZWY5YjJjNTBkZGQ0ZTQ0NWMxMDA0MzkwOGY3ODViMDg0NTY0ODk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-10T02:05:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-10T02:05:38Z"}, "message": "Auto merge of #101990 - clubby789:dont-machine-apply-placeholder-method, r=compiler-errors\n\nFix auto-application of associated generic functions with placeholders\n\nFixes #101920", "tree": {"sha": "bdd2204999f8ad7b584d2a94d6552c8e2f3a29e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdd2204999f8ad7b584d2a94d6552c8e2f3a29e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eef9b2c50ddd4e445c10043908f785b08456489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eef9b2c50ddd4e445c10043908f785b08456489", "html_url": "https://github.com/rust-lang/rust/commit/5eef9b2c50ddd4e445c10043908f785b08456489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eef9b2c50ddd4e445c10043908f785b08456489/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34115d040b43d9a0dcc313c6282520a86d1e6f61", "url": "https://api.github.com/repos/rust-lang/rust/commits/34115d040b43d9a0dcc313c6282520a86d1e6f61", "html_url": "https://github.com/rust-lang/rust/commit/34115d040b43d9a0dcc313c6282520a86d1e6f61"}, {"sha": "7df4b0b66252748108b5d7edee27ee5776222f64", "url": "https://api.github.com/repos/rust-lang/rust/commits/7df4b0b66252748108b5d7edee27ee5776222f64", "html_url": "https://github.com/rust-lang/rust/commit/7df4b0b66252748108b5d7edee27ee5776222f64"}], "stats": {"total": 321, "additions": 286, "deletions": 35}, "files": [{"sha": "799043842201af24de6da5abc62aae332c8c8bf8", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 115, "deletions": 20, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -14,11 +14,17 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ExprKind, Node, QPath};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{\n+    type_variable::{TypeVariableOrigin, TypeVariableOriginKind},\n+    RegionVariableOrigin,\n+};\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::traits::util::supertraits;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n-use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeVisitable};\n+use rustc_middle::ty::{\n+    self, DefIdTree, GenericArg, GenericArgKind, ToPredicate, Ty, TyCtxt, TypeVisitable,\n+};\n use rustc_middle::ty::{IsSuggestable, ToPolyTraitRef};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Symbol;\n@@ -280,7 +286,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ) {\n                     return None;\n                 }\n-\n                 span = item_name.span;\n \n                 // Don't show generic arguments when the method can't be found in any implementation (#81576).\n@@ -393,28 +398,118 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     custom_span_label = true;\n                 }\n                 if static_candidates.len() == 1 {\n-                    let ty_str =\n-                        if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) {\n-                            // When the \"method\" is resolved through dereferencing, we really want the\n-                            // original type that has the associated function for accurate suggestions.\n-                            // (#61411)\n-                            let ty = tcx.at(span).type_of(*impl_did);\n-                            match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n-                                (ty::Adt(def, _), ty::Adt(def_actual, _)) if def == def_actual => {\n-                                    // Use `actual` as it will have more `substs` filled in.\n-                                    self.ty_to_value_string(actual.peel_refs())\n+                    let mut has_unsuggestable_args = false;\n+                    let ty_str = if let Some(CandidateSource::Impl(impl_did)) =\n+                        static_candidates.get(0)\n+                    {\n+                        // When the \"method\" is resolved through dereferencing, we really want the\n+                        // original type that has the associated function for accurate suggestions.\n+                        // (#61411)\n+                        let ty = tcx.at(span).type_of(*impl_did);\n+                        match (&ty.peel_refs().kind(), &actual.peel_refs().kind()) {\n+                            (ty::Adt(def, _), ty::Adt(def_actual, substs)) if def == def_actual => {\n+                                // If there are any inferred arguments, (`{integer}`), we should replace\n+                                // them with underscores to allow the compiler to infer them\n+                                let infer_substs: Vec<GenericArg<'_>> = substs\n+                                    .into_iter()\n+                                    .map(|arg| {\n+                                        if !arg.is_suggestable(tcx, true) {\n+                                            has_unsuggestable_args = true;\n+                                            match arg.unpack() {\n+                                            GenericArgKind::Lifetime(_) => self\n+                                                .next_region_var(RegionVariableOrigin::MiscVariable(\n+                                                    rustc_span::DUMMY_SP,\n+                                                ))\n+                                                .into(),\n+                                            GenericArgKind::Type(_) => self\n+                                                .next_ty_var(TypeVariableOrigin {\n+                                                    span: rustc_span::DUMMY_SP,\n+                                                    kind: TypeVariableOriginKind::MiscVariable,\n+                                                })\n+                                                .into(),\n+                                            GenericArgKind::Const(arg) => self\n+                                                .next_const_var(\n+                                                    arg.ty(),\n+                                                    ConstVariableOrigin {\n+                                                        span: rustc_span::DUMMY_SP,\n+                                                        kind: ConstVariableOriginKind::MiscVariable,\n+                                                    },\n+                                                )\n+                                                .into(),\n+                                            }\n+                                        } else {\n+                                            arg\n+                                        }\n+                                    })\n+                                    .collect::<Vec<_>>();\n+\n+                                tcx.value_path_str_with_substs(\n+                                    def_actual.did(),\n+                                    tcx.intern_substs(&infer_substs),\n+                                )\n+                            }\n+                            _ => self.ty_to_value_string(ty.peel_refs()),\n+                        }\n+                    } else {\n+                        self.ty_to_value_string(actual.peel_refs())\n+                    };\n+                    if let SelfSource::MethodCall(_) = source {\n+                        let first_arg = if let Some(CandidateSource::Impl(impl_did)) = static_candidates.get(0) &&\n+                            let Some(assoc) = self.associated_value(*impl_did, item_name) {\n+                            let sig = self.tcx.fn_sig(assoc.def_id);\n+                            if let Some(first) = sig.inputs().skip_binder().get(0) {\n+                                if first.peel_refs() == rcvr_ty.peel_refs() {\n+                                    None\n+                                } else {\n+                                    Some(if first.is_region_ptr() {\n+                                        if first.is_mutable_ptr() { \"&mut \" } else { \"&\" }\n+                                    } else {\n+                                        \"\"\n+                                    })\n                                 }\n-                                _ => self.ty_to_value_string(ty.peel_refs()),\n+                            } else {\n+                                None\n                             }\n                         } else {\n-                            self.ty_to_value_string(actual.peel_refs())\n+                            None\n+                        };\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        let args = if let Some((receiver, args)) = args {\n+                            // The first arg is the same kind as the receiver\n+                            let explicit_args = if first_arg.is_some() {\n+                                std::iter::once(receiver).chain(args.iter()).collect::<Vec<_>>()\n+                            } else {\n+                                // There is no `Self` kind to infer the arguments from\n+                                if has_unsuggestable_args {\n+                                    applicability = Applicability::HasPlaceholders;\n+                                }\n+                                args.iter().collect()\n+                            };\n+                            format!(\n+                                \"({}{})\",\n+                                first_arg.unwrap_or(\"\"),\n+                                explicit_args\n+                                    .iter()\n+                                    .map(|arg| tcx\n+                                        .sess\n+                                        .source_map()\n+                                        .span_to_snippet(arg.span)\n+                                        .unwrap_or_else(|_| {\n+                                            applicability = Applicability::HasPlaceholders;\n+                                            \"_\".to_owned()\n+                                        }))\n+                                    .collect::<Vec<_>>()\n+                                    .join(\", \"),\n+                            )\n+                        } else {\n+                            applicability = Applicability::HasPlaceholders;\n+                            \"(...)\".to_owned()\n                         };\n-                    if let SelfSource::MethodCall(expr) = source {\n                         err.span_suggestion(\n-                            expr.span.to(span),\n+                            sugg_span,\n                             \"use associated function syntax instead\",\n-                            format!(\"{}::{}\", ty_str, item_name),\n-                            Applicability::MachineApplicable,\n+                            format!(\"{}::{}{}\", ty_str, item_name, args),\n+                            applicability,\n                         );\n                     } else {\n                         err.help(&format!(\"try with `{}::{}`\", ty_str, item_name,));\n@@ -1827,7 +1922,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Print out the type for use in value namespace.\n     fn ty_to_value_string(&self, ty: Ty<'tcx>) -> String {\n         match ty.kind() {\n-            ty::Adt(def, substs) => format!(\"{}\", ty::Instance::new(def.did(), substs)),\n+            ty::Adt(def, substs) => self.tcx.def_path_str_with_substs(def.did(), substs),\n             _ => self.ty_to_string(ty),\n         }\n     }"}, {"sha": "2432b5175197b791e70e305d2a8d28111a11442c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -1659,6 +1659,12 @@ impl<'t> TyCtxt<'t> {\n         debug!(\"def_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n         FmtPrinter::new(self, ns).print_def_path(def_id, substs).unwrap().into_buffer()\n     }\n+\n+    pub fn value_path_str_with_substs(self, def_id: DefId, substs: &'t [GenericArg<'t>]) -> String {\n+        let ns = guess_def_namespace(self, def_id);\n+        debug!(\"value_path_str: def_id={:?}, ns={:?}\", def_id, ns);\n+        FmtPrinter::new(self, ns).print_value_path(def_id, substs).unwrap().into_buffer()\n+    }\n }\n \n impl fmt::Write for FmtPrinter<'_, '_> {"}, {"sha": "07c8101cbc68b776aa15b2d6f5b3912af677ea60", "filename": "src/test/ui/issues/issue-3707.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fissues%2Fissue-3707.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fissues%2Fissue-3707.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3707.stderr?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -2,10 +2,10 @@ error[E0599]: no method named `boom` found for reference `&Obj` in the current s\n   --> $DIR/issue-3707.rs:10:14\n    |\n LL |         self.boom();\n-   |         -----^^^^\n+   |         -----^^^^--\n    |         |    |\n    |         |    this is an associated function, not a method\n-   |         help: use associated function syntax instead: `Obj::boom`\n+   |         help: use associated function syntax instead: `Obj::boom()`\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n note: the candidate is defined in an impl for the type `Obj`"}, {"sha": "fac68c053eb4f4f952176bf59041a40e62da2084", "filename": "src/test/ui/suggestions/inner_type2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.rs?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -22,5 +22,5 @@ fn main() {\n     let item = std::mem::MaybeUninit::new(Struct { p: 42_u32 });\n     item.method();\n     //~^ ERROR no method named `method` found for union `MaybeUninit` in the current scope [E0599]\n-    //~| HELP if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+    //~| HELP if this `MaybeUninit<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n }"}, {"sha": "984366123c82793f649f37d47c06b8fa017d0870", "filename": "src/test/ui/suggestions/inner_type2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Finner_type2.stderr?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -17,7 +17,7 @@ error[E0599]: no method named `method` found for union `MaybeUninit` in the curr\n LL |     item.method();\n    |          ^^^^^^ method not found in `MaybeUninit<Struct<u32>>`\n    |\n-   = help: if this `MaybeUninit::<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n+   = help: if this `MaybeUninit<Struct<u32>>` has been initialized, use one of the `assume_init` methods to access the inner value\n note: the method `method` exists on the type `Struct<u32>`\n   --> $DIR/inner_type2.rs:6:5\n    |"}, {"sha": "b17c4dc5dfb50998df9cca962e3023e696215420", "filename": "src/test/ui/suggestions/issue-102354.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102354.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102354.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102354.stderr?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -13,7 +13,7 @@ LL |     fn func() {}\n help: use associated function syntax instead\n    |\n LL |     i32::func();\n-   |     ~~~~~~~~~\n+   |     ~~~~~~~~~~~\n help: disambiguate the associated function for the candidate\n    |\n LL |     <i32 as Trait>::func(x);"}, {"sha": "a39b8711dd8745dd55309ab81c14ae6390182ed3", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-with-turbofish-placeholder.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-placeholder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-placeholder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-placeholder.rs?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -0,0 +1,11 @@\n+struct GenericAssocMethod<T>(T);\n+\n+impl<T> GenericAssocMethod<T> {\n+    fn default_hello() {}\n+}\n+\n+fn main() {\n+    let x = GenericAssocMethod(33);\n+    x.default_hello();\n+    //~^ ERROR no method named `default_hello` found\n+}"}, {"sha": "c247e73b39cb6a781396ba5e5f29b2278ceff20e", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-with-turbofish-placeholder.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-placeholder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-placeholder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-placeholder.stderr?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -0,0 +1,22 @@\n+error[E0599]: no method named `default_hello` found for struct `GenericAssocMethod<{integer}>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish-placeholder.rs:9:7\n+   |\n+LL | struct GenericAssocMethod<T>(T);\n+   | ---------------------------- method `default_hello` not found for this struct\n+...\n+LL |     x.default_hello();\n+   |     --^^^^^^^^^^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `GenericAssocMethod::<_>::default_hello()`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `GenericAssocMethod<T>`\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish-placeholder.rs:4:5\n+   |\n+LL |     fn default_hello() {}\n+   |     ^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "7c9f0b6c212e102037faef5e9f3f1bff2444a778", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-with-turbofish-through-deref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-through-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-through-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish-through-deref.stderr?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -2,10 +2,10 @@ error[E0599]: no method named `hello` found for struct `RefMut<'_, HasAssocMetho\n   --> $DIR/suggest-assoc-fn-call-with-turbofish-through-deref.rs:11:11\n    |\n LL |     state.hello();\n-   |     ------^^^^^\n+   |     ------^^^^^--\n    |     |     |\n    |     |     this is an associated function, not a method\n-   |     help: use associated function syntax instead: `HasAssocMethod::hello`\n+   |     help: use associated function syntax instead: `HasAssocMethod::hello()`\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n note: the candidate is defined in an impl for the type `HasAssocMethod`"}, {"sha": "02dd0715c8011dade2fa2bfe73e58b9d7d9bb48d", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-with-turbofish.fixed", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.fixed?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -0,0 +1,26 @@\n+// run-rustfix\n+\n+struct GenericAssocMethod<T>(T);\n+\n+impl<T> GenericAssocMethod<T> {\n+    fn default_hello() {}\n+    fn self_ty_hello(_: Self) {}\n+    fn self_ty_ref_hello(_: &Self) {}\n+}\n+\n+fn main() {\n+    // Test for inferred types\n+    let x = GenericAssocMethod(33);\n+    GenericAssocMethod::<_>::self_ty_ref_hello(&x);\n+    //~^ ERROR no method named `self_ty_ref_hello` found\n+    GenericAssocMethod::<_>::self_ty_hello(x);\n+    //~^ ERROR no method named `self_ty_hello` found\n+    // Test for known types\n+    let y = GenericAssocMethod(33i32);\n+    GenericAssocMethod::<i32>::default_hello();\n+    //~^ ERROR no method named `default_hello` found\n+    GenericAssocMethod::<i32>::self_ty_ref_hello(&y);\n+    //~^ ERROR no method named `self_ty_ref_hello` found\n+    GenericAssocMethod::<i32>::self_ty_hello(y);\n+    //~^ ERROR no method named `self_ty_hello` found\n+}"}, {"sha": "1d0ca8e780abf85a88dab2bab833a6d763baa835", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-with-turbofish.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.rs?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -1,11 +1,26 @@\n+// run-rustfix\n+\n struct GenericAssocMethod<T>(T);\n \n impl<T> GenericAssocMethod<T> {\n     fn default_hello() {}\n+    fn self_ty_hello(_: Self) {}\n+    fn self_ty_ref_hello(_: &Self) {}\n }\n \n fn main() {\n-    let x = GenericAssocMethod(33i32);\n-    x.default_hello();\n+    // Test for inferred types\n+    let x = GenericAssocMethod(33);\n+    x.self_ty_ref_hello();\n+    //~^ ERROR no method named `self_ty_ref_hello` found\n+    x.self_ty_hello();\n+    //~^ ERROR no method named `self_ty_hello` found\n+    // Test for known types\n+    let y = GenericAssocMethod(33i32);\n+    y.default_hello();\n     //~^ ERROR no method named `default_hello` found\n+    y.self_ty_ref_hello();\n+    //~^ ERROR no method named `self_ty_ref_hello` found\n+    y.self_ty_hello();\n+    //~^ ERROR no method named `self_ty_hello` found\n }"}, {"sha": "92b03fc77142c3f4bf7f6a260fa69bbe1babd4b1", "filename": "src/test/ui/suggestions/suggest-assoc-fn-call-with-turbofish.stderr", "status": "modified", "additions": 82, "deletions": 6, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5eef9b2c50ddd4e445c10043908f785b08456489/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-assoc-fn-call-with-turbofish.stderr?ref=5eef9b2c50ddd4e445c10043908f785b08456489", "patch": "@@ -1,22 +1,98 @@\n+error[E0599]: no method named `self_ty_ref_hello` found for struct `GenericAssocMethod<{integer}>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:14:7\n+   |\n+LL | struct GenericAssocMethod<T>(T);\n+   | ---------------------------- method `self_ty_ref_hello` not found for this struct\n+...\n+LL |     x.self_ty_ref_hello();\n+   |     --^^^^^^^^^^^^^^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `GenericAssocMethod::<_>::self_ty_ref_hello(&x)`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `GenericAssocMethod<T>`\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:8:5\n+   |\n+LL |     fn self_ty_ref_hello(_: &Self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `self_ty_hello` found for struct `GenericAssocMethod<{integer}>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:16:7\n+   |\n+LL | struct GenericAssocMethod<T>(T);\n+   | ---------------------------- method `self_ty_hello` not found for this struct\n+...\n+LL |     x.self_ty_hello();\n+   |     --^^^^^^^^^^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `GenericAssocMethod::<_>::self_ty_hello(x)`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `GenericAssocMethod<T>`\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:7:5\n+   |\n+LL |     fn self_ty_hello(_: Self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error[E0599]: no method named `default_hello` found for struct `GenericAssocMethod<i32>` in the current scope\n-  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:9:7\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:20:7\n    |\n LL | struct GenericAssocMethod<T>(T);\n    | ---------------------------- method `default_hello` not found for this struct\n ...\n-LL |     x.default_hello();\n-   |     --^^^^^^^^^^^^^\n+LL |     y.default_hello();\n+   |     --^^^^^^^^^^^^^--\n    |     | |\n    |     | this is an associated function, not a method\n-   |     help: use associated function syntax instead: `GenericAssocMethod::<i32>::default_hello`\n+   |     help: use associated function syntax instead: `GenericAssocMethod::<i32>::default_hello()`\n    |\n    = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n note: the candidate is defined in an impl for the type `GenericAssocMethod<T>`\n-  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:4:5\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:6:5\n    |\n LL |     fn default_hello() {}\n    |     ^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0599]: no method named `self_ty_ref_hello` found for struct `GenericAssocMethod<i32>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:22:7\n+   |\n+LL | struct GenericAssocMethod<T>(T);\n+   | ---------------------------- method `self_ty_ref_hello` not found for this struct\n+...\n+LL |     y.self_ty_ref_hello();\n+   |     --^^^^^^^^^^^^^^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `GenericAssocMethod::<i32>::self_ty_ref_hello(&y)`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `GenericAssocMethod<T>`\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:8:5\n+   |\n+LL |     fn self_ty_ref_hello(_: &Self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0599]: no method named `self_ty_hello` found for struct `GenericAssocMethod<i32>` in the current scope\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:24:7\n+   |\n+LL | struct GenericAssocMethod<T>(T);\n+   | ---------------------------- method `self_ty_hello` not found for this struct\n+...\n+LL |     y.self_ty_hello();\n+   |     --^^^^^^^^^^^^^--\n+   |     | |\n+   |     | this is an associated function, not a method\n+   |     help: use associated function syntax instead: `GenericAssocMethod::<i32>::self_ty_hello(y)`\n+   |\n+   = note: found the following associated functions; to be used as methods, functions must have a `self` parameter\n+note: the candidate is defined in an impl for the type `GenericAssocMethod<T>`\n+  --> $DIR/suggest-assoc-fn-call-with-turbofish.rs:7:5\n+   |\n+LL |     fn self_ty_hello(_: Self) {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n \n For more information about this error, try `rustc --explain E0599`."}]}