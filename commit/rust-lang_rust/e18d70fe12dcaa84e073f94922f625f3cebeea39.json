{"sha": "e18d70fe12dcaa84e073f94922f625f3cebeea39", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxOGQ3MGZlMTJkY2FhODRlMDczZjk0OTIyZjYyNWYzY2ViZWVhMzk=", "commit": {"author": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-21T23:47:47Z"}, "committer": {"name": "Paul Stansifer", "email": "paul.stansifer@gmail.com", "date": "2011-07-22T23:53:43Z"}, "message": "Implement Macro By Example.", "tree": {"sha": "a801c745ed8b038f6900ec2cf2286da2f6bb0169", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a801c745ed8b038f6900ec2cf2286da2f6bb0169"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e18d70fe12dcaa84e073f94922f625f3cebeea39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e18d70fe12dcaa84e073f94922f625f3cebeea39", "html_url": "https://github.com/rust-lang/rust/commit/e18d70fe12dcaa84e073f94922f625f3cebeea39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e18d70fe12dcaa84e073f94922f625f3cebeea39/comments", "author": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "paulstansifer", "id": 1431, "node_id": "MDQ6VXNlcjE0MzE=", "avatar_url": "https://avatars.githubusercontent.com/u/1431?v=4", "gravatar_id": "", "url": "https://api.github.com/users/paulstansifer", "html_url": "https://github.com/paulstansifer", "followers_url": "https://api.github.com/users/paulstansifer/followers", "following_url": "https://api.github.com/users/paulstansifer/following{/other_user}", "gists_url": "https://api.github.com/users/paulstansifer/gists{/gist_id}", "starred_url": "https://api.github.com/users/paulstansifer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/paulstansifer/subscriptions", "organizations_url": "https://api.github.com/users/paulstansifer/orgs", "repos_url": "https://api.github.com/users/paulstansifer/repos", "events_url": "https://api.github.com/users/paulstansifer/events{/privacy}", "received_events_url": "https://api.github.com/users/paulstansifer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a6ccf3b0ff7a476aa8d692766214bc8ebdfc1dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a6ccf3b0ff7a476aa8d692766214bc8ebdfc1dc", "html_url": "https://github.com/rust-lang/rust/commit/4a6ccf3b0ff7a476aa8d692766214bc8ebdfc1dc"}], "stats": {"total": 854, "additions": 643, "deletions": 211}, "files": [{"sha": "bdd0421cb2314fe76301e66f8c9186ae165ccd37", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -28,6 +28,7 @@ fn syntax_expander_table() -> hashmap[str, syntax_extension] {\n }\n \n type span_msg_fn = fn(span, str) -> !  ;\n+type msg_fn = fn(str) -> !  ;\n \n type next_id_fn = fn() -> ast::node_id ;\n \n@@ -38,6 +39,8 @@ type ext_ctxt =\n     rec(str crate_file_name_hack,\n         span_msg_fn span_fatal,\n         span_msg_fn span_unimpl,\n+        span_msg_fn span_bug,\n+        msg_fn bug,\n         next_id_fn next_id);\n \n fn mk_ctxt(&session sess) -> ext_ctxt {\n@@ -50,6 +53,18 @@ fn mk_ctxt(&session sess) -> ext_ctxt {\n         sess.span_err(sp, \"unimplemented \" + msg);\n         fail;\n     }\n+    auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n+    fn ext_span_bug_(&session sess, span sp, str msg) -> ! {\n+        sess.span_bug(sp, msg);\n+        fail;\n+    }\n+    auto ext_span_bug = bind ext_span_bug_(sess, _, _);\n+    fn ext_bug_(&session sess, str msg) -> ! {\n+        sess.bug(msg);\n+        fail;\n+    }\n+    auto ext_bug = bind ext_bug_(sess, _);\n+\n \n     // FIXME: Some extensions work by building ASTs with paths to functions\n     // they need to call at runtime. As those functions live in the std crate,\n@@ -59,14 +74,16 @@ fn mk_ctxt(&session sess) -> ext_ctxt {\n     // use it to guess whether paths should be prepended with \"std::\". This is\n     // super-ugly and needs a better solution.\n     auto crate_file_name_hack = sess.get_codemap().files.(0).name;\n-    auto ext_span_unimpl = bind ext_span_unimpl_(sess, _, _);\n+\n     fn ext_next_id_(&session sess) -> ast::node_id {\n         ret sess.next_node_id(); // temporary, until bind works better\n     }\n     auto ext_next_id = bind ext_next_id_(sess);\n     ret rec(crate_file_name_hack=crate_file_name_hack,\n             span_fatal=ext_span_fatal,\n             span_unimpl=ext_span_unimpl,\n+            span_bug=ext_span_bug,\n+            bug=ext_bug,\n             next_id=ext_next_id);\n }\n "}, {"sha": "71e217ddcf5e12d767dffe5b4d84db82f0600c70", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 546, "deletions": 179, "changes": 725, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -6,6 +6,8 @@ import std::vec;\n import std::option;\n import vec::map;\n import vec::len;\n+import std::map::hashmap;\n+import std::map::new_str_hash;\n import option::some;\n import option::none;\n \n@@ -19,6 +21,10 @@ import fold::*;\n import ast::respan;\n import ast::ident;\n import ast::path;\n+import ast::ty;\n+import ast::block;\n+import ast::expr;\n+import ast::expr_;\n import ast::path_;\n import ast::expr_path;\n import ast::expr_vec;\n@@ -27,243 +33,604 @@ import ast::mac_invoc;\n \n export add_new_extension;\n \n-fn lookup(&(invk_binding)[] ibs, ident i) -> option::t[invk_binding] {\n-    for (invk_binding ib in ibs) {\n-        alt (ib) {\n-            case (ident_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n-            case (path_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n-            case (expr_binding(?p_id, _)) { if (i == p_id) { ret some(ib); }}\n+fn path_to_ident(&path pth) -> option::t[ident] {\n+    if (ivec::len(pth.node.idents) == 1u\n+        && ivec::len(pth.node.types) == 0u) {\n+        ret some(pth.node.idents.(0u));\n+    }\n+    ret none;\n+}\n+\n+//an ivec of binders might be a little big.\n+type clause = rec((binders)[] params, @expr body);\n+\n+/* logically, an arb_depth should contain only one kind of matchable */\n+tag arb_depth[T] {\n+    leaf(T);\n+    seq(vec[arb_depth[T]], span);\n+}\n+\n+\n+tag matchable {\n+    match_expr(@expr);\n+    match_path(path);\n+    match_ident(ast::spanned[ident]);\n+    match_ty(@ty);\n+    match_block(block);\n+    match_exact; /* don't bind anything, just verify the AST traversal */\n+}\n+\n+/* for when given an incompatible bit of AST */\n+fn match_error(&ext_ctxt cx, &matchable m, &str expected) -> ! {\n+    alt(m) {\n+      case (match_expr(?x)) {\n+        cx.span_fatal(x.span, \"this argument is an expr, expected \"\n+                      + expected);\n+      }\n+      case (match_path(?x)) {\n+        cx.span_fatal(x.span, \"this argument is a path, expected \"\n+                      + expected);\n+      }\n+      case (match_ident(?x)) {\n+        cx.span_fatal(x.span, \"this argument is an ident, expected \"\n+                      + expected);\n+      }\n+      case (match_ty(?x)) {\n+        cx.span_fatal(x.span, \"this argument is a type, expected \"\n+                      + expected);\n+      }\n+      case (match_block(?x)) {\n+        cx.span_fatal(x.span, \"this argument is a block, expected \"\n+                      + expected);\n+      }\n+      case (match_exact) {\n+        cx.bug(\"what is a match_exact doing in a bindings?\");\n+      }\n+    }\n+}\n+\n+// We can't make all the matchables in a match_result the same type because\n+// idents can be paths, which can be exprs.\n+\n+// If we want better match failure error messages (like in Fortifying Syntax),\n+// we'll want to return something indicating amount of progress and location\n+// of failure instead of `none`.\n+type match_result = option::t[arb_depth[matchable]];\n+type selector = fn(&matchable) -> match_result;\n+\n+fn elts_to_ell(&ext_ctxt cx, &(@expr)[] elts) -> option::t[@expr] {\n+    let uint idx = 0u;\n+    for (@expr elt in elts) {\n+        alt (elt.node) {\n+          case (expr_mac(?m)) {\n+            alt (m.node) {\n+              case (ast::mac_ellipsis) {\n+                if (idx != 1u || ivec::len(elts) != 2u) {\n+                    cx.span_fatal(m.span,\n+                                  \"Ellpisis may only appear\"\n+                                  +\" after exactly 1 item.\");\n+                }\n+                ret some(elts.(0));\n+              }\n+            }\n+          }\n+          case (_) { }\n         }\n+        idx += 1u;\n     }\n     ret none;\n }\n \n-// substitute, in a position that's required to be an ident\n-fn subst_ident(&ext_ctxt cx, &(invk_binding)[] ibs, &ident i, ast_fold fld)\n-    -> ident {\n-    ret alt (lookup(ibs, i)) {\n-        case (some(ident_binding(_, ?a_id))) { a_id.node }\n-        case (some(path_binding(_, ?pth))) {\n-            cx.span_fatal(pth.span, \"This argument is expanded as an \"\n-                          + \"identifier; it must be one.\")\n+fn option_flatten_map[T,U](&fn(&T)->option::t[U] f, &vec[T] v)\n+    -> option::t[vec[U]] {\n+    auto res = vec::alloc[U](vec::len(v));\n+    for (T elem in v) {\n+        alt (f(elem)) {\n+          case (none) { ret none; }\n+          case (some(?fv)) { res += [fv]; }\n+        }\n+    }\n+    ret some(res);\n+}\n+\n+fn a_d_map(&arb_depth[matchable] ad, &selector f)\n+    -> match_result {\n+    alt (ad) {\n+      case (leaf(?x)) { ret f(x); }\n+      case (seq(?ads,?span)) {\n+        alt (option_flatten_map(bind a_d_map(_, f), ads)) {\n+          case (none) { ret none; }\n+          case (some(?ts)) { ret some(seq(ts,span)); }\n         }\n-        case (some(expr_binding(_, ?expr))) {\n-            cx.span_fatal(expr.span, \"This argument is expanded as an \"\n-                          + \"identifier; it must be one.\")\n+      }\n+    }\n+}\n+\n+fn compose_sels(selector s1, selector s2) -> selector {\n+    fn scomp(selector s1, selector s2, &matchable m) ->\n+        match_result {\n+        ret alt (s1(m)) {\n+          case (none) { none }\n+          case (some(?matches)) { a_d_map(matches, s2) }\n         }\n-        case (none) { i }\n     }\n+    ret bind scomp(s1, s2, _);\n }\n \n \n-fn subst_path(&ext_ctxt cx, &(invk_binding)[] ibs, &path_ p, ast_fold fld)\n-    -> path_ {\n-    // Don't substitute into qualified names.\n-    if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n-    ret alt (lookup(ibs, p.idents.(0))) {\n-        case (some(ident_binding(_, ?id))) {\n-            rec(global=false, idents=~[id.node], types=~[])\n+\n+type binders = rec(hashmap[ident,selector] real_binders,\n+                   mutable (selector)[] literal_ast_matchers);\n+type bindings = hashmap[ident, arb_depth[matchable]];\n+\n+fn acumm_bindings(&ext_ctxt cx, &bindings b_dest, &bindings b_src) {\n+}\n+\n+/* these three functions are the big moving parts */\n+\n+/* create the selectors needed to bind and verify the pattern */\n+\n+fn pattern_to_selectors(&ext_ctxt cx, @expr e) -> binders {\n+    let binders res = rec(real_binders=new_str_hash[selector](),\n+                          mutable literal_ast_matchers=~[]);\n+    //this oughta return binders instead, but macro args are a sequence of\n+    //expressions, rather than a single expression\n+    fn trivial_selector(&matchable m) -> match_result {\n+        ret some(leaf(m));\n+    }\n+    p_t_s_rec(cx, match_expr(e), trivial_selector, res);\n+    ret res;\n+}\n+\n+\n+\n+/* use the selectors on the actual arguments to the macro to extract\n+bindings. Most of the work is done in p_t_s, which generates the\n+selectors. */\n+\n+fn use_selectors_to_bind(&binders b, @expr e) -> option::t[bindings] {\n+    auto res = new_str_hash[arb_depth[matchable]]();\n+    let bool never_mind = false;\n+    for each(@tup(ident, selector) pair in b.real_binders.items()) {\n+        alt (pair._1(match_expr(e))) {\n+          case (none) { never_mind = true; }\n+          case (some(?mtc)) { res.insert(pair._0, mtc); }\n+        }\n+    }\n+    if (never_mind) { ret none; } //HACK: `ret` doesn't work in `for each`\n+    for (selector sel in b.literal_ast_matchers) {\n+        alt (sel(match_expr(e))) {\n+          case (none) { ret none; }\n+          case (_) { }\n+        }\n+    }\n+    ret some(res);\n+}\n+\n+/* use the bindings on the body to generate the expanded code */\n+\n+fn transcribe(&ext_ctxt cx, &bindings b, @expr body) -> @expr {\n+    let @mutable vec[uint] idx_path = @mutable [];\n+    auto afp = default_ast_fold();\n+    auto f_pre =\n+        rec(fold_ident = bind transcribe_ident(cx, b, idx_path, _, _),\n+            fold_path = bind transcribe_path(cx, b, idx_path, _, _),\n+            fold_expr = bind transcribe_expr(cx, b, idx_path, _, _,\n+                                             afp.fold_expr),\n+            map_exprs = bind transcribe_exprs(cx, b, idx_path, _, _)\n+            with *afp);\n+    auto f = make_fold(f_pre);\n+    auto result = f.fold_expr(body);\n+    dummy_out(f);  //temporary: kill circular reference\n+    ret result;\n+}\n+\n+\n+\n+/* helper: descend into a matcher */\n+fn follow(&arb_depth[matchable] m, @mutable vec[uint] idx_path)\n+    -> arb_depth[matchable] {\n+    let arb_depth[matchable] res = m;\n+    for (uint idx in *idx_path) {\n+        alt(res) {\n+          case (leaf(_)) { ret res; /* end of the line */ }\n+          case (seq(?new_ms,_)) { res = new_ms.(idx); }\n+        }\n+    }\n+    ret res;\n+}\n+\n+fn follow_for_trans(&ext_ctxt cx, &option::t[arb_depth[matchable]] mmaybe,\n+                    @mutable vec[uint] idx_path) -> option::t[matchable] {\n+    alt(mmaybe) {\n+      case (none) { ret none }\n+      case (some(?m)) {\n+        ret alt(follow(m, idx_path)) {\n+          case (seq(_,?sp)) {\n+            cx.span_fatal(sp, \"syntax matched under ... but not \"\n+                          + \"used that way.\")\n+          }\n+          case (leaf(?m)) {\n+            ret some(m)\n+          }\n+        }\n+      }\n+    }\n+\n+}\n+\n+/* helper for transcribe_exprs: what vars from `b` occur in `e`? */\n+iter free_vars(&bindings b, @expr e) -> ident {\n+    let hashmap[ident,()] idents = new_str_hash[()]();\n+    fn mark_ident(&ident i, ast_fold fld, &bindings b,\n+                  &hashmap[ident,()] idents) -> ident {\n+        if(b.contains_key(i)) { idents.insert(i,()); }\n+        ret i;\n+    }\n+    // using fold is a hack: we want visit, but it doesn't hit idents ) :\n+    // solve this with macros\n+    auto f_pre = rec(fold_ident=bind mark_ident(_, _, b, idents)\n+                     with *default_ast_fold());\n+    auto f = make_fold(f_pre);\n+    f.fold_expr(e); // ignore result\n+    dummy_out(f);\n+    for each(@tup(ast::ident, ()) it in idents.items()) {\n+        put it._0;\n+    }\n+}\n+\n+\n+/* handle sequences (anywhere in the AST) of exprs, either real or ...ed */\n+fn transcribe_exprs(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n+                    fn(&@expr)->@expr recur, (@expr)[] exprs) -> (@expr)[] {\n+    alt (elts_to_ell(cx, exprs)) {\n+      case (some(?repeat_me)) {\n+        let option::t[rec(uint rep_count, ident name)] repeat = none;\n+        /* we need to walk over all the free vars in lockstep, except for\n+        the leaves, which are just duplicated */\n+        for each (ident fv in free_vars(b, repeat_me)) {\n+            auto cur_pos = follow(b.get(fv), idx_path);\n+            alt (cur_pos) {\n+              case (leaf(_)) { }\n+              case (seq(?ms,_)) {\n+                alt (repeat) {\n+                  case (none) {\n+                    repeat = some\n+                        (rec(rep_count=vec::len(ms), name=fv));\n+                  }\n+                  case (some({rep_count: ?old_len,\n+                              name: ?old_name})) {\n+                    auto len = vec::len(ms);\n+                    if (old_len != len) {\n+                        cx.span_fatal\n+                            (repeat_me.span,\n+                             #fmt(\"'%s' occurs %u times, but \",\n+                                  fv, len)+\n+                             #fmt(\"'%s' occurs %u times\",\n+                                  old_name, old_len));\n+                    }\n+                  }\n+                }\n+              }\n+            }\n         }\n-        case (some(path_binding(_, ?a_pth))) { a_pth.node }\n-        case (some(expr_binding(_, ?expr))) {\n-            cx.span_fatal(expr.span, \"This argument is expanded as an \"\n-                          + \"path; it must be one.\")\n+        auto res = ~[];\n+        alt (repeat) {\n+          case (none) {\n+            cx.span_fatal(repeat_me.span,\n+                          \"'...' surrounds an expression without any\"\n+                          + \" repeating syntax variables\");\n+          }\n+          case (some({rep_count: ?rc, _})) {\n+            /* Whew, we now know how how many times to repeat */\n+            let uint idx = 0u;\n+            while (idx < rc) {\n+                vec::push(*idx_path, idx);\n+                res += ~[recur(repeat_me)]; // whew!\n+                vec::pop(*idx_path);\n+                idx += 1u;\n+            }\n+          }\n         }\n-        case (none) { p }\n+        ret res;\n+      }\n+      case (none) { ret ivec::map(recur, exprs); }\n     }\n }\n \n \n-fn subst_expr(&ext_ctxt cx, &(invk_binding)[] ibs, &ast::expr_ e,\n-              ast_fold fld, fn(&ast::expr_, ast_fold) -> ast::expr_ orig)\n+\n+// substitute, in a position that's required to be an ident\n+fn transcribe_ident(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n+                    &ident i, ast_fold fld) -> ident {\n+    ret alt (follow_for_trans(cx, b.find(i), idx_path)) {\n+      case (some(match_ident(?a_id))) { a_id.node }\n+      case (some(?m)) { match_error(cx, m, \"an identifier\") }\n+      case (none) { i }\n+    }\n+}\n+\n+\n+fn transcribe_path(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n+                   &path_ p, ast_fold fld) -> path_ {\n+    // Don't substitute into qualified names.\n+    if (ivec::len(p.types) > 0u || ivec::len(p.idents) != 1u) { ret p; }\n+    ret alt (follow_for_trans(cx, b.find(p.idents.(0)), idx_path)) {\n+      case (some(match_ident(?id))) {\n+        rec(global=false, idents=~[id.node], types=~[])\n+      }\n+      case (some(match_path(?a_pth))) { a_pth.node }\n+      case (some(?m)) { match_error(cx, m, \"a path\") }\n+      case (none) { p }\n+    }\n+}\n+\n+\n+fn transcribe_expr(&ext_ctxt cx, &bindings b, @mutable vec[uint] idx_path,\n+                   &ast::expr_ e, ast_fold fld,\n+                   fn(&ast::expr_, ast_fold) -> ast::expr_ orig)\n     -> ast::expr_ {\n     ret alt(e) {\n-        case (expr_path(?p)){\n-            // Don't substitute into qualified names.\n-            if (ivec::len(p.node.types) > 0u ||\n-                ivec::len(p.node.idents) != 1u) { e }\n-            alt (lookup(ibs, p.node.idents.(0))) {\n-                case (some(ident_binding(_, ?id))) {\n-                    expr_path(respan(id.span,\n-                                     rec(global=false,\n-                                         idents=~[id.node],types=~[])))\n+      case (expr_path(?p)){\n+        // Don't substitute into qualified names.\n+        if (ivec::len(p.node.types) > 0u ||\n+            ivec::len(p.node.idents) != 1u) { e }\n+        alt (follow_for_trans(cx, b.find(p.node.idents.(0)), idx_path)) {\n+          case (some(match_ident(?id))) {\n+            expr_path(respan(id.span,\n+                             rec(global=false,\n+                                 idents=~[id.node],types=~[])))\n+          }\n+          case (some(match_path(?a_pth))) { expr_path(a_pth) }\n+          case (some(match_expr(?a_exp))) { a_exp.node }\n+          case (some(?m)) { match_error(cx, m, \"an expression\")}\n+          case (none) { orig(e,fld) }\n+        }\n+      }\n+      case (_) { orig(e,fld) }\n+    }\n+}\n+\n+\n+\n+\n+\n+/* traverse the pattern, building instructions on how to bind the actual\n+argument. ps accumulates instructions on navigating the tree.*/\n+fn p_t_s_rec(&ext_ctxt cx, &matchable m, &selector s, &binders b) {\n+    //it might be possible to traverse only exprs, not matchables\n+    alt (m) {\n+      case (match_expr(?e)) {\n+        alt (e.node) {\n+          case (expr_path(?p_pth)) {\n+            p_t_s_r_path(cx,p_pth, s, b);\n+          }\n+          case (expr_vec(?p_elts, _, _)) {\n+            alt (elts_to_ell(cx, p_elts)) {\n+              case (some(?repeat_me)) {\n+                p_t_s_r_ellipses(cx, repeat_me, s, b);\n+              }\n+              case (none) {\n+                p_t_s_r_actual_vector(cx, p_elts, s, b);\n+              }\n+            }\n+          }\n+          /* TODO: handle embedded types and blocks, at least */\n+          case (_) {\n+            fn select(&ext_ctxt cx, &matchable m, @expr pat)\n+                -> match_result {\n+                ret alt(m) {\n+                  case (match_expr(?e)) {\n+                    if (e==pat) { some(leaf(match_exact)) } else { none }\n+                  }\n                 }\n-                case (some(path_binding(_, ?a_pth))) { expr_path(*a_pth) }\n-                case (some(expr_binding(_, ?a_exp))) { a_exp.node }\n-                case (none) { orig(e,fld) }\n             }\n+            b.literal_ast_matchers += ~[bind select(cx,_,e)];\n+          }\n         }\n-        case (_) { orig(e,fld) }\n+      }\n     }\n }\n \n-type pat_ext = rec((@ast::expr)[] invk, @ast::expr body);\n \n-// maybe box?\n-tag invk_binding {\n-    expr_binding(ident, @ast::expr);\n-    path_binding(ident, @ast::path);\n-    ident_binding(ident, ast::spanned[ident]);\n+/* make a match more precise */\n+fn specialize_match(&matchable m) -> matchable {\n+    ret alt (m) {\n+      case (match_expr(?e)) {\n+        alt (e.node) {\n+          case (expr_path(?pth)) {\n+            alt (path_to_ident(pth)) {\n+              case (some(?id)) {\n+                match_ident(respan(pth.span,id))\n+              }\n+              case (none) {\n+                match_path(pth)\n+              }\n+            }\n+          }\n+          case (_) { m }\n+        }\n+      }\n+      case (_) { m }\n+    }\n }\n \n-fn path_to_ident(&path pth) -> option::t[ident] {\n-    if (ivec::len(pth.node.idents) == 1u\n-        && ivec::len(pth.node.types) == 0u) {\n-        ret some(pth.node.idents.(0u));\n+/* Too much indentation, had to pull these out */\n+fn p_t_s_r_path(&ext_ctxt cx, &path p, &selector s, &binders b) {\n+    alt (path_to_ident(p)) {\n+      case (some(?p_id)) {\n+        fn select(&ext_ctxt cx, &matchable m) -> match_result {\n+            ret alt (m) {\n+              case (match_expr(?e)) { some(leaf(specialize_match(m))) }\n+              case (_) { cx.bug(\"broken traversal in p_t_s_r\"); fail }\n+            }\n+        }\n+        if (b.real_binders.contains_key(p_id)) {\n+            cx.span_fatal(p.span, \"duplicate binding identifier\");\n+        }\n+        b.real_binders.insert(p_id, compose_sels(s, bind select(cx,_)));\n+      }\n+      case (none) { }\n     }\n-    ret none;\n }\n \n-fn process_clause(&ext_ctxt cx, &mutable vec[pat_ext] pes,\n-                  &mutable option::t[str] macro_name, &path pth,\n-                  &(@ast::expr)[] invoc_args, @ast::expr body) {\n-    let str clause_name = alt(path_to_ident(pth)) {\n-        case (some(?id)) { id }\n-        case (none) {\n-            cx.span_fatal(pth.span, \"macro name must not be a path\")\n+/* TODO: move this to vec.rs */\n+\n+fn ivec_to_vec[T](&(T)[] v) -> vec[T] {\n+    let vec[T] rs = vec::alloc[T](ivec::len(v));\n+    for (T ve in v) { rs += [ve]; }\n+    ret rs;\n+}\n+\n+fn p_t_s_r_ellipses(&ext_ctxt cx, @expr repeat_me, &selector s, &binders b) {\n+    fn select(&ext_ctxt cx, @expr repeat_me, &matchable m) -> match_result {\n+        ret alt (m) {\n+          case (match_expr(?e)) {\n+            alt (e.node) {\n+              case (expr_vec(?arg_elts, _, _)) {\n+                auto elts = ivec::map(leaf, ivec::map(match_expr,\n+                                                      arg_elts));\n+                // using repeat_me.span is a little wacky, but the\n+                // error we want to report is one in the macro def\n+                some(seq(ivec_to_vec(elts), repeat_me.span))\n+              }\n+              case (_) { none }\n+            }\n+          }\n+          case (_) { cx.bug(\"broken traversal in p_t_s_r\"); fail }\n         }\n-    };\n-    if (macro_name == none) {\n-        macro_name = some(clause_name);\n-    } else if (macro_name != some(clause_name)) {\n-        cx.span_fatal(pth.span, \"#macro can only introduce one name\");\n     }\n-    pes += [rec(invk=invoc_args, body=body)];\n+    p_t_s_rec(cx, match_expr(repeat_me),\n+              compose_sels(s, bind select(cx, repeat_me, _)), b);\n }\n \n+fn p_t_s_r_actual_vector(&ext_ctxt cx, (@expr)[] elts, &selector s,\n+                         &binders b) {\n+    fn len_select(&ext_ctxt cx, &matchable m, uint len) -> match_result {\n+        ret alt (m) {\n+          case (match_expr(?e)) {\n+            alt (e.node) {\n+              case (expr_vec(?arg_elts, _, _)) {\n+                if (ivec::len(arg_elts) == len) { some(leaf(match_exact)) }\n+                else { none }\n+              }\n+              case (_) { none }\n+            }\n+          }\n+          case (_) { none }\n+        }\n+    }\n+    b.literal_ast_matchers +=\n+        ~[compose_sels(s, bind len_select(cx, _, ivec::len(elts)))];\n+\n+\n+    let uint idx = 0u;\n+    while (idx < ivec::len(elts)) {\n+        fn select(&ext_ctxt cx, &matchable m, uint idx) -> match_result {\n+            ret alt (m) {\n+              case (match_expr(?e)) {\n+                alt (e.node) {\n+                  case (expr_vec(?arg_elts, _, _)) {\n+                    some(leaf(match_expr(arg_elts.(idx))))\n+                  }\n+                  case (_) { none }\n+                }\n+              }\n+              case (_) { cx.bug(\"broken traversal in p_t_s_r\"); fail}\n+            }\n+        }\n+        p_t_s_rec(cx, match_expr(elts.(idx)),\n+                  compose_sels(s, bind select(cx, _, idx)), b);\n+        idx += 1u;\n+    }\n+}\n \n-fn add_new_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n+fn add_new_extension(&ext_ctxt cx, span sp, &(@expr)[] args,\n                      option::t[str] body) -> tup(str, syntax_extension) {\n     let option::t[str] macro_name = none;\n-    let vec[pat_ext] pat_exts = [];\n-    for (@ast::expr arg in args) {\n+    let (clause)[] clauses = ~[];\n+    for (@expr arg in args) {\n         alt(arg.node) {\n-            case(expr_vec(?elts, ?mut, ?seq_kind)) {\n+          case(expr_vec(?elts, ?mut, ?seq_kind)) {\n+            if (ivec::len(elts) != 2u) {\n+                cx.span_fatal((*arg).span,\n+                              \"extension clause must consist of [\" +\n+                              \"macro invocation, expansion body]\");\n+            }\n \n-                if (ivec::len(elts) != 2u) {\n-                    cx.span_fatal((*arg).span,\n-                                  \"extension clause must consist of [\" +\n-                                  \"macro invocation, expansion body]\");\n-                }\n-                alt(elts.(0u).node) {\n-                    case(expr_mac(?mac)) {\n-                        alt (mac.node) {\n-                            case (mac_invoc(?pth, ?invoc_args, ?body)) {\n-                                process_clause(cx, pat_exts, macro_name,\n-                                               pth, invoc_args, elts.(1u));\n-                            }\n-                        }\n+            alt(elts.(0u).node) {\n+              case(expr_mac(?mac)) {\n+                alt (mac.node) {\n+                  case (mac_invoc(?pth, ?invoc_args, ?body)) {\n+                    alt (path_to_ident(pth)) {\n+                      case (some(?id)) { macro_name=some(id); }\n+                      case (none) {\n+                        cx.span_fatal(pth.span, \"macro name \"\n+                                      + \"must not be a path\");\n+                      }\n                     }\n-                    case(_) {\n-                        cx.span_fatal(elts.(0u).span, \"extension clause must\"\n-                                      + \" start with a macro invocation.\");\n+                    auto bdrses = ~[];\n+                    for(@expr arg in invoc_args) {\n+                        bdrses +=\n+                            ~[pattern_to_selectors(cx, arg)];\n                     }\n+                    clauses +=\n+                        ~[rec(params=bdrses, body=elts.(1u))];\n+                    // FIXME: check duplicates (or just simplify\n+                    // the macro arg situation)\n+                  }\n                 }\n+              }\n+              case(_) {\n+                cx.span_fatal(elts.(0u).span, \"extension clause must\"\n+                              + \" start with a macro invocation.\");\n+              }\n             }\n-            case(_) {\n-                    cx.span_fatal((*arg).span, \"extension must be [clause, \"\n-                                  + \" ...]\");\n-            }\n+          }\n+          case(_) {\n+            cx.span_fatal((*arg).span, \"extension must be [clause, \"\n+                          + \" ...]\");\n+          }\n         }\n     }\n \n-    auto ext = bind generic_extension(_,_,_,_,@pat_exts);\n+    auto ext = bind generic_extension(_,_,_,_,clauses);\n \n     ret tup(alt (macro_name) {\n-                case (some(?id)) { id }\n-                case (none) {\n-                    cx.span_fatal(sp, \"macro definition must have \"\n-                                  + \"at least one clause\")\n-                }\n-            },\n+      case (some(?id)) { id }\n+      case (none) {\n+        cx.span_fatal(sp, \"macro definition must have \"\n+                      + \"at least one clause\")\n+      }\n+    },\n             normal(ext));\n \n \n-    fn generic_extension(&ext_ctxt cx, span sp, &(@ast::expr)[] args,\n-                         option::t[str] body, @vec[pat_ext] clauses)\n-        -> @ast::expr {\n-\n-        /* returns a list of bindings, or none if the match fails. */\n-        fn match_invk(@ast::expr pattern, @ast::expr argument)\n-            -> option::t[(invk_binding)[]] {\n-            auto pat = pattern.node;\n-            auto arg = argument.node;\n-            ret alt (pat) {\n-                case (expr_vec(?p_elts, _, _)) {\n-                    alt (arg) {\n-                        case (expr_vec(?a_elts, _, _)) {\n-                            if (ivec::len(p_elts) != ivec::len(a_elts)) {\n-                                none[vec[invk_binding]]\n-                            }\n-                            let uint i = 0u;\n-                            let (invk_binding)[] res = ~[];\n-                            while (i < ivec::len(p_elts)) {\n-                                alt (match_invk(p_elts.(i), a_elts.(i))) {\n-                                    case (some(?v)) { res += v; }\n-                                    case (none) { ret none; }\n-                                }\n-                                i += 1u;\n-                            }\n-                            some(res)\n-                        }\n-                        case (_) { none }\n-                    }\n-                }\n-                case (expr_path(?p_pth)) {\n-                    alt (path_to_ident(p_pth)) {\n-                        case (some(?p_id)) {\n-                            /* let's bind! */\n-                            alt (arg) {\n-                                case (expr_path(?a_pth)) {\n-                                    alt (path_to_ident(a_pth)) {\n-                                        case (some(?a_id)) {\n-                                            some(~[ident_binding\n-                                                   (p_id,\n-                                                    respan(argument.span,\n-                                                                 a_id))])\n-                                        }\n-                                        case (none) {\n-                                            some(~[path_binding(p_id,\n-                                                                @a_pth)])\n-                                        }\n-                                    }\n-                                }\n-                                case (_) {\n-                                    some(~[expr_binding(p_id, argument)])\n-                                }\n-                            }\n-                        }\n-                        // FIXME this still compares on internal spans\n-                        case (_) { if(pat == arg) { some(~[]) } else { none }}\n-                    }\n-                }\n-                // FIXME this still compares on internal spans\n-                case (_) { if (pat == arg) { some(~[]) } else { none }}\n-            }\n-        }\n+    fn generic_extension(&ext_ctxt cx, span sp, &(@expr)[] args,\n+                         option::t[str] body, (clause)[] clauses)\n+        -> @expr {\n \n-        for (pat_ext pe in *clauses) {\n-            if (ivec::len(args) != ivec::len(pe.invk)) { cont; }\n+\n+        for (clause c in clauses) {\n+            if (ivec::len(args) != ivec::len(c.params)) { cont; }\n             let uint i = 0u;\n-            let (invk_binding)[] bindings = ~[];\n+            let bindings bdgs = new_str_hash[arb_depth[matchable]]();\n+            let bool abort = false;\n             while (i < ivec::len(args)) {\n-                alt (match_invk(pe.invk.(i), args.(i))) {\n-                    case (some(?v)) { bindings += v; }\n-                    case (none) { cont }\n+                alt (use_selectors_to_bind(c.params.(i), args.(i))) {\n+                  case (some(?new_bindings)) {\n+                    /* ick; I wish macros just took one expr */\n+                    for each (@tup(ident,arb_depth[matchable]) it\n+                              in new_bindings.items()) {\n+                        bdgs.insert(it._0, it._1);\n+                    }\n+                  }\n+                  case (none) { abort = true; }\n                 }\n                 i += 1u;\n             }\n-            auto afp = default_ast_fold();\n-            auto f_pre =\n-                rec(fold_ident = bind subst_ident(cx, bindings, _, _),\n-                    fold_path = bind subst_path(cx, bindings, _, _),\n-                    fold_expr = bind subst_expr(cx, bindings, _, _,\n-                                                afp.fold_expr)\n-                with *afp);\n-            auto f = make_fold(f_pre);\n-            auto result = f.fold_expr(pe.body);\n-            dummy_out(f); //temporary: kill circular reference\n-            ret result;\n+            if (abort) { cont; }\n+            ret transcribe(cx, bdgs, c.body);\n         }\n         cx.span_fatal(sp, \"no clauses match macro invocation\");\n     }"}, {"sha": "f29649085b4f38651e6cecafa4b6536ba0c3c9a1", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -42,7 +42,8 @@ type ast_fold_precursor =\n         fn (&variant_, ast_fold) -> variant_              fold_variant,\n         fn (&ident, ast_fold) -> ident                    fold_ident,\n         fn (&path_, ast_fold) -> path_                    fold_path,\n-        fn (&local_, ast_fold) -> local_                  fold_local\n+        fn (&local_, ast_fold) -> local_                  fold_local,\n+        fn (fn(&@expr)->@expr, (@expr)[] es) -> (@expr)[] map_exprs\n         );\n \n type a_f =\n@@ -67,7 +68,8 @@ type a_f =\n         fn (&variant) -> variant                      fold_variant,\n         fn (&ident) -> ident                          fold_ident,\n         fn (&path) -> path                            fold_path,\n-        fn (&@local) -> @local                        fold_local\n+        fn (&@local) -> @local                        fold_local,\n+        fn (fn(&@expr)->@expr, (@expr)[] es) -> (@expr)[] map_exprs\n         );\n \n //fn nf_dummy[T](&T node) -> T { fail; }\n@@ -131,7 +133,7 @@ fn fold_mac_(&mac m, ast_fold fld) -> mac {\n             alt(m.node) {\n                 case (mac_invoc(?pth,?args,?body)) {\n                     mac_invoc(fld.fold_path(pth),\n-                              ivec::map(fld.fold_expr, args), body)\n+                              fld.map_exprs(fld.fold_expr, args), body)\n                 }\n                 case (mac_embed_type(?ty)) {\n                     mac_embed_type(fld.fold_ty(ty))\n@@ -341,7 +343,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n \n     ret alt (e) {\n         case (expr_vec(?exprs, ?mut, ?seq_kind)) {\n-            expr_vec(ivec::map(fld.fold_expr, exprs), mut, seq_kind)\n+            expr_vec(fld.map_exprs(fld.fold_expr, exprs), mut, seq_kind)\n                 }\n         case (expr_tup(?elts)) {\n             expr_tup(ivec::map(fold_elt, elts))\n@@ -351,7 +353,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n                      option::map(fld.fold_expr, maybe_expr))\n                 }\n         case (expr_call(?f, ?args)) {\n-            expr_call(fld.fold_expr(f), ivec::map(fld.fold_expr, args))\n+            expr_call(fld.fold_expr(f), fld.map_exprs(fld.fold_expr, args))\n                 }\n         case (expr_self_method(?id)) {\n             expr_self_method(fld.fold_ident(id))\n@@ -362,7 +364,7 @@ fn noop_fold_expr(&expr_ e, ast_fold fld) -> expr_ {\n                 }\n         case (expr_spawn(?spawn_dom, ?name, ?f, ?args)) {\n             expr_spawn(spawn_dom, name, fld.fold_expr(f),\n-                       ivec::map(fld.fold_expr, args))\n+                       fld.map_exprs(fld.fold_expr, args))\n                 }\n         case (expr_binary(?binop, ?lhs, ?rhs)) {\n             expr_binary(binop, fld.fold_expr(lhs), fld.fold_expr(rhs))\n@@ -537,6 +539,12 @@ fn noop_fold_local(&local_ l, ast_fold fld) -> local_ {\n             id=l.id);\n }\n \n+/* temporarily eta-expand because of a compiler bug with using `fn[T]` as a\n+   value */\n+fn noop_map_exprs(fn(&@expr)->@expr f, (@expr)[] es) -> (@expr)[] {\n+    ret ivec::map(f,es);\n+}\n+\n \n fn default_ast_fold() -> @ast_fold_precursor {\n     ret @rec(fold_crate = noop_fold_crate,\n@@ -560,32 +568,34 @@ fn default_ast_fold() -> @ast_fold_precursor {\n              fold_variant = noop_fold_variant,\n              fold_ident = noop_fold_ident,\n              fold_path = noop_fold_path,\n-             fold_local = noop_fold_local);\n+             fold_local = noop_fold_local,\n+             map_exprs = noop_map_exprs);\n }\n \n fn dummy_out(ast_fold a) {\n     *a = rec(fold_crate = nf_crate_dummy,\n-                     fold_crate_directive = nf_crate_directive_dummy,\n-                     fold_view_item = nf_view_item_dummy,\n-                     fold_native_item = nf_native_item_dummy,\n-                     fold_item = nf_item_dummy,\n-                     fold_item_underscore = nf_item_underscore_dummy,\n-                     fold_method = nf_method_dummy,\n-                     fold_block = nf_block_dummy,\n-                     fold_stmt = nf_stmt_dummy,\n-                     fold_arm = nf_arm_dummy,\n-                     fold_pat = nf_pat_dummy,\n-                     fold_decl = nf_decl_dummy,\n-                     fold_expr = nf_expr_dummy,\n-                     fold_ty = nf_ty_dummy,\n-                     fold_constr = nf_constr_dummy,\n-                     fold_fn = nf_fn_dummy,\n-                     fold_mod = nf_mod_dummy,\n-                     fold_native_mod = nf_native_mod_dummy,\n-                     fold_variant = nf_variant_dummy,\n-                     fold_ident = nf_ident_dummy,\n-                     fold_path = nf_path_dummy,\n-                     fold_local = nf_local_dummy);\n+             fold_crate_directive = nf_crate_directive_dummy,\n+             fold_view_item = nf_view_item_dummy,\n+             fold_native_item = nf_native_item_dummy,\n+             fold_item = nf_item_dummy,\n+             fold_item_underscore = nf_item_underscore_dummy,\n+             fold_method = nf_method_dummy,\n+             fold_block = nf_block_dummy,\n+             fold_stmt = nf_stmt_dummy,\n+             fold_arm = nf_arm_dummy,\n+             fold_pat = nf_pat_dummy,\n+             fold_decl = nf_decl_dummy,\n+             fold_expr = nf_expr_dummy,\n+             fold_ty = nf_ty_dummy,\n+             fold_constr = nf_constr_dummy,\n+             fold_fn = nf_fn_dummy,\n+             fold_mod = nf_mod_dummy,\n+             fold_native_mod = nf_native_mod_dummy,\n+             fold_variant = nf_variant_dummy,\n+             fold_ident = nf_ident_dummy,\n+             fold_path = nf_path_dummy,\n+             fold_local = nf_local_dummy,\n+             map_exprs = noop_map_exprs);\n }\n \n \n@@ -612,7 +622,8 @@ fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n                      fold_variant = nf_variant_dummy,\n                      fold_ident = nf_ident_dummy,\n                      fold_path = nf_path_dummy,\n-                     fold_local = nf_local_dummy);\n+                     fold_local = nf_local_dummy,\n+                     map_exprs = noop_map_exprs);\n \n     /* naturally, a macro to write these would be nice */\n     fn f_crate(&ast_fold_precursor afp, ast_fold f, &crate c) -> crate {\n@@ -712,7 +723,8 @@ fn make_fold(&ast_fold_precursor afp) -> ast_fold {\n                   fold_variant = bind f_variant(afp,result,_),\n                   fold_ident = bind f_ident(afp,result,_),\n                   fold_path = bind f_path(afp,result,_),\n-                  fold_local = bind f_local(afp,result,_));\n+                  fold_local = bind f_local(afp,result,_),\n+                  map_exprs = afp.map_exprs);\n     ret result;\n }\n "}, {"sha": "1cb2ee52dd5d08bfd0ba80200655ffd694f9615e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -807,6 +807,9 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         p.bump();\n         auto blk = ast::mac_embed_block(parse_block_tail(p));\n         ret mk_mac_expr(p, lo, p.get_hi_pos(), blk);\n+    } else if (p.peek() == token::ELLIPSIS) {\n+        p.bump();\n+        ret mk_mac_expr(p, lo, p.get_hi_pos(), ast::mac_ellipsis)\n     } else if (p.peek() == token::TILDE) {\n         p.bump();\n         alt (p.peek()) {"}, {"sha": "45926bfefa8bb2488fdff895ddf57bda719357c0", "filename": "src/test/compile-fail/macro-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-2.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -1,5 +1,5 @@\n // xfail-stage0\n-//error-pattern:expanded as an identifier\n+//error-pattern:is an expr, expected an identifier\n fn main() {\n   #macro([#mylambda(x, body), {fn f(int x) -> int {ret body}; f}]);\n "}, {"sha": "d557ce5d8c57e686a80caacd32b9f48b1bb8f018", "filename": "src/test/run-pass/macro-by-example-1.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-1.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+  #macro([#apply(f,[x,...]), f(x, ...)]);\n+\n+  fn add(int a, int b) -> int {\n+    ret a+b;\n+  }\n+\n+  assert(#apply(add, [1, 15]) == 16);\n+}\n\\ No newline at end of file"}, {"sha": "95b8bd262637630d98514a87958440cbb2f6eb3f", "filename": "src/test/run-pass/macro-by-example-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e18d70fe12dcaa84e073f94922f625f3cebeea39/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-by-example-2.rs?ref=e18d70fe12dcaa84e073f94922f625f3cebeea39", "patch": "@@ -0,0 +1,24 @@\n+fn main() {\n+    #macro([#zip_or_unzip([[x, ...], [y, ...]]), [[x, y], ...]],\n+           [#zip_or_unzip([[xx, yy], ...]), [[xx, ...], [yy, ...]]]);\n+\n+\n+    assert(#zip_or_unzip([[1,2,3,4],[5,6,7,8]]) == [[1,5],[2,6],[3,7],[4,8]]);\n+    assert(#zip_or_unzip([[1,5],[2,6],[3,7],[4,8]]) == [[1,2,3,4],[5,6,7,8]]);\n+\n+\n+    #macro([#nested([[[x, ...], ...], [[y, ...], ...]]),\n+            [[[x, y], ...], ...]]);\n+    assert(#nested([[[1,2,3,4,5], [7,8,9,10,11,12]],\n+                    [[-1,-2,-3,-4,-5], [-7,-8,-9,-10,-11,-12]]])\n+           ==\n+           [[[1, -1], [2, -2], [3, -3], [4, -4], [5, -5]],\n+            [[7, -7], [8, -8], [9, -9], [10, -10], [11, -11], [12, -12]]]);\n+\n+    #macro([#dup([y, [x, ...]]), [[y, x], ...]]);\n+\n+    assert(#dup([1,[1,2,3,4]]) == [[1,1], [1,2], [1,3], [1,4]]);\n+\n+\n+\n+}\n\\ No newline at end of file"}]}