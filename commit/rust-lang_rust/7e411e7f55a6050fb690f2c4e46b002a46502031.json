{"sha": "7e411e7f55a6050fb690f2c4e46b002a46502031", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNDExZTdmNTVhNjA1MGZiNjkwZjJjNGU0NmIwMDJhNDY1MDIwMzE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-23T13:39:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-11-23T17:09:36Z"}, "message": "Implement HashStable for Span in libsyntax_pos.", "tree": {"sha": "3466e240135f93f33e1ed37cfb4cfeff012d404d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3466e240135f93f33e1ed37cfb4cfeff012d404d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e411e7f55a6050fb690f2c4e46b002a46502031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e411e7f55a6050fb690f2c4e46b002a46502031", "html_url": "https://github.com/rust-lang/rust/commit/7e411e7f55a6050fb690f2c4e46b002a46502031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e411e7f55a6050fb690f2c4e46b002a46502031/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea0c354758b334985169b35575fcbb8ca0a6f2f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0c354758b334985169b35575fcbb8ca0a6f2f3", "html_url": "https://github.com/rust-lang/rust/commit/ea0c354758b334985169b35575fcbb8ca0a6f2f3"}], "stats": {"total": 193, "additions": 100, "deletions": 93}, "files": [{"sha": "8b35839c182ac921db0480899ad4c432d64108bd", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 10, "deletions": 83, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7e411e7f55a6050fb690f2c4e46b002a46502031/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e411e7f55a6050fb690f2c4e46b002a46502031/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=7e411e7f55a6050fb690f2c4e46b002a46502031", "patch": "@@ -2,25 +2,23 @@ use crate::hir;\n use crate::hir::def_id::{DefId, DefIndex};\n use crate::hir::map::DefPathHash;\n use crate::hir::map::definitions::Definitions;\n-use crate::ich::{self, CachingSourceMapView, Fingerprint};\n+use crate::ich::{self, CachingSourceMapView};\n use crate::middle::cstore::CrateStore;\n use crate::ty::{TyCtxt, fast_reject};\n use crate::session::Session;\n \n use std::cmp::Ord;\n-use std::hash as std_hash;\n-use std::cell::RefCell;\n \n use syntax::ast;\n use syntax::source_map::SourceMap;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{self, SyntaxContext};\n+use syntax_pos::{SourceFile, BytePos};\n \n use rustc_data_structures::stable_hasher::{\n     HashStable, StableHasher, ToStableHashKey,\n };\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n@@ -281,85 +279,14 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n }\n \n impl<'a> syntax_pos::HashStableContext for StableHashingContext<'a> {\n-    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n-    /// fields (that would be similar to hashing pointers, since those are just\n-    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n-    /// triple, which stays the same even if the containing `SourceFile` has moved\n-    /// within the `SourceMap`.\n-    /// Also note that we are hashing byte offsets for the column, not unicode\n-    /// codepoint offsets. For the purpose of the hash that's sufficient.\n-    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n-    /// span starts and ends in the same file, which is almost always the case.\n-    fn hash_stable_span(&mut self, span: &Span, hasher: &mut StableHasher) {\n-        const TAG_VALID_SPAN: u8 = 0;\n-        const TAG_INVALID_SPAN: u8 = 1;\n-        const TAG_EXPANSION: u8 = 0;\n-        const TAG_NO_EXPANSION: u8 = 1;\n-\n-        if !self.hash_spans {\n-            return\n-        }\n-\n-        if *span == DUMMY_SP {\n-            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-        }\n-\n-        // If this is not an empty or invalid span, we want to hash the last\n-        // position that belongs to it, as opposed to hashing the first\n-        // position past it.\n-        let span = span.data();\n-        let (file_lo, line_lo, col_lo) = match self.source_map()\n-                                                  .byte_pos_to_line_and_col(span.lo) {\n-            Some(pos) => pos,\n-            None => {\n-                return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-            }\n-        };\n-\n-        if !file_lo.contains(span.hi) {\n-            return std_hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n-        }\n-\n-        std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n-        // We truncate the stable ID hash and line and column numbers. The chances\n-        // of causing a collision this way should be minimal.\n-        std_hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n-\n-        let col = (col_lo.0 as u64) & 0xFF;\n-        let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n-        let len = ((span.hi - span.lo).0 as u64) << 32;\n-        let line_col_len = col | line | len;\n-        std_hash::Hash::hash(&line_col_len, hasher);\n-\n-        if span.ctxt == SyntaxContext::root() {\n-            TAG_NO_EXPANSION.hash_stable(self, hasher);\n-        } else {\n-            TAG_EXPANSION.hash_stable(self, hasher);\n-\n-            // Since the same expansion context is usually referenced many\n-            // times, we cache a stable hash of it and hash that instead of\n-            // recursing every time.\n-            thread_local! {\n-                static CACHE: RefCell<FxHashMap<hygiene::ExpnId, u64>> = Default::default();\n-            }\n-\n-            let sub_hash: u64 = CACHE.with(|cache| {\n-                let expn_id = span.ctxt.outer_expn();\n-\n-                if let Some(&sub_hash) = cache.borrow().get(&expn_id) {\n-                    return sub_hash;\n-                }\n-\n-                let mut hasher = StableHasher::new();\n-                expn_id.expn_data().hash_stable(self, &mut hasher);\n-                let sub_hash: Fingerprint = hasher.finish();\n-                let sub_hash = sub_hash.to_smaller_hash();\n-                cache.borrow_mut().insert(expn_id, sub_hash);\n-                sub_hash\n-            });\n+    fn hash_spans(&self) -> bool {\n+        self.hash_spans\n+    }\n \n-            sub_hash.hash_stable(self, hasher);\n-        }\n+    fn byte_pos_to_line_and_col(&mut self, byte: BytePos)\n+        -> Option<(Lrc<SourceFile>, usize, BytePos)>\n+    {\n+        self.source_map().byte_pos_to_line_and_col(byte)\n     }\n }\n "}, {"sha": "66f25770722b2563ae824c1cd9bd8c9554f653f7", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 90, "deletions": 10, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/7e411e7f55a6050fb690f2c4e46b002a46502031/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e411e7f55a6050fb690f2c4e46b002a46502031/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=7e411e7f55a6050fb690f2c4e46b002a46502031", "patch": "@@ -37,10 +37,12 @@ mod analyze_source_file;\n pub mod fatal_error;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::sync::{Lrc, Lock};\n+use rustc_data_structures::fx::FxHashMap;\n \n use std::borrow::Cow;\n-use std::cell::Cell;\n+use std::cell::{Cell, RefCell};\n use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::{Hasher, Hash};\n@@ -247,14 +249,6 @@ impl Ord for Span {\n     }\n }\n \n-impl<CTX> HashStable<CTX> for Span\n-    where CTX: HashStableContext\n-{\n-    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        ctx.hash_stable_span(self, hasher)\n-    }\n-}\n-\n /// A collection of spans. Spans have two orthogonal attributes:\n ///\n /// - They can be *primary spans*. In this case they are the locus of\n@@ -1577,5 +1571,91 @@ fn lookup_line(lines: &[BytePos], pos: BytePos) -> isize {\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n /// instead of implementing everything in librustc.\n pub trait HashStableContext {\n-    fn hash_stable_span(&mut self, span: &Span, hasher: &mut StableHasher);\n+    fn hash_spans(&self) -> bool;\n+    fn byte_pos_to_line_and_col(&mut self, byte: BytePos)\n+        -> Option<(Lrc<SourceFile>, usize, BytePos)>;\n+}\n+\n+impl<CTX> HashStable<CTX> for Span\n+    where CTX: HashStableContext\n+{\n+    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n+    /// fields (that would be similar to hashing pointers, since those are just\n+    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n+    /// triple, which stays the same even if the containing `SourceFile` has moved\n+    /// within the `SourceMap`.\n+    /// Also note that we are hashing byte offsets for the column, not unicode\n+    /// codepoint offsets. For the purpose of the hash that's sufficient.\n+    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n+    /// span starts and ends in the same file, which is almost always the case.\n+    fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n+        const TAG_VALID_SPAN: u8 = 0;\n+        const TAG_INVALID_SPAN: u8 = 1;\n+        const TAG_EXPANSION: u8 = 0;\n+        const TAG_NO_EXPANSION: u8 = 1;\n+\n+        if !ctx.hash_spans() {\n+            return\n+        }\n+\n+        if *self == DUMMY_SP {\n+            return std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n+        // If this is not an empty or invalid span, we want to hash the last\n+        // position that belongs to it, as opposed to hashing the first\n+        // position past it.\n+        let span = self.data();\n+        let (file_lo, line_lo, col_lo) = match ctx.byte_pos_to_line_and_col(span.lo) {\n+            Some(pos) => pos,\n+            None => {\n+                return std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+            }\n+        };\n+\n+        if !file_lo.contains(span.hi) {\n+            return std::hash::Hash::hash(&TAG_INVALID_SPAN, hasher);\n+        }\n+\n+        std::hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n+        // We truncate the stable ID hash and line and column numbers. The chances\n+        // of causing a collision this way should be minimal.\n+        std::hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n+\n+        let col = (col_lo.0 as u64) & 0xFF;\n+        let line = ((line_lo as u64) & 0xFF_FF_FF) << 8;\n+        let len = ((span.hi - span.lo).0 as u64) << 32;\n+        let line_col_len = col | line | len;\n+        std::hash::Hash::hash(&line_col_len, hasher);\n+\n+        if span.ctxt == SyntaxContext::root() {\n+            TAG_NO_EXPANSION.hash_stable(ctx, hasher);\n+        } else {\n+            TAG_EXPANSION.hash_stable(ctx, hasher);\n+\n+            // Since the same expansion context is usually referenced many\n+            // times, we cache a stable hash of it and hash that instead of\n+            // recursing every time.\n+            thread_local! {\n+                static CACHE: RefCell<FxHashMap<hygiene::ExpnId, u64>> = Default::default();\n+            }\n+\n+            let sub_hash: u64 = CACHE.with(|cache| {\n+                let expn_id = span.ctxt.outer_expn();\n+\n+                if let Some(&sub_hash) = cache.borrow().get(&expn_id) {\n+                    return sub_hash;\n+                }\n+\n+                let mut hasher = StableHasher::new();\n+                expn_id.expn_data().hash_stable(ctx, &mut hasher);\n+                let sub_hash: Fingerprint = hasher.finish();\n+                let sub_hash = sub_hash.to_smaller_hash();\n+                cache.borrow_mut().insert(expn_id, sub_hash);\n+                sub_hash\n+            });\n+\n+            sub_hash.hash_stable(ctx, hasher);\n+        }\n+    }\n }"}]}