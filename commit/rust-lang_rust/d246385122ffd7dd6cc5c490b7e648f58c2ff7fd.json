{"sha": "d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNDYzODUxMjJmZmQ3ZGQ2Y2M1YzQ5MGI3ZTY0OGY1OGMyZmY3ZmQ=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-01T23:47:58Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:49:01Z"}, "message": "Run RustFmt", "tree": {"sha": "a5047dc08e4a896995c406d8fbeff527a38e8290", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5047dc08e4a896995c406d8fbeff527a38e8290"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "html_url": "https://github.com/rust-lang/rust/commit/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0634a5007306f3951ec28c0b9986452a91eebda8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0634a5007306f3951ec28c0b9986452a91eebda8", "html_url": "https://github.com/rust-lang/rust/commit/0634a5007306f3951ec28c0b9986452a91eebda8"}], "stats": {"total": 975, "additions": 476, "deletions": 499}, "files": [{"sha": "004835b230ab44e3260494aaa3c9611a34b28827", "filename": "src/librustc/lint.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -11,7 +11,6 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use rustc_span::{Span, Symbol};\n \n-\n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable)]\n pub enum LintSource {\n@@ -175,7 +174,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n     }\n }\n \n-\n pub struct LintDiagnosticBuilder<'a>(DiagnosticBuilder<'a>);\n \n impl<'a> LintDiagnosticBuilder<'a> {\n@@ -186,7 +184,7 @@ impl<'a> LintDiagnosticBuilder<'a> {\n     }\n \n     /// Create a LintDiagnosticBuilder from some existing DiagnosticBuilder.\n-    pub fn new(err: DiagnosticBuilder<'a>) -> LintDiagnosticBuilder<'a>{\n+    pub fn new(err: DiagnosticBuilder<'a>) -> LintDiagnosticBuilder<'a> {\n         LintDiagnosticBuilder(err)\n     }\n }\n@@ -207,14 +205,17 @@ pub fn struct_lint_level<'s, 'd>(\n         level: Level,\n         src: LintSource,\n         span: Option<MultiSpan>,\n-        decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>) {\n+        decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>,\n+    ) {\n         let mut err = match (level, span) {\n             (Level::Allow, _) => {\n                 return;\n             }\n             (Level::Warn, Some(span)) => sess.struct_span_warn(span, \"\"),\n             (Level::Warn, None) => sess.struct_warn(\"\"),\n-            (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => sess.struct_span_err(span, \"\"),\n+            (Level::Deny, Some(span)) | (Level::Forbid, Some(span)) => {\n+                sess.struct_span_err(span, \"\")\n+            }\n             (Level::Deny, None) | (Level::Forbid, None) => sess.struct_err(\"\"),\n         };\n "}, {"sha": "df3971a5ac3f11523ceeb647acd65c16d975a906", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -120,19 +120,18 @@ impl<'tcx> ConstEvalErr<'tcx> {\n                     }\n                 }\n                 lint.emit();\n-            }\n-        , Some(lint_root)) {\n-            Ok(_) => {\n-                ErrorHandled::Reported\n-            }\n+            },\n+            Some(lint_root),\n+        ) {\n+            Ok(_) => ErrorHandled::Reported,\n             Err(err) => err,\n         }\n     }\n \n-   /// Sets the message passed in via `message`, then adds the span labels for you, before applying\n-   /// further modifications in `emit`. It's up to you to call emit(), stash(..), etc. within the\n-   /// `emit` method. If you don't need to do any additional processing, just use\n-   /// struct_generic.\n+    /// Sets the message passed in via `message`, then adds the span labels for you, before applying\n+    /// further modifications in `emit`. It's up to you to call emit(), stash(..), etc. within the\n+    /// `emit` method. If you don't need to do any additional processing, just use\n+    /// struct_generic.\n     fn struct_generic(\n         &self,\n         tcx: TyCtxtAt<'tcx>,"}, {"sha": "4c5cd866b4a01b6651e4634e079810572135d5aa", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -238,7 +238,10 @@ fn object_safety_violations_for_trait(\n                         ));\n                         let node = tcx.hir().get_if_local(trait_def_id);\n                         let msg = if let Some(hir::Node::Item(item)) = node {\n-                            err.span_label(item.ident.span, \"this trait cannot be made into an object...\");\n+                            err.span_label(\n+                                item.ident.span,\n+                                \"this trait cannot be made into an object...\",\n+                            );\n                             format!(\"...because {}\", violation.error_msg())\n                         } else {\n                             format!(\n@@ -252,7 +255,12 @@ fn object_safety_violations_for_trait(\n                                 err.help(&note);\n                             }\n                             (Some(_), Some((note, Some((sugg, span))))) => {\n-                                err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n+                                err.span_suggestion(\n+                                    span,\n+                                    &note,\n+                                    sugg,\n+                                    Applicability::MachineApplicable,\n+                                );\n                             }\n                             // Only provide the help if its a local trait, otherwise it's not actionable.\n                             _ => {}"}, {"sha": "7c93a35158b08173c69a0036cd45a3128f4394bb", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -16,13 +16,13 @@ use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use crate::ty::{self, TyCtxt, TypeFoldable};\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;\n use rustc_session::lint::builtin::COHERENCE_LEAK_CHECK;\n use rustc_session::lint::builtin::ORDER_DEPENDENT_TRAIT_OBJECTS;\n use rustc_span::DUMMY_SP;\n-use rustc::lint::LintDiagnosticBuilder;\n \n use super::util::impl_trait_ref_and_oblig;\n use super::{FulfillmentContext, SelectionContext};\n@@ -357,9 +357,10 @@ pub(super) fn specialization_graph_provider(\n                         }\n                         Err(cname) => {\n                             let msg = match to_pretty_impl_header(tcx, overlap.with_impl) {\n-                                Some(s) => {\n-                                    format!(\"conflicting implementation in crate `{}`:\\n- {}\", cname, s)\n-                                }\n+                                Some(s) => format!(\n+                                    \"conflicting implementation in crate `{}`:\\n- {}\",\n+                                    cname, s\n+                                ),\n                                 None => format!(\"conflicting implementation in crate `{}`\", cname),\n                             };\n                             err.note(&msg);\n@@ -396,7 +397,6 @@ pub(super) fn specialization_graph_provider(\n                         )\n                     }\n                 };\n-\n             }\n         } else {\n             let parent = tcx.impl_parent(impl_def_id).unwrap_or(trait_id);"}, {"sha": "f2ad01b3d59615d0d3fe4af2824f100a7938a319", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -41,8 +41,8 @@ use crate::ty::{ExistentialPredicate, InferTy, ParamTy, PolyFnSig, Predicate, Pr\n use crate::ty::{InferConst, ParamConst};\n use crate::ty::{List, TyKind, TyS};\n use crate::util::common::ErrorReported;\n-use rustc_attr as attr;\n use rustc::lint::LintDiagnosticBuilder;\n+use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sharded::{IntoPointer, ShardedHashMap};\n@@ -2594,7 +2594,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint: &'static Lint,\n         hir_id: HirId,\n         span: impl Into<MultiSpan>,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n     ) {\n         let (level, src) = self.lint_level_at_node(lint, hir_id);\n         struct_lint_level(self.sess, lint, level, src, Some(span.into()), decorate);"}, {"sha": "3c13735bbf41f5c53225c2703e827d0c37c59b1c", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -37,7 +37,9 @@ fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n                 .span_label(span, format!(\"expected one of {}\", expected.join(\", \")))\n                 .emit();\n         }\n-        AttrError::MissingSince => { struct_span_err!(diag, span, E0542, \"missing 'since'\").emit(); },\n+        AttrError::MissingSince => {\n+            struct_span_err!(diag, span, E0542, \"missing 'since'\").emit();\n+        }\n         AttrError::MissingFeature => {\n             struct_span_err!(diag, span, E0546, \"missing 'feature'\").emit();\n         }"}, {"sha": "39f585231eea433c5e737871dae38c0e331001a8", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -106,7 +106,11 @@ impl<'a> DiagnosticBuilder<'a> {\n     ///\n     /// See `emit` and `delay_as_bug` for details.\n     pub fn emit_unless(&mut self, delay: bool) {\n-        if delay { self.delay_as_bug(); } else { self.emit(); }\n+        if delay {\n+            self.delay_as_bug();\n+        } else {\n+            self.emit();\n+        }\n     }\n \n     /// Stashes diagnostic for possible later improvement in a different,"}, {"sha": "a5614f900b6fb142cae7ca5d85da01ba105ad0b6", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1113,7 +1113,11 @@ pub fn expr_to_string(\n     err_msg: &str,\n ) -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg)\n-        .map_err(|err| err.map(|mut err| { err.emit(); }))\n+        .map_err(|err| {\n+            err.map(|mut err| {\n+                err.emit();\n+            })\n+        })\n         .ok()\n         .map(|(symbol, style, _)| (symbol, style))\n }"}, {"sha": "9fc81a4a1fdafc18a1b0851141a5bd370cb818e5", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 140, "deletions": 158, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -80,12 +80,12 @@ impl EarlyLintPass for WhileTrue {\n                         cx.struct_span_lint(WHILE_TRUE, condition_span, |lint| {\n                             lint.build(msg)\n                                 .span_suggestion_short(\n-                                condition_span,\n-                                \"use `loop`\",\n-                                \"loop\".to_owned(),\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n+                                    condition_span,\n+                                    \"use `loop`\",\n+                                    \"loop\".to_owned(),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n                         })\n                     }\n                 }\n@@ -176,31 +176,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     if cx.tcx.find_field_index(ident, &variant)\n                         == Some(cx.tcx.field_index(fieldpat.hir_id, cx.tables))\n                     {\n-                        cx.struct_span_lint(\n-                            NON_SHORTHAND_FIELD_PATTERNS,\n-                            fieldpat.span,\n-                            |lint| {\n-                                let mut err = lint.build(&format!(\"the `{}:` in this pattern is redundant\", ident));\n-                                let binding = match binding_annot {\n-                                    hir::BindingAnnotation::Unannotated => None,\n-                                    hir::BindingAnnotation::Mutable => Some(\"mut\"),\n-                                    hir::BindingAnnotation::Ref => Some(\"ref\"),\n-                                    hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n-                                };\n-                                let ident = if let Some(binding) = binding {\n-                                    format!(\"{} {}\", binding, ident)\n-                                } else {\n-                                    ident.to_string()\n-                                };\n-                                err.span_suggestion(\n-                                    fieldpat.span,\n-                                    \"use shorthand field pattern\",\n-                                    ident,\n-                                    Applicability::MachineApplicable,\n-                                );\n-                                err.emit();\n-                            }\n-                        );\n+                        cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span, |lint| {\n+                            let mut err = lint\n+                                .build(&format!(\"the `{}:` in this pattern is redundant\", ident));\n+                            let binding = match binding_annot {\n+                                hir::BindingAnnotation::Unannotated => None,\n+                                hir::BindingAnnotation::Mutable => Some(\"mut\"),\n+                                hir::BindingAnnotation::Ref => Some(\"ref\"),\n+                                hir::BindingAnnotation::RefMut => Some(\"ref mut\"),\n+                            };\n+                            let ident = if let Some(binding) = binding {\n+                                format!(\"{} {}\", binding, ident)\n+                            } else {\n+                                ident.to_string()\n+                            };\n+                            err.span_suggestion(\n+                                fieldpat.span,\n+                                \"use shorthand field pattern\",\n+                                ident,\n+                                Applicability::MachineApplicable,\n+                            );\n+                            err.emit();\n+                        });\n                     }\n                 }\n             }\n@@ -644,22 +641,20 @@ impl EarlyLintPass for AnonymousParameters {\n                                     (\"<type>\".to_owned(), Applicability::HasPlaceholders)\n                                 };\n \n-                                cx.struct_span_lint(\n-                                    ANONYMOUS_PARAMETERS,\n-                                    arg.pat.span,\n-                                    |lint| {\n-                                    lint.build(\"anonymous parameters are deprecated and will be \\\n-                                     removed in the next edition.\")\n-                                        .span_suggestion(\n-                                            arg.pat.span,\n-                                            \"try naming the parameter or explicitly \\\n+                                cx.struct_span_lint(ANONYMOUS_PARAMETERS, arg.pat.span, |lint| {\n+                                    lint.build(\n+                                        \"anonymous parameters are deprecated and will be \\\n+                                     removed in the next edition.\",\n+                                    )\n+                                    .span_suggestion(\n+                                        arg.pat.span,\n+                                        \"try naming the parameter or explicitly \\\n                                             ignoring it\",\n-                                            format!(\"_: {}\", ty_snip),\n-                                            appl,\n-                                        )\n-                                        .emit();\n-                                    },\n-                                )\n+                                        format!(\"_: {}\", ty_snip),\n+                                        appl,\n+                                    )\n+                                    .emit();\n+                                })\n                             }\n                         }\n                         _ => (),\n@@ -838,22 +833,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                         match param.kind {\n                             GenericParamKind::Lifetime { .. } => {}\n                             GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                                cx.struct_span_lint(\n-                                    NO_MANGLE_GENERIC_ITEMS,\n-                                    it.span,\n-                                    |lint| {\n-                                        lint.build(\"functions generic over types or consts must be mangled\")\n-                                            .span_suggestion_short(\n-                                                no_mangle_attr.span,\n-                                                \"remove this attribute\",\n-                                                String::new(),\n-                                                // Use of `#[no_mangle]` suggests FFI intent; correct\n-                                                // fix may be to monomorphize source by hand\n-                                                Applicability::MaybeIncorrect,\n-                                            )\n-                                            .emit();\n-                                    },\n-                                );\n+                                cx.struct_span_lint(NO_MANGLE_GENERIC_ITEMS, it.span, |lint| {\n+                                    lint.build(\n+                                        \"functions generic over types or consts must be mangled\",\n+                                    )\n+                                    .span_suggestion_short(\n+                                        no_mangle_attr.span,\n+                                        \"remove this attribute\",\n+                                        String::new(),\n+                                        // Use of `#[no_mangle]` suggests FFI intent; correct\n+                                        // fix may be to monomorphize source by hand\n+                                        Applicability::MaybeIncorrect,\n+                                    )\n+                                    .emit();\n+                                });\n                                 break;\n                             }\n                         }\n@@ -995,30 +988,26 @@ impl UnreachablePub {\n                     applicability = Applicability::MaybeIncorrect;\n                 }\n                 let def_span = cx.tcx.sess.source_map().def_span(span);\n-                cx.struct_span_lint(\n-                    UNREACHABLE_PUB,\n-                    def_span,\n-                    |lint| {\n-                        let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n-                        let replacement = if cx.tcx.features().crate_visibility_modifier {\n-                            \"crate\"\n-                        } else {\n-                            \"pub(crate)\"\n-                        }\n-                        .to_owned();\n+                cx.struct_span_lint(UNREACHABLE_PUB, def_span, |lint| {\n+                    let mut err = lint.build(&format!(\"unreachable `pub` {}\", what));\n+                    let replacement = if cx.tcx.features().crate_visibility_modifier {\n+                        \"crate\"\n+                    } else {\n+                        \"pub(crate)\"\n+                    }\n+                    .to_owned();\n \n-                        err.span_suggestion(\n-                            vis.span,\n-                            \"consider restricting its visibility\",\n-                            replacement,\n-                            applicability,\n-                        );\n-                        if exportable {\n-                            err.help(\"or consider exporting it for use by other crates\");\n-                        }\n-                        err.emit();\n+                    err.span_suggestion(\n+                        vis.span,\n+                        \"consider restricting its visibility\",\n+                        replacement,\n+                        applicability,\n+                    );\n+                    if exportable {\n+                        err.help(\"or consider exporting it for use by other crates\");\n                     }\n-                );\n+                    err.emit();\n+                });\n             }\n             _ => {}\n         }\n@@ -1163,21 +1152,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n                 })\n                 .collect();\n             if !spans.is_empty() {\n-                cx.struct_span_lint(\n-                    TYPE_ALIAS_BOUNDS,\n-                    spans,\n-                    |lint| {\n-                        let mut err = lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n-                        let msg = \"the bound will not be checked when the type alias is used, \\\n+                cx.struct_span_lint(TYPE_ALIAS_BOUNDS, spans, |lint| {\n+                    let mut err =\n+                        lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n+                    let msg = \"the bound will not be checked when the type alias is used, \\\n                                    and should be removed\";\n-                        err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n-                        if !suggested_changing_assoc_types {\n-                            TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                            suggested_changing_assoc_types = true;\n-                        }\n-                        err.emit();\n-                    },\n-                );\n+                    err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n+                    if !suggested_changing_assoc_types {\n+                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                        suggested_changing_assoc_types = true;\n+                    }\n+                    err.emit();\n+                });\n             }\n         }\n     }\n@@ -1356,7 +1342,7 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n                             join,\n                             suggestion,\n                             \"..=\".to_owned(),\n-                            Applicability::MachineApplicable\n+                            Applicability::MachineApplicable,\n                         )\n                         .emit();\n                 });\n@@ -1405,7 +1391,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n         }\n \n         if let Some(attr) = attr::find_by_name(&it.attrs, sym::rustc_test_marker) {\n-            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| lint.build(\"cannot test inner items\").emit());\n+            cx.struct_span_lint(UNNAMEABLE_TEST_ITEMS, attr.span, |lint| {\n+                lint.build(\"cannot test inner items\").emit()\n+            });\n         }\n     }\n \n@@ -1486,20 +1474,16 @@ impl KeywordIdents {\n             return;\n         }\n \n-        cx.struct_span_lint(\n-            KEYWORD_IDENTS,\n-            ident.span,\n-            |lint| {\n-                lint.build(&format!(\"`{}` is a keyword in the {} edition\", ident, next_edition))\n-                    .span_suggestion(\n-                        ident.span,\n-                        \"you can use a raw identifier to stay compatible\",\n-                        format!(\"r#{}\", ident),\n-                        Applicability::MachineApplicable,\n-                    )\n-                    .emit()\n-            },\n-        );\n+        cx.struct_span_lint(KEYWORD_IDENTS, ident.span, |lint| {\n+            lint.build(&format!(\"`{}` is a keyword in the {} edition\", ident, next_edition))\n+                .span_suggestion(\n+                    ident.span,\n+                    \"you can use a raw identifier to stay compatible\",\n+                    format!(\"r#{}\", ident),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit()\n+        });\n     }\n }\n \n@@ -1803,19 +1787,22 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitOutlivesRequirements {\n             }\n \n             if !lint_spans.is_empty() {\n-                cx.struct_span_lint(\n-                    EXPLICIT_OUTLIVES_REQUIREMENTS,\n-                    lint_spans.clone(),\n-                    |lint| {\n-                        lint.build(\"outlives requirements can be inferred\")\n-                            .multipart_suggestion(\n-                                if bound_count == 1 { \"remove this bound\" } else { \"remove these bounds\" },\n-                                lint_spans.into_iter().map(|span| (span, \"\".to_owned())).collect::<Vec<_>>(),\n-                                Applicability::MachineApplicable,\n-                            )\n-                            .emit();\n-                    },\n-                );\n+                cx.struct_span_lint(EXPLICIT_OUTLIVES_REQUIREMENTS, lint_spans.clone(), |lint| {\n+                    lint.build(\"outlives requirements can be inferred\")\n+                        .multipart_suggestion(\n+                            if bound_count == 1 {\n+                                \"remove this bound\"\n+                            } else {\n+                                \"remove these bounds\"\n+                            },\n+                            lint_spans\n+                                .into_iter()\n+                                .map(|span| (span, \"\".to_owned()))\n+                                .collect::<Vec<_>>(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                });\n             }\n         }\n     }\n@@ -1842,14 +1829,13 @@ impl EarlyLintPass for IncompleteFeatures {\n             .chain(features.declared_lib_features.iter().map(|(name, span)| (name, span)))\n             .filter(|(name, _)| rustc_feature::INCOMPLETE_FEATURES.iter().any(|f| name == &f))\n             .for_each(|(name, &span)| {\n-                cx.struct_span_lint(\n-                    INCOMPLETE_FEATURES,\n-                    span,\n-                    |lint| lint.build(&format!(\n+                cx.struct_span_lint(INCOMPLETE_FEATURES, span, |lint| {\n+                    lint.build(&format!(\n                         \"the feature `{}` is incomplete and may cause the compiler to crash\",\n                         name,\n-                    )).emit(),\n-                )\n+                    ))\n+                    .emit()\n+                })\n             });\n     }\n }\n@@ -2039,32 +2025,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.tables.expr_ty(expr);\n             if let Some((msg, span)) = ty_find_init_error(cx.tcx, conjured_ty, init) {\n-                cx.struct_span_lint(\n-                    INVALID_VALUE,\n-                    expr.span,\n-                    |lint| {\n-                        let mut err = lint.build(&format!(\n-                            \"the type `{}` does not permit {}\",\n-                            conjured_ty,\n-                            match init {\n-                                InitKind::Zeroed => \"zero-initialization\",\n-                                InitKind::Uninit => \"being left uninitialized\",\n-                            },\n-                        ));\n-                        err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n-                        err.span_label(\n-                            expr.span,\n-                            \"help: use `MaybeUninit<T>` instead, \\\n+                cx.struct_span_lint(INVALID_VALUE, expr.span, |lint| {\n+                    let mut err = lint.build(&format!(\n+                        \"the type `{}` does not permit {}\",\n+                        conjured_ty,\n+                        match init {\n+                            InitKind::Zeroed => \"zero-initialization\",\n+                            InitKind::Uninit => \"being left uninitialized\",\n+                        },\n+                    ));\n+                    err.span_label(expr.span, \"this code causes undefined behavior when executed\");\n+                    err.span_label(\n+                        expr.span,\n+                        \"help: use `MaybeUninit<T>` instead, \\\n                             and only call `assume_init` after initialization is done\",\n-                        );\n-                        if let Some(span) = span {\n-                            err.span_note(span, &msg);\n-                        } else {\n-                            err.note(&msg);\n-                        }\n-                        err.emit();\n-                    },\n-                );\n+                    );\n+                    if let Some(span) = span {\n+                        err.span_note(span, &msg);\n+                    } else {\n+                        err.note(&msg);\n+                    }\n+                    err.emit();\n+                });\n             }\n         }\n     }"}, {"sha": "d9ad97654e04bebda129e2adb7fc5f2898c2a9e2", "filename": "src/librustc_lint/context.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fcontext.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -20,14 +20,14 @@ use crate::levels::LintLevelsBuilder;\n use crate::passes::{EarlyLintPassObject, LateLintPassObject};\n use rustc::hir::map::definitions::{DefPathData, DisambiguatedDefPathData};\n use rustc::lint::add_elided_lifetime_in_path_suggestion;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n use rustc::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use rustc::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync;\n use rustc_errors::{struct_span_err, Applicability};\n-use rustc::lint::LintDiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_session::lint::BuiltinLintDiagnostics;\n@@ -505,7 +505,8 @@ pub trait LintContext: Sized {\n                         Ok(ref s) => {\n                             // FIXME(Manishearth) ideally the emitting code\n                             // can tell us whether or not this is global\n-                            let opt_colon = if s.trim_start().starts_with(\"::\") { \"\" } else { \"::\" };\n+                            let opt_colon =\n+                                if s.trim_start().starts_with(\"::\") { \"\" } else { \"::\" };\n \n                             (format!(\"crate{}{}\", opt_colon, s), Applicability::MachineApplicable)\n                         }\n@@ -519,7 +520,9 @@ pub trait LintContext: Sized {\n                         \"names from parent modules are not accessible without an explicit import\",\n                     );\n                 }\n-                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(span_def) => {\n+                BuiltinLintDiagnostics::MacroExpandedMacroExportsAccessedByAbsolutePaths(\n+                    span_def,\n+                ) => {\n                     db.span_note(span_def, \"the macro is defined here\");\n                 }\n                 BuiltinLintDiagnostics::ElidedLifetimesInPaths(\n@@ -585,7 +588,7 @@ pub trait LintContext: Sized {\n         &self,\n         lint: &'static Lint,\n         span: S,\n-        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n     ) {\n         self.lookup(lint, Some(span), decorate);\n     }"}, {"sha": "79a06e81410d0778c7b349d32c1590229b1a8184", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -47,7 +47,10 @@ impl EarlyLintPass for DefaultHashTypes {\n                         replace.to_string(),\n                         Applicability::MaybeIncorrect, // FxHashMap, ... needs another import\n                     )\n-                    .note(&format!(\"a `use rustc_data_structures::fx::{}` may be necessary\", replace))\n+                    .note(&format!(\n+                        \"a `use rustc_data_structures::fx::{}` may be necessary\",\n+                        replace\n+                    ))\n                     .emit();\n             });\n         }\n@@ -90,13 +93,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n             if lint_ty_kind_usage(cx, last) {\n                 cx.struct_span_lint(USAGE_OF_TY_TYKIND, span, |lint| {\n                     lint.build(\"usage of `ty::TyKind::<kind>`\")\n-                    .span_suggestion(\n-                        span,\n-                        \"try using ty::<kind> directly\",\n-                        \"ty\".to_string(),\n-                        Applicability::MaybeIncorrect, // ty maybe needs an import\n-                    )\n-                    .emit();\n+                        .span_suggestion(\n+                            span,\n+                            \"try using ty::<kind> directly\",\n+                            \"ty\".to_string(),\n+                            Applicability::MaybeIncorrect, // ty maybe needs an import\n+                        )\n+                        .emit();\n                 })\n             }\n         }\n@@ -108,36 +111,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                 if let QPath::Resolved(_, path) = qpath {\n                     if let Some(last) = path.segments.iter().last() {\n                         if lint_ty_kind_usage(cx, last) {\n-                            cx.struct_span_lint(\n-                                USAGE_OF_TY_TYKIND,\n-                                path.span,\n-                                |lint| {\n-                                    lint.build(\"usage of `ty::TyKind`\")\n-                                        .help(\"try using `Ty` instead\")\n-                                        .emit();\n-                                },\n-                            )\n+                            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, |lint| {\n+                                lint.build(\"usage of `ty::TyKind`\")\n+                                    .help(\"try using `Ty` instead\")\n+                                    .emit();\n+                            })\n                         } else {\n                             if ty.span.from_expansion() {\n                                 return;\n                             }\n                             if let Some(t) = is_ty_or_ty_ctxt(cx, ty) {\n                                 if path.segments.len() > 1 {\n-                                    cx.struct_span_lint(\n-                                        USAGE_OF_QUALIFIED_TY,\n-                                        path.span,\n-                                        |lint| {\n-                                            lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n-                                                .span_suggestion(\n-                                                    path.span,\n-                                                    \"try using it unqualified\",\n-                                                    t,\n-                                                    // The import probably needs to be changed\n-                                                    Applicability::MaybeIncorrect,\n-                                                )\n-                                                .emit();\n-                                        },\n-                                    )\n+                                    cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, |lint| {\n+                                        lint.build(&format!(\"usage of qualified `ty::{}`\", t))\n+                                            .span_suggestion(\n+                                                path.span,\n+                                                \"try using it unqualified\",\n+                                                t,\n+                                                // The import probably needs to be changed\n+                                                Applicability::MaybeIncorrect,\n+                                            )\n+                                            .emit();\n+                                    })\n                                 }\n                             }\n                         }\n@@ -151,11 +146,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                     }\n                 }\n                 if let Some(t) = is_ty_or_ty_ctxt(cx, &inner_ty) {\n-                    cx.struct_span_lint(\n-                        TY_PASS_BY_REFERENCE,\n-                        ty.span,\n-                        |lint| {\n-                            lint.build(&format!(\"passing `{}` by reference\", t))\n+                    cx.struct_span_lint(TY_PASS_BY_REFERENCE, ty.span, |lint| {\n+                        lint.build(&format!(\"passing `{}` by reference\", t))\n                             .span_suggestion(\n                                 ty.span,\n                                 \"try passing by value\",\n@@ -164,8 +156,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                                 Applicability::MaybeIncorrect,\n                             )\n                             .emit();\n-                        },\n-                    )\n+                    })\n                 }\n             }\n             _ => {}"}, {"sha": "b58acac316ef27227053b7ec8cdd2106da9f9899", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1,13 +1,13 @@\n use crate::context::{CheckLintNameResult, LintStore};\n use crate::late::unerased_lint_store;\n use rustc::hir::map::Map;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{struct_span_err, Applicability};\n-use rustc::lint::LintDiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::{intravisit, HirId};\n@@ -248,13 +248,13 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     Some(li.span().into()),\n                                     |lint| {\n                                         lint.build(&msg)\n-                                        .span_suggestion(\n-                                            li.span(),\n-                                            \"change it to\",\n-                                            new_lint_name.to_string(),\n-                                            Applicability::MachineApplicable,\n-                                        )\n-                                        .emit();\n+                                            .span_suggestion(\n+                                                li.span(),\n+                                                \"change it to\",\n+                                                new_lint_name.to_string(),\n+                                                Applicability::MachineApplicable,\n+                                            )\n+                                            .emit();\n                                     },\n                                 );\n \n@@ -326,7 +326,6 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 db.emit();\n                             },\n                         );\n-\n                     }\n                 }\n             }"}, {"sha": "a0ca7ad1860e8625f2086851aea4384c5c8915ce", "filename": "src/librustc_lint/non_ascii_idents.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fnon_ascii_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnon_ascii_idents.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -22,17 +22,13 @@ impl EarlyLintPass for NonAsciiIdents {\n         if name_str.is_ascii() {\n             return;\n         }\n-        cx.struct_span_lint(\n-            NON_ASCII_IDENTS,\n-            ident.span,\n-            |lint| lint.build(\"identifier contains non-ASCII characters\").emit(),\n-        );\n+        cx.struct_span_lint(NON_ASCII_IDENTS, ident.span, |lint| {\n+            lint.build(\"identifier contains non-ASCII characters\").emit()\n+        });\n         if !name_str.chars().all(GeneralSecurityProfile::identifier_allowed) {\n-            cx.struct_span_lint(\n-                UNCOMMON_CODEPOINTS,\n-                ident.span,\n-                |lint| lint.build(\"identifier contains uncommon Unicode codepoints\").emit(),\n-            )\n+            cx.struct_span_lint(UNCOMMON_CODEPOINTS, ident.span, |lint| {\n+                lint.build(\"identifier contains uncommon Unicode codepoints\").emit()\n+            })\n         }\n     }\n }"}, {"sha": "52f29b30f3be967fea97fa94774fc8e5495c365d", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -109,12 +109,14 @@ impl NonCamelCaseTypes {\n         if !is_camel_case(name) {\n             let msg = format!(\"{} `{}` should have an upper camel case name\", sort, name);\n             cx.struct_span_lint(NON_CAMEL_CASE_TYPES, ident.span, |lint| {\n-                lint.build(&msg).span_suggestion(\n-                    ident.span,\n-                    \"convert the identifier to upper camel case\",\n-                    to_camel_case(name),\n-                    Applicability::MaybeIncorrect,\n-                ).emit()\n+                lint.build(&msg)\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"convert the identifier to upper camel case\",\n+                        to_camel_case(name),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit()\n             })\n         }\n     }\n@@ -243,7 +245,6 @@ impl NonSnakeCase {\n \n                 err.emit();\n             });\n-\n         }\n     }\n }\n@@ -394,13 +395,13 @@ impl NonUpperCaseGlobals {\n \n             cx.struct_span_lint(NON_UPPER_CASE_GLOBALS, ident.span, |lint| {\n                 lint.build(&format!(\"{} `{}` should have an upper case name\", sort, name))\n-                .span_suggestion(\n-                    ident.span,\n-                    \"convert the identifier to upper case\",\n-                    uc,\n-                    Applicability::MaybeIncorrect,\n-                )\n-                .emit();\n+                    .span_suggestion(\n+                        ident.span,\n+                        \"convert the identifier to upper case\",\n+                        uc,\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n             })\n         }\n     }"}, {"sha": "71a86592396c9c7147aa2c76508e6688f676f15c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 44, "deletions": 51, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -76,33 +76,29 @@ fn lint_overflowing_range_endpoint<'a, 'tcx>(\n         // (`..=`) instead only if it is the `end` that is\n         // overflowing and only by 1.\n         if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n-            cx.struct_span_lint(\n-                OVERFLOWING_LITERALS,\n-                parent_expr.span,\n-                |lint| {\n-                    let mut err = lint.build(&format!(\"range endpoint is out of range for `{}`\", ty));\n-                    if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n-                        use ast::{LitIntType, LitKind};\n-                        // We need to preserve the literal's suffix,\n-                        // as it may determine typing information.\n-                        let suffix = match lit.node {\n-                            LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n-                            LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n-                            LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n-                            _ => bug!(),\n-                        };\n-                        let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                        err.span_suggestion(\n-                            parent_expr.span,\n-                            &\"use an inclusive range instead\",\n-                            suggestion,\n-                            Applicability::MachineApplicable,\n-                        );\n-                        err.emit();\n-                        overwritten = true;\n-                    }\n-                },\n-            );\n+            cx.struct_span_lint(OVERFLOWING_LITERALS, parent_expr.span, |lint| {\n+                let mut err = lint.build(&format!(\"range endpoint is out of range for `{}`\", ty));\n+                if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                    use ast::{LitIntType, LitKind};\n+                    // We need to preserve the literal's suffix,\n+                    // as it may determine typing information.\n+                    let suffix = match lit.node {\n+                        LitKind::Int(_, LitIntType::Signed(s)) => format!(\"{}\", s.name_str()),\n+                        LitKind::Int(_, LitIntType::Unsigned(s)) => format!(\"{}\", s.name_str()),\n+                        LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_owned(),\n+                        _ => bug!(),\n+                    };\n+                    let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                    err.span_suggestion(\n+                        parent_expr.span,\n+                        &\"use an inclusive range instead\",\n+                        suggestion,\n+                        Applicability::MachineApplicable,\n+                    );\n+                    err.emit();\n+                    overwritten = true;\n+                }\n+            });\n         }\n     }\n     overwritten\n@@ -165,32 +161,29 @@ fn report_bin_hex_error(\n             (t.name_str(), actually.to_string())\n         }\n     };\n-    cx.struct_span_lint(\n-        OVERFLOWING_LITERALS,\n-        expr.span,\n-        |lint| {\n-            let mut err = lint.build(&format!(\"literal out of range for {}\", t));\n-            err.note(&format!(\n-                \"the literal `{}` (decimal `{}`) does not fit into \\\n+    cx.struct_span_lint(OVERFLOWING_LITERALS, expr.span, |lint| {\n+        let mut err = lint.build(&format!(\"literal out of range for {}\", t));\n+        err.note(&format!(\n+            \"the literal `{}` (decimal `{}`) does not fit into \\\n                     an `{}` and will become `{}{}`\",\n-                repr_str, val, t, actually, t\n-            ));\n-            if let Some(sugg_ty) = get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative) {\n-                if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n-                    let (sans_suffix, _) = repr_str.split_at(pos);\n-                    err.span_suggestion(\n-                        expr.span,\n-                        &format!(\"consider using `{}` instead\", sugg_ty),\n-                        format!(\"{}{}\", sans_suffix, sugg_ty),\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n-                }\n+            repr_str, val, t, actually, t\n+        ));\n+        if let Some(sugg_ty) = get_type_suggestion(&cx.tables.node_type(expr.hir_id), val, negative)\n+        {\n+            if let Some(pos) = repr_str.chars().position(|c| c == 'i' || c == 'u') {\n+                let (sans_suffix, _) = repr_str.split_at(pos);\n+                err.span_suggestion(\n+                    expr.span,\n+                    &format!(\"consider using `{}` instead\", sugg_ty),\n+                    format!(\"{}{}\", sans_suffix, sugg_ty),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                err.help(&format!(\"consider using `{}` instead\", sugg_ty));\n             }\n-            err.emit();\n-        },\n-    );\n+        }\n+        err.emit();\n+    });\n }\n \n // This function finds the next fitting type and generates a suggestion string."}, {"sha": "4dae7fbe9413d99915d8a0b4305b711211f432f5", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -379,21 +379,16 @@ fn do_mir_borrowck<'a, 'tcx>(\n         }\n \n         let mut_span = tcx.sess.source_map().span_until_non_whitespace(span);\n-        tcx.struct_span_lint_hir(\n-            UNUSED_MUT,\n-            lint_root,\n-            span,\n-            |lint| {\n-                lint.build(\"variable does not need to be mutable\")\n+        tcx.struct_span_lint_hir(UNUSED_MUT, lint_root, span, |lint| {\n+            lint.build(\"variable does not need to be mutable\")\n                 .span_suggestion_short(\n                     mut_span,\n                     \"remove this `mut`\",\n                     String::new(),\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();\n-            },\n-        )\n+        })\n     }\n \n     // Buffer any move errors that we collected and de-duplicated."}, {"sha": "2e8e4dac237bcfa517cf223b12a0660f47094d09", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -213,9 +213,7 @@ fn validate_and_turn_into_const<'tcx>(\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n         }) {\n-            Ok(_) => {\n-                ErrorHandled::Reported\n-            }\n+            Ok(_) => ErrorHandled::Reported,\n             Err(err) => err,\n         }\n     })"}, {"sha": "08ef60aa58ea5b1591d9d1bd7c00f37ea1041f55", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -624,15 +624,13 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n                         lint_hir_id,\n                         source_info.span,\n                         |lint| {\n-                            lint.build(\n-                                &format!(\n-                                    \"{} is unsafe and requires unsafe function or block (error E0133)\",\n-                                    description\n-                                )\n-                            )\n+                            lint.build(&format!(\n+                                \"{} is unsafe and requires unsafe function or block (error E0133)\",\n+                                description\n+                            ))\n                             .note(&details.as_str())\n                             .emit()\n-                        }\n+                        },\n                     )\n                 }\n             }"}, {"sha": "9a2e2c56f142648b14a20e67912821248613f1f7", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -923,17 +923,24 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                                     | PanicInfo::DivisionByZero\n                                     | PanicInfo::RemainderByZero => msg.description().to_owned(),\n                                     PanicInfo::BoundsCheck { ref len, ref index } => {\n-                                        let len =\n-                                            self.eval_operand(len, source_info).expect(\"len must be const\");\n+                                        let len = self\n+                                            .eval_operand(len, source_info)\n+                                            .expect(\"len must be const\");\n                                         let len = match self.ecx.read_scalar(len) {\n-                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n+                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                                data,\n+                                                ..\n+                                            })) => data,\n                                             other => bug!(\"const len not primitive: {:?}\", other),\n                                         };\n                                         let index = self\n                                             .eval_operand(index, source_info)\n                                             .expect(\"index must be const\");\n                                         let index = match self.ecx.read_scalar(index) {\n-                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw { data, .. })) => data,\n+                                            Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                                data,\n+                                                ..\n+                                            })) => data,\n                                             other => bug!(\"const index not primitive: {:?}\", other),\n                                         };\n                                         format!("}, {"sha": "acb9829ce5f370d4c5bae9018a07725cb12018d8", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 19, "deletions": 23, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -287,30 +287,26 @@ fn check_for_bindings_named_same_as_variants(cx: &MatchVisitor<'_, '_>, pat: &Pa\n                         })\n                     {\n                         let ty_path = cx.tcx.def_path_str(edef.did);\n-                        cx.tcx\n-                            .struct_span_lint_hir(\n-                                BINDINGS_WITH_VARIANT_NAME,\n-                                p.hir_id,\n-                                p.span,\n-                                |lint| {\n-                                    lint\n-                                        .build(\n-                                            &format!(\n-                                                \"pattern binding `{}` is named the same as one \\\n+                        cx.tcx.struct_span_lint_hir(\n+                            BINDINGS_WITH_VARIANT_NAME,\n+                            p.hir_id,\n+                            p.span,\n+                            |lint| {\n+                                lint.build(&format!(\n+                                    \"pattern binding `{}` is named the same as one \\\n                                                 of the variants of the type `{}`\",\n-                                                ident, ty_path\n-                                            )\n-                                        )\n-                                        .code(error_code!(E0170))\n-                                        .span_suggestion(\n-                                            p.span,\n-                                            \"to match on the variant, qualify the path\",\n-                                            format!(\"{}::{}\", ty_path, ident),\n-                                            Applicability::MachineApplicable,\n-                                        )\n-                                        .emit();\n-                                },\n-                            )\n+                                    ident, ty_path\n+                                ))\n+                                .code(error_code!(E0170))\n+                                .span_suggestion(\n+                                    p.span,\n+                                    \"to match on the variant, qualify the path\",\n+                                    format!(\"{}::{}\", ty_path, ident),\n+                                    Applicability::MachineApplicable,\n+                                )\n+                                .emit();\n+                            },\n+                        )\n                     }\n                 }\n             }"}, {"sha": "0017f800de7021ec0b5a2ea52274595c9de08426", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -124,20 +124,15 @@ fn check_fn_for_unconditional_recursion<'tcx>(\n     if !reached_exit_without_self_call && !self_call_locations.is_empty() {\n         let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let sp = tcx.sess.source_map().def_span(tcx.hir().span(hir_id));\n-        tcx.struct_span_lint_hir(\n-            UNCONDITIONAL_RECURSION,\n-            hir_id,\n-            sp,\n-            |lint| {\n-                let mut db = lint.build(\"function cannot return without recursing\");\n-                db.span_label(sp, \"cannot return without recursing\");\n-                // offer some help to the programmer.\n-                for location in &self_call_locations {\n-                    db.span_label(location.span, \"recursive call site\");\n-                }\n-                db.help(\"a `loop` may express intention better if this is on purpose\");\n-                db.emit();\n-            },\n-        );\n+        tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n+            let mut db = lint.build(\"function cannot return without recursing\");\n+            db.span_label(sp, \"cannot return without recursing\");\n+            // offer some help to the programmer.\n+            for location in &self_call_locations {\n+                db.span_label(location.span, \"recursive call site\");\n+            }\n+            db.help(\"a `loop` may express intention better if this is on purpose\");\n+            db.emit();\n+        });\n     }\n }"}, {"sha": "8dec64c579e8883b6b87790e4560a82a2e200161", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -317,9 +317,9 @@ impl<'a> StripUnconfigured<'a> {\n                     Ok(r) => return Some(r),\n                     Err(mut e) => {\n                         e.help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n-                        .note(CFG_ATTR_NOTE_REF)\n-                        .emit();\n-                    },\n+                            .note(CFG_ATTR_NOTE_REF)\n+                            .emit();\n+                    }\n                 }\n             }\n             _ => self.error_malformed_cfg_attr_missing(attr.span),"}, {"sha": "21a738c7f7b188925e544b10e574dfc1eb62f302", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1407,6 +1407,8 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n     *sess.reached_eof.borrow_mut() |=\n         unclosed_delims.iter().any(|unmatched_delim| unmatched_delim.found_delim.is_none());\n     for unmatched in unclosed_delims.drain(..) {\n-        make_unclosed_delims_error(unmatched, sess).map(|mut e| { e.emit(); });\n+        make_unclosed_delims_error(unmatched, sess).map(|mut e| {\n+            e.emit();\n+        });\n     }\n }"}, {"sha": "f5e47608d589de011db842db2aae0621a54de91a", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -27,7 +27,11 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n         _ => {\n             if let MacArgs::Eq(..) = attr.get_normal_item().args {\n                 // All key-value attributes are restricted to meta-item syntax.\n-                parse_meta(sess, attr).map_err(|mut err| { err.emit(); }).ok();\n+                parse_meta(sess, attr)\n+                    .map_err(|mut err| {\n+                        err.emit();\n+                    })\n+                    .ok();\n             }\n         }\n     }\n@@ -152,6 +156,8 @@ pub fn check_builtin_attribute(\n                 }\n             }\n         }\n-        Err(mut err) => { err.emit(); },\n+        Err(mut err) => {\n+            err.emit();\n+        }\n     }\n }"}, {"sha": "fac90525e3234668d810e16f2cd151e36ab8f99b", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -92,13 +92,9 @@ impl CheckAttrVisitor<'tcx> {\n             | Target::Method(MethodKind::Trait { body: true })\n             | Target::Method(MethodKind::Inherent) => true,\n             Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx\n-                    .struct_span_lint_hir(\n-                        UNUSED_ATTRIBUTES,\n-                        hir_id,\n-                        attr.span,\n-                        |lint| lint.build(\"`#[inline]` is ignored on function prototypes\").emit(),\n-                    );\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[inline]` is ignored on function prototypes\").emit()\n+                });\n                 true\n             }\n             // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n@@ -331,17 +327,16 @@ impl CheckAttrVisitor<'tcx> {\n             || (is_simd && is_c)\n             || (int_reprs == 1 && is_c && item.map_or(false, |item| is_c_like_enum(item)))\n         {\n-            self.tcx\n-                .struct_span_lint_hir(\n-                    CONFLICTING_REPR_HINTS,\n-                    hir_id,\n-                    hint_spans.collect::<Vec<Span>>(),\n-                    |lint| {\n-                        lint.build(\"conflicting representation hints\")\n-                            .code(rustc_errors::error_code!(E0566))\n-                            .emit();\n-                    }\n-                );\n+            self.tcx.struct_span_lint_hir(\n+                CONFLICTING_REPR_HINTS,\n+                hir_id,\n+                hint_spans.collect::<Vec<Span>>(),\n+                |lint| {\n+                    lint.build(\"conflicting representation hints\")\n+                        .code(rustc_errors::error_code!(E0566))\n+                        .emit();\n+                },\n+            );\n         }\n     }\n "}, {"sha": "709068d2189378f9d27ac9683ded814fb9bde14e", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1521,18 +1521,16 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if ln == self.s.exit_ln { false } else { self.assigned_on_exit(ln, var).is_some() };\n \n             if is_assigned {\n-                self.ir\n-                    .tcx\n-                    .struct_span_lint_hir(\n-                        lint::builtin::UNUSED_VARIABLES,\n-                        hir_id,\n-                        spans,\n-                        |lint| {\n-                            lint.build(&format!(\"variable `{}` is assigned to, but never used\", name))\n-                                .note(&format!(\"consider using `_{}` instead\", name))\n-                                .emit();\n-                        },\n-                    )\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_VARIABLES,\n+                    hir_id,\n+                    spans,\n+                    |lint| {\n+                        lint.build(&format!(\"variable `{}` is assigned to, but never used\", name))\n+                            .note(&format!(\"consider using `_{}` instead\", name))\n+                            .emit();\n+                    },\n+                )\n             } else {\n                 self.ir.tcx.struct_span_lint_hir(\n                     lint::builtin::UNUSED_VARIABLES,\n@@ -1543,8 +1541,10 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                         if self.ir.variable_is_shorthand(var) {\n                             if let Node::Binding(pat) = self.ir.tcx.hir().get(hir_id) {\n                                 // Handle `ref` and `ref mut`.\n-                                let spans =\n-                                    spans.iter().map(|_span| (pat.span, format!(\"{}: _\", name))).collect();\n+                                let spans = spans\n+                                    .iter()\n+                                    .map(|_span| (pat.span, format!(\"{}: _\", name)))\n+                                    .collect();\n \n                                 err.multipart_suggestion(\n                                     \"try ignoring the field\",\n@@ -1575,31 +1575,27 @@ impl<'tcx> Liveness<'_, 'tcx> {\n     fn report_dead_assign(&self, hir_id: HirId, spans: Vec<Span>, var: Variable, is_param: bool) {\n         if let Some(name) = self.should_warn(var) {\n             if is_param {\n-                self.ir\n-                    .tcx\n-                    .struct_span_lint_hir(\n-                        lint::builtin::UNUSED_ASSIGNMENTS,\n-                        hir_id,\n-                        spans,\n-                        |lint| {\n-                            lint.build(&format!(\"value passed to `{}` is never read\", name))\n-                                .help(\"maybe it is overwritten before being read?\")\n-                                .emit();\n-                        },\n-                    )\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_ASSIGNMENTS,\n+                    hir_id,\n+                    spans,\n+                    |lint| {\n+                        lint.build(&format!(\"value passed to `{}` is never read\", name))\n+                            .help(\"maybe it is overwritten before being read?\")\n+                            .emit();\n+                    },\n+                )\n             } else {\n-                self.ir\n-                    .tcx\n-                    .struct_span_lint_hir(\n-                        lint::builtin::UNUSED_ASSIGNMENTS,\n-                        hir_id,\n-                        spans,\n-                        |lint| {\n-                            lint.build(&format!(\"value assigned to `{}` is never read\", name))\n-                                .help(\"maybe it is overwritten before being read?\")\n-                                .emit();\n-                        },\n-                    )\n+                self.ir.tcx.struct_span_lint_hir(\n+                    lint::builtin::UNUSED_ASSIGNMENTS,\n+                    hir_id,\n+                    spans,\n+                    |lint| {\n+                        lint.build(&format!(\"value assigned to `{}` is never read\", name))\n+                            .help(\"maybe it is overwritten before being read?\")\n+                            .emit();\n+                    },\n+                )\n             }\n         }\n     }"}, {"sha": "4e2085d07a39ad869f2bcb66b08e030827b2eb4f", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -608,10 +608,10 @@ fn unnecessary_stable_feature_lint(tcx: TyCtxt<'_>, span: Span, feature: Symbol,\n         lint.build(&format!(\n             \"the feature `{}` has been stable since {} and no longer requires \\\n                       an attribute to enable\",\n-                feature, since\n-            )).emit();\n-        }\n-    );\n+            feature, since\n+        ))\n+        .emit();\n+    });\n }\n \n fn duplicate_feature_err(sess: &Session, span: Span, feature: Symbol) {"}, {"sha": "7f51bc25642b55f406e1f6d680d4762fcb3b1cf6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1786,15 +1786,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n                 self.item_id,\n                 self.span,\n                 |lint| {\n-                    lint.build(\n-                            &format!(\n-                            \"{} `{}` from private dependency '{}' in public \\\n+                    lint.build(&format!(\n+                        \"{} `{}` from private dependency '{}' in public \\\n                                                 interface\",\n-                            kind,\n-                            descr,\n-                            self.tcx.crate_name(def_id.krate)\n-                            )\n-                    ).emit()\n+                        kind,\n+                        descr,\n+                        self.tcx.crate_name(def_id.krate)\n+                    ))\n+                    .emit()\n                 },\n             );\n         }\n@@ -1818,9 +1817,12 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n                 err.emit();\n             } else {\n                 let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n-                self.tcx.struct_span_lint_hir(lint::builtin::PRIVATE_IN_PUBLIC, hir_id, self.span, |lint| {\n-                    lint.build(&format!(\"{} (error {})\", msg, err_code)).emit()\n-                });\n+                self.tcx.struct_span_lint_hir(\n+                    lint::builtin::PRIVATE_IN_PUBLIC,\n+                    hir_id,\n+                    self.span,\n+                    |lint| lint.build(&format!(\"{} (error {})\", msg, err_code)).emit(),\n+                );\n             }\n         }\n "}, {"sha": "fd4d2c718c094380186f301f0194696499dea890", "filename": "src/librustc_resolve/lifetimes.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_resolve%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_resolve%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flifetimes.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1580,15 +1580,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             id,\n                             span,\n                             |lint| {\n-                                let mut err = lint.build(&format!(\"lifetime parameter `{}` only used once\", name));\n+                                let mut err = lint.build(&format!(\n+                                    \"lifetime parameter `{}` only used once\",\n+                                    name\n+                                ));\n                                 if span == lifetime.span {\n                                     // spans are the same for in-band lifetime declarations\n                                     err.span_label(span, \"this lifetime is only used here\");\n                                 } else {\n                                     err.span_label(span, \"this lifetime...\");\n                                     err.span_label(lifetime.span, \"...is used only here\");\n                                 }\n-                                self.suggest_eliding_single_use_lifetime(&mut err, def_id, lifetime);\n+                                self.suggest_eliding_single_use_lifetime(\n+                                    &mut err, def_id, lifetime,\n+                                );\n                                 err.emit();\n                             },\n                         );\n@@ -1616,10 +1621,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             id,\n                             span,\n                             |lint| {\n-                                let mut err = lint.build(&format!(\"lifetime parameter `{}` never used\", name));\n+                                let mut err = lint\n+                                    .build(&format!(\"lifetime parameter `{}` never used\", name));\n                                 if let Some(parent_def_id) = self.tcx.parent(def_id) {\n-                                    if let Some(generics) = self.tcx.hir().get_generics(parent_def_id) {\n-                                        let unused_lt_span = self.lifetime_deletion_span(name, generics);\n+                                    if let Some(generics) =\n+                                        self.tcx.hir().get_generics(parent_def_id)\n+                                    {\n+                                        let unused_lt_span =\n+                                            self.lifetime_deletion_span(name, generics);\n                                         if let Some(span) = unused_lt_span {\n                                             err.span_suggestion(\n                                                 span,"}, {"sha": "909f40ee98499639825eefffe29f17d0e844f880", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -468,27 +468,20 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         } else {\n             (\"\", lint::builtin::TRIVIAL_CASTS)\n         };\n-        fcx.tcx.struct_span_lint_hir(\n-            lint,\n-            self.expr.hir_id,\n-            self.span,\n-            |err| {\n-                err.build(\n-                    &format!(\n-                        \"trivial {}cast: `{}` as `{}`\",\n-                        adjective,\n-                        fcx.ty_to_string(t_expr),\n-                        fcx.ty_to_string(t_cast)\n-                    )\n-                )\n-                .help(&format!(\n-                    \"cast can be replaced by coercion; this might \\\n+        fcx.tcx.struct_span_lint_hir(lint, self.expr.hir_id, self.span, |err| {\n+            err.build(&format!(\n+                \"trivial {}cast: `{}` as `{}`\",\n+                adjective,\n+                fcx.ty_to_string(t_expr),\n+                fcx.ty_to_string(t_cast)\n+            ))\n+            .help(&format!(\n+                \"cast can be replaced by coercion; this might \\\n                                    require {}a temporary variable\",\n-                    type_asc_or\n-                ))\n-                .emit();\n-            },\n-        );\n+                type_asc_or\n+            ))\n+            .emit();\n+        });\n     }\n \n     pub fn check(mut self, fcx: &FnCtxt<'a, 'tcx>) {"}, {"sha": "760b6487045d85340ed4c160ddea970bcb1cdd5a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1285,7 +1285,9 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             self.fcx.body_id,\n             self.span,\n             |lint| {\n-                let mut diag = lint.build(\"a method with this name may be added to the standard library in the future\");\n+                let mut diag = lint.build(\n+                    \"a method with this name may be added to the standard library in the future\",\n+                );\n                 // FIXME: This should be a `span_suggestion` instead of `help`\n                 // However `self.span` only\n                 // highlights the method name, so we can't use it. Also consider reusing the code from"}, {"sha": "be2052dce3c0b9f3232237f11fca5d3ebda0591c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -2895,17 +2895,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                 debug!(\"warn_if_unreachable: id={:?} span={:?} kind={}\", id, span, kind);\n \n-                self.tcx()\n-                    .struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, |lint| {\n-                        let msg = format!(\"unreachable {}\", kind);\n-                        lint.build(&msg)\n-                            .span_label(span, &msg)\n-                            .span_label(\n-                                orig_span,\n-                                custom_note.unwrap_or(\"any code following this expression is unreachable\"),\n-                            )\n-                            .emit();\n-                    })\n+                self.tcx().struct_span_lint_hir(lint::builtin::UNREACHABLE_CODE, id, span, |lint| {\n+                    let msg = format!(\"unreachable {}\", kind);\n+                    lint.build(&msg)\n+                        .span_label(span, &msg)\n+                        .span_label(\n+                            orig_span,\n+                            custom_note\n+                                .unwrap_or(\"any code following this expression is unreachable\"),\n+                        )\n+                        .emit();\n+                })\n             }\n         }\n     }"}, {"sha": "6471db3efce84ad24087fa7b5990ea47564b206b", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -180,7 +180,6 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n         };\n         let replacement = visibility_qualified(&item.vis, base_replacement);\n         tcx.struct_span_lint_hir(lint, id, extern_crate.span, |lint| {\n-\n             let msg = \"`extern crate` is not idiomatic in the new edition\";\n             let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n "}, {"sha": "1b4f0ffce9c1e9b6a7e461758e516b43147480d4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -1157,9 +1157,10 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n                             param.span,\n                             |lint| {\n                                 lint.build(&format!(\n-                                \"defaults for type parameters are only allowed in \\\n+                                    \"defaults for type parameters are only allowed in \\\n                                         `struct`, `enum`, `type`, or `trait` definitions.\"\n-                                )).emit();\n+                                ))\n+                                .emit();\n                             },\n                         );\n                     }"}, {"sha": "79bcfe7aee7447ee9caffd0eb364b0a1e13e89be", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -676,15 +676,17 @@ fn build_diagnostic(\n         |lint| {\n             let mut diag = lint.build(&format!(\"`[{}]` {}\", path_str, err_msg));\n             if let Some(link_range) = link_range {\n-                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n+                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs)\n+                {\n                     diag.set_span(sp);\n                     diag.span_label(sp, short_err_msg);\n                 } else {\n                     // blah blah blah\\nblah\\nblah [blah] blah blah\\nblah blah\n                     //                       ^     ~~~~\n                     //                       |     link_range\n                     //                       last_new_line_offset\n-                    let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                    let last_new_line_offset =\n+                        dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n                     let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n                     // Print the line containing the `link_range` and manually mark it with '^'s.\n@@ -804,7 +806,8 @@ fn ambiguity_error(\n             let mut diag = lint.build(&msg);\n \n             if let Some(link_range) = link_range {\n-                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs) {\n+                if let Some(sp) = super::source_span_for_markdown_range(cx, dox, &link_range, attrs)\n+                {\n                     diag.set_span(sp);\n                     diag.span_label(sp, \"ambiguous link\");\n \n@@ -851,7 +854,8 @@ fn ambiguity_error(\n                     //                       ^     ~~~~\n                     //                       |     link_range\n                     //                       last_new_line_offset\n-                    let last_new_line_offset = dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n+                    let last_new_line_offset =\n+                        dox[..link_range.start].rfind('\\n').map_or(0, |n| n + 1);\n                     let line = dox[last_new_line_offset..].lines().next().unwrap_or(\"\");\n \n                     // Print the line containing the `link_range` and manually mark it with '^'s.\n@@ -868,7 +872,6 @@ fn ambiguity_error(\n             diag.emit();\n         },\n     );\n-\n }\n \n /// Given an enum variant's res, return the res of its enum and the associated fragment."}, {"sha": "9e48904a47d335616009fb6a87cfa51ad21c475a", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d246385122ffd7dd6cc5c490b7e648f58c2ff7fd/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=d246385122ffd7dd6cc5c490b7e648f58c2ff7fd", "patch": "@@ -342,12 +342,9 @@ pub fn look_for_tests<'tcx>(\n \n     if check_missing_code == true && tests.found_tests == 0 {\n         let sp = span_of_attrs(&item.attrs).unwrap_or(item.source.span());\n-        cx.tcx.struct_span_lint_hir(\n-            lint::builtin::MISSING_DOC_CODE_EXAMPLES,\n-            hir_id,\n-            sp,\n-            |lint| lint.build(\"missing code example in this documentation\").emit(),\n-        );\n+        cx.tcx.struct_span_lint_hir(lint::builtin::MISSING_DOC_CODE_EXAMPLES, hir_id, sp, |lint| {\n+            lint.build(\"missing code example in this documentation\").emit()\n+        });\n     } else if check_missing_code == false\n         && tests.found_tests > 0\n         && !cx.renderinfo.borrow().access_levels.is_public(item.def_id)"}]}