{"sha": "a5214e4330e8186da7b1117119a7dccfc36a2e6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1MjE0ZTQzMzBlODE4NmRhN2IxMTE3MTE5YTdkY2NmYzM2YTJlNmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-26T15:43:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-26T15:43:38Z"}, "message": "Auto merge of #22715 - edwardw:send-sync-audit, r=alexcrichton\n\nIn the process, also replaces two raw mutable pointers with `Unique` to\r\nspell out the ownership semantics.\r\n\r\ncc #22709", "tree": {"sha": "6efcdfb2e9b145b2282e7236fd649c4a4062c09b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6efcdfb2e9b145b2282e7236fd649c4a4062c09b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5214e4330e8186da7b1117119a7dccfc36a2e6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5214e4330e8186da7b1117119a7dccfc36a2e6b", "html_url": "https://github.com/rust-lang/rust/commit/a5214e4330e8186da7b1117119a7dccfc36a2e6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5214e4330e8186da7b1117119a7dccfc36a2e6b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a96d6a9818fe2affc98a187fb1065120458cee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a96d6a9818fe2affc98a187fb1065120458cee9", "html_url": "https://github.com/rust-lang/rust/commit/3a96d6a9818fe2affc98a187fb1065120458cee9"}, {"sha": "68490068e0c6f1c6566d1161b0d54b6babd8b9b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/68490068e0c6f1c6566d1161b0d54b6babd8b9b2", "html_url": "https://github.com/rust-lang/rust/commit/68490068e0c6f1c6566d1161b0d54b6babd8b9b2"}], "stats": {"total": 161, "additions": 131, "deletions": 30}, "files": [{"sha": "4a80d75575e6db431b400987e05bf0b4c4d9d383", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -1085,7 +1085,7 @@ impl<K, V> Node<K, V> {\n                     vals: RawItems::from_slice(self.vals()),\n                     edges: RawItems::from_slice(self.edges()),\n \n-                    ptr: *self.keys as *mut u8,\n+                    ptr: Unique::new(*self.keys as *mut u8),\n                     capacity: self.capacity(),\n                     is_leaf: self.is_leaf()\n                 },\n@@ -1354,11 +1354,14 @@ struct MoveTraversalImpl<K, V> {\n     edges: RawItems<Node<K, V>>,\n \n     // For deallocation when we are done iterating.\n-    ptr: *mut u8,\n+    ptr: Unique<u8>,\n     capacity: usize,\n     is_leaf: bool\n }\n \n+unsafe impl<K: Sync, V: Sync> Sync for MoveTraversalImpl<K, V> {}\n+unsafe impl<K: Send, V: Send> Send for MoveTraversalImpl<K, V> {}\n+\n impl<K, V> TraversalImpl for MoveTraversalImpl<K, V> {\n     type Item = (K, V);\n     type Edge = Node<K, V>;\n@@ -1401,7 +1404,7 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n \n         let (alignment, size) =\n                 calculate_allocation_generic::<K, V>(self.capacity, self.is_leaf);\n-        unsafe { heap::deallocate(self.ptr, size, alignment) };\n+        unsafe { heap::deallocate(*self.ptr, size, alignment) };\n     }\n }\n \n@@ -1425,12 +1428,12 @@ pub enum TraversalItem<K, V, E> {\n /// A traversal over a node's entries and edges\n pub type Traversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n                                                               slice::Iter<'a, V>>,\n-                                                              slice::Iter<'a, Node<K, V>>>>;\n+                                                          slice::Iter<'a, Node<K, V>>>>;\n \n /// A mutable traversal over a node's entries and edges\n pub type MutTraversal<'a, K, V> = AbsTraversal<ElemsAndEdges<Zip<slice::Iter<'a, K>,\n                                                                  slice::IterMut<'a, V>>,\n-                                                                 slice::IterMut<'a, Node<K, V>>>>;\n+                                                             slice::IterMut<'a, Node<K, V>>>>;\n \n /// An owning traversal over a node's entries and edges\n pub type MoveTraversal<K, V> = AbsTraversal<MoveTraversalImpl<K, V>>;"}, {"sha": "9b5fbfc25114c046012f4f7e2e2748c004017146", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -51,8 +51,8 @@ struct Rawlink<T> {\n }\n \n impl<T> Copy for Rawlink<T> {}\n-unsafe impl<T:'static+Send> Send for Rawlink<T> {}\n-unsafe impl<T:Send+Sync> Sync for Rawlink<T> {}\n+unsafe impl<T:Send> Send for Rawlink<T> {}\n+unsafe impl<T:Sync> Sync for Rawlink<T> {}\n \n struct Node<T> {\n     next: Link<T>,"}, {"sha": "e18fa8c3082d103672a27aeb71addb2d0ac6cfad", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -1755,6 +1755,9 @@ pub struct Drain<'a, T:'a> {\n     marker: PhantomData<&'a T>,\n }\n \n+unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n+unsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for Drain<'a, T> {\n     type Item = T;"}, {"sha": "abcc0cef9f1feae7ad86e659f1475133de50a471", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -24,7 +24,6 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n use core::iter::{self, repeat, FromIterator, IntoIterator, RandomAccessIterator};\n-use core::marker;\n use core::mem;\n use core::num::{Int, UnsignedInt};\n use core::ops::{Index, IndexMut};\n@@ -59,12 +58,6 @@ pub struct VecDeque<T> {\n     ptr: Unique<T>,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Send> Send for VecDeque<T> {}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T: Sync> Sync for VecDeque<T> {}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for VecDeque<T> {\n     fn clone(&self) -> VecDeque<T> {\n@@ -545,9 +538,7 @@ impl<T> VecDeque<T> {\n         IterMut {\n             tail: self.tail,\n             head: self.head,\n-            cap: self.cap,\n-            ptr: *self.ptr,\n-            marker: marker::PhantomData,\n+            ring: unsafe { self.buffer_as_mut_slice() },\n         }\n     }\n \n@@ -1515,17 +1506,12 @@ impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     }\n }\n \n-// FIXME This was implemented differently from Iter because of a problem\n-//       with returning the mutable reference. I couldn't find a way to\n-//       make the lifetime checker happy so, but there should be a way.\n /// `VecDeque` mutable iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T:'a> {\n-    ptr: *mut T,\n+    ring: &'a mut [T],\n     tail: usize,\n     head: usize,\n-    cap: usize,\n-    marker: marker::PhantomData<&'a mut T>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1538,16 +1524,17 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             return None;\n         }\n         let tail = self.tail;\n-        self.tail = wrap_index(self.tail + 1, self.cap);\n+        self.tail = wrap_index(self.tail + 1, self.ring.len());\n \n         unsafe {\n-            Some(&mut *self.ptr.offset(tail as isize))\n+            let elem = self.ring.get_unchecked_mut(tail);\n+            Some(&mut *(elem as *mut _))\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let len = count(self.tail, self.head, self.cap);\n+        let len = count(self.tail, self.head, self.ring.len());\n         (len, Some(len))\n     }\n }\n@@ -1559,10 +1546,11 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n         if self.tail == self.head {\n             return None;\n         }\n-        self.head = wrap_index(self.head - 1, self.cap);\n+        self.head = wrap_index(self.head - 1, self.ring.len());\n \n         unsafe {\n-            Some(&mut *self.ptr.offset(self.head as isize))\n+            let elem = self.ring.get_unchecked_mut(self.head);\n+            Some(&mut *(elem as *mut _))\n         }\n     }\n }"}, {"sha": "8f767e62678e6b92788181b23e70542daf15b1cb", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -68,7 +68,7 @@ use num::{ToPrimitive, Int};\n use ops::{Add, Deref, FnMut};\n use option::Option;\n use option::Option::{Some, None};\n-use marker::Sized;\n+use marker::{Send, Sized, Sync};\n use usize;\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n@@ -1786,6 +1786,10 @@ pub struct Peekable<I: Iterator> {\n     peeked: Option<I::Item>,\n }\n \n+// FIXME: after #22828 being fixed, the following unsafe impl should be removed\n+unsafe impl<I: Iterator> Sync for Peekable<I> where I: Sync, I::Item: Sync {}\n+unsafe impl<I: Iterator> Send for Peekable<I> where I: Send, I::Item: Send {}\n+\n impl<I: Iterator + Clone> Clone for Peekable<I> where I::Item: Clone {\n     fn clone(&self) -> Peekable<I> {\n         Peekable {"}, {"sha": "91cad4330f20464441fdf623ee39219dcf81f58c", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -51,7 +51,7 @@ use ptr;\n use ptr::PtrExt;\n use mem;\n use mem::size_of;\n-use marker::{Sized, self};\n+use marker::{Send, Sized, Sync, self};\n use raw::Repr;\n // Avoid conflicts with *both* the Slice trait (buggy) and the `slice::raw` module.\n use raw::Slice as RawSlice;\n@@ -740,6 +740,9 @@ pub struct Iter<'a, T: 'a> {\n     _marker: marker::PhantomData<&'a T>,\n }\n \n+unsafe impl<'a, T: Sync> Sync for Iter<'a, T> {}\n+unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n+\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n@@ -830,6 +833,8 @@ pub struct IterMut<'a, T: 'a> {\n     _marker: marker::PhantomData<&'a mut T>,\n }\n \n+unsafe impl<'a, T: Sync> Sync for IterMut<'a, T> {}\n+unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {"}, {"sha": "6d29d5f2b3e91a80e7a4a8a5311c43cc92e4e068", "filename": "src/test/run-pass/sync-send-iterators-in-libcollections.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5214e4330e8186da7b1117119a7dccfc36a2e6b/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsync-send-iterators-in-libcollections.rs?ref=a5214e4330e8186da7b1117119a7dccfc36a2e6b", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused_mut)]\n+#![feature(collections)]\n+\n+extern crate collections;\n+\n+use collections::BinaryHeap;\n+use collections::{BitSet, BitVec};\n+use collections::{BTreeMap, BTreeSet};\n+use collections::EnumSet;\n+use collections::LinkedList;\n+use collections::Vec;\n+use collections::VecDeque;\n+use collections::VecMap;\n+\n+use collections::Bound::Included;\n+use collections::enum_set::CLike;\n+use std::mem;\n+\n+fn is_sync<T>(_: T) where T: Sync {}\n+fn is_send<T>(_: T) where T: Send {}\n+\n+macro_rules! all_sync_send {\n+    ($ctor:expr, $($iter:ident),+) => ({\n+        $(\n+            let mut x = $ctor;\n+            is_sync(x.$iter());\n+            let mut y = $ctor;\n+            is_send(y.$iter());\n+        )+\n+    })\n+}\n+\n+macro_rules! is_sync_send {\n+    ($ctor:expr, $iter:ident($($param:expr),+)) => ({\n+        let mut x = $ctor;\n+        is_sync(x.$iter($( $param ),+));\n+        let mut y = $ctor;\n+        is_send(y.$iter($( $param ),+));\n+    })\n+}\n+\n+fn main() {\n+    // The iterator \"generator\" list should exhaust what corresponding\n+    // implementations have where `Sync` and `Send` semantics apply.\n+    all_sync_send!(BinaryHeap::<usize>::new(), iter, drain, into_iter);\n+\n+    all_sync_send!(BitVec::new(), iter);\n+\n+    all_sync_send!(BitSet::new(), iter);\n+    is_sync_send!(BitSet::new(), union(&BitSet::new()));\n+    is_sync_send!(BitSet::new(), intersection(&BitSet::new()));\n+    is_sync_send!(BitSet::new(), difference(&BitSet::new()));\n+    is_sync_send!(BitSet::new(), symmetric_difference(&BitSet::new()));\n+\n+    all_sync_send!(BTreeMap::<usize, usize>::new(), iter, iter_mut, into_iter, keys, values);\n+    is_sync_send!(BTreeMap::<usize, usize>::new(), range(Included(&0), Included(&9)));\n+    is_sync_send!(BTreeMap::<usize, usize>::new(), range_mut(Included(&0), Included(&9)));\n+\n+    all_sync_send!(BTreeSet::<usize>::new(), iter, into_iter);\n+    is_sync_send!(BTreeSet::<usize>::new(), range(Included(&0), Included(&9)));\n+    is_sync_send!(BTreeSet::<usize>::new(), difference(&BTreeSet::<usize>::new()));\n+    is_sync_send!(BTreeSet::<usize>::new(), symmetric_difference(&BTreeSet::<usize>::new()));\n+    is_sync_send!(BTreeSet::<usize>::new(), intersection(&BTreeSet::<usize>::new()));\n+    is_sync_send!(BTreeSet::<usize>::new(), union(&BTreeSet::<usize>::new()));\n+\n+    all_sync_send!(LinkedList::<usize>::new(), iter, iter_mut, into_iter);\n+\n+    #[derive(Copy)]\n+    #[repr(usize)]\n+    #[allow(dead_code)]\n+    enum Foo { A, B, C }\n+    impl CLike for Foo {\n+        fn to_usize(&self) -> usize {\n+            *self as usize\n+        }\n+\n+        fn from_usize(v: usize) -> Foo {\n+            unsafe { mem::transmute(v) }\n+        }\n+    }\n+    all_sync_send!(EnumSet::<Foo>::new(), iter);\n+\n+    all_sync_send!(VecDeque::<usize>::new(), iter, iter_mut, drain, into_iter);\n+\n+    all_sync_send!(VecMap::<usize>::new(), iter, iter_mut, drain, into_iter, keys, values);\n+\n+    all_sync_send!(Vec::<usize>::new(), into_iter, drain);\n+}"}]}