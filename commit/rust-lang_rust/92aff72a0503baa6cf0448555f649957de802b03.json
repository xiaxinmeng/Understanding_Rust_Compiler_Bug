{"sha": "92aff72a0503baa6cf0448555f649957de802b03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYWZmNzJhMDUwM2JhYTZjZjA0NDg1NTVmNjQ5OTU3ZGU4MDJiMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-25T22:52:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-25T22:52:16Z"}, "message": "Auto merge of #54575 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #53518 (Add doc for impl From in char_convert)\n - #54058 (Introduce the partition_dedup/by/by_key methods for slices)\n - #54281 (Search box)\n - #54368 (Reduce code block sides padding)\n - #54498 (The project moved under the Mozilla umbrella)\n - #54518 (resolve: Do not block derive helper resolutions on single import resolutions)\n - #54522 (Fixed three small typos.)\n - #54529 (aarch64-pc-windows-msvc: Don't link libpanic_unwind to libtest.)\n - #54537 (Rename slice::exact_chunks() to slice::chunks_exact())\n - #54539 (Fix js error)\n - #54557 (incr.comp.: Don't automatically enable -Zshare-generics for incr. comp. builds.)\n - #54558 (Improvements to finding LLVM's FileCheck)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "7d88f60555c884da79b470c76d1afa299b195f74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d88f60555c884da79b470c76d1afa299b195f74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92aff72a0503baa6cf0448555f649957de802b03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92aff72a0503baa6cf0448555f649957de802b03", "html_url": "https://github.com/rust-lang/rust/commit/92aff72a0503baa6cf0448555f649957de802b03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92aff72a0503baa6cf0448555f649957de802b03/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4141a4079e3e6b2c4ac104fed042a9b7241467eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4141a4079e3e6b2c4ac104fed042a9b7241467eb", "html_url": "https://github.com/rust-lang/rust/commit/4141a4079e3e6b2c4ac104fed042a9b7241467eb"}, {"sha": "cc9dea43be5ab201421b41dbb027f6ba36973cac", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9dea43be5ab201421b41dbb027f6ba36973cac", "html_url": "https://github.com/rust-lang/rust/commit/cc9dea43be5ab201421b41dbb027f6ba36973cac"}], "stats": {"total": 762, "additions": 538, "deletions": 224}, "files": [{"sha": "66eaab236f7c0fcb6b1c94c347cb84e8bdbf357a", "filename": "config.toml.example", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -322,6 +322,7 @@\n \n # Flag indicating whether codegen tests will be run or not. If you get an error\n # saying that the FileCheck executable is missing, you may want to disable this.\n+# Also see the target's llvm-filecheck option.\n #codegen-tests = true\n \n # Flag indicating whether git info will be retrieved from .git automatically.\n@@ -416,6 +417,10 @@\n # target.\n #llvm-config = \"../path/to/llvm/root/bin/llvm-config\"\n \n+# Normally the build system can find LLVM's FileCheck utility, but if\n+# not, you can specify an explicit file name for it.\n+#llvm-filecheck = \"/path/to/FileCheck\"\n+\n # Path to the custom jemalloc static library to link into the standard library\n # by default. This is only used if jemalloc is still enabled above\n #jemalloc = \"/path/to/jemalloc/libjemalloc_pic.a\""}, {"sha": "3a4bc526d03bf3cec35b30bf5f2332f39195aeb7", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -162,6 +162,8 @@ pub struct Config {\n pub struct Target {\n     /// Some(path to llvm-config) if using an external LLVM.\n     pub llvm_config: Option<PathBuf>,\n+    /// Some(path to FileCheck) if one was specified.\n+    pub llvm_filecheck: Option<PathBuf>,\n     pub jemalloc: Option<PathBuf>,\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n@@ -330,6 +332,7 @@ struct Rust {\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct TomlTarget {\n     llvm_config: Option<String>,\n+    llvm_filecheck: Option<String>,\n     jemalloc: Option<String>,\n     cc: Option<String>,\n     cxx: Option<String>,\n@@ -583,6 +586,9 @@ impl Config {\n                 if let Some(ref s) = cfg.llvm_config {\n                     target.llvm_config = Some(config.src.join(s));\n                 }\n+                if let Some(ref s) = cfg.llvm_filecheck {\n+                    target.llvm_filecheck = Some(config.src.join(s));\n+                }\n                 if let Some(ref s) = cfg.jemalloc {\n                     target.jemalloc = Some(config.src.join(s));\n                 }"}, {"sha": "75831dbe262aea95feede7674be3c85e5b227a00", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -95,6 +95,8 @@ def v(*args):\n v(\"bindir\", \"install.bindir\", \"install binaries\")\n \n v(\"llvm-root\", None, \"set LLVM root\")\n+v(\"llvm-config\", None, \"set path to llvm-config\")\n+v(\"llvm-filecheck\", None, \"set path to LLVM's FileCheck utility\")\n v(\"python\", \"build.python\", \"set path to python\")\n v(\"jemalloc-root\", None, \"set directory where libjemalloc_pic.a is located\")\n v(\"android-cross-path\", \"target.arm-linux-androideabi.android-ndk\",\n@@ -323,6 +325,10 @@ def set(key, value):\n         set('build.cargo', value + '/bin/cargo')\n     elif option.name == 'llvm-root':\n         set('target.{}.llvm-config'.format(build()), value + '/bin/llvm-config')\n+    elif option.name == 'llvm-config':\n+        set('target.{}.llvm-config'.format(build()), value)\n+    elif option.name == 'llvm-filecheck':\n+        set('target.{}.llvm-filecheck'.format(build()), value)\n     elif option.name == 'jemalloc-root':\n         set('target.{}.jemalloc'.format(build()), value + '/libjemalloc_pic.a')\n     elif option.name == 'tools':"}, {"sha": "75c18cd2dd41c81ac8041ce97a29524a4a5b36f5", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -641,9 +641,28 @@ impl Build {\n     /// Returns the path to `FileCheck` binary for the specified target\n     fn llvm_filecheck(&self, target: Interned<String>) -> PathBuf {\n         let target_config = self.config.target_config.get(&target);\n-        if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n+        if let Some(s) = target_config.and_then(|c| c.llvm_filecheck.as_ref()) {\n+            s.to_path_buf()\n+        } else if let Some(s) = target_config.and_then(|c| c.llvm_config.as_ref()) {\n             let llvm_bindir = output(Command::new(s).arg(\"--bindir\"));\n-            Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target))\n+            let filecheck = Path::new(llvm_bindir.trim()).join(exe(\"FileCheck\", &*target));\n+            if filecheck.exists() {\n+                filecheck\n+            } else {\n+                // On Fedora the system LLVM installs FileCheck in the\n+                // llvm subdirectory of the libdir.\n+                let llvm_libdir = output(Command::new(s).arg(\"--libdir\"));\n+                let lib_filecheck = Path::new(llvm_libdir.trim())\n+                    .join(\"llvm\").join(exe(\"FileCheck\", &*target));\n+                if lib_filecheck.exists() {\n+                    lib_filecheck\n+                } else {\n+                    // Return the most normal file name, even though\n+                    // it doesn't exist, so that any error message\n+                    // refers to that.\n+                    filecheck\n+                }\n+            }\n         } else {\n             let base = self.llvm_out(self.config.build).join(\"build\");\n             let base = if !self.config.ninja && self.config.build.contains(\"msvc\") {"}, {"sha": "33ee76739c5b2c0ea7f0a55691fbcf7e3682971a", "filename": "src/doc/index.md", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -4,6 +4,23 @@\n nav {\n     display: none;\n }\n+#search-input {\n+    width: calc(100% - 58px);\n+}\n+#search-but {\n+    cursor: pointer;\n+}\n+#search-but, #search-input {\n+    padding: 4px;\n+    border: 1px solid #ccc;\n+    border-radius: 3px;\n+    outline: none;\n+    font-size: 0.7em;\n+    background-color: #fff;\n+}\n+#search-but:hover, #search-input:focus {\n+    border-color: #55a9ff;\n+}\n </style>\n \n Welcome to an overview of the documentation provided by the Rust project.\n@@ -45,8 +62,9 @@ accomplishing various tasks.\n \n <div>\n   <form action=\"std/index.html\" method=\"get\">\n-    <input type=\"search\" name=\"search\"/>\n-    <button>Search</button>\n+    <input id=\"search-input\" type=\"search\" name=\"search\"\n+           placeholder=\"Search through the standard library\"/>\n+    <button id=\"search-but\">Search</button>\n   </form>\n </div>\n "}, {"sha": "452aca51532c96da55dc58e5b649122aa1c3cb01", "filename": "src/doc/unstable-book/src/compiler-flags/profile.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fprofile.md?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -18,4 +18,4 @@ cargo run\n ```\n \n Once you've built and run your program, files with the `gcno` (after build) and `gcda` (after execution) extensions will be created.\n-You can parse them with [llvm-cov gcov](http://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/marco-c/grcov).\n+You can parse them with [llvm-cov gcov](https://llvm.org/docs/CommandGuide/llvm-cov.html#llvm-cov-gcov) or [grcov](https://github.com/mozilla/grcov)."}, {"sha": "7960936dad6bfd385da503ba556e9e852bd96539", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -116,9 +116,10 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n-#![feature(exact_chunks)]\n+#![feature(chunks_exact)]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n+#![feature(slice_partition_dedup)]\n #![feature(maybe_uninit)]\n \n // Allow testing this library"}, {"sha": "33d28bef2d707fb618d9b50091ee14e5660cf58d", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -123,8 +123,8 @@ pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n pub use core::slice::{from_ref, from_mut};\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-pub use core::slice::{ExactChunks, ExactChunksMut};\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+pub use core::slice::{ChunksExact, ChunksExactMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods"}, {"sha": "6ff39227555fe179872fd8597071228679b73885", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -20,7 +20,7 @@\n #![feature(str_escape)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(exact_chunks)]\n+#![feature(chunks_exact)]\n #![feature(repeat_generic_slice)]\n \n extern crate alloc_system;"}, {"sha": "c214c59618d3eb06d07849902fa1f23af16ca051", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -975,27 +975,27 @@ fn test_chunksator_0() {\n }\n \n #[test]\n-fn test_exact_chunksator() {\n+fn test_chunks_exactator() {\n     let v = &[1, 2, 3, 4, 5];\n \n-    assert_eq!(v.exact_chunks(2).len(), 2);\n+    assert_eq!(v.chunks_exact(2).len(), 2);\n \n     let chunks: &[&[_]] = &[&[1, 2], &[3, 4]];\n-    assert_eq!(v.exact_chunks(2).collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(2).collect::<Vec<_>>(), chunks);\n     let chunks: &[&[_]] = &[&[1, 2, 3]];\n-    assert_eq!(v.exact_chunks(3).collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(3).collect::<Vec<_>>(), chunks);\n     let chunks: &[&[_]] = &[];\n-    assert_eq!(v.exact_chunks(6).collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(6).collect::<Vec<_>>(), chunks);\n \n     let chunks: &[&[_]] = &[&[3, 4], &[1, 2]];\n-    assert_eq!(v.exact_chunks(2).rev().collect::<Vec<_>>(), chunks);\n+    assert_eq!(v.chunks_exact(2).rev().collect::<Vec<_>>(), chunks);\n }\n \n #[test]\n #[should_panic]\n-fn test_exact_chunksator_0() {\n+fn test_chunks_exactator_0() {\n     let v = &[1, 2, 3, 4];\n-    let _it = v.exact_chunks(0);\n+    let _it = v.chunks_exact(0);\n }\n \n #[test]\n@@ -1235,10 +1235,10 @@ fn test_mut_chunks_0() {\n }\n \n #[test]\n-fn test_mut_exact_chunks() {\n+fn test_mut_chunks_exact() {\n     let mut v = [0, 1, 2, 3, 4, 5, 6];\n-    assert_eq!(v.exact_chunks_mut(2).len(), 3);\n-    for (i, chunk) in v.exact_chunks_mut(3).enumerate() {\n+    assert_eq!(v.chunks_exact_mut(2).len(), 3);\n+    for (i, chunk) in v.chunks_exact_mut(3).enumerate() {\n         for x in chunk {\n             *x = i as u8;\n         }\n@@ -1248,9 +1248,9 @@ fn test_mut_exact_chunks() {\n }\n \n #[test]\n-fn test_mut_exact_chunks_rev() {\n+fn test_mut_chunks_exact_rev() {\n     let mut v = [0, 1, 2, 3, 4, 5, 6];\n-    for (i, chunk) in v.exact_chunks_mut(3).rev().enumerate() {\n+    for (i, chunk) in v.chunks_exact_mut(3).rev().enumerate() {\n         for x in chunk {\n             *x = i as u8;\n         }\n@@ -1261,9 +1261,9 @@ fn test_mut_exact_chunks_rev() {\n \n #[test]\n #[should_panic]\n-fn test_mut_exact_chunks_0() {\n+fn test_mut_chunks_exact_0() {\n     let mut v = [1, 2, 3, 4];\n-    let _it = v.exact_chunks_mut(0);\n+    let _it = v.chunks_exact_mut(0);\n }\n \n #[test]"}, {"sha": "e845438c0a836972d56a39c72cd7f897e6a1e626", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 11, "deletions": 89, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -947,10 +947,9 @@ impl<T> Vec<T> {\n     /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n     /// relation.\n     ///\n-    /// The `same_bucket` function is passed references to two elements from the vector, and\n-    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n-    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n-    /// `true`, `a` is removed.\n+    /// The `same_bucket` function is passed references to two elements from the vector and\n+    /// must determine if the elements compare equal. The elements are passed in opposite order\n+    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is removed.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///\n@@ -964,90 +963,12 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n     #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n-    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln <= 1 {\n-                return;\n-            }\n-\n-            // Avoid bounds checks by using raw pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r: usize = 1;\n-            let mut w: usize = 1;\n-\n-            while r < ln {\n-                let p_r = p.add(r);\n-                let p_wm1 = p.add(w - 1);\n-                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+    pub fn dedup_by<F>(&mut self, same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+        let len = {\n+            let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n+            dedup.len()\n+        };\n+        self.truncate(len);\n     }\n \n     /// Appends an element to the back of a collection.\n@@ -1533,7 +1454,8 @@ impl<'a> Drop for SetLenOnDrop<'a> {\n }\n \n impl<T: PartialEq> Vec<T> {\n-    /// Removes consecutive repeated elements in the vector.\n+    /// Removes consecutive repeated elements in the vector according to the\n+    /// [`PartialEq`] trait implementation.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///"}, {"sha": "e9ccdd0ea3c578ee0fdbb6fa820cb50e9f70efb9", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -115,6 +115,19 @@ pub unsafe fn from_u32_unchecked(i: u32) -> char {\n \n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n impl From<char> for u32 {\n+    /// Converts a [`char`] into a [`u32`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::mem;\n+    ///\n+    /// fn main() {\n+    ///     let c = 'c';\n+    ///     let u = u32::from(c);\n+    ///     assert!(4 == mem::size_of_val(&u))\n+    /// }\n+    /// ```\n     #[inline]\n     fn from(c: char) -> Self {\n         c as u32\n@@ -141,6 +154,19 @@ impl From<char> for u32 {\n /// C0 and C1 control codes.\n #[stable(feature = \"char_convert\", since = \"1.13.0\")]\n impl From<u8> for char {\n+    /// Converts a [`u8`] into a [`char`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::mem;\n+    ///\n+    /// fn main() {\n+    ///     let u = 32 as u8;\n+    ///     let c = char::from(u);\n+    ///     assert!(4 == mem::size_of_val(&c))\n+    /// }\n+    /// ```\n     #[inline]\n     fn from(i: u8) -> Self {\n         i as char"}, {"sha": "05027bbe8989028af69162d5eb3b64891082cbea", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 224, "deletions": 52, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -624,7 +624,7 @@ impl<T> [T] {\n     /// not divide the length of the slice, then the last chunk will\n     /// not have length `chunk_size`.\n     ///\n-    /// See [`exact_chunks`] for a variant of this iterator that returns chunks\n+    /// See [`chunks_exact`] for a variant of this iterator that returns chunks\n     /// of always exactly `chunk_size` elements.\n     ///\n     /// # Panics\n@@ -642,7 +642,7 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// [`exact_chunks`]: #method.exact_chunks\n+    /// [`chunks_exact`]: #method.chunks_exact\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks(&self, chunk_size: usize) -> Chunks<T> {\n@@ -655,7 +655,7 @@ impl<T> [T] {\n     /// not divide the length of the slice, then the last chunk will not\n     /// have length `chunk_size`.\n     ///\n-    /// See [`exact_chunks_mut`] for a variant of this iterator that returns chunks\n+    /// See [`chunks_exact_mut`] for a variant of this iterator that returns chunks\n     /// of always exactly `chunk_size` elements.\n     ///\n     /// # Panics\n@@ -677,7 +677,7 @@ impl<T> [T] {\n     /// assert_eq!(v, &[1, 1, 2, 2, 3]);\n     /// ```\n     ///\n-    /// [`exact_chunks_mut`]: #method.exact_chunks_mut\n+    /// [`chunks_exact_mut`]: #method.chunks_exact_mut\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n@@ -702,24 +702,24 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(exact_chunks)]\n+    /// #![feature(chunks_exact)]\n     ///\n     /// let slice = ['l', 'o', 'r', 'e', 'm'];\n-    /// let mut iter = slice.exact_chunks(2);\n+    /// let mut iter = slice.chunks_exact(2);\n     /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n     /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n     /// [`chunks`]: #method.chunks\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n     #[inline]\n-    pub fn exact_chunks(&self, chunk_size: usize) -> ExactChunks<T> {\n+    pub fn chunks_exact(&self, chunk_size: usize) -> ChunksExact<T> {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at(len);\n-        ExactChunks { v: fst, rem: snd, chunk_size }\n+        ChunksExact { v: fst, rem: snd, chunk_size }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time.\n@@ -739,12 +739,12 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(exact_chunks)]\n+    /// #![feature(chunks_exact)]\n     ///\n     /// let v = &mut [0, 0, 0, 0, 0];\n     /// let mut count = 1;\n     ///\n-    /// for chunk in v.exact_chunks_mut(2) {\n+    /// for chunk in v.chunks_exact_mut(2) {\n     ///     for elem in chunk.iter_mut() {\n     ///         *elem += count;\n     ///     }\n@@ -754,14 +754,14 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [`chunks_mut`]: #method.chunks_mut\n-    #[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n+    #[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n     #[inline]\n-    pub fn exact_chunks_mut(&mut self, chunk_size: usize) -> ExactChunksMut<T> {\n+    pub fn chunks_exact_mut(&mut self, chunk_size: usize) -> ChunksExactMut<T> {\n         assert!(chunk_size != 0);\n         let rem = self.len() % chunk_size;\n         let len = self.len() - rem;\n         let (fst, snd) = self.split_at_mut(len);\n-        ExactChunksMut { v: fst, rem: snd, chunk_size }\n+        ChunksExactMut { v: fst, rem: snd, chunk_size }\n     }\n \n     /// Divides one slice into two at an index.\n@@ -1402,6 +1402,178 @@ impl<T> [T] {\n         sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Moves all consecutive repeated elements to the end of the slice according to the\n+    /// [`PartialEq`] trait implementation.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup();\n+    ///\n+    /// assert_eq!(dedup, [1, 2, 3, 2, 1]);\n+    /// assert_eq!(duplicates, [2, 3, 1]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup(&mut self) -> (&mut [T], &mut [T])\n+        where T: PartialEq\n+    {\n+        self.partition_dedup_by(|a, b| a == b)\n+    }\n+\n+    /// Moves all but the first of consecutive elements to the end of the slice satisfying\n+    /// a given equality relation.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// The `same_bucket` function is passed references to two elements from the slice and\n+    /// must determine if the elements compare equal. The elements are passed in opposite order\n+    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is moved\n+    /// at the end of the slice.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+    ///\n+    /// assert_eq!(dedup, [\"foo\", \"BAZ\", \"Bar\", \"baz\"]);\n+    /// assert_eq!(duplicates, [\"bar\", \"Foo\", \"BAZ\"]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n+        where F: FnMut(&mut T, &mut T) -> bool\n+    {\n+        // Although we have a mutable reference to `self`, we cannot make\n+        // *arbitrary* changes. The `same_bucket` calls could panic, so we\n+        // must ensure that the slice is in a valid state at all times.\n+        //\n+        // The way that we handle this is by using swaps; we iterate\n+        // over all the elements, swapping as we go so that at the end\n+        // the elements we wish to keep are in the front, and those we\n+        // wish to reject are at the back. We can then split the slice.\n+        // This operation is still O(n).\n+        //\n+        // Example: We start in this state, where `r` represents \"next\n+        // read\" and `w` represents \"next_write`.\n+        //\n+        //           r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //           w\n+        //\n+        // Comparing self[r] against self[w-1], this is not a duplicate, so\n+        // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+        // r and w, leaving us with:\n+        //\n+        //               r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //               w\n+        //\n+        // Comparing self[r] against self[w-1], this value is a duplicate,\n+        // so we increment `r` but leave everything else unchanged:\n+        //\n+        //                   r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //               w\n+        //\n+        // Comparing self[r] against self[w-1], this is not a duplicate,\n+        // so swap self[r] and self[w] and advance r and w:\n+        //\n+        //                       r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //                   w\n+        //\n+        // Not a duplicate, repeat:\n+        //\n+        //                           r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //                       w\n+        //\n+        // Duplicate, advance r. End of slice. Split at w.\n+\n+        let len = self.len();\n+        if len <= 1 {\n+            return (self, &mut [])\n+        }\n+\n+        let ptr = self.as_mut_ptr();\n+        let mut next_read: usize = 1;\n+        let mut next_write: usize = 1;\n+\n+        unsafe {\n+            // Avoid bounds checks by using raw pointers.\n+            while next_read < len {\n+                let ptr_read = ptr.add(next_read);\n+                let prev_ptr_write = ptr.add(next_write - 1);\n+                if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n+                    if next_read != next_write {\n+                        let ptr_write = prev_ptr_write.offset(1);\n+                        mem::swap(&mut *ptr_read, &mut *ptr_write);\n+                    }\n+                    next_write += 1;\n+                }\n+                next_read += 1;\n+            }\n+        }\n+\n+        self.split_at_mut(next_write)\n+    }\n+\n+    /// Moves all but the first of consecutive elements to the end of the slice that resolve\n+    /// to the same key.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);\n+    ///\n+    /// assert_eq!(dedup, [10, 20, 30, 20, 11]);\n+    /// assert_eq!(duplicates, [21, 30, 13]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup_by_key<K, F>(&mut self, mut key: F) -> (&mut [T], &mut [T])\n+        where F: FnMut(&mut T) -> K,\n+              K: PartialEq,\n+    {\n+        self.partition_dedup_by(|a, b| key(a) == key(b))\n+    }\n+\n     /// Rotates the slice in-place such that the first `mid` elements of the\n     /// slice move to the end while the last `self.len() - mid` elements move to\n     /// the front. After calling `rotate_left`, the element previously at index\n@@ -3657,21 +3829,21 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksMut<'a, T> {\n /// up to `chunk_size-1` elements will be omitted but can be retrieved from\n /// the [`remainder`] function from the iterator.\n ///\n-/// This struct is created by the [`exact_chunks`] method on [slices].\n+/// This struct is created by the [`chunks_exact`] method on [slices].\n ///\n-/// [`exact_chunks`]: ../../std/primitive.slice.html#method.exact_chunks\n-/// [`remainder`]: ../../std/slice/struct.ExactChunks.html#method.remainder\n+/// [`chunks_exact`]: ../../std/primitive.slice.html#method.chunks_exact\n+/// [`remainder`]: ../../std/slice/struct.ChunksExact.html#method.remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-pub struct ExactChunks<'a, T:'a> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+pub struct ChunksExact<'a, T:'a> {\n     v: &'a [T],\n     rem: &'a [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> ExactChunks<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> ChunksExact<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -3681,19 +3853,19 @@ impl<'a, T> ExactChunks<'a, T> {\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> Clone for ExactChunks<'a, T> {\n-    fn clone(&self) -> ExactChunks<'a, T> {\n-        ExactChunks {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> Clone for ChunksExact<'a, T> {\n+    fn clone(&self) -> ChunksExact<'a, T> {\n+        ChunksExact {\n             v: self.v,\n             rem: self.rem,\n             chunk_size: self.chunk_size,\n         }\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> Iterator for ExactChunks<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> Iterator for ChunksExact<'a, T> {\n     type Item = &'a [T];\n \n     #[inline]\n@@ -3737,8 +3909,8 @@ impl<'a, T> Iterator for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ChunksExact<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.v.len() < self.chunk_size {\n@@ -3751,21 +3923,21 @@ impl<'a, T> DoubleEndedIterator for ExactChunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> ExactSizeIterator for ExactChunks<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ChunksExact<'a, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n     }\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, T> TrustedLen for ExactChunks<'a, T> {}\n+unsafe impl<'a, T> TrustedLen for ChunksExact<'a, T> {}\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> FusedIterator for ExactChunks<'a, T> {}\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> FusedIterator for ChunksExact<'a, T> {}\n \n #[doc(hidden)]\n-unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n+unsafe impl<'a, T> TrustedRandomAccess for ChunksExact<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T] {\n         let start = i * self.chunk_size;\n         from_raw_parts(self.v.as_ptr().add(start), self.chunk_size)\n@@ -3780,21 +3952,21 @@ unsafe impl<'a, T> TrustedRandomAccess for ExactChunks<'a, T> {\n /// `chunk_size-1` elements will be omitted but can be retrieved from the\n /// [`into_remainder`] function from the iterator.\n ///\n-/// This struct is created by the [`exact_chunks_mut`] method on [slices].\n+/// This struct is created by the [`chunks_exact_mut`] method on [slices].\n ///\n-/// [`exact_chunks_mut`]: ../../std/primitive.slice.html#method.exact_chunks_mut\n-/// [`into_remainder`]: ../../std/slice/struct.ExactChunksMut.html#method.into_remainder\n+/// [`chunks_exact_mut`]: ../../std/primitive.slice.html#method.chunks_exact_mut\n+/// [`into_remainder`]: ../../std/slice/struct.ChunksExactMut.html#method.into_remainder\n /// [slices]: ../../std/primitive.slice.html\n #[derive(Debug)]\n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-pub struct ExactChunksMut<'a, T:'a> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+pub struct ChunksExactMut<'a, T:'a> {\n     v: &'a mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> ExactChunksMut<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> ChunksExactMut<'a, T> {\n     /// Return the remainder of the original slice that is not going to be\n     /// returned by the iterator. The returned slice has at most `chunk_size-1`\n     /// elements.\n@@ -3803,8 +3975,8 @@ impl<'a, T> ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n     type Item = &'a mut [T];\n \n     #[inline]\n@@ -3850,8 +4022,8 @@ impl<'a, T> Iterator for ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.v.len() < self.chunk_size {\n@@ -3866,21 +4038,21 @@ impl<'a, T> DoubleEndedIterator for ExactChunksMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> ExactSizeIterator for ExactChunksMut<'a, T> {\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> ExactSizeIterator for ChunksExactMut<'a, T> {\n     fn is_empty(&self) -> bool {\n         self.v.is_empty()\n     }\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, T> TrustedLen for ExactChunksMut<'a, T> {}\n+unsafe impl<'a, T> TrustedLen for ChunksExactMut<'a, T> {}\n \n-#[unstable(feature = \"exact_chunks\", issue = \"47115\")]\n-impl<'a, T> FusedIterator for ExactChunksMut<'a, T> {}\n+#[unstable(feature = \"chunks_exact\", issue = \"47115\")]\n+impl<'a, T> FusedIterator for ChunksExactMut<'a, T> {}\n \n #[doc(hidden)]\n-unsafe impl<'a, T> TrustedRandomAccess for ExactChunksMut<'a, T> {\n+unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a mut [T] {\n         let start = i * self.chunk_size;\n         from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size)"}, {"sha": "e034ff80593490a5e68d89643f4c1bb2b2fe3e91", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -33,12 +33,13 @@\n #![feature(trusted_len)]\n #![feature(try_from)]\n #![feature(try_trait)]\n-#![feature(exact_chunks)]\n+#![feature(chunks_exact)]\n #![feature(align_offset)]\n #![feature(reverse_bits)]\n #![feature(inner_deref)]\n #![feature(slice_internals)]\n #![feature(option_replace)]\n+#![feature(slice_partition_dedup)]\n #![feature(copy_within)]\n \n extern crate core;"}, {"sha": "de49a7bed395c36a224ecd62bc5d1fef35954ccd", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 88, "deletions": 29, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -221,115 +221,115 @@ fn test_chunks_mut_zip() {\n }\n \n #[test]\n-fn test_exact_chunks_count() {\n+fn test_chunks_exact_count() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks(3);\n+    let c = v.chunks_exact(3);\n     assert_eq!(c.count(), 2);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks(2);\n+    let c2 = v2.chunks_exact(2);\n     assert_eq!(c2.count(), 2);\n \n     let v3: &[i32] = &[];\n-    let c3 = v3.exact_chunks(2);\n+    let c3 = v3.chunks_exact(2);\n     assert_eq!(c3.count(), 0);\n }\n \n #[test]\n-fn test_exact_chunks_nth() {\n+fn test_chunks_exact_nth() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    let mut c = v.exact_chunks(2);\n+    let mut c = v.chunks_exact(2);\n     assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n     assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4, 5, 6];\n-    let mut c2 = v2.exact_chunks(3);\n+    let mut c2 = v2.chunks_exact(3);\n     assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n     assert_eq!(c2.next(), None);\n }\n \n #[test]\n-fn test_exact_chunks_last() {\n+fn test_chunks_exact_last() {\n     let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks(2);\n+    let c = v.chunks_exact(2);\n     assert_eq!(c.last().unwrap(), &[4, 5]);\n \n     let v2: &[i32] = &[0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks(2);\n+    let c2 = v2.chunks_exact(2);\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n #[test]\n-fn test_exact_chunks_remainder() {\n+fn test_chunks_exact_remainder() {\n     let v: &[i32] = &[0, 1, 2, 3, 4];\n-    let c = v.exact_chunks(2);\n+    let c = v.chunks_exact(2);\n     assert_eq!(c.remainder(), &[4]);\n }\n \n #[test]\n-fn test_exact_chunks_zip() {\n+fn test_chunks_exact_zip() {\n     let v1: &[i32] = &[0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    let res = v1.exact_chunks(2)\n-        .zip(v2.exact_chunks(2))\n+    let res = v1.chunks_exact(2)\n+        .zip(v2.chunks_exact(2))\n         .map(|(a, b)| a.iter().sum::<i32>() + b.iter().sum::<i32>())\n         .collect::<Vec<_>>();\n     assert_eq!(res, vec![14, 22]);\n }\n \n #[test]\n-fn test_exact_chunks_mut_count() {\n+fn test_chunks_exact_mut_count() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks_mut(3);\n+    let c = v.chunks_exact_mut(3);\n     assert_eq!(c.count(), 2);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks_mut(2);\n+    let c2 = v2.chunks_exact_mut(2);\n     assert_eq!(c2.count(), 2);\n \n     let v3: &mut [i32] = &mut [];\n-    let c3 = v3.exact_chunks_mut(2);\n+    let c3 = v3.chunks_exact_mut(2);\n     assert_eq!(c3.count(), 0);\n }\n \n #[test]\n-fn test_exact_chunks_mut_nth() {\n+fn test_chunks_exact_mut_nth() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    let mut c = v.exact_chunks_mut(2);\n+    let mut c = v.chunks_exact_mut(2);\n     assert_eq!(c.nth(1).unwrap(), &[2, 3]);\n     assert_eq!(c.next().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4, 5, 6];\n-    let mut c2 = v2.exact_chunks_mut(3);\n+    let mut c2 = v2.chunks_exact_mut(3);\n     assert_eq!(c2.nth(1).unwrap(), &[3, 4, 5]);\n     assert_eq!(c2.next(), None);\n }\n \n #[test]\n-fn test_exact_chunks_mut_last() {\n+fn test_chunks_exact_mut_last() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n-    let c = v.exact_chunks_mut(2);\n+    let c = v.chunks_exact_mut(2);\n     assert_eq!(c.last().unwrap(), &[4, 5]);\n \n     let v2: &mut [i32] = &mut [0, 1, 2, 3, 4];\n-    let c2 = v2.exact_chunks_mut(2);\n+    let c2 = v2.chunks_exact_mut(2);\n     assert_eq!(c2.last().unwrap(), &[2, 3]);\n }\n \n #[test]\n-fn test_exact_chunks_mut_remainder() {\n+fn test_chunks_exact_mut_remainder() {\n     let v: &mut [i32] = &mut [0, 1, 2, 3, 4];\n-    let c = v.exact_chunks_mut(2);\n+    let c = v.chunks_exact_mut(2);\n     assert_eq!(c.into_remainder(), &[4]);\n }\n \n #[test]\n-fn test_exact_chunks_mut_zip() {\n+fn test_chunks_exact_mut_zip() {\n     let v1: &mut [i32] = &mut [0, 1, 2, 3, 4];\n     let v2: &[i32] = &[6, 7, 8, 9, 10];\n \n-    for (a, b) in v1.exact_chunks_mut(2).zip(v2.exact_chunks(2)) {\n+    for (a, b) in v1.chunks_exact_mut(2).zip(v2.chunks_exact(2)) {\n         let sum = b.iter().sum::<i32>();\n         for v in a {\n             *v += sum;\n@@ -1001,6 +1001,65 @@ fn test_align_to_empty_mid() {\n     }\n }\n \n+#[test]\n+fn test_slice_partition_dedup_by() {\n+    let mut slice: [i32; 9] = [1, -1, 2, 3, 1, -5, 5, -2, 2];\n+\n+    let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.abs() == b.abs());\n+\n+    assert_eq!(dedup, [1, 2, 3, 1, -5, -2]);\n+    assert_eq!(duplicates, [5, -1, 2]);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_empty() {\n+    let mut slice: [i32; 0] = [];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, []);\n+    assert_eq!(duplicates, []);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_one() {\n+    let mut slice = [12];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [12]);\n+    assert_eq!(duplicates, []);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_multiple_ident() {\n+    let mut slice = [12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [12, 11]);\n+    assert_eq!(duplicates, [12, 12, 12, 12, 11, 11, 11, 11, 11]);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_partialeq() {\n+    #[derive(Debug)]\n+    struct Foo(i32, i32);\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, other: &Foo) -> bool {\n+            self.0 == other.0\n+        }\n+    }\n+\n+    let mut slice = [Foo(0, 1), Foo(0, 5), Foo(1, 7), Foo(1, 9)];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [Foo(0, 1), Foo(1, 7)]);\n+    assert_eq!(duplicates, [Foo(0, 5), Foo(1, 9)]);\n+}\n+\n #[test]\n fn test_copy_within() {\n     // Start to end, with a RangeTo."}, {"sha": "8fa15d48a5dc9692f3fdfa38b71f9f34d8ae4814", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -646,7 +646,6 @@ impl Options {\n         match self.debugging_opts.share_generics {\n             Some(setting) => setting,\n             None => {\n-                self.incremental.is_some() ||\n                 match self.optimize {\n                     OptLevel::No   |\n                     OptLevel::Less |"}, {"sha": "89bc2f2709a3cf2284ea6c9faa2e0b3f64590878", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -575,6 +575,13 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // 5. Standard library prelude (de-facto closed, controlled).\n         // 6. Language prelude (closed, controlled).\n         // (Macro NS)\n+        // 0. Derive helpers (open, not controlled). All ambiguities with other names\n+        //    are currently reported as errors. They should be higher in priority than preludes\n+        //    and probably even names in modules according to the \"general principles\" above. They\n+        //    also should be subject to restricted shadowing because are effectively produced by\n+        //    derives (you need to resolve the derive first to add helpers into scope), but they\n+        //    should be available before the derive is expanded for compatibility.\n+        //    It's mess in general, so we are being conservative for now.\n         // 1. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled).\n         // 2. `macro_use` prelude (open, the open part is from macro expansions, not controlled).\n@@ -583,13 +590,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         // 2b. Standard library prelude is currently implemented as `macro-use` (closed, controlled)\n         // 3. Language prelude: builtin macros (closed, controlled, except for legacy plugins).\n         // 4. Language prelude: builtin attributes (closed, controlled).\n-        // N (unordered). Derive helpers (open, not controlled). All ambiguities with other names\n-        //    are currently reported as errors. They should be higher in priority than preludes\n-        //    and maybe even names in modules according to the \"general principles\" above. They\n-        //    also should be subject to restricted shadowing because are effectively produced by\n-        //    derives (you need to resolve the derive first to add helpers into scope), but they\n-        //    should be available before the derive is expanded for compatibility.\n-        //    It's mess in general, so we are being conservative for now.\n \n         assert!(ns == TypeNS  || ns == MacroNS);\n         assert!(force || !record_used); // `record_used` implies `force`\n@@ -621,7 +621,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         // Go through all the scopes and try to resolve the name.\n-        let mut where_to_resolve = WhereToResolve::Module(parent_scope.module);\n+        let mut where_to_resolve = WhereToResolve::DeriveHelpers;\n         let mut use_prelude = !parent_scope.module.no_implicit_prelude;\n         loop {\n             let result = match where_to_resolve {\n@@ -751,8 +751,8 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     }\n                     WhereToResolve::MacroUsePrelude => WhereToResolve::BuiltinMacros,\n                     WhereToResolve::BuiltinMacros => WhereToResolve::BuiltinAttrs,\n-                    WhereToResolve::BuiltinAttrs => WhereToResolve::DeriveHelpers,\n-                    WhereToResolve::DeriveHelpers => break, // nowhere else to search\n+                    WhereToResolve::BuiltinAttrs => break, // nowhere else to search\n+                    WhereToResolve::DeriveHelpers => WhereToResolve::Module(parent_scope.module),\n                     WhereToResolve::ExternPrelude => WhereToResolve::ToolPrelude,\n                     WhereToResolve::ToolPrelude => WhereToResolve::StdLibPrelude,\n                     WhereToResolve::StdLibPrelude => WhereToResolve::BuiltinTypes,"}, {"sha": "0b56692bc2e75731547b15a1645c7a36625bbd98", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -1991,8 +1991,11 @@\n                 }\n         };\n         if (getCurrentValue('rustdoc-trait-implementations') !== \"false\") {\n-            onEach(document.getElementById('implementations-list')\n-                           .getElementsByClassName(\"collapse-toggle\"), collapser);\n+            var impl_list = document.getElementById('implementations-list');\n+\n+            if (impl_list !== null) {\n+                onEach(impl_list.getElementsByClassName(\"collapse-toggle\"), collapser);\n+            }\n         }\n         if (getCurrentValue('rustdoc-method-docs') !== \"false\") {\n             var implItems = document.getElementsByClassName('impl-items');"}, {"sha": "ee811f3379239d4b560a9472f5c18477108be92e", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -139,7 +139,7 @@ code, pre {\n }\n .docblock code, .docblock-short code {\n \tborder-radius: 3px;\n-\tpadding: 0 0.2em;\n+\tpadding: 0 0.1em;\n }\n .docblock pre code, .docblock-short pre code, .docblock code.spotlight {\n \tpadding: 0;"}, {"sha": "8d54728a75f42ff3e93918feeda1bf9c596e00c3", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -208,7 +208,7 @@ mod prim_bool { }\n /// # `!` and traits\n ///\n /// When writing your own traits, `!` should have an `impl` whenever there is an obvious `impl`\n-/// which doesn't `panic!`. As is turns out, most traits can have an `impl` for `!`. Take [`Debug`]\n+/// which doesn't `panic!`. As it turns out, most traits can have an `impl` for `!`. Take [`Debug`]\n /// for example:\n ///\n /// ```\n@@ -228,9 +228,9 @@ mod prim_bool { }\n /// [`fmt::Result`]. Since this method takes a `&!` as an argument we know that it can never be\n /// called (because there is no value of type `!` for it to be called with). Writing `*self`\n /// essentially tells the compiler \"We know that this code can never be run, so just treat the\n-/// entire function body has having type [`fmt::Result`]\". This pattern can be used a lot when\n+/// entire function body as having type [`fmt::Result`]\". This pattern can be used a lot when\n /// implementing traits for `!`. Generally, any trait which only has methods which take a `self`\n-/// parameter should have such as impl.\n+/// parameter should have such an impl.\n ///\n /// On the other hand, one trait which would not be appropriate to implement is [`Default`]:\n ///"}, {"sha": "f6383c19cb5e6dc61bc2f96881b59c1b710aeb4d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -45,9 +45,17 @@\n extern crate getopts;\n #[cfg(any(unix, target_os = \"cloudabi\"))]\n extern crate libc;\n-extern crate panic_unwind;\n extern crate term;\n \n+// FIXME(#54291): rustc and/or LLVM don't yet support building with panic-unwind\n+//                on aarch64-pc-windows-msvc, so we don't link libtest against\n+//                libunwind (for the time being), even though it means that\n+//                libtest won't be fully functional on this platform.\n+//\n+// See also: https://github.com/rust-lang/rust/issues/54190#issuecomment-422904437\n+#[cfg(not(all(windows, target_arch = \"aarch64\")))]\n+extern crate panic_unwind;\n+\n pub use self::TestFn::*;\n pub use self::ColorConfig::*;\n pub use self::TestResult::*;"}, {"sha": "d0aed8b1624867c721de0dd544be438ee6ff68f5", "filename": "src/test/compile-fail-fulldeps/proc-macro/proc-macro-attributes.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fproc-macro-attributes.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -11,13 +11,11 @@\n // aux-build:derive-b.rs\n // ignore-stage1\n \n-#![allow(warnings)]\n-\n #[macro_use]\n extern crate derive_b;\n \n-#[B] //~ ERROR `B` is a derive mode\n-#[C]\n+#[B]\n+#[C] //~ ERROR attribute `C` is currently unknown to the compiler\n #[B(D)]\n #[B(E = \"foo\")]\n #[B(arbitrary tokens)]"}, {"sha": "124bc05b7a348cff354af2bdc772ee054efa4b69", "filename": "src/test/ui-fulldeps/custom-derive/auxiliary/plugin.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fauxiliary%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fauxiliary%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fauxiliary%2Fplugin.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -25,3 +25,13 @@ pub fn derive_foo(input: TokenStream) -> TokenStream {\n pub fn derive_bar(input: TokenStream) -> TokenStream {\n     panic!(\"lolnope\");\n }\n+\n+#[proc_macro_derive(WithHelper, attributes(helper))]\n+pub fn with_helper(input: TokenStream) -> TokenStream {\n+    TokenStream::new()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn helper(_: TokenStream, input: TokenStream) -> TokenStream {\n+    input\n+}"}, {"sha": "b750a8bb0d932d5880064ed43ee19b4b4aec747e", "filename": "src/test/ui-fulldeps/custom-derive/helper-attr-blocked-by-import-ambig.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -0,0 +1,13 @@\n+// aux-build:plugin.rs\n+// ignore-stage1\n+\n+#[macro_use(WithHelper)]\n+extern crate plugin;\n+\n+use plugin::helper;\n+\n+#[derive(WithHelper)]\n+#[helper] //~ ERROR `helper` is ambiguous\n+struct S;\n+\n+fn main() {}"}, {"sha": "059629c0b62d5ad17b33ef6c015381d01cea313e", "filename": "src/test/ui-fulldeps/custom-derive/helper-attr-blocked-by-import-ambig.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import-ambig.stderr?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -0,0 +1,20 @@\n+error[E0659]: `helper` is ambiguous\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:10:3\n+   |\n+LL | #[helper] //~ ERROR `helper` is ambiguous\n+   |   ^^^^^^ ambiguous name\n+   |\n+note: `helper` could refer to the name defined here\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:9:10\n+   |\n+LL | #[derive(WithHelper)]\n+   |          ^^^^^^^^^^\n+note: `helper` could also refer to the name imported here\n+  --> $DIR/helper-attr-blocked-by-import-ambig.rs:7:5\n+   |\n+LL | use plugin::helper;\n+   |     ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "03b774f6c64002ac2c73b328d3d4b1b45648866f", "filename": "src/test/ui-fulldeps/custom-derive/helper-attr-blocked-by-import.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fhelper-attr-blocked-by-import.rs?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -0,0 +1,29 @@\n+// compile-pass\n+// aux-build:plugin.rs\n+// ignore-stage1\n+\n+#[macro_use(WithHelper)]\n+extern crate plugin;\n+\n+use self::one::*;\n+use self::two::*;\n+\n+mod helper {}\n+\n+mod one {\n+    use helper;\n+\n+    #[derive(WithHelper)]\n+    #[helper]\n+    struct One;\n+}\n+\n+mod two {\n+    use helper;\n+\n+    #[derive(WithHelper)]\n+    #[helper]\n+    struct Two;\n+}\n+\n+fn main() {}"}, {"sha": "e0aeae4ba6c54ffa2202bccc166f042d061c3c91", "filename": "src/test/ui-fulldeps/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92aff72a0503baa6cf0448555f649957de802b03/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=92aff72a0503baa6cf0448555f649957de802b03", "patch": "@@ -4,17 +4,16 @@ error[E0659]: `my_attr` is ambiguous\n LL | #[my_attr] //~ ERROR `my_attr` is ambiguous\n    |   ^^^^^^^ ambiguous name\n    |\n-note: `my_attr` could refer to the name imported here\n-  --> $DIR/derive-helper-shadowing.rs:4:5\n-   |\n-LL | use derive_helper_shadowing::*;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `my_attr` could also refer to the name defined here\n+note: `my_attr` could refer to the name defined here\n   --> $DIR/derive-helper-shadowing.rs:7:10\n    |\n LL | #[derive(MyTrait)]\n    |          ^^^^^^^\n-   = note: consider adding an explicit import of `my_attr` to disambiguate\n+note: `my_attr` could also refer to the name imported here\n+  --> $DIR/derive-helper-shadowing.rs:4:5\n+   |\n+LL | use derive_helper_shadowing::*;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}]}